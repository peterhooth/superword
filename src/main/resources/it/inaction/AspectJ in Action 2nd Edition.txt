One of the clearest expositions of AOP and its benefits that I have seen....
It is obvious that a lot of care and attention has gone into the preparation of the material.
I would highly recommend AspectJ in Action to anyone who is interested in AOP....
I liked the practical angle, and you could tell that Ramnivas has really used AOP/ AspectJ on his projects.
Laddad brings to the professional community a valuable book, to support AOP tutoring and adoption...a well-constructed, well-balanced book that delivers what it promises.
It’s a must-read for anyone interested in the future of programming.
This book is to aspect-oriented programming what the Gang of Four book is to design patterns.
The author succeeds brilliantly in gradually building your understanding of AOP, then AspectJ’s own semantics, and then the coding possibilities these offer…
The writing is clear and accessible, the content expertly graduated.
Like the other books in the “In Action” series from Manning, it is filled with very good diagrams....
The subject-oriented approach in this book lends itself well to future reuse.
I found the book to really be excellent from all viewpoints for getting into the subject matter from many angles and diving down very deep into it.
This book provides a very good resource both for people starting to learn AOP and AspectJ and for experienced AOP programmers who wish to deepen their knowledge in this new area.
The only resource that presents AOP concepts and real-world examples in an approachable, readable way.
The publisher offers discounts on this book when ordered in quantity.
No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by means electronic, mechanical, photocopying, or otherwise, without prior written permission of the publisher.
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in the book, and Manning Publications was aware of a trademark claim, the designations have been printed in initial caps or all caps.
Recognizing the importance of preserving what has been written, it is Manning’s policy to have the books we publish printed on acid-free paper, and we exert our best efforts to that end.
Recognizing also our responsibility to conserve the resources of our planet, Manning books are printed on paper that is at least 15% recycled and processed without the use of elemental chlorine.
Since the first edition of AspectJ in Action, much has changed in AspectJ and the broader environment.
Among the changes, three issues stand out: important new capabilities of AspectJ, increasing interest in dynamic languages in general and on the JVM, and the emergence of AspectJ as a key practical technology in mainstream enterprise Java.
It now has comprehensive support for Java annotations, along with support for other language improvements such as generics, variable-length argument lists, and covariant return types.
Annotations fit hand in glove with AOP, providing an ideal way of adding information about program structure and semantics for use by aspects.
These language enhancements not only simplify the authoring of many aspects—they also make AspectJ an ideal match for modern enterprise Java programming models, and truly a new language.
The last few years has seen a significant rise in interest in dynamic languages—many of which (such as Groovy) provide capabilities for metaprogramming.
Although this is a welcome change, it has caused some confusion regarding the role of AOP.
Metaprogramming can solve some of the problems solved by AOP, but it doesn’t directly offer the ability to exploit program structure in a complementary way to OOP that is core to.
This book will help you understand which approach is appropriate to your everyday problems and how you can use them together.
Another important change since the first edition of this book is the rise of modern frameworks, which constitutes a huge validation of AOP.
Today, the Spring Framework has become the most popular component model for enterprise Java.
Indeed, all modern enterprise Java technologies follow Spring’s approach of providing enterprise services with minimal infrastructure API calls in user code.
Furthermore, Spring 2.0 made the important architectural decision to adopt the AspectJ pointcut expression language—the heart of AspectJ—and a subset of the AspectJ annotation programming model as its preferred AOP programming model—another validation, which exposes more developers to the benefits of AspectJ.
As a result, AspectJ works hand in hand with Spring and is particularly relevant to solving enterprise Java problems.
Ramnivas has embraced this synergy in this book: he explains clearly how you can benefit from AspectJ concepts if you’re already using Spring, and how AspectJ the language is a natural extension of the AOP concepts supported by Spring.
Readers who aren’t using Spring will still benefit from the valuable case studies and examples the Spring AOP experience provides.
Programming languages are only as valuable as their practical usage potential, as history repeatedly shows.
In the case of AspectJ, there has recently been a huge step forward in this regard.
Improvements to the Eclipse AspectJ plugin (AJDT) have resulted in dramatic performance and stability improvements, making AspectJ easier for less experienced developers to use.
Meanwhile, the new Spring Roo project (http://www.springsource.org/roo) makes innovative use of AspectJ in greatly simplifying the authoring of enterprise Java applications.
Not only is this a further validation of AspectJ, but it also promises to make the full power of AspectJ available in a large number of applications without developers needing to make an explicit choice to adopt AspectJ.
Together, these advances remove a key practical barrier to adopting AspectJ.
The remaining barrier to adoption is the effort in learning AOP and AspectJ concepts—an effort well worth making.
Learning AspectJ is like learning to type: it requires the investment of some time up front to be able to reap ongoing rewards in productivity.
This book will make that effort as easy and as pleasurable as possible.
As you learn about AOP and AspectJ, I highly recommend Ramnivas Laddad as your guide.
A long-term advocate of AOP, Ramnivas is outstandingly knowledgeable about his subject.
Even more important, he deeply understands how it fits into a broader context.
This experience stands out in the relevance and value of the examples and in the fact that the book is well balanced.
Ramnivas isn’t a mere cheerleader, and he provides excellent discussion of alternatives to AOP that will help you make the right architectural choices.
Finally, this book, like the previous edition, is a pleasure to read.
Clear, concisely worded, and well organized, it will make your navigation of AspectJ and AOP concepts easy.
I wish you great success with AspectJ and the Java platform, and I hope you enjoy reading this book as much as I have.
It felt like a breath of fresh air that finally addressed some of the shortcomings of object-oriented programming.
After writing the book, I gave talks at many conferences about facets of AOP and AspectJ, and how to use them with the Spring Framework commonly referred to as Spring.
Over the last few years, as a Spring committer, I have been trying to improve Spring-AspectJ integration.
While doing this, I have been actively using these technologies on many projects.
This book is a reflection of my experience with the technologies, understanding the best ways to explain them, and finding pragmatic ways to adopt them.
A lot has changed since the publication of the first edition of this book.
AspectJ was a new language, Spring had just come out, and alternative languages on the Java platform were far fewer.
Now, AspectJ is a 10-year-old language, Spring is the de facto lightweight framework for developing enterprise software, and new languages on the Java platforms are numerous.
As a result, our search for better ways to reduce implementation complexity also remains unchanged.
These factors make AOP implemented using AspectJ an important tool in an enterprise Java developer’s toolbox.
It now includes two syntax possibilities: the traditional syntax and the annotation-based @AspectJ syntax, which lowers the barrier to begin using AspectJ.
It supports many weaving possibilities, including load-time weaving, making the use of AspectJ for applications such as monitoring and tracing a simple experience.
To top it off, Spring has adopted AspectJ’s programming model as its AOP solution.
This caused the Spring community to be drawn to the power of AOP with AspectJ as the preferred programming model.
Due to the complexity involved on the compiler and tools front, projects such as AspectJ require serious attention.
Fulltime development afforded by SpringSource support has been crucial in recent years.
And so, it was time to write a new edition of AspectJ in Action.
My initial thought was that I would update most chapters with new AspectJ features and update a few examples.
Boy, was my estimate off the mark! It took more than three years to update and re-update the book.
There were many reasons (besides being busy at my day job)
Through my consulting experience, my understanding of the problems that AOP is trying to solve and its adoption in the real world changed, as well.
Therefore, many examples from the first edition wouldn’t work any more, even if I gave them a facelift.
Like the first edition, I wanted this book to be of immediate practical value.
Therefore, I decided to rewrite many of the chapters and most of the examples.
I humbly hope that you’ll appreciate my effort, like this book, and use it in your applications.
It is difficult to map requirements to the implementation and then trace the implementation back to the requirements.
Although many approaches—such as object-oriented programming, component-oriented programming, and design patterns—help to some extent, none of them satisfactorily addresses the system-level requirements, often referred to as crosscutting concerns, that must be included in multiple modules.
AspectJ was an implementation of aspect-oriented programming (AOP), a new methodology that specifically targeted the management of crosscutting concerns.
Even though AspectJ was in its infancy, I became fascinated by its potential.
The struggle to keep up with all the new advances in the Java and XML world, along xxv.
Still, exploring AspectJ was always on my to-do list, and I started looking at it again when it was in version 0.8
By then, AspectJ had evolved into a much more powerful language.
I started using AspectJ and found that the more I used it, the more I fell in love with it.
Today, the current version of AspectJ (1.1)—which this book is based on—has morphed into a mature, robust language.
In early 2002, I wrote a series of articles for JavaWorld describing AOP and AspectJ; the book you are holding grew out of that series.
From reader responses, I realized that most developers understand that AspectJ can be used to modularize the crosscutting concern of logging, but they struggle to imagine how it may be applied beyond.
Logging, while an important concern, is not something developers lose sleep over.
Logging using AspectJ, therefore, is best characterized as a vitamin and not a painkiller; while vitamins are important, often the need for them is not pressing enough to require immediate action.
To further complicate the situation, the examples of AOP that are widely available today either repeat the same logging problem or are too abstract to be of immediate practical value.
My mission statement for this book is “to be a key element in bringing AOP and AspectJ into everyday practice.” To accomplish this goal, the book not only presents the AspectJ language but also provides practical AspectJ-based solutions to a wide variety of real-world problems.
You will find that you can utilize these solutions to quickly reap the benefits of the language.
I have tried to use current technologies as the basis for these solutions so that you can readily apply them to your system.
This also demonstrates that these latest technologies by themselves are not enough to manage crosscutting concerns, since combined with AspectJ, they provide a better solution.
The book also presents a few original design patterns that increase the power of AspectJ significantly.
It is not often that one gets to write about such an exciting new programming methodology and language.
I’m humbled by all the support I’ve received in making this book a reality.
Special thanks to Andy and Andrew for meticulously reviewing the manuscript, making many helpful suggestions, and catching subtle issues.
Also thanks to past AspectJ teams—without you there would be no AspectJ.
Many thanks to Manning’s publisher, Marjan Bace, for his commitment to making this a quality book.
I’d like to thank Mary Piergies for managing the production and Tiffany Taylor for doing such an outstanding job at copyediting, making my writing look much better.
Also thanks to Maureen Spencer for weeding out errors durxxvii.
My sincerest thanks to Dean Wampler and Colin Yates for reviewing the manuscript with a keen and critical eye; without your reviews, the book wouldn’t be as accessible.
Thanks to Luke Taylor for reviewing the book, especially security related material.
I am honored to be able to call you my friends.
Thanks to the official reviewers, who provided extremely useful feedback that also led to many improvements: Doug Warren (who served as the technical proofreader as well), Ara Abrahamian, Madhav Ayyagari, Paul Benedict, Thomas Darimont, Dab.
Also thanks to many Author Forum readers who took time to review the Early Access chapters and notified me about bugs as well as offering suggestions for improvement.
I’d like to send a big thank-you to all my colleagues at SpringSource for their support and encouragement.
Special thanks to Rod Johnson for writing the foreword and rooting for AOP and AspectJ.
Finally, I’d like to thank my family for their help and support.
A special thanks goes to my wife, Kavita, who reviewed the manuscript, tried out multiple versions of code, and helped with the illustrations for the book—never complaining about my many broken promises to spend more time with her.
Thanks also to my son Shadaj, a budding computer scientist, for accepting the sacrifice that comes with having a busy dad.
Now that the book is complete, I promise to work with you on all the projects we’ve thought of.
Although the book focuses on practical applications, it doesn’t skimp on concepts in AOP and constructs in AspectJ.
I cover a broad spectrum of solutions—from simple examples that address tracing, monitoring, and policy enforcement to complex ones dealing with caching, concurrency control, transactions, and security.
The book also covers how AOP helps improve domain-logic implementation.
To make this book immediately useful and provide a practical context of enterprise applications, I use:
Regardless of your area of expertise, you’ll find examples that you can use in your work immediately.
Roadmap This book is divided into two parts plus three appendices.
It introduces the problems that aspect-oriented programming aims to address, discusses how current techniques fall short, and explains how AOP handles them.
It presents the core concepts of AOP such as the join point model, pointcuts, and advice.
It also presents a generic model of AOP to help distinguish it from similar technologies.
We’ll discuss various language concepts and constructs, weaving choices, and Spring integration.
We’ll finish the chapter by showing the IDE support for AspectJ.
Chapter 3 gets into the details of the AspectJ language by closely examining its join point model.
It introduces the pointcut expression language along with many examples.
This chapter should serve as a handy reference for you.
Chapter 4 focuses on dynamic crosscutting that lets you modify the behavior of the system.
In this chapter, you’ll begin to implement aspects to deal with fault tolerance and caching functionality.
This chapter provides you with enough information to start writing simple AspectJ programs.
Chapter 5 focuses on static crosscutting that you can use to modify the structure of the system.
It examines mechanisms such as inter-type declarations, weave-time errors and warning declarations, and exception softening.
It also shows a few examples of AspectJ that you can begin using immediately.
Chapter 6 discusses the unit of modularization in AspectJ: the aspect.
Specifically, we’ll add automated tests to verify its functionality and expose the aspect over JMX.
In this chapter, we’ll map the traditional syntax to the @AspectJ syntax, which is useful with both byte-code-based weaving and Spring’s proxy-based implementation.
We’ll complete this chapter by discussing how you choose between the traditional and the @Aspect syntax.
We’ll also show an example that adds monitoring to a web application using load-time weaving.
We’ll discuss using the @AspectJ syntax while avoiding the use of the byte-code-based weaver.
We’ll dive into how Spring’s dependency injection mechanism works in synergy with proxy-based AOP.
We’ll also discuss a Spring-based variation of load-time weaving along with a complete example.
Make no mistake: these aren’t toy aspects, and by the end of this chapter you should be able use aspects in your own project and reap immediate benefits.
Chapter 11 continues the journey of exploring another set of aspects that developers use during their initial exploration of AOP: policy enforcement.
In this chapter, we’ll discuss how policy-enforcement aspects can help keep your design intact.
We’ll include a wide range of examples: layered architecture, mixing of JDBC with JPA, Swing, and EJB.
Chapter 12 presents a set of design patterns that have been found to be useful in practice and that we’ll use in the chapters that follow.
We’ll present the worker object pattern, the wormhole pattern, the participant pattern, and its variation—the annotationdriven participant pattern.
Chapter 13 applies some of the patterns presented in the previous chapter to a complex crosscutting concern of concurrency control.
We’ll implement aspects that modularize concurrency control for Swing-based applications.
Chapter 14 discusses one of the most commonly required crosscutting concern in enterprise applications: transaction management.
We’ll implement several aspects based on the abstraction offered by Spring.
We’ll also develop a fault-tolerance scheme that works particularly well with transaction managed operations.
Chapter 15 explains the modularization of another crosscutting concern: security.
We’ll implement aspects based on abstraction offered by Spring Security.
Chapter 16 introduces how AOP can help you better implement domain logic.
We’ll discuss how AspectJ can extend dependency injection concepts to domain objects and how to use this possibility of implementing rich behavior in domain objects.
We’ll also examine improving business logic through aspects, refactoring using aspects, and implementing certain domain-driven design policies using aspects.
Chapter 17 rounds out the book by showing a pragmatic approach to adopting AOP.
The first of the three appendixes presents an e-commerce example that is used in.
The remaining appendixes explain how to use AspectJ with Ant and Maven.
Who should read this book AspectJ in Action, Second Edition is aimed at intermediate to advanced Java developers.
Whether you develop enterprise applications or architect complex software systems, you’ll find this book enjoyable and helpful.
If you’re developing applications using the Spring Framework, you’ll find most of the code developed in this book of immediate value.
But even if you aren’t using Spring, you’ll be able to modify the code to any other framework you may be using.
The book focuses heavily on Spring-based applications, but it also includes examples of other technologies such as Swing and EJB.
Basic knowledge of the Spring Framework will help you get the most out of this book.
If you aren’t familiar with the Spring Framework, you may want to read a few of the many online resources to gain some familiarity.
For some of the specific technologies, such as transaction management in Spring and Spring Security, the book presents a short introduction so that you can understand the aspects without needing another source.
I also cite resources (both text and online) for those who want to gain in-depth understanding.
Code and typographical conventions To keep the code short, we don’t show most import statements in Java and AspectJ source code, except in chapter 2 and where import statements improve clarity of the code.
Similarly, we don’t show the namespace and schema declarations in most XML source code.
Much of the source code is reusable either in its original state or after some customization.
The downloadable package contains the source code, instructions on how to set up the environment, and build scripts that automate compiling and running the programs.
The source code is organized to promote experimentation, where you can modify code for any of the projects without affecting others.
All of the technologies used in this book are being steadily updated.
But I’ll update source code with significant releases of the technologies used—especially if those break the code.
Author online The purchase of AspectJ in Action, Second Edition includes free access to a private web forum run by Manning Publications, where you can make comments about the book, ask technical questions, and receive help from the author and from other users.
This page provides information on how to get on the forum once you are registered, what kind of help is available, and the rules of conduct on the forum.
It is not a commitment to any specific amount of participation on the part of the author, whose contribution to the AO remains voluntary (and unpaid)
We suggest you try asking the author some challenging questions lest his interest stray!
The Author Online forum and the archives of previous discussions will be accessible from the publisher’s web site as long as the book is in print.
About the author RAMNIVAS LADDAD is a well-known expert in enterprise Java, especially in the area of AOP and Spring.
He is the author of the first edition of AspectJ in Action, the bestselling book on AOP and AspectJ that has been lauded by industry experts for its presentation of practical and innovative AOP applications to solve real-world problems.
Ramnivas, a Spring Framework committer, is also a very active presenter at leading industry events and has been an active member of both the AspectJ and Spring communities from their beginnings.
He has worked with a wide range of systems, especially dealing with complex and mission-critical applications, in various roles.
Ramnivas shares his thoughts on http://ramnivas.com/blog, and you can follow him on Twitter at http://twitter.com/ramnivas.
According to research in cognitive science the things people remember are things they discover during self-motivated exploration.
Although no one at Manning is a cognitive scientist, we are convinced that for learning to become permanent it must pass through stages of exploration, play, and, interestingly, retelling of what is being learned.
People understand and remember new things, which is to say they master them, only after actively exploring them.
An essential part of an In Action guide is that it is example-driven.
It encourages the reader to try things out, to play with new code, and explore new ideas.
There is another, more mundane, reason for the title of this book: our readers are busy.
They use books to do a job or solve a problem.
They need books that allow them to jump in and jump out easily and learn just what they want just when they want it.
The books in this series are designed for such readers.
General collection of costumes currently used in the nations of the known world, xxxv.
This work is very useful especially for those who hold themselves to be universal travelers.
Although nothing is known of the designers, engravers, and workers who colored this illustration by hand, the “exactitude” of their execution is evident in this drawing.
The “Ysleno Moluco” is just one of many figures in this colorful collection.
Their diversity speaks vividly of the uniqueness and individuality of the world’s towns and regions just 200 years ago.
This was a time when the dress codes of two regions separated by a few dozen miles identified people uniquely as belonging to one or the other.
The collection brings to life a sense of isolation and distance of that period—and of every other historic period except our own hyperkinetic present.
It is now often hard to tell the inhabitant of one continent from another.
Perhaps, trying to view it optimistically, we have traded a cultural and visual diversity for a more varied personal life.
Or a more varied and interesting intellectual and technical life.
We at Manning celebrate the inventiveness, the initiative, and the fun of the computer business with book covers based on the rich diversity of regional life of two centuries ago? brought back to life by the pictures from this collection.
We’ll start with AOP in the context of the typical hype cycle.
This will give us a historical perspective on AOP evolution and indicate what lies ahead.
We also look at the landscape, focusing on the current situation and changes since the first edition of this book.
While AOP is a more general concept, because our focus is the real world use of it, we’ll focus on AspectJ—its most prominent implementation.
Mapping AOP onto the hype cycle Every technology goes through a cycle that’s well illustrated by the Gartner Hype Cycle (http://en.wikipedia.org/wiki/Hype_cycle)
It allows you to offer a more accurate gauge of the benefits the technology is likely to offer and the risk you expose yourself to.
In this section, I’ll give my assessment of the hype cycle of AOP in five major phases: technology trigger, peak of inflated expectations, trough of disillusionment, slope of enlightenment, and plateau of productivity.
The following figure depicts the hype cycle and how AOP maps to it.
A REAL-WORLD PERSPECTIVE OF AOPxxxviii Let’s look at each of the major phases in the figure.
In this phase, a new technology appears on the horizon with a promise to solve a set of problems.
It may be an announcement of a new product or an actual release of a product.
Either way, it may generate some buzz and attract developers towards it.
Gregor Kiczales and his team, while working at Xerox Palo Alto Research Center (PARC), developed the AOP concepts backed by the AspectJ language.
Many technologists could immediately understand the potential for AspectJ, especially for enterprise applications.
For many technologies, especially with substantially new ideas and potential to solve complex problems, the next phase follows.
In this phase, the technology gains much hype (warranted or otherwise)
Everyone wants to know about it, everyone has an opinion of it, but few people use it in real applications.
A few adventurous (or reckless) developers (or early adopters) try it.
If the technology fits the problem well, and you have good understanding of it, adopting technology during this phase can give you a competitive advantage.
It’s fascinating to be associated with a technology in this phase.
Many smaller companies and a few larger ones used AspectJ in a few projects.
During this time, most developers working on AspectJ and AspectJ Development Tools (AJDT) were from IBM.
This significant investment from IBM helped AspectJ gain solid footing.
But the lack of mass adoption made using the technology an adventure.
Fortunately for AspectJ the peak wasn’t high due to expectation management by AspectJ evangelists.
After passing through various stages, currently AOP is on the slope of enlightenment.
In this phase, the technology starts to lose the attention it once received.
In this phase, many early adopters continue to use the technology creatively to gain a competitive advantage.
Others begin to look at it with a skeptical eye.
The technology sees serious and innovative competition from newer solutions that address part of the same problem space.
Interestingly, many of these competing technologies are going through the “peak of inflated expectation” phase.
On one extreme, these new technologies can drive the existing one into oblivion (which isn’t necessarily a bad thing—if the technology couldn’t take on a competition, oblivion is a respectful resting place)
On the other side, competition can shake the technology and force it to innovate further.
Although the core AJDT committers kept developing the technology, much more dedicated effort was needed.
Furthermore, many users perceived the adoption of AspectJ as a big step due to the requirement of using a brand-new syntax and the need to use a special compiler at the beginning of a project.
Eclipse, the main supported IDE for AspectJ, was advancing at a rapid pace, leaving a large gap between its Java support and AspectJ support.
Through a frameworkcentric approach, you could implement crosscutting functionality such as transaction management and security in a modular fashion.
More serious competition came from dynamic languages such as Ruby and Groovy and associated frameworks such as Rails and Grails.
The metaprogramming model available in these technologies provided an alternative solution to modularize crosscutting concerns.
On the tooling side, all new languages suffer from the lack of maturity (although most new language proponents would argue otherwise)
I still remember using Emacs with Java for several years after disappointing experiences with many IDEs.
But this didn’t cause us early Java adopters to discard the language for the lack of tools.
A judicious decision requires that you weigh the benefits of the language against the handicaps introduced by immature or nonexisting tools.
For AspectJ, the tools side—especially IDEs—has been a weakness, especially if you expected its support to match that of Java.
AspectJ took on all these challenges to enter the next—and most useful—phase.
This phase results from multiple factors such as changes in the technology to meet real-world requirements, maturing of the technology due to sustained field testing, finding the right context for the technology to make an impact, and disillusionment about other technologies once considered as alternatives.
The technology also starts to be used to solve problems in the context of focused application areas.
The slope of enlightenment started for AOP right after its trough.
Soon, I joined SpringSource, and I’ve been contributing to Spring AspectJ integration as a committer.
Currently, AspectJ is a SpringSource portfolio project and enjoys its sponsorship.
All these factors helped bring together Spring and AspectJ and afford sustained development.
During my consulting engagements, I see signs of AspectJ being in this phase.
Developers no longer fear it for its perceived complexity but rather show curiosity about exploring the benefits it offers and eagerly want to use AspectJ.
Let’s look at the underlying factors that caused AspectJ to enter this phase.
The promise of good tooling—especially the possibility of visualizing the interaction between aspects and classes—has been an important differentiator from similar technologies (such as metaprogramming)
Although AspectJ’s support for Eclipse has always been reasonable, it was never as good as that for Java.
Part of the problem was fast innovation in the underlying Eclipse JDT, which kept raising user expectations.
Furthermore, compilation speed and memory requirement have been less than optimal.
Overall, there was a gap between potential and reality when it came to tooling.
Lately, the AspectJ and AJDT teams have performed some amazing feats in optimizing the compilation process and IDE integration.
The changes in the latest AJDT, where the JDT is woven with AspectJ functionality (using AspectJ itself) make development within Eclipse a pleasant and productive experience.
With all these changes, any issues with tooling are a thing of past.
Although proxy-based AOP lowered the adoption barrier compared to AspectJ’s byte-code based AOP, Spring’s programming model wasn’t inviting.
As a result, most developers limited themselves to the aspects shipped as part of Spring and other frameworks.
Spring responded by adopting the AspectJ programming model with a proxy-based implementation.
This new possibility lets you use a subset of the AspectJ syntax without the need for a special compiler or weaver.
This significantly reduced the barrier to writing custom aspects to meet the specific needs of an application.
Here, too, annotation-based pointcuts helped remove whatever was left of the barrier to its adoption.
Currently, Spring considers AspectJ to be its preferred programming model and has relegated the old model to a transitionary technology status.
Spring’s adoption of AspectJ also provided AspectJ a much needed context to grow.
It has been used in real-time programming, UI programming, and server-side programming.
As a result, there has been a dissipated effort to make AOP a mainstream technology.
It provided the right context—enterprise applications—for AOP to gain prominence.
By using an elegant programming model offered by AspectJ, it paved the way for mass adoption.
The adoption of a new technology, especially with significantly new concepts such as AOP, is never easy.
You need a path that allows a gradual introduction of the technology.
Before AspectJ 5 and Spring AOP, the adoption path for AOP was steep.
Spring’s proxy-based AOP with AspectJ syntax is a great way to start with AOP.
Spring even provides a few pre-built aspects to get you started.
During this phase, you can start writing simple aspects based on the @AspectJ syntax applied using proxy-based AOP.
Later, you can use byte-code-based weaving along with or as a replacement for the proxy-based AOP.
Here, you can have several smaller steps available to manage risk.
Initially, you can use aspects such as tracing and monitoring for development.
Because you don’t need to commit to using these aspects in production, there is little risk in trying them.
With these aspects, load-time weaving is a great help; you don’t need to modify your build system or use a special IDE, making the addition of aspects a much simpler task.
You can get feedback provided by the aspects about any policy violations while remaining uncommitted to their.
In this phase, you can start using AJDT for immediate feedback right inside the IDE.
By this stage, you should be comfortable with the patterns and practices of AOP.
This is the point at which you can make a judicious decision based on real experience.
In the last few years, practitioners have distinguished between Java the platform and Java the language.
There is a growing recognition that Java the language isn’t sufficient for productivity even considering the vast number of tools available for it.
You need to choose some other language to gain a competitive advantage.
At the same time, there is growing faith in the other part of Java the platform.
With all the innovations in the VM as well as the overall platform (OSGi, mature libraries, IDEs), it’s compelling to use the Java platform for many projects.
Combining these factors has led to innovative new languages such as Groovy, JRuby, Scala, and Clojure on the Java platform.
Today, it’s not a shock to hear of a project using one of these new languages.
As a result, the fear of new languages has gone down substantially.
The use of multiple languages within the same project is also common.
One of the negatives of AspectJ—that it’s a new language—is no longer the case.
Even on the methodology front, there is a growing sense that OOP may have run its course.
We need to use OOP with something else: metaprogramming, functional programming, or, as I’ll explain in this book, aspect-oriented programming.
Furthermore, you may use several additional methodologies along with OOP.
For example, you may use Java with Scala to take the functional approach along with AspectJ to deal with crosscutting concerns.
This Polyglot Programming (http://www.polyglotprogramming.com) approach uses multiple languages in the same application and is steadily gaining traction.
AspectJ may have to adopt its join point model, which exclusively targets the Java language, to fit into the polyglot programming scenario.
Selecting the required crosscutting points is one of the most critical and difficult tasks in writing aspects.
Relying only on naming convention, type hierarchy, and package structure takes you quite a way.
But in many case, defining a robust pointcut poses some difficulty.
With the introduction of annotations in Java 5, AspectJ provides an easy and transparent way to select the join points you want.
With annotations in play, aspect developers can expect class developers to mark program elements with annotations.
It makes both camps happy—aspect developers can write simple pointcuts that can select program elements based on annotations they carry.
On the other hand, class developers control the application of crosscutting functionality, because they choose what to annotate.
The EJB framework appeared to provide a solution to modularizing crosscutting concerns.
But most developers realize that the approach it offers is too heavyweight.
For example, EJB3 introduces interceptors as a new mechanism, a concept similar to AOP’s advice—a definite step in the right direction, but lacking the join point model, which lies at the core of AOP.
But even with Groovy and Ruby, AOP has a place.
Dynamic languages, despite the buzz surrounding them, are still new.
As these languages mature and are used more seriously in enterprise applications, I expect AOP to gain prominence.
After all, not many people thought anything was lacking in the Java programming language 10 years back! Interestingly, due to the availability of metaprogramming in dynamic languages, implementing AOP is easy.
This is a boring phase, where there is little hype.
The technology is no longer cool and on the leading or bleeding edge.
It starts to appear on resumes and job applications in a substantial way.
The technology fulfills its promise of improved productivity, and developers use it for the problems where it’s known to really work.
Although it’s boring to those who are looking for a shot of excitement, this phase is the most appropriate for mass adoption.
This phase often includes interesting innovations, but they aren’t a hallmark of the phase.
Instead, the focus is on best (and worst) practices based on real experience in the technology’s adoption and problem-specific premade solutions (libraries)
Where is AOP being used? We can address the question of how real AOP is by looking at where it’s being used.
Enterprise applications need to address many crosscutting functionalities: transaction management, security, auditing, service-level agreement, monitoring, concurrency control, improving application availability, error handling, and so on.
All the examples in this book are based on real-world problems and their AOP solutions.
Many applications start with prewritten aspects supplied with Spring (primarily transaction management and security)
But due to the @AspectJ syntax, writing custom aspects is becoming a common task.
After reaching the limits of Spring AOP, many applications move toward AspectJ weaving.
The typical trigger point for this change is crosscutting of domain objects or other forms of deeper crosscutting functionalities.
At that time, it’s common to start with the @AspectJ syntax (which is used with Spring’s proxy-based AOP) along with.
Of course, applications that don’t use Spring often use AspectJ weaving from the beginning.
The industry sectors in which AspectJ is used in production (with proxy-based and bytecode-based AOP) range from financial companies (banking, trading, hedge funds) and health care to various web sites (e-commerce, customer care, content providers, and so on)
If you’re implementing enterprise applications and using AOP, you’re in good company.
The open source SpringSource dm Server (http://www.springsource.com/products/ dmserver) supports developing enterprise application based on OSGi.
It uses AspectJ to implement various crosscutting functionalities, such as First Failure Data Capture (FFDC), context collection, tracing, and policy enforcement.
The SpringSource tc Server (http://www.springsource.com/products/tcserver) uses AspectJ to implement monitoring of deployed applications.
You can expect a lot more functionality to be implemented using AspectJ in both these products.
Application frameworks can use AOP effectively to target specific crosscutting functionalities while keeping their structure modularized.
As discussed earlier, Spring provides crosscutting solutions such as transaction management and security through aspects.
Furthermore, Spring includes aspects for injecting dependencies into domain objects.
Frameworks that use AspectJ as their foundation have started to appear as well.
A recently released Spring Roo (http://www.springsource.org/roo) is an opensource, lightweight, and customizable framework that includes interactive and IDEbased tooling to enable rapid delivery of high performance enterprise Java applications.
It uses a round-tripping code generator along with AspectJ byte-code weaving to keep generated code separate from user-written code.
By judiciously combining annotations with AspectJ’s static and dynamic crosscutting, it offers a significant boost in developer productivity without tying the application to Spring Roo.
Another AspectJ-based project—Magma (http://cwiki.apache.org/labs/magma.html)—is an Apache lab project that simplifies development of Java web applications.
It internally uses AspectJ and exposes it to power users to improve developer productivity and produce maintainable software.
Glassbox (http://www.glassbox.com), an open source product, offers ready-to-use aspects and tools to help you get started with application-level monitoring and pinpoint potential bottlenecks.
It also includes functionality such as alerting and trend analysis to let you take corrective actions.
JXInsight (http://www.jinspired.com/products/jxinsight) monitors applications to provide insight into potential performance bottlenecks.
MaintainJ (http://maintainj.com) uses aspects to monitor system execution and generates sequence diagrams.
AspectJ itself uses AspectJ to extend the JDT complier to support AspectJ constructs.
This recent change enabled AJDT to provide a much better user experience.
Scala IDE for Eclipse also followed the same route to provide a better experience for Scala developers.
I hope this discussion has helped put AOP and AspectJ in perspective.
Rather than being a niche product, AspectJ has long been considered a standard tool in the developer toolbox.
The rest of the book should give you a deeper understanding of what these technologies offer you.
Part 1 of this book introduces aspect-oriented programming (AOP), the AspectJ language, and how it integrates with Spring.
We’ll discuss the need for a new programming methodology and the way this methodology is realized in AspectJ.
Because AOP is a new methodology, we’ll devote the first chapter to introducing it: why it is needed, and what its core concepts are.
Chapter 2 shows the overall flavor of the AspectJ language through examples.
The next four chapters will delve deeper into the AspectJ syntax.
Together, these chapters should give you enough information to start writing simple code and see the benefits that AspectJ offers.
Given the mutual importance of Spring and AspectJ, this part of the book ends by devoting chapter 9 to Spring-AspectJ integration.
Along the way, we’ll examine many examples to reinforce the concepts learned.
You’ll find the material in part 1 useful as a reference while reading the rest of the book.
If you’re new to AOP and AspectJ, we strongly recommend that you read this part first.
What can a software developer do to manage complexity? If complexity is the problem, modularization is the solution.
When you’re faced with complex software requirements, you’re likely to break those into multiple parts such as business functionality, data access, and presentation logic.
We call each of these functionalities concerns of the system.
In a banking system, you may be concerned with customer management, account management, and loan management.
You may also have an implementation of data access and the web layer.
We call these core concerns because they form the core functionality of the system.
Other concerns, such as security, logging, resource pooling, caching, performance monitoring, concurrency control, and transaction Discovering AOP.
Reflect back on your last project, and compare it with a project you worked on a few years back.
Today’s software systems are complex, and all indications point to even faster growth in software complexity in.
For core concerns, object-oriented programming (OOP), the dominant methodology employed today, does a good job.
Instead, OOP forces you to fuse the implementation of these functionalities in many modules.
The core classes are no longer burdened with crosscutting concerns.
An aspect weaver composes the final system by combining the core classes and crosscutting aspects through a process called weaving.
Thus, AOP helps to create applications that are easier to design, implement, and maintain.
In this chapter, we’ll examine the fundamentals of AOP, the problems it addresses, and why you need to know about it.
In the rest of the book, we’ll examine AspectJ, which is a specific implementation of AOP.
Let’s start by discussing how you manage various concerns without AOP, which will help you understand why you need AOP.
How do you implement crosscutting concerns using OOP alone? Typically, you add the code needed for each crosscutting concern in each module, as shown in figure 1.1
This figure shows how different modules in a system implement both core concerns and crosscutting concerns.
Consider the skeleton implementation of a representative class that encapsulates some business logic in a conventional way, shown in listing 1.1
Security Figure 1.1 Viewing a system as a composition of multiple concerns.
Each implementation module deals with some element from each of the concerns the system needs to address.
Although the details will vary, the listing shows a common problem many developers face: a conceptual separation exists between multiple concerns at design time, but implementation tangles them together.
Such an implementation also breaks the Single Responsibility Principle (SRP)1 by making the class responsible for implementing core and crosscutting concerns.
If you need to change the invocation of the code related to crosscutting concerns, you must change each class that includes such an invocation.
Doing so breaks the Open/Close principle2—open for extension, but closed for modifications.
The overall consequence is a higher cost of implementing features and fixing bugs.
With conventional implementations, core and crosscutting concerns are tangled in each module.
The presence of code tangling and code scattering is a tell-tale sign of the conventional implementation of crosscutting concerns.3 Let’s examine them in detail.
Code tangling is caused when a module is implemented to handle multiple concerns simultaneously.
Developers often consider concerns such as business logic, performance, synchronization, logging, security, and so forth when implementing a module.
Obviously, you can fix such problems within the bounds of OOP.
But in OOP the problem of crosscutting concerns is present even in well-designed systems.
This leads to the simultaneous presence of elements from each concern’s implementation and results in code tangling.
Another way to look at code tangling is to use the notion of a multidimensional concern space.
Imagine that you’re projecting the application requirements onto a multidimensional concern space, with each concern forming a dimension.
Here, all the concerns are mutually independent and therefore can evolve without affecting the rest.
For example, changing the security requirement from one kind of authorization scheme to another shouldn’t affect the business logic.
But as you see in figure 1.3, a multidimensional concern space collapses into a one-dimensional implementation space.
Because the implementation space is one-dimensional, its focus is usually the implementation of the core concern that takes the role of the dominant dimension; other concerns then tangle the core concern.
Although you may naturally separate the individual requirements into mutually independent concerns during the design phase, OOP alone doesn’t let you retain the separation in the implementation phase.
We’ve looked at the first symptom of crosscutting concerns when implemented using traditional techniques; now, let’s move on to the next.
Figure 1.2 Code tangling caused by multiple simultaneous implementations of various concerns.
This figure shows how one module manages parts of multiple concerns.
Figure 1.3 Mapping the n-dimensional concern space using a one-dimensional language.
The orthogonality of concerns in the concern space is lost when it’s mapped to the one-dimensional implementation space.
Code scattering is caused when a single functionality is implemented in multiple modules.
Because crosscutting concerns, by definition, are spread over many modules, related implementations are also scattered over all those modules.
For example, in a system using a database, performance concerns may affect all the modules accessing the database.
Figure 1.4 shows how a banking system implements security using conventional techniques.
Even when using a well-designed security module that offers an abstract API and hides the details, each client—the accounting module, the ATM module, and the database module—still needs the code to invoke the security API to check permission.
The code for checking permission is scattered across multiple modules, and there is no single place to identify the concern.
The overall effect is an undesired tangling between the modules to be secured and the security module.
Code tangling and code scattering together impact software design and development in many ways: poor traceability, lower productivity, lower code reuse, poor quality, and difficult evolution.
All of these problems lead us to search for better approaches to architecture, design, and implementation.
Later in this chapter, we’ll examine alternatives to AOP as well.
In OOP, the core concerns can be loosely coupled through interfaces, but there is no easy way to do the same for crosscutting concerns.
This is because a concern is implemented in two parts: the server-side piece and the client-side piece.
But when the concern is of a crosscutting nature, the client part (consisting of the requests to the server) is spread over all the clients.
Figure 1.4 Implementation of a security concern using conventional techniques.
The security module provides the API for authentication and authorization.
As an example, let’s take another look at the typical implementation of a crosscutting concern in OOP, shown in figure 1.4
The use of an interface loosens the coupling between the clients and the implementations of the interface.
Clients that use the security services through the interface are oblivious to the exact implementation they’re using; any changes to the implementation don’t require changes to the clients themselves.
Likewise, replacing one security implementation with another is just a matter of instantiating the right kind of implementation.
The result is that you can replace one security implementation with another with little or no change to the individual client modules.
But this arrangement still requires that each client have the embedded code to call the API.
Such calls must be included in all the modules requiring security and are tangled with their core logic.
Using AOP, none of the core modules contain calls to the security API.
For now, don’t worry about the way in which AOP achieves this; we’ll explain in the next section.
The fundamental change that AOP brings is the preservation of the mutual independence of the individual concerns.
Implementations can be easily mapped back to the corresponding concerns, resulting in a system that is simpler to understand, easier to implement, and more adaptable to changes.
Figure 1.5 Implementing a security concern using AOP techniques: The security aspect defines the interception points needing security and invokes the security API upon the execution of those points.
In order to be of any use in the real world, it must be implemented, or realized.
Each realization of AOP involves specifying a language or a framework and associated tools.
Like any other programming methodology, an AOP implementation consists of two parts:
The language specification describes the language constructs and syntax to express implementation of the core and crosscutting concerns.
The language implementation verifies the code’s adherence to the language specification and translates the code into an executable form.
Any implementation of AOP must specify a language to implement the individual concerns and a language to implement the weaving rules.
Note that an AOP system may offer a homogeneous language that doesn’t distinguish between the two parts.
This is likely to be the case in future AOP languages.
As in other methodologies, the concerns of a system are implemented into modules that contain the data and behavior needed to provide their services.
A module that implements the core part of the caching concern maintains a collection of cached objects, manages the validity of the cached objects, and ensures bounded memory consumption.
To implement both the core and crosscutting concerns, we normally use standard languages such as C, C++, and Java.
Weaving rules specify how to combine the implemented concerns in order to form the final system.
After you implement the core part of the caching concern in a module (perhaps through a third-party class library), you must introduce caching into the system.
The weaving rule in this case specifies the data that needs to be cached, the information that forms the key into the cache storage, and so forth.
The system then uses these rules to obtain and update cache from the specified operations.
The power of AOP comes from the economical way of expressing the weaving rules.
For instance, to modularize tracing concerns in listing 1.1, you can add a few lines of code to specify that all the public operations in the system should be logged.
This is much more succinct than modifying each public operation to add logging code.
Because the tracing concern is modularized away from the class, it may focus only on the core concern, as follows:
Compare this class with the one in listing 1.1: all the code to perform tracing—the ancillary concerns from the class’s point of view—have been removed.
When you apply the same process to other crosscutting concerns, only the core business logic remains in the class.
As you’ll see in the next section, an AOP implementation combines the classes and aspects to produce a woven executable.
Weaving rules can be general or specific in the ways they interact with the core modules.
In the previous logging example, the weaving rules don’t need to mention any specific classes or methods in the system.
On the other end of the spectrum, a weaving rule may specify that a business rule should be applied only to specific methods, such as the credit() and debit() operations in the Account class or the ones that carry the @ReadOnly annotation.
The specificity of the weaving rules determines the level of coupling between the aspect and core logic.
The language used to specify weaving rules can be a natural extension of that language or something entirely different.
For example, an AOP implementation using Java as the base language might introduce new extensions that blend well with the base language, or it could use a separate XML-based language to express weaving rules.
The AOP language implementation performs two logical steps: It first combines the individual concerns using the weaving rules, and then it converts the resulting information into executable code.
An AOP system can implement the weaver in various ways.
Here, the weaver processes source code for individual classes and aspects to produce woven source code.
The aspect compiler then feeds this woven code to the base language compiler to produce the final executable code.
This was the implementation technique used in early implementations of AspectJ.
The approach suffers from several drawbacks because the executable code can’t be easily traced back to the original source code.
For example, stack traces indicate line numbers in woven source code.
Another approach first compiles the source code using the base language compiler.
Then, the resulting files are fed to the aspect compiler, which weaves those files.
Figure 1.6 shows a schematic of a compiler-based AOP language implementation.
An AOP system may also be able to push the weaving process close to execution of the system.
If the implementation of AOP is Java-based, a special class loader or a virtual.
Fundamental concepts in AOP machine (VM) agent can perform the weaving.
Such an implementation first loads the byte code for the aspects, weaves them into the classes as they’re being loaded, and supplies those woven versions of the classes to the underlying VM.
In this case, each object that needs weaving is wrapped inside a proxy.
Such an implementation typically works well in conjunction with another framework that controls the creation of objects.
In this way, the framework can wrap each created object in a proxy.
So far, we’ve looked at the mechanics of an AOP system.
By now, it should be clear that AOP systems help in modularizing crosscutting concerns.
But so do many other technologies, such as byte-code manipulation tools, direct use of the proxy design pattern, and meta-programming.
How do you differentiate AOP from these options? To find out, we need to distill the core characteristics of AOP systems into a generic model.
If a system fits that model, it’s an AOP system.
To implement a crosscutting concern, an AOP system may include many of the following concepts:
Identifiable points in the execution of the system —The system exposes points during the execution of the system.
These may include execution of methods, creation of objects, or throwing of exceptions.
Such identifiable points in the system are called join points.
Note that join points are present in all systems—even those that don’t use AOP—because they’re points during execution of a system.
A construct for selecting join points —Implementing a crosscutting concern requires selecting a specific set of join points.
Figure 1.6 An AOP language implementation that provides a weaver in the form of a compiler.
The compiler takes the implementation of the core and crosscutting concerns and weaves them together to form the final system.
The pointcut construct selects any join point that satisfies the criteria.
This is similar to an SQL query selecting rows in database (we’ll compare AOP with databases in section 1.5.2)
A pointcut may use another pointcut to form a complex selection.
For example, a pointcut may collect method arguments as context.
The concept of join points and the pointcut construct together form an AOP system’s join point model.
A construct to alter program behavior —After a pointcut selects join points, you must augment those join points with additional or alternative behavior.
The advice construct in AOP provides a facility to do so.
An advice adds behavior before, after, or around the selected join points.
Before advice executes before the join point, whereas after advice executes after it.
Around advice surrounds the join point execution and may execute it zero or more times.
Advice is a form of dynamic crosscutting because it affects the execution of the system.
Constructs to alter static structure of the system —Sometimes, to implement crosscutting functionality effectively, you must alter the static structure of the system.
For example, when implementing tracing, you may need to introduce the logger field into each traced class; inter-type declaration constructs make such modifications possible.
In some situations, you may need to detect certain conditions, typically the existence of particular join points, before the execution of the system; weave-time declaration constructs allow such possibilities.
Collectively, all these mechanisms are referred to as static crosscutting, given their effect on the static structure, as opposed to dynamic behavior changes to the execution of the system.
A module to express all crosscutting constructs —Because the end goal of AOP is to have a module that embeds crosscutting logic, you need a place to express that logic.
It may be related to other aspects in a similar way to how a class relates to other classes.
Aspects become a part of the system and use the system (for example, classes in it) to get their work done.
Figure 1.7 shows all these players and their relationships to each other in an AOP system.
Each AOP system may implement a subset of the model.
On the other hand, the join point model is so central to AOP that every AOP system must support it—everything else revolves around the joinpoint model.
When you encounter a solution that modularizes crosscutting concerns, try to map it onto the generic AOP model.
If you can, then that solution is indeed an AOP system.
Otherwise, it’s an alternative approach for solving the problem of crosscutting concerns.
When you’re learning a new technology, it sometimes helps to compare it with existing technologies.
In this section, we’ll attempt to help you understand AOP by comparing it with Cascading Style Sheets (CSS), database programming, and eventoriented systems.
The purpose of this section is to help those familiar with at least one of these technologies to understand AOP by analogy.
Without CSS, formatting information is fused with content (causing tangling), and similar content elements have presentational information spread into multiple places (causing scattering)
AOP’s pointcuts have the same selection role as CSS selectors.
Whereas CSS selectors select structural elements in a document, pointcuts select program elements.
Similarly, the blocks describing the formatting information are analogous to AOP advice in functionality.
Often, the selection mechanism requires more information than merely using the inherent characteristics of a structure such as body p.
It’s common practice to supplement content elements with additional metadata through the class attribute.
Note that not every system implements each part of the model.
Then, in the stylesheet, you can select such an element by using the p.menu selector and apply appropriate presentation characteristics.
In AOP, practitioners face the same problem—selection through a pointcut often requires information beyond merely relying on inherent characteristics of the program elements such as class and method names.
The use of Java annotations plays a role similar to the class attribute in HTML documents.
You can, for example, mark a method as @Transactional and utilize it in a pointcut expression.
Through WYSIWYG HTML editors, it’s easy to create a good-looking HTML.
That apparent simplicity led to many initial web documents embedded with formatting information.
But when we realized that it’s difficult to create a consistent look when every element’s formatting is specified independently, developers started to look favorably at CSS.
There is a level of comfort in embedding the implementation of crosscutting functionality inside classes; you can see exactly what’s going to happen.
But you soon realize that creating a consistent implementation is nearly impossible when similar code is scattered in many places.
In addition, using CSS requires a level of expertise and understanding of the semantics associated with the elements in a document.
Using AOP requires similar understanding of the semantic separation between core and crosscutting elements.
Database systems offer “dynamic crosscutting” targeted toward data access, whereas AOP offers a similar mechanism toward general programming.
It offers two good analogies to AOP concepts: SQL with pointcuts and triggers with advice.
A join point is like a row in a database, whereas a pointcut is like an SQL query.
An SQL query selects rows according to a specified criterion such as “rows in accounts table, where the balance is greater than 50”
It provides access to the content of the selected rows.
Similarly, a pointcut is a query over program execution that selects join points according to a specified criterion such as “method execution in the Account class, where the method name starts with ‘set’”
It also provides access to the join point context (objects available at the join point, such as method arguments)
The static condition, such as the name of the table and the modified column, as well as the dynamic condition, such as the difference in the column value, are analogous to AOP’s pointcut concept.
The stored procedure specified in the trigger is analogous to AOP’s advice.
Database triggers and AOP’s advice both modify the normal program execution to carry additional or alternative actions.
But note that AOP doesn’t necessarily obviate the need for database triggers, for reasons such as performance and bringing uniformity to multiple applications accessing the same tables.
Similar to database triggers, event-oriented programming includes the notion of responding to events.
Event-oriented programming is essentially the observer design pattern (we’ll discuss it as an alternative to AOP in section 1.7.3)
Each interested code site notifies the observers by firing events, and the observers respond by taking appropriate action, which may be crosscutting in nature.
In AOP, the program is woven with logic to fire virtual events and to respond to the events with an action that corresponds to the crosscutting concern it’s implementing.
But note this important difference: Unlike in event-based programming, there is no explicit code for the creation and firing of events in the subject classes.
Also, event systems tend to be more coarse-grained than an AOP solution implements.
Note that you can effectively combine event-oriented programming with AOP.
Essentially, you can modularize the crosscutting concern of firing events into an aspect.
With such an implementation, you avoid tangling the core code with the event-firing logic.
Now that you have a good understanding of AOP, let’s turn our attention to a bit of history and the current status of AOP implementations.
Much of the early work that led to AOP today was done in research institutions.
Gregor coined the term AOP in 1996 and started AspectJ, the first implementation of AOP.
Each implementation takes a slightly different view on the target use case and programming constructs.
Let’s see who the dominant players are and how they size up against each other.
AspectJ is the original and still the best implementation of AOP.
After a few initial releases, Xerox transferred the AspectJ project to the open source community at eclipse.org.
Until a few years back, AspectJ had a close cousin: AspectWerkz.
This AOP system followed the core AspectJ model, except that it used metadata expressed through Javadoc annotations, Java 5 annotations, or XML elements in place of additional keywords.
One of AJDT’s most important features is a tool for visualization of crosscutting, which is helpful for debugging a pointcut specification.
Although you write classes and aspects separately, you can visualize the combined effect even before the code is deployed.
The AspectJ language has an alternative implementation called the AspectBench compiler (abc; http://aspectbench.org)
The focus of this project is to provide a flexible implementation to support experimenting with new AspectJ language features and optimization ideas.
Spring is the most popular lightweight framework for enterprise applications.
To satisfy the needs of enterprise applications, it includes an AOP system based on interceptors and the proxy design pattern.
Earlier implementations of Spring AOP (prior to Spring 2.0) offered a somewhat complex programming model.
The new programming model, based on AspectJ, offers a much better programming experience and enables Spring users to write custom aspects without difficulty.
We’ll examine how Spring uses AspectJ in detail in chapter 9 and in examples throughout the book.
It includes AOP support that is similar to Spring AOP.
Scala and AspectJ Scala is a new language that compiles source code to the standard Java byte code.
Scala maps program elements to byte code in a manner similar to that of Java.
Note that, unlike Scala, other JVM languages such as JRuby and Groovy use mapping that heavily relies on reflection.
Therefore, AspectJ may not be used as readily with those.
Instead, you need specialized languages that work with them, as you’ll see in section 1.6.3
In addition, the AOP Alliance API is implemented in frameworks such as Guice (http://code.google.com/p/ google-guice) and Seasar (http://www.seasar.org)
Spring used to offer a programming model based on the AOP Alliance API, but that model has been designated a transitional technology status due to the availability of the AspectJ-based model.
Groovy, like Ruby, makes it possible to implement an AOP-like functionality through its metaobject protocol (MOP) facility (see http://www.infoq.com/articles/aop-with-groovy for an explanation of this approach)
But as with Ruby, efforts are underway to introduce an AspectJ-like syntax to provide a domain-specific language (DSL) to simplify writing aspects (see http://svn.codehaus.org/grails-plugins/grails-aop for the code of the yet-to-be-released grails-aop project)
Due to the use of byte code representations and the possibility of using proxies, .NET offers choices similar to those available in the Java world.
The concerns of auditing, transaction management, security, and so on emerged as soon as we started implementing nontrivial software systems.
Consequently, many competitive technologies deal with the same problem: frameworks, code generation, design patterns, and dynamic languages.
Each of these approaches is appropriate for a set of problems.
Frameworks such as servlets and Enterprise JavaBeans (EJB) offer specific solutions to a focused set of problems.
For example, the servlet specification offers filters to deal with requests made using the HTTP protocol.
For example, with the servlet framework, you may use filters to implement concerns such as security.
Similarly, the EJB framework addresses crosscutting concerns such as transaction management and security.
But as you’ll see later, it falls short of being a complete solution.
In such an arrangement, the core framework deals with the target problem and lets aspects deal with crosscutting concerns.
For example, the core Spring Framework deals with dependency injection for configuration and enterprise service abstraction to isolate beans from the underlying infrastructure details, while employing AOP to deal with crosscutting concerns such as transaction management and security.
A framework’s approach to crosscutting concerns often, but not always, boils down to either employing code generation or implementing appropriate design patterns.
Code-generation techniques shift some responsibility of writing code from the programmer to the machine.
Of course, programmers do have to write code for the generators.
These techniques represent powerful ways to deal with a wide range of problems and often are helpful in raising the level of abstraction.
You can modify the original code to add functionality such as observer notifications or produce additional artifacts such as proxy classes.
In the process, code generation takes care of one of the drawbacks of using design patterns directly: manual modifications in many places.
A variation of code generation works at the compiled code level through byte-code manipulation tools.
Instead of producing source code that needs to be compiled into machine code, the code generator directly produces machine code.
For Java, the difference between source code–level generation and byte-code generation is small, given how directly source code maps to byte code.
Many Java technologies, such as Hibernate and JRuby, use byte-code manipulation techniques as the basis for their implementation.
In Java 5, the annotation language feature lets you attach additional information to the program elements.
Code-generation techniques can take advantage of those annotations to produce additional artifacts such as Java code or XML configuration files.
Java 5 even provides an Annotation Processing Tool (APT), to simplify the process.
But APT forces you to understand low-level details such as the syntax tree, and that makes it difficult to use unless you acquire specific skills.
AOP, on the other hand, can provide simpler solutions to process annotations, as you’ll see in rest of the book.
Many systems, most notably AspectJ, use byte-code manipulation as the underlying technique in implementing AOP.
The difference is how it employs the technique as part of the overall AOP model.
Alternatives to AOP model, making it easier for you to create modularized crosscutting implementations without knowing low-level details such as the abstract syntax tree.
Users are isolated from byte-code manipulation mechanisms, which aren’t for the faint of heart.
Furthermore, by limiting power, AOP nudges you toward writing better code.
In short, although code generation is capable of doing anything AOP can do (and a lot more), AOP brings a level of discipline that is essential for good software engineering when it comes to dealing with crosscutting concerns.
In this section, we’ll take a comparative look at some of the design patterns—observer, chain of responsibility, decorator, proxy, and interceptor—that help with crosscutting concerns.
You’ll see that quite a few similarities exist between design patterns and AOP—you can view a few design patterns as a “poor man’s” AOP implementation.
The well-known observer design pattern decouples the subject (an object of interest) from observers (objects that need to respond to changes in the subject)
The notification method iterates over all the observers and calls a method on each observer (in message-oriented systems, these details change a bit, but the overall scheme remains the same)
The called method in the observer includes the logic appropriate to respond to the event.
AOP’s advice may superficially look like an event responder, but there are some important differences.
As a result, you can produce notifications that weren’t planned in advance, making your system extensible over what it was originally designed to be and bringing it new life in some situations.
Second, the context collected by pointcuts (equivalent to information carried in an event object) is much more flexible and powerful in AOP.
Pointcuts can collect just the right amount of context needed for advice logic.
With a typical event model, you end up passing everything that you might possibly need.
The chain of responsibility (COR) pattern, shown in figure 1.8, puts a chain of processing objects in front of a target object.
Before or after invoking the target object, the objects in the chain may perform additional work.
First, you should have only one or a small number of target methods, whose processing needs to be augmented.
For example, the filter implementation in the servlet framework implements the COR pattern.
In this setup, some coarse-grained crosscutting concerns—ones that deal at the HTTP request level—may be modularized into servlet filters.
But for any concern that needs to go beyond the doService() method, filters offer no solution.
Instead, each aspect deals with the problem head on by advising appropriate code.
For example, each method may perform a security check before the wrapped object’s method is invoked.
Java offers dynamic proxies that reduce the code required for creating wrapper types and routing each method.
Using this feature, you dynamically create a proxy for a given set of interfaces, supplying an invocation handler.
The proxy implements all the specified interfaces and invokes the invocation handler when any interface method is called.
Implementing crosscutting concerns using dynamic proxies requires control over the creation of each object so that it may be wrapped in a dynamic proxy.
I lump these two patterns together because the distinction between them isn’t significant from the AOP perspective.
A decorator holds onto a real object that it decorates, whereas a proxy may not necessarily hold any real object but simulates holding one.
In a way, the proxy design pattern is a generalization of the decorator design pattern.
The original object is wrapped in the decorator that presents the same interface as the decorated object.
Each method passes through the decoration, which can implement functionality such as security and transaction management.
Figure 1.8 Chain of responsibility as implemented by the servlet framework.
The filter chain allows applying additional logic such as coarse-grained security around the doService() method.
Alternatives to AOP proxies invoke the invocation handler for every method, proxies must include logic to apply crosscutting concern selectively.
Furthermore, dynamic proxies intercept method invocations only: they can’t crosscut object creation, field access, exception handling, and so on.
Direct use of the decorator and proxy design patterns to implement crosscutting concerns requires substantial effort.
But you can use these patterns as the underlying implementation technique as a part of an AOP system.
The Spring Framework, as you’ll see in chapter 9, uses the proxy design pattern internally to avoid exposing it to users.
Another design pattern, interceptor, is often used along with the proxy design pattern.
Let’s see how it compares to AOP for crosscutting concerns.
An interceptor performs additional logic by intercepting method invocations on an object.
The interceptor pattern lets you express crosscutting logic in an interceptor object.
Used with the proxy or decorator design pattern, this pattern offers a reasonable solution for a wide range of crosscutting problems.
For example, Java supports the creation of dynamic proxies, which you can configure with an interceptor.
Implementing the interceptor pattern generically and successfully requires a fair amount of machinery; thus it’s best to leave such an implementation to a framework.
Let’s consider the newest implementation of the interceptor pattern in EJB3
The earlier versions of the EJB framework offered a solution for a specific set of crosscutting concerns: primarily transaction management and role-based security.
EJB3 offers a way to modularize user-specific crosscutting concerns through the interceptor approach:
Then, you can apply the interceptor to target classes and methods, as shown in the following code snippet:
You can target specific methods by marking each method with the @Interceptors annotation.
On the other extreme, you can declare an interceptor as a default interceptor.
EJB3’s implementation has a few limitations: for example, an interceptor may be applied only to EJBs and not to ordinary types in the system, which may pose restrictions on certain usages.
The programming model is also complex and type-unsafe: the intercepted context (intercepted bean, method name, method arguments) is accessed through the InvocationContext object, whose method returns Object and may require casting before using the context.
But the real problem with the EJB interceptor design (and many similar interceptor implementations) is the missing key abstraction of pointcuts.
Classes and methods need to declare that they must be intercepted, reducing the interceptor to a more macro-like facility.
As a result, although the logic equivalent to AOP’s advice is modularized, the pointcut equivalent logic is spread in all intercepted types.
And due to the generic nature of the join point context, the interceptor method may need complex logic to pluck arguments from the context.
But Spring’s AOP always used a pointcut notion to avoid the problem of spreading selection logic in multiple places.
A dynamic language, when combined with a framework that takes advantage of the underlying language, can provide powerful solutions for a set of problems.
For example, Ruby combined with Rails, or Groovy combined with Grails, provides simpler solutions for certain kinds of web applications.
Most dynamic languages offer a meta-programming facility that lets you modify the structure and behavior of a program during its execution.
For example, you can modify an existing method’s implementation to wrap it with code that performs the crosscutting functionality before or after dispatching the original method.
Although meta-programming is a fine tool for dealing with crosscutting concerns, you must keep in mind a few considerations:
You need to use a dynamic language that supports meta-programming.
The static versus dynamic languages war hasn’t concluded, nor will it conclude any time soon, so you’ll have to make a considered choice.
Meta-programming may be too powerful a tool for you; a more disciplined approach may be appropriate.
Tooling to support crosscutting implementation is difficult to imagine with general-purpose meta-programming facilities offered by dynamic languages.
This is a reason why Dean Wampler, a long-time AOP expert, started the Aquarium project (http://aquarium.rubyforge.org) to bring AOP to Ruby.
It shows that although AOP is popular in statically typed languages, it also has a role in dynamically.
Interestingly, as seen from this project, it’s relatively easy to build AOP capabilities on top of core meta-programming support provided by the underlying language.
By providing an aspect-focused DSL to express pointcuts, Aquarium provides a solution to modularize the pointcut portion of AOP in Ruby.
It’s instructive to note that the father of AOP, Gregor Kiczales, who wrote The Art of the Metaobject Protocol (MIT Press, 1991), thought that AOP was better suited for crosscutting concerns instead of a direct application of meta-programming.
In a way, statically typed languages use AOP to gain meta-programming support.
In contrast, dynamic languages benefit from AOP as a disciplined application of metaprogramming.
Nothing comes free! Software engineering, like any engineering discipline, is all about optimizing costs and benefits.
Critics of AOP often talk about how difficult it is to understand.
And indeed, AOP takes time, patience, and practice to master.
But the main reason behind the difficulty is the newness of the methodology.
When was the last time a brand-new programming methodology was accepted without its share of adaptation resistance? AOP demands that you think about system design and implementation in a new way.
When you use AOP, you get a lot of benefits, but you must also understand some costs in order to make informed decisions.
In this section, we’ll discuss first the costs and then the benefits of AOP.
Some of the costs associated with AOP are the usual suspects associated with any new technology:
Well-understood mitigation techniques are available for some of these issues:
Making a proper investment in learning the technology (and you already took a step by reading this book)
Doing due diligence in checking skill availability (which is becoming increasingly easy due to Spring’s popularity)
Following a gradual adoption path, which we’ll show in part 2 of the book.
Tools for AOP aren’t as mature as they are for Java (although they’re more mature than for most other languages that run inside the Java VM)
Fortunately, a lot of effort is currently under way to improve the tooling around AOP, so this isn’t a serious impediment to adopting it.
But one cost, still common to most new technologies, deserves more in-depth treatment: the cost of abstraction.
Abstraction lets you hide inessential details and thus reduce the complexity of the underlying system.
Because each module represents a much smaller subsystem, abstraction offers a way to contain complexity at a level you can cope with.
Creating the right level of abstraction is a highly skilled job (many correct abstractions are possible in a given system)
A thorough understanding of the costs and benefits is a hallmark of good software engineering.
For that, you must apply decomposition techniques to separate core concerns from crosscutting concerns.
All this requires experience that is often best gained by applying AOP in a gradual manner.
The second part of the book provides details of this strategy.
On the flip side, crosscutting logic is separated from business logic.
This enables you to use developers who understand only the business logic and not the intricacies of the crosscutting functionality.
In software systems, higher levels of abstraction always mean that less information is available at the code level.
Looking at a code segment doesn’t tell you the whole story that will unfold during system execution.
For example, in OOP, due to polymorphic methods, you can’t tell the exact method that will be executed at runtime, because the choice of method is based on the type of the object, not the static type of the declared variable.
Even in procedural languages such as C, if you use function pointers, the program flow isn’t static and requires some effort to be understood.
You may not know (except through good tooling support) that a crosscutting action will take place in a certain part of the code.
Many programmers new to AOP get stuck until they realize that this separation of concerns is the whole point.
If you insist on understanding the exact program flow, it’s a sign that you need to reflect a little longer on the core ideas of AOP.
But just as OOP requires a few years of practice before you understand the underlying core ideas, most developers get AOP eventually.
Now that you know the costs, let’s look at the benefits.
If you underdesign, you may have to make massive changes later in the development cycle.
If you overdesign, the implementation may be burdened with code of questionable.
With AOP, you can delay making design decisions for future requirements because you can implement those as separate aspects.
You can focus on the current requirements of the system.
Implementing a feature just because you may need it in the future often results in wasted effort because you won’t actually need it.
With AOP, you can practice YAGNI; and if you do need a particular kind of functionality later, you can implement it without having to make system-wide modifications.
Even for the feature that you need, agile programming promotes developing them progressively.
For example, a module implementing business logic is no longer responsible for the security functionality.
This results in cleaner assignments of responsibilities, reduced code clutter, and less duplication.
It also improves the traceability of requirements to their implementation, and vice versa.
Reduced code tangling makes it simpler to test code, spot potential problems, and perform code reviews.
Reviewing the code of a module that implements only one concern requires the participation of an expert in the functionality implemented by that module.
Reduced code scattering avoids the cost of modifying many modules to implement a crosscutting concern.
Thus, AOP makes it cheaper to implement a crosscutting feature.
By letting you focus on the core concern of a module and make the most of your expertise, AOP also reduces the cost of the core concerns.
The end effect is a cheaper overall feature implementation, better time-to-market, and easier system evolution.
The key to greater code reuse is a more loosely coupled implementation.
If a module is implementing multiple concerns, other systems requiring similar functionality may not be able to use the module if they implement a different set of crosscutting concerns.
With AOP, because you can implement each crosscutting module as an aspect, core modules aren’t aware of crosscutting functionality.
By modifying the aspects, you can change the system configuration.
For example, a service layer may be secured in a project with one security scheme, in another project with another scheme, or in still another project with no security at all by including or excluding appropriate aspects.
Without AOP, a service layer tied with a specific security implementation may not be reused in another project.
The most fundamental principle in software engineering is that the separation of concerns leads to a system that is simpler to understand and easier to maintain.
For instance, with OOP, by separating interfaces from their implementation, you can modularize the core concerns well.
But for crosscutting concerns, OOP forces the core modules to embed the crosscutting concern’s logic.
Although the crosscutting concerns are independent of each other, using OOP leads to an implementation that no longer preserves independence in the implementation.
Aspect-oriented programming changes this by modularizing crosscutting concerns in a generic and methodical fashion.
With AOP, crosscutting concerns are modularized by encapsulating them in a new unit called an aspect.
Core concerns no longer embed the crosscutting concern’s logic, and all the associated complexity of the crosscutting concerns is isolated into the aspects.
By building on top of existing programming methodologies, AOP preserves the investment in knowledge gained over the last few decades.
In the last few years, AOP has become a practical technology.
It has been deployed in many organizations, big and small, to add powerful features that we might have otherwise shied away from or implemented in a laborious manner.
In the next eight chapters, we’ll study a specific implementation of AOP for Java, AspectJ, as well as its integration with Spring.
Those chapters and the rest of the book will provide examples that use this technology to solve real problems.
In chapter 2, you’ll see how AspectJ implements AOP for Java.
AspectJ is an aspectoriented extension to the Java programming language.
Like any AOP implementation, AspectJ consists of two parts: the language specification, which defines the grammar and semantics of the language; and the language implementation, which includes weavers that take various forms such as a compiler and a linker.
A weaver produces byte code that conforms to the Java byte-code specification, allowing any compliant Java virtual machine (VM) to execute those class files.
The language implementation also offers support for integrated development environments (IDEs), to simplify building and debugging applications.
AspectJ started and initially grew as a special language that extends the Java language with new keywords.
It also provided a special compiler that could understand those extensions.
But recently, a lot has changed in its form as a language, as well as Introducing AspectJ.
In chapter 1, we focused on general concepts in AOP.
First, AspectJ offers an alternative syntax based on the Java annotation facility to express crosscutting constructs.
This lets you use a plain Java compiler instead of the special compiler.
Second, AspectJ offers new options for weaving classes with aspects.
Finally, it has gained a strong foothold in the Spring Framework with several integration options.
All these changes have made adoption of AspectJ easier than ever before.
In this chapter, we’ll examine important facets of AspectJ—starting with language constructs, passing through syntax and weaving choices, peeking into the Spring integration, and ending with tools support—from a high-level perspective.
In the chapters that follow, we’ll delve deeper into each of these facets.
This code introduces a few AspectJ concepts and gives you a feel for the language.
Let’s create a regular Java class, as shown in listing 2.1, which contains two methods that will print messages.
Later in this section, you’ll create a few aspects to introduce additional behavior without modifying the class.
Installing AspectJ You’ll need to install AspectJ to work with the code in this book.
Doing so opens a wizard that will guide you through the installation process.
Alternatively, you can use Eclipse along with the AspectJ Development Tools (AJDT) to run these examples in the IDE.
Therefore, you could use the AspectJ compiler (ajc) to compile the classes instead of a Java compiler such as javac.
Now that the basic setup is ready, let’s add a few aspects to the system to improve the message-delivery functionality.
Consider authentication functionality: before delivering a message, you’d like to check whether the user has been authenticated.
Without using AOP, you’d have to write code like the following:
Running the examples The main reason behind showing the command-line operations is to remove some of the mystery about how AspectJ works.
The downloadable sources include shell scripts that match the commands and also include the necessary setup.
But most developers will prefer to run the code through the Ant and Maven scripts also provided with the downloadable sources.
See appendixes B and C for detailed instructions on how to use these tools with AspectJ.
You have to add a call to authenticate() in each method that needs authentication, which leads to code tangling.
Later, you’ll see alternative syntax to implement the same functionality.
The Authenticator class asks for credentials (username and password) when the authenticate() method is called for the first time in a thread.
Upon successful authentication, it stores the user in a thread local so it doesn’t ask for credentials in the same thread again.
If you like, you can download it from the book’s web site: http://manning.com/laddad2/
Now, when you run the program, you see the following output (the use of Java generic feature in the Authenticator class requires specifying the -source 5 option to ajc):
Although the file extension doesn’t matter to the compiler, aspects typically use the .aj extension, and Java code uses the .java extension.
An aspect is a unit of modularization in AOP, much like a class is a unit of modularization in OOP.
The declaration of an aspect is similar to a class declaration.
A pointcut selects interesting points of execution in a system, called join points.
The * indicates that the pointcut matches any return type, and the ..
You’ll learn about join points and pointcuts in detail in the next chapter.
An advice defines the code to execute upon reaching join points selected by the associated pointcut.
Here, you define a piece of advice to execute before reaching the join points selected by the secureAccess() pointcut.
Now that you have the flavor of the AspectJ language, it’s time for an overview of the language and its core building blocks.
AspectJ is the most complete implementation of that model, supporting all its elements.
In this section, we’ll examine how AspectJ maps each model element into program constructs.
Note that AspectJ offers two syntax choices: traditional and @AspectJ.
This section uses the traditional syntax to study these building blocks.
We can classify the crosscutting constructs in the AOP model as common crosscutting constructs (join point, pointcut, and aspect), dynamic crosscutting construct (advice), and static crosscutting constructs (inter-type declarations and weave-time declarations)
AspectJ supports a few common constructs consisting of the join point, the pointcut, and the aspect.
You can use these constructs with both dynamic and static crosscutting.
In AOP, and therefore in AspectJ, join points are the places where the crosscutting actions take place.
Listing 2.1 has join points corresponding to the execution of the deliver() methods as well as calls to the println() method on the System.out object.
After you identify join points useful for a crosscutting functionality, you need to select them using the pointcut construct.
A pointcut is a program construct that selects join points and collects context at those points.
For example, a pointcut can select a join point that is an execution of a method.
It can also collect the join-point context, such as the this object and the arguments to the method.
The following pointcut selects the execution of any public method in the system:
Here, the only condition specified is that the access specification for the method must be public.
For example, you can name the earlier pointcut publicOperation, as follows:
The aspect is the central unit in AspectJ, in the same way that a class is the central unit in Java.
It contains the code that expresses the weaving rules for both dynamic and static crosscutting.
Additionally, aspects can contain data, methods, and nested class members, just like a normal Java class.
Let’s define an aspect that performs profiling that you’ll update as you learn about more elements:
Learning about common crosscutting constructs will pay off when you begin using them with dynamic and static crosscutting constructs.
AspectJ’s dynamic crosscutting support comes in the form of advice.
Advice is the code executed at a join point selected by a pointcut.
Advice can execute before, after, or around the join point.
The body of advice is much like a method body—it encapsulates the logic to be executed upon reaching a join point.
Let’s update ProfilingAspect (shown in listing 2.4) with profiling advice.
The advice records the start time, calls proceed() to continue executing the advised method, records the end time, and prints the time taken by the method execution.
When you compile this aspect along with the other code and execute it, you get the following output:
While dynamic crosscutting alters the program behavior, static crosscutting alters the programs structure.
Static crosscutting comes in the form of inter-type and weave-time declarations.
The inter-type declaration (ITD) (also referred to as introduction) is a static crosscutting construct that alters the static structure of the classes, interfaces, and aspects in the system.
For example, you can add a method or field to a class, or declare a type to implement an interface.
In an ITD, one type (an aspect) declares the structure for the other types (classes, interfaces, and even aspects)—hence the name.
You can then advise methods in a type that implements AccessTracked (directly or through a declare parents statement) to update the last-accessed time, as shown in the following snippet:
Pseudo keywords in AspectJ The proceed and other keywords such as aspect, pointcut, and before are really pseudo keywords that gain special meaning only in the right context.
For example, it is perfectly legitimate to use a method named ‘proceed’ in Java classes.
But when proceed is used in an around advice, it acquires a special meaning.
This use of pseudo keywords enables AspectJ to work with any valid Java program that may already include AspectJ keywords.
Let’s put all these snippets in an aspect, as shown in listing 2.5, to see their effect.
Listing 2.6 Modified Main class to print the last-accessed time.
When you compile and execute this class, the output is as follows:
An important form of static crosscutting allows detecting and flagging the presence of join points, matching a pointcut during compilation.
The weave-time declaration is another static crosscutting construct that allows you to add weave-time warnings and errors when detecting certain usage patterns.
Often, weaving is performed during compilation; therefore, these warnings and errors are issued when you compile the classes.
The following declaration will cause the compiler to issue a warning if any part of the system calls the prohibited method—except, of course, SecurityAspect:
Note the use of the call() pointcut to select a method call (as opposed to selecting the method execution, which is always in the Authenticator class) and !within() to restrict selection of join points to only those occurring outside SecurityAspect.
The weaver will report warnings when it detects the specified conditions along with other compile-time warnings such as use of a deprecated method.
Let’s see this in action by modifying SecurityAspect to add this declaration:
When you compile the code, the output is as follows:
As the output shows, the compiler detects and flags the violation and also points to the aspect with the corresponding declare warning statement.
This completes our discussion of various crosscutting constructs in AspectJ.
By offering comprehensive support for various elements, AspectJ enables modularization of crosscutting concerns.
You’ll see examples based on these constructs throughout the book.
Until now, we’ve restricted ourselves only to the traditional AspectJ syntax and compiler as the weaver.
But AspectJ offers an alternative syntax that we’ll study next.
The traditional syntax we’ve been using so far requires the use of the special ajc compiler early in the development process to compile aspects.
To simplify adoption, starting with AspectJ version 5, alternative syntax and weaving models are available, thanks to the merger of AspectJ with AspectWerkz, another implementation of AOP for Java.
The main advantage of this syntax style is that you can compile your code using a plain Java compiler (for example, javac)
As a result, the code works better with conventional Java IDEs and tools that don’t understand the traditional AspectJ syntax.
Furthermore, the proxy-based AOP framework in Spring uses this syntax, simplifying adoption of AspectJ if the project is already using Spring.
The disadvantage of @AspectJ syntax is its verbosity in expressing the same constructs and its limitations in expressing certain constructs, especially in the static crosscutting category.
Instead of using the aspect keyword, you use a class annotated with an @Aspect annotation.
The ajc compiler, which understands the semantics associated with the @Aspect annotation, uses this information to treat the class as if it’s an aspect.
Similarly, the @Pointcut annotation marks an empty method as a pointcut.
The name of the method serves as the pointcut name.
The @Before annotation marks a regular method as a before advice.
The body of the method consists of the advice logic—this code is executed when a matching join point is executed.
First, let’s compile the code using javac and execute the resulting code.
The code compiled fine, but the aspect had no effect on the output.
You need to include an aspect weaver somewhere between compiling the source code and executing the byte code in the VM.
The simplest way to use the @AspectJ syntax is to use the ajc compiler instead of javac.
Alternatives include binary weaving, where code compiled using javac is then woven using ajc; and load-time weaving (LTW), where classes are woven as they’re being loaded into the VM.
The output is the same as that produced by the aspect in listing 2.3
The value proposition of @AspectJ syntax is a simplified adoption curve.
The aspect’s syntax is expressed using Java constructs, which reduces the mental block commonly associated with using yet another language.
You’re still using plain Java! In addition, tools such as compilers, IDEs, and code-coverage utilities work more easily with the @AspectJ syntax, because they’re working with plain Java code.
Now, let’s look at another puzzle piece that completes AspectJ: the weaver.
A weaver needs to weave together classes and aspects so that advice gets executed, inter-type declarations affect the static structure, and weave-time declarations produce warnings and errors.
Regardless of the weaving model used, the resulting execution of the system is identical.
The weaving mechanism is also orthogonal to the AspectJ syntax used; any combination of weaving mechanism and AspectJ syntax will produce identical results.
In this section, we’ll examine the weaving models offered by AspectJ.
In source weaving, the weaver is part of the compiler (all the examples in this chapter so far have used source code weaving)
The input to the weaver consists of classes and aspects in source-code form.
You can write the aspects in either the traditional syntax or the @AspectJ syntax.
The weaver, which works in a manner similar to a compiler, processes the source and produces woven byte code.
The byte code produced by the compiler is compliant with the Java byte-code specification, which any standard compliant VM can execute.
But note that unlike javac, ajc requires that all sources be presented together if you want woven byte code.
If you present sources separately, the resulting byte code can be used as input for binary weaving or load-time weaving, discussed next.
In binary weaving, input to the weaver—classes and aspects—is in byte-code form.
The input byte code is compiled separately using the Java compiler or the AspectJ compiler.
For example, you can use jar files or class files produced using the Java compiler.
Let’s see binary weaving in action in a step-by-step manner.
The goal is to compile classes and aspects without weaving and then weave the resulting binary (.class) files.
You could use ajc; but to illustrate the effect of binary weaving clearly, we’re staying away from ajc.
Use the –d option to specify the destination directory for the classes, to help you better understand the effect:
Unsurprisingly, executing the Main class shows that there is no effect of the aspect:
If you wanted to use the traditional aspect from listing 2.3, you’d have to compile it using ajc:
Executing the Main class shows that the output still doesn’t have any effect on the aspect:
To weave aspects into classes in binary form, you use binary weaving:
The –inpath option specifies the path to the classes that are weaving targets.
Because you used javac to compile the aspects, you must also pass those to –inpath so that ajc can add the necessary support methods.
The -aspectpath option specifies the path to the aspects to be woven in.
Binary weaver and linker If you’re familiar with languages such as C and C++, think of the weaver as a linker, which is a more accurate comparison.
Much the same way a linker takes object files or libraries compiled using a compiler as input to produce an executable or another library, the weaver takes files containing byte code as input and produces woven byte code.
Executing the Main class shows that you’ve restored security to the system.
Because you pass an explicit –classpath option, you must add the CLASSPATH you’ve set to make the AspectJ runtime available to the VM:
Binary weaving can also take a combination of source and byte-code form as input (classes or aspects)
For example, you may have classes compiled into a jar file and aspects available in source form.
A load-time weaver takes input in the form of binary classes and aspects, as well as aspects and configuration defined in XML format.
A load-time agent can take many forms: a Java VM Tools Interface (JVMTI) agent, a classloader, or a VM- and application server–specific class preprocessor, which weaves the classes as they’re loaded into the VM.
Let’s use LTW to weave in the SecurityAspect, starting with the output of the first two steps in the previous section.
AspectJ supports a few locations for such a file; you’ll use one of them by naming the file aop.xml and placing it in a directory named META-INF in a classpath component.
Listing 2.8 shows the minimal XML file that serves this purpose.
This configuration instructs the weaver to weave in the SecurityAspect.
As you’ll see later in chapter 8, aop.xml can include a lot more configuration information, including pointcut definitions.
By now, you must be wondering how AspectJ performs its magic.
In the next section, we’ll take a quick look at how the source files are compiled into the byte code.
Because the byte code produced by the AspectJ weaver must run on any compliant Java VM, it must adhere to the Java byte-code specification.
This means the weaver must map crosscutting elements to Java constructs.
In this section, we’ll outline how the different elements in an AspectJ program map to pure Java byte code.
Note that the discussion that follows presents a simplified view of AspectJ code transformation into pure Java byte code.
Here are the typical ways the AspectJ weaver maps various crosscutting elements to pure Java:
Aspects map to classes, with each data member and method becoming the members of the class representing the aspect.
They may have associated auxiliary methods to help perform matching at runtime.
The weaver inserts calls to these methods at potential locations matching the associated pointcut.
They cause the compiler to print warnings or abort compilation when there’s an error.
Each mapped element carries annotations that help the weaver use the crosscutting information, even for aspects presented to it in byte code form.
Thinking about language semantics in terms of transformed code helps take the mystery out of AspectJ.
It also makes you appreciate the hard work the AspectJ weaver performs—and the hard work you no longer need to perform! But such thinking can bog you down in the details of the transformed code.
A better approach is to begin thinking in terms of language semantics instead of implementation.
In light of this information, let’s see how aspects and classes look after passing through the AspectJ weaver.
Note that the weaver produces byte code and not Java code, as shown here.
We’re showing you this code only to give you an idea of the source code that is roughly equivalent to the byte code produced.
First, let’s examine the code in a class that is equivalent to SecurityAspect from listing 2.3:
SecurityAspect is mapped to a class of the same name.
By default, an aspect is a singleton, and users don’t instantiate it explicitly.
The static block in the aspect ensures that the singleton aspect instance is created as soon as the SecurityAspect class is loaded into the system—typically, during the execution of code that refers to the aspect.
Notice the annotations on the methods; they make the code identical to that produced by compiling an equivalent @AspectJ aspect.
The AspectJ weaver weaves calls to these methods into the advised code, as you’ll see next.
Spring, the most widely used lightweight framework for developing enterprise applications, offers its own form of AOP to modularize crosscutting concerns typically seen in enterprise applications.
It uses the proxy design pattern to intercept the execution of methods on the target object.
Due to the use of proxies, it exposes method execution join points only for objects created by the Spring container (commonly known as Spring beans)
But it is a pragmatic solution for its target applications.
Starting with version 2.0, Spring offers several options to leverage AspectJ’s power in an incremental manner.
Performance implications of AspectJ weaving “How does it affect the performance of woven code?” is perhaps the most commonly asked question about AspectJ.
The inquiring mind wants to know how a hand-woven implementation of crosscutting functionality compares with that implemented with AspectJ.
The code produced by the weaver answers this question well.
Because the weaver encapsulates the advice in a method and calls it from appropriate places, there is virtually no overhead from the AspectJ weaver.
Furthermore, because advice is well isolated in one place, you can easily add optimizations to that code—something you’d cringe at implementing in hundreds of places.
Spring AspectJ integration in addition to its own pointcut expressions.
In this section, we’ll preview Spring AspectJ integration for aspects written in @AspectJ syntax.
This will be helpful to you because you’ll see many Spring-based examples in the book.
First, you’ll write a minimum application context file to define the needed configuration (see listing 2.9)
Please read the Spring Framework documentation for details of the syntax of the application configuration file.
Then, you use the bean to deliver a few messages (see listing 2.10)
Now, let’s compile all these classes and execute the Main class:
You see the same output as when you use an AspectJ weaver.
As a result, you can use the aspects written using @AspectJ in a Spring application without needing the AspectJ weaver.
So far in this chapter, you’ve used only command-line tools to work with aspects.
But in real life, virtually no one works without a good IDE.
You also need support for documentation so the crosscutting information is available outside the IDE.
In the next section, we’ll look at the logistical support provided by AspectJ.
AspectJ offers a complete set of tools ranging from a compiler to IDE support.
Let’s look at a few important tools in more detail.
This will help you when you download the book’s source code and try out the examples.
AspectJ eases the development process by providing integration with Eclipse.
The integration with the IDE is achieved through the AspectJ Development Tools (AJDT) plug-in.
Using this integration, you can edit, compile, and debug your project the same way you would a project written in Java.
Better still, you can use the free SpringSource Tools Suite (STS), which is an Eclipse distribution that includes many useful plugins, including AJDT, targeted for developing Spring-based applications.
Figure 2.1 shows how the example in this chapter looks in the Eclipse IDE.
Note that the Spring IDE, an Eclipse plug-in for developing Spring-based applications, offers similar functionality for Spring AspectJ integration, as discussed in section 2.6
In figure 2.1, Eclipse shows the standard views, along with a Cross References view that shows how an advice applies to different parts of the code.
This view helps in diagnosing problems where advice doesn’t apply to the expected set of methods.
If you see any mismatch, you can modify the corresponding pointcuts and reexamine the list of the advised methods.
The AJDT plug-in also offers a way to visualize the big picture effects of crosscutting concerns using the Visualiser.
Figure 2.1 Developing applications using Eclipse-AspectJ integration (using STS distribution)
The overall feel for editing, building, and debugging is like a plain Java project.
The IDE also shows how crosscutting elements affect the various parts of the system.
What about other IDEs? Earlier versions of AspectJ supported other IDEs besides Eclipse—NetBeans, JBuilder, and Java Development Environment for Emacs (JDEE)—by offering open source plug-ins for each of them.
An effort is currently under way to revive the NetBeans plug-in.
Although Eclipse IDE integration shows crosscutting information in a crosscutting references view, you’ll often need the same information in a static document.
The AspectJ documentation tool—ajdoc—extends Javadoc to provide crosscutting information in static form.
It produces HTML files similar to the ones produced by Javadoc, except the elements carry additional information showing how aspects and classes interact (see figure 2.2)
The output produced by ajdoc offers a simple way to examine the crosscutting structure without needing an IDE.
Because ajdoc isn’t tied to a specific IDE, you can use it alongside the IDE of your choice even if it doesn’t support AspectJ directly.
The tools offered by AspectJ are indispensable during the development process.
If you haven’t already done so, download and install AspectJ and AJDT as well as this book’s source code.
What about other IDEs? (continued) This is perhaps a reflection of the market reality—no other IDE is as popular as Eclipse.
One IDE that has a good market and mind share is IntelliJ IDEA.
Although an AspectJ plug-in is available for it (http://intellij.expertsystems.se/aspectj.html), it works only with the @AspectJ syntax.
Note that for any IDE without direct support for AspectJ, the possibility of using the @AspectJ syntax makes the lack of direct AspectJ support a less pronounced issue.
Because the code is still plain Java, as far as the IDE is concerned, you can edit code, take advantage of code completion, and so on.
If the IDE allows you to replace the default compiler, you can replace it with ajc.
If not, you can introduce a post-compilation step (often supported in IDEs) to run ajc to perform binary weaving.
Debugging works fine too, because the method representing advice is still executed as if there was a real call.
When you use the @AspectJ syntax in an IDE that doesn’t support AspectJ directly, you lose the source-code markers that indicate advice applicability, along with the crosscutting references view.
You can alleviate this problem to an extent by using ajbrowser (which comes as a part of the AspectJ distribution)—a standalone tool that shows how weaving rules affect different parts of a program.
You can add new functionality without changing code in the core modules and without those modules being aware of what you’ve done.
Aspect-oriented programming in AspectJ is simple: choose where you want to crosscut, choose the kind of action you need to perform, and programmatically specify both of them.
The AspectJ language exposes the necessary join points in a Java program.
Pointcuts let you choose the join points you want to affect, and advice allows you to specify the action at those join points.
The static crosscutting mechanism enables you to modify the static structure of the system.
Figure 2.2 Output produced by ajdoc, which works similarly to Javadoc.
In addition to the regular documentation, it provides markers to show crosscutting information.
By utilizing its power to modularize the crosscutting concerns, Java programmers no longer need to recode multiple modules when implementing or changing a crosscutting concern.
The new additions to AspectJ—the various syntax options, weaving models, and integration with Spring—make adopting AspectJ much easier.
It’s typical for Spring developers to start with the Spring AspectJ integration, using proxy-based weaving, and to learn the power of AOP and AspectJ through experience.
Then, they often move to advanced AOP techniques using AspectJ weaving, often along with the @AspectJ syntax.
At this point, load-time weaving is often a common choice due to its simplicity in getting started.
Later, when they’re looking for even more advanced usages, they may go for the traditional syntax along with a combination of source, binary, and load-time weaving.
In this chapter, we studied the core AspectJ concepts from 20,000 feet.
The next chapter introduces the join-point model that is at the heart of AOP.
The three chapters that follow will discuss dynamic crosscutting, static crosscutting, and aspects.
We’ll then proceed to examine the @AspectJ syntax, weaving mechanisms, and Spring integration.
All this information will enable you to write aspects that are useful in complex Java applications, which we’ll explore in part 2 of the book.
It consists of two parts: join points, the points in the execution of an application; and pointcuts, a mechanism for selecting join points.
It lets you select join points based on structural information such as types, names, arguments, and annotations as well as runtime conditions such as control flow.
This allows you to select exactly the join points you need to implement a crosscutting functionality.
In this chapter, you’ll learn about the concept of a join point in AOP and discuss the join point model in AspectJ.
We’ll discuss the join points supported by AspectJ, categorize them, and examine code associated with each kind of join point.
Then, you’ll build a simple example to reinforce the concepts learned.
We’ll spend the rest of the chapter discussing pointcuts supported by AspectJ along with many code Understanding the join point model.
The join point model is the central concept in AOP, as you’ve seen in previous.
We’ll also examine various signature patterns that form the basic building blocks of a pointcut.
The Spring Framework supports a subset of AspectJ pointcuts in its proxy-based AOP framework.
The focus of this chapter is on concepts and syntax.
We’ll visit the art of writing pointcuts in part 2 of the book.
By then, you’ll have seen many simple examples of AspectJ and will be ready to appreciate complex and more interesting applications.
Consider a situation where you need to implement transaction management.
If you decide that, due to the crosscutting nature of the functionality, AOP is the preferred approach, how do you go about implementing such functionality? Here is the typical process.
You identify places where you need to start a transaction before the main-line logic and where you commit or roll back the transaction after the logic finishes, based on the outcome.
In other words, you identify the join points that require the transaction management functionality.
You write a pointcut that selects the required join points.
For transaction management, the desired join points are likely to correspond to method execution.
Perhaps they belong to all types in a package or to subclasses of a type, or they share part of the method name.
More likely, in the case of transaction management, you may have an @Transactional annotation associated with the desired methods.
The pointcut may also need to collect join point context (objects such as this, arguments, and annotations) to provide to advice.
How to read this chapter This chapter serves a dual purpose: it teaches concepts and provides a reference when you practice AOP.
Then, if you’re reasonably familiar with AspectJ, I suggest that you read this chapter completely before proceeding with the next chapter.
If this book is your first introduction to AOP, read the remainder of the chapter focusing on the concepts, but without worrying about nuances of the syntax.
Come back and read this chapter fully to excel at AOP.
You can’t become a master database programmer unless you master SQL.
The same applies to AOP—you can’t claim mastery of AOP unless you master the join point model.
The advice in the aspect uses the pointcut you wrote to start and commit or roll back transactions at the selected join points.
The advice uses the collected join point context in its implementation.
For example, if the annotation specifies a read-only property, it may start a read-only transaction.
As you can see, the steps to identify join points and implement a pointcut dominate the process.
A join point is an identifiable execution point in a system.
A call to a method is a join point, and so is a field access.
A for loop or an if statement is a join point, too.
AspectJ deliberately exposes only a subset of all possible join points.
For example, AspectJ exposes join points for a method call and a field access, but not for a loop or an if statement.
Exposed join points are the only places where you can interject crosscutting actions.
The AspectJ join point model encourages you to write robust and maintainable systems by limiting access to more stable program constructs.
In figure 3.1, the UML sequence diagram shows join points in an account transaction, which illustrates some of the places where you can introduce augmentative or alternative crosscutting behavior.
In the sequence diagram, you see several join points that are encountered when an object invokes a debit() method on an AccountService object.
Method calls and execution are some of the most commonly used join points.
Not all the join points in the sequence diagram are shown in the figure.
Its execution encounters join points for the call and execution of the find() method on AccountDao and the debit() method on Account.
Method calls and execution aren’t the only join points; an assignment to a field, such as to the balance of the Account class, is also a join point (not shown in the sequence diagram)
You can write advice to perform an action at these join points.
For example, you can advise the execution of setBalance() to detect and flag a minimum-balance rule violation.
A pointcut is a program construct that selects join points and collects join point context.
As you’ll see shortly, you use types, methods, fields, and annotations as the primary mechanism to define pointcuts.
You can also specify runtime conditions that must be satisfied at a selected join point.
A join point has associated runtime information—called join point context—in the form of objects such as the executing object and the method arguments.
For example, a method call has the caller object, the object on which method is invoked, the arguments, and attached annotations of the method as the join point context.
Similarly, for the exception-handler join point, the current object and the thrown exception form its context.
As you’ll see in chapter 4, certain pointcuts can collect this context and pass it to advice.
Pointcuts use patterns for these signatures to specify the selected join points.
Figure 3.2 shows the relationship between program elements, signature, join points, and pointcuts.
Signature patterns can specify a few wildcards to match a wide range of program elements.
Often, a signature doesn’t offer enough information to specify the selection criterion.
AspectJ offers several pointcuts that use runtime information such as the runtime types of the object involved, their values, and the control flow that led to a join point.
For now, think of control flow as the call stack leading up to the join point.
When you specify a pointcut, the weaver needs to use that information to determine whether a program element matches the specified conditions.
For a pointcut that specifies only a structural matching criteria, the weaver can determine the match during the weaving process without any runtime checks.
Learning about pointcuts becomes easier when you understand various join point categories, as we’ll discuss next.
It’s important to know the join points exposed for a piece of code so that your advice applies properly.
Often, you’ll encounter a situation where selecting the required join point may not seem possible; but a good understanding of the exposed join points may reveal alternative possibilities.
For example, although no exposed join point corresponds to a middle of a method, perhaps a join point corresponding to a call or an exception handler in that method will do the job.
This understanding may also guide your refactoring process so that you can expose the needed join points.
For example, you can use the Extract Method refactoring to pull out the code so you can select join points corresponding to the extracted method.
Let’s take a quick look at the categories of the join points exposed by AspectJ and their semantics.
Table 3.1 shows each available category and the code it represents.
Methodrelated join points represent useful points to add crosscutting behavior.
In this code snippet, the join point for the execution of the debit() method encompasses the whole method body.
This means you can write advice for this join point to be applied before, after, and around the body.
Table 3.1 Overview of join point categories exposed by AspectJ.
Field access Read access Access to read an object’s or a class’s field.
Field access Write access Access to write an object’s or a class’s field.
The method-call join point occurs at the places where a method is being invoked.
The following code shows an example of the method-call join point for the debit() method:
In this code, the call join point is the call to the debit() method.
Note that the code that forms the arguments isn’t part of the join point.
Constructor join points are similar to method join points, except they represent the execution and invocation of object construction.
This join point encompasses the execution of the code within the body of a constructor for an object.
The most important effect of choosing one over the other relates to weaving.
If you advise an execution of a method, the weaver weaves advice into the method body.
But if you advise calls to a method, the weaver weaves all method invocation locations.
Consider a situation in which you need to advise the debit() method in the Account class.
If you want to weave the Account class, you use an execution join point.
If you want to affect only the caller classes, you use a call join point.
If your goal is to issue compile-time errors and warnings, where you may want to detect calls made from some parts of the code, using a call join point is the only choice.
The call join point also lets you collect the caller object’s context—something you can’t do easily with the execution join points.
If you use reflection to invoke a method or constructor, the weaver matches the execution join point the same way as a normal invocation.
But the call join point for the invocation corresponds to the reflection API that you use and not the method or constructor.
If your goal is to advise a method’s behavior, then in the absence of any requirements posed by weaving or other design considerations, you should prefer execution join points.
A typical program has multiple calls to the same method but only one method implementation.
Advice to the call join point, then, leads to weaving in all those places, instead of in just one location, as would be the case for an execution join point.
Similar to the method-execution join point, the execution join point for the Account(int) constructor encompasses the entire constructor body.
If you don’t have an explicit constructor, the constructor join point exposes the automatically supplied default constructor.
Constructor-call join points represent the points that invoke the creation of an object.
The following code shows an example of this join point for the Account object:
In this code, the constructor-call join point is the call to the constructor.
The discussion of choosing an execution or a call join point for a method applies to constructor join points equally well.
Imagine that you need to perform some crosscutting action whenever a field is accessed.
Perhaps the field is cached, and you need to ensure that it contains the latest value before any code reads it.
Or, perhaps you want to mark an object dirty whenever a field in it is modified.
These join points correspond to the read and write access to an instance or class member of a class.
The following code snippet shows field-access join points in the Account class:
In this code snippet, a join point for a field’s read access encompasses reading the field as part of creating the string representation of an object in the toString() method.
The join point for a field’s write access encompasses an assignment to accountNumber in the constructor.
A field access join point is similar to the execution join point for the getter and setter methods for the field, except that the former is present at the field level and doesn’t need those methods.
Therefore, advising field access join points is often a superior approach that doesn’t require implementing getters or setters to achieve functionality such as enforcing validation, implementing object-association constraints, and triggering business rules.
Note that AspectJ exposes access to instance variables as well as class variables (static fields) but not to local variables.
Furthermore, field access join point doesn’t match access through the reflection API.
Imagine that you want to respond to any handled exceptions of certain types.
AspectJ offers exception-handler join points, which represent the handler block (the catch block) of an exception type to make such a crosscutting implementation possible.
Let’s move on to the next join point category from table 3.1
Let’s say you want to perform class-level crosscutting, such as the initialization of class (static) variables.
If there were multiple static blocks, the join point would encompass all of them.
This join point is present even when you don’t have an explicit static block; in those cases, it represents the loading of the class, and you can use it to weave class load-time actions.
Typically, these join points are used with advice that needs to perform certain additional object initialization, such as injecting its dependencies.
For the second constructor, the join point encompasses the assignments in the first and second constructor.
It encompasses the passage from the first called constructor to the beginning of its parent constructor.
Practically, it encompasses calls made while forming arguments to the super() call in the constructor.
So far, we’ve examined join points present in Java programs.
Let’s complete the join point discussion with an additional type that is specific to AspectJ.
Not to be outdone by the standard Java constructs, AspectJ offers one of its own join points, which encompasses the execution of any advice in the system.
You can advise such join points for purposes such as profiling the advice itself or monitoring executions of advice for unit-testing of aspects.
It’s often desirable to avoid advising join points while a join point is being advised, to avoid a sort of recursive condition.
The advice execution along with a control-flow pointcut (see section 3.6.2) helps implement such requirements.
Now that you know all the join points AspectJ offers, let’s create an example to help you understand them.
We’ll use classes from appendix A to demonstrate join points in a program.
First, create a simple driver (listing 3.1) program, which will exercise some of those classes.
Later, you’ll add a simple aspect to trace join points in the system.
Listing 3.2 shows an aspect that prints the information for all join points as the code executes.
Because we haven’t discussed the details of various pointcuts, you’ll use only a within() pointcut along with a negation operator to select all the join points occurring outside the aspect.
You’ll learn more about the within() pointcut later in this.
The before and after advice print the information about the join points selected by the traced() pointcut.
The before advice executes just before each advised join point.
The call depth is the level in the execution stack of method calls.
You use the call depth to get the indentation effect by printing additional spaces corresponding to the call depth before each print statement; this helps you to better understand the output.
In the before advice, you increment the call depth to indicate that you’re going one level deeper into the call stack.
Then, you print the thisJoinPoint object, which contains the text representation of the advised join point.
For the call depth, you perform the action opposite the one in the before advice, because you’re now going one level up in the call stack.
Just as in the before advice, you print the thisJoinPoint object.
What does this demo aspect show you? Let’s look at the output.
When you compile all the classes and the tracing aspect and run the Main class, you get the following output:
The <clinit> part of the output indicates the class initialization.
The output lines that contain execution() and call() show the execution and call join points of a method or a constructor.
The output lines that contain get() and set() show the read and write field access join points.
You can use this code as a starting point for further exploration.
Experiment with it to gain a deeper understanding of the join point model.
Now, let’s move our attention to writing pointcuts to select join points.
AspectJ’s pointcut language is the same in the traditional and @AspectJ syntax.
A subset of the language is also available in the Spring Framework.
Knowing about possible pointcuts and join points selected will help you decide whether to use AspectJ’s weaver-based or Spring’s proxy-based AOP.
You can declare a pointcut inside an aspect, a class, or an interface.
As with data and methods, you can use an access specifier to restrict access to it.
Named pointcuts are elements that can be referenced from multiple places, making them reusable.
Anonymous pointcuts, like anonymous classes, are defined at the place of their usage, such as a part of advice, a part of static crosscutting constructs (discussed in chapter 5), or when another pointcut is defined.
Named pointcuts are recommended and therefore the most commonly used pointcuts.
Figure 3.3 shows the accountOperation() named pointcut that selects calls to any methods in an Account class.
You can use the named pointcut in advice as follows:
A special form of pointcut A special form of named pointcut omits the colon and the pointcut definition following it.
For example, the following pointcut selects no join points (indicating that there are no thread-safe operations):
Such pointcuts are useful to supply an implementation for an abstract pointcut from a base aspect (a topic we’ll cover in chapter 6) that selects no join points.
Think of this form as being analogous to implementing a method with an empty body.
Note that the special form of the pointcut differs from an abstract pointcut only in omitting the abstract keyword.
You define a named pointcut using the pointcut keyword and a name.
The part after the colon defines the selected join points using the pointcut type and signature.
In a few circumstances, a pointcut definition is simple and reusability isn’t a concern.
In those cases, it often suffices to use anonymous pointcuts.
You define an anonymous pointcut at the point of its usage.
Because you can’t reuse such pointcuts, you should avoid using them when the pointcut code is complicated.
You can specify anonymous pointcuts as a part of advice.
For example, advice may use an anonymous pointcut as follows:
You can also use an anonymous pointcut as part of another pointcut.
For example, the following pointcut uses an anonymous within() pointcut to limit the call join points selected by accountOperation() made from classes with banking as the root package:
You can combine both named and anonymous pointcuts using pointcut operators, which lets you create complex selection criteria using simpler pointcut definitions.
Java provides unary and binary operators to form complex conditional expressions by combining simpler conditional expressions.
Unary operator —AspectJ supports only one unary operation—! (negation)—that lets you match all join points except those specified by the pointcut.
The precedence between these operators is the same as in plain Java.
You can use parentheses to override the default operator precedence and make your code more legible.
The program-element signature forms the central construct in a pointcut definition.
After you learn the signature syntax, learning a set of pointcuts (called kinded pointcuts) becomes trivial.
Signature patterns, by themselves, are also helpful in static crosscutting.
Given that crosscutting concerns, by definition, span multiple modules and multiple program elements, the language must provide an economical way to express selection criteria.
The signature syntax in AspectJ uses wildcards to select program elements that share common characteristics.
In a type signature pattern, it denotes a part of the type or package name.
In other patterns, it denotes a part of the name such as the method or field name.
In a type signature pattern, it denotes all direct and indirect subpackages.
In method signature patterns, it denotes an arbitrary number of method arguments.
It may be used only as a suffix to a type signature pattern.
The term type collectively refers to classes, interfaces, annotations, and primitive types.
A type signature pattern specifies a set of types and may use wildcards, unary, and binary operators.
To simplify understanding this topic, we’ll categorize type signature patterns based on how they use Java constructs.
The basic type signature pattern doesn’t use new Java 5 features.
In @AspectJ syntax, you must always use fully qualified names except when specifying types in the same package as the aspect itself.
Account The Account type Only the Account type (not its base types or subtypes)
A new language feature in Java 5 offers a way to attach annotations to program elements.
Let’s see how you can use those annotations in type signature patterns.
Annotations specify metadata (additional data or information) about the element they’re annotating.
For example, a type may carry an annotation such as @Entity that indicates that the type is persistent.
AspectJ allows the use of annotations in type signature patterns.
Because the annotations are types too, the type signature patterns in table 3.2 apply to them as well.
Using annotations in pointcuts is proving to be popular among AOP practitioners.
When used with custom annotations, writing pointcuts becomes an easy task.
For example, you can define the Sensitive annotation as follows:
The annotation defines one integer attribute to indicate the level of sensitivity.
You can then mark all types that represent sensitive information, as shown here:
You can use the annotation in type selection criteria to select all sensitive types.
Retention policy of annotations Annotations used as a part of a statically determinable pointcut must have at least class-retention policy so the compiler retains them in the class file.
Others need runtime retention so the compiler retains them in the class files and the VM makes them available at runtime.
Let’s look at some examples of type signatures using annotations, shown in table 3.3
For example, you can’t declare an annotation type, say BusinessEntity, to extend another annotation type Entity.
Therefore, AspectJ need not (and doesn’t) support the + wildcard with annotation types.
Another major feature in Java 5 is support for generics.
Table 3.4 shows a few examples of type signatures using generics.
Note that the type-pattern complexity seen in the last two rows stems from Java; AspectJ uses the same syntax with the type signature patterns in Java.
The Customer type or its subtypes that carry an annotation of a type whose name starts with Business.
Map<Long,Account> The Map type, with the first generic parameter bound to the Long type and second bound to the Account type.
The Collection type, with a type parameter that carries the Sensitive annotation.
The Collection type, with a type parameter that is Account or extends Account.
The Collection type, with a type parameter that is one of the base type of the Account.
You can combine type signature patterns using unary and binary operators.
Although certain pointcut definitions use a type signature pattern by itself, its more common usage is as a part of method, constructor, and field signature patterns.
These signature patterns identify call and execution join points in methods and constructors.
Method and constructor signatures specify the name, the return type (for methods only), the declaring type, the argument types, and modifiers, as shown in figure 3.4
As you can see in figure 3.4, a method pattern uses the type signature patterns.
Table 3.5 Examples of combined type signatures using unary and binary operators.
Account, Customer, ArrayList (although it extends Collection), and so on.
Secured * Any type that doesn’t carry the Secured annotation.
A method pointcut specifies a method signature pattern that uses type and name patterns.
The portion before the return value contains modifiers, such as public, private, protected, static, and final as well as annotations for the method.
These modifiers are optional, and the matching process ignores the unspecified modifiers.
For instance, unless you specify the final modifier, the matching process selects both final and nonfinal methods that match the rest of the signature.
You can also use the modifiers with the negation operator to specify matching with all but the specified modifier.
When a type is used in the method signature for declaring classes, interfaces, return types, arguments, and declared exceptions, you can specify the type signatures discussed in tables 3.2–3.5 in place of specifying exact types.
Note that if a pattern matches a base type method, it also matches the overridden implementations of the same method in subclasses.
Any public method in the Account class with the name starting with set that returns void and takes a single argument of any type.
This match is performed regardless of other modifiers, such as static and final, as well as any annotations associated with the method.
This matches methods with public, private, protected, and the default access.
All methods in the previous three rows as well as methods in Account such as protected void debit(double amount)
Any method regardless of return type, defining type, method name, and arguments.
This matches any method with private, protected, or default access.
Any read() method in the Reader class, regardless of the type and number of arguments to the method, as long as the first argument type is char[]
Any method whose name starts with add and ends in Listener in the javax package, or any of the direct and indirect subpackages, that takes one argument of type EventListener or its subtype.
If a subclass overrides the method that declares to return a subtype of Account (using the covariant return type feature in Java 5), that is also selected.
If you’re using Java 5, you can use the annotations associated with methods by specifying annotation-based matching criteria in signatures.
AspectJ supports selecting methods based on the annotations they carry.
Table 3.7 shows examples of method selection based on annotations.
Table 3.7 Examples of method signature patterns based on annotations.
Any method that returns a type marked with an @Sensitive annotation.
Any method defined in a type annotated with the @BusinessEntity annotation.
All methods in Account and Customer, if these types are annotated with the @BusinessEntity annotation.
Note the use of parentheses around that last * to group the parameter type.
Note that you can use types with generics (as shown in table 3.4) for the type portions in method signatures.
Constructors, owing to their similarities to methods, follow the method signature patterns closely.
A constructor signature differs from a method signature in three ways:
Because constructors don’t have a return value, it doesn’t allow the return-value specification.
Because constructors don’t have names as regular methods do, you need to substitute new for the method name in a signature.
Because constructors can’t be declared static, you may not use the static keyword.
For example, the public constructor of the Account class, taking no arguments, has the signature public Account.new()
Due to the strong resemblance between method and constructor signatures, for brevity’s sake, we don’t show examples in a table.
We’ll complete the discussion of signature patterns with patterns for the fields defined in types.
Much like a method signature, a field signature allows you to designate a member field.
You can then use field signatures to select join points corresponding to read or write access to the specified fields.
A field signature must specify the field’s type, the declaring type, and the modifiers.
You can use type-signature patterns to specify the types involved.
Figure 3.5 shows how a field pointcut uses a field-signature pattern.
Any method with one parameter whose type carries the @Sensitive annotation.
Table 3.7 Examples of method signature patterns based on annotations (continued)
A field-access pointcut selects read (get) or write (set) access to fields matching the specified a field signature pattern that, in turn, uses type and name patterns.
As with a method signature, modifiers (access specification, static, and final) are optional.
Omitting a modifier selects fields without consideration for the omitted modifier.
The basic field signature, like a method signature, sticks to pre–Java 5 features.
Let’s dive straight into a few examples in table 3.8
You can enhance a field signature by specifying annotations associated with the field in addition to other selection criteria.
In addition to types and methods, Java 5 also supports annotating fields.
For example, in the following code, the field id is marked with the @Id annotation:
Private (instance or static) field balance of the Account class.
Account.* Any field of the Account class, regardless of access modifier, type, or name.
Account+.* Any field of the Account class or its subclasses, regardless of access modifier, type, or name.
As with method signatures, you can use types with generics in field signatures.
Now that you understand the syntax of the signatures, you’re ready to use them in.
That will prepare you to write useful aspects in your application.
AspectJ offers several pointcut designators, which when combined with the signatures discussed in the preceding section, form pointcuts.
Kinded pointcuts —Pointcuts that directly map to join point categories or kinds, discussed in section 3.2, to which they belong.
For example, AspectJ offers a pointcut designator to match method executions.
Non-kinded pointcuts —Pointcuts that select join points based on information at the join point, such as runtime types of the join point context, control flow, and lexical scope.
These pointcuts select join points of any kind as long as they match the prescribed condition.
Some of the pointcuts of this type also allow the collection of context at the selected join points.
By learning about various signature patterns, you’ve already traveled half way toward the goal of understanding kinded pointcuts.
Kinded pointcuts follow a specific syntax to select each kind of exposed join point in AspectJ.
When you understand the categories of exposed join points and signature syntax, you’ll find that understanding kinded pointcuts is simple—all you need is their syntax.
Table 3.10 shows the syntax for each of the kinded pointcuts.
If the type MedicalRecord is marked with the Sensitive annotation, this pattern selects any field of the MedicalRecord type.
Fields such as diagnosis and treatment in the MedicalRecord type (assuming MedicalRecord is annotated with @Sensitive)
Table 3.9 Examples of field signature patterns with annotations (continued)
Kinded pointcuts at a glance Selects—Join points of the specified kind and signature.
Similarly, to select any write access to the balance field of type double and with private access in the Account class, you write a set() pointcut as follows: set(private double Account.balance)
Table 3.10 Mapping of exposed join points to pointcut designators.
You can’t have a join point that is simultaneously both execution and call.
Remember, a call is on the caller side, whereas execution happens on the receiver side—they’re two completely different places.
You can’t have a join point of multiple kinds; and creating a pointcut to match different kinds always leads to no match.
You can avoid this common mistake by remembering a simple rule: don’t combine two pointcuts of different kinds with the && operator.
Another common newbie mistake is to be misled by &&
In our example, it’s a mistake to read the pointcut as “Select executions of Account methods and calls to Account methods.” The correct way to read this pointcut is, “Select join points that match both conditions: it’s an execution of an Account method and it’s a call to an Account method.”
Now that we’ve examined the kinded pointcuts, let’s look at the other type of pointcut: the kind that selects join points based on specified conditions regardless of the kind of join point.
This type of pointcut offers a powerful way to express certain complex weaving rules.
Non-kinded pointcuts select join points based on criteria other than the signature of the join point.
For example, with non-kinded pointcuts, you can select all join points occurring inside a class or all join points where the this object is of a certain type.
In each case, the selected join points may include method executions, calls, exception handlers, field accesses, and so on, as long as they match the specified criteria.
In other words, these pointcuts don’t consider the kind of join point during selection—hence the name.
AspectJ offers non-kinded pointcuts based on a program’s control flow and its lexical structure, execution object, arguments, annotations, and conditional expressions.
These pointcuts select join points occurring in the control flow of join points selected by another pointcut.
The control flow of a join point defines the flow of the program instructions that occur as a result of the invocation of the join point.
Think of control flow as similar to a call stack.
A join point can have only one kind (continued) If you read it this way, the error is easily apparent.
Remember another simple rule: pointcuts specify a selection criterion that every matching join point must satisfy.
This pointcut correctly reads, “Select join points that match either condition: it’s an execution of an Account method or it’s a call to an Account method.”
Spring and non-kinded pointcuts As we mentioned earlier, Spring supports only one kind of join point: method execution.
But it supports many ways to select those join points.
Obviously, it supports the execution() pointcut, which specifies method signatures.
It also supports a few pointcuts based on lexical structure, execution object, arguments, and annotation.
Chapter 9 provides a detailed look at what Spring supports; but where appropriate, this chapter also indicates the pointcuts supported by Spring.
In a similar manner, other methods, field access, and exception handler join points also occur in the control flow of the method’s join point.
The sequence diagram in figure 3.6 shows the graphical representation of the cflow() and cflowbelow() pointcuts.
Control-flow based pointcuts at a glance Selects—Join point in control flow or below of join points selected by the specified pointcut.
Figure 3.6 Control-flow based pointcuts select every join point occurring in the control flow of join points matching the specified pointcut.
The cflow() pointcut includes the matched join point, whereas cflowbelow() excludes that join point.
Table 3.11 shows some examples of using control-flow based pointcuts.
The control flow leading up to a join point is a runtime concept determined by the path taken during program execution.
Consequently, cflow() and cflowbelow() pointcuts can’t be determined at compile time.
Because only the lexical structure is considered during evaluation of the selection criteria, unlike with cflow() and cflowbelow(), these pointcuts are statically determinable.
All join points in the control flow of execution of any debit() method in Account, including the execution of the debit() method.
All join points in the control flow of execution of any debit() method in Account, but excluding the execution of the debit() method.
All join points in the control flow of execution of any method marked with the @Transactional annotation.
Idiom: top-level join point One common usage of cflowbelow() is to select top-level, nonrecursive join points.
In other words, it selects the outermost transacted method, where typically you’ll start and stop transactions.
These pointcuts select join points based on the types of the objects at execution time.
The pointcuts select join points that match either the type of this, which is the current execution object, or the target object, which is the object on which the method is being called.
Any join point inside the lexical scope of any debit() method of the Account class including inside any local classes.
Idiom: avoiding the advising of aspect elements One common usage of the within() pointcut is to exclude the join points in the aspect.
For example, the following pointcut excludes the join points inside TraceAspect:
It selects join points that have a this object associated with them that is of the specified type or the specified ObjectIdentifier’s type.
In other words, if you specify Type, it matches the join points where the expression this instanceof <Type> is true, leading to matching subtypes as well.
The form of this pointcut that specifies ObjectIdentifier collects the this object so you can use that object in advice.
The target() pointcut is normally used with a method-call join point, and the target object is the one on which the method is invoked.
In addition to matching the join points, these pointcuts can collect the context at the specified join point.
So, you can’t use the any wildcards while specifying the type.
AspectJ can optimize pointcuts such as this() in certain scenarios to avoid runtime checks (effectively determining them statically)
But such pointcuts still can’t be used in static crosscutting, and thus we classify them as statically non-determinable.
Execution object pointcuts at a glance Selects—Join points matching this or the target type.
Supports target() with somewhat different semantics to accommodate the proxy-based implementation.
The forms that specify types restrict the join point selection based on the types of the appropriate objects at a join point.
On the other hand, the forms that specify object identifiers restrict the join point selection based on the types of the object identifiers in addition to making the appropriate objects at the join point available to the advice.
Further, due to Java’s use of erasure for generics implementation, AspectJ doesn’t allow the type pattern for these pointcuts to be a generic type along with its parameters.
However, you may specify a generic type without the parameters such target(List)
Because static methods don’t have the this object associated with them, the this() pointcut won’t select the execution of such a method.
Similarly, because static methods aren’t invoked on an object, the target() pointcut also won’t match calls to such a method.
There are a few important differences in the way within() and this() perform matching.
The former matches when the object in the lexical scope matches the type specified in the pointcut, whereas the latter matches when the current execution object is of a type that is specified in the pointcut or its subclass.
The code snippet that follows shows the difference between the two pointcuts.
The SavingsAccount class extends the Account class, and the Account class contains a nested Helper class:
In this example, within(Account) selects any join point in the Account class, including any nested classes, but no join points inside its subclasses, such as SavingsAccount.
On the other hand, this(Account) selects any join point in the Account class as well as SavingsAccount, but excludes any join points inside either class’s nested classes.
This selects all join points, such as methods calls and field assignments, where the current execution object is Account or one of its subclasses: for example, SavingsAccount.
This selects all join points where the target object is Account or one of its subclasses: for example, SavingsAccount.
Implementing pointcuts all the instance and static methods defined in the Account class, whereas the latter picks up the instance methods in the class hierarchy of the Account class but none of the static methods.
These pointcuts select join points based on the argument object’s runtime type of a join point.
Objects considered as argument objects differ depending on the join point kind:
For method and constructor join points, the argument objects are the method and constructor arguments.
Note that the selection is based on runtime type (similar to the this() or target() pointcuts) and not the declared type in program element.
This matches methods such as print(Object, float, int) as long as the first argument passes the instanceof Account test.
It matches a method or constructor taking a single RemoteException argument, a field-write access setting a value of type RemoteException, or an exception handler of type RemoteException.
Idiom: selecting join points only in subclasses You can match all the join points only in subclasses of a type by using the this(Type) && !within(Type) idiom.
You can also use the within(Type+) && !within(Type) pointcut, but it also selects join points in the nested classes in the subclasses.
Argument pointcuts at a glance Selects—Join points matching argument types.
With Java 5, the use of annotations is proving to be a popular choice.
AspectJ allows selection based on annotations carried by types, methods, and fields.
Like the execution object and argument pointcuts, annotation-based pointcuts come in two forms: selection based on matching annotation types and collection of the matching annotation.
Table 3.15 summarizes these pointcuts and explains the version that performs only selection without collecting the matching annotation.
We’ll discuss the version that collects the matching annotation in the next chapter.
Any join point where the this object’s type carries the annotation of the TypePattern type.
Any join point where the target object’s type carries the annotation of the TypePattern type.
Any join point where the arguments’ type carries annotations of the TypePattern.
Any join point in the lexical scope of a type that carries an annotation matching the specified TypePattern.
Any join point where the matching program element (method or constructor) carries an annotation matching the TypePattern.
Any join point where the subject carries the specified annotation.
For method, constructor, and advice-execution join points, the subject is the same as the program element.
For field-access and exceptionhandler join points, the subject is the field or exception being accessed.
For initialization and pre-initialization join points, the subject is the first called constructor matching the specified signature.
For static initialization join points, the subject is the type being initialized.
Annotation based pointcuts at a glance Selects—Join points based on annotations.
Note that the annotations used in a statically determinable pointcut in table 3.15 must have either class or runtime retention, whereas annotations used in the remaining pointcuts must have runtime retention.
So far, we’ve explored pointcuts that use join point signatures.
AspectJ also offers a way to select based on arbitrary conditions.
This pointcut selects join points based on some conditional check at the join point.
Table 3.16 shows some examples of using conditional check pointcuts.
The if() pointcut is often combined with other pointcuts to selectively apply dynamic crosscutting.
The real innovation in AspectJ is the pointcut expression language; it’s powerful, expressive, and well thought out.
Although we focused solely on AspectJ’s pointcut language, you’ll find that applying it to other AOP systems such as Spring and JBoss AOP is easy—the concepts remain the same, even though different mechanisms are used.
Furthermore, in Spring 2.0, you can use the AspectJ pointcut expressions directly without using the AspectJ weaver.
All the join points occurring after the current time has crossed the triggerTime value.
The circle object must be a context collected by the other parts of the pointcut or a static field in the defining aspect.
Conditional check pointcuts at a glance Selects—Join points matching a condition.
AspectJ’s pointcut support offers many possibilities to facilitate writing good pointcuts:
You can write pointcuts exploiting program elements’ core components such as name, defining types, and access modifier.
If you use generics, you can specify those to further restrict in your selection criteria.
You can also use dynamic conditions such as runtime types involved at the join point as well as the control flow that led to the execution of the join point.
You can also use annotations associated with the join points.
During your initial exploration of AOP, annotation-based crosscutting will be particularly attractive.
If the program elements of your interest carry annotations, it’s trivial to define a pointcut based on those annotations.
For some developers, AspectJ’s pointcut language may seem daunting at first.
When I give talks introducing AOP, I often show a few examples of simple pointcuts, explain the wildcards for a couple of minutes, and then ask attendees to tell me pointcuts for more complex selection.
The reason for such a good response is the consistent nature of the AspectJ language; when you understand the basics, complex patterns become obvious and intuitive.
Now that you know how to write type, method, and field signature patterns and how to utilize them in pointcuts to select the relevant join points, you’re ready to put them to good use.
In the next chapter, we’ll discuss dynamic crosscutting, where additional or augmentative behavior is associated with the selected join point.
In the previous chapter, we presented the join point model and examined the pointcut construct as the way to select join points of interest.
In this chapter, you’ll put that knowledge to practical use as we discuss dynamic crosscutting.
Dynamic crosscutting constructs provide a way to affect the behavior of a system, whereby you can alter behavior at join points selected by pointcuts.
After reading this chapter, you should be able to start writing meaningful programs in AspectJ.
Although the details vary a bit, all of these syntaxes share a common base.
After you learn the traditional syntax, you can easily learn the @AspectJ syntax.
Spring-AspectJ integration also uses many of the same base constructs, so when you know an AspectJ syntax form, you can easily apply it in Spring.
In this chapter, we’ll continue to focus on the traditional syntax.
Dynamic crosscutting weaving rules consist of two parts: advice (what to do) and pointcuts (when to apply the advice)
AspectJ supports dynamic crosscutting through advice—a method-like construct that defines crosscutting action at the join points selected by a pointcut.
We’ll begin with discussing three kinds of advice followed by the general anatomy of advice.
If you’re implementing a security check, you want that check to take place before executing the join point.
On the other hand, if you’re implementing exception logging, you want to log after executing the join point and only if it threw an exception.
If you’re implementing caching, you want to surround the original code with the caching logic: obtain a value from the cache, execute the original code if the cache doesn’t contain a value, and add the value to the cache after executing the original code.
To take care of all these scenarios, AspectJ offers three kinds of advice:
Join points exposed by AspectJ are the only points where you can apply advice.
Figure 4.1 shows various join points in an execution sequence at which you can introduce a new behavior via advice.
Let’s see how you can implement each kind of advice.
Although details vary, all instances of advice share a good portion of syntax.
Let’s look at the general syntactical structure of an advice.
Advice declaration —Specifies if the advice will run before, after, or around the join points.
Before we show an example, let’s review the pointcut that you’ll use in an advice:
The part before the colon is the advice declaration, which specifies when the advice executes relative to the selected join point—before, after, or around it.
The advice declaration also specifies the context information available to the advice body, such as the execution object and arguments, which the advice body can use to perform its.
Figure 4.1 Various points in a program flow where you can advise the join point (not all possible points are shown)
It also specifies any checked exceptions thrown by the advice.
A before() or after() advice doesn’t declare a return type, but an around() advice declares the return type.
The part after the colon is the pointcut; the advice executes whenever a join point matching the pointcut is encountered.
You can use an advice not just with methods but also with any other kind of join point.
For example, you can advise a constructor invocation, field write-access, exception handler, and so forth.
Just like a method body, the advice body contains the actions to execute.
In the example, the around advice prints the time elapsed during advised connection operations.
In around advice, the proceed() statement is a special syntax to carry out the advised operation, as we’ll examine in section 4.3.3
This makes sense because you never call advice directly; it’s the system’s responsibility to execute the advice body upon reaching the selected join points.
But you can assign advice a name using a special annotation.
For example, you can use the following snippet to assign profileConnection as the advice name:
Tools such as aspect-aware unit-testing frameworks may also use the name of the advice.
Looking at the advice construct, you’re probably thinking that it looks an awful lot like a method.
Because advice and methods both express behavior, AspectJ keeps advice syntax close to that of methods.
But because advice logic applies automatically in a crosscutting manner instead of through explicit calls to a method, there are some differences.
Let’s compare the three categories of similarities: declaration, body, and behavior.
The advice declaration part looks much like a method signature:
Advice behaves in a similar way to a method overriding the advised join point—it can augment or alter the overriding methods behavior.
Can’t declare that it may throw a checked exception that isn’t already declared by all advised join points.
The weaver will issue an error if this condition isn’t met.
For example, you aren’t allowed to declare that the advice may throw SQLException unless all the advised methods declare that they throw it.
May omit a few checked exceptions declared by the advised join points.
For example, if all advised join points throw IOException and SQLException, an advice may declare that it can throw only one of them.
May declare that it can throw more specific checked exceptions than those declared by the advised join points.
May use the keyword proceed in around advice to proceed with the advised join point.
Let’s look at each kind of advice in more details.
Armed with information about the advice classification and general syntax, it’s a good time to dive deeper into each type of advice.
In this section, we’ll start with the simplest kind of advice: before.
Then, we’ll look into all variations of the after advice followed by the around advice.
Before advice executes before the execution of the advised join point.
In the following code snippet, the advice performs authorization prior to the execution of any method annotated with the @Secured annotation:
If you throw an exception in the before advice, the advised operation won’t execute.
For example, if the authorization logic in the previous advice throws an exception, the advised method won’t execute.
Before advice is typically used for performing preoperation tasks, such as policy enforcement, tracing, and security.
After advice executes after the execution of a join point.
Because it’s often important to distinguish between normal returns from a join point and those that throw an exception, AspectJ offers three variations of after advice:
The following code snippet shows the basic form of after advice that executes regardless of the join point’s outcome: returning normally or throwing an exception.
This plain form of the after advice is often referred to as after (finally) advice due to its behavioral resemblance to a finally block, which executes regardless of the outcome of the corresponding try block:
This advice executes after any call to any method in the Account class, regardless of how it returns—normally or by throwing an exception.
You often need to apply advice only after a successful completion of advised join points.
AspectJ offers after returning advice that is executed after the successful execution of join points.
The following code shows the form for after returning advice:
This advice executes after the successful completion of a call to any method in the Account class.
If the advised method throws an exception, the advice doesn’t execute.
AspectJ offers a variation of the after returning advice that collects the return value.
You can use the collected return object in the advice as shown in figure 4.2
Although you can modify the collected return object (for example, remove elements from a collection), there is no way to return a new object.
If you need such possibility, you’ll have to use the around advice.
You then use the return object in the advice body to print its value.
After advice implicitly limits join point selection to only those that are compatible with the specified return type inside returning()
Another variation of the after advice advises join points upon throwing an exception.
Similar to after returning advice, AspectJ offers after throwing advice.
Such advice executes only when the advised join point throws an exception.
The following code shows the form for after throwing advice:
This advice executes after execution of any method in the Controller class or its subtype (note the +) if it throws an exception.
Similar to the variation of the after returning advice, AspectJ offers a variation of the after throwing advice that captures the thrown exception object.
You can use this form of the after throwing advice when you want to collect the exception thrown by the advised method so that you can use it in the advice body.
In figure 4.3, you collect the exception thrown by any method by specifying the exception type and.
Figure 4.2 Passing a return object context to an advice body.
The return object is collected in returning() by specifying the type and object identifier.
Much like the return value and any other context, you can use this exception object in the advice body.
Note that thisJoinPoint is a special type of variable that carries join point context information.
We’ll look at these types of variables in section 4.5
Similar to the after returning type, the selected join points are implicitly limited to the join points that throw exceptions compatible with the type specified inside throwing()
Unless the after throwing advice itself throws an exception, the original exception processing continues up the call stack.
Specifically, after throwing advice can’t swallow an exception, and the caller of the join point receives the exception thrown by the join point.
Now, let’s move on to the omnipotent around advice that is capable of implementing all other types of advice.
It has the ability to execute the join point with the same or different context any number (including zero) of times.
This implies that an around advice may bypass the advised join point or execute the advised join point multiple times, each with different context.
Perform additional logic before and after the advised join point (for example, profiling)
Bypass the original operation and perform some alternative logic (for example, caching)
Surround the operation with a try/catch block to perform an exceptionhandling policy (for example, transaction management)
Around advice is the most potent form in that it can be always used instead of before or after advice; but in order to precisely express programming intent, it’s best to use the simplest form of advice appropriate for the task.
Around advice has explicit control over the advised join point’s execution.
Unless you call proceed(), the advised join point is bypassed.
When using proceed(), you can pass the context collected by the advice, if any, as the arguments; or you can pass a different set of arguments.
The important thing to remember is that you must pass the same number and types of arguments as collected by the advice.
Figure 4.3 Passing a thrown exception to an advice body.
The exception object is captured in throwing() by specifying the type and object identifier.
Advice may access the special variables such as thisJoinPoint in a similar manner to the this variable inside an instance method.
Advice in depth of the advised join point, it returns the same value returned by the advised join point.
For example, advising a method that returns a float value, invoking proceed() returns the same float value as the advised method.
We’ll discuss the details of returning a value from an around advice later in this section.
In the following snippet, the around advice invokes proceed() with a try/catch block to handle exceptions.
This snippet also collects the context of the operation’s target object and argument.
The target() and args() pointcuts collect join point context: the account and the amount.
The result is that when the advice is executed, it in turn executes the advised method using proceed()
Each around advice must declare a return value (which can be void)
It’s typical to declare the return type to match the return type of the advised join points.
For example, if you advise a set of methods that are returning an integer, you declare the advice.
But the overall theme is consistent with the concepts presented here.
For a field-read join point, you match the advice’s return type to the accessed field’s type.
In some cases, an around advice applies to join points with different return types.
For example, if you advise all the methods needing transaction support, the return values of all those methods are likely to be different.
To resolve such situations, the around advice may declare its return value as—catch all—Object.
In those cases, AspectJ accommodates return types in the following manner:
If a join point returns a primitive type, AspectJ boxes it in its corresponding wrapper type and performs the opposite, unboxing after returning from the advice.
For instance, if a join point returns an integer and the advice declares that it will return Object, AspectJ boxes the integer value in an Integer object and returns it from the advice.
Upon assignment of such a value, the object is first unboxed to an integer.
If a join point returns a non-primitive type, AspectJ performs appropriate typecasts before assigning the return value.
The scheme of returning the Object type works even when a captured join point returns a void type.
Note that the AspectJ weaver issues an error if you specify a return type that isn’t compatible with any of the advised join points.
Invoking proceed() returns the value returned by the join point.
Unless you need to manipulate the returned value, you can return the value that was returned by the proceed() statement.
If you don’t invoke proceed(), you must still return an appropriate value.
An around advice, like other advice, must declare any checked exceptions it throws during advice execution.
But any exception thrown by calling proceed() need not be declared.
When you’re advising join points that all throw the same exceptions, this works fine.
But in situations such as transaction management, selected join points throw a variety of exceptions, and an around() advice may need to catch the thrown.
Advice in depth exception and rethrow the caught exception after taking some action.
This need, combined with the rules governing which exceptions an advice may declare, make the situation complicated.
In these cases, you need to use other techniques, including throwing a runtime exception or wrapping the original exception.
Let’s look at an example that uses around advice to handle failures.
In a distributed environment, dealing with a network failure is often an important task.
The following example examines how an aspect with around advice can implement the functionality to handle a network failure.
Listing 4.1 simulates the network and other failures by making the method throw an exception randomly.
This example doesn’t use Spring to create proxies, because the local invocation suffices for illustration.
Let’s also create an annotation type (as shown in listing 4.2) that you can use to denote idempotent methods—operations that may be retried safely.
Listing 4.2 Marker annotation to denote methods that may be retried.
Next, let’s write a simple client (listing 4.3) that invokes the idempotent method in RemoteService.
Now, let’s write an aspect to handle failures by reattempting the operation three times before giving up and propagating the failure to the caller (listing 4.4)
You declare that the around advice returns Object to accommodate potential different return value types in the selected join points.
The pointcut part of the advice uses an anonymous pointcut to select calls to all methods with the @Idempotent annotation.
You return the value returned by the invocation of proceed()
Although the join point is returning an int, AspectJ takes care of the boxing and unboxing logic.
When you compile and run the program, you get output similar to the following:
The output shows a few failures, some retries, and eventual success.
Your output may be different due to the randomness introduced.
It also shows the correct assignment to the retVal member in the RemoteClient class, even though the advice returned the Object type.
In chapter 3, we alluded to an important function of a pointcut: collecting join point context.
Now is a good time to understand how pointcuts collect context so that you can use it in dynamic crosscutting.
The permission-check logic needs access to the method and objects involved—referred to as join point context—to make a decision if the caller possesses the authority to access the objects.
Pointcuts, therefore, need to expose the context at the point of execution to pass it to the advice implementation.
AspectJ provides the this(), target(), and args() pointcuts to collect the objects at the advised join points.
You’ll recall from chapter 3 that you can specify each of the context-collecting pointcuts two ways:
When advice needs the join point context, you use a pointcut that uses the ObjectIdentifier.
The advice declares the collected objects in much the same way as a method would—each argument specifies a type and name.
Then, you use pointcuts to bind each argument to a join point context.
For example, in figure 4.4, the anonymous pointcut in the before advice declares all the arguments to be collected by the pointcut.
The declaration for collected context specifies the type of each collected object.
The target() pointcut specifies account as the object identifier for the collected object, whose type is specified in the pointcut declaration as Account.
For example, in figure 4.4, the matched join points are limited to target (Account), because the type of the account identifier is Account.
This restricts any matching to join points, where the target object is of the Account type (even if you omitted the call() portion of the pointcut expression)
Figure 4.4 shows an example of collecting join point context and using it in an advice.
The target() pointcut collects the objects on which the credit() method is being invoked, whereas the args() pointcut collects the argument to the method.
The part of the advice before the colon specifies the type and name for each of the collected arguments.
The body of the advice uses the collected context in the same way that the body of a method would use the parameters passed to it.
The object identifiers in the code in the figure are account and amount.
When you use named pointcuts, those pointcuts must collect the context and pass it to the advice.
The pointcut creditOperation(), besides selecting join points, collects the context so that the advice can use it.
You collect the target object and the argument to the credit() operation.
Note that the pointcut declares the type and name of each collected element, much like a method call.
The names of the arguments in the first part of the advice match those in the pointcut definition.
In figure 4.6, you collect the security annotation associated with the method and use its property to perform authorization.
As we discussed earlier in this section, when you’re collecting context, an implicit restriction on matched join points limits you to only those that can satisfy the collected context.
In this example, only join points that carry an @Secured annotation.
Figure 4.5 Passing an executing object and an argument captured by a named pointcut.
This code snippet is functionally equivalent to figure 4.4 but uses a named pointcut.
For the advice to access the join point’s context, the pointcut must collect the context, as opposed to the advice collecting the context when using anonymous pointcuts.
Figure 4.4 Passing an executing object and an argument context from the join point to the advice body.
The target object in this case is collected using the target() pointcut, whereas the argument value is collected using the args() pointcut.
After you collect the annotation, you can use it like any other object; specifically, you can access annotation properties.
In figure 4.6, you access the permission property to perform an authorization check.
Let’s look at all available pointcuts that let you collect the required context.
For a method call join point, the target object is the object on which the method is being invoked.
For a method-execution join point, the target object is the this object (the same as that collected using this())
For field-access join points, the target object is the object whose field is being accessed.
For method-call or -execution and constructor-call or -execution join points, it collects the arguments to the method or constructor.
For field-modification join points, it collects the new value being set.
Figure 4.6 Collecting the annotation associated with the join point.
Here, you collect the annotation associated with the advised method.
After it’s collected, the annotation can be used like any other object.
This requirement is common to any runtime usages of annotations (such as through reflection) and not specific to AspectJ.
Let’s utilize the context-collecting functionality in an example that implements a simple caching strategy.
Consider a stock-market service that provides charts for a given stock for a given number of preceding days.
The service computes the contents for the chart (such as a GIF or PNG file’s content), given the ticker symbol for the stock.
Assume that creating a chart is an expensive operation, and you’d like to cache the chart.
Notice the use of an annotation to indicate the methods whose return values may be cached.
In order to develop an aspect based only on the constructs you’ve learned so far, let’s make a series of assumptions (some of them not realistic—we’ll revisit the solution later in this chapter and again in chapter 6)
First, we assume that the cached methods take only one argument.
Second, we assume that a concatenation of the cacheStorage attribute (in annotation) and the method argument form the cache key.
Now, let’s develop an aspect that implements caching in such scenarios.
You could modify the solution to use any other product, such as EHCache, Oracle Coherence, or even a good-old in-memory.
Regardless, the aspect must advise any cached operation, compute the cache key, and query the cache with that key.
If it finds a cached value, it needs to return it and bypass the original operation.
Otherwise, it must proceed with the advised method and put its return value in the cache.
An around advice fits the bill, given the need to potentially bypass the original operation.
The cachedAccess() pointcut selects the execution of methods that take a single argument and are marked @Cachable.
It collects the argument to the method using the args() pointcut.
To accommodate arguments of various types, including primitives, you declare the collected argument’s type as Object.
It also collects the annotation to the method using the @annotation() pointcut.
It declares that it uses the context collected by the pointcut by declaring the advice parameters.
In the advice body, if the argument to the advised method is null, it calls proceed() to continue with the original method.
This ensures that the advice doesn’t alter the behavior of a call when it can’t effectively deal with it.
First, it computes the cache key by appending the argument to the cacheStore attribute of the annotation; this forms keys such as Chart:GOOG.
Next, it tries to retrieve the cached value for the key.
If not (detected by caching exception), it calls proceed() to continue with the advised method and puts the return value in the cache before returning it.
Recall that the number and type of arguments to proceed() must match the advice declaration.
Let’s write a simple tracing aspect so that you can see the effect of the aspect in action.
Listing 4.8 shows an aspect that produces a trace on cache hits and misses.
Finally, let’s write a simple class that exercises the service, as shown in listing 4.9
When you compile and run the code using the build script supplied with the downloadable sources, you get the following output:
As soon as the aspect finds a cached value, it uses that value instead of recomputing.
AspectJ offers an alternative way to collect context through the special variables available in each advice.
AspectJ offers an alternative way to access the static and dynamic context associated with the join points through a reflection API.
For example, through this API, you can access the name of the currently advised method as well as the argument objects to that method.
The most common use of this reflective information is to implement tracing and similar aspects.
In this section, we’ll examine the details of reflection support.
These objects are much like the special variable this that is available in each instance method in Java to provide access to the execution object.
The information contained in these three objects is of two types:
For example, the name and source location of a method remain the same during different invocations of the method.
Dynamic information —Changes with each invocation of the same join point.
For example, two different calls to the method Account.debit() will probably have different account objects and debit amounts.
Testing an aspect Ideally, you should write a test for your aspect so you can run it automatically.
Developing such tests, however, require injecting a mock or stub object in the CacheAspect instance to set its cache property.
Then we can control and observe interaction with the cache property to verify correctness.
We haven’t yet examined the mechanism to access an aspect instance that you need to in order to inject dependencies.
You’ll learn that mechanism in chapter 6, where you’ll improve this aspect and write tests for it.
Each join point provides one object that contains dynamic information and two objects that contain static information about the join point and its enclosing join point.
Let’s examine the information in each of these special objects:
It gives access to the target object, the execution object, and the method arguments.
Through these objects, you can access annotations associated with their types as well.
It also provides access to the static information for the join point, using the getStaticPart() method.
You use thisJoinPoint when you need dynamic information related to the join point.
For example, if you want to log the execution object and method arguments, you use the thisJoinPoint object.
It gives access to the source location, the kind (method-call, method-execution, field-set, field-get, and so forth), and the signature of the join point.
The enclosing context of a join point depends on the kind of join point.
For example, for a method-call join point, the enclosing join point is the execution of the caller method, whereas for an exception-handler join point, the enclosing join point is the method that surrounds the catch block.
For example, while logging an exception, you can log the enclosing context information as well.
To use the special variables available in advice, you need to know the API for the associated types.
The reflection API in AspectJ is a set of interfaces that together form the programmatic access to the join point information.
These interfaces provide access to dynamic information, static information, and various join point signatures.
In this section, we’ll examine these interfaces and their relationship with each other.
Figure 4.7 shows the structural relationship between the interfaces of the reflection API in a UML class diagram.
This object provides access to the join point’s static information.
This static information consists of the join point’s kind, signature, and source code location.
The Signature object provides access to the join point’s signature, and the SourceLocation object provides access to the join point’s source-code location.
Figure 4.7 The structural relationship among various interfaces supporting reflection.
Now, let’s examine the API for accessing dynamic join point information.
This interface provides access to the dynamic information associated with the currently advised join point.
It specifies two methods for obtaining the currently executing object, target object, and arguments, as well as the static information:
The getThis() method returns the currently executing object, whereas the getTarget()method is used to obtain the target object for a called join point.
The getThis() method returns null for join points occurring in a static method, whereas getTarget() returns null for the calls to static methods.
For method and constructor join points, getArgs() returns an array of each element referring to each argument in the order they’re supplied to the join point.
The AspectJ weaver wraps each primitive argument in the corresponding wrapper type.
For example, it wraps an int argument in an Integer object.
For field-set join points, the new value of the field is available in getArgs()
For field-get join points, getArgs() returns an empty array, because there is no argument for the operation.
Although there is no direct API to obtain annotations, you can obtain the corresponding objects through the reflection API and then use Java’s reflection API to access annotations.
In addition to providing access to the dynamic information, the JoinPoint interface offers direct access to the static information of the advised join point.
There are two ways to obtain the static information through the thisJoinPoint variable of type JoinPoint:
Let’s move our attention to accessing join point’s static information.
This interface allows the API to access the static information associated with the currently advised join point.
It specifies three methods to obtain the kind of join point, the join point signature, and the source location information corresponding to code for the join point:
The JoinPoint interface defines one constant for each of the available kinds of join points.
The SourceLocation interface contains a method for accessing the source filename, line number, and so forth.
Therefore, using dynamic information is expensive compared to static information.
You should be aware of this fact while designing aspects such as tracing.
To demonstrate the use of reflection APIs, let’s modify the caching example from section 4.4.2
Recall from the caching example in section 4.4.2 that we made a series of assumptions.
Particularly onerous ones were that cached methods take only one argument and that the argument would be sufficient to form the key.
Alas, the real world doesn’t confirm to such assumptions: methods routinely take more than one argument, and a key may need to be a complex composition of arguments.
For example, if the arguments to a method that retrieves a statement are of type Account and duration, forming the cache key may require composing the account id (but not its balance) and duration.
Now that you know more about join point context, you can improve the solution.
The important mechanism we’ll introduce in the new solution is using annotations to support specifying a script that computes the key and letting the script use the join point context.
For example, the modified StockService specifies the caching information, as shown in listing 4.10
For the purpose of illustration, the example uses Spring’s expression language as the scripting language.
This class specifies the key to be computed by augmenting the ticker argument with the days argument, separated by a colon.
Note how the script uses variables that match the method parameter names.
Obviously, you need to modify the annotation type to include the keyScript attribute, as shown in listing 4.11
Let’s modify the aspect to use the key script, as shown in listing 4.12
Listing 4.12 Caching scheme that uses script for key computation.
Evaluating a script expression requires you to specify a context—a map with keys set to the variable names and values set to the variable objects.
In order to use scripts for caching, you must create a map with keys set to parameter names and values set to arguments.
Using reflection API, this is a simple task, as shown in listing 4.13
The code also binds a few other variables such as this, target, and arguments, as well as the join point, so that a script can use them.
Note that merely binding the join point object will suffice, because you can navigate to all the objects from it; but scripts written using it alone aren’t as elegant.
Its main purpose is to isolate code related to evaluating.
Listing 4.13 Utility class that creates a map from the join point object.
Finally, let’s modify the Main class, as shown in listing 4.15, to exercise new additions, mainly using the second argument to the getQuoteGraph() method that specifies the duration of the chart.
Now, when you execute the new code, you get the following output:
The output shows the effect of caching that considers both the ticker and the specified duration.
We’ll revisit this example in chapter 6 to improve it further.
In addition to showing the use of reflection API, the example demonstrates how AspectJ works nicely with other solutions: a caching product and a scripting engine, in this case.
For most nontrivial problems (such as the ones you’ll see in part 2 of this book), such combinations often lead to elegant and reusable solutions.
As you can see, using the reflection API is easy.
Although you can always use reflection to obtain the dynamic context, this approach has some downsides:
But sometimes you need to use reflection because little information is available or required about the advised join points.
For instance, you can’t easily use an args() pointcut to collect all arguments for all traced methods, because each method may take a different number and type of arguments.
Further, the tracing aspect’s advice doesn’t need to care about the type of the argument objects because the only interaction of the tracing aspect with those objects is to print them.
In such cases, the reflection API is the appropriate mechanism to access the join point context.
Table 4.2 compares the two ways to access the join point context.
This table doesn’t show all possibilities, because the purpose is to give you a quick idea about ways to access join point information.
The preceding table makes it clear that using the pointcut approach is simpler and type-safe.
Therefore, when possible, it’s best to avoid the reflection API.
Aspect as a controller It can be tempting to start putting too many concerns into the advice, making the advice difficult to test and causing maintenance headaches.
With such an arrangement, you can test classes separately from aspects.
The tests for aspects only need to verify correct invocations of the collaborating classes.
You’ll use this arrangement in chapter 6, when you write a test for an improved version of the caching aspect.
Dynamic crosscutting in AspectJ modifies the behavior of the modules and consists of both pointcut and advice constructs.
The advice constructs provide a way to express actions at before, after, or around the desired join points.
With context-collecting pointcuts, advice can support static typing that is natural to a Java programmer.
The reflection support in AspectJ provides access to the join point’s static and dynamic information through a small number of interfaces.
You can use this context to tailor the advice based on the actual values (method parameters or return value) being used at runtime.
Alternatively, you can use this information in tracing aspects to gain more insight into the system’s inner workings.
The dynamic and static information together can produce an enriched log output with a simple tracing aspect.
Although dynamic crosscutting forms a major part of support for crosscutting functionality, elegant solutions need to modify the static structure of the system.
Such support comes in the form of static crosscutting, which we’ll explore in the next chapter.
Altering the dynamic behavior of the system in a crosscutting manner dominates the use of AOP.
But often you’ll also need to alter the static structure of the system in a crosscutting manner.
Whereas dynamic crosscutting modifies the behavior of the program, static crosscutting modifies the static structure of the types—the classes, interfaces, and other aspects—and their weave-time behavior.
Inter-type declaration (ITD) —One type (an aspect) makes declarations for another type (an interface, a class, or even an aspect)
It consists of support for member introduction, type-hierarchy modification, and annotation supplementation.
Exception softening —This approach lets you deal with checked exceptions in a crosscutting manner.
In this chapter, we’ll examine all these constructs and present several examples.
Consider a situation where you want to implement the observer design pattern, where observers are notified about any modifications to the observed object—the subject.
In enterprise applications, such an arrangement is common with systems that react to changes in certain objects.
For example, rule engines like Jess and Drools are capable of observing objects that participate in evaluating a rule.
Whenever any observed object’s state changes, the rule engine reevaluates the applicability of rules.
Supporting such a scenario requires each subject class to include code to add and remove listeners as well as notification code in each property.
To support property change notifications, you must add methods to add and remove a listener and fire a property change event in each setter.
You can push the common methods to a base class, but such a technique doesn’t work in cases where the subject class already extends another class.
AspectJ’s static crosscutting offers an elegant solution that, when combined with dynamic crosscutting, yields untangled code as in listing 5.1 and avoids any duplication across multiple classes.
In the next section, we’ll focus on removing tangling using aspects.
In section 5.2, we’ll extend the aspect to remove scattering as well.
Before we proceed, let’s write a quick test case to allow you to monitor your progress.
Listing 5.3 shows a test case that verifies that listeners get notifications when the address property is modified.
Your goal is to make it pass with listing 5.1
Let’s fix it by writing an aspect shown in listing 5.4 that uses member introduction to introduce such members into the specified classes and interfaces in a crosscutting manner.
AspectJ interprets the access specifiers for the introduced members with respect to the introducing aspect.
For example, the members marked private are accessible only from the introducing aspect, as in D.
The use of public access makes these methods part of the API for the Customer class.
Other classes and aspects may freely use these methods much the same way as the public getAddress() method.
With these two changes, you should be able to compile the test case successfully.
But there will be no notifications, and the test will fail.
It’s typical for the introducing aspect to use the introduced members to support dynamic crosscutting.
Note the use of initialization() pointcut to select only the first called constructor of the object being created.
The around advice uses the introduced field to notify the listeners.
I haven’t taken care of mapped and indexed properties and assume that a getter exists for each setter.
You can improve this part of the functionality before you use this aspect in real systems.
Note that the around advice uses reflection to obtain old values.
In many cases, observers don’t need the old values, because they’re interested in knowing that a.
If that is the case, you can remove the attendant code and make the aspect more efficient.
A mixin is a program construct that lets you mix certain functionality into other classes.
Depending on the programming language, it may be implemented in a variety of ways: a class in C++, a trait in Scala, and a module in Ruby.
In Java, there is no way to implement a mixin in a useful manner.
In AspectJ, interfaces with inter-type declarations offer the mixin functionality.
The classes implementing the interface automatically have those methods’ implementation available.
Listing 5.5 shows the BeanSupport marker interface (marker interface is an interface without methods)
The classes that need to support change notification must implement the BeanSupport interface, as shown for the Customer class in listing 5.6 (in the section that follows, you’ll remove this requirement)
A holistic approach toward member introduction In object-oriented programming, the fundamental paradigm—which is often lost in implementation mechanics—is that of sending messages to an object and the object processing those messages.
A typical implementation of this concept maps messagesending to a method call and message-processing to a method implementation.
The location of the code that processes the message isn’t a core concept.
In languages like Java, the message-processing logic, implemented as a method, resides in the class or in a base class in the inheritance hierarchy.
You can apply this conceptual framework to member introduction in AOP: think of a method introduced by an aspect as an alternative location to process the message—the aspect body instead of the class or its base type.
In other words, an aspect introducing a method responds to the messages on behalf of the class.
Next, the modified version of the BeanMakerAspect in listing 5.7 shows how the aspect uses the BeanSupport interface instead of a hard-coded Customer class.
Listing 5.7 Aspect implementing bean functionality in a crosscutting manner.
The code segments in bold are the only changes we’ve made compared to listing 5.4
For example, to add the functionality to the Account class, all you need to do is modify the declaration of the class as shown in the following snippet:
In section 5.2, you’ll see another kind of ITD to get the same effect of implementing an interface without modifying the class.
Now that you’ve seen one complete example, let’s go over the rules of engagement when an aspect introduces a member:
An aspect may only introduce members with public or private access specification.
When using a private introduction, the name of the member woven into the types is a mangled version.
The name change caused by mangling may be significant in a few cases where tools and frameworks rely on specific names or name patterns.
Spring Roo and ITDs Spring Roo (http://www.springsource.org/roo) is a new framework based on Spring and AspectJ that promotes domain-driven design.
It uses ITDs to separate automatically maintained generated code from user code.
An aspect may introduce fields (final as well as non-final), methods, and constructors to classes as well as interfaces.
Notice that the aspect may introduce methods along with their implementations to an interface.
This is contrary to standard Java rules, where interfaces may contain only method declarations (but not their implementations) and may contain only final fields.
If a class contains a method, and an aspect introduces the same method to its base interface, the implementation in the class takes precedence.
Intuitively, you may think of this rule as matching the override semantics.
But note this caveat: unlike a regular override, there is no way to call the logical super() method (which would be the introduced implementation)
This prevents you from implementing an augmentative override, where you call super() before or after additional code.
If you encounter such a situation, consider advising the introduced method to augment behavior.
But as you’ll see in the next section, you can combine a member declaration with a type modification to get the effect of introducing a member into multiple types.
Let’s complete our discussion of member introduction with a popular idiom used in AspectJ projects.
Plain Java doesn’t allow interfaces to contain implementation code; only classes can implement methods.
Sometimes, it would be useful to have a default implementation for interfaces as well.
Without AspectJ, the usual strategy is to create a default implementation class for the interface and let the classes extend this class.
This works fine as long as the implementing classes need to extend this class alone, but the solution starts to break down if you need to implement two or more such interfaces.
Similarly, it breaks down if you need to extend another class and implement an interface using its default implementation.
You can make the task somewhat easier with the delegation pattern by delegating each method to an instance of the default implementation class.
Nevertheless, you end up with several one-line methods, which causes code scattering—one of the symptoms of a crosscutting concern.
We’ll use this interface to show how AspectJ can simplify the job of providing the default implementation for an interface.
With pure Java, you have to implement the two methods in each class that implements this interface, as in listing 5.9
With this idiom, you create an aspect that introduces the default implementation of the methods to the interface.
Listing 5.10 shows the implementation of the methods in the Nameable interface.
The classes implementing the Nameable interface no longer have to contain these methods.
Listing 5.9 Entity class implementing the Nameable interface in a conventional way.
But this approach would work only when you implemented a single interface.
If Entity were to implement both Nameable and Identifiable without using AspectJ, you’d have to implement one of the interfaces and extend the other’s default implementation.
When you use the default-interface idiom, you declare that the Entity class implements both the interfaces, and you’re done.
As you can see in listing 5.13, the nested aspect inside Identifiable is similar to the one in Nameable.
The Entity class implements both interfaces, as shown in listing 5.14
The effect is the same as extending the default implementation for both (if multiple inheritance was allowed in Java)
Listing 5.11 Entity class implementing the Nameable interface the AspectJ way.
This idiom not only saves you from writing code, but it also facilitates making changes.
If you need to modify the default implementation, all you need to do is change the nested aspect.
Although the classes that implement these interfaces no longer have to implement their methods, in some cases you may need to customize a few methods.
When such methods are directly implemented in classes, they override the default implementation introduced by the aspect, just as you’d expect.
Another variation you can use provides only a partial default implementation for an interface.
For example, consider a situation where the default implementation needs information from the concrete classes or where you want to force the implementing class’s developers to think about the correct semantics for a certain method.
In such cases, this idiom lets you implement as many methods as appropriate in the interface, and lets the concrete classes implement the rest.
Yet another variation provides a choice to the class implementers if they want to use the introduced implementation or provide their own.
With such an idiom, instead of introducing the fields directly to the interface, the aspect introduces them to a subinterface.
Listing 5.15 shows an implementation of this variation for the Nameable interface.
Now, the classes that want to utilize the mixin implementation introduced through an aspect extend the mixin interfaces instead of the original interface, as shown in listing 5.16
The next time you encounter an interface whose implementation is boilerplate, consider using this idiom to save code.
So far, we’ve focused on one form of static crosscutting: member introduction.
The next form lets you modify the type hierarchy in a crosscutting manner.
The implementation in listing 5.7 requires that any class that wants to participate must declare that it implements the BeanSupport interface.
Sometimes, such modifications aren’t possible—for example, when you’re working with a third-party library.
In a few cases, the modifications may be undesirable, as when too many classes need such behavior.
With AspectJ, you can modify the inheritance hierarchy of existing classes and interfaces through use of the declare parents construct.
The declaration of parents must follow the regular Java object-hierarchy rules.
For example, you can’t declare a class to be the parent of an interface.
Similarly, you can’t declare parents in such a way that it results in multiple inheritance.
The declare parents feature can help by using some characteristics of the types to select them and supply a base class or interface.
For example, if you want all the classes in banking.entities to have the notification functionality, you add the following aspects:
Now, classes like Customer don’t have to include implements BeanSupport as part of their declaration.
Although the preceding declaration relies on the package structure, you can use any other characteristics.
Evaluation order: static and dynamic crosscutting AspectJ applies all static crosscutting prior to dynamic crosscutting.
For example, it applies all declare parents statements before evaluating matches for a pointcut.
This way, matching isn’t affected by how a static structure came to be: it could be due to the way classes were written or due to a static crosscutting construct.
Introducing members to multiple types functionality to any class with the @Entity annotation, you can easily do so by using the following declaration in an aspect:
Let’s pause to look at an example using the constructs you’ve learned so far.
A combination of member introduction and type-hierarchy modification provides a useful idiom to introduce members to multiple types.
In such cases, you create an interface, introduce members to it, and declare it the parent of the target types.
The overall scheme is similar to creating default implementations of interfaces, as discussed in section 5.1.5, except that here you use an interface as an intermediary to introduce members.
Let’s say you want to trace the last-accessed time for each service class.
Further, assume that a service class is marked with the @Service interface.
You need to introduce a field for the last-accessed time in all service classes.
Therefore, you’ll need to use another type as an intermediary, as shown in listing 5.17
Experimental features: hasmethod() and hasfield() The current version of AspectJ includes an experimental feature that defines a type pattern based on the methods and fields a target type contains (enabled through the –XhasMember compiler flag)
Such a type pattern works only in a declare parents construct.
For example, you can use the following statement to declare BeanSupport as the parent of types that contain a method with the @Observed annotation:
With this statement, including a method with @Observed annotation leads to supporting bean-notification functionality (the pointcut as written also expects a one-argument method to match the setter semantics and let it collect the old value)
But other parts of the system may also call those methods.
For example, you can expose the methods through a JMX console using an exporter as if the method was present in each service class.
Now, let’s move our attention to another form of inter-type declaration that helps you associate annotations with program elements.
These frameworks support program elements to carry annotations that are meaningful to the framework.
AspectJ provides support for selecting join points based on annotations carried by the program elements.
In many cases, several program elements repeat the same annotation, leading to annotation clutter.
To avoid this kind of clutter and provide support for many interesting design patterns (such as the annotation-driven participant pattern discussed in chapter 12), AspectJ offers static crosscutting constructs to supply annotations in a crosscutting manner.
You can use AspectJ’s declare @method construct as follows to get the job done:
AspectJ lets you associate annotations with methods, constructors, fields, and types.
The constructs for supplying annotations share the following general form:
Table 5.1 shows all the constructs in AspectJ for annotating program elements:
Like normal annotations, declare statements must use annotations that are compatible with the elements being annotated.
One interesting use of the declaring annotations is creating annotation bridging by supplying an annotation when another annotation is detected.
Program elements annotated using the declare statement can be used the same way as normally annotated program elements.
For example, if a pointcut specifies an annotation as part of the matching specification, program elements annotated using a declare statement will match the same way as methods directly marked with an annotation.
Furthermore, annotations introduced using a declare statement will be available to tools such as persistence frameworks (like Hibernate and JPA) and EJB application servers just like annotations directly supplied to a program element.
AspectJ provides a static crosscutting mechanism to declare weave-time errors and warnings based on certain usage patterns.
This mechanism is often used with the AspectJ compiler as the weaver and therefore is also referred to as a compile-time error and warning construct.
The declare error construct provides a way to declare a weave-time error when the compiler detects the presence of a join point matching a given pointcut.
The compiler issues an error, prints the given message for each detected use, and aborts the compilation process:
Similarly, the declare warning construct provides a way to declare a compile-time warning, but it doesn’t abort the compilation process:
Note that because these declarations affect compile-time behavior, you must use only statically determinable pointcuts in the declarations.
Domain-object dependency injection and static crosscutting Spring’s support for domain-object dependency injection (often known through the @Configurable annotation associated with it) lets you inject dependencies into any object (not just Spring beans)
It also serves as a good real-world use of static crosscutting.
Its implementation uses a member introduction, parent hierarchy modification, supplying annotations, and the hasmethod() type pattern (in a commented block of code due to its experimental nature)
A typical use of these constructs is enforcing rules, such as prohibiting calls to certain unsupported methods, or issuing a warning about such calls.
The following code example causes the AspectJ compiler to produce a compile-time error if a join point matching the callToUnsafeCode() pointcut is found anywhere in the code that is being compiled: declare error : callToUnsafeCode() : "This third-party code is known to result in a crash";
The following code is similar, except it produces a compile-time warning instead of an error:
Let’s complete our discussion of static crosscutting support in AspectJ by examining a construct that lets you demote checked exceptions to unchecked at selected join points.
Java specifies two categories of exceptions that a method may throw: checked and unchecked.
When an exception is checked, callers must deal with it either by catching the exception or by declaring that they can throw it.
When an exception is unchecked (which directly or indirectly extends RuntimeException or Error), callers need not deal with it explicitly and the exception is automatically propagated up the call stack.
Exception softening lets you treat checked exceptions thrown by specified pointcuts as unchecked ones and thus eliminates the need to explicitly deal with them in the caller code.
For example, you can soften a RemoteException thrown in a Remote Method Invocation (RMI)-based system to avoid handling the exception at each level.
For instance, if you know you’re using local objects of RMI-capable classes that won’t throw any RemoteException, you can soften those exceptions.
To soften exceptions, you use the declare soft construct, which takes the following form:
If a method is throwing more than one checked exceptions, you must soften each one individually.
Compiling the TestSoftening class by itself results in a compiler error, because main() neither catches the exception nor declares that it’s throwing that exception:
By softening the exception, you can compile the code without errors.
When you run the program, you see a call stack due to a thrown SoftException:
Exception softening is a quick way to avoid tangling the concern of exception handling with the core logic.
But be careful about overusing this technique: one of the reasons to use checked exceptions is that it forces you to handle them by making a conscious decision about processing the exceptions or propagating them to the caller.
Static crosscutting offers ways to affect the static structure of the system.
Static crosscutting, which you can use by itself or in support of dynamic crosscutting, includes the.
Summary following constructs: member introduction, annotation supplementation, type hierarchy modification, weave-time declarations, and exception softening.
The ability to modify the type hierarchy offers a way to deal with multiple types uniformly even though the types don’t share a common type.
Annotations declared in this manner can be consumed using dynamic crosscutting through annotation-based pointcuts.
Weave-time errors and warnings provide a way to detect the presence of join points that may be in violation of some programming wisdom.
You’ll see many of these facilities used to implement complex crosscutting concerns in part 2 of this book.
In the next chapter, we’ll discuss the construct of an aspect that provides a unit to express both dynamic and static crosscutting elements.
Aspects represent the unit of modularization in AOP and AspectJ.
They provide a way to include crosscutting constructs such as pointcuts and advice.
You’ve already seen quite a few aspects in the preceding chapters’ examples.
In this chapter, we’ll take a closer look at the core aspect construct.
We’ll begin by examining the aspect construct in a formal way and compare it to the class—the most similar concept in object-oriented programming.
Next, we’ll examine the aspect association that provides a mechanism needed to write reusable aspects.
We’ll follow that by considering the effects of multiple aspects in a system advising the same join point, and ways to control ordering.
Like the preceding three chapters, we’ll focus on aspects expressed using the traditional syntax.
As you’ll see in the next chapter, the concepts you learn here can be easily mapped into aspects expressed using the @AspectJ syntax as well as Spring AOP.
The AspectJ weaver takes the rules specified in each aspect and uses them to modify the behavior of the core modules in a crosscutting manner.
Syntactically, an aspect declaration looks much like a class declaration:
It has a name to enable the other parts of the program to refer to it and its elements.
Because the simplest way to look at aspects is to see them as analogous to classes in Java, let’s look at the similarities and differences between aspects and classes.
The data members and methods in aspects have the same role as in classes.
For instance, an aspect can manage its state using data members, whereas methods can implement behavior that supports the crosscutting concern’s implementation or can be utility methods.
Therefore, only the no-argument constructor can call constructors that take arguments.
An aspect’s access specifier governs its visibility following the same rules as classes and interfaces.
Top-level aspects can have only public or package (specified by omitting the access specifier) access.
Nested aspects, like nested classes, can have a public, private, protected, or package access specifier.
With abstract aspects, you can create reusable units of crosscutting by deferring some of the implementation details to subaspects.
An abstract aspect can mark any pointcut or method as abstract and refer to it from other constructs.
Like a class, an aspect that contains abstract pointcuts or methods must declare itself as an abstract aspect.
Any subaspect of an abstract aspect that doesn’t define every abstract pointcut and method in the base aspect, or that adds additional abstract pointcuts or methods, must also declare itself abstract.
The mechanism of creating abstract aspects is useful for library aspects, such as for transaction management.
The following example shows an abstract aspect that contains an abstract pointcut and an abstract method:
In this aspect, the traced() pointcut is declared abstract to let subaspects provide its definition.
Similarly, the abstract method getLogger() defers providing the logger object to subaspects.
The advice that logs the message uses both these abstract entities to perform its task.
The net effect is the encapsulation of the tracing logic in the base aspect.
Each subaspect fills in the details of the trace points and the logger object.
Let’s see how a concrete aspect provides a definition for abstract pointcuts and methods.
The following concrete aspect extends the AbstractTracing aspect you’ve just seen.
It provides definitions for its abstract pointcut and method, matching the requirements of tracing the banking system:
This aspect defines the traced() pointcut to select the execution of any method in classes that are part of the banking root package.
The getLogger() method implementation returns the logger that is specific to the banking system.
You can have many such subaspects, each providing the required definitions.
Note that an aspect may extend a class and implement interfaces.
Such an aspect can access the base-class functionality in the same way as a subclass.
You can embed aspects into classes and interfaces when the aspect’s implementation is intimately tied to its enclosing class or interface (such as refactoring aspects, as you’ll see in chapter 16)
Because the aspect resides in the same source file, this simplifies the modifications required for the aspect’s implementation when the enclosing entity changes.
Note that an embedded aspect must be marked as static.
Here are some of the ways that aspects are different from classes:
In other words, you never use new to create an aspect instance.
Although aspects can inherit from abstract aspects, they can’t inherit from concrete aspects.
Explicit aspect creation A typical dependency injection (DI) framework by default uses a constructor to instantiate objects.
When using an aspect with such a framework, you often need to inject dependencies into the aspect instance as well.
But the fact that an aspect shouldn’t be constructed directly using a constructor poses a problem.
If subaspects of a concrete aspect were allowed, the language would have to specify how such subaspects interact with the weaving specified by their base aspect.
In practice, this restriction usually doesn’t pose any significant problem.
Because the system instantiates an aspect, there would be no way to bind a generictype parameter during such instantiation.
Any concrete aspect extending such an aspect must bind the generic parameters in its declaration.
This gives them access to the private members of the classes they’re crosscutting.
Let’s turn our focus to an advanced feature of AspectJ—aspect association—which comes in handy when you’re developing reusable aspects for certain crosscutting functionality.
By default, only one instance of an aspect type exists—much like a singleton class.
Usually, this arrangement is fine and even desirable for stateless aspects as well as aspects with an inherently global state, such as a resource pool.
But in some situations, especially when you’re creating reusable aspects, you want to associate the aspect’s state with an individual object, a specific class, or a control flow.
The aspect-association mechanism offers various ways to associate aspect instances.
Although an aspect is a singleton aspect by default, you can explicitly specify so by using the following form:
For per-object and per–control-flow association, you can specify association by modifying the aspect declaration that takes the following form:
The part in bold specifies how the aspect is associated with the join points selected by the specified pointcut.
For per-type association, you use a modification to the previous syntax:
Aspect association is perhaps the most advanced topic in AspectJ, and some effort is required to understand it fully.
This is especially true if you haven’t had much experience with AspectJ.
But it’s an important topic for developers engaged in writing reusable library aspects.
If you’re relatively new to AspectJ, you may want to skim until section 6.2.8 (where I show how to use Spring to configure an aspect and implement automated testing for the caching example we have been developing in previous chapters)
After you’ve gained more experience, you can revisit this section.
Let’s explore all these aspect association choices in detail; then, we’ll examine how each affects the join point selection.
Default association is in effect when you don’t include an association specification.
Alternatively, you can use issingleton() in the aspect declaration; but such explicit declaration isn’t a common practice.
All the aspects you’ve seen so far in this book are of this type.
This type of association creates one instance of the aspect for an aspect type.
Later, you’ll modify this aspect to see the effect of other aspect associations.
Listing 6.1 shows the default (singleton) association aspect that illustrates aspect instance creation.
You’ll use the Account class along with SavingsAccount, which extends Account (not shown here, but provided as a part of this book’s downloadable sources)
The aspect logs a message in its constructor to designate its creation.
Then, it prints the aspect’s instance and the this object at the advised join point.
You print a simple message in the aspect constructor to keep track of when the aspect instance is created.
It also collects the Account object using the this() pointcut so that you can print it in the advice.
Note that when used from advice, the object this refers to the instance of an aspect and not the execution object at a join point.
Next, let’s write a simple driver program (listing 6.2) that creates two Account objects and calls methods on them.
When you compile the classes and run the driver program, you see output similar to the following:
The output shows that only one instance of the aspect is created, and that instance is available to the advice in the aspect and shared among all the Account objects.
Now, let’s move our attention to other aspect associations that allow more than one instance of an aspect to exist in an application.
Consider a situation where you need to apply the read-write lock pattern, which needs a lock per object.
Ideally, you’d like to create a reusable aspect given that the pattern itself is reusable.
The per-object association feature provides a mechanism to associate a new aspect instance with each execution or target object.
In the following snippet, a new aspect instance is associated with each new execution object using perthis(), which matches the abstract access() pointcut (see chapter 13 for a complete example of this pattern implemented using AspectJ):
As an example, you can enable read-write concurrency control for the banking-related classes by creating a subaspect that provides a definition for the abstract pointcuts:
Effectively, the aspect’s state forms a part of each execution object’s state.
The advice in the base and derived aspects may then use the state of the aspect as if it were the advised object’s state.
With per-object associations, an aspect instance is associated with each object matching the association specification.
With object associations, the aspect instance is created when executing a join point of a matching object for the first time.
Specifically, executing another matching join point on the same object doesn’t create a new aspect with the object.
Figure 6.1 illustrates object association using a UML sequence diagram.
As the figure shows, an aspect is created for each object when the join point matching the pointcut is executed the first time for that object.
The aspect association remains valid during the lifetime of the object.
When you compile this using the modified aspect and run the driver program (listing 6.2), you get the following output:
Each aspect is created just before the execution of the first join point with each Account object.
In each advice body, the same aspect instance is available for each join point on an object.
To associate an aspect instance with the target object for a matching join point instead of the execution object, you use pertarget() instead of perthis()
You need to maintain the transactional resource (JDBC connection, Hibernate session) from the point at which the transaction starts until it ends.
The per-control-flow aspects offer a possibility of associating an aspect instance with each control flow associated with a join point.
As an alternative to using percflow() aspects, you can use thread-specific storage such as ThreadLocal to manage the control flow’s state.
But in many cases, using an aspect association creates a simpler implementation.
As figure 6.2 shows, an aspect is created as soon as each matching control flow is entered for the first time.
The aspect association then remains valid during the lifetime of the control flow.
Each gray area in the figure indicates the scope of the aspect instance that was created upon entering the area.
Figure 6.2 This sequence diagram shows aspect-creation and -association points for control-flow-based associations.
Much like the perthis() and pertarget() cases, after an association is made between a control flow and an aspect instance, it continues to exist for the lifetime of that control flow.
In the figure, an aspect associates the aspect instance with the control flow of join points that match the execution of the debit() method in the AccountService class.
Two aspect instances are created—one each for the invocation of debit() execution.
Each aspect instance continues to exist until its join point’s execution completes.
You’ll also modify the pointcut in the before advice to include the setBalance() execution, as shown in listing 6.4
When you compile and run the program, you see output similar to the following:
Four instances of the aspect are created: two corresponding to the credit() method and two corresponding to the debit() method executions initiated by the Main class.
Each execution of the credit() and debit() methods called from the Main class resulted in a new control flow matching the join point specified in the aspect association pointcut, resulting in a new aspect instance being created.
Each instance is created just before the execution of the credit() and debit() methods, because a new control flow matching the pointcut specified starts with their execution.
The setBalance() method that is called from the control flow of debit() and credit() methods is associated with the same aspect as its caller.
Because the setBalance() method falls in the control flow of debit() and credit() methods, the instance created for the caller continues to be associated with any method called by this caller.
Let’s see how it compares with the other association types.
Associating an aspect instance with the type (class, interface, or aspect) is similar to object association, except the aspect instance is associated with the class instead of its objects.
You can think of per-type association as being similar to a static member defined in a class, whereas per-object association is like an instance member.
Let’s look at the general structure of per-type association (see chapter 10 for a more complete example):
With such a declaration, the state in the aspect effectively becomes the static (classbound) state of any class matching any type in the ajia.services package.
It’s typical to advise the static initializer to initialize the aspect state and use that state in other advice.
For each pertypewithin() aspect, the weaver adds this method, which returns the type name associated with the aspect instance.
Any other advice then effectively uses the class-specific state (logger, in this case)
To illustrate the effect of the aspect association, make a small modification to SavingsAccount to override the implementation of the debit() method, as shown in Listing 6.6
When you compile and execute the code, you see output similar to the following:
The most important observation is that there are two aspect instances, and the aspect instance available at a join point corresponds to the type in which the join point is defined.
In the current AspectJ implementation, the aspect instance is created when the class is loaded, which also corresponds to the static initialization join point for the class.
When a join point with corresponding code defined in the Account type is advised, the aspect instance available at that point is the one created for the Account type.
An aspect instance is similarly created for the SavingsAccount class.
When a join point with the corresponding code defined in SavingsAccount is advised, the aspect instance accessed is the one created for SavingsAccount.
For example, for the debit() method, when the code defined in SavingsAccount executes, the aspect instance accessed is the one for SavingsAccount.
But when the superclass’s code is executed for the same method, the aspect instance accessed is the one created for the Account type.
The lexical scope in which the join point’s program element is defined governs the aspect instance available at a join point.
In particular, the dynamic type of the object doesn’t play any role here.
Although the type of the advised object is always SavingsAccount, the aspect instance corresponding to Account or SavingsAccount is made available depending on where the code resides.
This behavior lets you implement the common logging idiom by using the logger instance associated with the class from which the logging code is executed.
Using the per-object, per-control-flow, or per-type association has the side effect of implicitly limiting the advice in the aspect to only join points that match the scope of an aspect instance.
The scope of an aspect instance is the set of join points that have.
For example, for the percflow() association, the scope of an aspect instance is all the join points occurring inside the control flow of the specified pointcut.
This means that even if a pointcut specified for an advice matches a join point, the advice to that join point won’t apply unless the join point also matches the scope of the aspect.
This side effect often surprises developers when they refactor an aspect to create reusable parts and need to use per- associations.
The aspect association implies that advice in an aspect will apply to join points only if:
For perthis() associations, the join point’s execution object matches the aspect instance’s associated object.
For pertarget() associations, the join point’s target object matches the aspect’s associated object.
For percflow() associations, the join point is in the control flow of the aspect’s associated control flow.
For percflowbelow() associations, the join point is below the control flow of the aspect’s associated control flow.
For pertypewithin() associations, the type matching the join point’s definition matches the type pattern declared in the aspect association.
Aspect instances are created automatically by the system according to the association specification.
To access their state from outside the aspect, you need to get its instance.
Consider a profiling aspect that collects durations for the execution of profiled methods.
You’d typically keep the profile data inside the profile aspect.
When you need to retrieve this data—say, from another thread that prints the latest profile information—you have to get the aspect instance first.
For all types of aspect associations, you can get the aspect instance using the static method aspectOf() that is available for each aspect.
For a profiler case, you can retrieve the data as follows:
The aspectOf() method returns the aspect instance associated with the aspect on which the method is invoked.
Each aspect contains two static methods: aspectOf(), to obtain the associated aspect instance; and hasAspect(), to check if an instance is associated.
These methods take different arguments depending on the aspect association.
Table 6.1 shows the arguments taken by different aspect associations.
In all cases, the aspectOf() method returns the instance of an aspect if one is associated.
In the case of the default association, it creates an instance if none is associated, and returns it.
You can use this fact to inject dependencies into aspects (you’ll use it in an example later in this section)
The method hasAspect() returns true if an aspect instance is associated; otherwise, it returns false.
Note that because an aspect instance with a control-flow-based association lives only during the control flow (or below, for percflowbelow()), you can get the aspect instance only in the control flow associated with the aspect.
They share some commonality, but there are a few important differences.
You can avoid using per-object association by judiciously using static crosscutting with introduced fields.
In that case, instead of keeping the state in an aspect, you introduce that state to the object being advised.
For example, consider the following aspect, which associates an aspect instance with each Account object.
To use a member introduction instead of an association, you can change the aspect in the following way:
The result is identical in both snippets—a new state is associated with each Account object.
Certain reusable aspects (such as a read-write lock management aspect) that need to work with diverse types of objects may not have a common shared type.
For example, Customer and Account probably have no class or interface common to their inheritance hierarchy.
Therefore, to introduce a state, you must first specify a common type using declare parent.
This way, you get the same effect as per-object association using a simple introduction mechanism.
Developing reusable aspects using introduction instead of per-object association can get tricky.
Although you can get around this issue by using a complex design, per-object association can offer an elegant alternative solution.
When you use per-object association, the base aspect includes an abstract pointcut that associates the aspect with the object at the matching join points.
All that a derived aspect needs to do is provide a definition for that pointcut so that it selects join points whose associated objects need an additional per-object state.
Section 13.3.2 will provide a concrete example of simplifying a reusable aspect using per-object association.
The choice between using per-object association and member introduction is a balance between elegance and simplicity.
In chapter 4, the caching solution used a hard-coded instance of the cache object.
A better design choice is to use a DI mechanism to inject a cache instance in the aspect.
Let’s modify the example to use Spring’s DI with the aspect.
You’ll then externalize the cache configuration and expose a few objects through the Java Management Extension (JMX) so you can change the cache configuration in a running application.
Let’s modify the aspect to remove the hard-coded creation of the cache field and add a setter so that you can use the Spring container to configure that property.
This also enables you to inject the aspect with mock objects for testing purposes.
If that flag is set to false, the advice bypasses the caching logic.
The setCache() method lets the cache property be injected through an external configuration such as the one in listing 6.8, which defines an application context to be used by the Spring container.
The example has beans corresponding to the aspect and the cache object that you expose through JMX.
Whereas in a typical Spring application, even StockService is configured as a bean, here we’ve left it unchanged to maintain our focus on the main theme of this section.
You use aspectOf() as the factory method when defining the bean corresponding to the aspect.
The Spring container uses that method to instantiate the aspect instead of using new.
The bean corresponding to the aspect is like any other bean.
The cache bean is an instance of the Cache class with all constructor arguments set to true.
The use of DI allows aspects to leverage the Spring Framework’s power.
You expose the cache aspect and the cache bean to JMX by adding this snippet to an application context file.
Similarly, you could utilize other functionality offered by Spring, such as transaction management and security.
Let’s modify the Main class to load the Spring application context that will lead to configuring the aspect instance.
You’ll also add a loop around the code, which exercises caching functionality to let you play with it while you modify properties through a JMX console.
Note that the aspect has the needed support in place to write an automated test.
Listing 6.9 Modified main class to load Spring’s application context.
When you run this program, you can connect to it using a JMX console.
Executing this program leads to a few warnings due to our taking the simplest possible approach and exposing all properties of the beans.
Notice how the cache and cacheAspect beans are available as MBeans.
Also notice how the aspect’s enabled property is exposed, which lets you enable or disable the caching logic.
The following output shows an interaction, with commentary regarding the input and JMX console interaction in italics:
Play around with it to get a better understanding of interacting with the cache object.
To ensure that the aspect continues to behave correctly in the future, let’s write tests that can be run automatically.
Because you’ve modified the aspect to allow injecting dependencies, you can inject it with mock objects and verify correct interactions.
You obtain the instance of the CacheAspect using the aspectOf() method.
You also use a TestService object whose method is marked with the @Cachable annotation.
TestService class uses a helper object, whose interaction you monitor to verify correct caching behavior.
You inject the mock object for TestServiceHelper into the TestService object.
Similarly, you inject the mock object for Cache into the aspect.
The test for a cache hit invokes the method that should be cached.
It verifies that the cache is queried with the right key.
It also verifies that no interaction took place with the helper object, because a cache hit should lead to bypassing that object.
The test for a cache miss specifies the behavior for the cache to throw an exception.
After calling the cached method, this test verifies that the helper method has been called, because a cache miss should lead to its invocation.
Run this test, and you should see a green bar.
Because a system may consist of multiple advice in the same or different aspects that interact with the same join point, an obvious question arises: how does AspectJ determine the order in which advice are applied, and how can you control this order? To understand the need for controlling the advice execution order, let’s look at the example in listing 6.11
Consider a class representing a home, with methods for entering and exiting the home.
Now, let’s create a security aspect (listing 6.12) consisting of advice for engaging the security system in the home when you exit and disengaging it when you enter.
Another aspect (listing 6.13) conserves energy by switching off the lights before you leave the home and switching them on after you enter.
The simple driver in listing 6.14 shows the effects of multiple advice on a join point.
When you compile these files together passing the compiler the –Xlint:warning flag, you get the following warnings:
When execute the Main program, you see the following output:1
Listing 6.14 Simple class to show the effect of multiple advice on a join point.
It’s possible to get output that differs from what is shown here, depending on several factors, including the version of the AspectJ compiler you’re using.
Your output may match the desired output, but such a match is accidental: precedence is arbitrarily determined, unless you specify the advice precedence.
The exhibited behavior may not be desirable, considering that switching off lights prior to securing the home may make you fumble in the dark.
Also, trying to disarm the security system without the lights on when you enter may cause similar trouble, and any delay in disarming the system may result in security being called.
In the next few sections, we’ll discuss the rules of precedence and ways you can control precedence.
Later, you’ll apply this information to the previous problem to learn how you can achieve the correct advice ordering.
As you’ve just seen, with multiple aspects present in a system, pieces of advice in the different aspects can often apply to a single join point.
When this happens, AspectJ uses the following precedence rules to determine the order in which the advice is applied.
The aspect with higher precedence executes its before advice on a join point before the aspect with lower precedence.
The aspect with higher precedence executes its after advice on a join point after the aspect with lower precedence.
The around advice in the higher-precedence aspect encloses the around advice in the lower-precedence aspect.
This kind of arrangement allows the higherprecedence aspect to control whether the lower-precedence advice will run by controlling the call to proceed()
If the higher-precedence aspect doesn’t call proceed() in its advice body, not only will the lower-precedence aspects not execute, but the advised join point also won’t execute.
It’s often necessary to change the precedence of advice applied to a join point.
Let’s see what mechanisms AspectJ provides to meet such needs.
The declare precedence construct must be specified inside an aspect.
The result of this kind of declaration is that aspects matching the type pattern on the left dominate the ones on the right, thus taking a higher precedence.
Precedence ordering considers only concrete aspects when matching the type pattern and ignores all abstract aspects.
By controlling aspect precedence, you can control the order in which advice is applied to a pointcut.
Let’s use this declaration to correct the precedence between HomeSecurityAspect and SaveEnergyAspect in the Home class example.
You want to run the before advice to arm the security system prior to the before advice to switch off the lights, and the after advice to disarm the system following the after advice to switch on the lights.
This means you need HomeSecurityAspect to have a higher precedence than SaveEnergyAspect.
You achieve this goal by writing another aspect (listing 6.15) that declares the correct and explicit precedence between the two.
When you compile your code and run the driver program, you see the following output:
Figure 6.4 Ordering the execution of advice and join points.
You can think of the around advice as the higher-precedence advice running the lower-precedence advice in a nested manner.
You could have added the declare precedence clause in either HomeSecurityAspect or SaveEnergyAspect and gotten the same result.
But this kind of modification would cause the declaring aspect to know about the other aspect and thus cause an undesirable coupling between the two.
In the absence of any special precedence control, the order in which the advice is applied is unpredictable.
The AspectJ compiler can help you spot situations where the advice order is unpredictable—all you need to do is pass it the -Xlint:warning flag.
Let’s examine some more examples of the declare precedence clause, to help you better understand it.
Because the clause expects a list of TypePatterns, you can use wildcards in aspect names.
But in this declaration, the precedence between two aspects starting with Auth is unspecified.
If controlling the precedence between two such aspects is important, you must specify both aspects in the desired order.
Because declare precedence takes a type list, you can specify a sequence of precedence.
For example, the following declaration causes aspects whose names start with Auth to have precedence over both PoolingAspect and LoggingAspect, while also causing PoolingAspect to take precedence over LoggingAspect:
It’s common for certain aspects to have higher precedence among all aspects.
It’s also common for certain aspects to have lower precedence among all aspects.
You can use a wildcard to achieve this as well.
The following declaration causes CachingAspect to have the lowest precedence:
It’s an error if a single declare precedence clause causes circular dependency in the ordering of aspect precedence.
But it’s legal to specify a circular dependency that causes precedence in multiple clauses.
You can use this to enforce that two different, potentially conflicting or redundant aspects, such as two pooling aspects, share no join points.
You get a compile-time error if the two aspects in question share a join point.
You can include a declare precedence clause inside any aspect.
Such a separation is particularly important for third-party, offthe-shelf aspects where you may not have the control over source files that you would need to add such clauses.
Separating precedence control also avoids the tangling of the core functionality in the precedence relationship with other aspects.
The precedence control offered by AspectJ is simple yet powerful and is immensely helpful for a complex system.
You can now create multiple aspects independently as well as use aspects developed by others without requiring modifications to any aspects.
Let’s now examine the rules that govern the precedence of advice within an aspect.
It’s also possible to have multiple advice in one aspect that you want to apply to a pointcut.
Because the advice reside in the same aspect, aspect-precedence rules can no longer apply.
In such cases, the advice that appears first lexically inside the aspect executes first.
Note that the only way to control precedence between multiple advice in an aspect is to arrange them lexically.
Let’s illustrate this rule through a simple example (listing 6.16) that shows both the effect of the precedence rule and its interaction between different types of advice.
Aspect inheritance and precedence AspectJ implicitly determines the precedence between two aspects related by a basederived aspect relationship.
The rule is simple: the derived aspect implicitly has higher precedence than the base aspect.
Because only concrete aspects in the declare precedence clause are designated for precedence ordering, declaring a base aspect (which is always abstract) to have higher precedence over subaspects has no effect.
In other words, there is no way to declare higher precedence for base aspects.
In listing 6.17, the Main class sets up the scenario to check the precedence by calling the perform() method from the main() method.
After compiling the aspect with the Main class, when you run the code, you get this output:
Listing 6.17 Main driver to check precedence within an aspect.
Note that, regardless of precedence, all before advice for a join point must execute before the advised join point.
The after advice executes before completing the around advice, because it has higher precedence than the around advice.
Note that the earliest an after advice can run is after the join point’s execution.
Now that you know all about precedence control between multiple aspects and advice within an aspect, you should be able to control how aspects and advice apply at any given join point.
For the most part, aspects have the same standard Java access-control rules as classes.
For example, an aspect normally can’t access any private members of other classes.
This is usually sufficient and is desirable on most occasions.
But in a few situations, an aspect may need to access certain data members or operations that aren’t exposed to outsiders.
You can gain such access by marking the aspect privileged.
The Main class (listing 6.18) contains a private data member.
Listing 6.19 Aspect that accesses private member of a class.
If you try to compile this code, you get a compiler error for accessing the Main class’s private member id:
But if you mark the aspect as privileged (as follows), the code compiles without error and behaves as expected:
With the privileged aspect, you can access the internal state of a class without changing the class.
Privileged aspects have access to implementation details, so you should exercise restraint when using this feature.
Aspect-association constructs offer elegant ways to manage the state of an aspect with respect to the associated object, control flow, or type.
This mechanism—although a little difficult to understand at first—provides the necessary machinery to write complex aspects.
Using this feature, you can create reusable aspects more effectively while knowing only minimal information about the target systems.
As you begin to realize the benefits of aspect-oriented programming, you may find that multiple aspects, such as authorization and transaction management, affect the same parts of the system.
Aspect precedence will help you coordinate these aspects so that they function correctly.
The privileged-aspect feature will help you handle situations where you need to access the private members of classes.
But in this case, it’s perhaps more important to understand the negative implications of using the technique.
So far, we’ve mainly focused on the traditional AspectJ syntax and compile-time weaving.
But AspectJ provides alternative syntax and weaving models that can be valuable for certain kinds of applications.
We’ll devote the next three chapters to exploring these new features.
One-size-fits-all usually fits nothing! Over the last few years, the AspectJ community realized that a single syntax style and one weaving model didn’t meet all the needs of real-world AOP usage.
AspectJ responded to the real world’s needs by offering pragmatic choices for syntax and weaving models.
With the new choices, using AspectJ is easier than ever before.
In this chapter, we’ll examine a major alternative to the traditional syntax.
Until now in this book, we’ve focused on the traditional syntax, which excels in its power, expressiveness, and compactness.
But using it requires a leap of faith, due to the need to use a different compiler and other tools (mainly an IDE) that can understand such syntax.
For a pragmatic adoption, we need a smoother path and reduced dependency on specialized tools.
If you’re in a situation where you can’t afford to make an outright switch to the AspectJ compiler, the @AspectJ syntax offers you a compelling alternative.
The @AspectJ syntax was added due to the merging of AspectWerkz with AspectJ.
The users of AspectWerkz made it clear that the syntax aided in simplifying AOP adoption.
The @AspectJ syntax uses plain Java along with annotations to express crosscutting elements.
Although the syntax tends to be somewhat verbose and slightly less powerful, aspects written in @AspectJ syntax can be compiled using a plain Java compiler.
Later, you can use the binary or load-time weaver to weave classes and aspects together.
The @AspectJ syntax thus provides a pragmatic balance between compactness and toolability.
The Spring Framework heavily utilizes the @AspectJ syntax within its proxy-based AOP framework without needing an AspectJ weaver—not even binary or load-time.
We’ll examine the purpose of the @AspectJ syntax, mapping of the various crosscutting constructs, and limitations of the syntax.
We’ll then put all this information together to help you choose the right syntax given your situation.
Each crosscutting element is mapped to a Java element carrying a specific annotation.
Any information that can’t be expressed in Java alone is expressed as parameters to the annotations.
The driving principles behind the @AspectJ syntax are the natural mapping of crosscutting elements, compatibility with Java, and early error detection.
The @AspectJ syntax uses similarities between AOP and OOP constructs to find a natural mapping for crosscutting constructs.
For example, given the similarity between aspects and classes, (as discussed in section 6.1.1) a class with an annotation can serve as an aspect.
Also, because a pointcut can be abstract and may declare parameters, a method makes a good candidate that can represent these characteristics.
Most elements find a direct mapping from the traditional syntax into the @AspectJ syntax.
A few features, such as the privileged aspect, can’t be mapped at all within the constraint of compiling using javac.
You’ll need to put this jar in the classpath when you compile aspects written in this syntax.
The @AspectJ syntax utilizes many concepts from the traditional syntax.
For example, although it doesn’t use the pointcut keyword to define a pointcut, it uses the same pointcut expression language (with minor differences) inside an annotation.
Aspects expressed using the @AspectJ syntax can be compiled using regular javac.
This lets existing IDEs work better with such code, because they can always treat aspects as regular Java code.
The IDE can compile the code using a Java compiler and weave in the classes and aspects in a post-processing step (you can also use the loadtime weaver)
Other tools, such as code-coverage tools (such as Clover) and code analyzers (for example, PMD and FindBugs) work well, again due to the fact that they treat the code as plain Java code.
Obviously, these tools won’t understand the semantics of the annotations; but the tools won’t balk at @Aspect-expressed aspects, and that is sufficient in most cases.
As a result, you still need the AspectJ weaver to perform binary weaving during build-time or load-time.
Note that if you use ajc to compile the aspects written using @AspectJ syntax, it performs weaving at build-time, obviating the need for a special weaving step.
The @AspectJ syntax is designed to give as many errors and warnings as soon as possible even when you compile using the javac compiler.
This design dictates using the Java constructs as much as possible instead of using expressions buried in strings.
Consider a hypothetical plain-Java AspectJ syntax that uses a string whose value is the text for the corresponding aspect defined using the traditional syntax (note that there are many other possibilities for this kind of syntax)
For example, the following class could represent an aspect in plain Java:
This hypothetical syntax could work, and it’s trivial to learn once you understand the traditional syntax.
But a big drawback would be the lack of compile-time checks for the code expressed using the string, if you use javac to compile such code.
Any syntactical (or even spelling) errors in code expressed in the string will be reported only at the weave time, which may be as late as deployment time if you use load-time weaving (discussed in the next chapter)
For example, any errors in the body of the around() advice will go undetected during compilation using javac.
This consideration has led to a few deviations from a straightforward mapping from the traditional syntax (a good example is the if() pointcut, discussed in section 7.3.2)
Let’s examine the various crosscutting elements expressed in the @AspectJ syntax.
In AspectJ, an aspect is the unit of modularization for crosscutting concerns and consists of elements such as pointcuts and advice.
Such a class can contain other crosscutting elements such as pointcuts and advice, also expressed using the @AspectJ syntax.
Here is the general form of aspect declaration using @AspectJ syntax:
One difference from a regular class is the annotation attached to the class that indicates to an AspectJ weaver that the class is to be treated as an aspect.
This declaration is equivalent to the following aspect expressed using the traditional syntax:
The next snippet declares a subaspect of the previous abstract aspect:
The equivalent aspect expressed using the traditional syntax is as follows:
Due to the special semantics associated with aspects, there are a few restrictions on the class declaration to match the aspect semantics.
See section 6.1.2 for a discussion of differences between aspects and classes.
This matches the restriction that an inner aspect must be static (that is, not bound to an instance of the enclosing type)
The @Aspect annotation has an optional property that you can use to specify aspect association, as we’ll discuss next.
You can similarly specify associations such as pertarget(), percflow(), and percflowbelow() as well as pertypewithin()
Let’s see how you do that with the @AspectJ syntax.
When you’re using traditional-style aspects, you can access an aspect instance using the automatically added aspectOf() method (see section 6.2.6 for details)
For per-object or per-type aspects, you pass the object or the class for the type as the second argument.
The traditional syntax offers the declare precedence construct to control precedence between aspects, as discussed in section 6.3.2
AspectJ syntax offers the @DeclarePrecedence annotation for the same purpose, which you use as follows:
You set the annotation’s value attribute to aspect type patterns separated by a comma—following the same rules as the traditional syntax.
Note that you must use fully qualified aspect types unless the aspect resides in the same package as the aspect declaring precedence.
Crosscutting elements in an @AspectJ aspect must be expressed using annotated elements.
Let’s examine how the various crosscutting elements map to the @AspectJ syntax.
After you’ve defined your aspects, you’ll want to add pointcuts to select join points and collect context at the selected join points.
The value parameter of the annotation represents the pointcut expression.
All other pointcut characteristics such as the name, access specification, abstractness, and parameters match with the corresponding characteristics of the method representing it.
Abstract pointcuts allow you to write reusable aspects by letting subaspects provide a definition for those pointcuts.
Here is the general form of abstract pointcut expressed in the @AspectJ syntax:
Not quite a direct mapping Because the value attribute is of the String type, you can declare only one precedence per aspect.
This is unlike the traditional syntax, where an aspect may include any number of declare precedence statements.
Equivalent functionality in the @AspectJ syntax requires using multiple aspects, with each declaring a single precedence.
In a future version of AspectJ, the attribute type may change to String[], thus resolving this difference.
Because an abstract pointcut doesn’t need a pointcut expression, the default value for the pointcut annotation suffices.
The method representing the abstract pointcut must be declared to return void.
Method parameters define the pointcut parameters that a concrete pointcut must collect as the join point context.
The following pointcut defines an abstract pointcut that doesn’t declare any parameters:
This pointcut is equivalent to the following pointcut expressed in the traditional syntax:
This pointcut is equivalent to the following pointcut expressed in the traditional syntax:
The method-access specification can be public, package (default), or protected, but not private, following the rules for an abstract method.
A concrete pointcut uses a pointcut expression to specify a join point selection criterion and collect join point context.
The method body for a concrete pointcut is empty, because the method is a placeholder without any significance for the code inside it (except the if() pointcut, which we’ll discuss shortly)
This pointcut is equivalent to the following pointcut expressed using the traditional syntax:
We’ll now examine the specific requirements for pointcuts written using the @AspectJ syntax.
The pointcut expression for a concrete pointcut is the same as in the traditional syntax (as described in section 3.4), except for two differences:
Type names, if any, must be fully qualified, unless the type resides in the same package as the aspect or belongs to the java.lang package.
If you use an if() pointcut, it must be of the if(true), if(false), or if() form.
If you use the last form, the method body must specify the selection criteria for the pointcut, as we’ll discuss later in this chapter.
You’re required to use fully qualified type names because import statements aren’t retained in compiled byte code.
That makes it impossible for the Aspect weaver to deduce the type from the pointcut expression string.
For example, the following pointcut must specify the fully qualified type names even if the corresponding types are part of import statements:
It’s also equivalent to the following pointcut defined in a file that imports the used type:
Pointcut parameters expressed as part of the method parameters must be bound using the same pointcut expression.
For example, the following pointcut binds the pointcut context using the this() and args() pointcuts:
Weaving and error detection Although the @AspectJ syntax promotes early error detection, due to the fact that pointcut expressions are strings, errors in them aren’t reported until those strings are parsed.
If you use ajc to compile the aspects, it parses pointcuts immediately and issues any errors.
If you use AJDT, it also reports any errors immediately.
But if you use the binary or load-time weaver, parsing and (consequently) error detection occur at that time.
If you use javac to compile code that uses method parameters (such as in the previous snippet), you must use either the –g:vars (or –g, which is a superset of –g:vars) flag or the argNames parameter to the @Pointcut annotation.
This is required because the Java compiler doesn’t preserve argument names in the compiled code.
As a result, the AspectJ weaver can’t determine the correspondence between the method parameter names (which are lost in the byte code) and identifiers used in the pointcut expression (which, being part of the annotation value, are preserved)
Using –g:vars instructs the compiler to preserve argument names in the compiled byte code.
The use of this flag leads to slightly larger class files; but no degradation occurs in the runtime performance of such a class, making the use of this flag a non-issue in realworld applications.
If you can’t (or prefer not to) use the –g:vars flag, you need to use the argNames parameter to preserve the same information.
For example, the following pointcut redefines the accountOperation() pointcut to use the argNames pointcut parameter:
The value of the argNames parameter is a comma-separated list of the method parameter names in the same order as defined by the method.
Because argNames duplicates parameter names, there is a chance that it may become inconsistent when, for example, method parameters are rearranged without rearranging the argNames parameters value.
Therefore, I recommend that you use the –g:vars (or –g) flag to compile @AspectJ-styled aspects.
Let’s complete our discussion of pointcuts by examining the special treatment provided to the if() pointcut.
In the traditional syntax, you include the conditional statement in the if() pointcut definition.
With @AspectJ, you must provide the same statement in a method.
This difference in style allows more checks to be performed at compile-time even when you use a Java compiler.
For example, consider the pointcut defined using the traditional syntax:
The pointcut expression in the @AspectJ syntax is "if()" as part of the annotation value.
The method declares that it returns a boolean and the body is the expression used in the traditional syntax.
The method used for the if() pointcut must be public.
You can then use this named pointcut as a part of other pointcuts, such as the following:
You can also rewrite the same pointcut to avoid the explicit debugEnabled() pointcut, as follows:
Here, the if() pointcut is part of the expression and supplies the condition that goes with it as part of the method body.
Note that the if() pointcut can use pointcut context as well as the reflective join point objects same way as in the traditional syntax.
For example, the following pointcut uses the collected context in evaluating the condition:
For example, the following pointcut selects the execution of join points whose return type is a primitive:
Because the method corresponding to a pointcut that uses if() must be static, and because an advice may not be declared as a static method (as we’ll discuss in section 7.4), an if() pointcut may not be part of pointcut expression specified with an advice.
You can use two special forms of the if() pointcut without the accompanying method body: if(true) and if(false)
Mapping dynamic crosscutting constructs the inclusion of && if(false) in the following snippet provides a quick way to turn off the advice:
Now that we’ve completed our discussion of pointcuts, we’ll move on to advice expressed using @AspectJ syntax, which builds on the pointcut syntax.
Like a pointcut, an advice is represented with a method.
This shouldn’t be surprising considering the commonality between advice and methods, as discussed in section 4.2.1
The value attribute of the annotation denotes the associated pointcut (which can be named or anonymous), whereas the method body denotes the advice to be executed.
As in the traditional syntax, methods that stand in for advice.
Should not return a value (they must return void), except for the around advice.
This matches the traditional syntax, where advice may not return a value unless it’s an around advice.
Because a method has a name, that name is also the advice’s name.
Note that in the traditional syntax, advice doesn’t have an inherent name.
Why the special treatment for if()? Consider the following code segment, using a hypothetical alternative that follows the same style of expressing the pointcut expression as an annotation value:
The two spelling mistakes and the use of a non-existent operator will go unnoticed by a plain Java compiler, for whom the annotation value carries no meaning other than being a string value.
AspectJ chooses syntax that lets such errors be caught at compile-time.
Although all advice constructs follow common ideas, each has a few peculiarities.
The before advice is created using a method with the @Before annotation.
The value of the @Before annotation specifies the pointcut associated with the advice.
The pointcut may be named (referring to a pointcut defined in the same or a different aspect) or may be a pointcut expression.
The method used as advice must be public and must return void.
The advice name doesn’t matter from AspectJ’s point of view; but you should provide a meaningful name that represents the logic carried by the advice.
The optional arguments to the method represent the join point context.
Let’s look at a few examples of the before advice with anonymous and named pointcuts as well as with reflective access to join point information.
The first example specifies an anonymous pointcut and uses no join point context.
The aspect in listing 7.1 advises the execution of any method in the system to produce a heartbeat so that monitoring tools can check if the system is alive.
The anonymous pointcut selects all the methods except those in the ajia.monitoring package to avoid infinite recursion that would result from advising the beat() method.
But in most cases, you’ll want to use a named pointcut.
By separating the definition of the pointcut from the advice that uses it, you create a reusable pointcut and make your code more readable.
The @AspectJ syntax provides a natural way to express this recommended approach.
Let’s modify the previous aspect to use a named pointcut, as shown in listing 7.2
Because you use a named pointcut, you may use it for more than one advice and use it as part of other pointcut definitions.
Although beatHeart() is a method, from AspectJ’s perspective, it really is an advice.
Hence, the join point corresponds to its advice-execution join point and not a method execution.
Therefore, AspectJ requires the advice to declare method parameters of the corresponding type and use those parameters inside advice.
The weaver ensures that those parameters are appropriately passed when advice is executed.
The simple aspect shown in listing 7.3 prints entry into each method.
This requires the method name to be available in the join point’s static context.
In the advice, you get reflective access to the dynamic context of the current join point by declaring a method parameter of type JoinPoint.
When the advice is executed, the information in this variable is exactly the same as you get in thisJoinPoint in the traditional syntax.
The equivalent advice in the traditional style would use the special thisJoinPoint variable available in every advice as follows:
You can always obtain the join point context using reflective access, but this approach suffers from issues such as lack of compile-time safety, reduced performance, and difficult programming (see section 4.5)
A better approach is to use pointcuts such as this() and args(), which expose the join point context with more specific types.
The @AspectJ syntax requires that the needed join point context be declared as method.
Mapping dynamic crosscutting constructs parameters the same way a traditional advice declares advice parameters.
The pointcut must then use the same parameter names to collect context in pointcut.
Figure 7.2 shows the scheme for collecting context using anonymous pointcuts.
Let’s consider an example where the goal is to log all operations on a JDBC connection (see listing 7.4)
The log statement should contain information about the connection object.
In this aspect, the advice needs access to the target of any call to Connection.
Therefore, the advice declares a method parameter of the Connection type with connection as the variable name.
The pointcut then uses a target() pointcut to bind that variable.
You can, of course, use a named pointcut, where the pointcut binds the context and makes it available to the advice.
Figure 7.3 shows the scheme for collecting context using named pointcuts.
Listing 7.4 Collecting the join point context using an anonymous pointcut.
The method parameter declares the needed context, and the context-collecting pointcut binds those parameters to the join point context.
The pointcut method parameter declares the needed context, and the context-collecting pointcut binds those parameters to the join point context.
Listing 7.5 shows the modified aspect that uses a named pointcut.
Note that you can mix reflective access to join point information with that obtained using context-binding pointcuts by including one or more variables of appropriate reflective access types.
For example, Listing 7.6 shows enhanced connection monitoring through use of static context available with the join point as well as the information about the surrounding join point.
That completes our exploration of the before advice along with many common concepts applicable to all kinds of advice in @AspectJ.
Let’s now move our attention to other kinds of advice, starting with the after advice.
In AspectJ, the after advice has three variations: after (finally), after returning, and after throwing.
The after (finally) advice, which executes regardless of how the join.
Listing 7.5 Collecting the join point context using a named pointcut.
Mapping dynamic crosscutting constructs point execution completes (normally or by throwing an exception), is similar to before advice from the code point of view because the information available to the advice is exactly the same.
The other two variations of after advice (after returning and after throwing) come in two sub-variations.
The first variation uses the fact that the join point executes normally or by throwing an exception.
The second variation collects either the returned object (for the after-returning advice) or the thrown exception (for the afterthrowing advice)
Often, you need to collect the result of the join point execution.
The second variation of the after advice—the one that needs access to the returned object or the thrown exception—must be expressed differently.
For the after-returning advice, you can specify an additional parameter to the method and use the parameter name as the value of the returning attribute of the annotation to that parameter name.
The after-throwing advice is similar: you specify an exception type as the method parameter and use the name of the parameter as the value of the throwing attribute.
Let’s modify the example in the listing 7.8 to collect the return value and thrown exception.
This is required because the annotation specification in Java lets you omit the attribute name only if a single value is specified and the attribute name is value.
Also, note that the pointcut attribute is available, which you can use in place of value.
If both pointcut and value attributes are specified, the pointcut attribute takes precedence.
The type of the return value or the exception specified limits the advice applicability to where the return object or the thrown exception is assignable to the specified type.
For example, instead of specifying Object as the return value type, if you specify Statement, only methods that return Statement or its subtype will be selected.
This behavior is identical to that seen with the traditional syntax.
The last kind of advice—around advice—comes with interesting peculiarities owing to its power.
Let’s look at it to complete our discussion of dynamic crosscutting support in @AspectJ.
The method must be public and may return a value.
The rules governing the return value are the same as the rules in the traditional syntax.
Specifically, the return value must be compatible with all matching join points.
For example, the method may return void only if all matching join points return void.
Similarly, the method may return Collection only if all matching join points return Collection or its subtype.
The method may also return Object, where the matching join points may return any type and the weaver takes care of necessary unboxing and casting.
What happens when you want to implement the advice logic and want to proceed with the original join point? In the traditional syntax, you do so by using the special keyword proceed() in around advice.
Instead, you must take the same approach as with thisJoinPoint and related variables.
The no-argument proceed() proceeds with the original join point with unaltered join point context (the execution object, method arguments, and so on)
This approach is useful in the majority of cases, where there is no need to alter the context.
Listing 7.10 shows a use of no-argument proceed() (you’ll use this aspect in a running example in the next chapter, where you’ll define a concrete subaspect for it)
Notice that the measureTime() method declares that it throws a Throwable.
This is required because proceed() declares that it throws Throwable to accommodate for exceptions a join point may throw.
For example, a join point invoked by calling proceed() may throw SQLException or IOException.
The rules of engagement are different if you need to proceed with the join point with altered context.
In a few use cases of the around advice, the original join point must be invoked with an altered context.
In those cases, you need to use the other form—proceed (Object[])—to pass the new context.
The array passed to the call must contain elements in the following order:
The this object or its replacement (only if you collected context using this())
The target object or its replacement (only if you collected context using target())
The join point’s arguments or its replacements, in the same order as needed by the join point (even if you did not use the args() pointcut to collect them)
This logic is best illustrated by the following utility method, which takes care of these rules to form the array that can be passed to proceed(Object[])
The method expects that the caller passes in the objects to be used as this, target, and arguments.
If you don’t collect either of the first two, the caller passes a null for them:
This scheme of proceeding with altered context is different from that used in the traditional style, where you pass objects matching the collected context.
The @AspectJ style is especially weak when you need to alter the context collected by arguments, because you’re forced to know the exact position of the argument you want to alter, in turn forcing the advice to know too much about the join point.
For example, imagine an advice to two methods, with the first method taking a PaymentService object as the first argument and the other method taking it as the second argument.
If you want the methods to proceed with an alternative payment service, you must set the first parameter for the first method and the second parameter for the second method, forcing the advice to examine details of the join point.
In the traditional syntax, you invoke proceed() with the parameter corresponding to the service collected.
In that case, the decision of collecting the PaymentService argument from the two methods resides with the pointcut, which is the right place to know more about the selected join point.
To summarize, dynamic crosscutting is well supported in the @AspectJ syntax.
All the things that you can do in the traditional syntax can be done with the @AspectJ syntax.
Yes, the approach has a few differences, such as the if() pointcut and the invocation of proceed() in an around advice; but overall, @AspectJ is a fairly easy syntax to learn once you understand the traditional syntax.
Static crosscutting, on the other hand, has some significant differences imposed by the core design constraint of compilation with javac.
Although some features are implemented in a straightforward way, others are complex.
Recall that static crosscutting modifies the structure of a program.
It comes in many forms: introducing members, declaring new types as parent type, attaching annotations, compile-time errors and warnings, and exception softening.
As a result, not all features can be implemented in @AspectJ.
Then, we’ll examine how @AspectJ maps the declare parents feature.
In the section that follows, we’ll examine the features that aren’t available with the @AspectJ syntax.
The value of the string is the message emitted by the weaver upon detecting the occurrence of a matching join point; the annotation attribute specifies the.
For example, the following snippet results in the issue of an error for every join point matching the callToUnsafeCode() pointcut:
This ensures that the variable remains unmodified during program execution.
Otherwise, confusion may exist between the message in the source file and its runtime value.
Further, the string specified must be a literal and not a result of a call to a static method.
This constraint ensures that the weaver can access the message string without executing any methods.
With the traditional syntax, it’s possible to use declare parents statements to add new parent types (class or interface) to a set of existing types (see section 5.2 for details)
An AspectJ weaver can then take into account the effect of such statements during code compilation.
For example, if the Account type is declared to have Entity as a parent, the AspectJ compiler lets an Account object be assigned to a variable of Entity type.
The Java compiler, on the other hand, can’t understand the meaning behind a declaration expressed in an annotation and won’t allow such assignments without an explicit typecast.
Therefore, you’ll see some significant differences in how declare parents is supported in the two syntaxes.
The support for declaring parents comes though the @DeclareMixin annotation.
This annotation mixes an interface into a matching set of types and delegates the implementation to a specified object.
To mix in a set of types, you annotate a factory method with this annotation and specify a type-pattern to select types being mixed-in as its value attribute.
The return type of the method (which must be an interface) is mixed in with the matched types.
The AspectJ weaver uses the object returned by the method to delegate the implementation for the mixed-in interface.
If the interface isn’t a marker interface, you need to consider additional constraints, as we’ll discuss next.
If the interface used in @DeclareMixin isn’t a marker interface, either the classes selected by the type pattern must already implement the methods for the interface or the factory method must return an object to delegate the implementations for the interface methods.
Listing 7.11 The interface for any types that need the id property.
Listing 7.12 Account-tracking aspect declaring parents to the tracked types.
Of course, requiring classes to already include an implementation isn’t useful in most situations.
Therefore, the method annotated with @DeclareMixin annotation must return an object that is used as the delegate.
Listing 7.13 shows a modified aspect that doesn’t require the selected types to implement the methods in the parent interface.
The AspectJ weaver uses the return object to delegate implementation of the interface to the types specified.
The annotated factory method is public and may be declared static.
If it’s an instance method, it can use aspect instance members while creating the delegate object.
For example, if an aspect is injected with a dependency, that dependency may be passed on to the delegate object.
The method annotated with the @DeclareMixin annotation can declare a single parameter.
In that case, AspectJ passes the object being mixed in as that parameter.
You can pass this parameter to the delegate object being created if it needs access to the object being mixed in.
In the following snippet, the mixedIn parameter is the object into which the Auditor interface is being mixed in:
By default, the return type of the factory method is the type to be mixed in.
Only methods that belong to that interface are delegated to the returned object.
You can control the interfaces to be mixed in by specifying the interfaces attribute of the annotation.
So far, you’ve seen ways to introduce a parent type.
But how do you use the introduced type? Specifically, how can you invoke methods specified in the declared parent interface on regular objects? UTILIZING THE INTRODUCED TYPE.
With a @DeclareMixin statement, the weaver modifies the byte code for the child types to make them implement the parent type.
For example, the statement in the previous section modifies the Account class to implement the Identifiable interface.
As a result, you’ll get compilation errors if you assign an Account object to a variable of the Identifiable type.
You can fix these errors by specifying a typecast, as shown in listing 7.14
Most likely, an advice will use the new parent type.
In that case, you can avoid typecasts by using an appropriate context-collecting pointcut.
For example, the code in listing 7.15 assigns the desired type to the collected context without the need for a typecast.
Listing 7.14 Using a typecast to use the new declared parent interface.
You therefore use an Identifiable variable in the advice declaration and bind it using the this() pointcut.
In summary, the declare parents feature comes with a few interesting twists.
But when you need full power, you must use the traditional syntax.
There are other reasons to use the traditional syntax—primarily the lack of equivalent constructs in the @AspectJ syntax.
Let’s discuss the AspectJ features that aren’t available with the @AspectJ syntax.
AspectJ strives hard to offer a reasonable and intuitive mapping to @AspectJ syntax for most features.
Let’s start with the feature that is currently not implemented.
As discussed in section 5.4, the various ways to declare annotations offer means to attach annotations to program elements in a crosscutting manner.
The current version of AspectJ doesn’t offer the same facility with the @AspectJ feature.
This feature isn’t implemented because there isn’t an elegant mapping that allows compilation using javac and performs as much compile-time checking as reasonably possible.
Let’s discuss the features that can’t be implemented in @AspectJ due to the fundamental constraints of compiling code using a plain Java compiler.
With the traditional syntax, you can introduce additional members (data and methods) directly to other types.
The introduced member can then be used like any other member (without consideration for whether the member existed because the type declared it or because an aspect introduced it)
When an introduced member is encountered, the AspectJ compiler treats it correctly because it understands the semantics behind the member.
A plain Java compiler, oblivious to such semantics, can’t compile such code.
For example, consider the following code, which uses a hypothetical syntax to introduce a data member:
A plain Java compiler won’t realize that the dirty field has been introduced by an aspect, making such an introduction useless, even if it were possible.
The next feature is also useless due to the Java compatibility constraint, even if implemented.
Exception softening lets you treat specified checked exceptions as unchecked at certain join points.
This feature relies on the AspectJ compiler’s ability to use directives to treat exceptions thrown by join points as runtime exceptions during compilation and hence not force handling of the exceptions.
A plain Java compiler can’t understand the expected compile-time behavior.
Although you can declare an intent that the AspectJ compiler should be able to understand, a Java compiler won’t modify its compile-time behavior.
But the same part can also be implemented easily using an AfterThrowing advice:
Note that an advice alters only the runtime behavior and will still force the caller to handle the exception even if RemoteException will never be thrown.
The real value of declare soft is its compile-time behavior.
If that can’t be provided, there is little left in the feature to be a useful addition.
As discussed in section 6.4, privileged aspects are allowed to bypass the regular Java access rules.
In most systems, this isn’t a burden, because you shouldn’t use this feature too often anyway.
Let’s compare the syntax choices with regard to ease of learning, code verbosity, crosscutting expression power, tool friendliness, and ease of adoption.
This will help you choose the right syntax based on your specific needs:
The syntax is “plain” in that a Java compiler doesn’t choke on it.
From a programmer’s perspective, you still have to learn the pointcut syntax and advice semantics.
When choosing one syntax over the other, ease of learning isn’t a factor.
Verbosity —The traditional syntax is the most compact because it’s specifically designed to express AOP constructs.
Further, the traditional syntax can use types referring to import statements, shortening the pointcut expressions.
But the @AspectJ syntax must always use fully qualified types, which can lead to difficult-to-read pointcut expressions.
Crosscutting expression power —Because the traditional syntax requires the use of a special compiler, it liberates the program elements from a few Java rules (such as allowing ITDs and exception softening) and facilitates advanced applications of AOP.
Depending on the application, the difference in power may be a deciding factor.
If all you need is dynamic crosscutting, you won’t feel that the @AspectJ syntax is much less powerful than the traditional syntax.
But if you must use advanced static crosscutting, you may have to use the traditional syntax.
Tool friendliness —The traditional syntax is foreign to most Java tools and will cause difficulties for those tools.
The @AspectJ syntax, owing to the fact that aspects may be treated as regular Java classes, offers tool friendliness.
The @AspectJ syntax works reasonably well in an environment without specific support for AspectJ (IntelliJ IDEA, for example), because such environments can treat the AspectJ code as the Java code.
For example, in Eclipse, you get all the goodies, such as the.
Certain tools, such as Emma (http://emma.sourceforge.net), work at the byte-code level; in those cases, because aspects compile to standard-compliant byte code, there is no difference in tool friendliness for either syntax.
Note that even with @AspectJ, you still need an AspectJ-aware IDE to see the crosscutting reference view and visualize the relationship between program elements and aspects.
For example, IntelliJ IDEA users don’t get this functionality easily (AspectJ includes a standalone ajbrowser tool and ajdoc, but the user experience isn’t the same)
Adoption ease —The simplified adoption of a new technology requires a pay-asyou-go approach that offers a way to introduce the technology with minimal impact on your development tools and processes.
The @AspectJ syntax offers a gradual path to AOP adoption that may follow these lines: – If your application is based on the Spring Framework, you can use Spring’s.
Instead, Spring uses the information in an aspect to create proxies around beans to implement the crosscutting functionality.
Further, the Spring IDE (an Eclipse plug-in) offers the cross-reference view that lets you visualize the interaction between beans and aspects.
Using the @AspectJ syntax along with proxy-based weaving is popular in Spring applications and experiences virtually no resistance during adoption.
When you need more power than that offered by Spring’s proxy-based AOP, you can continue to use the @AspectJ syntax along with a build-time or loadtime AspectJ weaver.
The @AspectJ syntax used this way requires minimal changes to your tool chain or build and deployment processes, thus simplifying its inclusion.
When you need even more power, you can write a few aspects using the traditional syntax.
I’ll make a few more recommendations about choosing syntax in the next chapter, after you’ve learned about weaving choices.
AspectJ’s approach to providing an AOP solution for Java is a pragmatic one.
The real world is full of varied needs and preferences.
To respond to these needs, AspectJ provides choices for the syntax.
On the language side, a one-size-fits-all approach, which seems attractive because it reduces the size of the language, may not work well.
The annotation-based @AspectJ syntax offers most features of the traditional syntax approach while staying within the limits of plain Java.
Combined with an AspectJ weaver, the @AspectJ syntax offers a great way to use AspectJ without making any significant modifications to tools.
AspectJ’s approach to creating an annotation-based syntax fully leverages the Java language, making it possible to flag programming errors as soon as possible.
When it comes to dynamic crosscutting, where runtime behavior is affected, @AspectJ offers the full power of AOP.
With static crosscutting, given the use of a Java compiler, a subset of features is offered, which should be sufficient to implement most applications of AOP.
We aren’t finished with choices yet! The next chapter discusses another set of decisions regarding weaving models and a related additional syntax based on XML.
The most basic form of weaving is build-time source-code weaving, where the AspectJ compiler compiles source files to produce a woven system.
Although this form offers the best experience by providing immediate feedback for source-code errors and by eliminating deployment modifications, using a new compiler can impede AOP adoption.
One alternative is build-time byte-code weaving, which lets you delay the introduction of the special compiler until after you compile the code.
It also offers a way to weave even when you don’t have access to the source code for classes or aspects.
Load-time weaving goes further by eliminating the weaving step from the build process.
Instead, it weaves classes as they’re loaded into the VM.
Load-time weaving is often the first choice for AspectJ-based tools that want to add AspectJ weaving models.
But for aspects to have effect, you need to weave them.
Weaving, a fundamentally critical mechanism in implementing AOP, composes classes and aspects into an executable system.
All these choices make adoption of AspectJ easier than ever before.
We’ll also discuss the XML syntax, which offers a simpler way to modify aspects without requiring recompilation.
We’ll end the chapter by comparing all the choices and creating guidelines for choosing the appropriate weaving model in a given situation.
You can classify an AspectJ weaving model based on when it performs weaving and which kind of input it processes.
Based on when it performs weaving, AspectJ offers two weaving models:
Build-time weaving weaves classes and aspects together during the build process before deploying the application.
Load-time weaving (LTW) weaves just in time as the classes are loaded by the VM, obviating any pre-deployment weaving.
Based on the kind of input a weaver processes, you can classify weaving models two ways:
Table 8.1 shows the weaving possibilities supported by the AspectJ weaver.
AspectJ supports build-time weaving that can take either source code or byte code.
For LTW, the primary supported input is the byte code.
For example, you may have a few aspects woven in using source-code build-time weaving and a few more (say, third-party aspects) using byte-code build-time weaving.
Then, you can use XML-based aspects using source-code load-time weaving.
You may also weave in aspects (again, perhaps, third-party aspects) using the byte-code load-time weaver.
Let’s examine the details of each supported weaving model, starting with buildtime weaving.
The compiler produces woven byte code (as class files or as a jar depending on the compiler options)
You can then deploy the resulting byte code in any standard compliant VM.
Except for adding aspectjrt.jar to the classpath, you don’t need to make any changes in deployment.
The aspectjrt.jar file contains definitions for the various user accessible AspectJ types such as JoinPoint and Signature, various @AspectJ annotations, as well as internal AspectJ types utilized during runtime.
The quick feedback you get from the compiler is invaluable.
Build-time weaving is the only choice when it comes to certain static crosscutting usages.
For example, consider an aspect that introduces a method to a class using an ITD.
Such a method must be woven in to successfully compile the classes that use the introduced method.
Waiting until LTW will lead to compilation errors in the accessing classes aborting any further steps.
Build-time weaving is also attractive for refactoring aspects, where the classes often embed aspects.
Build-time weaving can work with either source or binary code.
In this most common weaving mechanism, the weaver accepts classes and aspects in the source format (written using the traditional syntax or the @AspectJ syntax)
The compiler produces byte code, which you can execute in any standard VM.
This option is similar to using javac to compile Java sources.
In this book, we’ve so far used this model to compile all the examples.
Using build-time source-code weaving essentially involves replacing javac with ajc.
The AspectJ compiler is based on the Eclipse Java compiler.
Java sources and aspect sources are provided as the input to ajc, which produces the woven system.
For example, to weave the tracing logic in all banking classes, you supply sources as follows:
You can also specify the root directories of the source files you want to compile by passing the list of directories to the -sourceroots option.
The AspectJ compiler then compiles all source files under each specified directory and its subdirectories.
Instead, you’ll use Ant or Maven as discussed in appendixes B and C, which shows all the options in this chapter using build scripts.
The AspectJ compiler supports additional options such as -showWeaveInfo, to show information about how AspectJ is weaving classes with aspects, and –Xlint, to produce useful warnings about potential programming mistakes.
See the AspectJ documentation (http://www.eclipse.org/aspectj/doc/released/devguide/ajc-ref.html) for the full list of options.
Even when you present source files as input to the compiler, the AspectJ compiler first compiles the code into bytecode form and then weaves the resulting byte code together.
Often, you don’t have access to the source code for the classes or aspects or both.
For example, you may be using a third-party library for classes or aspects.
This isn’t the case with ajc; instead, you must pass all the input files together in one invocation.
For example, the following two commands will not produce the same result as the earlier command:
The apparent intention is to weave the tracing aspect into the banking-related classes.
But TraceAspect.aj isn’t included while compiling the banking classes, so no such weaving occurs.
Build-time weaving source-code weaving won’t be useful for such a scenario.
AspectJ’s build-time binary weaving offers a solution in such cases.
These classes may have been compiled using either a Java compiler or the AspectJ compiler; it doesn’t matter.
Aspects written using the @AspectJ syntax may have been compiled using either the Java compiler or the AspectJ compiler.
Much the same as for classes, using the Java or AspectJ compiler makes no logical difference.
You must use the –g:vars or –g option, as described in section 7.3.2, when compiling aspects using javac.
Aspects written using the traditional syntax, of course, must have been compiled using the AspectJ compiler, because javac won’t understand the syntax.
Weave classes with aspects by presenting their byte code to another invocation of ajc, which produces a set of classes or a jar file depending on the options provided.
Any standard VM may then execute the resulting byte code.
From a usage perspective, the difference between source code weaving and binary.
The only difference is the flags that specify sources or byte-code input.
The following command uses the classes in services.jar as input to be woven in with aspects in monitoring.jar:
You can combine source-code and binary weaving in a single command.
For example, the following command uses source-code weaving for files with a .java extension in the.
Java and aspect byte-code files are provided as the input to ajc, which produces the woven system.
You can use the –outjar option of ajc to produce a jar file.
This jar file can be used as a part of the final system.
It may also be used as input to another invocation of ajc, as byte code input to be woven in (using -inpath) or aspects to weave in (using -aspectpath)
Figure 8.3 shows how you can create an aspect library using javac or ajc and how you can use such a library with binary weaving.
You can compile the source code (including aspects expressed using the @AspectJ syntax) using javac.
Then, you can use binary weaving to produce the final system.
Jar by –outjar: nothing special Note that the jar file produced by using –outjar is a packaged version of the class files that would be produced if you didn’t specify the flag.
In other words, no additional information is added to the packaged jar file when you use this flag.
Figure 8.3 Creating an aspect library involves using –outjar or explicitly using the jar tool.
When you use the library, you need the –aspectspath and –inpath options.
The output of the system can be multiple class files or a jar file, depending on how you use the –outjar option.
This style also helps keep your build process unchanged up to the point of creating jar files for plain Java source files.
You can then augment the build process with an additional build step that weaves in the needed aspects.
As shown in the figure, the existing build system produces a jar file.
The AspectJ compiler weaves aspects into that jar file to produce a woven jar.
Build-time weaving can be easy or difficult to start, depending on your perspective.
If you use build-time binary weaving, you can even leave your build system or IDE setup intact except for an additional post-compilation step.
When it comes to deployment, except for including aspectjrt.jar in the classpath, you can ignore the fact that the system was built using the AspectJ compiler.
But you may also perceive it as difficult because it affects how you build your system; and, for a certain class of crosscutting concerns, it may be a bit burdensome.
LTW, discussed in the next section, offers a solution in those cases.
Support for XML syntax in build-time weaving The current version of AspectJ doesn’t support XML syntax (described in section 8.3.2) with build-time weaving.
There is no fundamental reason for this, so expect a future version of AspectJ to support aspects defined using XML-based syntax.
Figure 8.4 Augmenting the existing build system to weave in the aspects.
Let’s say you want to monitor the behavior of your application to see if there are any performance bottlenecks.
Or, perhaps you want to include a concurrency monitoring aspect to debug a deadlock situation.
In either case, you don’t expect to keep the aspects in the system after they have served their purpose (finding the code responsible for performance bottlenecks and deadlocks)
Modifying the build system only to weave aspects that you don’t intend to keep in the system for a long time can be a hindrance.
For such cases, load-time weaving provides a way to leave your build system intact and still weave aspects as needed.
The mechanism used for LTW is an extension of binary weaving.
LTW, much like binary weaving, takes byte code as input.
The difference is that unlike with binary weaving, there is no explicit weaving step.
Instead, the VM is set up to perform weaving as the VM loads the classes—hence the name load-time weaving.
The load-time weaver is a JVMTI agent that uses this functionality to weave in classes as the VM loads them.
This agent, of course, works only with Java 5 and newer VMs.
For pre-Java 5, you can use a classloader-based version, because a classloader, too, offers a way to intercept the loading of a class and modify its byte code before the VM loads it.
But unlike the JVMTI solution, a classloader-based solution is often application-server specific.
The load-time weaver needs additional information to decide which aspects to weave.
Although the weaver could examine the classpath to detect aspects present, that would be a prohibitively expensive approach because every class on the classpath would have to be checked to see if it was an aspect.
Weaving all aspects found on the classpath may not be desirable, anyway.
Therefore, the weaver requires that you explicitly specify each aspect in an aop.xml file in the META-INF directory on the classpath.
Because many classpath entries (jar files and directories) may contain an aop.xml file, the weaver uses them all by combining the information in them.
Figure 8.5 shows the overview of arrangement used by LTW.
Spring-native load-time weaving Spring version 2.5 supports LTW that obviates the use of a JVMTI agent on certain application and web servers.
It also supports the use of an alternative JVMTI agent that serves other purposes (specifically, to aid Java Persistence API (JPA) based implementations)
During initialization, the agent loads all the files matching META-INF/aop.xml in the classpath.
It examines each aop.xml file for the list of aspects.
It also examines any inclusion or exclusion filter specified (see the next section for more details)
If the agent finds multiple aop.xml files in META-INF directory on the classpath, it logically combines them.
The agent loads the listed aspects that also match the inclusion and exclusion conditions.
The agent registers its interest in the class-loading event so that the VM gives it an opportunity to examine and possibly modify a class being loaded.
The weaver intercepts loading of any class to weave in appropriate aspects.
This option is useful when you want to try multiple load-time weaver configurations quickly.
In this book, when I refer to aop.xml, the discussion applies to the alternative files as well.
The VM notifies the agent whenever it loads a class.
The agent, in turn, inspects the class to determine if any of the loaded aspects need to be woven in.
If so, it weaves the class and hands over the modified byte code to the VM.
The VM uses the woven byte code to realize the class.
As you may guess from these steps, LTW has a definite impact on load-time performance.
Specifically, the time to load the application and the memory consumed by it are higher.
But after a class is loaded into the VM, there is no additional performance penalty.
The woven byte code produced by LTW is identical to the byte code you would obtain using build-time weaving.
In a way, you need to pay for weaving at some point between writing code and executing the system.
For build-time weaving, you pay at build time; and for load-time weaving, you pay at class-loading time.
Although significant optimizations are being added to LTW, depending on your usage, you may get performance improvements by offloading the weaving step away from deployment.
An important component of LTW is the aop.xml files that configure the weaver.
The LTW configuration specifies the aspects and classes participating in the weaving process, the definitions of pointcuts for abstract aspects, and various debugging options.
Logically, the XML files are a kind of source code useful only for LTW.
Except for the XML files, all other input must be first compiled using the Java or AspectJ compiler.
This is similar to how Java Server Pages (JSP) work; although the web container will compile JSP files to byte code (typically, after first compiling to source code), all.
OSGi and LTW OSGi defines an architecture for dynamic and modular Java applications.
Eclipse, of course, is a well-known application based on the OSGi platform.
On the server side, too, OSGi is gaining popularity through application servers such as the SpringSource dmServer (http://www.springsource.org/dmserver)
Typically, a bundle includes Java types as well as metadata to export and import types and services.
The Equinox Aspects project (http://www.eclipse.org/equinox/incubator/aspects) lets you add aspects to a bundle.
It can then weave those aspects into other bundles as they’re deployed into the OSGi container.
Recently, the AJDT project has started using Equinox Aspects to weave AspectJ tooling functionality into JDT.
The Scala plug-in has taken a similar approach based on Equinox Aspects.
Load-time weaving other Java code must have been already compiled.
Often, you need to supply a reusable concrete aspect to the load-time weaver.
The name attribute of the element is a fully qualified type name.
Note that a type pattern isn’t allowed as an attribute value.
You must define concrete subaspects for those aspects to be woven in.
Listing 8.2 shows an example of a concrete aspect defined using AspectJ’s XML syntax by providing a definition for the abstract pointcut in the base aspect.
The use of XML to define pointcuts offers an easy way to modify the definition and affect system behavior without recompilation.
For example, if you need to monitor the execution of methods in banking classes along with JDBC, you change the pointcut to the following definition:
Unlike with traditional or @AspectJ syntax, you can’t define or override methods in the base aspect.
You can’t, for example, use an args() pointcut to collect arguments to a.
This limitation makes aspects expressed using XML suitable only for scoping purposes.
For instance, you may have a base class that defines a pointcut to do the primary selection along with an abstract-scope pointcut.
You can then provide the definition for the scope pointcut in XML.
The pointcut must use fully qualified type names similar to @AspectJ syntax and for the same reason: XML syntax doesn’t support a feature comparable to Java import statements.
But note that you can always use wildcards to select a set of types as usual.
Given these restrictions, you may have situations where you need to use the traditional or @Aspect syntax to define concrete aspects.
As you may recall from chapter 6, without explicit declarations, the order in which advice from multiple aspects apply is arbitrary.
AspectJ provides a mechanism to control precedence among multiple aspects.
To specify aspect precedence, you define a <concrete-aspect> element and specify the precedence sequence in its precedence attribute.
The concrete aspect specified in this manner is merely a placeholder that should not extend any abstract aspect or define any pointcuts.
For more advanced use of LTW, you need more control.
Specifically, you need to specify aspects and classes participating in the weaving process.
In contrast, the <weaver> section specifies the classes to weave into, in addition to controlling other weaver parameters.
Each <include> element specifies a type pattern for the within attribute.
A common use of the <include> element is to weave only a subset of aspects declared in other aop.xml files.
For example, the aop.xml in an aspect library may list all its aspects.
But another aop.xml may limit weaving to only a subset of those aspects by using an <include> element.
Similarly, optional <exclude> sections specify type patterns for the aspects to be excluded.
A common use of <exclude> is to exclude aspects defined in other aop.xml files.
It serves a purpose similar to that of the <include> element, except that it allows exclusion instead of inclusion.
In this case, you’re excluding deadlock-detection aspects by specifying a type pattern that selects all subaspects of DeadLockDetection.
You also exclude all aspects that carry the @Untested annotation.
The <weaver> element controls the classes to be woven in along with a few other characteristics of the weaving process.
The <weaver> element can specify the options passed to the weaver using the options attribute.
The <include> element specifies a type pattern for the types exposed to the weaver, which is thus available to be woven in.
By default, the weaver weaves in all types exposed to it.
The <exclude> element specifies a type pattern for the types that shouldn’t be exposed to the weaver.
Note that the weaver excludes all types in direct or indirect subpackages of java, javax, and org.aspectj by default.
Finally, the <dump> section can specify woven types that should be written to the disk for diagnostic purposes.
The optional beforeandafter parameter specifies whether the unwoven classes should be dumped as well.
This may be useful to examine generated classes such as those for JSP pages.
You may run into a situation where you have multiple aop.xml files.
When you have multiple aop.xml files in various components in the classpath, AspectJ’s load-time weaver logically combines all those files.
Because the net effect is the logical combination, it may have surprising results.
The recommended practice is that the aop.xml file associated with each library should only list aspects using the <aspect> elements and not exclude any aspects using wildcards.
Although excluding specific aspects in the library isn’t a problem, using a wildcard can end up choosing aspects in other libraries and may lead to surprises.
Instead, you should use an additional aop.xml file to choose aspects to be woven in.
Let’s put all the information in this chapter to good use by seeing an example in action.
In the next chapter, we’ll use the same example to illustrate Spring-driven LTW.
You’ll use the jpetstore sample web application based on the Spring Framework and Tomcat as the web server.
But as you’ll see, you can easily modify the example to use with any application and server.
Start with the copy of jpetstore provided in the downloadable sources.
The downloaded sources contain scripts for Windows and UNIX platforms.
Automatically generating aop.xml AspectJ offers –outxml and -outxmlfile compiler options to create weaver configuration files.
You can include the generated file in the aspect library jar.
When you include the resulting jar in the classpath for the system, the load-time weaver automatically considers all the aspects in the library for weaving.
Of course, if you don’t want a particular aspect, you can add an <exclude> element in another aop.xml file.
Many times, especially when you’re learning to use LTW, you’ll encounter issues that have little to do with LTW but are rather due to errors in the application.
Therefore, it’s prudent to run the application without LTW as the first step.
Assuming the default Tomcat settings, this will also explode the war file that you’ll need for the next step.
Visit the web page for the application (with default settings, at http://localhost:8080/jpetstore), and buy a few pets.
If everything goes fine, follow the next steps to add LTW.
Compile the aspect, and copy the resulting class and aop.xml file to the deployed web application using the following commands:
Alternatively, you could copy the resulting class file and META-INF/aop.xml into the classes directory in the application’s WEB-INF directory.
You could also bundle the same files as part of the war file.
The only things that matter are that the class files corresponding to the aspect be available on the classpath and that aop.xml be included in a META-INF directory in a classpath component.
Next, modify the new file by adding the following snippet at the top, to add the AspectJ LTW agent to the Java VM used by Tomcat:
To see the effect of the aspects, revisit the application’s web page, and buy a few pets:
As you can see, you get monitoring of every call on any JDBC object.
Play around—in particular, modify the monitored() pointcut in aop.xml to monitor different parts of the system.
Also, if you have a web application running with Java 5 or above, try adding LTW-based monitoring to it.
Which weaving model is best suited: build-time or load-time? Which syntax is the best: traditional or @AspectJ? All these choices have pros and cons, with no clear winner in all situations.
This realization is behind AspectJ’s support for multiple syntaxes and weaving models.
In this section, we’ll look at some guidelines you can follow to help choose the right syntax and weaving model in a given situation.
Although these guidelines are somewhat prescriptive in nature, their main purpose is to help you simplify the decision-making process.
Considering your unique circumstances, you may want to deviate from these guidelines:
The team is using Eclipse, and AspectJ is a core part of the design.
Use the traditional syntax, because it will lead to the most compact code and provide the full power of AspectJ.
You can use build-time weaving, because the plug-in makes its usage easy.
Although plug-ins are available for other IDEs (NetBeans, for example), in the short term, they won’t be as good as the Eclipse plug-in.
The team isn’t using Eclipse, and AspectJ is a core part of the design.
Use the @AspectJ syntax if you must work in non-Eclipse environments.
Let the IDE compile classes and aspects through its normal build process.
Use a post-build step to weave classes and aspects together.
Even though the IDE isn’t AspectJ aware, debugging won’t be a problem.
You can set breakpoints in normal classes as well as those carrying the @Aspect annotation.
You’re also likely to use pre-built third-party (open source or otherwise) aspects instead of developing your own.
In this situation, because you aren’t yet sure about the scope of AspectJ usage in your project, it’s best to not alter your build environment.
If you’re using Java 5, due to the simple configuration to set up the weaving agent, LTW should receive your first consideration.
All you’ll need to do is make a few modifications to your startup script (add the –javaagent option) and create an aop.xml file (to define aspects to weave in and define concrete subaspects)
If you’re using pre-Java 5, although you may use a classloader-based LTW, it can be difficult to set up correctly at first.
As in figure 8.4, let the main build system produce jar files.
Create another build script to take that input and weave aspects into it.
Whenever you face choices for AspectJ usage, start with these basic recommendations.
After you gain sufficient experience, you’ll figure out needed improvisations.
AspectJ’s approach to providing an AOP solution for Java is pragmatic.
The real world is full of varied needs and preferences.
The weaving models offered by AspectJ simplify its use in a wide variety of applications.
Build-time weaving is the easiest approach for many applications due to the experience provided by AspectJ-aware tools such as the Eclipse AJDT plug-in.
But it requires an upfront cost that can sometimes be prohibitive, especially while you’re still deciding if you want to go the AOP route.
Binary weaving offers a choice of keeping the build environment largely unchanged by requiring a post-build weaving task.
The other weaving model, load-time weaving, offers a simpler alternative.
You aren’t yet finished with choices! The next chapter discusses another possibility that is both an alternative syntax and an alternative weaving model: Spring-AspectJ integration.
It allows components to be wired in a declarative manner.
The enterprise services abstraction encourages isolating stable application logic from volatile infrastructure code.
Of course, our main interest here is the use of AOP in Spring.
All of these features work together to offer a compelling solution.
The central theme in Spring is the use of plain old Java objects (POJOs) as the primary backbone of an application.
Each POJO is just that—a plain old Java object that isn’t tied to any framework artifacts.
POJOs let you focus on the core concerns of a class and isolate the stable business logic from the volatile infrastructure.
The result is the creation of a loosely coupled system that is faster to develop, easier to Integration with Spring.
The Spring Framework, a widely used enterprise application framework, is based.
But for a typical enterprise application, POJOs alone can’t provide all the needed functionality.
Specifically, POJOs can’t deal with crosscutting concerns without duplicating code and tying into infrastructural code.
Spring offers AOP as the way to deal with the crosscutting concerns.
In this chapter, we’ll look at the Spring integration options for AspectJ and provide guidelines for choosing the right form for a given scenario.
Of course, you should also read the comprehensive documentation that comes with the Spring Framework (http://www.springsource.org/documentation)
As we discussed in chapter 1, various AOP systems can implement the general AOP concepts in a variety of ways.
Although their styles and capabilities differ, all the systems aim at the same problem of modularizing crosscutting concerns and share the core concepts.
Spring provides its own way of implementing AOP: the main highlight is the use of proxies that avoid the need for explicit weaving (build-time or load-time)
This kind of solution offers the lowest barrier to adoption, because you’re still programming in plain Java.
Spring’s AOP, although not as powerful as AspectJ, offers a pragmatic solution to modularize commonly encountered crosscutting concerns in a typical enterprise application.
If you need more power, you can always use AspectJ byte-code weaving, because AspectJ works with any Java application.
Spring provides a few options to simplify AspectJ usage, as well.
Spring has always included AOP as a fundamental component of the framework.
But the programming model used to be a bit complex due to the exposure of low-level constructs directly to developers.
As a result, most aspects using that model were a part of Spring itself or written by advanced Spring developers.
Starting with version 2.0, Spring simplifies the programming model through AspectJ integration that still works within the proxy-based framework (and hence doesn’t require explicit byte-code weaving)
This is an especially useful alternative if you can’t use Java 5 or above and, hence, annotations.
Spring also simplifies the use of full-power AspectJ that relies on byte-code modification techniques.
Let’s dive straight into a simple example that illustrates the use of the @AspectJ syntax with Spring.
In later sections, we’ll delve deeper into nuances of AspectJ integration.
We’ll start with a stub implementation of the InventoryService interface (developed as a part of the code in appendix A) in listing 9.1
It prints a message as the implementation of each method.
Dependency injection Objects need collaborating objects to implement their behavior.
For example, an MVC controller needs service objects so that it can invoke business functionality in response to user interaction.
An important consideration is how an object gets access to its collaborating objects.
You can create the collaborating objects inside an object that needs them, but this is undesirable due to the strong coupling with a specific implementation of the collaborating classes and difficulty in sharing the collaborating objects.
Alternatively, you can use a locator (essentially, a map) to locate a collaborating object by its key.
The objects that need dependencies often use an interface to specify the type of a collaborating object to avoid dependency on a particular implementation.
Although this improves the situation a bit, objects now have a dependency on the locator object.
Consequently, such objects can be used only in environments that support the locator implementation.
Objects declare their dependency on collaborating objects through constructor parameters, setter methods, or annotated methods and fields.
An external configuration specifies the wiring information, and a container uses that configuration to construct the objects and inject them with their dependencies.
With such an arrangement, objects have no direct dependency on the environment.
For example, in a unit test, you can directly construct an object, call its setters (perhaps with mock objects), and test it.
See http://martinfowler.com/articles/injection.html for more information on the principles behind DI.
We’ll discuss DI in more detail in chapter 16, where we examine how AOP can help implement it for domain objects.
If necessary, you can inject other beans as dependencies in the inventoryService bean as well as inject this bean as into other beans.
Finally, listing 9.3 shows a simple driver program to exercise the setup created so far.
The driver program creates an application context and obtains the inventoryService bean from it.
When you compile and run this program, you see the following output:
It’s time to add aspects written using the @AspectJ syntax into this Spring application.
Functionally, the aspect is auditing the use of the inventory service.
InventoryAuditing is an @AspectJ aspect consisting of a pointcut and an advice.
Next, you need to let Spring’s container know about the aspect, as shown in listing 9.5
In the configuration, you declare a bean corresponding to the InventoryAuditing type.
Now, when you compile the classes using the javac compiler and execute the program, you get the following output:
Without using a special compiler, you could implement auditing in the system.
Spring’s AspectJ integration provides IDE support through a set of Eclipse plugins in the form of Spring IDE (see http://springide.org/project/wiki/SpringideInstall for installation instructions)
This indispensable plugin for any project using Spring lets you visualize the effects of crosscutting concerns in a way similar to that provided by AJDT.
Note that the SpringSource Tools Suite (STS) includes Spring IDE in addition to many other plug-ins.
For this example, when you view the code developed so far inside Eclipse, you get the crosscutting information presented in a nice form, as shown in figure 9.1
As you can see, it isn’t difficult to integrate @AspectJ aspects with Spring.
You may be curious about how it all works without needing a byte-code weaver.
Spring AOP is a proxy-based AOP system that modularizes crosscutting concerns.
Based on the configuration instructions, Spring automatically creates a proxy for each bean that matches the criteria specified in pointcuts.
In this section, we’ll examine the mechanics of Spring AOP, its underthe-hood implementation, and its limitations.
Figure 9.1 Eclipse integration for Spring showing the aspect-bean interaction.
Spring AOP under the hood understanding of Spring AOP and guide you in deciding whether to use Spring AOP or AspectJ AOP.
Because the use of dynamic proxies is central to Spring AOP implementation, let’s get a quick introduction to it.
Starting with JDK 1.3, Java offers a mechanism to create proxies for interfaces.
Given a set of interfaces, you can use the Proxy class to create a proxy.
The creation method takes an invocation handler of the InvocationHandler type (which defines a single invoke() method)
The dynamically created proxy dispatches each method to the invocation handler.
You can start modularizing crosscutting functionality directly with proxies by writing an InvocationHandler whose invoke() method implements the crosscutting logic.
For example, to trace method invocations, you can write a handler as shown in listing 9.6
The handler implements the crosscutting logic in the invoke() method.
This arrangement is similar to around advice, with method.invoke() taking the place of the proceed() call.
Next, you must wrap each object that you want to trace in a proxy, using the code in listing 9.7
Listing 9.6 Tracing invocation handler to be used in a proxy.
Listing 9.7 Creating a proxy to associate an invocation handler.
Sure enough, when you execute this class, you get the following output:
Note that JDK dynamic proxies work only with interfaces; but you can use the Code Generation Library (CGLIB) and other byte-code engineering libraries to create proxies based on classes.
Although the proxy creation provides enough support to implement simple crosscutting functionalities, programming using proxies is too low level for typical needs of enterprise applications.
Lack of a pointcut language —There is no pointcut language with plain proxy usage.
This forces the invocation handlers to perform two roles: selecting the join point, and implementing crosscutting logic.
For example, if you wanted to trace only a few specific methods, the logic to select those methods would have to reside in the invoke() method.
Explicit creation of proxies —You must control the creation of each object that needs crosscutting functionality, in order to create a proxy and wrap the original object in it.
Weakly typed access to join point context —Inside the invoke() method, join point context (the target object and method arguments) is available only as the raw Object type.
This forces potentially erroneous typecasts if you need to invoke any methods on them.
All these shortcomings of the raw use of proxies make them unsuitable for implementing complex crosscutting concerns.
We need is a higher level programming model—and that is exactly what Spring offers.
Spring AOP utilizes proxies as the underlying implementation while simplifying the associated programming model.
The result is an AOP solution geared toward enterprise applications.
Spring’s programming model overcomes issues with the raw use of proxies in the following ways:
Automatic proxy creation —The Spring container already controls the creation of beans for the purpose of dependency injection (DI)
Spring can extend the creation logic to wrap those beans in an automatically created proxy.
For example, you can use the args() pointcut to make the product argument to InventoryService methods available as the Product type.
Let’s look at how Spring offers all these advantages and how it fits into the overall DI mechanism.
Spring uses proxies configured with pointcuts and advice as a mechanism to implement AOP while staying with the overall mechanism dictated by proxies.
A proxy implements the same interfaces as those implemented by the target object.
Alternatively, the proxy may extend the class of the target object.
Either way, the external code may use the proxy as a drop-in replacement for the target object.
Figure 9.2  A simplified schematic of Spring AOP with pointcuts and advice.
The proxy object is a wrapper around the target object and advisors.
The pointcut decides whether the invoked method is to be advised, and the advice contains the crosscutting functionality.
Of course, it works only when the target class implements one or more interfaces.
If this isn’t the case, or you explicitly want to avoid JDK proxies, Spring offers CGLIB-based proxies, where it dynamically creates a subclass of the target class.
Because Java prevents overriding final methods, the dynamically created proxy can’t advise final methods in the target class.
Spring produces a warning if it detects such a situation.
If a final method is invoked, it can lead to inconsistency between the target and proxy object state.
If you see such a warning, you should consider avoiding CGLIB proxies.
Let’s see how Spring handles the creation of a proxy and blends it with the core DI mechanism.
Spring AOP fits well with the overall DI mechanism that is at the heart of the Spring framework.
For example, you can use the following snippet to inject an OrderServiceImpl into an OrderController:
With this configuration, Spring injects the raw orderService bean into the orderController bean, as shown in the upper part of figure 9.3
You declare the configuration, such as the injection of the OrderService bean into the OrderController bean.
Spring’s proxy-based AOP creates proxies around any bean that needs to be advised and injects that bean instead of the original.
To implement a crosscutting concern, you declare a bean for an aspect and configure the application context to have Spring’s autoproxy mechanism use that aspect:
Examine each bean to check if it’s an aspect (by checking for the @Aspect annotation associated with it)
For each bean in the application context, check if the advice would apply to a method in that bean.
For each matching bean, automatically create a proxy (hence the name autoproxy) wrapping the original bean—the target object.
The proxy implements the same interfaces or extends the same class as the target object.
Replace the original bean in the application context with its proxy.
When Spring’s DI performs injection, the proxied bean—and not the target bean—is injected.
The DI mechanism makes proxy-based AOP transparent to the programmer.
The result is a clean separation of core injection logic and crosscutting logic.
Now that you have a good understanding of the mechanism employed by Spring AOP, let’s understand some of its limitations.
All of these limitations are due to the use of proxies as the underlying mechanism.
Spring AOP works only for method execution join points, because proxies can intercept only method executions.
For many crosscutting concerns seen in enterprise applications, this may not be an immediate problem.
For example, transaction management and security often need to intercept at the method execution level.
Even in implementations using AspectJ, which supports a whole range of join points, method execution is by far the most commonly used join point.
The proxy creation requires that the Spring container create the objects that need to be advised.
Because Spring controls the instantiation of beans, Spring AOP works naturally with beans.
Although you can apply Spring AOP programmatically to any object, as long as you can control its instantiation, this isn’t often done in practice.
The main reason to avoid programmatic use of Spring AOP is to limit dependency on the Spring Framework.
For example, you can’t apply transaction management and security at the domain entities level, because domain entities typically aren’t Spring beans.
In chapter 16, we’ll examine the use of AspectJ-based crosscutting to overcome this limitation.
With Spring’s proxy-based AOP, the calls to the self (the this object) made from the target object aren’t advised.
Unless the object on which a method is invoked is a proxy, the advisor chain doesn’t come into the picture.
For example, consider the following implementation of the removeProduct() method:
The call is being made on the this object, which is the raw target object and not the proxy.
You can get around the self-call limitation by obtaining the proxy to the self object and invoking a method on it.
Essentially, it gives access to the proxy for the current target.
Although the method gets the job done, this approach has one serious issue: you just made the business objects aware of the use of the proxy.
Therefore, you should use such an approach only in extreme situations.
If you find that you need to advise self-calls often, it may be the time to think about using the AspectJ weaver.
Note that AspectJ doesn’t have this problem because no dichotomy exists between the target and proxy object and self-calls are no different from calls to outside objects.
Now that you have a basic understanding of Spring AOP, let’s discuss @AspectJ integration in full.
Figure 9.4 Spring AOP advises method execution resulting from an external call.
When the object invokes methods on the self object, the proxy chain is bypassed.
You get the full expressive power of the syntax while still staying within the proxy-based AOP.
Further, such syntax facilitates easy migration to full-power AspectJ, when needed, by switching to AspectJ weaving.
Because Spring AOP uses the proxy-based implementation, Spring supports only a subset of the @AspectJ language.
For example, because a proxy-based AOP supports only method execution join points, Spring’s @AspectJ integration doesn’t support pointcuts such as call() and handler()
In addition, some of the static crosscutting constructs, such as compile-time errors and warnings, aren’t supported either.
But given the primary importance of the “bean” concept in Spring, there is an additional pointcut to select join points in specific beans.
In this section, we’ll look at the parts of the @AspectJ language that Spring AOP supports.
To integrate an aspect with Spring, you declare a bean corresponding to the @AspectJ aspect in the same way as any other bean.
If needed, you can even inject dependencies into this bean and use them in the advice logic.
Then, you instruct Spring through XML to use those beans to advise Spring beans.
By default, Spring includes all beans with the @Aspect annotation for the proxycreation purpose.
With such a declaration, Spring uses only the listed beans for autoproxying.
By default, Spring uses JDK dynamic proxies as described in section 9.2.1
In those situations, or if you wish to use CGLIB-based proxies, you can set the optional proxy-target-class attribute to true:
You can use any class written using the @AspectJ syntax.
In the application context, you must instantiate a bean of that class.
Doing so lets you advise beans that don’t implement any interfaces.
It also lets you advise a class that implements interfaces, but that you want to advise methods declared in the class that aren’t declared in any of the interfaces.
Equipped with the general structure of @AspectJ integration, let’s see how this integration supports two specific forms of crosscutting.
Dynamic crosscutting comes in the form of advice that utilizes pointcuts.
Spring uses the @AspectJ syntax and semantics to the extent possible given the constraint of a proxy-based implementation.
In some cases, it deviates a bit to simplify certain usage patterns found in typical Spring applications.
Due to Spring’s proxy-based mechanism, which restricts the selected join points to method execution only, you can’t use AspectJ’s full power.
Table 9.1 shows the AspectJ pointcuts that you can use in Spring.
The same pointcuts are also available in schema-style AOP, as you’ll see in section 9.4
Note that all context-collecting pointcuts may specify types or identifiers as the parameters.
If an expression specifies an identifier in place of type, then in addition to performing selection, the pointcut also collects the matching object that advice may use in the same way as the core @AspectJ syntax.
This pointcut behaves the same way as in AspectJ, except the pattern specified can’t be a constructor pattern, because Spring-AOP can’t advise object construction.
Note an important difference between Spring’s matching from that of AspectJ.
In AspectJ, the target() pointcut matches the same objects matched by this() for an execution join point.
In Spring, this() matches the proxy, whereas target() matches the target object.
Select methods where the method argument’s types match the specified type patterns.
You can compose pointcuts using unary and binary operations to form a complex join-point selection criterion much the same way with the @AspectJ syntax.
Spring also offers an additional pointcut to select Spring beans.
An application is a composition of beans created as per the configuration instructions.
Beans are also the objects that can be proxied to apply aspects.
It’s therefore appropriate that there be a way to select specific beans based on their identifiers.
The name-pattern follows the AspectJ matching rules for a name pattern with * being the only allowed wildcard.
This pointcut represents a Spring-specific extension to the AspectJ expression language and as such is useful only with Spring AOP.
This pointcut designator offers two interesting ways to select beans if you follow an appropriate naming convention:
Selecting a vertical slice of beans —If you follow a convention where bean names include a string indicating their role from the business perspective, a bean() pointcut can select beans based on business functionality.
Selecting a horizontal slice of beans —If you follow a convention where bean names include a string indicating their role from the architectural perspective, a bean() pointcut can select beans based on their architectural role.
For example, you can use bean(*Repository) to select all repository beans.
Without the bean() pointcut, you have to rely on the package structure or type-based pointcuts, which can sometimes be too restrictive.
Note that use of @this() isn’t allowed, because the proxy object is automatically generated and selecting annotations based on it isn’t useful.
Select methods where the annotations with the method parameters’ type match the specified annotation type patterns.
You can use unary and binary operators to negate or combine bean() pointcuts in.
Figure 9.6 Selecting horizontal and vertical slices of beans based on their names using the bean() pointcut designator.
After you select join points of interest, you can advise them with crosscutting logic as you see next.
Spring’s @AspectJ integration supports all advice types: before, after (including after returning and after throwing variations), and around.
Therefore, in this section, we’ll examine only the around advice.
If the around advice needs to proceed with the same context, it can call the no-arg version of proceed(), again matching the core @AspectJ semantics.
But the difference comes when it wants to proceed with an altered context.
In Spring, you must pass arguments to proceed() matching the join-point arguments.
Specifically, contrasting with discussion in section 7.4.3, you don’t need to and can’t pass the this and target objects even though you collect them as join point context.
Note that there is no way to modify the service (collected using the this() pointcut) with which the advice should proceed.
In reality, in a typical Spring application, proceeding with altered context is uncommon (which is why I needed a contrived example)—more so with altered this and target objects.
You’ll use the no-arg version of proceed() on most occasions.
If an aspect needs to control ordering, it implements the Ordered interface and the configuration sets its order property, which specifies the relative order.
For example, if you need SecurityAspect to have higher precedence than AuditingAspect, you have both implement the Ordered interface as follows:
Then, you set the order property of bean for both aspects, as follows:
An aspect with a lower value for the order property has higher precedence over an aspect with a higher value.
In the previous snippet, advice in SecurityAspect has higher precedence than advice in AuditingAspect.
The aspect is marked with the @Order annotation, whose value specifies the aspect’s relative order.
For example, to get the same ordering as earlier, you mark the SecurityAspect as follows:
Similarly, you mark the AuditingAspect with the @Order annotation and specify a higher value (lower precedence):
Essentially, with the @Order annotation, the responsibility to specify the order shifts from configuration to code.
You choose the Ordered interface if you wish to control order through configuration; otherwise, you use the @Order annotation.
Spring’s AspectJ integration supports the per-object aspect instantiation models through perthis() and pertarget() aspect associations (specified using the value property of the @Aspect annotation)
An aspect with perthis() has a separate aspect instance bound for each Spring bean’s this object (the proxy around the bean), whereas pertarget() has a separate aspect instance bound to each Spring bean’s.
Spring doesn’t support other instantiation models: percflow(), percflowbelow(), and pertypewithin()
Spring supports a limited form of static crosscutting as well.
Statelessness (not holding any conversational state) of a typical Spring bean is at odds with the typical use of declaring a parent to add new state.
This limits the practical use of declaring a parent for a Spring bean only to introduce a simple state exposed to JMX (usage statistics, performance metrics) or the state that is immediately persisted (metering, audit records)
To support Java 1.4, Spring provides an XML-based alternative that we discuss next.
Schema-style AOP support offers a way to turn a plain Java class into an aspect by specifying the aspect-related metadata using XML.
The idea is similar to the @AspectJ syntax you’ve seen in the previous section, except here the crosscutting information is in XML form.
By avoiding the use of Java annotations, the schema-styled AOP makes it possible to express AOP constructs in a form suitable to Java versions prior to Java 5, where there is no language support for annotations.
Figure 9.7 shows the general structure of schema-style AOP support.
The overall idea behind the schema-style AOP is simple: express the state and behavior part in classes, while expressing the crosscutting rules in XML.
Plain classes along with metadata expressed in XML represent aspects in schema-style AOP.
You create a bean of the class representing an aspect and declare an aspect based on that bean.
In figure 9.5, the InventoryAuditing class is a plain Java class; it extends no special class, implements no special interfaces, and carries no special annotations.
Aspects stand in for class, methods stand in for advice, and pointcuts are described in XML.
The use of context-collecting pointcuts such as args() lets you collect join point context and makes it available to advice in a strongly type manner.
If you must use the schema-style AOP, read the Spring documentation for full details.
The <aop:advisor> element offers a way to use advisors written using Spring’s traditional AOP API.
Declaring an <aop:config> element is an indication to Spring’s application context loader that the aspects defined need to be applied to beans.
This element may also declare an attribute proxy-target-class to instruct Spring to use class-based proxies created using CGLIB.
The default value for this attribute is false, indicating the choice of JDK dynamic proxies.
In other words, it doesn’t support perthis() or pertarget() instantiation models.
Any aspect may refer to the pointcuts defined at the <aop:config> level, thus making them global pointcuts.
In contrast, only the enclosing aspect may refer to the pointcuts defined at the <aop:aspect> level.
Each <aop:pointcut> element has two mandatory attributes: id and expression.
The id attribute assigns an identifier that an advice may later use to refer to the pointcut.
This is a purposeful deviation from the @AspectJ syntax because once the metadata is removed from the method standing in for a pointcut, the only thing left is the pointcut name; this can be easily expressed in XML using the id attribute.
As with @AspectJ syntax, the pointcut may collect context using pointcuts such as args()
A pointcut expression may use any of the supported pointcut designators shown in table 9.1
For example, consider the inService() pointcut defined using the schema-style AOP.
It’s an error to use this pointcut in the definition of another pointcut:
The sole use of the id is to refer to the pointcut from advice elements, as we’ll discuss in the next section.
Note that although you can’t use the pointcut defined in the XML itself for composition purposes, you can use pointcuts defined using the @AspectJ style aspects.
A method along with an XML element designating the kind of advice defines an advice in the schema-style AOP.
The method’s arguments serve as the join-point context, and the body serves as the advice implementation.
Methods standing in for an advice don’t have any special requirements beyond what makes sense for an advice: methods must be public, non-static, and return void unless they represent an around advice.
Similarly, an around advice is mapped using an <aop:around> element.
In addition, the context-collecting pointcuts may specify identifiers, instead of just types.
Any identifier used must match one of the parameter names in the advice method.
The expression associated with the referred pointcut must match the same criteria of context-matching as described for the pointcut attribute.
It lets you map the name of the context collected by pointcut to the method parameters.
If you don’t specify this parameter, you must compile the class standing for the referred aspect using either –g or –g:vars.
As a last resort, Spring tries to deduce arguments from the parameter’s type.
For example, if the method takes one parameter of type Product and another of type int, Spring can correctly bind the Product and int context.
This scheme, of course, doesn’t work if you have multiple parameters of the same type.
Each advice kind may offer additional attributes and have additional peculiarities.
The following points should make sense, because they map well from the @AspectJ syntax:
The value of this attribute must be one of the method arguments.
The type of the argument must be compatible with the value returned by the advised join point.
For example, consider the following recordShipment() method to be used as an after returning advice:
The method needs the order as well as the tracking number.
The order is available as the parameter to the advised method, so you use an args() pointcut to collect it.
The tracking number is the return value of the advised method that you’ll pass as the trackingNumber argument to the advice.
Hence, you specify trackingNumber as the value of the returning attribute:
You can specify Object as the type to capture the return value of any type.
The identifier specified by the throwing attribute gives access to the thrown exception.
The method must declare a return value compatible with the selected join points.
The return type Object is treated in the same way as in the @AspectJ syntax; it’s compatible with any return type including primitives and void.
This parameter lets you call proceed() when it wants to proceed with the advised join point.
The invocation of the proceed() method must follow the rules described in section 9.3.1
Schema-style AOP also supports a limited form of static crosscutting that we’ll examine next.
With this feature, you can declare a new interface as the parent for beans matching a certain type pattern and delegate the implementation to a default implementation.
This feature is much like the declare parents and @DeclareParents feature in AspectJ, with appropriate modifications to work with Spring AOP.
An XML element maps to static crosscutting that offers a way to declare new interfaces as parent types.
The declared interface and its default implementation are, of course, implemented in Java.
Schema-style AOP is a big improvement over old-style Spring AOP that simplifies writing aspects even for newcomers to the AOP field.
So far in this chapter, we’ve focused on Spring’s proxy-based AOP.
But you can use Spring applications with the regular AspectJ weaver to get the full-power of AOP.
You can then use the full AspectJ syntax and crosscut join points other than method execution.
You also don’t have to limit yourself to Spring beans.
In this section, we’ll look into configuring aspects using Spring DI and leveraging Spring-driven load-time weaving (LTW)
Another usage extends Spring’s DI to objects that aren’t Spring beans; we’ll discuss that possibility in chapter 16 because it represents a specific use of AspectJ.
When you use the AspectJ weaver, you may need to inject dependencies into aspect instances much the same way as for other Spring beans.
For example, you may need to inject a monitoring agent into a monitoring aspect.
When you use aspects in a Spring application, the best practice is to use Spring’s DI to inject dependencies.
You saw an example of such usage in section 6.2.8 to inject the cache bean into the caching aspect.
Aspects can’t be instantiated manually using the constructor (which is Spring’s default mechanism for creating beans), so you must use the aspectOf() method to create the aspect or access one that is already created.
Spring provides the factory-method attribute to specify a static method that should be used instead of the constructor.
This mechanism works for aspects written using the traditional syntax as well as the @AspectJ syntax (in which case the aspectOf() method is introduced in such an aspect by the weaver)
Note that aspects used with the proxy-based AOP (declared using @AspectJ or XML-based syntax) are Spring beans and shouldn’t use the aspectOf() approach to instantiation.
The use of aspectOf() as the factory method works only for singleton aspects.
It doesn’t work for other kinds of aspect instantiation: perthis(), pertarget(), percflow(), percflowbelow(), and pertypewithin()
For these aspect associations, you can use the domain object DI aspects to configure each newly created aspect instance.
AspectJ’s support for load-time weaving, described in chapter 8, uses a Java VM Tool Interface (JVMTI) agent.
Often, a different set of developers (Operations) controls the launch script.
Starting with version 2.5, Spring makes using LTW simpler and puts more power in the hands of application developers.
We’ll look at this arrangement in detail later in this section.
First, let’s see this in action through a simple example.
But instead of making modifications to the deployed application, you’ll make the same modifications to the application before deploying it to better show that you don’t need changes to the deployment environment (except that if you’re using Tomcat or GlassFish, you need to copy a jar to the server’s lib directory, as you’ll see in a moment)
Note that it’s valid to make changes in the deployed application as well.
Follow these steps to have the application work with Spring-driven LTW:
In this step, you create a separate XML file to enable the load-time weaver.
By using a separate file, you can easily enable or disable LTW by including or excluding the file from application context.
Listing 9.9 shows code that declares the use of LTW.
No proxies, really! Let’s make one point clear, which is often a source of confusion: Spring-driven LTW isn’t a proxy-based AOP; it’s just a way to simplify AspectJ’s LTW in Spring applications.
It does so by leveraging the server’s infrastructure or by augmenting that infrastructure to introduce AspectJ’s byte-code weaver such that classes pass through it while being loaded into the VM.
Although the first two steps are sufficient for a few application servers (we’ll discuss those in the section that follows), Tomcat and GlassFish need an extra step.
But it supports replacing its classloader with one specified by the user.
Create a new META-INF directory parallel to the WEB-INF directory, and add the context.xml file shown in listing 9.11
Now you need to prepare the aspects and associated configuration.
This is logically the same step as in section 8.4
Now that everything is set up, you’re ready to deploy the application.
From the jpetstore directory, execute the following commands, visit the pet store using a browser, and buy a few pets:
This output is similar to what you saw with AspectJ’s LTW using JVMTI in chapter 8.1
The classloader passes the byte code for an unwoven class to the instrumentation agent and uses the woven byte code to define the class.
Spring-driven LTW requires that the classloader loading the application be capable of accepting an instrumentation agent.
A few implementations of Java Persistence API (JPA) also require load-time instrumentation.
Therefore, many recent versions of application and web servers already provide such a classloader.
In such cases, Spring-driven LTW configures that classloader with AspectJ’s instrumentation agent.
For other servers, you can specify a simple JVMTI agent (that Spring includes) that provides the same capability in any server.
Note that AspectJ’s instrumentation agent works only with Java 5 and above.
GlassFish 2.0+ web applications (which use Tomcat and therefore match Tomcat in the required application-level changes)
With other application servers, if Spring’s agent for JPA is used, Spring-driven LTW can utilize it instead of needing the AspectJ LTW.
The classloader passes unwoven byte code to AspectJ’s instrumentation agent.
The classloader then loads the woven byte code into the VM.
Note that the Spring agent doesn’t, by itself, perform any weaving.
Now that you understand AspectJ and Spring AOP, let’s discuss which AOP system is appropriate in a given situation.
Spring AOP lets you use several styles to express aspects.
In this section, we’ll compare these choices and establish guidelines for their use.
For this discussion, we assume that Spring is already the architectural basis for your system.
Note that you can always use AspectJ weaving with Spring.
After all, a Spring application is just a Java application, and AspectJ works with any Java application.
Armed with this information, we’ll create a set of guidelines to help you through the decision process of choosing the right AOP system and syntax.
AspectJ represents a powerful system that requires you to use a weaver.
Spring AOP, on the other hand, represents a simpler system that works within the machinery offered by Java.
The join point model —Spring AOP exposes only one kind of join point: execution of public non-static methods.
AspectJ exposes several in addition to method execution, such as object construction, class loading, method call, exception handler, and field access.
Spring AOP also implicitly limits exposed join points to those for the beans.
AspectJ, as you’ve seen in all the chapters so far, has a farreaching crosscutting capability.
You don’t need to employ any special tools or modify the build or execution environment.
Even the AOP concepts you need to learn are far fewer in Spring AOP.
Further, Spring AOP’s limited power can be seen as a benefit; fewer things can go wrong while you’re learning how to use AOP!
Spring-driven LTW without Spring It’s possible to use the approach taken by Spring-driven LTW even when you don’t use Spring.
As long as you can access the classloader and add the instrumentation agent to it, you can use LTW.
You must add the agent before any of the classes to be woven are loaded, because once a class is loaded into the VM, the classloader and the instrumentation agent are out of picture.
If you’re using Spring, all the hard work is already done for you.
Performance —Spring’s proxy-based AOP, due to the use of reflection necessitated by proxies, has lower performance than byte-code weaving implemented by AspectJ.
But most applications of Spring AOP involve advising already expensive operations (database accesses, message queue operations, or network operations)
In those cases, the overhead added by Spring’s proxy is negligible.
In general, Spring AOP’s applications are self-selecting regarding performance characteristics—if Spring AOP is suitable for functionality, the performance characteristics are likely to be acceptable.
If you decide to use Spring AOP, you have a few choices about the syntax: traditional interceptor syntax, schema-style AOP, and @AspectJ.
The biggest advantage of schema-style AOP is the possibility of using it with Java 1.4 and earlier versions.
Another advantage of schema-style AOP is that you can look at the configuration file and know about all the aspects in the system.
For example, you can understand pointcuts used by security and transaction management aspects just by looking at an XML file.
A disadvantage of schema-style AOP is that to understand an aspect, you need to examine both configuration files and Java code.
The biggest drawback of schema-style AOP is the lack of a way to compose pointcuts (as discussed in section 9.4.2)
It makes it easy to understand a single aspect; the advice logic and pointcuts are in the same place.
It also lets you write pointcuts the way they’re supposed to be written—simple pointcuts composed to form complex pointcuts.
A disadvantage of @AspectJ compared to schema-style AOP is that examining the XML files forming the application context doesn’t reveal the big picture of aspects and their interaction.
First, Spring’s best practice to use multiple XML files to form a Spring application context requires viewing all those files to get the big picture anyway.
Second, using the Spring IDE provides the big picture in a much nicer form, as you saw in figure 9.1
Let’s put all this information together to create guidelines for choosing the right AOP system for the right job.
If your aspects need to be applied to Spring beans, use Spring AOP.
In practice, Spring AOP works fine for crosscutting concerns for Spring beans such as service objects, Data Access Objects (DAOs), and UI controllers.
Because there is no special weaver, you don’t need to change your tool chain.
Specifically, you don’t need to switch to a particular IDE to build Spring applications.
Some of the limitations you’re likely to encounter are advising self calls and advising object instantiation join points.
This syntax is easy to understand and offers a possibility of moving to fullfledged AspectJ usage should such a need arise in the future.
If your AOP needs to extend beyond Spring beans, use AspectJ.
In practice, this means you need fine-grained crosscutting functionalities that extend to domain entities.
In those cases, the benefit added by AspectJ outweighs the added logistical complexity (modifications to build or launch scripts)
If you need to advise join points beyond method execution, use AspectJ.
If you need to advise join points exposed by AspectJ, but not exposed by Spring AOP, such as method calls, object instantiation, exception handlers, and field access, you need to tap into the power of AspectJ.
But make sure the extra performance gained makes a difference in your overall system performance.
If you need weave-time errors and warnings to enforce architectural policies, use AspectJ.
You’ll probably want to use build-time weaving to flag any policy violations as early as possible.
The choices, while overwhelming at first, offer you a solution that matches your needs in any situation.
Start with these guidelines, and make changes to match your unique constraints.
Spring’s integration with AspectJ is drawing a lot of attention.
In its simplest form, it lets you use the AspectJ language to express pointcuts.
The XML-based aspect configuration further leverages the AspectJ syntax to turn a regular bean into an aspect.
The @AspectJ syntax takes an additional step by modularizing the AOP-related configuration right into the beans themselves.
Spring accomplishes all these syntax possibilities while staying within the limits of its proxy-based AOP framework.
Of course, you can always use an AspectJ weaver with Spring as with any Java application.
These concepts, along with the ones presented in the earlier chapters, complete our introduction to the AspectJ language.
Now that you understand the concepts and constructs in AspectJ as well as how it works with Spring, we’re ready to dive into practical examples in areas such as tracing, concurrency control, transaction management, and security.
The material presented so far will serve as a reference while you read the remainder of the book.
Part 2 puts the knowledge you gained in the first part to practical use by showing how AspectJ and the Spring Framework simplify enterprise applications.
Although Spring provides dependency injection and enterprise service abstraction, AspectJ completes the picture by modularizing crosscutting concerns.
We’ll explore the two ways Spring integrates with AspectJ: through dynamic proxies and through byte-code weaving.
You should be able to use most of the example code in your applications without much modification.
Even if you aren’t using Spring, you’ll find that you can adopt these examples to suit your applications.
We begin by examining a classic application of AOP: monitoring and tracing.
Then, we’ll modularize the policy-enforcement concerns to create a safety net that ensures you won’t get into trouble by violating programming policies.
You can take out these aspects when you deploy your system without affecting the correctness of the core system.
Of course, as we explain, you can continue using these aspects in the deployed system and gain even more benefits.
First, chapter 12 introduces a few AOP design patterns that are used in the remaining chapters.
Chapter 17 concludes this book with a discussion of how you can incorporate AOP into your organization.
During the development phase, monitoring helps you understand the interactions between components in the system and spot any deviations from what is expected.
During the deployment phase, it lets you profile the application under load to plan the hardware needed for a successful deployment.
During production, monitoring helps you verify that the system is working within the expected range of operating parameters; it alerts you about any impending problems and lets you extract useful diagnostic information when things go wrong.
All monitoring techniques share some common problems when implemented using conventional techniques.
First, their implementations cut across multiple modules, causing code scattering.
Second, the code for monitoring intertwines with business logic, causing code tangling.
The sheer amount of code needed is often a reason Monitoring techniques.
Furthermore, even if a determined team is ready to add the needed code, implementing monitoring functionality consistently is a tall order that is seldom achieved with the needed precision.
Recent advances in AspectJ, such as load-time weaving (LTW), make deploying monitoring aspects a much simpler task while providing control over the monitored points without needing recompilation.
Spring’s AspectJ integration also provides simpler opportunities to implement monitoring functionality for the key components in a typical enterprise application without any changes to build or deployment environments.
In this chapter, we’ll examine ways to introduce monitoring in a systematic and noninvasive manner through use of aspects.
We’ll start with the perennial favorite of AOP: tracing! By introducing simple aspects, you can consistently trace important events in the system, such as execution of and calls to selected methods and throwing of exceptions.
For each of these techniques, we’ll examine common patterns in implementing tracing the AOP way.
You should be able to use the information provided in this chapter immediately during development.
The experience gained in this process will help you decide about further use of AOP.
Tracing is one of the most common monitoring techniques used to understand a system’s behavior.
In its simplest form, tracing logs messages that describe the occurrence of interesting events during the execution of a system.
For example, in a banking system, you would log each account transaction with information such as the nature of the transaction, the account number, and the transaction amount.
You could also log exceptions that occurred during execution of the system along with the context under which they occurred.
During the development cycle, tracing plays a role similar to a debugger.
It’s also usually the only reasonable choice for debugging distributed systems or concurrencyrelated problems.
By examining the log, you can spot unexpected system behavior and correct it.
A log also helps you see the interactions between different parts of a system to detect exactly where the problem might be.
Likewise, in fully deployed systems, tracing acts as a diagnostic assistant for finding the root cause of the problem.
A poster child of AOP Tracing has always been a poster child of AOP applications (as well as a popular target of the myth that all AOP can do is tracing—something I’ll debunk throughout this book by providing a vast range of applications other than tracing)
Tracing and other monitoring techniques are good examples of crosscutting functionality at its extreme.
It not only saves a ton of code but also establishes centralized control, consistency, and efficiency.
Let’s examine an AOP implementation of tracing in action through a simple console application based on code provided in appendix A.
In listing 10.1, you add a product to an order.
Now, let’s look at tracing implemented using AspectJ; later, we’ll compare it with conventional techniques.
Let’s use AspectJ to introduce the tracing functionality into each method in all the classes in the example.
That’s it! You’ll have tons of output to impress your colleagues.
The traced() pointcut selects methods to trace—in this case, it selects all the methods in the system.
You also follow a common idiom in AspectJ to exclude join points in the aspect itself to avoid a potential problem of infinite recursion.
Although such exclusion won’t matter in the current version of the aspect because there are no methods in the aspect itself, it’s never too early to start using good practices.
You use the toShortString() method to obtain the shorter version description.
If needed, you could obtain the longer version using the toLongString() method or obtain individual parts of the signature and assemble the output yourself.
Note that the weaver creates static information about the join point at weave time, and neither compiler optimization nor the presence of the Just in Time (JIT) and hotspot virtual machine alters this information.
See chapter 4 for detailed information about using reflection in an advice body.
When you compile this aspect together with the classes and run the test program, you get output similar to this:
With the tracing aspect, you get good insight into the system’s execution just by writing a simple tracing aspect.
Later in this chapter, you’ll see improvements that will help you gain an even deeper understanding of the system’s inner workings.
To truly appreciate the AOP implementation, let’s examine how you could implement the same functionality without it.
If you were to implement tracing without using AspectJ, you’d end up with code such as in listing 10.3
To illustrate the additional work needed on your part, let’s look at the modifications to the Order class required using the log4j API.
You instrument each method of the class to log the entry into it.
You log each method at the Level.INFO level because you’re writing informational entries.
That would be quite a task, right? Granted, the job would be mostly mechanical—you’d probably copy and paste code.
After pasting, you’d have to be sure you changed each argument to the log() method correctly; if you didn’t, you’d end up with a log message that was inconsistent with the operation being performed.
Furthermore, if you wanted entry and exit traced rather than just a log message for entry, it would be even worse.
We’ll examine a way to eliminate the difference in section 10.4.5
Now, consider how long it would take to introduce tracing in a real system with hundreds of classes.
How sure could you be that the methods would log the right information? This is a typical scenario with any crosscutting concerns: too much effort to implement them, and too many opportunities for bugs.
Now that you’ve seen tracing using conventional and AspectJ-based techniques, let’s compare the two approaches.
Logging toolkit and automatic extraction of caller information When you’re using log4j, avoid using it with %C, %F, %L, %M, or a combined %l layout pattern.
These patterns examine the call stack to extract the caller information (such as the class name, method name, and line number) at the location of the log() method invocation.
The performance hit from using the call stack to deduce a caller is significant, because it involves obtaining the call stack and parsing its contents—not a trivial job.
When you don’t use these formats, you need to supply the caller information yourself the way you did in listing 10.3
But note that this isn’t a log4jspecific issue; the same issue exists in any logging kit that offers to deduce the caller from the call stack.
Alas, the need for caller information is too common; without such information, the log output is much less useful.
But adding location information to each log invocation adds additional code to something that is already complex.
In section 10.7.1, we’ll examine a way to obtain the caller information in the same manner even when you use conventional logging.
The base implementation technique used in conventional tracing involves a logging toolkit and calls to its APIs.
The logging toolkit simplifies the job of categorizing and formatting the log message.
For example, with log4j, you can have a logger associated with a category (typically the class name)
You can then specify a log4j.xml file to control the level for each log category.
As you can see, the tracing calls are all over the core modules.
When a new module is added to the system, all of its methods that need tracing must be instrumented.
Such instrumentation is invasive, causing tangling of the core concerns with the tracing concern.
If the tracing specification requires that a certain kind of operations be logged, then the implementation must log every invocation of those operations.
When things go wrong in a system, doubting the tracing consistency is probably the last thing you want to do.
Missed tracing calls can make output hard to understand and sometimes useless.
For example, if you were expecting a certain method to have been invoked, and you didn’t see a log output for that method, you couldn’t be sure if the method wasn’t called or wasn’t logged due to inconsistent implementation.
Achieving consistency using conventional tracing is a lofty goal; and although systems can attain it initially, it requires continuous vigilance to maintain.
For example, if you add new classes to the system or new methods in existing classes, you must ensure that they implement tracing that matches the current tracing strategy.
Most developers (and this book) refer to logging as an act of producing messages specific to the logic carried by a piece of code.
Tracing is commonly considered as the act of producing messages for lower-level events: method entry and exits, object construction, exception handling, state modification, and so on.
Both techniques often use a logging toolkit to simplify their implementation.
Figure 10.1 Conventional tracing, where all log points issue calls to the logger explicitly.
The beauty of this approach is that you don’t need to instrument any log points; writing an aspect does a functional equivalent automatically.
Further, because there is a central place to control tracing operations, you achieve consistency easily.
With AspectJ-based tracing, the tracing aspect separates the core modules and the logger object.
Instead of the core modules’ embedding the log() method invocations in their source code, the aspect weaves the logging invocations into the core modules when they’re needed.
AOP-based tracing reverses the dependency between the core modules and the logger; the aspect encodes how the operations in the core modules are logged instead of each core module deciding for itself.
Furthermore, as we’ll show later in this chapter, extending tracing to other events in the system, such as throwing an exception and modifying or accessing important object state, can be implemented easily owing to the powerful pointcut language.
As you can distill from the discussion so far, monitoring through AOP boils down to two parts:
The first part requires some considerations that we’ll discuss next.
Typically, you’ll want to select a list of monitored methods to make output more understandable and avoid degrading performance.
You can achieve this goal by implementing the pointcut to select join points based on their static and dynamic characteristics.
Let’s look at several design options that will be useful for many pervasive aspects, like tracing.
Specifically, note the reversal of the arrows to the classes.
A simple way to select a set of monitored join points is based on their static structure.
You can use characteristics such as the package hierarchy of the types, inheritance structure, method name patterns, and method return type.
Leveraging annotations associated with various programming elements is also a powerful way to select the trace points.
Typically, you’ll use a combination of all these techniques to define your tracing pointcuts.
A well-defined package structure is central to any good software system.
It’s common to have the package hierarchy reflect high-level design elements.
Choosing monitoring points using packages therefore makes it easy to select elements based on the function they’re playing.
With such a selection, you can capture coarse-grained monitoring requirements such as “trace all domain model interactions.” Listing 10.4 illustrates a selection based on static structure.
Note how you construct the final pointcut using simple pointcuts, each selecting a specific set of types.
This style—a best practice in AOP—simplifies understanding and maintenance because you can focus on a simple concept at each level.
An alternative style is to use package scopes to define pointcuts, as shown in listing 10.5
Listing 10.4 Trace aspect utilizing pointcuts based on package structure.
Here, the first three pointcuts select all the join points within a certain package structure and combine them with pointcuts selecting all methods and constructors.
Of course, nothing prevents you from further refining the traced() pointcut to, say, separate the selection of method executions from the selection of object creations.
With either style, typically, you promote pointcuts corresponding to high-level functionality and reusable concepts to a library aspect.
For example, you can include the aspect shown in listing 10.6
Such an aspect is usable not only from a monitoring aspect but also from other aspects, as you’ll see in the next chapter, where you use it to enforce system-level policies.
Refactoring in action Notice how you’re progressively modifying the pointcuts to make them simpler and reusable.
Start by focusing on the problem at hand, and improve it as you go along.
With experience, you’ll develop your own style whereby you’ll start with an implementation following the best practices and thus skip a few initial stages of refactoring.
Then, the tracing aspect can use these pointcuts to compose its own pointcuts, as shown in listing 10.7
Although the package structure provides a coarse-grained selection of join points, you need to use other information to select join points to match tracing needs more precisely.
Type-structure information, such as the naming pattern and inheritance hierarchy, provides useful techniques to select trace join points.
If you use a consistent naming pattern for your types, you can leverage type names to define patterns using wildcards.
For example, if all your types representing a controller are suffixed with Controller, you can use *Controller as the pattern to select them.
But because you’re relying on a programmer’s due diligence in adhering to a naming convention, it’s best to find other ways before resorting to using a name pattern.
For example, if all your domain entities extend the DomainEntity class, you can use DomainEntity+ as the type pattern.
For example, if you choose to use the Java Persistence API (JPA), you can use an annotation such as @Entity to select only.
Listing 10.7 Trace aspect based on reusable aspect defining the system architecture.
Similarly, if you were to use Spring’s annotation-based MVC, you could use the following pointcut:
This lets you reuse them in multiple aspects or even in multiple projects using the same set of technologies.
You can even create your own custom annotations and use them for selection.
For example, you can use the @Audit annotation to implement the tracing functionality required for a regulatory compliance.
Such annotations may even specify the compliance code so the audit record can include it:
Similar to types, you can use annotations marked not only for the method but also for the return type, parameters, and declared exceptions.
For example, the following pointcut selects all methods that return a type that is marked with the @HIPPAData annotation:
When using custom annotations, you should avoid the use of tracing-specific annotations such as @TraceMe.
Although such annotations provide a better degree of separation than a direct use of a logging API, it goes against the core idea of noninvasiveness behind AOP.
Like type patterns, using name patterns is a possibility, and the same caveat of an unstable naming convention applies.
But certain naming patterns—such as all setter methods starting with set—prove to be general, especially because other technologies such as dependency injection (DI) and persistence frameworks utilize those conventions.
When you’re defining methods using a name pattern, exercise some care to specify the exact criteria needed.
A better pointcut for selecting setters would consider characteristics such as public access, void return type, and a single argument: execution(public void set*(*))
You still risk selecting a method such as settle, should it have public access, a void return type, and a single argument.
If you want to be even more defensive, you can further tighten the definition to ensure that the character that follows set is an uppercase letter.
Selecting join points of interest can then settle the score with the settle method! Here is a pointcut that does the job (marginal improvements are possible to minimize typing, but you still need all 26 lines—one per each letter of the alphabet in English):
You can similarly write a pointcut for getter methods that uses !void as the return type pattern for methods starting with get and boolean return type for methods starting with is.
You must also ensure that the method doesn’t take any arguments.
You definitely want such pointcuts nicely tucked away in a reusable aspect so you can reap the benefits of the many lines of code you diligently typed!
Other method signature constituents, such as return type, parameter types, and thrown exceptions, can often help you select the right kind of join points.
For example, the following pointcut selects all Remote Method Invocation (RMI) operations:
This pointcut leverages the type pattern Remote+ along with the exception declaration in method to select all public non-static methods defined in the Remote type or its subtypes.
This also illustrates how to use just the essential characteristics of join points to specify a precise selection criterion.
This kind of selection is particularly useful when you’re working with standard technologies such as Swing, SWT, Spring, and EJB.
Through a judicious combination of package, type, and method patterns, you can select join points needed for most tracing functionalities mirroring their conventional equivalent.
It’s important to strike a balance between too general and too specific: the latter runs into the fragile pointcut problem because names change and it’s easy to forget to change pointcuts.
AspectJ can offer additional possibilities by leveraging dynamic context that would be practically unattractive to implement conventionally.
Consider a scenario in which you’re utilizing repository classes through various services and you want to trace calls only if a web service originated those calls.
The cflow() and cflowbelow() pointcuts can allow such a criterion.
For example, the following pointcut selects all join points in the control-flow of any web service execution:
You can then combine this pointcut with another that selects repository operations:
This pointcut selects any repository method regardless of its lexical location and call depth if it’s inside the control-flow of a web service operation.
The control-flow-based pointcuts are also useful in limiting tracing to only the toplevel operations in a recursive call stack.
By now, you should be convinced that you can select appropriate join points matching a specific monitoring requirement.
It does take some experience to master writing good pointcuts, but be assured that it’s easier than it may seem at first.
Let’s examine the second part involved in each monitoring technique: the monitoring logic.
Then, we’ll discuss exception monitoring, improving conventional logic, and performance monitoring.
As you saw at the beginning of this chapter, the basic tracing implementation through AOP is easy.
In this section, we’ll look at indenting trace calls, sharing aspect functionality, tracing intra-method activities, logging method parameters, and using type-specific loggers.
Now, get ready to do something that is practically impossible to do without aspects in any reasonable manner.
You can make trace output tremendously more useful by exposing the caller-callee relationship in some fashion.
Not only do you get to see the execution of join points, but you can also visualize the call graph—kind of like a sequence diagram.
You may expose this relationship in a variety of forms.
A simple way is to include the call-depth value in the log message.
Alternatively, a visually more appealing way is to indent the log output to indicate the call-depth value.
Let’s develop an aspect to illustrate how easy it is to accomplish this using AspectJ.
The core idea here is to keep track of call depth on a per-thread basis and use it when logging a message.
The implementation involves advising the traced method with a before advice to increment the depth as you enter the method and with an after advice to decrement it as you exit the method.
A simple way to keep the call depth is to use a thread-local wrapping an integer and update it from before and after advice.
Then, when you log, compute the whitespace characters required, and prefix those whitespaces to the message.
When using log4j, you can leverage its capability to set up NDC for the same purpose to simplify the implementation.
Here, each method pushes whitespaces in the nested context upon entry and pops them upon exit.
The log statements then include all the accumulated whitespaces in the nested context.
Listing 10.8 shows the aspect that implements the indentation functionality.
You need to make a small change to the output format configuration in the log4j.xml file to include the nested context, as shown in the following snippet.
The only difference is the inclusion of the %x pattern, which stands for the nested context:
Nested Diagnostic Context and Mapped Diagnostic Context Log statements typically include information available in the local context, such as method names and parameters.
To make log output more useful, certain logging toolkits let you set additional context.
A log statement then may include that context in its output.
Nested Diagnostic Context (NDC) lets you arrange information in a hierarchical manner.
Using NDC, you can push information identifying each layer as you enter it and pop that information when you exit.
The log statement then may include the trail of layers that led up to that statement.
Mapped Diagnostic Context (MDC) lets you arrange information in a map.
Consider a web application, where you need the log statements in the data access layer to include information such as the accessing user and the remote IP address available in the web layer.
Using MDC, the web layer can add the needed information in a map.
A log statement in the data layer may then include this information along with its local context.
When you compile this aspect along with the classes and execute the system, you get output as follows:
Take a moment to pause and consider how you might implement this functionality without using aspects.
In every method, you might have to do something like:
This kind of code is an invitation to create bugs.
First, you might forget to use a try/finally arrangement to perform NDC operations, thus missing NDC.pop() when an exception is thrown.
Second, you might forget to include the NDC logic in every method, making the overall indentation scheme unreliable.
When you add functionality such as indentation logic, the trace aspects are no longer trivial, and it’s desirable to share the tracing logic to avoid duplication and simplify maintenance.
Ideally, a separate aspect should implement each requirement to ease implementation and maintenance.
But you’ll still want to share all common tracing functionality.
A good way to achieve both these goals is to create a reusable base aspect containing the core tracing functionality and one or more abstract pointcuts.
Compared to listing 10.8, you make only two changes: you mark the aspect as abstract and mark traced() as a public abstract pointcut, and you remove the implementation body from the abstract pointcut.
For example, listing 10.10 shows an aspect that logs only the model classes.
With reusable parts in place, you can create simple subaspects and include them as required.
So far, we’ve limited ourselves to tracing at the entry and exit of a method.
For example, you may want to trace all remote calls occurring from within specified methods.
AspectJ-based tracing helps to modularize logging invocations that are crosscutting in nature.
A judicious combination of tracing options presented in this chapter will take care of a majority of the cases.
For example, while processing an order, you may want to log specific steps such as securing payment, checking inventory, contacting the shipping division, and so on.
If you implemented all these steps in one method, you would be able to use call() pointcuts perhaps in combination with withincode() to select individual calls.
But some steps may encompass multiple calls, further reducing the possibility of selecting the required join points and hence tracing those steps.
The first response in such situations should be to break each step into a separate method through Extract Method and similar refactoring (for details, see Refactoring: Improving the Design of Existing Code by Martin Fowler [Addison-Wesley, 1999])
This process yields an improved implementation, which is a good thing even without considering the benefits of simplifying tracing.
But real life isn’t always considerate enough to offer such a choice.
Perhaps the requirements may call for logging specific states of the system instead of just the this object or the method arguments.
In those cases, your only practical choice is to log the intra-method calls the conventional way, with in-line code.
As you’ll see in section 10.7, AspectJ can help even when you use conventional logging.
Often, you not only want to log the method calls but also the invoked object and the method parameters.
You can implement this requirement easily by using the thisJoinPoint reference.
In each advice body, a special thisJoinPoint object is available that includes information about the advised join point and its associated context.
The aspect in listing 10.11 modifies the before advice in TraceAspect to log the method parameters.
But when toString() executes, it first attempts to log the operation, and the logger will prepare a parameter string for it again when it calls toString() on the same object, and so on, causing an infinite recursion.
By avoiding the join points for toString() execution, you avoid infinite recursion.
But you generalize it a bit further, to avoid tracing calls such as equals() and hashCode() as well by excluding all methods in the Object class.
Now, when you compile the classes with this aspect and execute the Main class, you get output similar to the following that includes the invoked object and the method parameters:
So far, you’ve used a logger specific to the aspect.
Let’s see how you can use the logger specific to the types being traced.
A common logging idiom is to use a type-specific logger so that a configuration file can control the information being logged by specifying the log level for each type or a set of types.
For example, the following snippet in a log4j.xml file declares that the minimum required log level for a message to appear from types in ajia.web package is warn:
The aspects so far in this chapter haven’t had this kind of type-specific control through configuration.
If you have multiple tracing aspects, you can control them separately using configuration such as the following:
But if you want class-level control, you can do so easily using the pertypewithin() aspect association.
Recall from section 6.2.4 that pertypewithin() associates the aspect state with a type.
If you include an aspect member for the logger, a separate.
A detour: deployment options for monitoring aspects aspect instance and therefore a separate logger are associated with each advised type.
Listing 10.12 shows a tracing aspect that uses type-specific loggers.
The pertypewithin() aspect association selects all types to avoid filtering due to the type pattern specified, if any.
This way, the pointcut alone determines the selected join points (otherwise, implicit limiting of join points comes into effect, as discussed in section 6.2.5)
After loading any class being logged, you initialize the logger member to get the logger object corresponding to that class.
Because a separate aspect instance is associated with each matching type, the logger initialized this way is type-specific.
Let’s discuss these deployment options before we resume discussing additional monitoring techniques.
AspectJ load-time weaving (LTW) introduces a weaver into the runtime system without affecting the build system, thus simplifying its use.
Similarly, if your application is based on Spring, you can use Spring’s proxy-based AOP that also obviates any buildtime changes and goes a step further by avoiding any deployment changes.
Let’s use tracing as a specific technique to see how AspectJ LTW and Spring AOP can be used with monitoring.
This choice requires that you have a base aspect that declares the monitored pointcut as an abstract pointcut.
When you’re defining concrete aspects in XML, you provide a definition for the pointcut.
Let’s apply the trace aspect you developed in listing 10.9 to your web application through LTW.
First, you’ll need to write an aop.xml file describing the aspects to weave in and target classes to be woven in.
Listing 10.13 shows an example aop.xml that you’ll use for the example.
You use a <concrete-aspect> element along with a pointcut definition that selects all join points in the system.
You include all types in direct and indirect subpackages of the ajia package.
You exclude those classes through a series of <exclude> elements.
I strongly recommend that you play with this configuration and see the effects.
If you’re still new to AspectJ but already using Spring as an architectural basis, you.
Consider a situation where you need to trace the internal workings or monitor the performance of controllers and repositories in a web application.
Although AspectJbased weaving will work, you can get the functionality without needing an AspectJ weaver (build-time or load-time)
This can significantly reduce resistance in getting started with writing your own aspect.
If you’re using the Spring Framework, you’re probably already using aspects shipped with the framework; but many projects could gain a lot from custom aspects to meet their specific needs.
You can use Spring AOP to introduce tracing without any logistical overhead.
The downside is that you can only trace public method execution on Spring beans, but this is often sufficient in many enterprise applications.
Let’s implement a tracing aspect as shown in listing 10.14
You can apply this aspect by adding the configuration file in listing 10.15, which is a part of the application context.
When you execute the web application and exercise the functionality, you get output such as the following (the shown output is produced when adding a product to the cart):
Notice that you see output corresponding to the services, repositories, transaction manager, JPA manager, and datasource objects—all of those are Spring beans.
But you don’t see any calls for the domain objects such as Product and LineItem.
This is due to the use of Spring AOP, which only applies to Spring beans.
Now you can have monitoring enabled in your application without needing the AspectJ weaver.
When your tracing needs to expand beyond what can be handled by Spring’s proxy-based weaving—say, to enable intra-method call tracing—you can consider using the full power of AspectJ weaving.
Because exception throwing is an important event in the system, tracing such occurrences is typically desirable.
Exception monitoring is an extension of the methodtracing concept, except the focus is on exceptional conditions in a program rather than the execution of methods.
The conventional way to trace exceptions involves surrounding the interesting parts of code with a try/catch block and instrumenting each catch block with a log statement.
With AspectJ, it’s possible to log exceptions thrown by a method without any modification to the original code.
In this section, you’ll develop an aspect that enables the logging of thrown exceptions in the system.
The aspect in listing 10.16 logs any method in the system that throws an exception.
First-failure data capture First-failure data capture (FFDC) functionality requires logging all the data (this, arguments, method information) at the point of the first failure.
By combining the aspect in this section with that in section 10.4.4, you can easily implement FFDC.
To avoid logging the same exception at each level in the call stack, you keep track of the last logged exception.
If another thread throws the same exception object, you want it to be considered a new exception and logged.
Note that you could keep all exceptions thrown in a collection, instead of storing just the last exception.
But the most common way to handle an exception is catching and rethrowing the same or a wrapped exception.
Therefore, you don’t need to worry about an old exception being thrown after throwing a new exception.
In those situations, the aspect ends up logging the old exception multiple times, which may be a good idea anyway.
The exceptionTraced() pointcut selects all the methods that need exception logging.
Here, you’re defining this as an execution of any method in the system.
You can modify this pointcut to include a subset of methods, as described in section 10.3.1
The after throwing advice collects the thrown object as context.
Let’s write a simple program (listing 10.17) to exercise your aspect.
You use a nested method that throws an exception to show the behavior of avoiding repeated logging of the same exception.
All customizations discussed for method tracing in section 10.4 apply here equally well, including using a type-specific logger and creating reusable aspects.
As discussed in section 10.4.3, sometimes you have to resort to conventional logging.
Even then, AspectJ won’t quit helping you; it’s such a good friend, as we’ll discuss next.
Unlike tracing, logging tends to be specific to the application.
For example, you can log all the steps in processing an order.
In many situations, common parts of logging in a class or a set of classes can be extracted into aspects.
Further, because you can log calls and not just execution, you can target calls made from a few specific classes to modularize those calls.
Essentially, you can try to reduce logging into somewhat specific tracing.
In any case, these aspects tend to be specific to those classes.
With all that said, you’re still left with situations where there is no apparent commonality that can be extracted.
In those cases, you implement logging in a conventional manner and use AspectJ to enhance the logging functionality and simplify the implementation.
You’ll like setting up NDC around that method so that all statements use that context (for example, to provide the indentation effect)
If you perform this functionality using conventional coding alone, you must ensure that you call NDC.push() upon entering and NDC.pop() before exiting each method.
This usually involves using a finally block such as the following:
If you don’t need the indentation effect but rather wish to obtain nested caller information associated with each log statement, you use a string identifying the operation as the argument to the NDC.push() method.
If done consistently, you get nested context in output such as “placeOrder processOrder”, if the placeOrder() method calls the processOrder() method.
In particular, it’s common to see a call to NDC.pop() without using the finally block (thus not clearing the context in case of an exception)
The aspect declares an abstract pointcut and advises it to push and pop a few spaces.
The derived aspects provide a definition for the logContextOp() pointcut to select the caller of the log method.
You implement a subaspect as shown in listing 10.19 to apply the context indentation to all service types.
It uses a few classes that we don’t show, because all they do is log a message in each method.
When you call the processOrder() method from a driver class, you get the following output:
As you can see, the indentation makes output easier to comprehend by clarifying the caller-callee relationship.
Note that following the warning in section 10.1 against using %C, %F, %L, %M, and %l layout patterns, you explicitly pass the class and method name to each log statement.
In the simplest form, you can register the caller method name and the defining the type as the context.
This is a much cheaper way to include the caller information without having to use a pattern that deduces the information by examining the call stack.
Next, because the aspect establishes the caller context, you don’t need to add that information in each log statement.
You can combine MDC with NDC (discussed in the previous section)
Furthermore, you can use any other diagnostic context to be automatically available for logging.
For example, in the following snippet, we use Spring Security API to add context information related to the accessing user:
The other context that you can establish using MDC includes the ongoing transaction’s identifier, the business-specific context such as the shopping card identifier, and so on.
Imagine the kind of tangling that would result if you were to provide diagnostic.
With AspectJ helping with crosscutting functionality, you can concentrate on only the bare minimum work.
Performance monitoring involves measuring the time taken by interesting parts of the system as well as the number of times a particular method is invoked.
Depending on how it’s used, you can monitor activities at various levels.
For example, in a web application, you can monitor requests by measuring time taken at the servlet and controller layers.
You can also monitor the service layer to gain more fine-grained information.
For development purposes, you can focus on parts suspected of slowing down the system.
For example, you can monitor JDBC or ORM calls to monitor database access.
You can also monitor the concurrency characteristics of the system to determine parameters such as thread pool size and throttling.
Performance monitoring of an application involves recording vital parameters of parts of the system: how long it takes to execute certain functionality, how many calls have been made for a particular method, and so on.
You can extend the basic idea of tracing to implement performance monitoring.
The idea is to compute the difference in timestamps before and after each monitored operation and record that difference against the currently advised join point.
You can also count the number of invocations for each advised operation.
The use of the @AspectJ syntax will also allow you to use the aspect through Spring’s proxy-based weaving.
Prebuilt solutions for monitoring The purpose of aspects in this section is to illustrate the core performance monitoring technique.
For a more complete solution, you may want to consider prebuilt solutions such as Glassbox and the SpringSource Application Monitoring Suite (AMS) that use AspectJ internally as an implementation technology.
But it’s best to encapsulate such functionality into a separate interface to allow a pluggable implementation.
For example, you can use Jamon (http://jamonapi.sourceforge.net) or Simon (http://code.google.com/p/ javasimon) to simplify gathering data and computing statistics.
It’s also best to leverage a DI mechanism to make such pluggability a configuration option.
Let’s enable monitoring of repository classes by creating a subaspect as shown in listing 10.23
You can now enable this aspect though AspectJ LTW using an <aspect> element inside aop.xml.
You may also use build-time weaving to weave the aspect prior to deployment.
Either way, when a user adds an item to a cart, you get output similar to the following:
You can play with the aspect to make the output more interesting and useful.
The same aspect can be applied using Spring AOP by adding the code in listing 10.24 into a file that forms the application context.
Now, when you run the web application and add a product to the shopping cart, you get output similar to the following:
Notice that only Spring beans and not other classes such as domain entities are being monitored.
This is due to the proxy-based AOP being applied only to the Spring beans.
You can also extend AspectJ-based profiling functionality to implement modular dynamic service-level monitoring.
You may have an agreement that provides you with certain performance guarantees.
You can collect the time before and after each invocation of the services.
When the service gets near or below the agreed level, you can alert the provider as well as use the information to collect penalties, if the agreement so specifies.
If you’re on the provider side, you can use the profile information to create alerts when the level of service approaches the agreed level.
Such alerts may help you fix the problem before it reaches a critical level.
Let’s complete the discussion of AOP-based monitoring by examining how you can control aspects once they’re deployed.
Monitoring aspects often need to be turned on or off in production.
This reduces the overhead associated with monitoring and the amount of data reported, thus improving comprehension.
A simple way to control an aspect is by using an if() check evaluating a boolean field and exposing that field through JMX.
If you need to control the applicability of the aspect at application startup, you can assign the boolean field a system property (or a property read from a property file)
You can also combine these two techniques to control the default applicability of the aspect as well as allow runtime control, as shown in listing 10.25
The aspect includes a boolean field so that it can be exposed to a JMX console.
You use this field inside the advice to control its application.
Note that you can use an if() pointcut, if the aspect is woven using the AspectJ weaver (which can then perform certain optimizations to avoid creation of the pjp object if the condition in the pointcut evaluates to false)
But because Spring AOP doesn’t support the if() pointcut, you embed the check inside the advice.
For runtime control, you need to expose the field through JMX.
If you’re using the Spring Framework, exposing the aspect through JMX is a trivial task, as shown in listing 10.26 (assumes AspectJ LTW deployment)
Now, when you connect to the application using a JMX console such as JConsole, as shown in figure 10.3, you see a bean named monitorAspect and can modify its enabled property.
As you can see, implementing performance monitoring using AspectJ is just as easy as tracing.
At this point, if you haven’t already done so, I urge you to download the source code for the book and try it yourself before proceeding to the next chapter.
Listing 10.26 Exposing the monitoring aspect using Spring’s JMX support.
Software developers and management often look for a killer application: one that is so well suited that it makes adopting a new technology worthwhile, despite the risks.
The reason behind this conservative approach is to balance the considerable investment associated with any new technology against the benefits it offers.
A killer application supposedly provides enough benefits to outweigh the risks.
Add to that the difficulty in measuring largely qualitative benefits, such as productivity improvements, cleaner design, ease of evolution, and improved quality.
Such qualitative benefits make proving the advantages of a new approach to a skeptic challenging.
The more practical approach is to find ways to reduce the investment involved with the new technology.
If you can achieve such reduction, you no longer have to wait until you see a bonanza of benefits.
AspectJ-based tracing and monitoring techniques offer low-investment, low-risk ways to begin using AspectJ.
The aspects and idioms presented in this chapter may be all that you need to start applying them in real world applications.
The use of LTW further enhances the plug-and-play nature of the solution; a simple modification to the startup script is all you need to add aspects to or remove them from your system.
If this chapter has convinced you of the benefits of using AspectJ for monitoring, you may start out by using it for tracing and performance monitoring to understand.
Figure 10.3 JConsole to monitor and control aspect exposed through JMX.
Later, you can demonstrate to your team the benefits you’ve experienced, which may lead them to adopt AspectJ as well.
At any point, including during the final shipment, you can exclude the AspectJ and monitoring aspects.
The overall effect is that you can start using AspectJ with minimal risk.
When you commit to AspectJ-based monitoring, you’ll start seeing even more benefits.
You can use AspectJ-based solutions for auditing and production performance monitoring.
This solution leads to increased flexibility, improved accuracy, and better consistency.
It saves you from the laborious and boring task of writing nearly identical log statements in code all over your system.
The use of AspectJ also makes the job of switching logging toolkits an easy task.
You can start with any one that you’re familiar with and feel comfortable that changing the choice later on will require modifying only a few statements.
Although it isn’t a killer application, monitoring may be the perfect way to introduce yourself and your organization to AspectJ.
Imagine that you’re convinced public access to a data member of a class isn’t a good idea.
Or, imagine that you’ve realized layered architecture is the way to go.
Or, suppose you’ve just finished reading the Enterprise JavaBeans (EJB) specification and realize that the specification prohibits working directly with files from an EJB.
Clearly, you’d like to ensure that the projects you work on don’t violate these principles and restrictions.
What are your choices? You could send emails to your team asking them to check for these violations, or you could add this information to a knowledge base.
Even if you somehow manage to detect any violations, perhaps through regular code reviews, what if you start a new project with a new team? Educate them again? OK, you get the point.
Policy enforcement is a mechanism for ensuring that system components follow certain programming practices, comply with specified rules, and meet any assumptions.
If there is no enforcement, errors may go undetected during development and show up only in the deployed system.
How would you enforce such policies today? Perhaps you’d use a static code-analysis tool such as PMD or FindBugs that looks for specific code patterns to flag potential programming problems.
You may also be able to write simple custom policies if you learn the tool’s specific programming language.
Even then, you’re limited to policies that static code analysis can detect.
Specifically, you can’t enforce policies that need information available only at runtime.
Although these tools are excellent additions to most development environments, they aren’t adequate for catching all scenarios.
You can also reuse those aspects and apply them to other projects without incurring additional development cost, thus building a company-wide library of accepted policies.
Policy enforcement with AOP falls in the developmental aspect category.
You can include these aspects during the development phase to help detect policy violations; and for deployment, you can exclude them without affecting the core system behavior.
This can be part of an incremental adaptation of AOP; you don’t have to commit to using AOP in the deployed system in order to get the benefits from it.
This chapter presents many examples that illustrate how you can detect violations by compiling your code along with a few prewritten aspects.
The examples include enforcement of layering in a typical application, enforcing good programming practices and idioms, as well as enforcing framework and concurrency control policies.
You’ll use AspectJ byte-code weaving as well as Spring AOP to implement various policies.
Because the code-analysis tools provide an alternative way to implement some of these policies, we’ll compare them with AOP-based solutions and provide guidelines for choosing the right tool for the job.
Let’s start with an overview of the AOP way of enforcing policies.
Consider a commonly accepted policy in a layered architecture, as shown in figure 11.1
The core idea is that each layer can access functionality only of the layer directly beneath it.
This policy, if implemented correctly, can simplify understanding and maintenance of the system.
Over time, many applications reach a point where the layered architecture has no discipline at all.
With AspectJ, you can write a simple aspect, as shown in listing 11.1, to enforce the layering policy.
Any other interaction is in violation of the layering policy.
You do it by detecting calls to specific layers and ensuring that they don’t occur outside the allowed layer.
Each statement declares that a call to a layer occurring outside the same layer or the layer above it is in error.
Note that the first statement doesn’t check for calls made in the same layer, because you won’t weave into the code for the data layer.
Similarly, the last statement doesn’t check for the layer above the web layer, because no such layer exists.
Instead, it uses the aspect shown in listing 11.2, which describes the system architecture.
Other aspects in the same system may reuse this aspect.
In this aspect, you assume that the application’s package structure follows the layering arrangement shown in figure 11.1
For example, you assume that types belonging to the service layer reside in the ajia.service’s direct or indirect subpackages.
This separation of pointcuts also simplifies modifications to the pointcuts when you perform refactoring such as renaming a package.
In any case, the pointcuts are well modularized in a single place.
The SystemArchitecture aspect uses yet another set of reusable aspects.
You don’t need the jdbcExecution() pointcut in this section, but it will come in handy as a reusable pointcut.
Similarly, listing 11.4 shows an aspect that implements JPA pointcuts.
Crosscut Programming Interface The SystemArchitecture aspect represents a kind of interface to a system that exposes its crosscutting structure.
With this approach, a set of aspects exposes XPI through pointcuts, and other aspects program to that XPI.
Specifically, you define a pointcut that selects calls that use Spring JDBC support classes.
Of course, if you access JDBC functionality through other means (say, through iBatis), you can add more aspects.
Let’s consider the code snippet in listing 11.6, which violates the layering policy by using JDBC from the UI layer.
Listing 11.6 A UI layer class that violates the layering rules.
When you compile this class with aspects and the rest of your classes, you get errors like this one:
After you add this aspect to your project’s build facility to compile it with the AspectJ compiler, you never have to remind your team members about avoiding layer crossing or accessing the layers in a wrong direction; the aspect does the job for you.
Although these types of policy violations may be caught by a thorough code review, the immediate feedback of tool-based policy enforcement is incredibly valuable.
You’re notified about the policy violation as soon as you build code.
Indeed, if you’re using the AspectJ Development Tools (AJDT) in Eclipse, it will notify you about the violations soon as you enter the code!
Figure 11.2 shows the overall scheme of policy enforcement using AspectJ.
Although the figure shows the use of build-time source weaving, other mechanisms such as load-time weaving work as well.
See chapter 8 for more information about adding the AspectJ weaver into your system.
Aspects implement policy enforcement to identify any violations in a software system.
With Spring AOP, you can implement violation detection only during runtime.
The solution presented in this chapter opens a new possibility for application frameworks and library creators.
Instead of (or in addition to) shipping the documentation specifying the restrictions, such products can now ship aspects that capture parts of the specification along with their framework.
Developers using the framework can detect most violations at compile time by including the aspects in their build system.
Aspects implementing policy enforcement are compiled together with the implementation of the core business logic.
Runtime enforcement detects violations when the system executes the violating code.
Because aspects are program constructs, they also serve as precise documents.
These aspects watch the users over their shoulders to check whether the assumptions made by the library developers are satisfied.
Avoiding incorrect usages leads to higher-quality applications, which results in higher user satisfaction.
Now that you have a general understanding of enforcing policies using AOP, let’s take a step back and examine how policies originate, why it’s important to invest in enforcing those policies, and how you can enforce them.
Policies represent accumulated knowledge about how to create higher-quality software.
Your own ideas about what a good architecture looks like, requirements of the underlying framework, and core architecture of the specific project.
Specific design choices made by the team on a project.
What you do with these policies is up to you.
If the policies encapsulate design decisions, the software system that follows will stand the test of time.
But if you let one violation go through, more violations will soon follow.
Code that violates policies can be mistaken for design decisions by new programmers unaware of the real policies, which in the worst case can lead to repetition of those violations as those new programmers ironically try to follow “the company standard”
Eventually, such an application loses the implicit architecture that was once its foundation.
There have been several attempts to create ways to implement these policies.
The most common way of documenting these policies relies too much on programmers’ due diligence.
Regularly conducted code reviews offer a way to share knowledge with others in the team and to look out for policy violations.
Code reviews should instead focus on the subtler nuances of design and implementation.
Automated tools offering static analysis of code to find out potential violations offer excellent solutions in some cases.
These tools share a few characteristics with AOP-based policy enforcement.
For now, let’s examine the core ideas in policy-enforcement implementation using AspectJ.
Fundamentally, policy enforcement requires flagging conditions that violate certain principles and assumptions, such as accessing the state of a class in a thread-unsafe way or from undesirable classes.
Detecting and correcting these conditions is vital for the quality of the overall system.
As we alluded to earlier, policy enforcement using AOP involves creating a few aspects that detect all usages that violate the required policies.
You can use many of the aspects developed in this chapter directly, without any modifications.
You have two choices for implementing policies: compile-time checking and runtime checking.
Each kind of enforcement has its appropriate usages and limitations.
In this section, we’ll discuss the AOP implementation for both kinds of checking.
Compile-time checking implies performing policy-violation checks during the compilation phase.
Compile-time checks are powerful—they allow you to perform checks even before running the system.
In strongly typed languages such as Java and C++, compilers already perform certain compile-time checking, such as type matching, access control, and so forth.
With AspectJ, you can take such checking to a new level; you can specify custom checks.
Now the compiler is your best friend; it can save you from a potentially time-consuming bug-fix cycle by minimizing the time between creating a bug and finding it.
Note that you may prefer to keep your build system unchanged but still benefit from AOP policy enforcements.
The regular build system produces artifacts such as jar files.
Then, either an additional build step or a separate build system weaves in those artifacts with policy enforcement aspects, producing errors and warnings during the build process as well as woven artifacts with runtime policy checks embedded in them.
Implementing compile-time enforcement using AspectJ involves the use of declare error and declare warning constructs.
These mechanisms provide a way to detect the presence of a matching join point during the compilation phase and to issue an error or a warning.
Although its early-detection capability is powerful, compile-time checking has limitations on the kinds of checks it can perform:
The only pointcuts you can use are statically determinable pointcuts.
Pointcuts such as this(), if(), and cflow() can’t be used for this purpose.
Pointcuts select join points and therefore can’t indicate a lack of a join point.
For example, you can’t detect an empty catch block (absence of a join point embedded in a handler join point)
You can’t use analysis based on multiple join points to declare an error or warning.
A declare error or warning construct issues an error or warning upon detecting a matching join point.
The use of statically determinable pointcuts precludes selecting a join point based on a matching criterion at another join point.
Therefore, compile-time enforcement can’t implement policies such as checking that a method is correctly releasing a concurrency lock that it acquired earlier in that method.
Checking for such a condition requires expressions that encompass two join points: one for acquiring the lock and another for releasing it.
For example, a pointcut can’t select methods that are over a certain size, methods that lack documentation, or methods with too many return statements.
Further, certain kinds of behavior, such as checking for ranges in values of certain arguments, can be performed only during the execution of a program.
In contrast to compile-time checking, runtime enforcement performs violation detection during system execution.
In languages such as Java, the VMs already perform certain runtime checks, such as cast-correctness and null-reference access checks.
Runtime policy enforcement is a similar idea, except that you can specify custom checks.
Upon detecting a policy violation at runtime, the usual approach is to log the violation along with the context in which it occurred.
If the system malfunctions, the logs can offer insight to potential precursors.
Even without malfunctions, periodically examining the logs can provide useful information so you can avoid potential problems in the next release—a sort of built-in QA.
Alternatively, you can implement a fail-fast strategy, where you throw an exception upon detecting a violation.
Such a strategy ensures that system integrity isn’t compromised due to continued execution of the system after a violation has occurred.
Of course, you should have a complete, automated test suite to catch violations during the testing phase instead of causing abrupt failures in production.
Runtime enforcement involves verifying the policies using dynamic crosscutting constructs.
For instance, you can write advice to detect the violation of Swing’s threadsafety rule.
Because such checking detects violations after the fact, logging for auditing purposes is usually the best option.
For major violations, it may be desirable to let the system shut down gracefully to avoid further damage.
The choice of action ultimately depends on the nature of the violation.
You can use either AspectJ weaving or Spring’s proxy-based AOP depending on the policies being enforced (the criterion to use one or the other is the same as discussed in chapter 9)
You need to hit the code path leading to a violation for the enforcement aspect to warn you about the problem.
For example, unit or integration tests must exercise code that violates the policy for the Swing single thread policy to be able to flag the violation.
In practice, this means having enough testing to exercise many scenarios, so you gain confidence in the code’s adherence to policies.
Contract enforcements Design-level contracts include pre-conditions, post-conditions, and invariants of form policies that let you express programming intentions.
But fixing the problem will force you to include the aspects in the deployed system, and that will remove the choice of using AOP in the deployed system.
If you want to preserve that choice, it’s important that the policy enforcements don’t change the core program behavior in any way.
They should be side-effect free and add notifications to inform you about policy violations.
While you have all the information ready to start developing a few examples, let’s address a lingering question—how code-analysis tools compare with the AOP way for policy enforcement.
Policy enforcement is so important that a few recently developed tools such as FindBugs (http://findbugs.sourceforge.net), Checkstyle (http://checkstyle.sourceforge.net) and PMD (http://pmd.sourceforge.net) address it.
These tools use code analysis to find violations of common coding practices.
Some even make it easy for you to write your own rules.
These tools can be tremendously valuable in improving the quality of your software.
Further, IDE integration of these tools makes it easy to use them.
Code-analysis tools can detect code patterns spanning multiple methods and classes.
They can also detect code patterns such as empty catch blocks.
Some of the tools operate at the source-code level (instead of the byte-code level) and therefore can detect a lack of documentation and even violations of coding conventions.
Some policies, such as avoiding public non-final fields in a class, can be enforced by either code-analysis tools or aspects.
If the code-analysis tool you use includes a policy of your choice, there isn’t much point in duplicating that enforcement using an AOP-based solution.
But in other cases, AspectJ’s simpler and more expressive programming model is attractive.
For the set of problems where AspectJ’s join point model is sufficient, writing a couple of pointcuts is all it takes to implement a new policy.
This makes it attractive to write policies specific to your code base.
In a few other cases, a code-analysis tool can detect violations of policies at compiletime, whereas with AOP you have to wait until runtime—for example, acquiring and releasing a concurrent lock.
In these cases, if the code-analysis tool of your choice implements the needed policy, you should favor its use over AOP.
Code-analysis tools offer no way to detect policies that require a runtime context.
For example, the Swing thread-safety violation that requires runtime knowledge (the caller thread, specifically) can’t be detected by any code-analysis tool.
In summary, you should use code-analysis tools as the first line of defense for enforcing common programming wisdom.
For runtime enforcement, AOP is often the only reasonable choice.
Now that you have a good understanding of AOP policy enforcement as well as its power and limitations, let’s examine a series of examples to put this information to good use.
Access control is a kind of enforcement that limits access to certain functionality.
Preventing access to certain parts of the API enables future modifications.
It also simplifies assumptions made on the caller, further simplifying the implementation.
But you can reap these benefits only if you can be sure that the whole system follows the access control.
AspectJ lets you define access control in far more precise terms than those offered by the standard Java access specifiers of public, protected, package (default), and private.
For package access, for example, Java offers only two categories: the owner package and all other packages.
But you may need to define access at a much finer package granularity—such as user interface, networking, and database—so that you can control which packages can access a certain class or method.
Consider the best practice of not exposing the internal implementation of a class.
Minimally, this practice translates to assigning nonpublic access to any (nonfinal) members.
In listing 11.7, the aspect warns you about using public access to any nonfinal field.
The aspect, per se, doesn’t detect the presence of public fields in a class.
But it detects read or write access to any such field.
The use of !final prevents the code from issuing warnings for access to final fields, which usually isn’t considered bad practice.
We don’t consider setting a final field to be in error, because that can happen only when the field is being initialized.
The class file in listing 11.8 shows the effect of the enforcement aspect.
You can then assign appropriate nonpublic access control to the field and introduce getter and/or setter methods.
The next time someone writes code that contains a public field, this aspect will catch the violation immediately.
Try this aspect in your own system; you may get some surprises.
It appears that the programmer intended to allow the manipulation of the Order class only through implementation of the OrderService interface, which ensures correct inventory updates.
But what is there to prevent direct access to an Order object?
Leaving the situation as it is downgrades the programmer’s “intention” to a programmer’s “wish.” Java’s access-control mechanism isn’t enough in this case.
Note that because the Order and OrderService implementation classes are likely to reside in.
Listing 11.8 Class to illustrate the violation of publicly exposed fields.
You need a way to implement access control that disallows calls to certain operations on an Order object from anywhere except in OrderService.
With AspectJ, writing a simple aspect such as the one in listing 11.9 ensures the intended access control.
You can see the violation detection in action by using the class in listing 11.10, which directly accesses the prohibited methods of the Order class.
Compiling OrderAccessAspect along with the CustomerService class detects any illegal access and issues a compile-time error like this:
Spring AOP applicability Due to the need to use the call() pointcut and the declare error statement, you can’t use proxy-based Spring AOP to enforce this policy.
With pure Java, this type of complex access control—allowing communication only between collaborating classes—isn’t possible.
Consider the factory pattern to create objects of the Product class.
Let’s say you want only the factory to create the Product objects.
With Java’s access-control mechanism, the best you can do is force the Product class and the factory class to reside in the same package and assign package access to the Product class’s constructors.
This is over-restrictive and, in some cases, impossible to implement.
For example, if the factory is in a package and the Product class is in a subpackage, it isn’t possible to implement the pattern correctly.
Further, other classes in the same package can freely create Product objects.
The usual solution is to let the Product class’s constructors have public access and document the restriction.
If a developer misses this documentation, you’re out of luck.
With AspectJ, you can implement and enforce the needed access-control properly.
With AspectJ, you can implement the friend functionality in Java as well as far more powerful access control.
Listing 11.11 shows the ProductFactory class that contains a nested aspect that implements the factory pattern policy.
The nested aspect declares that invoking any of the Product class’s constructors from any class other than ProductFactory or one of its subclasses will result in a compiletime error.
The class in listing 11.12 creates a Product without going through its factory.
Listing 11.11 ProductFactory class, with an aspect that controls its creation.
When you compile this class with the ProductFactory class (and therefore its nested aspect), you see an error as follows.
You could further restrict the access to various createProduct() methods in ProductFactory by replacing the within() pointcut with withincode()
See table 3.12 for more details about the withincode() pointcut:
Now, if you call a constructor of the Product class from anywhere other than a createProduct() method in ProductFactory or its subclass, you get a compile-time error.
If you’ve adopted AspectJ as your project’s programming language, this is often a better approach because it tightly connects the enforced class and enforcing aspect.
Such tight coupling allows you to update the enforcement aspect when the implementation of the access-controlled class changes.
But when you use this approach, you lose the choice of compiling the project with a pure Java compiler for deployment builds.
If such a choice is important to you, you should move the aspect to a separate file that can be excluded from the final build.
Alternatively, you can express the same aspect using the @AspectJ syntax.
If you compile the class with ajc, you’ll get enforcement.
But you’re still free to compile the same class using javac.
Of course, in that case, you won’t see any enforcement.
The examples have shown how to implement precise access control using AspectJ.
You can use this pattern to implement the access control that is suitable for your purposes.
The examples so far have been simple and used only static crosscutting.
Spring AOP applicability Due to the need to advise constructors, you can’t enforce this policy using Spring’s proxy-based AOP.
In a software system, you often decide to use a certain set of practices and follow certain guidelines.
When every part of the system follows them, the code’s clarity and maintenance improve significantly.
Let’s consider an idiom to never return a null collection and instead return an empty collection.
This simple idea has an interesting effect on code in that callers don’t have to check for null before iterating over a collection.
But if this pattern is implemented inconsistently, it quickly loses its value.
A developer using a class can never be sure if they should test against null before iterating over a collection.
As a result, some part of the code will perform the check and others won’t, without any necessary correlation with the code that requires checking.
This leaves messy code that the pattern tried to prevent in the first place.
Let’s apply this policy to the repository or Data Access Object (DAO)
You’d like to enforce that methods don’t return a null collection or map.
For illustration purposes, assume that all repository classes end in Repository (you should be able to modify the example easily to use any other mechanism, such as the @Repository annotation in Spring)
This aspect advises all join points in repository classes corresponding to methods that return Collection, Map, or their subtypes with an after returning advice.
The advice collects the return value, examines it for null, and logs a message upon detecting a null value.
Listing 11.14 Repository that violates the policy of not returning a null collection.
Note that AspectJ can also help implement the pattern by advising the target method, check against null, and return an empty collection.
But as we discussed at the beginning of this chapter, using aspects for such a purpose forces you to use aspects in production.
The listing shows a test that uses JPA to update an entity and JDBC to check whether the update was made to the database.
The test uses the @Autowired annotation from Spring to cut down the code required.
See the Spring documentation for this annotation and Spring’s support for JUnit 4 tests.
Spring AOP applicability You can translate this aspect to use @AspectJ syntax and use it with Spring AOP.
I assure you that there is nothing wrong with the repository implementation, at least from the test’s perspective.
What gives? Well, I forgot to flush the entity manager before making the JDBC call.
But would you always be lucky enough to notice the problem so quickly? I, for sure, would have first suspected the mapping (isn’t it always a mapping problem?) and then perhaps my SQL.
Only after some digging would I have realized the real problem.
As you’ll see shortly, with AOP, you can develop a reusable aspect that ensures that you catch such a mistake right away.
For performance and other reasons, it’s common to mix ORM with JDBC.
For example, you can update a few objects using JPA followed by JDBC calls to perform bulk object updating.
Therefore, you must explicitly flush the entity manager before performing any JDBC operation.
This policy is easy to understand and equally easy to forget, causing a lot of headache down the line.
You can use an aspect to detect the violation of such a policy.1 You can implement this policy using AspectJ AOP and Spring AOP.
I first saw my colleague Alef Arendsen implement such a policy, which he has used in his consulting engagements.
Seeing this common violation leading to mysterious results, he needed a way to detect any violations.
The AOP solution, similar to the one in this section, was a good fit.
This means any queries made through JPA may result in stale or incorrect data.
In general, barring a few carefully considered situations, you should perform bulk operations by themselves in a separate transaction.
Based on the material presented in this chapter, you should be able to write an aspect that detects such situations and produces a warning.
The example aspect assumes Hibernate as the JPA implementation.2 You need to make such an assumption because JPA lacks the API to detect a dirty entity manager.
Listing 11.16 shows an aspect that checks whether an entity manager is dirty (indicating the need to flush) and issues an error.
Using the Spring Framework, you can create a bean for this aspect and have it automatically injected with an EntityManager (see listing 11.17 for the configuration)
The jdbcCall() pointcut uses JDBC and Spring library aspects to select calls made using raw JDBC API or Spring’s JDBC template class.
Due to the use of the call() pointcut, you must use the AspectJ weaver.
Note that you could use the execution() pointcut, but that would force weaving into JDBC, JPA, and Spring.
Listing 11.16 Aspect to detect dirty session state (AspectJ weaving)
The before advice in the aspect obtains the current entity manager and casts it to Hibernate Session.
If the session isn’t null (indicating there is a current session), it’s open, and it’s dirty (indicating there is a need to flush the session), you issue an error log.
Listing 11.17 shows the Spring configuration needed to instantiate a bean for the aspect and have Spring inject its dependencies.
When you run the test, you get the following helpful error:
Note that is it easy to fix the problem by calling em.flush() in place of issuing an error.
But doing so forces inclusion of that aspect in production.
You can modify the aspect to use the execution() pointcut to make it suitable for Spring AOP.
In a typical Spring application, you won’t have beans of raw JDBC types such as Statement.
For a more comprehensive enforcement, you should use the solution based on the AspectJ weaver.
Listing 11.17 Spring configuration to initialize an aspect (AspectJ weaving)
Listing 11.18 Aspect to detect dirty session state (Spring weaving)
You also need to change the Spring configuration to remove the factory-method attribute, as shown in listing 11.19
Because the aspect is instantiated as a Spring bean without the AspectJ weaver, it won’t have the aspectOf() method.
Therefore, you use the default constructor to instantiate the bean.
When you run the test case, you get the same warning as with AspectJ weaving.
We’ll now move to another framework—EJB—to see how AspectJ can help with enforcing its policies.
This allows the framework to make a few assumptions and simplify its implementation.
In this section, we’ll examine programming restrictions imposed by the EJB specification on a bean.
To allow application servers to utilize nodes in a server cluster without any behavioral change in the system, the EJB programming model expects beans to follow certain guidelines.
Because most of these situations occur during heavy loads, you may not run into them during the development phase, and failure may occur only in real deployment situations and stress testing.
Listing 11.19 Spring configuration to initialize an aspect (Spring weaving)
This kind of combination is allowed and even makes sense.
The reusable aspects containing pointcuts can be in a separate project and compiled using ajc.
The plain Java project that uses Spring only deals with the .class files produced by ajc, so it can remain a plain Java project.
Instead, it’s an illustration of how AspectJ can help enforce its policies.
If you’re using EJBs, these policies will help you use them correctly.
Even if you aren’t using EJBs, you’ll see interesting AspectJ idioms, especially related to the use of custom annotations, that will help you enforce policies of other frameworks.
A first step in implementing a policy-enforcement aspect is to identify the target classes.
In either approach, EJBs no longer need to implement any specific interfaces or extend specific classes.
With annotation-based EJBs, identifying the classes implementing EJBs is easy.
But the AspectJ compiler can’t check deployment descriptors to identify the EJB classes.
In this section, we’ll emphasize policy enforcement for annotation-based EJBs, because they represent the promoted approach in the EJB 3 world and they’re easy to enforce with AspectJ.
Later, we’ll present a few ideas about how to extend the solution to XML-based EJBs.
Our way to detect violations of the EJB specification, like most of the solutions presented in this book, works in a plug-and-play style and is reusable.
Compiling your code with the aspect in listing 11.20 gets you the benefit.
You can use AspectJ to catch violations at compile time and runtime in a nonintrusive manner, as we discussed in section 11.3
Listing 11.20 shows an EJB policy-enforcement aspect that enforces two rules: no AWT code from EJBs and no nonfinal static field access (note that you could write separate aspects for each violation)
The uiCall() pointcut selects calls to any method in any class that extends a class in java.awt or its subpackage.
You can easily exclude a few classes by modifying the pointcut.
You make it an error to have UI calls made from within EJB.
You use a library pointcut inEJB() from the EJBPointcuts aspect (see listing 11.21)
To detect violations through indirect calls, you advise the UI calls in the aspect to check a call occurring in the control flow of a join point in an EJB.
It detects violations, for example, if a bean calls a method in a utility class, which in turn calls one of the prohibited methods.
Bear in mind that this advice may not always catch the violations, because the code path leading to the violating calls may not be executed in a particular sequence.
Therefore, you should first try to enumerate all the classes and packages that make UI calls and include those classes in the uiCall() pointcut.
This way, you’ll catch any violations at compile time and won’t have to wait until you run the system for problems to occur.
Another EJB programming restriction disallows the use of nonfinal static fields by a bean.
With AspectJ, you can indirectly implement this restriction by selecting write access to such fields.
This solution doesn’t implement the policy in exact terms, but it implements the spirit of it.
This aspect in listing 11.20 uses another library aspect, EJBPointcuts, which defines EJB-related pointcuts.
The EJB 3 specification lets you define EJBs by annotating classes.
There are three kinds of annotations for stateless, stateful, and message-driven bean.
Because you aren’t interested in the specific type of bean, you need a way to select classes that are marked with any of the annotations.
Listing 11.21 shows an aspect that uses a bridge annotation to simplify selection of an EJB.
You use a simple PolicyEnforcedEJB annotation without any properties as an intermediary bridge annotation to select all EJB types.
Without such an annotation, you’ll get a long-winded pointcut to select types carrying any of the EJB annotations.
Consider listing 11.22, which violates some of the EJB programming restrictions.
You’re now forced to address the problem (which may involve a simple fix or may require design modifications) before the system can be compiled without errors again.
This is a huge improvement in productivity, because fixing errors found at compile-time takes much less effort than if the same bugs are found during code review, testing, or production.
You can extend this aspect to implement other restrictions, such as no calls to Thread’s methods, socket creation, System.in access, native library loading, or reflection use.
For each such restriction, you must provide a pointcut definition to select the join points corresponding to the restricted operations.
You also need to include a declare error clause for those pointcuts.
To select indirect calls, you have to advise the join point occurring in the control flow of the bean method and log the violation.
To select EJBs developed using XML-based metadata, you need additional aspects to mark the EJBs with the @PolicyEnforcedEJB annotation.
For example, if Inventory is an EJB that uses the XML-based metadata, you can include an aspect such as the one in listing 11.23 to make it participate in EJB policy enforcement.
The aspect uses the bridge annotation as a way to inform the EJBPointcuts that the marked class is an EJB.
Note that although you could use an appropriate EJB annotation in the declare @type expression, using a bridge annotation lets you avoid interfering with the EJB tools and frameworks.
You can include any number of such aspects to treat classes as EJBs for enforcement purposes.
You can even select non-EJB classes that are known to be exclusively used by EJBs to maximize compile-time errors (as discussed in D accompanying listing 11.20)
Sometimes, a policy must enforce that a project may not use certain types or methods.
Let’s use EJBs as an example to illustrate implementing such a policy.
Let’s complete this section by implementing a fun policy that specifies that you shall not use EJBs in a project.
I call it a “fun” policy that is of little practical importance because accidentally slipping in an EJB is practically impossible.
Therefore, the value of this example lies in showing how to implement policies that prohibit accidental use of a certain set of classes.
Listing 11.24 shows how you can implement the policy to avoid using EJBs.
Without the static initialization restriction, you’d get one error per join point in such a class.
You can put concurrent computing resources to good use as long as you understand the rules of engagement.
But failing to use them correctly can cause headaches to no end.
Any enforcement in this area can be of tremendous importance.
This section uses Swing’s concurrency rules as an example to illustrate how AspectJ can detect violations.
Swing, currently the most popular Java GUI library, uses a simple thread-safety pattern: use a single thread to access the component! This pattern requires accessing all the Swing components only through the event-dispatching thread (also called the AWT thread)
By limiting access to the preassigned thread, the pattern moves the issue of thread-safe access away from the components.
When another thread needs to access a Swing component, it must request the event-dispatching thread to carry out the operation on its behalf instead of doing so itself.
In simple applications that don’t use any user-created threads, single-thread access usually isn’t a major concern.
Because the components are updated in response to user actions, which are called in the event-dispatching thread, the single-thread rule is automatically observed.
For example, you don’t have to worry about this rule when you’re deleting a row in JTable in direct response to a user clicking a button.
A typical example is a thread performing network- or I/O-intensive operations or database-related activities.
For example, consider a situation where you need to update the UI based on information from a server (a table’s contents in a database, for instance)
You make a request to the server, wait for a response, and update the UI based on that response.
You don’t want the event-dispatching thread to be blocked for the response, because doing so locks your whole GUI until the server responds.
A simple solution is to let some other thread wait for the server to respond and update the UI once the response is obtained.
If the thread waiting for the server to respond updates the component while the AWT thread is repainting the UI component, it may result in UI anomalies or even worse—a crash.
Even more dangerous is the fact that these issues aren’t immediately visible—it may be that you never see this problem on your machine.
Murphy’s Law seems to work well with the single-thread rule: if you violate the single-thread rule, the problems always seem to occur during the customer demo of your product!
In this section, we’ll examine a way to detect these violations.
The term realized in this context refers to making a component visible.
When a component is visible, the event-dispatching thread is the only thread that can safely access or update the state of the realized component.
The rule exempts certain methods, allowing them to be safely called from any thread.
The simple program in listing 11.25 illustrates a violation of this policy.
But unlike Swing, SWT enforces this policy, thus obviating the need for an external enforcement mechanism.
The two lines in bold violate the rule requiring that after the components are put onto the screen (using pack() and setVisible()), any access or modification must take place only from the event-dispatching thread by calling either invokeLater() or invokeAndWait() in the main thread.
In this case, you call the setValueAt() and removeRow() methods on the table model.
In practice, this type of violation occurs because of calls made from another user thread, such as a thread reading data from a network or database.
We’ll discuss the solution to the problem in more detail in chapter 13, where we’ll also examine the AOP way of modularizing it.
You’ll now develop a dynamic checking aspect to catch any violation of Swing’s singlethread rule.
The fundamental idea is simple: check whether a thread other than the event-dispatching thread accesses a Swing component’s state.
The aspect itself uses a library aspect—Swing—that defines a few pointcuts.
The advice logs a message with the information about the call, the caller method, and the caller thread, if any join points aren’t called from the event-dispatching thread.
This helps you analyze the root cause of the problem.
In practice, instead of printing a message onto a console, you’ll want to log it into a file; there is little point in telling the user that your program did something wrong.
The bulk of the heavy lifting lies in defining the Swing-related pointcuts.
Listing 11.27 shows the library aspect that defines the relevant pointcuts.
The pointcut threadSafeCall() selects method calls that are considered safe as per the JComponent documentation.
It also uses naming patterns to select all listener management methods.
The pointcut viewCall(), which selects the method calls on a view object, is defined as a call to any method of JComponent or its subclasses.
The pointcut modelCall(), which selects operations on a model, is defined as a call to any method of any class with a name ending in Model within the javax package or its subpackages; it also selects subclasses of such a class.
By the way, notice the importance of following a consistent naming convention; if you name all your models ending in Model, then selecting join points based on name becomes easy.
The pointcut uiCall() combines the viewCall() and modelCall() pointcuts to select all the method calls that are involved in Swing’s thread-safety rule.
You could have defined the uiCall() to directly select all the required methods calls, but the use of separate pointcuts helps improve overall understanding.
When you compile the classes and aspect together and run the driver program, you get the following output:
Note that you’re getting false positives before the frame is visible.
As you introduce AOP to your project, one of the problems you can face is resistance to committing to it.
People will demand proof that AOP is worth the perceived effort and complexity.
This can become a Catch 22 situation—you can’t show its usefulness to your project because you can’t use it, and you won’t be able to use it unless you show its usefulness.
Well, policy enforcement offers you a way to overcome this issue.
Even if your organization or team isn’t yet committed to AOP, you can still use AOP-based enforcement to improve your personal productivity.
If that convinces your colleagues about the benefits that AOP offers, good.
Otherwise, continue using the aspects in your own development world, and exclude them in the final builds.
The plug-and-play nature of policy-enforcement aspects provides you an opportunity to play with AOP without requiring a full commitment.
The next time you encounter a novel programming wisdom or best practice, consider writing an enforcement aspect encapsulating the knowledge.
Over time, you’ll have a repository of policy-enforcement aspects that will help you in all your projects.
When you start using a new framework, you can create policy-enforcement aspects specifically targeted to the framework.
If you’re in a mentoring role, you can provide your aspects to your team.
You’ll then no longer have to sit down and repeat the policies with each team member.
The policy-enforcement aspects you develop are reusable, lowering your per-project development cost.
These aspects use the AspectJ compiler to enforce as many policies as possible at compile time and use dynamic crosscutting to understand the runtime violations in more detail.
You can even use Spring AOP to implement certain runtime policy enforcements.
With such aspects in place, you’re assured of better-quality code, and you can spend your time on more exciting issues.
Note, though, that the mechanisms presented here don’t substitute for code reviews.
But with policy enforcement in place, the code reviews can focus on the subtler nuances of design and implementations.
When you start enforcing policies in a significant way by using AOP, you’ll find AOP to be your best friend; it always watches you, reminds you of common pitfalls, and lets you spend time on the more creative aspects of life.
Patterns also carry names like factory, visitor, and decorator to simplify the communication of design concepts.
Pattern names also convey the designer’s intent and decisions succinctly and accurately without providing all the details.
This chapter presents AOP design patterns that can help you define solutions when you start applying AOP.
They can also help you start thinking about problems in more abstract terms.
Although this book covers problems from many domains, you’ll no doubt encounter new problems as you begin using AOP in your projects.
When that happens, you’ll find that a combination of these design patterns will lead you to a solution more quickly.
In this chapter, we’ll examine four design patterns: the worker object pattern, the wormhole pattern, the participant pattern, and the annotation-driven participant pattern.
Except for the wormhole pattern, you can implement them using Spring AOP as well.
In the chapters that follow, we’ll use these patterns for more advanced crosscutting implementations.
A worker object is an instance of a class that encapsulates a method (called a worker method)
A worker object can be passed around, stored, and invoked.
In Java, a common implementation of a worker class implements Runnable, where the run() method invokes the worker method.
When you execute such an object, it in turn executes the worker method.
The worker object pattern offers a way to generate worker objects automatically for join points selected by a pointcut.
You can then pass around these objects to implement various functionalities.
When you use this pattern, you ensure a consistent behavior in your system—and you save a ton of code.
I first discovered this pattern while adding thread safety to a Swing-based project, where a network reader thread was performing some UI updates.
To comply with Swing’s single-thread rule (discussed in chapter 11), the network reader thread couldn’t directly call the UI update methods.
But in the first solution, I used one hand-coded worker class to route each update method individually.
The thread-safety aspect advised each method to pass an instance of the corresponding worker class to the event queue instead of directly invoking the method.
Although AspectJ clearly helped to avoid polluting the core code with the logic to comply with the Swing rules, writing the boilerplate classes for each kind of update was boring, to say the least.
Feeling that something was amiss, I experimented and created a single aspect that advised all the update methods with an around advice that invoked proceed() in an unconventional manner (as I’ll describe shortly)
The result was that a single aspect consisting of only a few lines replaced all the hand-coded classes.
Soon, I was encountering problems of authorization and transaction management where the same solution could help.
Then, I realized that I could use the same approach to execute certain time-consuming operations in a separate thread and thus improve the responsiveness of the UI application.
What I had on my hands was a scheme that solved a recurring set of problems—in other words, a pattern.
If you were to solve the problem of creating worker objects without using the pattern, you’d have to address two chief tasks for each method involved:
Depending on the situation, you may use either named or anonymous classes.
In either case, you implement an interface such as Runnable that contains a run() method for invoking the work method.
If you use named classes, you must add a constructor to accept arguments matching those of the work method.
If you use anonymous classes, you don’t (and can’t) write a constructor.
Instead, you create the class locally and pass the variables from the outer context (where the class is implemented) as the arguments to the work method.
You need to mark each local variable passed as final because local classes can’t access non-final local variables.
With either style, you need to replace the normal method call with the creation of a worker object and invoke that object.
The sheer amount of code makes implementation a daunting task; it also increases the risk of missing certain changes, which may result in undesirable system behavior.
As you’ll see in the next section, the worker object pattern encapsulates these steps into an aspect, eliminating the need to create multiple worker classes.
In this pattern, you use an aspect to create objects of anonymous classes (which are the worker objects) automatically.
You write a pointcut selecting all the join points that need routing through a worker object, and advice that executes the selected join point inside the run() method of the anonymous worker class.
Normally, when proceed() is called directly from within around advice, it executes the selected join point.
But with the worker object pattern, you create a worker object, have its run() method call proceed(), and invoke the run() method later, perhaps in another thread, to execute the selected join point.
Let’s write a pattern template that you can use to create your own implementation easily.
First, you write a pointcut selecting the needed join points.
Next, you advise this pointcut with an around advice to create and use the worker object, as shown in the following snippet:
Let’s use a simple example to illustrate the worker object pattern.
Assume that you’ve decided that cache pre-fetching and saving a backup copy of a project are expensive operations that can be better executed in a separate thread.
Later, in chapter 13, we’ll expand this example to demonstrate how you can avoid locking the UI when calling a time-consuming task.
Let’s set up the example with three classes; then, you’ll apply the pattern to them.
The class CachePreFetcher in listing 12.1 contains one method that simulates the cache fetching operation by printing a message.
Similarly, the ProjectSaver class in listing 12.2 contains a single method that simulates backing up a project by printing a message.
Now, you write a simple driver (listing 12.3) to exercise these classes.
When you compile these classes and run the main program, you get following output:
The output shows that the main thread executes both methods.
Consequently, the main thread is blocked for the period that the method is running.
Now, let’s write a simple reusable aspect that executes selected join points in a separate thread.
In the aspect, the asyncOperation() pointcut selects join points to be routed asynchronously.
The around advice creates an object—worker—of an anonymous class that implements the Runnable interface.
In the run() method, it calls proceed() to execute the advised join point.
Because worker performs the operation selected by the advised join point, it’s the worker object here.
The advice executes the work by passing the worker object to the execute() method of the executor object.
Although you use a thread pool–based executor, you can use any other implementation (such as the one obtained through your application server)
The effect of this advice is that instead of directly invoking the join point, the aspect routes the join point execution in a new thread.
Note that you can extract a reusable base aspect to route operations asynchronously.
When you compile all these classes and aspects and run the driver program, you get this output:
As you can see, by introducing a simple aspect to the system, you ensure that each operation runs in a new thread instead of the main thread.
Some of the routed calls could be returning a value to the caller.
In that case, proceed() returns the value of the method when the operation has completed.
You can keep this value in the worker object and later return it from the around advice.
Of course, for the value to make sense, the caller must wait until the execution of the worker object finishes.
The run() method in the implementing classes must set the returnValue property to the return value of the proceed() statement, which is the return value of the executed join point.
Instead of using Runnable, you use the class shown in listing 12.5 as the base class for an anonymous class inside the advice, as in the code snippet that follows.
You also set the return value to the value returned by proceed()
Continuations and worker objects A continuation represents an object form of some code to be executed.
Because a continuation is an object, it may be passed around or stored.
A worker object also represents the same concept that can be implemented in Java with the help of AspectJ.
Note that for the return value to make sense, you must wait for the work to complete before invoking getReturnValue()
If you call the worker object’s run() method object in the same thread, you don’t need to do anything special.
You’ll see examples of such situations in chapter 14, when you apply this pattern to transaction management –related concerns.
If you call the run() method in a separate thread, you have to wait until that thread has a chance to execute the work.
You’ll see examples of such situations in chapter 13, when you apply this pattern to implement Swing’s thread-safety policy.
As discussed in chapter 4, specifying Object as the return value causes the around advice to wrap the primitive return values before they’re returned from the advice and unwrapping and casting the objects correctly after they’re returned from the advice.
For example, if the selected method returns a float, the AspectJ weaver takes care of it by creating a wrapper object to be returned by proceed() and unwrapping it when you assign the advice’s return value to a float variable.
You’ll implement an aspect as shown in listing 12.6 that uses a worker class to route the advised methods synchronously.
The aspect implements the template shown earlier in the section.
I chose these methods to illustrate that the aspect handles returning a primitive type, returning void, and returning an object.
The advice creates a worker object and calls the run() method on it.
Then, it logs a message when it’s about to execute the worker object.
Typically, you’d pass the worker object to another thread and wait for the execution of the worker.
Finally, let’s write a simple driver program (listing 12.7), which prints the result of each operation as it executes.
First, you compile the program without aspects and see the output:
Now, when you compile and run the program with the aspects, you see output similar to the following:
As illustrated by the output, the resulting program’s behavior is unchanged from the original program that didn’t include any aspects.
You now have a mechanism for routing direct calls through worker objects that requires writing only a few lines of code.
The worker object pattern offers a new opportunity to deal with otherwise complex problems.
You can use this pattern in a variety of situations: from implementing.
The wormhole pattern thread safety in Swing applications and improving the responsiveness of UI applications to performing authorization and transaction management.
Initially, I was fascinated by the time I saved by not having to write as much code.
Later, I felt that the pattern’s real value lies in the sheer elegance and consistency it brings to the solution.
The wormhole pattern makes context information from a caller available to a callee—without having to pass the information as a set of parameters to each method in the control flow.
For example, consider an authorization system, where many methods need to know who invoked them to determine if the caller should be allowed to execute the operation.
The wormhole allows the methods to access the caller object and its context to obtain such information.
By creating a direct route between two levels in the call stack, you create a wormhole and avoid linearly traveling through each layer.
This saves you from having to modify the call chain when you want to pass additional context information, and it prevents API pollution.
If you don’t use AspectJ, there are two ways to pass the caller’s context in a multithreaded environment:
Pass the context as additional parameters to methods, which subsequently pass it on.
This continues until the context reaches the place of its use.
This causes API pollution—every method in the execution stack must have extra parameters to pass on the context collected.
Use thread-local storage to set and access the context information.
This requires the caller to create a ThreadLocal variable to store the context information.
Although this approach avoids API pollution, it entails changes in both caller and callee implementation and requires an understanding of how the context is stored.
This is especially important in an environment that uses thread pools (practically, that includes every application and web server)
If you forget to clear a thread local, you run the risk of exposing old information to the next user of that thread.
Therefore, even if you don’t use the wormhole pattern, consider using an aspect to set and clear thread locals.
In either case, multiple modules are involved in the logic to manage the context.
The basic idea behind the wormhole pattern, shown in figure 12.1, is to specify two pointcuts: one for the caller and the other for the callee, with the former collecting.
Then, you specify the wormhole as the execution of the callee’s join points in the control flow of a caller’s join points.
Figure 12.1 depicts each level in the call stack as a plane in the space.
To transport context from one plane to another, you’d normally have to pass it to the next plane until it reached the desired location.
The wormhole pattern provides a path that cuts directly through the planes, which avoids having the context trickle through the levels from caller to callee.
Let’s create a template for the pattern that will allow you to plug the pattern into your system by replacing the entities in the template with the specific ones in your system:
In this template, you define a pointcut in the caller’s space that collects the associated context.
The collected context in both cases could be an execution, a target, arguments to the callee join point, or any associated annotations.
You then create a wormhole through these two spaces using a pointcut that selects the join points selected by the calleeSpace() pointcut in the control flow of the join points selected by the callerSpace() pointcut.
Because you have the context available for both of these join points, you can write advice to the wormhole() pointcut using this information.
Each horizontal bar shows a level in the call stack.
The wormhole makes the object in the caller plane available to the methods in the called plane without passing the object through the call stack.
The aspect in listing 12.8 creates a wormhole between a transaction system such as an ATM, a teller, or an Internet bank and the actual account operations.
Due to the use of a wormhole, it doesn’t matter how many layers exist between a transaction system and the account objects.
It collects the this object as the context that you want to pass through the wormhole.
Note that only context that can be collected using a pointcut can be passed through the wormhole.
In other words, objects such as local variables can’t be passed.
It collects the account and the amount as the context.
Only with AspectJ Due to the use of the cflow() pointcut, the wormhole presented here works only with AspectJ weaving.
With Spring AOP, you may get a similar effect using ThreadLocals.
The pointcut also collects the context selected by the constituent pointcuts, so that advice to it may use it.
The advice to the wormhole() pointcut can now use the context.
The advice knows not only the account and the amount but also the transaction system responsible for causing the account activity.
For example, the advice may log this information, perhaps to a database, so that it can be used to generate monthly statements showing transaction systems accessed by customer for each transaction.
The wormhole pattern offers you the flexibility to introduce new join points in the caller space.
For example, in a banking system, activities performed in crediting an account may depend on which kind of system invoked them.
If a debit action is initiated through a check-clearance system, you can fire overdraft protection logic.
But if the same actions were invoked through an ATM machine, you limit the withdrawal amount—it doesn’t matter which specific ATM machine initiated the transaction; it’s enough that an ATM machine did it.
Using a wormhole pattern in these cases helps to avoid passing an extra parameter to the account operations to indicate the type of the transaction system.
This not only avoids API pollution but also offers a nonintrusive change if the system adds a new kind of caller.
In this banking example, you can implement additional rules when a new kind of the account-access system is added, such as internet banking, without making any system-wide changes.
The wormhole pattern removes the need to modify multiple modules for passing the caller’s context.
With the caller context available at the callee’s join point execution, you can easily implement functionalities that require both contexts.
Selecting join points with common characteristics across a system is essential in ensuring consistent system behavior.
For example, you may want to surround all slow operations in the system with a wait cursor.
The common AOP approach for accomplishing this is to define pointcuts based on the type and name patterns.
For example, a method throwing an IOException is potentially performing some IO operation.
This information, in conjunction with a hypothesis that IO operations are slow, lets you identify and select a few slow methods.
Similarly, you can consider all methods whose name starts with set as potentially state-altering operations.
But you often can’t select all the join points sharing a similar characteristic just by using the type and name patterns.
For example, although you characterized all IO operations as potentially slow, how do you select other operations that are slow because they perform complex computations?
Many crosscutting concerns, such as transaction management and authentication, tend to span operations that can’t be selected by pointcuts relying solely on type and name patterns.
Developers usually assign the name of a method based on its core operation.
Therefore, the method’s name doesn’t reflect the method’s peripheral characteristics.
Therefore, selecting transactional join points that rely on method names isn’t possible.
The participant pattern helps select the methods based on their characteristics and requires the participating classes to collaborate with the aspects explicitly.
Keep in mind, though, that the participant pattern and its variations require modifications to the core classes, and there is a possibility that you may not identify all the operations.
For this reason, you should use the regular pointcuts to the fullest extent possible.
First, we’ll look at a simple technique that allows you to advise join points that share certain characteristics.
Then, we’ll improve the solution to make it easier to maintain.
We’ll use the example where a wait cursor needs to be set around any slow operation.
The aspect defines a pointcut that lists all the methods that have the characteristics of being slow.
The problem with this approach is that tight coupling exists between the aspect, all the classes, and the methods in the list.
If a new class is added to the system containing a method with the same characteristics, it won’t be advised until it’s added to the list.
Similarly, if a method that is originally part of the list changes its implementation so that it’s no longer slow, it will continue to be advised until the aspect is changed to remove the method from the pointcut definition.
Let’s see if you can tie the pointcut definitions to the classes themselves.
Recall that a class can include pointcuts (but not advice)
Because a class knows about the characteristics of its methods, it can specify pointcuts identifying those characteristics.
Listing 12.10 shows how Analytics includes a pointcut that selects its slow methods.
Similarly, Document in listing 12.11 includes a pointcut that selects its slow methods.
Now you can write an aspect to advise both slowOperation() pointcuts defined in Analytics and Document.
Instead of being aware of classes and methods, the aspect is now aware of only the classes because it uses the pointcuts defined in them to select the methods.
Nevertheless, the need to be explicitly aware of all the classes doesn’t make it an optimal solution.
If a new class is added to the system, the aspect won’t advise the new class until you add it to the aspect.
You must explicitly enumerate all the pointcuts you want to advise from each class.
The participant pattern builds on the idea of classes that contain a pointcut denoting certain characteristics.
Instead of including a pointcut definition directly inside each class and using those pointcuts in an aspect, the classes define a subaspect that extends the advising aspect and provides the pointcut definition.
In a way, this pattern reverses the roles—instead of making aspects aware of classes, it makes the classes aware of the aspects.
You write an abstract aspect that contains abstract pointcut(s) denoting join points with the desired characteristics.
The aspect also advises each pointcut (or a combination of them) with the required behavior.
You can think of this aspect as an inviting aspect—it invites others to participate in the functionality it offers.
Such an offer is strictly an invitation or opt-in only.
Each class that wants to participate in such a behavior includes a concrete subaspect extending the abstract inviting aspect.
Each of these subaspects provides the implementation of the abstract pointcut for the enclosing class.
Note that the concrete subaspects don’t have to be nested aspects of the class—they can be peer aspects.
This way, each class that wants to participate in the collaboration needs to do so explicitly—hence the name of the pattern.
In this section, you’ll develop a template for the pattern.
Listing 12.13 shows the abstract aspect that contains the core logic for implementing the concern; but it defers the definition of the slowOperation() pointcut to subaspects.
The required crosscutting behavior is in the advice to the abstract pointcut.
The effect of this aspect is that the advice to slowOperation() in the base aspect is applied to the specified methods.
Document in listing 12.15 participates in the collaboration in the same way.
There can be many more participants in addition to Analytics and Document.
Each of the participating nested subaspects provide a definition to select the join points in.
The participant pattern their enclosing class, thus applying the functionality of the base aspect to those join points.
Note that it’s perfectly legitimate for a subaspect to use a naming pattern or other signature components to define the pointcut instead of enumerating the methods.
With the participant pattern, the collaborating classes explicitly participate in the implementation of the crosscutting concerns by extending an inviting abstract aspect and providing the definition for its abstract pointcut.
It’s possible, for example, to have one participant per class hierarchy or package.
But in such cases, because the aspect isn’t nested in the class, you must remember to modify the pointcut in the participant aspect whenever the list of methods matching the desired characteristic changes.
Crosscutting concern implementations often require some behavior specific to the advised type to be invoked from advice.
For example, an authorization aspect may need the roles that are authorized to access specific functionality.
In many cases, the base aspect can leverage join point context to deduce the needed behavior.
For example, the authorization aspect might use a method name as a key into a map to obtain the security role (you’ll use such a scheme in chapter 15)
But in other cases, complex logic may be needed to obtain the role.
Perhaps the amount involved in a banking transaction determines the role needed to perform the operation.
In such cases, you need collaboration from classes not only in supplying the pointcuts but also in augmenting the behavior.
The setup for the participant pattern easily accommodates such scenarios.
You include one or more abstract methods in the base aspect.
For each class, a nested subaspect exists to make the class participate in the collaboration offered by the base aspect.
The participant pattern provides a good solution, but it suffers from a couple of shortcomings:
You can overcome some of these limitations with a variation of the pattern that uses annotations, as you’ll see shortly.
Only classes have the potential to know such information, so the pattern makes tracking changes in the class a local affair.
Although the pattern requires explicit participation by classes in the aspect collaboration, their knowledge of the aspect is limited to defining the implementation of the abstract aspect.
The biggest consequence of using this pattern is a reversal of the collaboration flow.
In the participant pattern, the aspect makes the class participate in the aspect collaboration, whereas in other cases, aspects affect classes without their knowledge.
The core concept in the participant pattern is explicit participation by the participants (classes, typically)
With the growing popularity of language support for metadata, there is a variation of the classical participant pattern: the annotation-driven participant pattern (ADPP)
The key to annotationdriven participation is changing how the participants show interest in the functionality offered by an aspect.
Whereas the classical version of the pattern uses a pointcut, the ADPP uses one or more annotation types and expects the participants to attach the annotations to appropriate elements.
Figure 12.3 The annotation-driven participant pattern uses an aspect that expects program elements to carry certain annotations.
The classes participate in the functionality offered by marking program elements with the expected annotation.
As shown in the figure, the aspect advises join points for the methods annotated with the @Transactional annotation.
Classes such as OrderService participate in this functionality by marking appropriate program elements with that annotation.
The classical participant pattern discussed in the earlier section is the most common current solution that addresses the problem of selecting join points of the desired characteristics.
Obviously, it represents one of the best options when there isn’t a way to use annotations.
But note that the classical participant pattern offers a few customization possibilities that are harder to achieve with ADPP.
For example, in the classical pattern, you can create multiple subaspects, each to suit a specific need.
Each subaspect can also provide a variation of a certain behavior by overriding methods in the base aspect.
You should preserve the use of an abstract base aspect even in ADPP to allow for such customization.
We’ll use the same example of managing wait cursor around slow methods.
Listing 12.16 shows an aspect that uses an annotation to select slow operations and advises them to manage the wait cursor around them.
The aspect extends the base aspect you developed in listing 12.14
Note how you still use the base aspect that doesn’t use any annotations and a subaspect that defines the pointcuts using annotations.
This arrangement provides freedom regarding the type of annotation used and lets you fall back to the classical participant pattern, if necessary.
The annotation specifies that it may be used to annotate types and methods.
Now, you need to mark methods or classes with the @Slow annotation.
The annotation type used needs careful consideration to produce the right level of abstraction.
Writing software is mostly about working at the correct level of abstraction.
Keep in mind that the right abstraction is always in the eye of the beholder.
Although I’ll specify three levels of abstraction and discuss criteria, it may not always be clear which level a particular annotation belongs to.
Listing 12.18 Analytics class annotated to participate in the collaboration.
Annotation-driven participant pattern the levels matter less than the thought process that leads to a correct level.
Further, the use of an abstract base aspect lets you use multiple levels of abstraction that are suitable for a given task.
You can then write subaspects to do either direct participation as with the classical pattern or annotation-driven participation using any annotation of your choice.
At this level of abstraction, the goal is to avoid a direct coupling of aspects with classes by using an annotation as an intermediary.
The classes and aspects agree on a narrowly defined annotation type whose sole goal is to facilitate the join point selection for a specific functionality.
For example, in the case of the wait-cursor management functionality, aspects are required to set and unset the wait cursor.
In environments where a wait cursor makes no sense (say, a server-side application), the aspect is in a fix: should it ignore the demand or fulfill it anyway?
Essentially, with this level of abstraction, you get a macro-like facility.
It offers a better alternative than directly embedding crosscutting code inside the classes.
It also provides a level of consistency by isolating the functionality in an aspect.
For example, you won’t run into issues such as a few methods forgetting to unset the wait cursor in a finally block (because methods contain no code related to setting and unsetting the wait cursor)
But you can often use a better level of abstraction, as you’ll see next.
At this level of abstraction, the focus is on using annotations to describe characteristics of the program element, keeping in mind its specific usages by aspects.
This level of abstraction allows program elements to express characteristics within the context of a specific crosscutting functionality.
For example, you can use the @Slow annotation because slowness is a characteristic of a method that may be used to manage the wait cursor.
Specifically, these kinds of annotations make certain assumptions about how they will be used.
In the case of wait-cursor management with the @Slow annotation, the slowness represents a subjective criterion with an eye on a target usage.
It’s unlikely that a UI application and a robotics application can agree on the same criterion to define slowness!
For all its limitations, in some cases a subjective characteristic is the best you can do.
Note that a method doesn’t have an inherent characteristic of being secure; it’s only in the context.
But subjectively, in the context of a secured application, methods have security attributes that annotations may describe.
In some cases, you may do better and avoid subjective characteristics when using annotations, as you’ll see next.
At this level of abstraction, annotations purely describe program elements’ characteristics, which aspects may use in any possible way.
In other words, annotations describe the objective characteristics of a program element that hold true in any context.
For example, for the wait-cursor management functionality, you can use purely timingrelated annotations that specify the expected execution time; see listing 12.20
Then, the aspect can select join points based on timing information; see listing 12.21
You can use the same annotation for a variety of purposes.
For example, you can write an aspect that performs monitoring to ensure that a slow operation (with an appropriate threshold) doesn’t occur in a critical path.
For example, consider the @ReadOnly annotation to describe read-only methods and objects.
This annotation essentially nudges toward replicating the const keyword feature in C++
For example, what should be the unit of the value property of the Timing annotation? Any wallclock based unit will be wrong on a machine with a different speed.
Perhaps you can use milliseconds on a particular setup that serves as a benchmark, or the number of CPU cycles on a benchmark CPU.
No abstraction makes sense in all situations, and providing freedom in choosing a specific implementation is always desirable.
Using an abstract base aspect that doesn’t use any annotations addresses this issue by letting subaspects make the right choice of abstraction.
Let’s examine a variation of ADPP that bridges these abstraction levels and works with elements that aren’t annotated.
They have the sense that using annotations (especially framework-specific annotations) strips Plain Old Java Objects of their plainness.
For example, consider the @Configurable annotation in the Spring Framework.
Although most developers venturing into domain-object dependency injection (DI) are fine with marking their classes with the @Configurable annotation, others feel a bit of uneasiness due to coupling between their domain classes and the Spring Framework.
On the one hand, Spring’s aspects expect classes to be marked with that annotation.
On the other hand, marking your domain classes with the annotation makes them less plain.
In this case, you can use an aspect that supplies the annotation expected by a framework aspect.
With this arrangement, the classes don’t directly depend on the framework, yet they benefit from its functionality.
This pattern also helps when you can’t modify existing source code to add annotations.
Consider a situation where domain classes that need DI are already extending a class—say, DomainEntity.
You can use the following declaration to supply the @Configurable annotations:
The Spring Framework will now behave as if the domain classes carry the @Configurable annotation.
Alternatively, if the classes don’t share a common characteristic, you can use your own interface (say, IConfigurable) to modify the classes and use it in supplying annotation as follows:
Note that the classes will now be coupled with IConfigurable.
But if it’s your own interface, the coupling isn’t as onerous.
You can also use an existing annotation to the same effect.
Figure 12.4 shows the overall scheme used in the bridged participation pattern.
As shown in the figure, the aspect advises methods whose return type is marked with the @Sensitive annotation.
The bridging aspects use declare statements to attach the @Sensitive annotation to the existing types, thus making them participate in the collaboration offered by the aspect.
Annotation bridging has a few limitations when implemented in AspectJ.
In particular, there is no way for a bridge to transfer annotation property values.
Furthermore, there is no way to use annotation values in making decisions to supply annotations.
The aspects in the library often use the bridged participation pattern discussed in the previous section.
Instead of writing subaspects and pointcuts (which can be a daunting task for programmers not yet experienced with AOP), library users mark program elements with annotations to participate in the collaboration.
The Spring Framework, for example, uses a few annotations to simplify how library users participate in the provided functionality.
Figure 12.4 Bridged participation pattern, where the aspect advises join points based on the associated annotations just as in ADPP.
But instead of marking program elements with annotations, additional aspects attach annotations to those elements through declare statements.
The existence of design patterns—knowledge in a condensed form—reflects the maturity of programming methodologies and languages.
The patterns we introduced in this chapter are merely the beginning; and a lot more patterns are waiting to be discovered.
The worker object pattern helps simplify the creation and usage of worker objects.
You can use this pattern in implementing functionalities such as concurrency control schemes (discussed in the next chapter) and retrying a failed operation (discussed in chapter 14)
The wormhole lets you cut through a call-stack layer to make objects at a layer available to another layer without any help from the intermediate layers.
You can use this pattern to make decisions based on context from multiple layers (discussed in chapter 16)
When you encounter problems, knowing how to apply these patterns will help you solve them efficiently.
Instead of thinking about each problem afresh, you can determine whether one of the patterns will fit your situation.
Experiment with these patterns, gain an understanding of them, and think about places you may be able to apply them.
When you know these patterns, instead of being surprised by a problem, you’ll probably respond by saying, “Yes, I can use the <namethe-pattern> pattern.”
If the commonplace usage of multicore processors, the advent of specialized languages such as Erlang and Haskell, the heated discussions in developer communities, and the popularity of books on the subject are any indication, software systems are rapidly embracing ever-higher levels of concurrency.
Yet concurrency control remains a mysterious topic to many developers.
This can lead to poorly implemented systems with visual anomalies, mysterious crashes, compromised data integrity, and deadlocks—all embarrassingly common problems.
Instead of analyzing ad hoc implementations, you start with proven ways to address thread safety and liveliness problems.
A pattern, for example, can specify when and Implementing concurrency control.
Modularizing Swing’s single-thread rule how to obtain locks on an object to avoid deadlocks, provide maximum concurrency, and minimize overhead.
Of course, each pattern suits a particular kind of problem, and you must analyze your problem to choose the right pattern.
In this chapter, we’ll examine how AOP can provide a level of consistency that is seldom achieved in conventional implementations.
Specifically, we’ll discuss modularizing the implementation of two patterns: a Swing thread-safety pattern and the read-write lock pattern.
In chapter 11, we developed an AspectJ-based solution for catching violations of Swing’s single-thread rule and logging the context under which they occurred.
When you understand the violations, you can use conventional solutions to fix them.
But fixing the violations in a conventional way can be a daunting task that requires significant modifications in multiple modules.
Let’s develop a way to fix the problem by adding a couple of aspects to your system; no modifications to the core classes are required.
I discovered that pattern while trying to solve this problem in an application.
Later in this chapter, we’ll explore other ways you can use this pattern, such as executing time-consuming tasks in separate threads to improve the responsiveness of the user interface.
Now, let’s investigate the solution in more detail so you can modularize its implementation using aspects.
If you’re already familiar with the problem and solution, you can go directly to section 13.1.3
Swing requires that only the preassigned event-dispatching thread can access a UI component.
To allow other threads to access the component, Swing provides a mechanism to pass a request to the preassigned thread.
With either method, you pass a Runnable object whose run() method performs the intended operation.
The first limitation is easier to deal with—you can create a library of such classes and use it in your projects.
Missing a few such calls can lead to unexplainable UI problems.
Dynamically determining the callers’ thread ensures correct behavior if employed consistently, but those.
Let’s set up an example to understand the problem and see how AspectJ can help with it.
Later, you’ll use the same program to show how the conventional and AspectJ solutions work.
The last four UI accesses in this program are made from the main thread (which isn’t an event-dispatching thread)
To correct this situation, you need to route such calls through the event-dispatching thread.
Although you’re making these calls in the main thread, in real situations such calls typically occur from some other thread, such as a networking thread.
The call to set the value of a cell ultimately results in updating the table component.
This call can typically be invoked asynchronously—the caller doesn’t have to wait until the execution is carried out, because showing the new values doesn’t occur until the AWT thread repaints the table.
The call to display a message must be made synchronously—the caller must wait until the call has completed the execution, which means after the user has seen and responded to the message.
Listing 13.1 Test program showing incorrect usage of the UI update call.
These calls must also wait before returning to the caller.
Only after the method execution can you obtain and assign the return value.
The simple aspect in listing 13.2 monitors UI access calls and the thread executing them.
This aspect advises join points selected by the Swing.uiCall() pointcut to print the method signature and the caller thread.
When you compile and run the Main class with the logging aspect, you get output similar to the following:
The output shows that all the calls are made by the main thread.
The calls made after the call to setVisible() are in violation of the single-thread rule.
The correct usage requires them to be executed only in the event-dispatching thread.
Now that you have a simple program illustrating the problem, let’s see how to solve it using the conventional solution.
Before we discuss the AspectJ solution, let’s look at a conventional solution; this will help you see the complexity and crosscutting nature of such a solution.
You’ll also understand the behavior expected from an AspectJ-based solution; ultimately, you want both solutions to behave identically.
Listing 13.3 shows the modified Main class that implements the thread-safety rule using conventional techniques.
This is essentially the same approach you used in chapter 11, where you reported any calls not made in the eventdispatching thread.
The test code exercises components to be tested, whereas the aspect checks for adherence to the thread-safety rule.
For example, the test code calls methods such as updateStockQuote()
Any misrouted calls lead to a test failure due to the advice.
Although you could have used such a test in this chapter, the logging approach is easier to understand.
In listing 13.3, you route all the calls that access or update the UI components’ state by posting a request in EventQueue.
You wrap each method call made after making the frame visible in an anonymous Runnable class, also known as a routing class.
Although you use anonymous classes here, you could use named classes.
For calls that can be performed in a nonblocking manner, you use invokeLater(), whereas for calls that must block the caller, you use invokeAndWait()
Note the use of the final variables to comply with the Java rules that anonymous classes may access only the final variables from the outer method.
You could call all the methods after the frame is realized through a single worker object.
In section 13.1.4, I’ll show you how to deal with exceptions with the AspectJ-based solution (where the base solution and the exception-handling task are vastly simpler)
When you compile the previous class along with the logging aspect and run it, you get the following output:
As you can see, your hard work has paid off.
All the calls made after making the frame visible are called in the event-dispatching thread (note the thread ID printed in the log)
Let’s see if you can use AspectJ to get rid of this complexity.
SwingWorker Java 6 includes the SwingWorker class to simplify the conventional implementation of Swing concurrency control.
The solution in this section doesn’t use this class, to better mirror how you’ll use AspectJ, which doesn’t use or need the SwingWorker class.
You select calls to all the required methods, use the pattern to create a new Runnable object, and hand over the object to the event queue for execution.
Before releasing the object to the queue, you also check whether the caller thread is already the event-dispatching thread; in that case, you let the original method execute directly.
With the AspectJ-based solution, you’ll implement Swing’s single-thread rule without making any change to the Main class in listing 13.1
You’ll implement multiple versions of the solution, with each new solution building on the prior version.
In addition to making the final solution easy to understand, this step-by-step approach suggests a typical way you may want to develop an AspectJ-based solution that tackles new problems: start simple, and handle more issues as you progress.
Although you could implement one concrete aspect in each case, using an abstract aspect offers flexibility that can be important when you use the solutions in your system.
For instance, you can include the unaltered abstract aspect in your system and write a simple subaspect, similar to the ones shown here, to handle your system-specific requirements.
In section 13.1.4, we’ll examine the kinds of customization you may need.
With this arrangement, the caller is blocked until the eventdispatching thread executes the operation.
In practice, blocking the caller is often undesirable and should be limited to situations that warrant its usage.
But the implementation does provide a simple solution to ensure compliance with Swing’s singlethread rule.
Listing 13.4 shows the base abstract aspect that routes all join points selected by the uiCall() pointcut synchronously.
The concrete subaspects must provide a definition for this pointcut that selects all the calls to the Swing components.
The nonRoutedCall() pointcut selects join points selected by either the Swing.
The routedCall() pointcut combines the uiCall() pointcut with the negation of nonRoutedCall() to select the join points that needs to be routed through the eventdispatching thread.
The run() method calls proceed() to carry out the original operation.
The invokeAndWait() method makes the request and is blocked until the event-dispatching thread executes the run() method.
The event-dispatching thread eventually calls the run() method, resulting in the invocation of the original call, and then unblocks the caller thread.
The advice assigns the return value of the proceed() statement to the return value property of the worker object.
It later obtains this return value by calling the getReturnValue() method on the worker object.
For now, you’ll ignore the exceptions and revisit this issue in section 13.1.4
Now that you have the base aspect taking care of all the details, let’s create a subaspect.
Modularizing Swing’s single-thread rule reusable Swing aspect, defining the pointcut is an easy task.
This subaspect ensures adherence to Swing’s single-thread rule as long as all your UI components are based on Swing’s components and models.
If you have additional custom components that don’t use any of the standard Swing models as a base class, you need to write a subaspect similar to the one in listing 13.5 and define the pointcut corresponding to all the appropriate methods in your classes.
You may want to use the participant pattern (discussed in chapter 12) and write the subaspect as a nested aspect in the classes, which makes it easy to modify the pointcut when the implementation of the enclosing class changes.
Refer to chapter 6 for more details of aspect-precedence control.
Let’s continue to use the driver program from listing 13.1
When you compile all the classes and aspects and run the test program, you get output similar to this:
You can see from the output that all UI operations are executed in the event-dispatching thread.
The return values printed are correct, too—for both primitive and object return types.
This first version of the solution lets you adhere to the Swing’s single-thread rule, and you didn’t have to touch any of the core classes.
The central idea behind the second version is to detect the need to route a method synchronously or asynchronously based on its return type.
If the method is returning a non-void type, you must execute the method synchronously.
For all other operations, you assume that it’s fine to invoke those operations asynchronously.
You need to synchronously route the join points that return a value.
You need to asynchronously route join points that don’t return a value.
You advise the syncRoutedCalls() pointcut to route the join point synchronously.
Except for the pointcut used, the advice remains unchanged from the first version.
You add a new advice to route calls asynchronously for the join points that don’t return a value.
The advice body is similar to the synchronous routing advice.
You use Runnable instead of RunnableWithReturn to implement the worker object, because you don’t need to consider the return value.
The subaspect in listing 13.5 (which provides the definition for a pointcut corresponding to all UI operations) continues to work fine with this aspect.
When you compile all the classes and aspects and run the driver program, you get output similar to this:
The output shows that the call to setValueAt(), which was invoked synchronously using the earlier version of the solution, is now being invoked asynchronously.
This is what you expect, because it doesn’t return any value.
This isn’t the correct behavior; it needs to wait until the user has responded to the message dialog box before continuing.
If you ran the program yourself, you’d see that getRowCount() and getGridColor() are executed before you close the message dialog box.
As you can see, the modified solution, taking its cue from the return value type, addresses most needs but behaves incorrectly in certain cases.
The idea behind the third version is to let subaspects have explicit control over methods that require synchronous routing.
You’ll select such methods in a pointcut regardless of their return value type.
Listing 13.10 shows an aspect that explicitly specifies the methods that must be routed synchronously.
You add a new abstract pointcut, uiSyncCall(), to let subaspects define methods that they wish to route synchronously.
You must ensure that all methods selected by the uiSyncCall() pointcut—even those with the void return type—aren’t executed asynchronously.
You need to modify the subaspect to add a definition for uiSyncCall()
The aspect in listing 13.11 defines uiSyncCall() as selected by the same-named pointcut in the Swing aspect to select all the calls to any method in JOptionPane or its subclasses.
Listing 13.12 shows the modifications to the Swing aspect to include the uiSyncCall() pointcut.
You need to select the call join points because you’ll want to weave the call sites (your code) instead of the execution site (Swing code)
You can modify the pointcut definition to add other join points that you wish to run synchronously with the caller.
Notice the advantage of using a separate aspect to define pointcuts: most likely, such an aspect will become a part of your aspect library, so that any project can use these pointcuts effortlessly.
Listing 13.11 Subaspect that lists synchronous execution join points explicitly.
The output is nearly identical to that for the conventional solution.
The only difference is the additional log statement for monitoring synchronous versus asynchronous execution.
You now have a complete solution that implements Swing’s single-thread rule without requiring any modification to the core classes.
Applying this solution will guarantee compliance with the threading rule without the need to make system-wide modifications.
When you apply this aspect to real-world problems, you’re likely to need a few enhancements that we consider next.
Here, methods carry an appropriate annotation and pointcuts select methods based on the annotations they carry.
But for Swing, this won’t work well, because the Swing code (as well as your custom components) must be modified to attach such annotations.
Any missed annotations in either case will lead to incorrect routing.
Therefore, it’s best to study the API to define the needed pointcuts.
For the more general case, the annotation-based approach often works better.
In this section, we’ll discuss a few enhancements to the previous solution, such as handling exceptions and optimizing the solution using system-specific knowledge.
Exception handling poses an interesting challenge when the exceptions are thrown by asynchronously routed calls.
For such calls, because the caller isn’t going to wait for the execution to be complete, it doesn’t have access to the exceptions thrown.
Further, exceptions are thrown in the control flow of the event-dispatching thread and not the caller thread.
A reasonable strategy to deal with these exceptions is to set a listener that will be notified if the operation fails.
All you need to do is surround the proceed() statement with a try/catch block, as shown in the following snippet.
In the catch block, you can perform any operations necessary to match your exception-handling policy (such as logging it or passing it to an exception listener)
You can also rethrow the exception after wrapping the caught exception in a runtime exception:
Notice how easy it was to modify the exception-handling strategy.
If you weren’t using AOP, and you employed anonymous classes, you’d have to modify every method that routed the call asynchronously.
If you used named classes to carry out the operations, you’d have to modify each of those classes.
With such widespread modifications, ensuring consistent implementation becomes a daunting task.
Using a conventional solution, it’s possible to implement the expected behavior the first time—with a lot of labor and diligence.
With AspectJ, making changes in the exception-handling strategy is easy.
For example, if you decide to log an exception in addition to passing it to an exception listener, all you need to change is the aspect and nothing else.
This way, the clients need not be aware of the routing and issues related to it.
In the solution so far, you’ve selected all the calls to the UI methods.
But if the overhead is a problem for your system, you can use the typical technique of limiting join points selected by a pointcut to certain packages.
You can also use your own aspect to route a group of calls as a batch.
For example, you may want to update multiple components in response to a network event.
To implement such behavior, you need to create a method (perhaps following the Extract Method refactoring) that makes the calls to be routed as a batch.
Then, you select that method with either the uiCall() or the uiSyncCall() pointcut.
If you use these kinds of optimizations, I strongly recommend that you also use the policy-enforcement aspect developed in chapter 11, which detects the violations of Swing’s single-thread rule during the development and testing phases.
This way, wrong assumptions, if any, will be caught early on.
Let’s discuss another usage of the worker object pattern to improve the responsiveness of UI applications.
Although we’ve focused on the use of the worker object pattern to ensure thread safety, you can use a small variation on the same theme to improve the responsiveness of UI applications.
For example, a common need in UI applications is to avoid locking the GUI when performing a time-consuming task.
Let’s say you want to implement a time-consuming task, such as sending an email.
You don’t want to lock up the UI while the email is being sent.
Improving the responsiveness of UI applications package ajia.main; import ...
Compile and run this program, and click the Send Emails button.
The reason is that sendEmails() is executed in the event-dispatching thread, preventing it from refreshing the GUI.
Locking up the GUI in this way is undesirable, and yet you’ll see it happen frequently.
The reason, I suspect, is the invasiveness associated with implementing a solution that performs operations in the background.
Implementing the asynchronous execution of a thread is simple when you use AspectJ.
All you need to do is use the reusable aspect shown in listing 13.10 and provide concrete subaspects of it.
Let’s enhance it to show how you can avoid locking the GUI by asynchronously routing invocations of time-consuming operations.
The reusable implementation in listing 13.14 enables the subaspect to improve responsiveness by providing the definition for a pointcut.
The aspect in listing 13.14 dispatches the operation selected by the asyncOperation() pointcut.
The setExecutor() method lets you plug in an appropriate executor following the classic strategy design pattern.
If you’re using this aspect in a container that supports dependency injection, you can easily externalize the configuration of this aspect.
Let’s apply the annotation-driven participant pattern (ADPP) discussed in chapter 12 to implement a subaspect.
In a given project and with a given team composition, making an appropriate choice is often easy.
The only thing left to do is to mark the sendEmails() method with the @Slow annotation.
When you click the Send Emails button, the GUI won’t lock.
You’ll also see that each call is routed through a separate thread asynchronously (the following output produced after clicking the button three times and then waiting about 20 seconds):
In the next section, as a sample of modularizing classic thread-safety patterns using AspectJ, we’ll examine the read-write lock pattern.
The read-write lock pattern offers maximal liveliness while ensuring the integrity of objects.
It’s an appropriate pattern in situations where you expect the reader threads to access the object more frequently than the writer threads, and the operations are expensive (to justify the use of acquiring and releasing locks)
The fundamental idea is that any number of readers can simultaneously read the state of the object as long as no thread is modifying the state at the same time.
Implementing this pattern in a conventional way requires adding certain code to each method that reads or modifies the state of an object.
We’ll introduce a reusable aspect that enables you to implement this pattern with your classes just by adding a simple subaspect.
Consider an implementation of the InventoryService interface from appendix A that uses a grid-based cache (implemented as the Map interface) to avoid round trips.
Because inventory is queried more frequently than it’s modified, and because access to the grid-based map is expensive, using the read-write lock pattern for such an implementation is appropriate.
The read-write lock pattern uses a pair of locks: the read lock and the write lock.
Multiple threads can simultaneously acquire the read lock as long as the write lock hasn’t been acquired.
Only one thread, on the other hand, can acquire the write lock at any moment as long as no read locks have been acquired.
Each operation in the class that needs this pattern must acquire and release the read lock for readonly operations and the write lock for state-altering operations.
When the operation is over, it must release the lock that it acquired.
In contrast, because the other methods modify the state of the object, you take and release the write lock.
The use of try/finally ensures that the locks are released even when the operation aborts due to an exception.
You must similarly modify each class that needs this pattern.
Any missed methods will result in potentially fatal program behavior.
Further, you must make sure that a method that takes a read lock releases only the read lock and not a write lock, and vice versa.
The core concept behind the AspectJ-based solution is to create an aspect that encapsulates this pattern.
You can then avoid the need to modify each class.
Further, because the pattern is reusable, you want the aspect to be reusable as well.
To achieve this goal, let’s write a base aspect that implements the read-write lock pattern.
Listing 13.18 shows the implementation of the pattern in an abstract aspect.
Using the perthis() association, you associate a new aspect instance with each this object that matches the readOperation() or writeOperation() pointcut.
This arrangement lets you effectively introduce the lock object in each read-write lock managed class without knowing about the specific type of the object.
The concrete subaspects should implement the abstract readOperation() pointcut to select methods that don’t modify the state of the object.
Similarly, the abstract writeOperation() pointcut should select methods that modify the state of the object.
Because a separate aspect instance is created for each this object at the matched join point, effectively a separate lock object gets associated with each advised object.
The around advice to the readOperation() pointcut locks and releases the read lock.
Similarly, the around advice to the writeOperation() pointcut locks and releases the write lock.
Now you have a base aspect ready to be extended by subaspects.
To enable the read-write lock pattern, you need to create one or more subaspects, which will make the appropriate classes participate in the base aspect’s functionality.
Because the subaspects need to select read and write operations, using annotations to simplify the selection is a good idea.
Let’s pursue this by creating the annotation shown in listing 13.19 that can mark a method as a read operation.
Although you could create an annotation to mark a write operation, you can also infer the same from the lack of @ReadOnly.
ReadOnly is an annotation that describes an objective characteristic and as such says nothing about the locking mechanism.
Note the use of @Inherited to apply the annotation to subclasses.
Finally, you’re ready to write the subaspect based on these annotations.
Listing 13.21 shows an annotation-driven subaspect to apply the read-write lock pattern.
Although you could explicitly use the !static qualifier to exclude static methods (because they shouldn’t be applied with a locking scheme), because the base aspect uses the perthis() association, it excludes any static methods making the use of !static redundant.
Listing 13.20 Annotation to mark a class suitable for the read-write lock pattern.
The readOperation() pointcut selects the execution of methods marked with @ReadOnly in a read-write lock managed type.
The writeOperation() pointcut selects methods not selected by the readOperation() pointcut.
Selecting the write operations using the negation of readOperation() is a defensive approach; it’s better to err on the side of safety by declaring that all the methods that aren’t read-only operations are state-altering operations.
Compared to listing 13.17, you removed the embedded read-write lock-management code and added annotations to denote the read-write lock managed class and readonly operations.
Unlike marking methods with @ReadOnly (which represents an intrinsic characteristic of those methods), classes suggesting a participation in the read-write lock pattern may not be desirable if the same.
Summary class is to be used in multiple systems with varying concurrency characteristics and needs (as well as the injected grid-based map’s implementation)
Instead of marking the class with the annotation, you use the aspect in listing 13.23 to supply a set of classes with the needed annotation.
If you want to provide thread-safe access to other classes, you can modify the declaration or add additional aspects to supply the annotations for those classes.
You may, for example, use a type pattern to declare a set of classes as participants in the read-write lock concurrency control.
You now have a reusable implementation for a reusable pattern.
You can make these aspects a part of your library and avoid reinventing the wheel each time.
By doing so, you’ll be assured that the pattern is being implemented correctly and consistently.
The conventional solutions make it even more so by requiring system-wide invasive changes.
The conceptual reusability of the few thread-safety patterns is lost in the conventional implementations.
Swing’s single-thread rule is simple for component developers but often requires system-wide changes if you’re using those components in multithreaded UI applications.
The solution we’ve presented eliminates the need for invasive changes while ensuring consistent behavior.
By employing reusable aspects, you make adhering to Swing’s thread-safety rule as easy as extending that aspect and providing a few pointcut definitions.
With AspectJ, you have a simple model for thread safety that doesn’t burden you with complex usage.
Similarly, by introducing a reusable aspect encapsulating the read-write lock pattern, implementing this feature of thread safety is as easy as adding a few simple aspects and marking program elements with annotations.
You no longer have to hit the books every time you need to understand exactly how the pattern is supposed to work.
Instead, you need to know which methods access the state in a read-only manner and which ones alter the state.
You can extend the ideas presented in this chapter to offer interesting solutions to otherwise laborious work.
For example, you can extend aspects from the Swing UI.
You can then ensure that only a preassigned thread is able to access objects of those classes and that other threads route the calls through the preassigned thread using an aspect.
The power of AOP and the patterns should be clear to you by now.
In the following chapters, you’ll use these patterns to solve other complex crosscutting concerns using AOP.
What would happen if the operation failed after you added an item to the cart but before it was removed from the inventory? The system would be in an inconsistent state, with the same item counted as being in the shopping cart and in the inventory.
To prevent this undesirable situation, you need to execute both operations in a transaction.
A transaction defines a unit of work that ensures that the system remains in a consistent state before and after its execution.
If any operations within a transaction fail, then all of them fail, leaving the system as it was before the transaction started.
Transaction management has four properties: atomicity, consistency, isolation, and durability (ACID)
Transaction management is perhaps the most widely known crosscutting concern in enterprise applications.
Most enterprise applications use persistent storage or a messaging system that leads to the need for the transaction management.
Traditional implementations of this crosscutting functionality require embedding the transaction management code in many methods.
Owing to its crosscutting nature, AOP offers a compelling and elegant solution to implement this functionality.
In this chapter, we’ll examine how AOP helps to modularize transaction management.
You’ll implement an aspect usable with either Spring’s proxy-based or AspectJ’s byte-code-based AOP.
This will provide you a template to implement transaction-like functionality.
Furthermore, you’ll implement an AOP solution to retry failed transactions automatically.
Let’s begin by examining how transaction management is implemented with conventional and AOP techniques.
The core idea behind transaction management is simple: start a transaction at the beginning of a unit of work, perform the work, and commit or roll back the transaction.
Typically, you commit if no exceptions are thrown during the work.
If an exception is thrown, you typically roll back the transaction.
Transaction attributes specify properties of the transaction about to be started.
The common properties include propagation, isolation, read-onlyness, timeout, and rollback behavior for exceptions.
The propagation attribute governs whether the transaction manager should start a new transaction or continue to use the ongoing one, if any.
Upon successful completion of the operation, the method asks the transaction manager to commit the transaction.
Depending on the transaction status, the transaction manager may or may not commit the transaction to the underlying resource.
For example, if the status indicates that it isn’t a new transaction, no commit takes place at the current level, leaving the decision to the outer transactional method.
Upon throwing an exception, depending on the exception type, the transaction manager is asked to commit or roll back.
Similar to D, the transaction manager may or may not commit or roll back the transaction yet.
The transactional method must use the resources associated with the current transaction throughout its control-flow.
For example, if a business operation uses a JDBC connection, it must use the same connection during the entire transaction.
Specifically, it must not create a new connection for individual nested operations.
In a typical implementation, the transaction manager binds the resources associated with a transaction to a thread-local.
The business operations access the thread-local when they need a resource.
Of course, a good API hides the use of a thread-local, removing some burden from you.
As you can see, a conventional implementation of transaction management causes code tangling and code scattering.
With the AOP implementation, aspects take care of transaction management.
This allows business modules to focus on their core functionality:
Notice how closely the around advice resembles a transactional method in a conventional implementation, with the proceed() call replacing the business logic.
Transaction management involves many players that must do a delicate dance to get the desired effect.
The UI layer builds on top of the service layer, which in turn uses the repository layer.
The repository uses transactional resources such as a JDBC data source, JPA entity manager, Hibernate session, or JMS session.
Typically, the service operations represent use cases that should be atomic.
Upon starting a transaction, the manager binds the transactional resources to the current thread.
The repository layer must use the bound resources throughout the transaction.
Although demarcating transactions at the service layer is common today, it isn’t the only possibility.
In an alternative design, domain objects may demarcate the transaction boundaries.
A transaction manager provides a way to start a new transaction and commit or roll back the current transaction.
But each transactional resource provides a different way to perform these basic operations.
For example, a JDBC connection doesn’t have an explicit way to begin a transaction and provides the commit() and rollback() methods on the Connection type.
On the other hand, Hibernate requires calling beginTransaction() on the Session object and provides commit() or rollback() on the returned Transaction object.
Similarly, other persistence technologies such as JPA and messaging technologies such as JMS have their own API for transaction management.
But it targets distributed transaction management and requires you to use a transaction manager typically available in an application server.
All of these implementations are different, with no unifying API.
Therefore, if you switch from one technology to another, you need to rewrite a good portion of code.
Spring provides one such abstraction with a simple interface and implementations for most commonly used technologies.
The implementation of the getTransaction() method obtains a transaction based on the transaction definition (propagation, read-onlyness, isolation, and timeout) provided.
By default, the implementation associates the current transaction with the current thread.
The returned object contains information about the transaction that must be passed to the commit() or rollback() method.
The return object can also be used to mark the transaction as rollback only.
In the next section, you’ll use this abstraction through aspects.
To implement transaction management, you can use Spring’s proxy-based or AspectJ’s byte-code based AOP.
Because the service layer encapsulates business functionality, service objects provide a good place to mark transaction boundaries.
Furthermore, because service objects are often Spring beans, the proxy-based choice fits the bill well.
Figure 14.2 Structure of transaction management implemented in a proxybased AOP framework.
Let’s examine the roles played by the various objects in the figure:
The proxy includes a transactional aspect, whose pointcut selects the transactional methods.
The advice uses the transaction manager to start and stop a transaction.
For example, the transaction manager for a JDBC data source may call the commit() or rollback() method on a Connection object.
The repository uses the same transactional resources as those driven by the transaction manager.
To satisfy the requirement that the same transactional resources must be used throughout a transaction, a transactional resource is often wrapped in a proxy.
The proxy, upon requesting a new resource, looks up a thread-local to check if there is already a resource bound to the current transaction, and returns it.
Otherwise, it creates a new resource and binds it to the thread-local.
Although convenient, proxy-based AOP does have some limitations, as discussed in chapter 9:
If these limitations don’t suit your applications, you need to resort to byte-code weaving.
Consider a situation where you need to apply transactional boundaries to domain entities (we’ll examine cases where applying transaction boundaries at the domain-object level makes sense in chapter 16)
In such a case, because domain entities usually aren’t Spring beans, you need an approach that avoids the use of proxies.
You still have the same collaboration between the aspect and a transaction manager.
If you use the @AspectJ syntax, which is supported in both Spring’s proxy-based AOP and AspectJ’s byte code based AOP, you can even reuse the same aspects for both kinds of weaving without any changes.
Summarizing, although proxy-based AOP can be sufficient in a majority of cases, you need AspectJ-based AOP in other cases.
Let’s write aspects in both styles to understand the nuances of the solution.
Although Spring offers a complete solution, one of the goals of this book is to enable you to write your own aspects and not merely learn how to use existing ones.
First, it will provide an example to follow if you have a crosscutting concern that matches closely to transaction management.
Second, if you aren’t using Spring, you may have an easier time creating your own aspect by following this example.
The “from scratch” part will be restricted to aspects only, because that is the focus of the book.
For other parts, you’ll use ready-made ingredients available in Spring.
The first two may vary depending on factors such as the possibility of changing the existing code (to add, say, annotations) and personal preference (such as XML versus annotations)
Whichever style you use, the advice needs to perform the same task of starting and stopping transactions.
Therefore, you write an abstract aspect, deferring the choice of defining the pointcut and obtaining transactional attributes to its subaspects.
Of course, you can weave the aspect using the AspectJ weaver, if desired.
Interested only in using Spring’s transaction management? If you’re only interested in how to use Spring’s transaction management and not in how to implement a similar support yourself, you may skip this section.
The abstract transactionalOp() pointcut defers the selection of transactional operations to subaspects, which may use any criteria such as a naming pattern or annotations.
Such a method is commonly implemented using an external map (typically defined in XML) or the annotation attributes.
The around advice mimics the code from the conventional implementation.
You start a transaction and then proceed with the business logic by invoking pjp.
If no exception is thrown, the advice commits the transaction.
If the business logic throws an exception, it commits or rolls back the transaction based on the thrown exception and the transaction attribute.
In case of an exception, the advice also rethrows the caught exception so that the caller receives the original exception.
The aspect declares that it has a dependency on a transaction manager.
Let’s define a concrete subaspect, as shown in listing 14.3, that selects transactional operations based on the annotations.
It then creates a transactional attribute based on those annotations.
This allows type-level annotation to declare attributes common to all the methods, but still allows individual methods to override certain attributes.
But does this aspect work? Like all good developers, you’ll check it using a test.
Later, you’ll also see it in action using the JPA-based example in appendix A.
To write good tests, let’s examine what can go wrong with the implementation.
Test that the aspect starts and commits or rolls back the transactions correctly at the methods marked with the @Transactional annotation.
You should ensure that the aspect doesn’t apply its logic to non-transactional methods.
For example, if the business method throws IOException, then the application of the aspect shouldn’t alter that exception in any way.
Although it’s crucial that the annotation attribute be passed to the transaction manager correctly, you have that code in a separate class and should unit-test that code separately.
Compile this test along with the aspect and related code using the AspectJ compiler (you can use the Java compiler followed by the binary or load-time weaver, as discussed in chapter 8)
Running this test shows you a green bar! You can modify the test to verify its correctness when using Spring AOP as well.
Although the test in the previous section illustrated that the basic aspect works fine, you’ll take it for a road test with a real application in appendix A.
First, you’ll write code common to both AspectJ and Spring AOP.
Let’s start with a driver, as shown in listing 14.5, so that you can see this aspect in action.
Let’s write an aspect (listing 14.6) to trace interactions with the transaction manager.
You’ll also use a variation of TraceAspect you developed in chapter 10 to trace domain, service, and repository method executions (The downloadable sources contain this aspect)
You’ll trace interaction with the transaction manager and the transactional resources (in this case, JPA EntityManager) used during a transaction.
The trace aspect uses library aspects that define pointcuts for the transaction manager (see listing 14.7), JPA, and the Object class.
At the start of a transaction, the advice logs the read-only property of the transaction definition as well as the status of the started transaction that indicates if this is a new transaction.
For the EntityManager, the advice logs the operation carried out and the identity of the entity manager so that you can check whether the same entity manager is used during a transaction.
You can specify a type-level annotation to execute public methods in that type in a transaction.
The annotation attributes (such as readOnly, propagation, and isolation) specified at the type level automatically apply to each public method.
If you need to override an attribute for a specific method, you can specify an annotation at the method level as well.
Any public method without the @Transactional annotation automatically uses the annotations specified at the type level.
You now have code common to AspectJ byte-code weaving and Spring’s proxy-based AOP.
You do that through the snippet in listing 14.9 (which you can add to any XML file in the META-INF/spring directory on the classpath)
When you run this code, you get the following log output:
Notice how the transactions start with the correct read-only properties.
For example, when the transaction for the finder operations begins, the transaction is read-only, whereas for addProduct(), the transaction isn’t read-only.
Finally, notice that the same entity manager is used during a transaction.
The entity manager with Proxy in its type name is a proxy around the real entity manager; it ensures that the business operation uses the same entity manager throughout the transaction, following the scheme shown in figure 14.2
You can use Spring’s proxy-based AOP to get the same effect.
Compared to listing 14.9, you no longer use the factory-method attribute, because the aspect is a Spring bean.
When you run the same driver, you get the following output:
First, notice the glaring difference of Proxy (such as in the first line) in the type name where you would expect a service implementation.
Because Spring’s proxy-based AOP is in play, and the service objects contain transactional methods, AOP proxies wrap the original service beans.
This is due to the self-call limitation of the proxy-based approach, discussed in section 9.2.5
Now that you have a good idea of the AOP implementation of transaction management, we’ll examine how prebuilt aspects provided as a part of Spring can simplify this functionality.
Although the solution uses AOP, it hides most of the AOP-related details using the namespace-based configuration.
Using your own annotations In your service classes, you use the @Transactional annotation to mark the transactional types and methods.
But you should be able to utilize any other means to select the required join points.
For example, you can use the @Service annotation to select, say, all public methods of the service layer as transactional.
Furthermore, if you use the Model-Driven Architecture (MDA), you can use UML stereotypes that map to Java annotations.
Spring offers both types of weaving discussed in section 14.3: proxy-based and AspectJ-based.
The proxy-based choice restricts demarcating transaction boundaries to Spring-managed beans, whereas the AspectJ-based choice allows the same demarcation at any object, including Spring beans.
The focus of this section is on a general understanding of Spring’s support for transaction management and how a good aspect library takes the burden off you.
With the XML-driven approach, AspectJ pointcuts specified in XML select the transactional methods.
Additional XML elements provide attributes such as propagation and read-onlyness.
Listing 14.11 shows the XML configuration needed to add transaction management to the service layer.
The other embedded <aop:advisor> element specifies a pointcut reference (it could also specify a pointcut expression using the pointcut attribute) and a reference to an advisor defined in C.
The <tx:advice> element specifies the attributes for the transactional methods.
The embedded <tx:attributes> elements specify a regular expression for the name attribute.
The other attributes specify transactional properties such as propagation, isolation, and read-onlyness for the selected methods.
To control rollback behavior when an advised method throws an exception, you can use the rollback-for and no-rollback-for properties, specifying a list of exceptions.
When you run the system with the classes in appendix A, you get the following output.
Note that when using the XML-based style, you need not add any Transactional annotation to your Java code:
You also see that transaction management with nested operations works as expected.
XML-based transaction management lets you implement the transaction functionality without modifying Java code.
For example, if you rename a method, you must check <tx:attributes> to ensure that the specified regular expression continues to select the correct methods.
The fundamental role played by the XML configuration is to select transactional methods and supply transactional properties for those methods.
An alternative to the XML-based configuration moves these roles from XML to Java annotations.
With the Java code specifying all the details, you no longer need to specify the pointcut and transactional attributes.
Furthermore, the attributes in the annotations specify the transactional properties.
The element can use the optional transactionManager attribute to specify the name of the transaction manager bean.
If you execute the driver, you’ll see identical output compared to the XML-driven version in the previous section.
For this scheme to work, you must use the AspectJ weaver in one of the forms described in chapter 8 (build-time or load-time weaver, including the Spring-driven load-time weaver)
If you execute the main driver with the AspectJ weaver, you get the following output:
The most interesting change in the output compared to proxy-based transaction management is the lack of trace output with type names such as Proxy20 for service beans.
With AspectJ-based weaving, Spring doesn’t need to create AOP proxies.
Transactional operations are inherently idempotent—if a transactional operation fails, it leaves no change in the system state.
Consequently, you can retry transactional operations to implement fault tolerance.
In this section, you’ll implement an aspect to retry transactional operations.
Later, you’ll improve the solution to consider practical realities that require adjustments to the assumption of transactional operations being idempotent.
In this section, you’ll also see some interesting use of aspects for integration testing.
To simplify code, provide flexibility, and allow better testing, you create a base aspect to encapsulate the essence of the retry crosscutting logic.
The base aspect shown in listing 14.13 avoids most of the tough decisions through the use of an abstract pointcut and the strategy design pattern.
The base aspect also makes the aspect reusable beyond transactional operations, such as network operations.
The strategy design pattern lets you use a DI container to configure the retry policy.
Note that the aspect uses RetryTemplate and related types from the Spring Batch project (see http://static.springframework.org/ spring-batch for more details)
The aspect specifies an abstract pointcut to let subaspects select operations to retry.
The advice passes the worker object to the retry template.
Based on how the retry template is configured, the retry template calls the doWithRetry() method multiple times, each time executing the join point.
Listing 14.13 Base aspect to introduce fault tolerance through retries.
The retry template itself may be configured to decide several factors such as which exceptions should be retried, how many times, and how much delay there should be between the successive retries.
The most important question is, which operations should be retried? Let’s write a subaspect that answers it.
You can extend the base aspect to provide a definition for the pointcut in a variety of ways.
For example, you can use the participant pattern (discussed in chapter 12) to add an aspect per class whose method needs to be retried.
But keeping the focus on transaction management, let’s use the annotation-driven participant pattern (ADPP) to enable retry logic for the transactional operations.
When working with JPA resources, you need to consider certain characteristics as you design the retry logic.
These considerations stem from the fact that JPA exceptions aren’t recoverable.
When a JPA operation throws an exception, all bets are off, and the entity manager must be discarded.
In addition, each new transaction must be associated with a fresh entity manager.
This is a common practice in many enterprise applications already, so you just need to ensure its adherence.
Specifically, you need to watch out for the use of an Open Session in View (or its JPA equivalent—Open Entity Manager in View) filter or other ways to keep the entity manager open longer than the transactions.
You can check for this through an enforcement aspect (as discussed in chapter 11) to be extra sure.
You should not retry failures in inner transactional operations (that is, the ones that are in the control flow of an ongoing transaction)
Even if an inner operation succeeds after a few retries, the outer operation is still destined for an unrecoverable failure (the transaction is marked for rollback-only in case of an exception), wasting any effort spent in retrying the inner operation.
You can satisfy this requirement by using the common idiom of selecting top-level join points, as discussed in section 3.6.2
Let’s use this information to write a subaspect, as shown in listing 14.14
You define a private pointcut to select top-level transactional operations through the use of the cflowbelow() pointcut.
Then, you define the retryOperation() pointcut (which is the abstract pointcut in the base aspect) with this pointcut.
The main configuration option is to select the exceptions to be retried, because you should retry only failures that have some chance of succeeding on a reattempt.
For example, if the failure is due to insufficient inventory, there is no point in retrying operations within a few milliseconds.
On the other hand, concurrency failure exceptions have a better chance of success upon retry.1 Similarly, failures due to network errors are worth retrying if you’re dealing with distributed objects.
Listing 14.15 shows a Spring configuration that sets the retry policy.
See POJOs in Action by Chris Richardson (Manning, 2006) for an example that handles the specific case of concurrent modification failures.
Let’s examine this configuration at a high level (the details are beyond the scope of this book)
Now, you see DI in full force! The retryTemplate bean is injected with a retry policy that uses a map to decide which exception should be retried and how many times.
Although you don’t use it in this configuration, you can specify a back-off strategy to introduce delays between the successive retries.
Such a strategy would come in handy when retrying network failures.
You need to control precedence between transaction management and the retry aspect.
Alternatively, if you’re using LTW, you can use aop.xml to have the same effect with the following element:
Testing for fault tolerance entails exercising normal test cases, but you need to check that they succeed even when the underlying implementation throws certain exceptions a limited number of times.
To do so, you can use a nifty aspect that avoids all the duplication that would otherwise be required for such testing.
Listing 14.16 shows the test for the InventoryService interface, which uses an aspect that throws faults during testing.
You create a subclass of your test but include no additional tests because you need to run the same tests with injected faults.
The aspect is declared with the percflow() association to attach a fresh aspect instance for each test execution.
This way, you can keep track of the number of faults you threw in a test.
Note that as discussed in section 6.2.3, the use of percflow() causes an implicit restriction on advice matching, selecting only join points in the control flow of faultTest()
This is exactly what you want: to inject faults only if the initiator of the flow is your test.
With this arrangement, if you execute the base test class, you’ll see no fault injection.
Effectively, you have two set of tests: one for the base tests by themselves and another for the fault-injected tests.
The advice to the faultSite() pointcut throws an exception if the fault count hasn’t exceeded the max count.
Because the aspect uses the percflow association, its state—specifically the faultCount instance variable—is associated with the control flow for each test.
When a new test starts, the faultCount is set to zero.
With AOP helping along the way, you can write surprisingly little code to introduce fault tolerance and even less code to test it.
Let’s complete this chapter by briefly discussing a few improvements to the faulttolerance aspect.
First, we’ll examine the use of nontransactional resources such as email notifications, which can challenge the idempotent characteristic of a transactional operation.
Next, we’ll discuss how you can use Spring AOP to apply the retry aspects.
Consider an order-placement operation that sends emails to customers, acknowledging orders.
If you retry this operation without special care, you’ll end up sending extra emails—one per retry.
Note that this problem exists even when you don’t intend to retry the transaction.
Even in the first attempt, you need to ensure that you perform the nontransactional work only if the ongoing transaction succeeds.
If the operations are such that executing them out of order or delaying them is allowed (such as in case of email), aspects can help to improve the situation.
You can take care of such operations by accumulating the work and executing it at the time of transaction commit.
If a rollback comes along instead, you empty the accumulated work without executing it.
Using Jexin to inject faults You can use the Jexin open source project (http://jexin.sourceforge.net), which uses AspectJ to inject exceptions to simulate faults.
The aspect uses percflow() to associate a separate instance of the aspect per transactional operation’s control flow.
Then, the advice creates a worker object and puts it in a queue.
Because the aspect uses the percflow association, it’s a candidate for garbage collection after the transaction is complete.
Therefore, you don’t need to worry about explicitly clearing the accumulated work.
Note that you aren’t implementing a two-phase commit approach here.
For example, if the main transaction succeeds, there is a chance that the nontransactional work you accumulated may fail.
You need to be ready for such a possibility—for example, you may retry those failures as well.
In general, it’s best to limit nontransactional work to noncritical activities such as sending email notifications.
You used AspectJ weaving that allowed you to focus more on the high-level problem.
But you can use all the ideas and most of the code with Spring’s proxy-based AOP.
Let’s see how you can adjust the code to make it work.
Use the Ordered interface or the @Order annotation to control precedence between transaction management and the retry aspect.
Replace the use of call() with execution(), and ensure that the join points selected correspond to Spring beans.
Note that you can use execution() even with AspectJ byte-code weaving.
But if the corresponding method belongs to a third-party jar, it forces the use of LTW or binary weaving of those jars.
For the fault-injection aspect, you can’t use the percflow aspect association.
Now, you can choose to use Spring AOP without losing much functionality.
Transaction management is one of the most common crosscutting concerns found in enterprise applications.
You can configure these aspects in your applications and check off one task in your project with little effort.
You can use either the proxy-based or byte code-based AOP with Spring’s.
Furthermore, you can use XML to specify transaction boundaries and associated attributes or use annotations.
These patterns should come in handy when you begin implementing your own aspects.
We showed how advanced language features and design patterns help in simplifying implementations of this complex concern.
We also used this functionality to show interesting ways you can use aspects to inject faults and avoid rewriting tests.
In the next chapter, we’ll examine another common crosscutting concern: security.
Much like transaction management, it lends itself to creating aspect libraries.
It isn’t a surprise that most enterprises spend substantial time, energy, and money to secure applications.
Security consists of many components such as authentication, authorization, auditing, protection against web site attacks, and cryptography.
In chapter 10, we discussed auditing that you can target for various purposes including security.
Implementing security using conventional programming techniques requires you to modify multiple modules to add authentication and authorization code.
For instance, to implement access control in an e-commerce system, you must invoke security code from methods of inventory control and procurement modules.
Security is an important consideration in modern, highly connected software systems.
Most applications need to expose functionality through multiple interfaces to allow access to the business data and make complex integration possible.
In this chapter, we’ll show how Spring Security (formerly known as Acegi) along with AOP can simplify the implementation of the classic crosscutting concern of securing your application.
Although we’ll use a specific security implementation (Spring Security), given the abstract nature of the API, you should be able to use the solution with other APIs just as well.
As in the previous chapter, we’ll start with an overview of the problem and follow it with a quick introduction to the underlying implementation (Spring Security)
The need to secure applications is common, and there are many ways to do so.
Modern APIs such as Java Authentication and Authorization Service (JAAS) and Spring Security provide a layer of abstraction over the underlying mechanism and let you separate the configuration from the code.
The overall goal of these APIs is to reduce complexity and provide agile implementations.
Yet such APIs offer only a part of the solution, leaving you with the task of calling these APIs from many places in the code.
We can classify the conventional solutions in two categories: the do-it-yourself approach, where you explicitly invoke security APIs in appropriate places; and the framework-based approach, where the application framework provides support for common security use cases.
In the simplest implementation, the classes implementing the business functionality directly call the authentication and authorization methods.
For example, business methods that require an access check directly invoke the security system APIs, as shown in the following snippet:
Security attributes specify the privileges needed to execute the business operations.
For example, they may specify that the user must be in the admin role.
The access manager decides whether the user accessing the method has sufficient privileges.
If the user doesn’t have sufficient privileges, the checkPermission() method throws an exception.
Frameworks often target a specific class of applications and can take advantage of the nature of the applications to offer simplified security solutions.
Let’s see how two common frameworks do this: servlets and EJBs.
Of course, a framework may use AOP as the underlying mechanism as is done in Spring Security.
We will discuss such an approach in the sections that follow.
The Servlet specification defines authentication functionality so that applications don’t have to deal with it.
It also offers a simple role-based authorization to protect URLs.
As we discussed in chapter 1, servlet filters implement the chain of responsibility design pattern.
Authorization is one of the responsibilities that a filter can implement.
Such a filter can enforce the access rules based on the URL.
For example, it may require that the user possesses the admin role to access URLs starting with /admin.
As we’ll discuss in section 15.2, Spring Security uses servlet filters to implement URL-level security.
Although it’s simple to protect resources based on URLs, a filter-based implementation can’t go much beyond that.
The EJB framework handles authorization by separating the security attributes into the deployment descriptor or annotations, where you specify the required roles for methods in the EJBs.
But you may face situations that require a custom solution for authentication and authorization.
Consider, for example, data-driven authorization, where an authorization check considers not only the identity of the user and the functionality accessed but also the data involved.
Current EJB frameworks don’t offer a good solution to problems that demand this type of flexibility, leaving you to implement the do-it-yourself approach.
Given the crosscutting nature of security, it shouldn’t come as a surprise that AOP offers a simplified and flexible solution.
The interesting piece of code is the computation of the security attributes.
In the doit-yourself approach, each method creates a separate security attribute object.
In an AOP solution, the same advice applies to all advised join points, yet each join point may require a different attribute.
Therefore, the advice may need some cooperation from the advised code or some external configuration to compute a correct attribute at each join point.
One way to achieve this collaboration is to use annotations, as you’ll see when you implement a complete aspect in section 15.4.2
You can apply security aspects using either the proxy-based or byte-code based AOP.
The considerations behind choosing the appropriate AOP system are identical to those discussed in section 14.3
As you’ve seen in previous chapters, the AOP solution relies on an appropriate implementation of the underlying infrastructure.
The security aspect acts as a controller that mediates between the core system and the security subsystem.
Let’s do a quick overview of Spring Security, which you’ll use in the subsequent sections to implement your aspects.
Security requirements vary widely, and many implementations exist to meet these needs.
For example, an authentication requirement may vary from simple web-based authentication to a single sign-on solution.
Storage for credentials (such as passwords) and authorities (typically roles such as ADMIN or USER) varies widely as well—from a simple text file to a database or Lightweight Directory Access Protocol (LDAP)
These variations make the already complex topic of security even more so.
But creating such an abstraction isn’t always an easy task, especially if security isn’t your core expertise.
By providing an abstraction layer and an implementation for most commonly used security systems, you can create powerful, portable solutions.
If a supplied implementation doesn’t meet your needs, you can easily extend it by implementing a few interfaces.
Furthermore, Spring Security provides ready-made solutions for a few common scenarios that allow you to implement certain security requirements by including just a few lines of configuration.
We’ll now examine Spring Security up close, focusing on the parts you’ll use later in this chapter: authentication and authorization.
Authentication is a process that verifies that the user (human or machine) is indeed whom they claim to be.
For example, the system may challenge the user with a username and password.
When the user enters that information, the system verifies it against the stored credentials.
Spring Security supports authentication using a wide range of authentication schemes such as basic, forms, database, LDAP, JAAS, and single sign-on.
You can also roll your own authentication to support the specific scheme that your organization is using (and still utilize the rest of the framework, including authorization)
After the user credentials have been authenticated, the authenticated user (more generally known as the principal) is stored in the security context.
Figure 15.1 shows the overall structure used in Spring Security for authentication.
As shown in the figure, the authentication system stores an Authentication object inside a SecurityContext.
The thread-local scope is the default and most useful in web applications.
The authenticated user may then be accessed by other parts of the system.
For example, a service layer may access the principal authenticated by the web layer so that it can determine whether the user has appropriate privileges for the invoked services.
You’ll use this fact to access the principal from security-related aspects.
Authorization is a process that establishes whether an authenticated user has sufficient privileges to access certain resources.
For example, only users with the admin privilege may access certain web pages or invoke certain business methods.
To accommodate potentially complex custom requirements, it provides several components that you can customize.
It makes the determination based on the current Authentication object, the accessed resource (which may be a domain object, an object representing a method, or even a join point), and the security attributes associated with the accessed object.
The security attributes specify properties such as the roles required for an authorized access.
The authenticator stores the authentication object in the security context.
Other parts of the system, including the authorization subsystem, may access the authentication object from the security context.
Check the Spring Security documentation for more details on these classes.
In addition to providing support to perform authentication and authorization, Spring Security provides prewritten servlet filters and aspects to enable security in your application with little custom coding.
We’ll discuss the prebuilt support in Spring Security in section 15.6
You’re now ready to use Spring Security to write a few aspects.
Following the template set in the previous chapter, you’ll develop a few aspects from scratch.
It will provide a deeper understanding of how AOP modularizes a security implementation.
You’ll use Spring Security as the underlying mechanism but drive it through your own aspects.
If you need to use a different mechanism, you should be able to modify the aspect easily (although you may configure Spring Security to use that mechanism as well)
You have two separate functionalities to deal with: authentication and authorization.
When do you authenticate a user? You can do an up-front login when a user visits the web site or starts a UI or console application.
You can delay it a bit, for example, when a user visits a secure web page.
You can delay it even further, say, when a user accesses a specific functionality leading to a secured method invocation.
Yet another style is to perform authentication when the authorization logic throws an exception indicating that the accessing user hasn’t been authenticated yet.
Depending on your choice, AOP may or may not be the right implementation technique.
For example, if you need to perform authentication only at one specific point, you may not need AOP.
In this section, we’ll focus on the cases where authentication is performed in response to a method being invoked.
Because join points where you need to perform authentication vary, let’s write the base aspect shown in listing 15.1
You use the @AspectJ syntax to allow the choice of proxy-based versus byte-code weaving.
If you use Spring to configure the application, you can inject this dependency through configuration.
Otherwise, you can call the setter directly from the code.
See chapter 6 for a discussion of how to access the aspect instance so that you can call a setter on it.
Interested only in using Spring security? As in the previous chapter, if you’re only interested in using Spring Security, you can skip to section 15.6
Thanks to the support class in listing 15.2, there is no Spring Security–related code in the aspect itself.
The injected object needs to be configured with the required objects, such as a credential source.
This way, you can plug in any authentication mechanism such as a database, LDAP, or single sign-on.
The class also declares a dependency on a LoginService object.
It also has a dependency on a strategy that obtains the username and password as the default implementation.
For a fat-client UI application, the implementation could put up a dialog box to ask for the username and password.
The authentication logic first checks if there is already an authenticated user in the security context.
If not, it obtains an authentication token using the login service.
It then passes that token to the authentication manager to validate it.
Otherwise, the method stores the validated authentication object in the SecurityContext so that other parts of the system may obtain it.
A good place to authenticate is when the user first invokes a service method.
You’ll accordingly write a subaspect (listing 15.3) with a pointcut that selects any service method.
Before you can use this aspect, you need to configure it.
If you’re using Spring to configure your application, you’ll need to add a snippet similar to listing 15.4 in one of the files that forms the application context.
Listing 15.3 Aspect for upfront login in a console application.
The configuration uses namespace support to reduce the code required (see the Spring Security namespace documentation for more information)
In real projects, you’ll replace this authentication provider with an appropriate one such as that based on a real database, LDAP, or single-sign on.
You inject this authentication manager into an authentication support bean, and that bean into the aspect.
If you need to authenticate at a different point (say, after the main window is visible in a fat-client application), you have to modify only the pointcut in the subaspect.
Now, let’s move to a more interesting and complex topic of authorization.
An authorization aspect ensures that the user has sufficient privileges to access the advised join point.
As usual, you have two choices for weaving in the authorization logic: proxy-based or byte code–based weaving.
To accommodate both choices, you’ll use the @AspectJ syntax, exactly as you did for authentication.
Implementing security using proxybased Spring AOP involves the arrangement shown in figure 15.3
You’ll see similarities due to the common use of AOP as the underlying mechanism.
Spring AOP creates a proxy around the service beans, and the security advice ensures authorized access.
As discussed in earlier chapters, Spring AOP works only with Spring beans.
If you need a more encompassing solution, you’ll need to use byte-code weaving.
In the same way as the authentication aspect, the mechanism to choose authorized join points and to obtain security attributes varies.
Let’s write a base aspect that defers those decisions to subaspects.
To allow flexibility in selecting authorized join points, you implement the abstract aspect shown in listing 15.5
Like the authentication aspect, the authorization aspect delegates to a support class.
The advice delegates to a support class, which then performs the same task as in figure 15.2
The advice delegates the authorization logic to the injected support object.
Because authorization depends on the join points to compute the security attributes, it passes the current join point to the delegated method.
This aspect uses the support class shown in listing 15.6 to perform authorization.
This class essentially implements the collaboration shown in figure 15.2
The authorize() method obtains a list of ConfigAttributes, which are the security attributes for the secured resource.
Finally it passes all this information to the decide() method.
Securing web applications through Spring Security uses a similar approach, performing authentication through a servlet filter in response to a thrown exception.
You have a few possible ways to write subaspects based on how you select join points to authorize.
The two main selection choices are with or without annotations.
A simple choice in writing a subaspect is to define a pointcut and provide a way to compute security attributes for a given join point.
Here, you can use the participant pattern discussed in chapter 12, where you implement many simple aspects, each securing a specific class or a set of related classes.
The subaspect as shown in listing 15.7 selects all service methods for authorization.
Although the pointcut itself is simple, you need to implement another puzzle piece to obtain the security attributes for the advised join point.
But nothing stops you from applying it to any other set of objects.
Particularly, if you use the AspectJ weaver, you can write a subaspect that applies authorization to the domain entities.
Noninvasive crosscutting Subaspects that don’t use annotations require no changes to the core code.
Instead, they rely on existing program structure such as the package structure, inheritance hierarchy, class and method name patterns, and even annotations not related to security.
But these subaspects are a little complex to implement in the absence of security-related information available from the secured program elements.
Furthermore, they can be more fragile, because they often rely on fragile naming conventions.
The role mapping is configured externally (typically, through Spring’s application context)
The key in the map is a name pattern such as expire*, and the value is the required role to access a method matching the name.
You need to configure the aspect (listing 15.9) and its associated objects through Spring’s application context.
You use the UnanimousBased class as the implementation for the access decision manager.
You configure it with one voter to decide access based on roles.
The mapping specifies that the user accessing the methods with name starting in expire or exactly matching reducePrice to be in the ROLE_SUPERVISOR role.
For all other methods, you set the required role to ROLE_USER.
If you’re using Spring AOP, you shouldn’t specify this attribute.
You need to ensure that authentication kicks in before authorization if both take place at the same join point.
Listing 15.10 Aspect to control ordering of authentication and authorization.
Let’s execute the driver program and log in as the user with the USER role.
You expect access to be denied to the expireProduct() method:
The output for the access by a user with the SUPERVISOR role (username: ramnivas, password: aop) is similar, except no exception is thrown.
One of the important advantages of the simple aspect is noninvasiveness.
The core code is unaware of the security requirements and doesn’t need any specific accommodation.
This works fine for simple cases where the criterion to select the authorization join points and the logic to deduce the security attributes are simple.
But in other cases, it may pose a difficulty in writing a robust pointcut and externalizing the security attributes.
In those cases, you may need some collaboration from the core code in the form of annotations.
The core idea behind the annotation-driven approach is to attach authorized types and/or methods with annotations that specify security-related information such as the expected roles.
The aspect can then select all methods that carry such annotations and compute the security attributes based on the annotation values.
This idea is similar to how you implemented transaction management in the previous chapter.
Let’s write a subaspect that uses annotations, as shown in listing 15.11
For this aspect to work, you must mark the type or methods with the @Secured annotation and specify the required role as the attribute.
The annotations specify that the expireProduct() method may be accessed only by users with the SUPERVISOR role.
Users possessing the USER role may access any other method.
You need to configure this aspect as shown in listing 15.12
The output is identical to that of the subaspect that didn’t use annotations.
Now that you’ve implemented simple authentication and authorization, let’s get a.
Consider a health-care application that manages entities such as doctors, patients, prescriptions, lab results, diagnoses, and insurance claims.
Although many users may access diagnoses, not all may see every field.
For example, an insurance agent may see when a lab test was performed but not the test results.
Similarly, a patient may see the result only after the doctor approves it.
In such situations, security is at the individual field level and not at the object level.
Because the security-access logic applies to the fields of domain objects, proxybased AOP doesn’t cut it.
Note that Spring Security currently doesn’t provide this functionality out of the box, but a future version may.
The decision to determine access may be based on roles, object state, or a combination thereof.
For example, a user with ROLE_DOCTOR may be able to see any test results (role-based decision), or you may have a more stringent requirement that only the doctor who ordered the test may see its results (object-state and role-based decision)
Furthermore, it’s likely that you’ll want to have doctors with ROLE_EMERGENCY_ DOCTOR to be able to see results regardless of their relationship to the patients.
The core idea behind implementing field-access checks is similar to method access.
The only real difference is that instead of using method-level annotations, you use field-level annotations.
By using a field-access pointcut (discussed in chapter 3), you can enforce the access check.
Let’s see how this is implemented in your e-commerce application.
First, you’ll define an annotation (listing 15.13) that can be attached to fields.
The only difference is that you allow the annotation target to be a field.
Listing 15.14 shows a test that you’ll follow with an implementation to make it pass.
Annotation isn’t the only choice As you’ve seen for authorization, the use of annotations isn’t the only choice for fieldlevel security.
It’s valid to enforce access checks based on packages, inheritance hierarchy, and so on.
For example, if you need to control access to all fields whose type extends the Document type, you can use get(Document+ *) to select the accesscontrolled fields.
It boils down to understanding the join point model and the pointcut expression language.
In this test, you exercise three scenarios: uninhibited access to an unsecured field, successful access for users with a correct role, and preventing access to users with an incorrect role.
The test assumes that the price field in the Product class is a secured field that requires ROLE_SUPERVISOR as the expected role.
The pointcut selects read and write access to any field annotated with the @Access annotation.
The advice consults the injected securitySupport object to make an access decision.
When you run this test, you see a green bar! Now, let’s examine how Spring Security uses AOP to provide out-of-box solutions.
Spring Security provides ready-made solutions that enable developers to secure applications with a few lines of configuration.
These solutions target different parts of application: web, service layer, and domain objects.
Note that full details of Spring Security are beyond the scope of this book.
I strongly recommend that you read the documentation provided as a part of its download.
Securing web applications is a common task, therefore, Spring Security provides special support for this scenario.
With namespace-based configuration, a few lines can configure URL level security that ensures that the user has the right authority to access the URLs.
For example, the following Spring configuration provides authentication using a default login page and ensures that any URLs that end with “delete.htm” are accessible only by users with the ADMIN role.
Other URLs are accessed only by users with the USER role.
Typically, you’ll start with a simple snippet as shown, modify various attributes, and add additional elements to tailor to your specific needs.
For many applications, it’s sufficient to secure just the UI layer.
But you may want to secure the service layer as well, to prevent any errors in the UI security configuration from compromising the system.
Because most enterprise applications utilize a service layer as the exclusive way of accessing business functionality, it makes sense to secure this layer.
It offers two options to specify the access-control information: through the XML-based configuration and through annotations.
With the external configuration option, XML code specifies the secured methods as well as the mapping between methods and roles.
This approach is similar to what we presented in section 15.4.2
The following snippet shows how you can limit method access to users with specific roles:
Notice something that should look familiar to you by now: a pointcut expression.
The protect-pointcut element specifies a pointcut and the required privileges to access the join points selected by that pointcut.
For example, this snippet specifies that only users with the ADMIN role may access any method whose name starts with delete in a class in the ajia.service package.
Behind the scenes, this snippet leads to the creation of a proxy for the service beans along with a security aspect, as shown earlier in figure 15.3
Instead of writing a pointcut, you attach types and methods with annotations that specify the security attributes, as shown in listing 15.18
The type-level annotation specifies the security attribute required for all methods in the type.
The method-level annotation specifies the security attribute for the annotated method.
The XML configuration enables the use of JSR 250 annotation as follows:
Whichever way you choose, the underlying mechanism involves Spring AOP along with Spring Security players, as shown earlier in figure 15.3
In some situations, the role alone isn’t sufficient to determine access.
Moreover, the role required to access some functionality may depend on the data at the time of.
What about prescreening? A common way to handle access control is to apply anticipatory restrictions.
For example, in a web application, you may hide certain links after you determine that the user doesn’t possess sufficient authority to successfully access the associated functionality.
Disabling that functionality has the additional advantage of not letting a user attempt access only to be presented with an unfriendly message indicating that they shouldn’t have clicked that link.
Any lapse on their part may lead to security holes.
Even if prescreening is used, it’s still critical that the backend expect the unexpected, always suspect all requests, and apply security on its own.
Of course, you should add prescreening whenever possible; but its purpose should be to provide a better user experience, not to secure applications.
Therefore, Spring Security offers a way to protect domain entities through an access control list (ACL)
With it, you can limit access to certain objects only to users with specific authorization to those objects.
Spring Security, starting with version 3.0, also offers a way to specify scripts that describe access rules.
For example, as shown in the following snippet, you can specify that expiring an item in the inventory requires that the user be the manager for the department of the product being expired:
The implementation behind the script-based support is similar to that for caching in chapter 4, where you used a script to compute the cache key.
Scripts can use method arguments and the authentication object to define access rules.
The scriptbased authorization also supports post authorization (which can also access the object returned by the advised method) as well as filtering of arguments and returned objects.
For some applications, securing the service layer isn’t sufficient; you need to secure domain objects as well.
You need to apply security to domain objects such as an account, customer, and line item.
In many applications, every operation is funneled through the service layer, so service-layer security suffices.
But such use of the service layer can be a burden on the architecture (especially if that is the only purpose of the service layer)
Therefore, it can be valuable to apply security directly to domain objects.
As you saw in section 15.3, Spring Security offers an infrastructure that is flexible enough to be applied to domain objects with little effort.
Currently, Spring Security doesn’t include prebuilt aspects targeted toward domain objects; but this may change in a future version.
Meanwhile, you can use the aspects developed in listings 15.5–15.17 to secure your domain objects.
Of course, because typically domain objects aren’t managed by Spring, you can’t use Spring’s proxy-based AOP; that job is best left to the AspectJ weaver.
Let’s end this chapter with a discussion of what else aspects can do to implement a wide range of security requirements.
As I mentioned earlier, security requirements vary a lot—and when you cross the comfort zone of basic authentication and authorization, it’s wild out there! Enterprises tend to have specific requirements to enforce various facets of security, such as auditing access to sensitive data and filtering collections returned as part of a query.
This section will discuss a few ideas and ways to approach these requirements.
When you implement your specific requirements, I recommend that you start with the presented approach and modify it as needed.
For privacy monitoring and regulatory compliance, you may need to monitor access to important data and operations.
For example, although a user may have access to a piece of data, it may be important to audit when and in which context they access that data.
If things go wrong or suspicious activities take place, such auditing may save people and organizations; that’s the world we’ve come to live in.
Essentially, you extend the monitoring aspects presented in that chapter to audit security-related fields and operations.
The audit record may need to include the accessing context, such as the top-level method that led to an access to a sensitive field.
You may also need the join point context associated with the top-level method.
The cflow() pointcut combined with the wormhole pattern discussed in chapter 12 comes in handy here.
For example, the users can see only products associated with their department.
In this case, you don’t want to completely reject access to the field.
But you can also implement your own filter using an around() advice.
The scheme of filtering returned data may exhibit a performance problem if the returned value is a large collection.
Filtering essentially pulls all the information from the underlying source and removes elements that don’t match a security criterion.
If you use an ORM technology such as Hibernate, you can enable filters that augment SQL queries with a where clause.
For example, you can enable a filter upon entering a service method so that when eventually a query is executed at the data layer, the clause limits the returned data.
The ORM technologies also offer the concept of criteria that play a role similar to filters but apply to individual queries.
By advising the queries’ creation to augment the additional criteria, you can easily limit access to data.
Security is a classic example of a crosscutting concern—the same concern needs to be implemented and applied across many chunks of the same code base.
Although security frameworks such as Spring Security and JAAS isolate you from the details of the underlying security mechanism, the application of the security check can still lead to code tangling and scattering.
By driving the security APIs through aspects, it keeps the security code away from the main-line business code.
This offers a good separation of responsibility: security experts can focus on writing security aspects, and developers with business knowledge can focus solely on business logic.
The simplest form uses a servlet filter to secure the UI layer or proxy-based AOP to secure the service layer.
But many applications need to go beyond securing the UI or the service layer.
This is where the general nature of an AOP solution outshines all the alternatives.
By targeting the aspect to domain objects, you can easily implement domain-object security.
You can even target fields of an object so that information doesn’t leak to unauthorized users.
This provides enormous flexibility in designing your application and avoids having to make architectural decisions just to provide a convenient funnel in which security is applied.
A solution that uses annotations isn’t as transparent, because business code carries security-related annotations.
But many developers see this arrangement as a good compromise between a completely noninvasive solution and directly embedded security code.
With a completely noninvasive solution, business developers wonder how security is implemented and how to influence security requirements.
Aspect developers also need to work hard on writing a good pointcut and potentially require business classes to include an aspect following the participant pattern.
Annotations provide a good collaboration point, where classes contain annotations and aspects consume those through pointcuts.
For any kind of situation, AOP offers a broad range of possibilities for making authorization decisions.
You can use AOP’s modularization and simplicity to address any security requirements during application evolution—all you need is good knowledge of the underlying security APIs and AspectJ.
So far in this book, we’ve focused mostly on infrastructural aspects.
In the next chapter, we’ll examine a few ways aspects can help with that.
But AOP is also useful in improving the implementation of domain logic in several ways.
First, aspects help in implementing dependency injection (DI) for objects not explicitly managed by a DI container.
This enables the implementation of complex behavior that would otherwise be tedious.
Second, by modularizing crosscutting business logic, AOP provides the same benefits it offers to crosscutting infrastructure concerns.
Furthermore, AOP helps enforce design rules targeted toward the domain objects, improving the overall quality of the software system.
Unlike infrastructure aspects, these aspects are specific to the target domain.
In this chapter, we’ll focus on general concepts so that you can map them to your own domain.
So far in this book, we’ve established that AOP is useful for implementing crosscutting infrastructure functionality such as monitoring, concurrency control, transaction management, and security.
But the precise nature of the business domain isn’t the main point.
This chapter is about identifying solutions that remove limitations from the current architecture styles.
It strives to trigger a thought process so that you can apply and expand on the ideas presented.
In this chapter, we’ll focus on empowering objects with a combination of DI enabled through AOP and modularizing crosscutting business logic.
We will also examine a way to avoid the use of Data Transfer Objects (DTOs) in many cases without sacrificing benefits they offer.
One of the main premises of object-oriented programming is that objects should have both data and behavior.
As a result, implementations often shift the behavior to the service layer.
The core problem is that implementing rich behavior requires collaboration with other objects, and accessing those objects isn’t as easy as it may appear at first.
Let’s revisit the Order class you’ve been using in this book.
For the most part, this class is a data carrier: it includes a list of LineItems and the status of the order indicating if it has been placed.
Essentially, it contains all the information that is persistent in nature.
It includes some trivial behavior to obtain the total of the entire order, but there is a catch.
You’re getting away with using a simple implementation for this behavior: the order total is the sum of the individual line-item costs.
In the real world, this implementation is unlikely to fly.
The order total must consider various factors such as a bulk discount, a special discount due to a coupon, or special pricing based on the status of the customer.
The same level of complexity applies to other pricing-related functionality: obtaining discount details, obtaining possible discounts if the customer adds more items or acquires a special status, and so on.
Similar complexity may crop up in other classes such as LineItem.
You certainly don’t want to burden the domain objects with pricingrelated logic.
Doing so would tangle the pricing logic with the domain objects and make it difficult to share pricing computations between related classes such as Order and LineItem.
In the last few years, the Domain Driven Design (DDD) approach has gained popularity.
The main premise of the DDD approach is that the design, especially for complex systems, should be based on a domain model, and the primary focus should be on domain logic and not technological factors.
Because the domain models for complex systems have rich behavior, the corresponding design and implementation should have the matching rich behavior.
Empowering objects chapter, AOP substantially helps you implement the DDD approach by overcoming these difficulties.
Implementing rich behavior in a reasonable manner requires the Order class to delegate the pricing computation to a separate class.
To avoid serializing this field, you mark it as transient.
With an object-relational mapping (ORM) framework such as JPA, marking the field as transient avoids persisting it into database.
The getTotalPrice() method uses this field to call the getPrice() method, passing the this object as the parameter.
The hard-coded dependency makes it difficult to swap a pricing strategy or perform unit testing.
Locator —Introduce a locator class (commonly known as a service locator) with a method to obtain a reference to a shared object.
At the application or container level, you register various objects with the locator.
Doing so removes the hard-coded dependency between the Order class and a pricing strategy implementation.
Spring Roo and domain-driven design The Spring Roo (http://www.springsource.org/roo) project uses AspectJ to promote domain-driven design.
Through a judicious use of annotations along with aspects, it offers improved productivity, elegant design, and simpler implementation without locking user applications to Roo.
Such an arrangement makes it easier to swap the implementation by registering a different object with the locator.
But the domain objects now depend on the locator class—Context, in turn, adds a dependency on the environment that supplies a locator.
Compared with the hard-coded dependencies approach, such an arrangement doesn’t fare much better with unit testing.
Unit tests need to somehow coerce the Context object into returning the expected mock or stub object, because you may need to set the pricingStrategy to a different mock or stub object in each test.
Dependency injection —Add the necessary structure to domain objects to enable DI.
For example, you can add a setter for each injected dependency.
Then, you let a container inject dependencies upon instantiating the object.
With this setup, the object has no knowledge of the mechanics of the DI.
You can swap one service for another by modifying the configuration.
For unit testing, you can set the dependencies directly by calling setters from the test code, without needing any special mechanism.
With beans such as controllers, services, and repositories, a DI container such as Spring instantiates the objects and injects dependencies.
But a DI container doesn’t instantiate domain objects (such as entities and value objects)
Instead, you or other frameworks such as ORM can directly instantiate objects (using new or the reflection API)
Consequently, the container doesn’t have an opportunity to inject dependencies.
AspectJ comes to the rescue by extending the container services to the domain objects.
Let’s examine an implementation of this technique available in Spring.
Spring uses the AspectJ weaver to provide a prebuilt solution to inject dependency into any objects—even those that are instantiated outside of Spring.
An aspect injects dependencies whenever an instance of a specified class is instantiated or deserialized.
Figure 16.1 shows how an aspect injects dependencies into domain objects.
Static field dependency injection? You can add a static field to the domain classes and initialize this field through an external mechanism.
Spring offers two ways for you to specify classes to participate in such a DI mechanism: by annotating the class and through domain-specific interfaces along with custom subaspects.
With this style, you mark each class that needs DI with the @Configurable annotation.
You also specify through configuration how Spring should inject dependencies.
As you’ll see later in this section, you can avoid most of the configuration through Spring’s autowiring feature.
You’ll inject each instance of Order with a PricingStrategy bean.
You mark the class with the @Configurable annotation to signal that this class should be configured by the Spring container, even though it’s not instantiated as a Spring bean.
Domain objects Figure 16.1 Domain object DI through an aspect.
Upon creating domain objects, the aspect performs DI on them.
The aspect itself has dependencies injected into it, which it injects into the domain objects.
You use the injected pricing strategy to implement the getTotalPrice() method to delegate the computation.
You add a setter to allow Spring to inject the dependency.
Although you’ll be creating Orders outside of Spring, you need to instruct Spring how to configure an Order instance.
You do that through a prototype bean definition; see listing 16.2
The pricingStrategy bean is a regular Spring bean that you’ll inject into the Order objects.
The prototype scope instructs Spring to not create a bean for this definition upon creating the application context.
In your setup, you’ll never request a bean for this definition; hence, no bean will ever be created for the definition.
Alternatively, you can use the abstract="true" attribute to the same effect.
In either case, the bean definition serves only as the specification for the injected dependencies.
You use a <property> element to declare that the dependency should be wired to the pricingStrategy bean.
If there were more dependencies to be injected, you would have one <property> element for each of them, just like any other Spring bean.
Behind the scenes, it instantiates an aspect and configures it.
Let’s check this through a simple integration test, as shown in listing 16.3
The test creates an Order and checks whether the dependency has been injected into it.
Spring’s autowiring mechanism offers an additional technique based on the @Autowired annotation that eliminates the associated configuration.
With the @Autowired annotation, you no longer need a prototype bean in the configuration.
In listing 16.5, you don’t see any beans corresponding to the Order class.
Spring detects any property marked with the @Autowired annotation and injects that dependency using the configuration specified in the XML file.
You don’t even need the setter method; you can mark the field itself as autowired, as shown in the listing 16.6
Unit-testing with @Configurable objects When you’re using unit testing, unlike integration testing, you don’t want to involve any infrastructure, including Spring.
Therefore, you should manually inject dependencies (typically, mock or stub objects) by calling the appropriate setters.
With the field itself marked with the @Autowired annotation, you no longer need a setter.
This will, however, require you to use reflection to set such fields for unit-testing purpose as you have done in listing 16.3
For objects that are created often, this may cause a performance problem.
Furthermore, the @Configurable annotation is Spring specific, creating a dependency between the domain objects and the framework.
You can avoid the performance problem and the object’s dependency on Spring using domain interface-based DI.
This requires writing aspects, but if you’ve come this far in reading this book, it should be of no big concern to you!
A way to look at the Order and LineItem classes is that they’re clients of the injected dependencies.
The classes may indicate this relationship by implementing specific interfaces.
A typical interface would include setter methods that set dependencies.
This style allows using domain-specific interfaces instead of the Springspecific @Configurable annotation.
Listing 16.7 shows the interface that a client of PricingStrategy would implement.
All Spring container services now showing in objects near you The @Configurable annotation extends the Spring container functionality to any object—not just Spring beans.
This is why the @Autowired mechanism, which is a general Spring feature, worked for the Order class.
The more services you use from the Spring container, the more dependency you have on it.
You need to be careful when extending the container services to the domain objects such as Order and LineItem.
A pragmatic approach requires that you consider the convenience offered by annotations and the purity of the code without them.
As always, start with what makes sense at a given moment, and refactor when necessary.
You can extend this aspect to apply DI on classes that implement your domain specific interface(s)
Notice that you no longer need a Spring-specific annotation in this class.
This code implements what we may call the dependency distribution pattern.
You inject the aspect with dependencies and the aspect will distribute those dependencies into other objects.
Let’s see the parts of the aspect in more details.
The configure() method provides a definition for the abstract method in the base aspect.
The base aspect will call this method whenever a configurable object matching the generic parameter type is either created or deserialized.
The method calls the appropriate setter to inject the dependency.
In your case, there is only one dependency to set.
But you may configure the object in whatever way appropriate.
Note that, dependency injection is done by direct method calls instead of reflection, thus offering better performance.
The aspect includes a setter to declare a dependency that it will distribute to the advised objects.
Alternatively, you can mark the pricingStrategy field with @Autowired and avoid the setter.
Of course, you’ll need to configure each aspect to inject the dependency into it.
Listing 16.10 shows the bean definition corresponding to the aspect.
You don’t need a prototype bean defined in the application context, because each DI aspect knows how to inject dependencies.
If you run the same test, you should see a green bar.
Second, you can use the interface implementation idiom discussed in chapter 5 to relieve each class of the burden of implementing the client interface.
When you make these changes, you get the implementation in listing 16.11
Listing 16.11 Improved DI through use of a nested aspect.
You need to adjust the configuration for the nested aspect’s fully qualified name.
It may seem that routing requests, such as for the getTotalPrice() method in the Order class, through the domain objects offers only superficial advantages.
But on closer examination, you start to see several advantages.
By making domain objects offer rich functionality (even when achieved by delegating to other objects), you can achieve real encapsulation and autonomy within the domain classes.
You also reduce the amount of collaboration that needs to be carried outside those classes.
For example, the clients don’t have to know the existence of a pricing strategy to compute prices.
They get pricing from the order objects—just as it would appear natural to do.
This kind of arrangement also conforms to the Law of Demeter, also referred to as the Principle of Least Knowledge (http://www.ccs.neu.edu/home/lieber/LoD.html), which promotes the motto “Only talk to your friends.”
Where else can you take advantage of DI in the domain objects?
You now have a good idea of how to inject dependencies.
In all these cases, you’ll use one of the DI mechanisms discussed earlier.
Take a look at the OrderServiceImpl class in appendix A, listing A.10
The addProduct() and removeProduct() methods delegate their work of adding a line item to or removing it from the Order class.
It also updates the inventory by invoking a method on the inventory service.
Note that downlodable sources include automated tests for the code in this section.
There is of course the danger of including too many concerns.
For example, is it an order’s responsibility to notify inventory? This is where your domain model comes into the picture.
If the domain concept of order describes notifying inventory, it’s a good idea to mirror that in the implementation, but not otherwise.
A right-sized approach to design I use varied approaches when it comes to designing a system.
If the domain logic is complex, I lean heavily toward a rich domain-object model.
But if the application is simple, essentially performing create, read, update, and delete (CRUD) operations with simple business logic, I may go for a more rote approach with an anemic domain model.
Of course, the trick is knowing which category your application belongs in.
As you will see throughout this chapter, AOP makes moving from anemic to rich domain model in an incremental manner a much simpler process.
The addProduct() and removeProduct() methods take on the responsibility of notifying the inventory service of the changes.
The Order object itself is now capable of implementing any behavior that makes sense for the domain.
With this modification, the service layer no longer needs to deal with the inventory management, as shown in listing 16.14
Any client must still funnel all requests to add or remove products through OrderServiceImpl, because it still updates the Order (makes the persistence framework reattach the entity) as well as manages the transactions.
You can make the Order take care of notifying the repository of the changes, if you inject the OrderRepository into the Order class as shown in listing 16.15
Package arrangement with domain object DI When you start to inject services into domain objects, if you continue to use the existing package structure, you get a circular dependency: services refer to domain objects, and domain objects refer to the services.
You can resolve this by making the service interfaces belong to the same package as the domain classes they’re injected into.
Service implementations should stay in a separate package, because those implementations refer to domain objects, but not vice versa.
The same issue and resolution apply to any other injected objects, such as repositories.
Autowired private transient InventoryService inventoryService; @Autowired private transient OrderRepository orderRepository;
With this change, OrderServiceImpl reduces to nothing more than a plain delegation, as shown in listing 16.16
The application configuration still sets up the transactions around this service class.
It also contains other methods such as finding an order or all orders, or deleting an order.
In those cases, each operation is delegated to the repository.
You could easily apply transactions to Order and OrderRepository’s methods.
If the unit of work encompasses multiple repository operations, you can always set transaction boundaries at the methods that represent the unit of work.
In such an arrangement, transactions at the repository level participate in the outer transactions.
See chapter 14 for more information about how transaction management works with nested operations.
So, with OrderServiceImpl reduced to pure delegation and not even taking care of transaction management, does it still need to exist? DISCUSSION: RETHINKING THE SERVICE LAYER.
After the business logic and transaction management is removed from the service object, the service layer serves no technical function.
From this perspective alone, you may remove the service layer.
In a web application, this means that the web UI controllers access the domain objects and the repository layer directly.
Another way to look at services is to categorize them into two kinds: technical and integration.
Technical services exist only due to the technical architecture of the system.
Integration services, in contrast, allow exposing functionality to logically or physically external components.
The system needs integration services regardless of the underlying architecture.
If you’re new to the full power of AspectJ-based AOP, I suggest that you keep a thin service layer.
You may even want to keep transaction boundaries at the service layer.
Inject repositories? Injecting repositories into the domain objects may make you uncomfortable.
This may be due to the kind of architecture you’ve been implementing for many years.
In general, understand the possibilities and make your own decisions.
Implication on service-oriented architecture In a service-oriented architecture (SOA), an application is composed of well-defined services.
How does focusing away from services and toward domain objects affect this? It doesn’t in any significant way.
Services designed in SOA have a different focus than services defined only to serve a technical purpose.
You wouldn’t take a service designed to serve a co-located web layer and make it available as it is to other clients in a SOA-based application.
Instead, you’d carefully craft a service, paying attention to factors such as forward compatibility and suitability by access through remote clients.
With the domain-focused approach enabled by AOP, the services exposed in this manner can delegate to rich domain objects.
Over time, as you feel more confident with this approach, you can move toward using domain objects directly or through other services.
The goal of enriching domain objects isn’t the removal of the service layer; it’s making objects map more closely to the domain model.
A look at the Order class reveals that the client must obtain product objects (through the product repository) to add or remove items.
If you inject a product repository into the order object, you can implement methods that take the product id, obtain the product using the repository, and pass it to the method that takes the Product object as an argument.
Now the classes that use Order don’t need to access ProductRepository.
By reducing the number of objects the clients have to deal with, you offer a simpler API and you gain implementation flexibility.
There is an alternative to adding the new APIs directly in the target class.
Using static crosscutting, you can separate the simplification API from the main API.
Listing 16.17 Simplified API to order through the use of an injected repository.
Humane interfaces This kind of client-centric API is also referred to as a humane interface.
In contrast, a minimal interface provides only the basic methods that enable but don’t provide clients to write convenience methods.
A humane interface considers typical uses of the interface and provides convenience methods as a part of the interface itself.
Implementing business logic shows an aspect that introduces the id-based API that internally uses a repository to obtain the product and call the product-based API.
Note that you inject the ProductRepository into the aspect itself.
As a result, you need not inject the repository into the Order class.
A further refinement of this scheme would put the aspect directly inside the Order class.
This way, the main and the simplification API reside in their own compartments (the class and the aspect)
Some business logic exhibits micro-crosscutting concerns—they spread over a few small chunks of code, often just a few methods in one class.
In these cases, AOP can avoid code scattering and tangling at a smaller level.
Let’s see two examples of such concerns in the e-commerce domain: implementing inventory monitoring and checking order-level constraints.
Realtime monitoring of inventory enables businesses to respond to changing demands in an agile manner.
Because this aspect advises the service-layer objects, which are defined as Spring beans, you can use Spring AOP along with the @AspectJ aspects.
Alternatively, if your architecture so dictates, you can apply the aspect to the domain objects and advise the methods in the InventoryItem class.
Listing 16.20 shows an aspect that monitors changes in the inventory and updates an inventory monitor.
This scheme works fine for the InventoryService or InventoryItem class, because you can select the two methods that modify the object state.
But if a class has a large number of methods, such selection will lead to the fragile pointcut problem.
This implementation has a caveat: notifications are sent even when the ongoing transaction fails (adding a product to or removing it from inventory)
You can fix this problem in a variety of ways.
First, you can use Java Transaction API (JTA) and ensure.
Implementing business logic that the notification implementation participates in the transaction; but for most use cases, using JTA for such a scenario is overkill.
Finally, you can make the response to the notifications immune to false notifications.
For example, the notification processor can check the database for changes before proceeding.
Depending on your domain, what constitutes a valid order may be complex.
For example, perhaps only certain kinds of line items may be mixed, an order amount or weight may not exceed a certain threshold, the type or count of items that may be bought is limited, certain customers may not purchase hazardous materials, and so on.
It’s best to detect violations as they take place so you can provide feedback.
The aspect in listing 16.21 shows how AOP can help implement such business rules.
The cflow() pointcut ensures that calls initiated from the OrderValidator aren’t validated.
You may consider the order-validation logic to be part of the Order class.
In that case, you may want to embed the aspect inside the Order class to signify the stronger relationship between the two.
With such a structure, the nested validation aspect helps to untangle the validation logic from the main-line logic.
You’ll see an example of such arrangement in the next section.
You can apply the aspect to the service layer, as long as you ensure that all the modifications to the order are funneled through the service.
In that case, you can use Spring AOP instead of AspectJ weaving.
For the purpose of illustration, you’ll use a simple rule where the order total can’t exceed a prespecified amount, as shown in listing 16.22 (see downloadble source for automated tests)
Note that you may choose to send a notification instead of throwing an exception to alert users, but still allow temporary violations.
The separation of concerns implemented by the code simplifies any such changes—all you need to do is modify the OrderValidator class.
Refactoring is a way to modify an internal implementation without affecting the externally observable behavior.
With recent interest in Extreme Programming (XP), refactoring techniques are gaining well-deserved attention.
Consider the Order class, which implements the freezing of a placed order.
Currently, the addProduct() and removeProduct() methods check whether the order is frozen before changing the order.
In a more realistic implementation, it’s likely to be scattered in even more locations.
You can write a simple aspect that implements the freezing functionality.
Typically, you’ll place the aspect inside the class, similar to a private method.
But you may not recognize the need to create an aspect for such functionality right away; instead, you may start with a conventional implementation and then refactor through aspects.
But these notifications are limited to persistent entities and occur only when entities are committed.
The AspectJ-based approach lets you detect violations to any objects as soon as they occur, which is a much more natural fail-fast implementation.
Aspects used to refactor crosscutting code differ from mainstream aspects in the following ways:
Aspects used for refactoring are narrowly scoped to crosscut a class or two as opposed to potentially crosscutting the whole system.
Because refactoring aspects are tightly bound to classes they’re refactoring, it’s okay for these aspects to depend on implementation details of the classes being refactored.
In fact, such an aspect is an implementation detail of a class.
The order-validation and order-freezing functionality use the same overall template.
When you apply aspectoriented refactoring to your domain objects, you’ll find this pattern useful.
We’ll now move to the last idea for improving the domain logic implementation that ensures that objects are accessed only in the intended way.
Consider how the web layer may access an Order object for display purposes.
Perhaps the service layer provides the web with the Order object.
Consequently, the web layer also gets access to the contained LineItem objects.
But you don’t want the web layer to modify the LineItem objects directly.
Doing so may potentially violate the constraints at the Order level as discussed in section 16.2.2
You want these kinds of checks to be performed at the Order level—in Domain Driven Design (DDD) parlance, at the aggregate root level.
Listing 16.24 shows an aspect that ensures that a LineItem isn’t modified except in the control-flow of an Order method.
The implementation follows the aspects developed in chapter 11, where you applied a similar policy for runtime enforcement of EJBs.
See POJOs in Action by Chris Richardson (Manning, 2006) for more information about various way for the web layer to access the domain model.
By checking whether the line item is modified in the control flow of an operation of the Order class, you enforce the access-control rule.
You can generalize this rule to avoid a specific implementation for each set of domain classes.
The general rule for aggregate boundaries is that for each set of classes, there is a designated aggregate root class.
All modifications to any aggregate member must be through its aggregate root.
From the implementation point of view, you need to enforce two rules:
No modifications to a non-root entity from another architectural layer —For example, the web layer must not directly modify a LineItem object.
No foreign aggregate root access —Any access through an aggregate root must match the aggregate root for the modified entity.
For example, a LineItem may be modified only during an operation in its aggregate root: Order.
It would be a violation if a LineItem is modified from another aggregate root such as Customer.
If these rules are broken, you can get subtle bugs in the system.
The aspect you’re about to implement is fairly complex; but because this is the last chapter with code, you should be ready for such an aspect by now!
A challenge in implementing an enforcement aspect is identifying aggregate roots, aggregate members, and modifying operations.
All access to an aggregate member must originate from the aggregate root designated for the same group.
You can mark aggregate root types with this annotation, whose value property specifies an identifier for the aggregate.
The attribute for the annotation must uniquely identify each type of aggregate in the system.
A good choice is the name of the root class.
You can choose to automatically determine this by relying on a convention (for example, the package structure, if all members belong to the same package) and omit specifying an explicit value.
Then, you mark the non-root members of an aggregate with this annotation, whose value attribute specifies an identifier matching the root they belong to.
For example, you mark the LineItem class to belong to the order aggregate, as shown in listing 16.28
Listing 16.27 Aggregate annotation to declare membership to an aggregate.
Note that as an alternative, you can use naming conventions to select read-only methods.
With such arrangement, although the class avoids a repeated use of the @ReadOnly annotation, the aspect itself doesn’t have to rely on a naming convention.
Finally, you use these annotations to implement the aspect to enforce aggregate boundaries, as shown in listing 16.30
It also collects the @Aggregate annotation so that you can use it in the advice that enforces that the modifications happen through its root entity.
It also collects the annotation to use in the advice.
The use of the cflowbelow() pointcut accommodates intermediate classes (such as utility classes) between root and non-root objects.
This pointcut doesn’t collect any context because a direct modification is a violation regardless of the annotation values.
Because the advice must check for the matching attribute values, you collect the annotation associated with both root and non-root objects.
Note the use of the wormhole pattern (discussed in chapter 12) to collect the annotation for the root object.
For example, if a LineItem is modified during an operation in the Customer class, it’s a violation, because the aggregate roots for the two classes (customer and order) don’t match.
Let’s complete this implementation by writing the test in listing 16.31
In this test, you run through a few scenarios: direct access, access through an invalid root (order versus test), and access through a valid root.
With the enforcement aspect watching your back, you can be sure that the objects are used only as intended.
You can also avoid writing extra classes just to ensure the correct access.
Overall, you get higher-quality implementation with a lot less code.
Crosscutting concerns exist even for the domain logic, and AOP can help modularize those.
One of the common problems faced in designing enterprise applications is the inability to create behavior-rich objects, which leads to anemic domain models.
The main reason behind the existence of an anemic domain model is the difficulty in making the collaborating objects available to the domain objects.
Extending DI to domain objects allows them to collaborate with the injected dependencies to implement rich behavior.
These domain objects offer simpler APIs to the client, improve testability, and simplify the overall architecture.
The focus of such an implementation is separating the main-line business logic from the crosscutting business rules.
By observing changes in the domain or service objects, you can provide additional business services.
This gives you flexibility in choosing monitored objects and responding to notifications.
Extending enforcement aspects to implement the ideas in DDD helps you avoid creating unnecessary classes while ensuring the correct use of the existing classes.
This speeds up the development process by letting you focus on what is important: your domain logic.
By now, you should be convinced of the power and versatility of the aspectoriented programming.
In the next chapter, we’ll deal with adoption issues so that you can put all this information to good use.
Others still need convincing, especially when applying AOP that involves byte-code weaving.
The industry could also use more guidance toward using an aspect-oriented approach in analyzing new problems and designing solutions.
In this chapter, we’ll address the adoption issue head on.
I’ll make a few specific recommendations to help you be successful with AOP while managing risks with it.
I’ll also discuss analysis and design based on AOP concepts.
Successfully adopting any technology requires that you take a pay-as-you-go approach.
Such a path avoids undue risk, requires minimum upfront cost, and Taking the next step.
As we come to the end of this book, let’s consider some issues and practical solutions that will help your organization embrace AOP.
In the last few years, having gone through its hype cycle, most developers and managers understand AOP’s value proposition.
Let’s discuss a typical adoption path applied to enterprise application development.
If you’re using the Spring Framework as the basis for your application, using Spring AOP is a risk-free way to introduce AOP.
You need no special compiler, no modifications to launch scripts, and, perhaps more important, no management approval—it’s just Java as far as development and deployment are concerned! Furthermore, Spring provides pre-built aspects for common enterprise crosscutting concerns such as transaction management and security, to get you started quickly.
Spring AOP is limited in the kind of crosscutting it supports—it can advise only public methods of Spring beans.
This makes it difficult to make mistakes (especially in over-applying aspects)
This will help you to move to the AspectJ weaving, because you would have already learned a majority of the syntax.
Spring AOP will enable you to implement a few useful applications of AOP as you have seen throughout the book.
You may stay with Spring AOP, until you come across a need for more complex crosscutting that needs the full power offered by AspectJ.
A typical tipping point for the use of AspectJ in Spring applications is a crosscutting functionality that applies to objects beyond just Spring beans.
If you aren’t using Spring as the basis for your application, AspectJ will be the starting point.
When you decide to use AspectJ, you face choices of syntax and the weaving mechanism.
The right choices depend on multiple factors such as your team’s experience level, the IDE you use for development, and the kind of crosscutting functionality you need to implement.
Of course, you may use AspectJ weaving along with Spring AOP in the same application.
Whether you use Spring AOP or AspectJ, you still don’t need to dive in head first.
You can dip your toes using development aspects and then move to production aspects.
You’ll typically start with simpler applications of AOP, gain experience, and then apply it to problems that are more complex.
You may want to start with aspects meant to be used only during development and then later develop aspects for production use.
In either case, you can use Spring AOP or AspectJ.
Development aspects help to simplify the development process without having to be included in the production system.
The adoption path: applications perceived risk of using a new technology is substantially lower.
You’ll also likely have a better chance of getting approval from management (most of the time, you may not need any approval)
Development aspects also offer a way to gain experience with AOP if you’re new to it.
While you’re learning it, your main purpose should be to improve your individual productivity and gain confidence in AOP.
Due to the unpredictability of the issue and modifications of the concurrency dynamics due to breakpoints, using a debugger isn’t a good choice.
In such cases, you can write a few tracing aspects and execute the system (run your test suite or perform manual testing)
You can periodically examine the log output to see if you’ve hit the concurrency problem.
When the problem is fixed, you no longer need the aspect.
Of course, you can add it back periodically to see if there are other problems lurking as the application evolves.
Although a profiler may help with this problem, many performance issues are uncovered only during close-to-real deployment.
You then have the option to either continue using those aspects in the deployed system or take them out.
When you’re developing complex applications, you definitely need to ensure that the program elements adhere to certain policies.
In chapter 11, we discussed several examples of enforcement that you can implement using AOP.
The real value of those examples is in the techniques they present.
Whenever you come across a new policy, implement it using aspects.
Over time, you’ll collect a repertoire of aspects that you can use in existing and new projects without much effort.
You can also use a tracing aspect to get the most out of the testing effort.
During the testing phase, when you expect to uncover problems, you can use aspects to collect context information and not just exception call stacks.
When it’s time to ship the product, you can take out the context-collecting aspects.
With an AOP-based approach, you have a flexible way to collect context and maintain better control over the inclusion or exclusion of the collection logic.
When you have enough experience with development aspects, you’ll be ready to move to production aspects.
Production aspects require a bigger commitment, because unlike development aspects, you must use them in production.
You can’t, for example, have an option to exclude transaction management or security aspects.
Common aspects include those used for transaction management, security, and concurrency control.
You may find pre-built solutions for many of these functionalities in frameworks such as Spring.
If not, you should strive to create reusable aspects, because many other projects will need the same functionality.
When you’re comfortable implementing infrastructure aspects, you can look for subtler crosscutting concerns such as those in the domain logic.
You can start with domain-object dependency injection implemented using AspectJ.
Although the injection is a crosscutting concern, using the dependency isn’t; but it provides significant leeway in how you architect your system.
As we discussed in chapter 16, you may find business logic that applies to a few classes or a set of methods in a class.
You can use aspects to modularize such logic, leading toward a cleaner implementation.
Often, you may not recognize the crosscutting nature of domain logic until you’ve already implemented it.
Refactoring aspects are produced through the application of the refactoring process to extract crosscutting logic.
Because the code is already implemented along with tests, the refactoring process provides a way to modify the implementation with an assurance that the code works the same way as it did before the refactoring, even with the new aspects.
When you implement a new crosscutting concern using aspects, you’ll face challenges in approaching it.
After you’ve committed to using AOP in your organization, you need to decide whether it’s appropriate for each target problem.
You must consider an approach that will incorporate AOP while causing minimal destabilization of the overall system.
Typically, you want to apply aspects to a restricted subsystem and then, when the solutions are proven, expand the use of AOP to the whole system.
In this section, we’ll examine the two phases of applying AspectJ to a problem: deciding to use it and then using it.
How do you decide whether a concern is better addressed by AOP compared to a conventional solution? In other words, how do you know if a concern is crosscutting? You can use the following as a guide:
Will a non-AOP alternative cause code tangling? Code tangling generally accompanies code scattering, but you may see code tangling by itself.
For example, you may have just one service that uses the read-write lock based concurrency control.
A conventional implementation tangles the two functionalities: concurrency code and the service’s business logic.
Using aspects separates these two functionalities, makes them simpler to understand, and allows them to evolve separately.
It’s much like refactoring code into private methods even when you know there is only one caller.
Over time, you’ll find more modules that call for the same separation of crosscutting concerns.
Exercise caution when an AOP solution is meant to patch the underlying implementation.
It’s better to address the underlying problem than to use aspects to get around it.
When you determine that a certain functionality is a possible crosscutting concern, and you decide to use AOP to implement it, you can follow this approach:
In this step, you sketch out, design, and even prototype the conventional solution.
The idea is to first sketch the code tangling and code scattering, and then modularize it.
After you become reasonably experienced at this, you can reduce the emphasis on this step or even eliminate it.
By limiting the solution to only modules that currently need the functionality, you eliminate the impact—both positive and negative—on other modules.
The goal is to leave as much of the system unaffected as possible and reduce the testing effort required.
To do this, you can either use pointcuts such as within() to specify only join points in the modules you want to weave, or you can configure your build system to include only those modules.
Alternatively, you can use annotations to target specific program elements.
The pointcuts can select the join points that carry the annotations.
When you’re comfortable with the solution and its impact, you should modify the pointcuts or build configurations that have been limiting applicability.
For example, instead of restricting monitoring to certain modules, you lift those restrictions to let monitoring span the whole system.
This way, if a new module joins the system, it starts benefiting from the aspects right away.
This systematic approach helps you tackle almost any problem with little risk.
Experience will be your best guide in determining how much weight you should assign to each step in your system.
Let’s look at some typical ways AOP helps in each situation.
If you start using AOP in the design phase, you’ll reap the maximum benefits.
From an architectural perspective, the separation of concerns offered by AOP simplifies designing both the business logic and crosscutting concerns.
Furthermore, as discussed in chapter 16, AOP offers alternative architectural choices promoting a more domaindriven approach.
Here is a typical way to use AOP during a design phase:
As a rule of thumb, consider concerns described with an adjective or adverb starting with every, such as every time or everywhere, as possible crosscutting concerns.
Recognizing these concerns ahead of time lets you avoid the effort needed to modularize crosscutting concerns in the conventional fashion.
The better you design the business functionality, the easier it will be to apply crosscutting concerns, because it will simplify the specification of the weaving rules.
It’s also a good idea to sketch out the crosscutting concerns that you’re aware of but don’t need to address immediately.
This approach helps you avoid overdesign; and because you’ll use AOP to implement the crosscutting concerns, deferring the decision won’t lead to huge code changes.
When you use AOP in the implementation phase, you should place additional emphasis on certain common practices, as well as follow a few new guidelines to make the process of implementing the core and crosscutting concerns as easy as possible.
The decision to use AOP affects how you’ll implement the core concerns.
Fortunately, if you’re using AOP, much of the process and methodology is largely unchanged from OOP.
But paying attention to a few practices will make your job easier.
You should follow these common principles regardless of whether you use AOP:
Sticking to a consistent naming convention throughout your project will help you write pointcuts that use wildcards to select join points.
Using wildcards instead of fully specifying each join point not only makes writing aspects easier but also ensures that the aspects automatically apply to any new modules that you may add to the system later.
Most technologies such as JPA, EJB3, and Spring MVC offer a choice between annotating program elements and specifying external XML configuration.
From AOP’s perspective, using annotations is a better choice, because you can use those annotations in pointcut expressions.
In addition to these common good practices, here are some guidelines that are specific to AOP:
Separate the crosscutting concerns from the core modules in the initial phase.
When you come across a concern that affects multiple modules, apply the questions in section 17.3.1 to determine whether you should use aspects to implement the functionality.
You may decide to implement the functionality using aspects immediately or wait until the functionality is really needed.
Be on the lookout for code tangling and code scattering while implementing the core concerns; consider them a symptom of possible crosscutting concerns being implemented using OOP techniques that may be candidates for AOP.
Initially, you’ll be looking for well-known crosscutting concerns, such as tracing or security.
Later on, with experience, you’ll be able to spot more subtle crosscutting concerns and modularize them.
These steps will help you to better implement crosscutting concerns.
When you implement crosscutting concerns, you need to perform the following tasks.
It’s typical to iterate over them during the implementation phase:
In this step, you identify the places in the code that need the crosscutting behavior.
Then, you need to decide the best way to express the pointcuts that select the required join points: signature-based pointcuts, annotation-based pointcuts, control flow–based pointcuts, and so on.
If required, to help in selecting pointcuts, you may have to implement custom annotations and attach them to program elements.
To implement a crosscutting concern, you often have to decide what the underlying implementation will be.
You may want to consider using one or more of the patterns presented in chapter 12 (as well as any new patterns you’ve discovered) as a template.
Pay particular attention to using consistent naming conventions for aspects; that will simplify the process of selecting join points inside the aspects.
It will also help you when you want to specify aspect precedence.
Finally, you also need to decide whether you can create reusable aspects so that you can leverage them the next time you deal with the same crosscutting concern.
Another issue to consider is how to organize the aspects so that your build configurations are flexible and easy to work with.
To use aspects in a plug-and-play manner, you must separate them according to the functionality they implement (typically by adding them to separate packages)
A proper separation of aspects will help you to more easily configure the build system to include or exclude certain aspects in your builds.
Deployment —Certain aspects are most useful during the development phase, such as those that perform tracing for debug/profiling purposes and policy enforcement.
You’ll probably want to group these developmental aspects under a separate package so that you can easily add them to and remove them from your builds as you choose.
That way, you can take advantage of those aspects during the development phase while ensuring they don’t affect the deployed system.
Correctness —The most fundamental characteristic of any software system is its correctness—the other characteristics, such as efficiency, are secondary.
Although you may choose to remove some aspects that you used in development from your deployment build system, you must ensure that the aspects that are necessary for correctness are always included in any build target.
After the system has been implemented and deployed, the maintenance phase commences.
The maintenance phase consists primarily of two activities: adding implementations to satisfy new requirements and fixing bugs found in the deployed systems.
Creating protection walls —A big challenge during the maintenance phase is making sure that new changes don’t break other parts of the system.
Policy-enforcement aspects ensure that the new features don’t violate the policies, thus helping in preventing the introduction of new bugs.
Creating emergency patches—You may encounter situations where you need to augment or find an alternative behavior to a few methods in an existing system.
The urgency of such a need may prevent you from implementing a proper solution.
In these cases, AspectJ can provide a simpler way to patch these methods.
Emergency patches have a tendency to remain as “solutions” forever.
If too many patches are added to a system, eventually they often lead to maintenance nightmare.
If you’re like most developers, as much as you wish otherwise, you have to deal with legacy projects.
Let’s see how AOP can make your life better during that phase.
Legacy projects can be a challenge primarily for two reasons.
First, the core code may lack the clean separation of functionality that allows you to use AOP.
Second, certain crosscutting concerns may already be implemented using conventional techniques.
This may mean that you must first remove the concern from the core code and put it into aspects before improving its implementation.
Through all these steps, you need to exercise care to avoid altering the core system behavior in an undesirable way.
Begin with simple aspects, such as policy enforcements and tracing.
These aspects enable you to introduce new behavior without requiring any modifications to the core modules.
This way, you minimize the risk of inadvertently affecting the core system behavior.
The application of these aspects is limited to development, and you don’t need a commitment to use AOP in deployment.
This no-commitment, no-risk approach helps you use AOP immediately in almost any system.
For such usages, AspectJ’s LTW is often the best choice to get started.
Any serious use of AOP requires that the core code within each module implement relatively clear responsibilities.
Ensuring that this is the case and refactoring the code if necessary may require considerable effort.
Fortunately, it will help your system regardless of whether you use AOP.
For messy code bases, you may want to apply techniques described in Working Effectively with Legacy Code by Michael Feathers (Prentice Hall, 2004) to clean code before adding aspects to it.
Policy-enforcement aspects also help during application of these techniques to protect you against inadvertent violations.
While refactoring the core concern, you’ll see code-tangling and code-scattering symptoms.
Work your way through the modularization of a few prominent crosscutting concerns.
A test suite will help during this step to ensure continual conformity to core system functionality.
Now that you’ve seen how to approach AOP, let me share a few final thoughts.
Here are some additional recommendations as you move forward on your path toward becoming an AOP and AspectJ expert:
In particular, don’t worry about reusable aspects in the beginning; adding these features later, even as an afterthought, is usually better than paying an upfront cost.
Most aspects in this book are reusable, but I didn’t design them that way in my first attempts.
The typical process is to come up with the overall design, implement simple aspects that solve the problem, and then see how to generalize them into reusable aspects.
Remember your first encounter with OOP? You most likely didn’t create interfaces, function objects, and delegate objects right away.
You can refactor aspects just like you can refactor classes!
There are a couple of good mailing lists and forums that you should consider joining.
On these mailing lists, you’ll find that committers and users for the projects are ready to help anyone facing problems.
I’ll be available on Author Online at http://www.manning.com/laddad2 to help you with your questions.
These technologies have been used by thousands of developers worldwide for several years, and such heavy usage results in mature solutions.
You can use AOP to fill in the missing pieces of these technologies.
You’ll get valuable insight into the AOP philosophy and its logistical issues.
You’ll gradually become more comfortable with it and be ready to solve more complex problems.
When it comes to productivity, nothing beats reusing modules that have already been developed.
Many crosscutting concerns apply not only to multiple modules but also to multiple systems.
As you gain more experience, start paying attention to reusable parts and create reusable libraries to benefit various projects.
But keep in mind that you should always start simple.
Aspect-oriented programming helps to bring order to the chaos introduced by crosscutting concerns.
When you use it, the design is more clearly mapped to the implementation.
Nevertheless, you have to make progress—one step at a time.
Over the last decade, AOP has influenced enterprise technologies (EJB3 interceptors, monitoring solutions, transaction and security implementation), and I expect it to influence many more changes over the next decade.
To let you work with an application that represents a real-world application, this appendix sets up a base example that you’ll use throughout the book.
You’ll create an e-commerce site whose UI allows users to view product details and buy products.
The example also uses many other packages (directly and indirectly)
The downloadable sources contain a Maven build script that automates downloading dependencies and building the required artifacts.
The script shows the specific version of each of the packages used.
It also includes an Eclipse project that will let you easily experiment within the IDE environment.
I’ll only show interesting parts of the system, leaving out some details to avoid distracting from the main goal of the system: introducing various crosscutting functionalities.
You can download the complete code from the book’s web site.
Domain classes Because the domain objects form the core of an application, you’ll start with those classes.
You’ll set up a simple class structure with Product, Order, LineItem, and InventoryItem classes and their superclass, DomainEntity.
Whenever appropriate, they rely on default mapping to avoid an annotation overload.
Let’s start with the abstract base class DomainEntity in listing A.1
It represents a potentially persistent entity that has an id property.
The purpose of this class is to avoid duplicating the id-related code in each entity class.
The use of the @MappedSuperClass annotation lets mapping information come from the derived classes.
Next comes the Product subclass in listing A.2, which represents a product such as a book.
There isn’t much JPA-related code because I chose to use default column names for each field.
A LineItem represents an entry for a given product in an order.
Listing A.3 LineItem: order entry describing the product and its quantity.
Anemic domain model? This application uses an anemic domain model, where the domain model classes don’t contain interesting behaviors.
Chapter 16 deals with this question by looking into alternative architecture styles enabled by AspectJ.
The annotations are a bit more interesting here due to management of the relationship between LineItem, Product, and Order.
You also include a no-arg, private constructor to work with object-relational mapping (ORM) solutions.
Because the product price may change after you create a line item, the product price is stored when the line item is created.
Next, the Order class in listing A.4 includes a collection of LineItems.
The main functionality this class offers is adding and removing products.
It ensures that adding a product for which a line item already exists leads to updating the line item’s quantity instead of creating a new line item.
Similarly, it removes the line item when its product quantity is reduced to zero.
Like LineItem, it models the inventory associated with a product.
InventoryItem lets you deplete and replenish inventory to account for bought items, cancelled orders, and arrival of new products.
In a more complete implementation, you would have the ability to reserve items and consider items being procured.
We won’t implement those features here, to keep things simple.
Repository layer The repository, also known as the Data Access Object (DAO) layer, is responsible for allowing access to persistent objects.
Because many repositories share common methods to find, delete, and update entities, you can create a reusable interface and its implementation.
For simplicity, this implementation assumes that an entity’s id is always of the Long type.
Nothing terribly interesting here; it lets you find all entities or a single entity with the given id, update an entity, and delete it.
Subinterfaces, if required, may add methods specific to the associated entity type as shown in listing A.7
This interface adds the ability to find the inventory item associated with a product.
All repositories can use the common implementation shown in listing A.8 as the.
A specific implementation may choose to override the base implementation.
Next, you implement the repository for InventoryItem, as shown in listing A.9
Listing A.9 Inventory repository based on a common JPA repository.
You’ll now move one level up and implement the service layer.
This is also where you typically demarcate the transaction boundary (we’ll discuss that in chapter 14)
The first implementation is OrderService in listing A.10, which is responsible for managing orders: adding products to an order, placing or cancelling an order, as well as creating, querying, and deleting orders.
This example takes a simple approach to inventory management, where adding an item to an order removes it from the inventory.
This simplification allows us to focus on the core goals of the book.
A comprehensive approach would include the notion of reserving items until finalizing the order, and so on.
These annotations, along with @Autowired, can significantly reduce the amount of XML you need to write.
In this book, it also allows us to focus on the core topic: the use of aspects.
Before cancelling an order, it puts the products in the order back in inventory.
OrderServiceImpl uses InventoyService, which you implement next as shown in listing A.11
You now have all the classes required to implement a basic application.
Application configuration Following Spring best practices, you’ll split this configuration across multiple files and put them in a META-INF/spring directory.
Following another best practice, you’ll use two application contexts related by a parent-child relationship: the web application context is a child of the business application context.
The former includes webrelated artifacts such as controllers and views; the latter includes backend objects such as services, repositories, data sources and transaction management, configuration of the ORM framework, as well as applying transaction management to the service layer.
The first context file in listing A.12 uses Spring’s component-scanning feature to scan the classpath, create components, and wire them up.
You exclude the ajia.web package to let web components be created in the web context, which is a child of the application context.
Next, you set up the datasource as shown in listing A.13
You use the datasource through JPA, as shown in listing A.15
Here, you set up a JPA entity manager with Hibernate as the underlying implementation.
You also create a transaction manager based on the entity manager.
Configuring JPA requires specifying a persistence.xml file that describes the domain entities being managed by JPA and the properties for the underlying implementation, as shown in listing A.16
Finally, you set up infrastructure services—in this case, transaction management—and apply it to the service layer, as shown in listing A.17
When we discuss transaction management in chapter 14, you’ll modify this configuration to use annotation-based alternatives.
The web layer The web layer specifies view-related beans such as controllers and views.
The web application context, which is a child context of the backend application context, configures these beans.
Because it’s a child context, it can use beans such as services from the parent context.
You’ll use a recommended approach from the annotation-based Spring MVC.
Listing A.18 shows a controller that lets you view an order, add products to it, and place the order.
You similarly have controllers for viewing products, editing orders, and administrative functionality.
You create a web application context based on the controller classes, as shown in listing A.19
You also provide a view resolver to map view names into a JSP view.
Logging configuration You write a basic logging configuration, as shown in listing A.20
When you add AOP functionality, you’ll modify this base configuration appropriately.
The system includes many other classes and configuration files especially related to unit and integration testing.
But we don’t need them for our purpose of explaining the use of AOP.
Building and running the application Thanks to Maven, building and running application is easy.
You don’t need to download anything other than the Java Development Kit (JDK) and Maven.
To build the war file, issue the following command, which also runs the tests before packaging:
To deploy the application, assuming Tomcat is your web server, you can copy the war file (in the target directory) as Commerce.war to Tomcat’s webapps directory and start Tomcat (a similar process will work for other web or application servers)
Alternatively, you can run the application using embedded Tomcat by issuing the following command:
You should be able to view products, add a few to the shopping cart, and view the shopping cart.
Most developers use either Ant or Maven to build their projects.
Note that the focus of this appendix is the use of AspectJ weaver; therefore, we use the simplest Ant structure to get things done.
Let’s start with the simplest scenarios of building using source code build-time weaving.
Weaving sources As discussed in chapter 8, in source code build-time weaving, you supply the ajc compiler with classes and aspects in source-code form.
The aspects may be expressed using either traditional syntax or @AspectJ syntax.
Listing B.1 shows an Ant build file that compiles classes and aspects together.
You define the compile target by using the iajc task and specify sourceroots as a nested element.
You use the destdir attribute to specify the destination directory for the class files produced.
Alternatively, you could use the outjar attribute to specify a jar file as the destination.
The jar file produced using the outjar attribute is identical to the classes produced using the destdir attribute followed by a <jar> Ant task.
You define the run target using the java task element and specify ajia.main.Main as the class to execute.
When you execute the build file, you get output similar to the following:
Note that the iajc task allows additional options that match those of the ajc compiler.
See chapter 8 for more information about each compiler option.
Because profiling is a reusable functionality, you want to create an aspect library out of it so that you can weave it into any application that needs that functionality.
Creating an aspect library The mechanics of creating an aspect library differ from source code build-time weaving only in that you don’t pass the classes to be woven to the iajc task.
Note that if you use the @AspectJ syntax to develop a library, you can use javac to compile the aspects (optionally, you can package using the jar task)
The Ant file in listing B.2 assumes that the profiling aspect is in a separate project (along with any support classes)
The iajc task definition hasn’t changed much since listing B.1
The main change is the use of the outjar attribute instead of the destdir attribute.
Note that you could use the same definition as in listing B.1
But because it’s best to package a library as a jar, you use the outjar option.
As described in section earlier, the outjar option is merely a shortcut for compiling the classes followed by a jar task.
When you execute the build file, you see output as following:
Note the warning issued by the AspectJ weaver: it tells you that the profiling advice didn’t apply to any join points.
The warning is correct but not useful for a library aspect, because the advice will be applied only when the library is woven into other parts of the system.
To stop this warning, you need to create a file as shown in listing B.3
The levels you specify must be error, warning, or ignore.
See the AspectJ documentation for possible lint errors and warnings.
You need to specify the xlintfile properties of the iajc task to modify its error and warning reporting, as follows:
Lint is a program that flags potential problems in code written in the C programming language.
The iajc task allows the outxml attribute to specify whether the aop-ajc.xml file should be created.
Such a file enlists all the aspects supplied as the input to the compiler.
This option is useful with load-time weaving (LTW) because it obviates the need to use a separate aop.xml file (see chapter 8 for more about LTW):
Weaving into jar files To use an aspect library, you must weave it into an application.
To illustrate such weaving, you first create a jar file for your application classes without weaving any aspects in them.
Listing B.4 assumes a project with the classes by themselves.
Note that there is nothing special in this Ant file from the AspectJ perspective; you’re only interested in the final product—a jar file.
In a real application, you’ll probably start with a jar file handed to you.
When you execute this Ant file, you get an application.jar file in the dest directory.
Note that AspectJ doesn’t require that the input be a jar file; it works fine with classes.
Let’s weave application.jar with profiling.jar, which was produced in the previous section.
Listing B.5 shows an Ant file that uses the iajc task to accomplish this goal.
The iajc task in the weave target specifies application.jar as the jar file to be woven in using the inpath attribute and profiling.jar as the aspect library using the aspectpath attribute.
Each of these attributes can be specified as nested elements, which comes in handy if you need to specify multiple jar files.
As with any iajc task, you could specify the destdir attribute to produce class files instead of a jar file.
Note that we show these tasks for illustration purpose only.
In a typical enterprise application, you’ll deploy the woven jar file to the application or web server.
When you execute the Ant file for both these targets, you get the following output:
The run-normal target shows the output without any profiling information.
The run-woven target, on the other hand, shows the effect of the woven aspect.
The previous appendix examines various weaving options enabled through Ant.
Weaving sources Maven, through the open source codehaus.org project, provides a plugin to work with AspectJ (visit http://mojo.codehaus.org/aspectj-maven-plugin for details)
Let’s see this plugin in action through the Maven pom.xml file in listing C.1
Listing C.1 Maven pom.xml to perform source code build-time weaving.
When you execute the build file to install the compiled sources and execute the main class, you get output similar to the following:
Creating an aspect library As with the Ant version, building an aspect library is nothing special, except for a few additional options.
If you use the @AspectJ syntax, you don’t need to use the Maven.
AspectJ plugin; simply declare dependency on aspectjrt.jar and compile the sources.
You set that element to true to automatically generate aop-ajc.xml and include it in the output jar.
When you execute the build file, the profiling jar is installed in your Maven repository.
Next, you’ll weave this aspect library jar into another application jar file.
Listing C.4 shows the Maven pom.xml file that weaves these to produce a woven jar.
Listing C.3 Maven pom.xml to create unwoven HelloWorld application jar.
When you execute this build file, the application-woven artifact is installed in your Maven repository.
Therefore, in the downloadable sources, you’ll find a blank interface included in the src/main/java directory.
See exception-handler join point exposed, advice, on 88 field access.
AspectJ is a mature AOP implementation for Java, now integrated with Spring.
AspectJ in Action, Second Edition is a fully updated, major revision of Ramnivas Laddad’s best-selling fi rst edition.
You’ll master key features including annotation-based syntax, load-time weaver, annotation-based crosscutting, and Spring-AspectJ integration.
Building on familiar technologies such as JDBC, Hibernate, JPA, Spring Security, Spring MVC, and Swing, you’ll apply AOP to common problems encountered in enterprise applications.
Th is book requires no previous experience in AOP and AspectJ, but it assumes you’re familiar with OOP, Java, and the basics of Spring.
What’s Inside Totally revised Second Edition When and how to apply AOP Master patterns and best practices Code you can reuse in real-world applications.
An expert in enterprise Java, Ramnivas Laddad is well known in the area of AOP and Spring.
Th is book teaches you how to think in aspects.
It is essential reading for both beginners who know nothing about AOP.
Front cover brief contents contents foreword preface preface to the first edition acknowledgments about this book Roadmap Who should read this book Code and typographical conventions Getting the source code Author online About the author.
