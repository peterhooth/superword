The publisher offers discounts on this book when ordered in quantity.
No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by means electronic, mechanical, photocopying, or otherwise, without prior written permission of the publisher.
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in the book, and Manning Publications was aware of a trademark claim, the designations have been printed in initial caps or all caps.
Recognizing the importance of preserving what has been written, it is Manning’s policy to have the books we publish printed on acid-free paper, and we exert our best efforts to that end.
Recognizing also our responsibility to conserve the resources of our planet, Manning books are printed on paper that is at least 15 percent recycled and processed without the use of elemental chlorine.
To the Apache Camel community May this book be a helpful companion on your journeys with Camel.
They give us the vocabulary to express what a program should do.
They force us to encode our requirements in precise and non-ambiguous terms.
I’m talking about the languages we use to communicate from human to human, from developer to developer, or from end user to product manager.
For a long time, the world of enterprise integration (or EAI, as it was commonly known in the “dark ages of integration”) lacked such a vocabulary.
Each vendor offered a proprietary solution, which not only failed to integrate at a technical level with other vendors’ offerings, but also used a different language to describe the main components and their functions.
This not only caused confusion, but was also a key inhibitor to creating a community of developers that could span the vast space of enterprise integration.
Ironically, integration developers were faced with the same “tower of Babel” problem that their software was designed to solve!
Establishing a common vocabulary that enables knowledge sharing and collaboration was the key motivator for us to write Enterprise Integration Patterns (EIPs)
Each of the 65 patterns has a descriptive name, which represents the solution to a design challenge in the integration space.
Besides supporting effective communication, this vocabulary also raises the level of abstraction at which we can describe integration problems and solutions.
A shared vocabulary is a big step forward, but a giant step we could not imagine at the time was that our language would spur the development of a whole family of open.
These tools embrace the EIP vocabulary by implementing many patterns directly in the platform.
With Apache Camel, a Splitter pattern translates directly into a “split” element in the Camel DSL.
We couldn’t have wished for a more direct translation of the pattern language into an implementation platform.
Claus and Jon bring the saga to a grand finale by showing us how to use the Camel pattern language to compose real-life messaging solutions.
In doing so, they not only cover fundamental concepts like routing and transformation, but also dig into oftenneglected parts of the development process, including testing, monitoring, and deploying.
They find the right balance of the pattern language, Camel core concepts, and running code to help you build easy-to-understand and robust messaging solutions.
I found that Enterprise Integration Patterns were becoming increasingly central to what we were doing on these projects and how we were using them; the only difference was the context and technologies with which we were using the patterns.
There have been many libraries and frameworks over the years to help with integration.
But frequently the concepts behind the Enterprise Integration Patterns get transformed into some complex class hierarchies or objects that need to be wired together just so, and the original intentions and patterns are often lost.
The developer is forced from then on to focus on the low-level detail and some complex class library API, losing the bigger picture and patterns.
Integration is hard and once you start down the path of integrating things together xix.
So we decided it was time for a new integration framework that put the EIPs at its core and tried to raise the abstraction level so that developers could describe declaratively in very concise terms what Enterprise Integration Patterns they wanted to use in a simple domain-specific language.
Using a convention over configuration approach, developers would declaratively describe what they wanted to do, using the Enterprise Integration Pattern language; it would be both quick and easy to get things done and.
There are many different places we wanted to use the EIPs; whether in a standalone application, a web services stack, an enterprise message broker like Apache ActiveMQ, or inside a full-blown ESB like Apache ServiceMix, so we wanted a lightweight framework that was middleware agnostic that users could embed anywhere they wanted it.
We also wanted developers to focus on the Enterprise Integration Patterns first and foremost and not to get lost in the weeds of different middleware APIs and technologies.
We also wanted developers to be able to use whatever DSL flavor they wished (whether Java, XML, Groovy, Ruby, Scala, or whatever) and yet, at runtime, still be able to introspect the framework and understand all of the EIPs that were being used.
They would be able to visualize the core patterns to the team at any point in the project lifecycle, auto-document the patterns, or even support things like graphical editing of the Enterprise Integration Patterns at design time or runtime.
So Apache Camel was born, and since then we’ve seen the codebase, community, and number of components, technologies, and data formats grow massively as more and more developers have found Apache Camel an ideal way to design, implement, and maintain the Enterprise Integration Patterns.
Then they walk you through how to take the concepts and apply them to many real-life scenarios to provide scalable and efficient solutions that are easy to understand and quick to adapt to your integration needs.
I hope you’ll enjoy reading this book as much as I did!
As a developer, you end up spending a considerable amount of time working with the plumbing of the integration protocols to open up the IT systems to the outside world.
In Enterprise Integration Patterns, Gregor Hohpe and Bobby Woolf gave us a standard way to describe, document, and implement complex integration problems.
Developers and architects alike can use this common language and catalog of solutions to tackle their integration problems.
But although Hohpe and Woolf gave us the theory, the industry still needed an open source implementation of the book.
Apache Camel is an integration framework whose main goal is to make integration easier.
It implements many of the EIP patterns and allows you to focus on solving business problems, freeing you from the burden of plumbing.
Using connectivity components has never been easier, because you don’t have to implement JMS message listeners or FTP clients, deal with converting data between protocols, or mess with the raw details of HTTP requests.
All of this is taken care of by Camel, which makes mediation and routing as easy as writing a few lines of Java code or XML in a Spring XML file.
PREFACExxii Apache Camel has since become very popular and today has an ever-growing community.
As with many open source projects that become popular, a logical next step is for someone to write a book about the project.
Hadrian Zbarcea, the Project Management Committee chair of the Apache Camel project, realized this, and in early 2009 he contacted Manning to discuss the need for such a book.
Hadrian got in touch with me (Claus Ibsen), inviting me in as a coauthor.
It was perfect timing, as I was taking over from James Strachan as the lead on Apache Camel.
Later that year, Hadrian had to step down as an author, but he invited Jonathan Anstey in as his replacement, to ensure the project could continue.
Jonathan and I are both integration specialists working for FuseSource, which is the professional company that offers enterprise services around various Apache projects.
This book is written by the people who wrote the Camel code, which ensures you have the most updated Camel book on the market.
Writing this book has been a very intense journey, proven by the fact that we were able to complete the manuscript in a year.
It took a long time to implement the examples and to ensure that the accompanying source code is of the highest standard.
But the result is a great source of examples that should inspire you to get the best out of Camel, and it should be a good starting point for your Camel projects.
While we were writing this book, we were also implementing new features in Camel, which often meant we had to go back and revise the material along the way.
But we have kept up, and this book uses the latest Camel release at the time of writing (Camel 2.5)
We hope this book brings great value to you and helps you prosper in the Camel community.
We’d also like to thank our awesome copy editor, Andy Carroll, for catching an amazing number of grammatical errors in the early revisions of the book.
The greater Manning team deserves kudos as well; they’ve made for a very pleasant writing experience over the past year and a half.
Special thanks to Willem Jiang for being our technical proofreader, catching those bugs we missed, and helping improve the source code for the book.
Thanks to Martin Krasser for contributing appendix E, which is all about using Camel from the Akka project.
We couldn’t think of a better person to write about Camel and Akka.
We’d also like to thank Hadrian Zbarcea for getting this book project started—who knows when this book would have been written or by whom if he hadn’t gotten us together!
We’d like to thank Gregor Hohpe and James Strachan for writing the forewords to our book.
Gregor’s book, Enterprise Integration Patterns, has been one of our favorite.
Without the EIP book, Apache Camel would look a lot different than it does today, if it existed at all.
In our opinion, James is an inspiration to many developers out there—including us.
He has co-founded tons of successful open source projects; Camel is just one of them.
If James and the other Apache Camel co-founders had not decided to create Camel, we wouldn’t be writing this book.
Finally, we’d like to give a big warm thank you to the community.
Without the community, the Apache Camel project wouldn’t be as successful as it is today.
In fact, without the success, both of us would have different kinds of jobs today, which wouldn’t involve hacking on Camel all day along.
Knowing that you would never let my hand go, that the family life is safe and secure, is exactly the support any writer needs in taking up such a big challenge as writing a book.
A warm thank you goes to our dog, Bambi, who patiently sleeps in my office, and occasionally wakes up and politely “asks” me for a break and a walk.
I must admit many of the ideas and thoughts behind this book came to me during my walks with Bambi.
It simply would not have happened if it wasn’t for you.
To Georgia, my beautiful daughter: thank you for cheering me up when the writing got the better of me.
Camel’s online documentation serves as a reference for its many features and components.
In contrast, this book aims to guide readers through these features, starting with the simple points and building up to advanced Camel usage by the end of the book.
Throughout the book, Camel’s features are put into action in real-life scenarios.
Part 1 starts off simple by introducing you to Camel’s core functionality and concepts, and it presents some basic examples.
Chapter 1 introduces you to Camel and explains what Camel is and where it fits into the bigger enterprise software picture.
Chapter 2 covers Camel’s main feature, which is message routing.
The Java DSL and Spring DSL are covered as are several enterprise integration patterns (EIPs)
Chapter 3 explains how Camel can help you transform your data to different formats while it’s being routed.
Chapter 7 covers the most heavily used components among Camel’s large selection of components.
Chapter 8 looks in depth at five of the most complex EIPs.
In part 3 we cover the topics that are useful when you’ve gained a better understanding of Camel from the earlier chapters.
In chapter 12 we cover how to manage and monitor Camel applications.
Among other things, how to read the Camel logs and how to control Camel with JMX are covered.
In chapter 13 we discuss the many ways to start and stop Camel.
Deployment to several of the most popular containers is also discussed.
Chapter 14 covers what we consider extra features of Camel: routing with beans and using remoting to hide Camel APIs.
We consider this extra because these features do routing without using any of Camel’s DSLs and in some cases with no Camel APIs.
They take a different approach than what was discussed throughout the book.
The appendixes at the end of the book contain useful reference material on the Simple expression language, expressions and predicates, the producer and consumer templates, and the Camel community.
Appendix E is written by Martin Krasser and shows how to use Akka with Camel.
Who should read this book We wrote this book primarily for developers who have found the online Camel documentation lacking and needed a guidebook that explained things in a more detailed and organized way.
Although we mainly targeted existing Camel users, Camel in Action.
Experienced engineers and architects are also encouraged to read this book, as it explains advanced Camel concepts that you just can’t find elsewhere.
Test and Q&A engineers will find Camel and this book useful as a means of driving tests that require communication with various transports and APIs.
System administrators, too, may find the management, monitoring, and deployment topics of great value.
Camel’s features are focused on the enterprise business community and its needs, but it’s also a generic and very useful integration toolkit.
Any Java developer who needs to send a message somewhere will probably find Camel and this book useful.
All source code in listings or in text is in a fixed-width font like this to separate it from ordinary text.
Code annotations accompany many of the listings, highlighting important concepts.
In some cases, numbered bullets link to explanations that follow the listing.
Software requirements The following software is required to run the examples:
Apache Camel can be downloaded from its official website: http://camel.apache.org/ download.html.
Chapter 1 shows you how to get started with Maven and run the examples.
Author Online The purchase of Camel in Action includes free access to a private web forum run by Manning Publications, where you can make comments about the book, ask technical questions, and receive help from the authors and from other users.
This page provides information on how to get on the forum once you’re registered, what kind of help is available, and the rules of conduct on the forum.
Manning’s commitment to our readers is to provide a venue where a meaningful dialogue between individual readers and between readers and the authors can take place.
It is not a commitment to any specific amount of participation on the part of the authors, whose contribution to the forum remains voluntary (and unpaid)
We suggest you try asking the authors some challenging questions, lest their interest stray!
The Author Online forum and the archives of previous discussions will be accessible from the publisher’s website as long as the book is in print.
The title page is missing from the collection and we have been unable to track it down to date.
The book’s table of contents identifies the figures in both English and French, and each illustration also bears the names of two artists who worked on it, both of whom would no doubt be surprised to find their art gracing the front cover of a computer programming book.
The collection was purchased by a Manning editor at an antiquarian flea market in the “Garage” on West 26th Street in Manhattan.
The seller was an American based in Ankara, Turkey, and the transaction took place just as he was packing up his stand for the day.
The Manning editor did not have on his person the substantial amount of xxix.
With the seller flying back to Ankara that evening, the situation was getting hopeless.
What was the solution? It turned out to be nothing more than an oldfashioned verbal agreement sealed with a handshake.
The seller simply proposed that the money be transferred to him by wire and the editor walked out with the bank information on a piece of paper and the portfolio of images under his arm.
Needless to say, we transferred the funds the next day, and we remain grateful and impressed by this unknown person’s trust in one of us.
It recalls something that might have happened a long time ago.
They recall the sense of isolation and distance of that period—and of every other historic period except our own hyperkinetic present.
Dress codes have changed since then and the diversity by region, so rich at the time, has faded away.
It is now often hard to tell the inhabitant of one continent from another.
Perhaps, trying to view it optimistically, we have traded a cultural and visual diversity for a more varied personal life.
Or a more varied and interesting intellectual and technical life.
We at Manning celebrate the inventiveness, the initiative, and, yes, the fun of the computer business with book covers based on the rich diversity of regional life of two centuries ago‚ brought back to life by the pictures from this collection.
He has often worked with integration in various forms, from integrating with legacy systems on AS/400s to building custom in-house integration frameworks.
Claus has designed and architected a large solution for custom clearance for the district of Shanghai, China.
He currently holds a position as principal software engineer at FuseSource, as project lead on Apache Camel.
Claus has ambitions to pick up speaking engagements, so you will likely be able to catch up with him at various conferences.
Claus lives in Sweden near Malmo with his wife and dog, which is spoiled as the only child in the family.
He got involved in the Apache Camel project in early 2008 and hasn’t looked back since.
Most recently, Jon has been working on Apache Camel and other Apache open source projects at FuseSource.
When Jon is not hacking on Camel, he likes to spend time with his wife and daughter in St.
Apache Camel is an open source integration framework that aims to make integrating systems easier.
In the first chapter of this book we’ll introduce you to Camel and show you how it fits into the bigger enterprise software picture.
Chapter 2 focuses on one of Camel’s most important features: message routing.
Camel has two main ways of defining routing rules: the Java-based domainspecific language (DSL) and the Spring XML configuration format.
In addition to these route-creation techniques, we’ll show you how to design and implement solutions to enterprise integration problems using enterprise integration patterns (EIPs) and Camel.
You can’t finalize a jigsaw puzzle until you have a complete set of pieces that plug into each other simply, seamlessly, and robustly.
But whereas jigsaw puzzle pieces are made to plug into each other, the systems we integrate rarely are.
As an integrator, you’re less concerned about how the system you integrate works and more focused on how to interoperate with it from the outside.
A good integration framework provides simple, manageable abstractions for the complex systems you’re integrating and the “glue” for plugging them together seamlessly.
In this book, we’ll help you understand what Camel is, how to use it, and why we think it’s one of the best integration frameworks out there.
Building complex systems from scratch is a very costly endeavor, and one that’s almost never successful.
An effective and less risky alternative is to assemble a system like a jigsaw puzzle from existing, proven components.
This chapter will start off by introducing Camel and highlighting some of its core features.
We’ll then take a look at the Camel distribution and explain how you can run the Camel examples in the book.
We’ll round off the chapter by bringing core Camel concepts to the table so you can understand Camel’s architecture.
Camel is an integration framework that aims to make your integration projects productive and fun.
We’re confident that by the time you finish reading these pages, you’ll appreciate Camel and add it to your “must have” list of tools.
The Apache Camel project was named Camel simply because the name is short and easy to remember.
Rumor has it the name may be inspired by the fact that one of the founders once smoked Camel cigarettes.
At the Camel website a FAQ entry (http://camel.apache.org/why-the-name-camel.html) lists other lighthearted reasons for the name.
At the core of the Camel framework is a routing engine, or more precisely a routingengine builder.
It allows you to define your own routing rules, decide from which sources to accept messages, and determine how to process and send those messages to other destinations.
Camel uses an integration language that allows you to define complex routing rules, akin to business processes.
One of the fundamental principles of Camel is that it makes no assumptions about the type of data you need to process.
This is an important point, because it gives you, the developer, an opportunity to integrate any kind of system, without the need to convert your data to a canonical format.
Camel offers higher-level abstractions that allow you to interact with various systems using the same API regardless of the protocol or data type the systems are using.
Components in Camel provide specific implementations of the API that target different protocols and data types.
Out of the box, Camel comes with support for over 80 protocols and data types.
Its extensible and modular architecture allows you to implement and seamlessly plug in support for your own protocols, proprietary or not.
These architectural choices eliminate the need for unnecessary conversions and make Camel not only faster but also very lean.
As a result, it’s suitable for embedding into other projects that require Camel’s rich processing capabilities.
Other open source projects, such as Apache ServiceMix and ActiveMQ, already use Camel as a way to carry out enterprise integration.
Camel isn’t an enterprise service bus (ESB), although some call Camel a lightweight ESB because of its support for routing, transformation, monitoring, orchestration, and so forth.
Introducing Camel container or a reliable message bus, but it can be deployed in one, such as OpenESB or the previously mentioned ServiceMix.
For that reason, we prefer to call Camel an integration framework rather than an ESB.
To understand what Camel is, it helps to look at its main features.
Camel introduces a few novel ideas into the integration space, which is why its authors decided to create Camel in the first place, instead of using an existing framework.
We’ll explore the rich set of Camel features throughout the book, but these are the main ideas behind Camel:
Let’s dive into the details of each of these features.
The core feature of Camel is its routing and mediation engine.
A routing engine will selectively move a message around, based on the route’s configuration.
In Camel’s case, routes are configured with a combination of enterprise integration patterns and a domain-specific language, both of which we’ll describe next.
Although integration problems are diverse, Gregor Hohpe and Bobby Woolf noticed that many problems and their solutions are quite similar.
They cataloged them in their book Enterprise Integration Patterns, a must-read for any integration professional (http://www.enterpriseintegrationpatterns.com)
If you haven’t read it, we encourage you to do so.
At the very least, it will help you understand Camel concepts faster and easier.
The enterprise integration patterns, or EIPs, are helpful not only because they provide a proven solution for a given problem, but also because they help define and communicate the problem itself.
Patterns have known semantics, which makes communicating problems much easier.
The difference between using a pattern language and describing the problem at hand is similar to using spoken language rather than sign language.
If you’ve ever visited a foreign country, you’ve probably experienced the difference.
Although EIPs describe integration problems and solutions and also provide a common vocabulary, the vocabulary isn’t formalized.
Camel tries to close this gap by providing a language to describe the integration solutions.
There’s almost a one-to-one relationship between the patterns described in Enterprise Integration Patterns and the Camel DSL.
Camel’s domain-specific language (DSL) is a major contribution to the integration space.
A few other integration frameworks currently feature a DSL (and some allow you to use XML to describe routing rules), but unlike Camel their DSLs are based on custom languages.
Camel is unique because it offers multiple DSLs in regular programming languages such as Java, Scala, Groovy, and it also allows routing rules to be specified in XML.
The purpose of the DSL is to allow the developer to focus on the integration problem rather than on the tool—the programming language.
Although Camel is written mostly in Java, it does support mixing multiple programming languages.
Each language has its own strengths, and you may want to use different languages for different tasks.
You have the freedom to build a solution your own way with as few constraints as possible.
Here are some examples of the DSL using different languages and staying functionally equivalent:
These examples are real code, and they show how easily you can route files from a folder to a JMS queue.
Because there’s a real programming language underneath, you can use the existing tooling support, such as code completion and compiler error detection, as illustrated in figure 1.1
Figure 1.1 Camel DSLs use real programming languages like Java, so you can use existing tooling support.
Here you can see how the Eclipse IDE’s autocomplete feature can give us a list of DSL terms that are valid to use.
Camel provides an extensive library of more than 80 components.
These components enable Camel to connect over transports, use APIs, and understand data formats.
Camel can route any kind of payload—you aren’t restricted to carrying XML payloads.
This freedom means that you don’t have to transform your payload into a canonical format to facilitate routing.
Camel has a modular architecture, which allows any component to be loaded into Camel, regardless of whether the component ships with Camel, is from a third party, or is your own custom creation.
Beans (or POJOs) are considered first-class citizens in Camel, and Camel strives to let you use beans anywhere and anytime in your integration projects.
This means that in many places you can extend Camel’s built-in functionality with your own custom code.
Chapter 4 has a complete discussion of using beans within Camel.
The convention over configuration paradigm is followed whenever possible, which minimizes configuration requirements.
In order to configure endpoints directly in routes, Camel uses an easy and intuitive URI configuration.
For example, you could configure a file consumer to scan recursively in a subfolder and include only a .txt file, as follows:
Camel has a built-in type-converter mechanism that ships with more than 150 converters.
You no longer need to configure type-converter rules to go from byte arrays to strings, for example.
And if you find a need to convert to types that Camel doesn’t support, you can create your own type converter.
The best part is that it works under the hood, so you don’t have to worry about it.
The Camel components also leverage this feature; they can accept data in most types and convert the data to a type they’re capable of using.
This feature is one of the top favorites in the Camel community.
You may even start wondering why it wasn’t provided in Java itself! Chapter 3 covers more about type converters.
Camel’s core can be considered pretty lightweight, with the total library coming in at about 1.6 MB and only having a dependency on Apache Commons Logging and FuseSource Commons Management.
This makes Camel easy to embed or deploy anywhere you like, such as in a standalone application, web application, Spring application, Java.
Camel was designed not to be a server or ESB but instead to be embedded in whatever platform you choose.
Camel provides a Test Kit that makes it easier for you to test your own Camel applications.
The same Test Kit is used extensively to test Camel itself, and it includes more than 6,000 unit tests.
The Test Kit contains test-specific components that, for example, can help you mock real endpoints.
It also contains setup expectations that Camel can use to determine whether an application satisfied the requirements or failed.
This is essential if you intend to use any open source project in your application.
Inactive projects have little community support, so if you run into issues, you’re on your own.
With Camel, if you’re having any trouble, users and developers alike will come to your aid promptly.
Now that you’ve seen the main features that make up Camel, we’ll get a bit more hands on by looking at the Camel distribution and trying out an example.
In this section, we’ll show you how to get your hands on a Camel distribution, explain what’s inside, and then run an example using Apache Maven.
After this, you’ll know how to run any of the examples from the book’s source code.
On that page you’ll see a list of all the Camel releases and also the downloads for the latest release.
For the purposes of this book, we’ll be using Camel 2.5.0
To get this version, click on the Camel 2.5.0 Release link and near the bottom of the page you’ll find two binary distributions: the zip distribution is for Windows users, and the tar.gz distribution is for Unix/Linux/Cygwin users.
When you’ve downloaded one of the distributions, extract it to a location on your hard drive.
Open up a command prompt, and go to the location where you extracted the Camel distribution.
Issuing a directory listing here will give you something like this:
As you can see, the distribution is pretty small, and you can probably guess what each directory contains already.
You’ll see later in the chapter how Maven can be used to easily grab dependencies for the components outside the core.
Because this is an Apache project, the license is the Apache License, version 2.0
So far, we’ve shown you how to get a Camel distribution and we’ve explored what’s inside.
At this point, feel free to explore the distribution; all examples have instructions to help you figure them out.
From this point on, though, we won’t be using the distribution at all.
The examples in the book’s source all use Apache Maven, which means that Camel libraries will be downloaded automatically for you—there’s no need to make sure the Camel distribution’s libraries are on the path, for example.
The first example we’ll look at can be considered the “hello world” of integrations: routing files.
Suppose you need to read files from one directory (data/inbox), process them in some way, and write the result to another directory (data/outbox)
For simplicity, you’ll skip the processing, so your output will be merely a copy of the original file.
It looks pretty simple, right? Here’s a possible solution using pure Java (with no Camel)
Listing 1.1 Routing files from one folder to another in plain Java.
Figure 1.2 Files are routed from the data/inbox directory to the data/outbox directory.
You have to use low-level file APIs and ensure that resources get closed properly, a task that can easily go wrong.
Also, if you wanted to poll the data/ inbox directory for new files, you’d need to set up a timer and also keep track of which files you’ve already copied.
Integration tasks like these have been done thousands of times before—you shouldn’t ever need to code something like this by hand.
Let’s see what a polling solution looks like if you use an integration framework like Apache Camel.
Listing 1.2 Routing files from one folder to another with Apache Camel.
Most of this code is boilerplate stuff when using Camel.
Every Camel application uses a CamelContext that’s subsequently started and then stopped.
You also add a sleep method to allow your simple Camel application time to copy the files.
What you should really focus on in listing 1.2 is the route B.
Routes in Camel are defined in such a way that they flow when read.
This route can be read like this: consume messages from file location data/inbox with the noop option set, and send to file location data/outbox.
The noop option tells Camel to leave the source file as is.
If you didn’t use this option, the file would be moved.
Most people who have never seen Camel before will be able to understand what this route does.
You may also want to note that, excluding the boilerplate code, you created a file-polling route in just one line of Java code B.
To run this example, you’ll need to download and install Apache Maven from the Maven site at http://maven.apache.org/download.html.
Once you have Maven up and working, open a terminal and browse to the chapter1/file-copy directory of the book’s source.
If you take a directory listing here, you’ll see several things:
Newer versions of Maven may not work or appear exactly as we’ve shown.
Maven itself is a complex topic, and we won’t go into great detail here.
We’ll give you enough information to be productive with the examples in this book.
For an in-depth look at Maven, we recommend reading Maven by Example and Maven: The Complete Reference, both of which are freely available from http://www.sonatype.com/book.
We’ll also discuss using Maven to develop Camel applications in chapter 11, so there’s a good deal of information there too.
The Maven POM in listing 1.3 is probably one of the shortest POMs you’ll ever see—almost everything uses the defaults provided by Maven.
Besides those defaults, there are also some settings configured in the parent POM B.
Probably the most important section to point out here is the dependency on the Camel library C.
Create a search path based on the groupId, artifactId, and version.
The version element is set to the camel-version property, which is defined in the POM referenced in the parent element B, and will resolve to 2.5.0
The type of dependency was not specified, so the JAR file type will be assumed.
This JAR will be saved to Maven’s local download cache, which is typically located in the home directory under .m2/repository.
When the application code in listing 1.2 is started, the Camel JAR will be added to the classpath.
To run the example in listing 1.2, use the following command:
A broadband speed connection is preferable because Apache Maven will download many JAR dependencies of the examples, some of which are large.
The whole set of examples will download about 140 MB of libraries.
Run the Maven command from the chapter1/file-copy directory, and after it completes, browse to the data/outbox folder to see the file copy that has just been made.
Congratulations, you’ve just run your first Camel example! It was a simple example, but knowing how it’s set up will enable you to run pretty much any of the book’s examples.
We now need to cover some Camel basics and the integration space in general to ensure that you’re well prepared for using Camel.
We’ll turn our attention to the message model, the architecture, and a few other Camel concepts.
Most of the abstractions are based on known service-oriented architecture (SOA) and EIP concepts and retain their names and semantics.
In Camel, there are two abstractions for modeling messages, both of which we’ll cover in this section.
This exchange of messages has an “in” message and as a reply, an “out” message.
We’ll start by looking at Message to understand how data is modeled and carried in Camel.
Then we’ll look at how a “conversation” is modeled in Camel by the Exchange.
Messages are the entities used by systems to communicate with each other when using messaging channels.
Messages flow in one direction from a sender to a receiver, as illustrated in figure 1.3
Messages have a body (a payload), headers, and optional attachments, as illustrated in figure 1.4
The identifier’s uniqueness is enforced and guaranteed by the message creator, it’s protocol dependent, and it doesn’t have a guaranteed format.
For protocols that don’t define a unique message identification scheme, Camel uses its own UID generator.
Headers are values associated with the message, such as sender identifiers, hints about content encoding, authentication information, and so on.
Headers are name-value pairs; the name is a unique, case-insensitive string, and the value is of type java.
This means that Camel imposes no constraints on the type of the headers.
A message can also have optional attachments, which are typically used for the web service and email components.
Figure 1.3 Messages are entities used to send data from one system to another.
Figure 1.4 A message can contain headers, attachments, and a body.
That means that a message can store any kind of content.
It also means that it’s up to the application designer to make sure that the receiver can understand the content of the message.
When the sender and receiver use different body formats, Camel provides a number of mechanisms to transform the data into an acceptable format, and in many cases the conversion happens automatically with type converters, behind the scenes.
Some protocols and specifications, such as WSDL and JBI, distinguish between output and fault messages.
They’re both valid responses to invoking an operation, but the latter indicates an unsuccessful outcome.
They’re part of the contract between the client and the server and are handled at the application level.
An exchange in Camel is the message’s container during routing.
An exchange also provides support for the various types of interactions between systems, also known as message exchange patterns (MEPs)
MEPs are used to differentiate between one-way and request-response messaging styles.
The Camel exchange holds a pattern property that can be either.
For example, HTTP-based transports are often request reply, where a client requests to retrieve a web page, waiting for the reply from the server.
Figure 1.5 illustrates the contents of an exchange in Camel.
Let’s look at the elements of figure 1.5 in more detail:
Camel will generate a default unique ID, if you don’t explicitly set one.
MEP—A pattern that denotes whether you’re using the InOnly or InOut messaging style.
When the pattern is InOnly, the exchange contains an in message.
For InOut, an out message also exists that contains the reply message for the caller.
It also has an in message to store the incoming message and an out message to store the result.
Properties—Similar to message headers, but they last for the duration of the entire exchange.
Properties are used to contain global-level information, whereas message headers are specific to a particular message.
Camel itself will add various properties to the exchange during routing.
You, as a developer, can store and retrieve properties at any point during the lifetime of an exchange.
Out message—This is an optional message that only exists if the MEP is InOut.
We discussed Camel’s message model before the architecture because we wanted you to have a solid understanding of what a message is in Camel.
After all, the most important aspect of Camel is routing messages.
You’re now well prepared to learn more about Camel and its architecture.
We’ll first take a look at the highlevel architecture and then drill down into the specific concepts.
After you’ve read this section, you should be caught up on the integration lingo and be ready for chapter 2, where we’ll explore Camel’s routing capabilities.
We think that architectures are best viewed first from high above.
Figure 1.6 shows a high-level view of the main concepts that make up Camel’s architecture.
A DSL wires endpoints and processors together to form routes.
Figure 1.6 At a high level, Camel is composed of processors, components, and routes.
The routing engine uses routes as specifications for where messages are routed.
Routes are defined using one of Camel’s domain-specific languages (DSLs)
Processors are used to transform and manipulate messages during routing and also to implement all the EIP patterns, which have corresponding keywords in the DSL languages.
Components are the extension points in Camel for adding connectivity to other systems.
To expose these systems to the rest of Camel, components provide an endpoint interface.
With that high-level view out of the way, let’s take a closer look at the individual concepts in figure 1.6
Figure 1.6 revealed many new concepts, so let’s take some time to go over them one by one.
You may have guessed that the CamelContext is a container of sorts, judging from figure 1.6
You can think of it as Camel’s runtime system, which keeps all the pieces together.
Figure 1.7 shows the most notable services that the CamelContext keeps together.
As you can see from figure 1.7, there are a lot of services for the CamelContext to keep track of.
The details of each of these services will be discussed throughout the book.
Let’s now take a look at routes and Camel’s routing engine.
Camel is capable of loading components on the fly either by autodiscovery on the classpath or when a new bundle is activated in an OSGi container.
Camel has a mechanism that allows you to manually or automatically convert from one type to another.
Figure 1.7 The CamelContext provides access to many useful services, the most notable being components, type converters, a registry, endpoints, routes, data formats, and languages.
Camel’s routing engine is what actually moves messages under the hood.
This engine isn’t exposed to the developer, but you should be aware that it’s there and that it does all the heavy lifting, ensuring that messages are routed properly.
The simplest way to define a route is as a chain of processors.
There are many reasons for using routers in messaging applications.
By decoupling clients from servers, and producers from consumers, routes can.
Each route in Camel has a unique identifier that’s used for logging, debugging, monitoring, and starting and stopping routes.
Routes also have exactly one input source for messages, so they’re effectively tied to an input endpoint.
To wire processors and endpoints together to form routes, Camel defines a DSL.
In Camel, DSL means a fluent Java API that contains methods named for EIP terms.
Here, in a single Java statement, you define a route that consumes files from a file endpoint.
Messages are then routed to the filter EIP, which will use an XPath predicate to.
Registry Contains a registry that allows you to look up beans.
It can also be an OSGi registry if you use Camel in an OSGi container.
Camel allows you to use many different languages to create expressions.
You’ll get a glimpse of the XPath language in action when we cover the DSL.
A complete reference to Camel’s own Simple expression language is available in appendix A.
If a message passes the test, it’s forwarded to the JMS endpoint.
Camel provides multiple DSL languages, so you could define the same route using the Spring DSL, like this:
The DSLs provide a nice abstraction for Camel users to build applications with.
Under the hood, though, a route is actually composed of a graph of processors.
Let’s take a moment to see what a processor really is.
The processor is a core Camel concept that represents a node capable of using, creating, or modifying an incoming exchange.
During routing, exchanges flow from one processor to another; as such, you can think of a route as a graph having specialized processors as the nodes, and lines that connect the output of one processor to the input of another.
Many of the processors are implementations of EIPs, but one could easily implement their own custom processor and insert it into a route.
So how do exchanges get in or out of this processor graph? To find out, we’ll need to look at both components and endpoints.
To date, there are over 80 components in the Camel ecosystem that range in function from data transports, to DSLs, data formats, and so on.
From a programming point of view, components are fairly simple: they’re associated with a name that’s used in a URI, and they act as a factory of endpoints.
For example, a FileComponent is referred to by file in a URI, and it creates FileEndpoints.
The endpoint is perhaps an even more fundamental concept in Camel.
An endpoint is the Camel abstraction that models the end of a channel through which a system can send or receive messages.
Figure 1.8 An endpoint acts as a neutral interface allowing systems to integrate.
At runtime, Camel will look up an endpoint based on the URI notation.
The scheme B denotes which Camel component handles that type of endpoint.
In this case, the scheme of file selects the FileComponent.
The FileComponent then works as a factory creating the FileEndpoint based on the remaining parts of the URI.
The context path data/ inbox C tells the FileComponent that the starting folder is data/inbox.
Figure 1.10 shows how an endpoint works together with an exchange, producers, and consumers.
At first glance, figure 1.10 may seem a bit overwhelming, but it will all make sense in a few minutes.
In a nutshell, an endpoint acts as a factory for creating consumers and producers that are capable of receiving and sending messages to a particular endpoint.
We didn’t mention producers or consumers in the high-level view of Camel in figure 1.6, but they’re important concepts.
A producer is the Camel abstraction that refers to an entity capable of creating and sending a message to an endpoint.
Figure 1.10 illustrates where the producer fits in with other Camel concepts.
When a message needs to be sent to an endpoint, the producer will create an exchange and populate it with data compatible with that particular endpoint.
For example, a FileProducer will write the message body to a file.
This is an important feature in Camel, because it hides the complexity of interacting with particular transports.
All you need to do is route a message to an endpoint, and the producer does the heavy lifting.
Figure 1.9 Endpoint URIs are divided into three parts: a scheme, a context path, and options.
Figure 1.10 How endpoints work with producers, consumers, and an exchange.
A consumer is the service that receives messages produced by a producer, wraps them in an exchange, and sends them to be processed.
Consumers are the source of the exchanges being routed in Camel.
Looking back at figure 1.10, we can see where the consumer fits in with other Camel concepts.
To create a new exchange, a consumer will use the endpoint that wraps the payload being consumed.
A processor is then used to initiate the routing of the exchange in Camel using the routing engine.
In Camel there are two kinds of consumers: event-driven consumers and polling consumers.
The differences between these consumers are important, because they help solve different problems.
The most familiar consumer is probably the event-driven consumer, which is illustrated in figure 1.11
This kind of consumer is mostly associated with client-server architectures and web services.
It’s also referred to as an asynchronous receiver in the EIP world.
An event-driven consumer listens on a particular messaging channel, usually a TCP/IP port or a JMS queue, and waits for a client to send messages to it.
When a message arrives, the consumer wakes up and takes the message for processing.
The other kind of consumer is the polling consumer illustrated in figure 1.12
In contrast to the event-driven consumer, the polling consumer actively goes and fetches messages from a particular source, such as an FTP server.
The polling consumer is also known as a synchronous receiver in EIP lingo, because it won’t poll for more messages until it has finished processing the current message.
A common flavor of the polling consumer is the scheduled polling consumer, which polls at scheduled intervals.
File, FTP, and email transports all use scheduled polling consumers.
With this new knowledge, you can revisit your first Camel ride and see what’s really happening.
Recall that in your first Camel ride (section 1.2.2), you read files from one directory (data/inbox) and wrote the results to another directory (data/outbox)
Now that you know the core Camel concepts, you can put this example in perspective.
Figure 1.11 An event-driven consumer waits idle until a message arrives, at which point it wakes up and consumes the message.
Figure 1.12 A polling consumer actively checks for new messages.
In this example, you first create a CamelContext, which is the Camel runtime.
You then add the routing logic using a RouteBuilder and the Java DSL B.
By using the DSL, you can cleanly and concisely let Camel instantiate components, endpoints, consumers, producers, and so on.
All you have to focus on is defining the routes that matter for your integration projects.
Under the hood, though, Camel is accessing the FileComponent, and using it as a factory to create the endpoint and its producer.
The same FileComponent is used to create the consumer side as well.
You saw how Camel simplifies integration by relying on known EIPs.
You also saw Camel’s DSL, which aims to make Camel code self documenting and keeps developers focused on what the glue code does, not how it does it.
We covered Camel’s main features, what Camel is and isn’t, and where it can be used.
We looked at how Camel provides abstractions and an API that work over a large range of protocols and data formats.
At this point, you should have a good understanding of what Camel does and what the concepts behind Camel are.
Soon you’ll be able to confidently browse Camel applications and get a good idea of what they do.
In the rest of the book, we’ll explore Camel’s features and give you practical solutions you can apply in everyday integration scenarios.
We’ll also explain what’s going on under Camel’s tough skin.
To make sure that you get the main concepts from each chapter, from now on we’ll present you with a number of best practices and key points in the summary.
In the next chapter, we’ll investigate routing, which is an essential feature and a fun one to learn.
Listing 1.4 Routing files from one folder to another with Apache Camel.
One of the most important features of Camel is routing; without it, Camel would essentially be a library of transport connectors.
When you mail a letter, for instance, it may be routed through several cities before reaching its final address.
An email you send will be routed through many different computer network systems before reaching its final destination.
In all cases, the router’s function is to selectively move the message forward.
In the context of enterprise messaging systems, routing is the process by which a message is taken from an input queue and, based on a set of conditions, sent to one of several output queues, as shown in figure 2.1
Introducing Rider Auto Parts input and output queues are unaware of the conditions in between them.
The conditional logic is decoupled from the message consumer and producer.
It’s defined as a step-by-step movement of the message, which originates from an endpoint in the role of a consumer.
The consumer could be receiving the message from an external service, polling for the message on some system, or even creating the message itself.
This message then flows through a processing component, which could be an enterprise integration pattern (EIP), a processor, an interceptor, or some other custom creation.
The message is finally sent to a target endpoint that’s in the role of a producer.
A route may have many processing components that modify the message or send it to another location, or it may have none, in which case it would be a simple pipeline.
In this chapter, we’ll first introduce the fictional company that we’ll use as the running example throughout the book.
To support this company’s use case, you’ll learn how to communicate over FTP and Java Message Service (JMS) using Camel’s endpoints.
Following this, we’ll look in depth at the Java-based domain-specific language (DSL) and the Spring-based configuration format for creating routes.
We’ll also give you a glimpse of how to design and implement solutions to enterprise integration problems using EIPs and Camel.
By the end of the chapter, you’ll be proficient enough to create useful routing applications with Camel.
To start, let’s look at the example company that we’ll use to demonstrate the concepts throughout the book.
Our fictional motorcycle parts business, Rider Auto Parts, supplies parts to motorcycle manufacturers.
Over the years, they’ve changed the way they receive orders several times.
Initially, orders were placed by uploading comma-separated value (CSV) files to an FTP server.
Currently they provide a website through which orders are submitted as XML messages over HTTP.
Rider Auto Parts asks new customers to use the web interface to place orders, but because of service level agreements (SLAs) with existing customers, they must keep all the old message formats and interfaces up and running.
All of these messages are converted to an internal Plain Old Java Object (POJO) format before processing.
A highlevel view of the order processing system is shown in figure 2.2
Figure 2.1 A message router consumes messages from an input channel and, depending on a set of conditions, sends the message to one of a set of output channels.
Rider Auto Parts faces a pretty common problem: over years of operation, they have acquired software baggage in the form of transports and data formats that were popular at the time.
This is no problem for an integration framework like Camel, though.
In this chapter, and throughout the book, you’ll help Rider Auto Parts implement their current requirements and new functionality using Camel.
As a first assignment, you’ll need to implement the FTP module in the Rider order frontend system.
Later in the chapter, you’ll see how backend services are implemented too.
To complete the entire assignment, you’ll need to understand routing with the Java DSL.
Let’s first take a look at how you can use Camel’s endpoints.
As you read in chapter 1, an endpoint is an abstraction that models the end of a message channel through which a system can send or receive messages.
In this section, we’re going to explain how you can use URIs to configure Camel to communicate over FTP and JMS.
One of the things that make Camel easy to use is the endpoint URI.
By specifying a URI, you can identify the component you want to use and how that component is configured.
You can then decide to either send messages to the component configured by this URI, or to consume messages from it.
To download new orders from the FTP server, you need to do the following:
Figure 2.2 A customer has two ways of submitting orders to the Rider Auto Parts order-handling system: either by uploading the raw order file to an FTP server or by submitting an order through the Rider Auto Parts web store.
All orders are eventually sent via JMS for processing at Rider Auto Parts.
As shown in figure 2.3, you can easily configure Camel to do this by using URI notation.
Camel will first look up the ftp scheme in the component registry, which will.
The FtpComponent then works as a factory, creating the FtpEndpoint based on the remaining context path and options.
The context path of rider.com/orders tells the FtpComponent that it should log into the FTP server at rider.com on the default FTP port and change the directory to “orders”
Finally, the only options specified are username and password, which are used to log in to the FTP server.
The FtpComponent isn’t part of the camel-core module, so you have to add an additional dependency to your project.
Using Maven you just have to add the following dependency to the POM:
Although this endpoint URI would work equally well in a consumer or producer scenario, you’ll be using it to download orders from the FTP server.
To do so, you need to use it in a from node of Camel’s DSL:
That’s all you need to do to consume files from an FTP server.
The next thing you need to do, as you may recall from figure 2.2, is send the orders.
This process requires a little more setup, but it’s still easy.
Figure 2.3 A Camel endpoint URI consists of three parts: a scheme, a context path, and a list of options.
For now, though, we’re just going to cover enough so that you can complete your first task for Rider Auto Parts.
Recall that you need to download orders from an FTP server and send them to a JMS queue.
It also mandates that messaging is asynchronous and has specific elements of reliability, like guaranteed and once-and-only-once delivery.
In JMS, message consumers and producers talk to one another through an intermediary—a JMS destination.
As shown in figure 2.4, a destination can be either a queue or a topic.
Queues are strictly point-to-point, where each message has only one consumer.
Topics operate on a publish/subscribe scheme; a single message may be delivered to many consumers if they have subscribed to the topic.
To connect Camel to a specific JMS provider, you need to configure Camel’s JMS component with an appropriate ConnectionFactory.
Apache ActiveMQ is one of the most popular open source JMS providers, and it’s the primary JMS broker that the Camel team uses to test the JMS component.
As such, we’ll be using it to demonstrate JMS concepts within the book.
Figure 2.4 There are two types of JMS destinations: queues and topics.
The queue is a point-to-point channel, where each message has only one recipient.
A topic delivers a copy of the message to all clients who have subscribed to receive it.
The vm://localhost URI means that you should connect to an embedded broker named “localhost” running inside the current JVM.
The vm transport connector in ActiveMQ creates a broker on demand if one isn’t running already, so it’s very handy for quickly testing JMS applications; for production scenarios, it’s recommended that you connect to a broker that’s already running.
Furthermore, in production scenarios we recommend that connection pooling be used when connecting to a JMS broker.
Next, when you create your CamelContext, you can add the JMS component as follows:
The JMS component and the ActiveMQ-specific connection factory aren’t part of the camel-core module.
In order to use these, you’ll need to add some dependencies to your Maven-based project.
For the plain JMS component, all you have to add is this:
The connection factory comes directly from ActiveMQ, so you’ll need the following dependency:
Now that you’ve configured the JMS component to connect to an actual JMS broker, it’s time to look at how URIs can be used to specify the destination.
Once the JMS component is configured, you can start sending and receiving JMS messages at your leisure.
Because you’re using URIs, this is a real breeze to configure.
Let’s say you want to send a JMS message to the queue named incomingOrders.
The “jms” prefix indicates that you’re using the JMS component you configured before.
You could even have omitted the queue qualifier, because the default behavior is to send to a queue rather than a topic.
For instance, the JMS component has about 60 options, many of which are only used in specific JMS scenarios.
Camel always tries to provide built-in defaults that fit most cases, and you can always find out what the default values are by browsing to the component’s page in the online Camel documentation.
Using Camel’s Java DSL, you can send a message to the incomingOrders queue by using the to keyword like this:
This can be read as sending to the JMS queue named incomingOrders.
Now that you know the basics of communicating over FTP and JMS with Camel, you.
In chapter 1, you saw how each CamelContext can contain multiple routes and also how a RouteBuilder could be used to create a route.
It may not have been obvious, though, that the RouteBuilder isn’t the final route that the CamelContext will use at runtime; it’s a builder of one or more routes, which are then added to the CamelContext.
The addRoutes method of the CamelContext accepts a RoutesBuilder, not just a RouteBuilder.
This means that you could use your own custom class to build Camel routes.
The most common way to build routes, though, is to use the RouteBuilder class, which implements RoutesBuilder.
The RouteBuilder class also gives you access to Camel’s Java DSL for route creation.
In the next sections, you’ll learn how to use a RouteBuilder and the Java DSL to create simple routes.
Figure 2.5 RouteBuilders are used to create routes in Camel.
You’ll need to use it any time you create a route in Java.
To use the RouteBuilder class, you extend a class from it and implement the configure method, like this:
You then need to add the class to the CamelContext with the addRoutes method:
Alternatively, you can combine the RouteBuilder and CamelContext configuration by adding an anonymous RouteBuilder class directly into the CamelContext, like this:
Within the configure method, you define your routes using the Java DSL.
We’ll discuss the Java DSL in detail in the next section, but you can start a route now to get an idea of how it works.
In chapter 1, you should have downloaded the source code from the book’s website and set up Apache Maven.
Change to the chapter2/ftp-jms directory in your terminal, and type this command:
To start a route, you should use the from method.
The from method accepts an endpoint URI as an argument.
You can add a FTP endpoint URI to connect to Rider Auto Parts’ order server as follows:
The from method returns a RouteDefinition object, on which you can invoke a number of different methods that implement EIPs and other messaging concepts.
Congratulations, you’re now using Camel’s Java DSL! Let’s take a closer look at what’s going on here.
Domain-specific languages (DSLs) are computer languages that target a specific problem domain, rather than a general purpose domain like most programming languages.
For example, you have probably used the regular expression DSL to match strings of text and found it to be a clear and concise way of matching strings.
Doing the same string matching in Java wouldn’t be so easy.
The regular expression DSL is an external DSL—it has a custom syntax and so requires a separate compiler or interpreter to execute.
Internal DSLs, in contrast, use an existing general purpose language, such as Java, in such a way that the DSL feels like a language from a particular domain.
The most obvious way of doing this is by naming methods and arguments to match concepts from the domain in question.
Another popular way of implementing internal DSLs is by using fluent interfaces (aka fluent builders)
When using a fluent interface, you build up objects with methods that perform an operation and then return the current object instance; another method is then invoked on this object instance, and so on.
He also has an entry on “Fluent Interfaces” at http://www.martinfowler.com/bliki/FluentInterface.
Camel’s domain is enterprise integration, so the Java DSL is essentially a set of fluent interfaces that contain methods named after terms from the EIP book.
In the Eclipse editor, take a look at what is available using autocomplete after a from method in the RouteBuilder.
You should see something like what’s shown in figure 2.7
The screenshot shows several EIPs—Pipeline, Enricher, and Recipient List—and there are many others that we’ll discuss later.
For now, select the to method and finish the route with a semicolon.
Each Java statement that starts with a from method in the RouteBuilder creates a new route.
This new route now completes your first task at Rider Auto Parts—consuming orders from an FTP server and sending them to the incomingOrders JMS queue.
Figure 2.7 After the from method, use your IDE’s autocomplete feature to get a list of EIPs (such as Pipeline, Enricher, and Recipient List) and other useful integration functions.
As you can see, this listing includes a bit of boilerplate setup and configuration, but the actual solution to the problem is concisely defined within the configure method as a single Java statement B.
The from method tells Camel to consume messages from an FTP endpoint, and the to method instructs Camel to send messages to a JMS endpoint.
The flow of messages in this simple route can be viewed as a basic pipeline, where the output of the consumer is fed into the producer as input.
Listing 2.1 Polling for FTP messages and sending them to the incomingOrders queue.
The output of the FTP consumer is fed into the input of the JMS producer.
The payload conversion from file to JMS message is done automatically.
One thing you may have noticed is that we didn’t do any conversion from the FTP file type to the JMS message type—this was done automatically by Camel’s TypeConverter facility.
You can force type conversions to occur at any time during a route, but often you don’t have to worry about them at all.
You may be thinking now that although this route is nice and simple, it would be really nice to see what’s going on in the middle of the route.
Fortunately, Camel always lets the developer stay in control by providing ways to hook into flows or inject behavior into features.
There is a pretty simple way of getting access to the message by using a processor, and we’ll discuss that next.
The Processor interface in Camel is an important building block of complex routes.
This gives you full access to the message exchange, letting you do pretty much whatever you want with the payload or headers.
You can even add a simple processor to your route inline, like so:
By adding this processor into the middle of the route, you’ve effectively added it to the conceptual pipeline we mentioned earlier, as illustrated in figure 2.9
The output of the FTP consumer is fed into the processor as input; the processor doesn’t modify the message payload or headers, so the exchange moves on to the JMS producer as input.
In the previous example, you used the CamelFileName header to retrieve the filename of the file that was downloaded via FTP.
The component pages of the online documentation contain information about the headers set for each individual component.
Camel’s main method for creating routes is through the Java DSL.
There are other ways of creating routes though, some of which may better suit your situation.
For instance, Camel provides extensions for writing routes in Groovy, Scala, and, as we’ll discuss next, Spring XML.
Spring is the most popular Inversion of Control (IoC) Java container out there.
The core framework allows to you “wire” beans together to form applications.
In this section, we’ll give you a quick introduction to creating applications with Spring.
For a more comprehensive view of Spring, we recommend Spring in Action, by Craig Walls (http://www.manning.com/walls4/)
We’ll then go on to show you how Camel uses Spring to form a replacement or complementary solution to the Java DSL.
Creating an application from beans using Spring is pretty simple.
All you need are a few Java beans (classes), a Spring XML configuration file, and an ApplicationContext.
The ApplicationContext is similar to the CamelContext, in that it’s the runtime container for Spring.
Consider an application that prints out a greeting followed by your username.
In this application you don’t want the greeting to be hardcoded, so you can use an interface to break this dependency.
Figure 2.9 With a processor in the mix, the output of the FTP consumer is now fed into the processor, and then the output of the processor is fed into the JMS producer.
This application will output a different greeting depending on how you configure it.
To configure this application using Spring, you could do something like this:
This class loads Spring XML files from a location specified on the classpath.
You then call getBean on the context to look up the bean with the greetMeBean ID in the Spring registry.
All beans defined in this file are accessible in this way.
To run this example, go to the chapter2/spring directory in the book’s source code and run this Maven command:
This will output something like the following on the command line:
If you had wired the DanishGreeter in instead, you’d have seen something like this on the console:
This example may seem pretty simple, but it should give you an understanding of what Spring and, more generally, an IoC container, really is.
So how does Camel fit into this? Essentially, Camel can be configured as if it were another bean.
For instance, you configured the JMS component to connect to an ActiveMQ broker in section 2.2.2, but you could have done this in Spring by using the bean terminology, as follows:
But where is the CamelContext defined in Spring? Well, to make things easier on the eyes, Camel utilizes Spring extension mechanisms to provide custom XML syntax for Camel concepts within the Spring XML file.
To load up a CamelContext in Spring, you can do the following:
Also notice that you had to include the http://camel.apache.org/schema/spring/camel-spring.xsd XML schema definition in the XML file—this is needed to import the custom XML elements.
This snippet alone isn’t going to do much for you.
You need to tell Camel what routes to use, as you did when using the Java DSL.
The following code uses Spring to produce the same results as the code in listing 2.1
In order to reproduce the Java DSL example in listing 2.1, you have to factor out the anonymous RouteBuilder into its own named class.
Now that you know the basics of Spring and how to load Camel inside it, we can go further by looking at how to write Camel routing rules purely in XML—no Java DSL required.
What we’ve seen of Camel’s integration with Spring is adequate, but it isn’t taking full advantage of Spring’s methodology of configuring applications using no code.
To completely invert the control of creating applications using Spring XML, Camel provides custom XML extensions that we call the Spring DSL.
The Spring DSL allows you to do almost everything you can do in the Java DSL.
Let’s continue with the Rider Auto Parts example shown in listing 2.2, but this time you’ll specify the routing rules defined in the RouteBuilder purely in XML.
In this listing, under the camelContext element you replace routeBuilder with the route element.
Within the route element, you specify the route using elements with names similar to ones used inside the Java DSL RouteBuilder.
In the book’s source code, we changed the from method to consume messages from a local file directory instead.
The file endpoint will load order files from the relative src/data directory.
The noop property configures the endpoint to leave the file as is after processing; this option is very useful for testing.
In chapter 7, you’ll also see how Camel allows you to delete or move the files after processing.
You need to add an additional processing step for testing.
Adding additional processing steps is simple, as in the Java DSL.
Here you’ll add a custom processor like you did in section 2.3.2
Because you can’t refer to an anonymous class in Spring XML, you need to factor out the anonymous processor into the following class:
You can now use it in your Spring DSL route as follows:
Go to the chapter2/spring directory in the book’s source code and run this Maven command:
Because there is only one message file named message1.xml in the src/data directory, this will output something like the following on the command line:
What if you wanted to print this message after consuming it from the incomingOrders queue? To do this, you’ll need to create another route.
You may recall that in the Java DSL each Java statement starting with a from creates a new route.
You can also create multiple routes with the Spring DSL.
To do this, simply add an additional route element within the camelContext element.
For example, move the DownloadLogger bean into a second route, after the order gets sent to the incomingOrders queue:
Now you are consuming the message from the incomingOrders queue in the second route.
So, the downloaded message will be printed after the order is sent to the queue.
Which DSL is best to use in a particular scenario is a common question for Camel users, but it mostly comes down to personal preference.
Spring or like defining things in XML, you may prefer a pure Spring approach.
If you want to be hands-on with Java, maybe a pure Java DSL approach is better for you.
In either case, you’ll be able to access nearly all of Camel’s functionality.
The Java DSL is a slightly richer language to work with because you have the full power of the Java language at your fingertips.
Also, some Java DSL features, like value builders (for building expressions and predicates1), aren’t available in the Spring DSL.
On the other hand, using Spring gives you access to the wonderful object construction capabilities as well as commonly used Spring abstractions for things like database connections and JMS integration.
A common compromise (and our favorite usage) is to use both Spring and the Java DSL, which is one of the topics we’ll cover next.
Whether you write your routes in the Java or Spring DSL, running Camel in a Spring container gives you many other benefits.
For one, if you’re using the Spring DSL, you don’t have to recompile any code when you want to change your routing rules.
Also, you gain access to Spring’s portfolio of database connectors, transaction support, and more.
Let’s take a closer look at what other Spring integrations Camel provides.
Using the Spring CamelContext as a runtime and the Java DSL for route development is a great way of using Camel.
You saw before that you can explicitly tell the Spring CamelContext what route builders to load.
Being this explicit results in a clean and concise definition of what is being loaded into Camel.
Sometimes, though, you may need to be a bit more dynamic.
This is where the packageScan and contextScan elements come in:
You can even be a bit more picky about what route builders are included:
See appendix B for more information on expressions and predicates.
The matching syntax is similar to what is used in Apache Ant’s file pattern matchers.
You can now enable the component scanning by using the following configuration in your Spring XML file:
Under the hood, some of Camel’s components, like the JMS component, are built on top of abstraction libraries from Spring.
It makes sense that configuring those components is easy in Spring.
You saw in section 2.4.1 that components could be defined in Spring XML and would be picked up automatically by Camel.
The bean id defines what this component will be called.
This gives you the flexibility to give the component a more meaningful name based on the use case.
One could be for Apache ActiveMQ and another could be for SonicMQ:
Endpoints can also be defined using Camel’s Spring XML extensions.
A better way would be to refer to credentials that are defined and sufficiently protected elsewhere.
A common practice in Spring development is to separate out an application’s wiring into several XML files.
This is mainly done to make the XML more readable; you probably wouldn’t want to wade through thousands of lines of XML in a single file without some separation.
Another reason to separate an application into several XML files is the potential for reuse.
For instance, some other application may require a similar JMS setup, so you can define a second Spring XML file called jms-setup.xml with these contents:
This file could then be imported into the XML file containing the CamelContext by using the following line:
Now the CamelContext can use the JMS component configuration even though it’s defined in a separate file.
Other useful things to define in separate files are the Spring DSL routes themselves.
Because route elements need to be defined within a camelContext element, an additional concept is introduced to define routes.
You can define routes within a routeContext element, as shown here:
This routeContext element could be in another file or in the same file.
You can then import the routes defined in this routeContext with the routeContextRef element.
You use the routeContextRef element inside a camelContext as follows:
If you import the routeContext into multiple CamelContexts, a new instance of the route is created in each.
In the preceding case, two identical routes, with the same endpoint URIs, will lead to them competing for the same resource.
In this case, only one route at a time will receive a particular file from FTP.
In general, you should take care when reusing routes in multiple CamelContexts.
There are many other configuration options available when using the Spring CamelContext:
With these route configuration techniques behind us, you’re ready to tackle more advanced routing topics using Camel’s implementation of the EIPs.
So far we haven’t touched much on the EIPs that Camel was built to implement.
We wanted to make sure you had a good understanding of what Camel is doing in the simplest cases before moving on to more complex examples.
Other patterns will be introduced throughout the book, and in chapter 8 we’ll be covering the most complex EIPs.
For now, let’s start by looking at the most well known EIP, the Content-Based Router.
As the name implies, a Content-Based Router (CBR) is a message router that routes a message to a destination based on its content.
The content could be a message header, the payload data type, part of the payload itself—pretty much anything in the message exchange.
Some customers have started uploading orders to the FTP server in the newer XML format rather than CSV.
That means you have two types of messages coming in to the incomingOrders queue.
We didn’t touch on this before, but you need to convert the incoming orders into an internal POJO format.
You obviously need to do different conversions for the different types of incoming orders.
As a possible solution, you could use the filename extension to determine whether a particular order message should be sent to a queue for CSV orders or a queue for XML orders.
As you saw earlier, you can use the CamelFileName header set by the FTP consumer to get the filename.
To do the conditional routing required by the CBR, Camel introduces a few keywords in the DSL.
The choice method creates a CBR processor, and conditions are added by following choice with a combination of a when method and a predicate.
Camel’s creators could have chosen contentBasedRouter for the method name, to match the EIP, but they stuck with choice because it reads more naturally.
Figure 2.10 The CBR routes messages based on their content.
In this case, the filename extension (as a message header) is used to determine which queue to route to.
You may have noticed that we didn’t fill in the predicates required for each when method.
A predicate in Camel is a simple interface that only has a matches method:
For example, you can think of a predicate as a Boolean condition in a Java if statement.
You probably don’t want to look inside the exchange yourself and do a comparison.
Fortunately, predicates are often built up from expressions, and expressions are used to extract a result from an exchange based on the expression content.
As you’ll see in chapter 4, you can even use a method call to a bean as an expression in Camel.
In this case, you’ll be using the expression builder methods that are part of the Java DSL.
Within the RouteBuilder, you can start by using the header method, which returns an expression that will evaluate to the header value.
On this expression you can invoke a number of methods to create a predicate.
So, to check whether the filename extension is equal to .xml, you can use the following predicate:
To run this example, go to the chapter2/cbr directory in the book’s source code and run this Maven command:
The output comes from the two routes at the end of the configure method C.
These routes consume messages from the xmlOrders and csvOrders queues and then print out messages.
You use these routes to test that the router B is working as expected.
One of Rider Auto Parts’ customers sends CSV orders with the .csl extension.
Your current route only handles .csv and .xml files and will drop all orders with other extensions.
This isn’t a good solution, so you need to improve things a bit.
One way to handle the extra extension is to use a regular expression as a predicate instead of the simple endsWith call.
Any orders not conforming to the file extension scheme will be dropped.
Really, you should be handling bad orders that come in so someone can fix the problem.
Now, all orders not having an extension of .csv, .csl, or .xml are sent to the badOrders queue for handling.
To run this example, go to the chapter2/cbr directory in the book’s source and run this command:
You can now see that a bad order has been received.
The CBR may seem like it’s the end of the route; messages are routed to one of several destinations, and that’s it.
Well, there are several ways you can continue routing after a CBR.
One is by using another route, like you did in listing 2.4 for printing a test message to the console.
Another way of continuing the flow is by closing the choice block and adding another processor to the pipeline after that.
You can close the choice block by using the end method:
Here, the choice has been closed and another to has been added to the route.
You can also control what destinations are final in the choice block.
For instance, you may not want bad orders continuing through the rest of the route.
You’d like them to be routed to the badOrders queue and stop there.
In this case, you can use the stop method in the DSL:
Using the Spring DSL, this route looks a bit different:
Other than being in XML rather than Java, there are two main differences to note here, compared to the Java DSL version:
Figure 2.11 By using the end method, you can route messages to a destination after the CBR.
You don’t have to use an end() call to end the choice block because XML requires an explicit end block in the form of the closing element </choice>
Rider Auto Parts now has a new issue—their QA department has expressed the need to be able to send test orders into the live web frontend of the order system.
Your current solution would accept these orders as real and send them to the internal systems for processing.
You’ve suggested that QA should be testing on a development clone of the real system, but management has shot down this idea, citing a limited budget.
What you need is a solution that will discard these test messages while still operating on the real orders.
The Message Filter EIP, shown in figure 2.12, provides a nice way of dealing with this kind of problem.
Incoming messages only pass through the filter if a certain condition is met.
Recall that the web frontend that Rider Auto Parts uses only sends orders in the XML format, so you can place this filter after the xmlOrders queue, where all orders are XML.
Test messages have an extra test attribute set, so you can use this to do the filtering.
To run this example, execute the following Maven command on the command line:
Figure 2.12 A Message Filter allows you to filter out uninteresting messages based on some condition.
You’ll only receive one message after the filter because the test message was filtered out.
You may have noticed that this example filters out the test message with an XPath.
XPath expressions are useful for creating conditions based on XML payloads.
In this case, the expression will evaluate true for orders that don’t have the test attribute.
As you saw back in section 2.4.2, when the Spring DSL is used, you cannot use an anonymous inner class for a processor.
You must name the Processor class and add a bean entry in the Spring XML file.
So a message filter route in the Spring DSL looks like this:
The flow remains the same as in the Java DSL version of this route, but here you reference the processor as orderLogger, which is defined as a bean entry in the Spring XML file.
So far, the EIPs we’ve looked at only sent messages to a single destination.
Next we’ll take a look at how you can send to multiple destinations.
Often in enterprise applications you’ll need to send a copy of a message to several different destinations for processing.
When the list of destinations is known ahead of time and is static, you can add an element to the route that will consume messages from a source endpoint and then send the message out to a list of destinations.
Borrowing terminology from computer networking, we call this the Multicast EIP.
Currently at Rider Auto Parts, orders are processed in a step-by-step manner.
They’re first sent to accounting for validation of customer standing and then to production for manufacture.
A bright new manager has suggested that they could improve the speed of operations by sending orders to accounting and production at the same time.
This would cut out the delay involved when production waits for the OK from accounting.
You’ve been asked to implement this change to the system.
Using a multicast, you could envision the solution shown in figure 2.13
With Camel, you can use the multicast method in the Java DSL to implement this solution:
To run this example, go to the chapter2/multicast directory in the book’s source code and run this command:
You should see the following output on the command line:
These two lines of output are coming from two test routes that consume from the accounting and production queues and then output text to the console that qualifies the message.
In the preceding example, a message is sent to the accounting queue and then to the production queue.
But what if you wanted to send them in parallel?
Sending messages in parallel using the multicast involves only one extra DSL method: parallelProcessing.
Extending the previous multicast example, you can add the parallelProcessing method as follows:
This will set up the multicast to distribute messages to the destinations in parallel.
A default thread pool size of 10 is used if you don’t specify anything else.
This code increases the maximum number of threads to 16, in order to handle a larger number of incoming requests.
By default, the multicast will continue sending messages to destinations even if one fails.
In your application, though, you may consider the whole process as failed if one destination fails.
Our multicast solution at Rider Auto Parts suffers from a problem: if the order failed to send to the accounting queue, it might take longer to track down the order from production and bill the customer.
To solve this problem, you can take advantage of the stopOnException feature of the multicast.
When enabled, this feature will stop the multicast on the first exception caught, so you can take any necessary action.
To enable this feature, use the stopOnException method as follows:
When using the Spring DSL, this route looks a little bit different:
The main difference is that the methods used to set flags such as stopOnException in the Java DSL are now attributes on the multicast element.
Also, the executor service is now specified as a reference to a Spring bean defined as follows:
Now you know how to multicast messages in Camel, but you may be thinking that this seems like a pretty static solution, because changing the destinations means changing the route.
Let’s see how you can make sending to multiple recipients more dynamic.
In the previous section, you implemented a new manager’s suggestion to parallelize the accounting and production queues so orders could be processed more quickly.
Rider Auto Parts’ top-tier customers first noticed the problem with this approach: now that all orders are going directly into production, top-tier customers are not getting priority over the smaller customers.
Their orders are taking longer, and they’re losing business opportunities.
Management suggested immediately going back to the old scheme, but you suggested a simple solution to the problem: by parallelizing only toptier customers’ orders, all other orders would have to go to accounting first, thereby not bogging down production.
This solution can be realized by using the Recipient List EIP.
As shown in figure 2.14, a recipient list first inspects the incoming message, then generates a list of desired recipients based on the message content, and sends the message to those recipients.
Note that the recipient list is different from the multicast because the list of recipients is dynamic.
Camel provides a recipientList method for implementing the Recipient List EIP.
For example, the following route will take the list of recipients from a header named recipients, where each recipient is separated from the next by a comma:
This is useful if you already have some information in the message that can be used to construct the destination names—you could use an expression to create the list.
In order for the recipient list to extract meaningful endpoint URIs, the expression result must be iterable.
In the Rider Auto Parts situation, the message doesn’t contain that list.
You need some way of determining whether the message is from a top-tier customer or not.
A simple solution could be to add a custom processor to do this:
Figure 2.14 A recipient list inspects the incoming message and determines a list of recipients based on the content of the message.
In this case, the message is only sent to the A, B, and D destinations.
The processor now sets the recipients header to "jms:accounting, jms:production" only if the customer is at the gold level of support.
The check for gold-level support here is greatly simplified—ideally you’d query a database for this check.
Any other orders will be routed only to accounting, which will send them to production after the checks are complete.
The Spring DSL version of this route follows a very similar layout:
As you may have expected, the anonymous processor specified in the Java DSL route had to be separated out into a named processor.
It’s common for recipients to not be embedded in the message as headers or parts of the body, and using a custom processor for this case is perfectly functional, but not very nice.
In using a custom processor, you have to manipulate the exchange and message APIs directly.
Fortunately, Camel supports a better way of implementing a recipient list.
Rather than using the recipientList method in the DSL, you can add a @RecipientList annotation to a method in a plain Java class (a Java bean)
This annotation tells Camel that the annotated method should be used to generate the list of recipients from the exchange.
This behavior only gets invoked, however, if the class is used with Camel’s bean integration.
For example, replacing the custom processor you used in the previous section with an annotated bean results in a greatly simplified route:
Now all the logic for calculating the recipients and sending out messages is captured in the RecipientListBean class, which looks like this:
Notice that the return type of the bean is a list of the desired recipients.
Camel will take this list and send a copy of the message to each destination in the list.
One nice thing about implementing the recipient list this way is that it’s entirely separated from the route, which makes it a bit easier to read.
You also have access to Camel’s bean-binding annotations, which allow you to extract data from the message using expressions, so you don’t have to manually explore the exchange.
This example uses the @XPath bean-binding annotation to grab the customer attribute of the order element in the body.
We’ll cover these annotations in chapter 4, which is all about using beans.
Why do you get this output? Well, you had the following two orders in the src/data directory:
The first message is from a gold customer, according to the Rider Auto Parts rules, so it was routed to both accounting and production.
The second order is from a smaller customer, so it went to accounting for verification of the customer’s credit standing.
What this system lacks now is a way to inspect these messages as they’re flowing through the route, rather than waiting until they reach the end.
Often in enterprise applications it’s useful and necessary to inspect messages as they flow through a system.
For instance, when an order fails, you need a way to look at which messages were received to determine the cause of the failure.
You could use a simple processor, as you’ve done before, to output information about a incoming message to the console or append it to a file.
Here is a processor that outputs the message body to the console:
This is fine for debugging purposes, but it’s a pretty poor solution for production use.
What if you wanted the message headers, exchange properties, or other data in the message exchange? Ideally you could copy the whole incoming exchange and send that to another channel for auditing.
As shown in figure 2.15, the Wire Tap EIP defines such a solution.
By using the wireTap method in the Java DSL, you can send a copy of the exchange to a secondary destination without affecting the behavior of the rest of the route:
The preceding code sends a copy of the exchange to the orderAudit queue, and the original exchange continues on through the route, as if you hadn’t used a wire tap at all.
Camel doesn’t wait for a response from the wire tap because the wire tap sets the message exchange pattern (MEP) to InOnly.
This means that the message will be sent to the orderAudit queue in a fire-and-forget fashion—it won’t wait for a reply.
In the Spring DSL, you can configure a wire tap just as easily:
What can you do with a tapped message? A number of things could be done at this point:
Figure 2.15 A wire tap is a fixed recipient list that sends a copy of a message traveling from a source to a destination to a secondary destination.
You could save the message in a persistent store (in a file or database) for retrieval later.
The wire tap is a pretty useful monitoring tool, but it leaves most of the work up to you.
In this chapter, we’ve covered one of the core abilities of Camel: routing messages.
By now you should know how to create routes in either the Java or Spring DSL and know the differences in their configuration.
You should also have a good grasp of when to apply several EIP implementations in Camel and how to use them.
With this knowledge, you can create Camel applications that do useful tasks.
Here are some of the key concepts you should take away from this chapter:
Whether you’re surfing the Internet, doing online banking, booking a flight or hotel room, messages are being routed behind the scenes using some sort of router.
Camel is primarily a message router that allows to you route messages from and to a variety of transports and APIs.
The Java DSL allows you to write in the popular Java language, which gives you autocompletion of terms in most IDEs.
It also allows you to use the full power of the Java language when writing routes.
The Spring DSL allows you to write routing rules without any Java code at all.
In section 2.4.3 we described our favorite way to write Camel applications, which is to boot up the CamelContext in Spring and write routing rules in Java DSL RouteBuilders.
This gives you the best of both: the most expressive DSL that Camel has in the Java DSL, and a more feature-rich and standard container in the Spring CamelContext.
Use enterprise integration patterns (EIPs) to solve integration and routing problems.
EIPs are like design patterns from object oriented programming, but for the enterprise integration world.
Use Camel’s built-in EIP implementations rather than creating your own.
Camel implements most EIPs as easy-to-use DSL terms, which allows you to focus on the actual business problem rather than the integration architecture.
In the coming chapters we’ll build on this foundation to show you things like data transformation, error handling, testing, sending data over other transports, and more.
In the next chapter, we’ll look at how Camel makes data transformation a breeze.
In part 1, we guided you through what we consider introductory topics in Camel.
They were topics you absolutely needed to know to use Camel.
In this next part, we’ll cover in depth the core features of Camel.
You’ll need many of these features when using Camel in real-world applications.
In chapter 3 we’ll take a look at the data in the messages being routed by Camel.
In particular, we’ll look at how you can transform this data to other formats using Camel.
Camel has great support for integrating beans into your routing applications.
In chapter 4 we’ll look at the many ways beans can be used in Camel applications.
In complex enterprise systems, lots of things can go wrong.
This is why Camel features an extensive set of error-handling abilities.
In chapter 6 we’ll take a look at another important topic in application development: testing.
You can use these features for testing your own Camel applications or applications based on other stacks.
As such, they include functionality to connect to many different transports, APIs, and other extensions to Camel’s core.
Chapter 7 covers the most heavily used components that ship with Camel.
The last chapter of this part revisits the important topic of enterprise integration patterns (EIPs) in Camel.
In the previous chapter, we covered routing, which is the single most important feature any integration kit must provide.
In this chapter, we’ll take a look at the second most important feature: data or message transformation.
Just as in the real world, where people speak different languages, the IT world speaks different protocols.
Software engineers regularly need to act as mediators between various protocols when IT systems must be integrated.
To address this, the data models used by the protocols must be transformed from one form to another, adapting to whatever protocol the receiver understands.
Mediation and data transformation is a key feature in any integration kit, including Camel.
In this chapter, you’ll learn all about how Camel can help you with your data transformation challenges.
We’ll start with a brief overview of data transformation in Camel and then look at how you can transform data into any custom format you may have.
Then we’ll look at some Camel components that are specialized for transforming XML data and other well-known data formats.
We’ll end the chapter by looking into Camel’s type-converter mechanism, which supports implicitly and explicitly type coercing.
After reading this chapter, you’ll know how to tackle any data transformation you’re faced with and which Camel solution to leverage.
Camel provides many techniques for data transformation, and we’ll cover them shortly.
But first we’ll start with an overview of data transformation in Camel.
Data transformation is a broad term that covers two types of transformation:
Data format transformation—The data format of the message body is transformed from one form to another.
Data type transformation—The data type of the message body is transformed from one type to another.
Figure 3.1 illustrates the principle of transforming a message body from one form into another.
This transformation can involve any combination of format and type transformations.
In most cases, the data transformation you’ll face with Camel is format transformation, where you have to mediate between two protocols.
Camel has a builtin type-converter mechanism that can automatically convert between types, which greatly reduces the need for end users to deal with type transformations.
We’ll introduce them in the following section, and then look at them one by one.
After reading this chapter, you’ll have a solid understanding of how to use Camel to transform your data.
In Camel, data transformation typically takes places in the six ways listed in table 3.1
Transform Figure 3.1 Camel offers many features for transforming data from one form to another.
In this chapter, we’ll cover the first five of the data transformation methods listed in table 3.1
Data mapping is the process of mapping between two distinct data models, and it’s a key factor in data integration.
There are many existing standards for data models, governed by various organizations or committees.
As such, you’ll often find yourself needing to map from a company’s custom data model to a standard data model.
Camel provides great freedom in data mapping because it allows you to use Java code—you aren’t limited to using a particular data mapping tool that at first might seem elegant but that turns out to make things impossible.
In this section, we’ll look at how you can map data using a Processor, which is a Camel API.
Camel can also use beans for mapping, which is a good practice, because it allows your mapping logic to be independent of the Camel API.
This pattern covers translating a message from one format to another.
Table 3.1 Six ways data transformation typically takes place in Camel.
You can explicitly enforce transformation in the route using the Message Translator or the Content Enricher EIPs.
This gives you the power to do data mapping using regular Java code.
Camel provides a range of components for transformation, such as the XSLT component for XML transformation.
Data formats are Camel transformers that come in pairs to transform data back and forth between well-known formats.
Camel provides a range of components for transforming using templates, such as Apache Velocity.
Camel has an elaborate type-converter mechanism that activates on demand.
Camel’s many components adapt to various commonly used protocols and, as such, need to be able to transform messages as they travel to and from those protocols.
Often these components use a combination of custom data transformations and type converters.
This happens seamlessly, and only component writers need to worry about it.
See the “Design Patterns” Wikipedia article for more information: http://en.wikipedia.org/wiki/Design_Patterns_(book)
The Processor is a low-level API where you work directly on the Camel Exchange instance.
It gives you full access to all Camel’s moving parts from the CamelContext, which you can obtain Exchange using the getCamelContext method.
At Rider Auto Parts you’ve been asked to generate daily reports of newly received orders to be outputted to a CSV file.
The company uses a custom format for order entries, but to make things easy, they already have an HTTP service that returns a list of orders for whatever date you input.
The challenge you face is mapping the returned data from the HTTP service to a CSV format and writing the report to a file.
Because you want to get started on a prototype quickly, you decide to use the Camel Processor.
Listing 3.1 Using a Processor to translate from a custom format to CSV format.
Figure 3.2 In the Message Translator EIP, an incoming message goes through a translator and comes out as a translated message.
First you grab the custom format payload from the exchange B.
It’s a String type, so you pass String in as the parameter to have the payload returned as a String.
Then you extract data from the custom format to the local variables C.
The custom format could be anything, but in this example it’s a fixed-length custom format.
Then you map the CSV format by building a string with comma-separated values D.
Finally, you replace the custom payload with your new CSV payload E.
The preceding route uses Quartz to schedule a job to run once a day at 6 a.m.
It then invokes the HTTP service to retrieve the orders received yesterday, which are returned in the custom format.
You can try this example yourself—we’ve provided a little unit test with the book’s source code.
Go to the chapter3/transform directory, and run these Maven goals:
Using a processor has one disadvantage: you’re required to use the Camel API.
In the next section, we’ll look at how to avoid this by using a bean.
Using beans is a great practice because it allows you to use any Java code and library you wish.
Camel can invoke any bean you choose, so you can use existing beans without having to rewrite or recompile them.
Listing 3.2 Using a bean to translate from a custom format to CSV format.
Using the getIn and getOut methods on exchanges The Camel Exchange defines two methods for retrieving messages: getIn and getOut.
The getIn method returns the incoming message, and the getOut method accesses the outbound message.
There are two scenarios where the Camel end user will have to decide among using these methods:
In the second scenario, you’d assume getOut should be used.
That’s correct according to theory, but in practice there’s a common pitfall when using getOut: the incoming message headers and attachments will be lost.
This is often not what you want, so you must copy the headers and attachments from the incoming message to the outgoing message, which can be tedious.
The alternative is to set the changes directly on the incoming message using getIn, and not to use getOut at all.
This means your bean is totally independent of the Camel API.
The next difference is that you can name the method signature in listing 3.2—in this case it’s a static method named map.
The method signature defines the contract, which means that the first parameter, (String custom), is the message body you’re going to use for translation.
The method returns a String, which means the translated data will be a String type.
The actual mapping B is the same as with the processor.
You can use OrderToCsvBean in a Camel route as shown here:
You can try this example from the chapter3/transform directory by using the following Maven goals:
Another advantage of using beans over processors for mappings is that unit testing.
We’ll leave the beans for now, because they’re covered extensively in the next chapter.
But you should keep in mind that beans are very useful for doing message transformation.
Transform() is a method in the Java DSL that can be used in Camel routes to transform messages.
By allowing the use of expressions, transform() permits great flexibility, and using expressions directly within the DSL can sometimes save time.
Suppose you need to prepare some text for HTML formatting by replacing all line breaks with a <br/> tag.
This can be done with a built-in Camel expression that searches and replaces using regular expressions:
What this route does is use the transform() method to tell Camel that the message should be transformed using an expression.
Camel provides what is know as the Builder pattern to build expressions from individual expressions.
This is done by chaining together method calls, which is the essence of the Builder pattern.
Now you’ve combined two methods that conform to a compound Camel expression.
You can run this example from chapter3/transform directly by using the following Maven goal:
This is useful when you need to be in full control and have Java code at your fingertips.
For example, the previous example could have been implemented as follows:
As you can see, this code uses an inlined Camel Expression that allows you to use Java code in its evaluate method.
This follows the same principle as the Camel Processor you saw before.
The Direct component provides direct invocation between a producer and a consumer.
It only allows connectivity from within Camel, so external systems can’t send messages directly to it.
This component is used within Camel to do things such as link routes together or for testing.
Now let’s see how you can transform data using Spring XML.
Using <transform> from Spring XML is a bit different than from Java DSL because the XML DSL isn’t as powerful.
In Spring XML, the Builder pattern expressions aren’t available because with XML you don’t have a real programming language underneath.
What you can do instead is invoke a method on a bean or use scripting languages.
The following route uses a method call on a bean as the expression:
First, you declare a regular spring bean to be used to transform the message B.
You can also use scripting languages as expressions in Camel.
For example, you can use Groovy, MVEL, JavaScript, or Camel’s own scripting language, called Simple (explained in some detail in appendix A)
We won’t go in detail on how to use the other scripting languages at this point, but the Simple language can be used to build strings using placeholders.
It pretty much speaks for itself—I’m sure you’ll understand what the following transformation does:
You can try the Spring transformation examples provided in the book’s source code by running the following Maven goals from the chapter3/transform directory:
This pattern documents the scenario where a message is enriched with data obtained from another resource.
To help understand this pattern, we’ll turn back to Rider Auto Parts.
It turns out that the data mapping you did in listing 3.1 wasn’t sufficient.
Orders are also piled up on an FTP server, and your job is to somehow merge this information into the existing report.
Resource Figure 3.3 In the Content Enricher EIP, an existing message has data added to it from another source.
Figure 3.4 An overview of the route that generates the orders report, now with the content enricher pulling in data from an FTP server.
It then pulls data from an HTTP server, which returns orders in a custom format C, which is then transformed into CSV format D.
At this point, you have to perform the additional content enrichment step E with the data obtained from the FTP server F.
After this, the final report is written to the file server G.
Before we dig into the code and see how to implement this, we need to take a step back and look at how the Content Enricher EIP is implemented in Camel.
Camel provides two operations in the DSL for implementing the pattern:
This aggregate method is a callback that you must implement.
The method has two parameters: the first, named oldExchange, contains the original exchange; the second, newExchange, is the enriched source.
Your task is to enrich the message using Java code and return the merged result.
This may sound a bit confusing, so let’s see it in action.
To solve the problem at Rider Auto Parts, you need to use pollEnrich because it’s capable of polling a file from an FTP server.
Listing 3.3 Using pollEnrich to merge additional data with an existing message.
The difference between pollEnrich and enrich The difference between pollEnrich and enrich is that the former uses a consumer and the latter a producer to retrieve data from the source.
Knowing the difference is important: the file component can be used with both, but using enrich will write the message content as a file; using pollEnrich will read the file as the source, which is most likely the scenario you’ll be facing when enriching with files.
The HTTP component only works with enrich; it allows you to invoke an external HTTP service and use its reply as the source.
The route is triggered by Quartz to run at 6 a.m.
You invoke the HTTP service to retrieve the orders and transform them to CSV format using a processor.
At this point, you need to enrich the existing data with the orders from the remote FTP server.
This is done by using pollEnrich B, which consumes the remote file.
First, you check whether any data was consumed or not.
If newExchange is null, there is no remote file to consume, and you just return the existing data.
If there is a remote file, you merge the data by concatenating the existing data with the new data and setting it back on the oldExchange.
Then, you return the merged data by returning the oldExchange.
To write the CSV report file, you use the file component D.
PollEnrich uses a polling consumer to retrieve messages, and it offers three timeout modes:
It will never wait for messages to arrive, so this mode will never block.
It’s a best practice to either use timeout = 0 or to assign a timeout value when using pollEnrich to avoid waiting indefinitely if no message arrives.
Enrich and pollEnrich can’t access information in the current exchange Neither enrich nor pollEnrich can leverage any information from the current exchange.
This means, for example, that you can’t store a filename header on the exchange for pollEnrich to use to select a particular file.
This may change in the future if the Camel team can find a solution.
Now let’s take a quick look at how to use enrich with Spring XML; it’s a bit different than when using the Java DSL.
Enrich is used when you need to enrich the current message with data from another source using request-response messaging.
A prime example would be to enrich the current message with the reply from a web service call.
But we’ll look at another example, using Spring XML to enrich the current message using the TCP transport:
Here you use the Camel mina component for TCP transport, configured to use request-response messaging by using sync=true option.
You’ve seen a lot about how to transform data in Camel, using Java code for the actual transformations.
Now let’s take a peek into the XML world and look at the XSLT component, which is used for transforming XML messages using XSLT stylesheets.
For example, XSLT can be used to transform XML into HTML for web pages or to transform an XML document into another XML document with a different structure.
Think twice before deciding to pick up and use XSLT.
Camel provides XSLT as a component in camel-spring.jar because it leverages Spring’s resource loading.
This means greater flexibility in loading stylesheets because Spring enables them to be loaded from various locations, such as the classpath, file paths, and over HTTP.
Using the XSLT component is straightforward because it’s just another Camel component.
The following route shows an example of how you could use it; this route is also illustrated in figure 3.5
The file consumer picks up new files and routes them to the XSLT component, which transforms the payload using the stylesheet.
After the transformation, the message is routed to a JMS producer, which sends the message to the JMS queue.
The part after the scheme is the URI location of the stylesheet to use.
As mentioned before, the Camel XSLT component leverages Spring to load the stylesheet.
You can prefix the resource name with any of the three prefixes listed in table 3.2
Let’s leave the XSLT world now and take a look at how you can do XML-to-object marshaling with Camel.
Table 3.2 Prefixes supported by the XSLT component for loading stylesheets.
If no prefix is provided, Camel loads the resource from the classpath.
Figure 3.5 A Camel route using an XSLT component to transform an XML document before it’s sent to a JMS queue.
Any software engineer who has worked with XML knows that it’s a challenge to use the low-level XML API that Java offers.
Instead, people often prefer to work with regular Java objects and use marshaling to transform between Java objects and XML representations.
In Camel, this marshaling process is provided in ready-to-use components known as data formats.
We’ll cover data formats in full detail in section 3.4, but we’ll take a quick look at the XStream and JAXB data formats here as we cover XML transformations using marshaling.
XStream is a simple library for serializing objects to XML and back again.
Suppose you need to send messages in XML format to a shared JMS queue, which is then used to integrate two systems.
When using the XML DSL, you can declare the data formats used at the top B of the <camelContext>
By doing this, you can share the data formats in multiple routes.
In the first route, where you send messages to a JMS queue, you use marshal C, which refers to the id from B, so Camel knows that the XStream data format is being used.
You can also use the XStream data format directly in the route, which can shorten the syntax a bit, like this:
The same route is a bit shorter to write in the Java DSL, because you can do it with one line per route:
And the reverse operation, unmarshaling from XML to an object, is just as simple:
Listing 3.4 Using XStream to transform a message into XML.
You’ve now seen how easy it is to use XStream with Camel.
Like XStream, it allows you to serialize objects to XML and back again.
It’s not as simple, but it does offer more bells and whistles for controlling the XML output.
And because it’s distributed in Java, you don’t need any special JAR files on the classpath.
Unlike XStream, JAXB requires that you do a bit of work to declare the binding between Java objects and the XML form.
Suppose you define a model bean to represent an order, as shown in listing 3.5, and you want to transform this into XML before sending it to a JMS queue.
Then you want to transform it back to the order bean again when consuming from the JMS queue.
Listing 3.5 shows how to use JAXB annotations to decorate your model object (omitting the usual getters and setters)
First you define @XmlRootElement B as a class-level annotation to indicate that this class is an XML element.
Then you define the @XmlAccessorType to let JAXB access fields directly.
To expose the fields of this model object as XML attributes, you mark them with the @XmlAttribute annotation.
Using JAXB, you should be able to marshal a model object into an XML representation like this:
Listing 3.5 Annotating a bean with JAXB so it can be transformed to and from XML.
Listing 3.6 shows how you can use JAXB in routes to transform the PurchaseOrder object to XML before it’s sent to a JMS queue, and then back again from XML to the PurchaseOrder object when consuming from the same JMS queue.
First you need to declare the JAXB data format B.
Note that a contextPath attribute is also defined on the JAXB data format—this is a package name that instructs JAXB to look in this package for classes that are JAXB-annotated.
The first route then marshals to XML C and the second route unmarshals to transform the XML back into the PurchaseOrder object D.
You can try this example by running the following Maven goal from the chapter3/ order directory:
It’s a plain text file in which each line lists the class name.
In the preceding example, the file contains a single line with the text PurchaseOrder.
That’s the basis of using XML object marshaling with XStream and JAXB.
Both of them are implemented in Camel via data formats that are capable of transforming back and forth between various well-known formats.
In Camel, data formats are pluggable transformers that can transform messages from one form to another and vice versa.
Listing 3.6 Using JAXB to serialize objects to and from XML.
You may already have realized that these two functions are opposites, meaning that one is capable of reversing what the other has done, as illustrated in figure 3.6
We touched on data formats in section 3.3, where we covered XML transformations.
This section will cover data formats in more depth and using other data types than XML, such as CSV and JSON.
We’ll even look at how you can create your own data formats.
We’ll start our journey by briefly looking at the data formats Camel provides out of the box.
Camel provides data formats for a range of well-known data models, as listed in table 3.3
Table 3.3 Data formats provided out of the box with Camel.
GZip Any camel-gzip Compresses and decompresses files (compatible with the popular gzip/gunzip tools)
Jackson JSON camel-jackson Transforms to and from JSON using the ultra-fast Jackson library.
Class Figure 3.6 An object is marshaled to a binary representation; unmarshal can be used to get the object back.
As you can see, Camel provides 18 data formats out of the box.
They’re among the most commonly used, and what you learn about those will also apply for the remainder of the data formats.
The camel-csv data format is capable of transforming to and from CSV format.
It leverages Apache Commons CSV to do the actual work.
Suppose you need to consume CSV files, split out each row, and send it to a JMS queue.
Sounds hard to do, but it’s possible with little effort in a Camel route:
You may not want to send each row as a List type to the JMS queue, so you can transform the row before sending, perhaps using a processor.
The same example in Spring XML is a bit different, as shown here:
Serialization Object camel-core Uses Java Object Serialization to transform objects to and from a serialized stream.
TidyMarkup HTML camel-tagsoup Tidies up HTML by parsing ugly HTML and returning it as pretty well-formed HTML.
XMLSecurity XML camel-xmlsecurity Facilitates encryption and decryption of XML documents.
Zip Any camel-core Compresses and decompresses messages; it’s most effective when dealing with large XML- or text-based payloads.
Table 3.3 Data formats provided out of the box with Camel (continued)
The noticeable difference is how you tell <split> that it should split up the message body.
To do this you need to provide <split> with an Expression, which is what the splitter should iterate when it performs the splitting.
To do so, you can use Camel’s built-in expression language called Simple (see appendix A), which knows how to do that.
This example is in the source code for the book in the chapter3/order directory.
You can try the examples by running the following Maven goals:
At first, the data types that the CSV data format uses may seem a bit confusing.
One problem with camel-csv is that it uses generic data types, such as Maps or Lists, to represent CSV records.
Often you’ll already have model objects to represent your data in memory.
Let’s look at how you can use model objects with the camel-bindy component.
The two existing CSV-related data formats (camel-csv and camel-flatpack) are older libraries that don’t take advantage of the new features in Java 1.5, such as annotations and generics.
In light of this deficiency, Charles Moulliard stepped up and wrote the camel-bindy component to take advantage of these new possibilities.
It’s capable of binding CSV, FIX, and fixed-length formats to existing model objects using annotations.
Table 3.4 Data types that camel-csv uses when transforming to and from CSV format.
OutputStream Contains multiple rows in CSV format where each row is separated by \n (newline)
Suppose you have a model object that represents a purchase order.
By annotating the model object with camel-bindy annotations, you can easily transform messages between CSV and Java model objects.
First you mark the class with the @CsvRecord annotation B to indicate that it represents a record in CSV format.
Then you annotate the fields with @DataField according to the layout of the CSV record C.
For numeric fields, you can additionally declare precision, which in this example is set to 2, indicating that the price should use two digits for cents.
Bindy also has attributes for fine-grained layout of the fields, such as pattern, trim, and length.
You can use pattern to indicate a data pattern, trim to trim the input, and length to restrict a text description to a certain number of characters.
Before we look at how to use Bindy in Camel routes, we need to take a step back and look at the data types Bindy expects to use.
Why doesn’t it just use a single model object for that? The answer is that you can have multiple model objects with the CSV.
Table 3.5 Data types that Bindy uses when transforming to and from CSV format.
OutputStream Contains multiple rows in CSV format where each row is separated by a \n (newline)
Contains a List of rows where each row contains 1..n data models contained in a Map.
In this listing, you first create and populate the order model using regular Java setters B.
Then you send the order model to the route by sending it to the direct:toCsv endpoint C that is used in the route.
The route will then marshal the order model to CSV using Bindy D.
Notice how Bindy is configured to use CSV mode via BindyType.Csv.
To let Bindy know how to map to order model object, you need to provide a package name that will be scanned for classes annotated with Bindy annotations.
Chapter 6 will covered testing with Camel, and you’ll learn all about using MockEndpoints.
Listing 3.8 Using Bindy to transform a model object to CSV format.
You can try this example from the chapter3/order directory using the following Maven goal:
The source code for the book also contains a reverse example of how to use Bindy to transform a CSV record into a Java object.
You can try it by using the following Maven goal:
Bindy is equally capable of working with fixed-length and FIX data formats, both of which follow the same principles as CSV.
It’s now time to leave CSV and look at a more modern format: JSON.
In this section, we’ll focus on camel-jackson because Jackson is a very popular JSON library.
Back at Rider Auto Parts, you now have to implement a new service that returns order summaries rendered in JSON format.
Doing this with Camel is fairly easy, because Camel has all the ingredients needed to brew this service.
Listing 3.9 shows how you could ramp up a prototype.
First you need to set up the JSON data format and specify that the Jackson library should be used B.
Then you define a route that exposes the HTTP service using the Jetty endpoint.
This example exposes the Jetty endpoint directly in the URI.
Whenever a request hits this HTTP service, it’s routed to the orderService bean C and the lookup method is invoked on that bean.
The result of this bean invocation is then marshaled to JSON format and returned back to the HTTP client.
The order service bean could have a method signature such as this:
Listing 3.9 An HTTP service that returns order summaries rendered in JSON format.
This signature allows you to implement the lookup logic as you wish.
Notice that the service bean can return a POJO that the JSON library is capable of marshaling.
For example, suppose you used the PurchaseOrder from listing 3.7, and had JSON output as follows:
The HTTP service itself can be invoked by an HTTP Get request with the id of the order as a parameter: http://0.0.0.0:8080/order/service?id=123
Notice how easy it is with Camel to bind the HTTP id parameter as the String id parameter with the help of the @Header annotation.
You can try this example yourself from chapter3/order directory by using the following Maven goal.
So far we’ve used data formats with their default settings.
But what if you need to configure the data format, such as to use another splitter character with the CSV data format? That’s the topic of the next section.
In section 3.4.2, you used the CSV data format, but this data format offers many additional settings.
This listing shows how you can configure the CSV data format.
Configuring data formats in Camel is done using regular Java code; you use the API that the data format provides.
In listing 3.10, the CSV data format offers a CSVConfig object B that is used to set the semicolon as a delimiter and to specify the order of the.
The data format itself is then created C and set to use the configuration.
The use of the data format stays the same, so all you need to do is refer to it from the marshal D or unmarshal methods.
This same principle applies to all data formats in Camel.
Now that you know how to use data formats, let’s look at how you can write your own data format.
You may find yourself needing to transform data to and from a custom data format.
In this section, we’ll look at how you can develop a data format that can reverse strings.
Let’s look at how you could implement a string-reversing data format.
The custom data format must implement the DataFormat interface, which forces you to develop two methods: marshal B and unmarshal C.
Listing 3.11 Developing a custom data format that can reverse strings.
The marshal method B needs to output the result to the OutputStream.
To do this, you need to get the message payload as a byte[], and then reverse it with a helper method.
Note that you use the Camel type converters to return the message payload as a byte[]
This is very powerful and saves you from doing a manual typecast in Java or trying to convert the payload yourself.
You use the Camel type-converter mechanism again to provide the message payload as a byte[]
Note that in this method you return the data instead of writing it to a stream.
You’ll find this example in the chapter3/order directory, and you can try it by using the following Maven goal:
You’ve now learned all about data formats and even how to develop your own.
It’s time to say goodbye to data formats and take a look at how you can use templating with Camel for data transformation.
Templating is extremely useful when you need to generate automatic reply emails.
FreeMarker—Another popular templating language that may be a bit more advanced than Velocity (http://camel.apache.org/freemarker.html)
These two templating languages are fairly similar to use, so we’ll only discuss Velocity here.
Rider Auto Parts has implemented a new order system that must send an email reply when a customer has submitted an order.
Thank you for ordering X piece(s) of XXX at a cost of XXX.
There are three pieces of information in the email that must be replaced at runtime with real values.
Table 3.6 Entities prepopulated in the Velocity context and that are available at runtime.
This can clash with a reserved word in some languages; use request instead.
This can clash with a reserved word in some languages; use response instead.
Using Velocity in a Camel route is as simple as this:
All you have to do is route the message to the Velocity endpoint that’s configured with the template you want to use, which is the rider/mail.vm file that’s loaded from the classpath by default.
All the template components in Camel leverage the Spring resource loader, which allows you to load templates from the classpath, file paths, and other such locations.
You can use the same prefixes listed in table 3.2
You can try this example by going to the chapter3/order directory in the book’s source code and running the following Maven goal:
We’ll now leave data transformation and look at type conversion.
Camel has a powerful type-converter mechanism that removes all need for boilerplate type-converter code.
Camel provides a built-in type-converter system that automatically converts between well-known types.
This system allows Camel components to easily work together without having type mismatches.
And from the Camel user’s perspective, type conversions are built into the API in many places without being invasive.
The getBody method is passed the type you want to have returned.
Under the covers, the type-converter system converts the returned type to a String if needed.
In this section, we’ll take a look at the insides of the type-converter system.
We’ll explain how Camel scans the classpath on startup to register type converters dynamically.
We’ll also show how you can use it from a Camel route, and how to build your own type converters.
To understand the type-converter system, you first need to know what a type converter in Camel is.
By using the TypeConverter, Camel can then convert one type to another using TypeConverter’s convertTo method, which is defined as follows:
This is a plain text file that has a list of packages that contain Camel type converters.
The special file is needed to avoid scanning every possible JAR and all their packages, which would be time consuming.
This special file tells Camel whether or not the JAR file contains type converters.
For example, the file in camelcore contains the following three entries:
The following code is a snippet from IOConverter class from camel-core JAR:
Camel will go over each method annotated with @Converter and look at the method signature.
The first parameter is the from type, and the return type is the to type—in this example you have a TypeConverter that can convert from a URL to an InputStream.
Now that you know how the Camel type converters are loaded, let’s look at using them.
As we mentioned, the Camel type converters are used throughout Camel, often automatically.
But you might want to use them to force a specific type to be used in a route, such as before sending data back to a caller or a JMS destination.
To do so, you can convert each file to a String, which forces the JMS component to use TextMessage.
This is easy to do in Camel—you use the convertBodyTo method, as shown here:
If you’re using Spring XML, you provide the type as an attribute instead, like this:
Another reason for using convertBodyTo is to read files using a fixed encoding such as UTF-8
This is done by passing in the encoding as the second parameter:
That’s all there is to using type converters in Camel routes.
Before we wrap up this chapter, though, let’s take a look at how you can write your own type converter.
You already saw what a type converter looks like in section 3.6.1, when we looked at how type converters work.
Suppose you wanted to write a custom type converter that can convert a byte[] into a PurchaseOrder model object (an object you used in listing 3.7)
As you saw earlier, you need to create a @Converter class containing the type-converter method.
In listing 3.12, the Exchange gives you access to the CamelContext and thus to the parent TypeConverter B, which you use in this method to convert between strings and numbers.
The rest of the code is the logic for parsing the custom protocol and returning the PurchaseOrder C.
Notice how you can use the converter to easily convert between well-known types.
All you need to do now is add the service discovery file, named TypeConverter, in the META-INF directory.
As explained previously, this file contains one line identifying each package to be scanned for @Converter classes.
This example can be found in the chapter3/converter directory of the book’s source code, which you can try using the following Maven goal:
And that completes this chapter on transforming data with Camel.
Listing 3.12 A custom type converter to convert from byte[] to PurchaseOrder type.
Data transformation is the cornerstone of any integration kit; it bridges the gap between different data types and formats.
It’s also essential in today’s industry because more and more disparate systems need to be integrated to support the ever-changing businesses and world we live in.
This chapter covered many of the possibilities Camel offers for data transformation.
You learned how to format messages using EIPs and beans.
You also learned that Camel provides special support for transforming XML documents using XSLT components and XML-capable data formats.
Camel provides data formats for well-known data models, which you learned to use, and it even allows you to build your own data formats.
We also took a look into the templating world, which can be used to format data in specialized cases, such as generating email bodies.
Finally, we looked at how the Camel type-converter mechanism works and learned that it’s used internally to help all the Camel components work together.
You learned how to use it in routes and how to write your own converters.
Here are a few key tips you should take away from this chapter:
Integrating IT systems often requires you to use different data formats when exchanging data.
Camel can act as the mediator and has strong support for transforming data in any way possible.
Use the various features in Camel to aid with your transformation needs.
Using Java code isn’t a worse solution than using a fancy mapping tool.
Even if it takes 50 lines of grunt boilerplate code to get the job done, you have a solution that can easily be maintained by fellow engineers.
If you’re using Java code for data transformation, you can use beans or processors.
Processors are more dependent on the Camel API, whereas beans allow loose coupling.
In the preceding two chapters, we’ve covered two crucial features of integration kits: routing and transformation.
The next chapter dives into the world of beans, and you’ll see how Camel can easily adapt to and leverage your existing beans.
This allows a higher degree of reuse and loose coupling, so you can keep your business and integration logic clean and apart from Camel and other middleware APIs.
Some of these models, especially the earlier ones, imposed a great deal on the programming model, dictating what you could and couldn’t do, and they often required complex packaging and deployment models.
This left the everyday engineer with a lot of concepts to learn and master.
In some cases, much more time was spent working around the restrictive programming and deployment models than on the business application itself.
Because of this growing complexity and the resulting frustrations, a simpler, more pragmatic programming model arose from the open source community: the POJO model.
The Spring Framework has opened the door to the enterprise, proving that the POJO programming model and a lightweight container indeed meet the Using beans with Camel.
If you’ve been developing software for five years or longer, you’ve likely worked.
In fact, the simple programming model and lightweight container concept proved superior to the heavyweight and over-complex enterprise application and integration servers that were used before.
So what does this have to do with Camel? Well, Camel doesn’t mandate using a specific component or programming model.
It doesn’t mandate a heavy specification that you must learn and understand to be productive.
Camel doesn’t require you to repackage any of your existing libraries or require you to use the Camel API to fulfill your integration needs.
Camel is on the same page as the Spring Framework, with both of them being lightweight containers favoring the POJO programming model.
In fact, Camel recognizes the power of the POJO programming model and goes great lengths to work with your beans.
By using beans, you fulfill an important goal in the software industry, which is to reduce coupling.
Camel not only offers reduced coupling with beans, but you get the same loose coupling with Camel routes.
For example, three teams can work simultaneously on their own sets of routes, which can easily be combined into one system.
We’ll start this chapter by showing you how not to use beans with Camel, which will make it clearer how you should use beans.
After that, we’ll take a look at the theory behind the Service Activator EIP and dive inside Camel to see how this pattern is implemented.
Finally, we’ll look at the bean-binding process, which gives you finegrained control over binding information to the parameters on the invoked method from within Camel and the currently routed message.
It may sound confusing at first, but don’t worry—it will make sense shortly.
In this section, we’ll walk through an example that shows how not to use beans with Camel—the hard way to use beans.
Then we’ll look at how to use beans the easy way.
Suppose you have an existing bean that offers an operation (a service) you need to use in your integration application.
For example, HelloBean offers the hello method as its service:
Let’s look at some different ways you could use this bean in your application.
By using a Camel Processor, you can invoke a bean from Java code.
Listing 4.1 Using a Processor to invoke the hello method on the HelloBean.
You use an inlined Camel Processor B, which gives you the process method, in which you can work on the message with Java code.
First, you must extract the message body from the input message, which is the parameter you’ll use when you invoke the bean later.
Then you need to instantiate the bean and invoke it C.
Finally you must set the output from the bean on the output message.
Now that you’ve done it the hard way using the Java DSL, let’s take a look at using Spring XML.
You’ll often use Spring as a bean container and define beans using its XML files.
First you define HelloBean in the Spring XML file with the id helloBean B.
You still want to use the Java DSL to build the route, so you need to declare a bean that contains the route.
Finally, you define a CamelContext, which is the way you get Spring and Camel to work together.
Listing 4.2 Setting up Spring to use a Camel route that uses the HelloBean.
The difference is that now the bean is injected using the Spring @Autowired annotation B, and instead of instantiating the bean, you use the injected bean directly C.
You can try these examples on your own; they’re in the chapter4/bean directory of the book’s source code.
Run Maven with these goals to try the last two examples:
So far you’ve seen two examples of using beans with a Camel route, and there’s a bit of plumbing to get it all to work.
Here are some reasons why it’s hard to work with beans:
You must extract data from the Camel message and pass it to the bean, and you must move any response from the bean back into the Camel message.
Now let’s look at the easy way of doing it.
Suppose you were to define the Camel route in the Spring XML file instead of using a RouteBuilder class.
First you define the bean as a Spring bean, and then you define the Camel route with the direct:start input.
At B you want to invoke HelloBean, but you’re in troublethis is XML, and you can’t add Java code in the XML file.
In Camel, the easy way to use beans is to use the <bean> tag at B:
Camel offers the same solution when using the Java DSL.
You can simplify the route in listing 4.3 like this:
That’s a staggering reduction from eight lines of code to one.
And on top of that, the one code line is much easier to understand.
It’s all high-level abstraction, containing no low-level code details, which were required when using inlined Processors.
You could even omit the hello method, because the bean only has a single method:
Using the <bean> tag is an elegant solution for working with beans.
Without using that tag, you had to use a Camel Processor to invoke the bean, which is a tedious solution.
Now let’s look at how you can work with beans in Camel from the EIP perspective.
It describes a service that can be invoked easily from both messaging and non-messaging services.
Figure 4.1 shows a service activator component that invokes a service based on an incoming request and returns an outbound reply.
The service activator acts as a mediator between the requester and the POJO service.
The requester sends a request to the service activator B, which is responsible for adapting the request to a format the POJO service understands (mediating) and passing the request on to the service C.
Figure 4.1 The service activator mediates between the requestor and the POJO service.
The POJO service then returns a reply to the service activator D, which passes it back (requiring no translation on the way back) to the waiting requester E.
As you can see in figure 4.1, the service is the POJO and the service activator is something in Camel that can adapt the request and invoke the service.
We’ll look at how this BeanProcessor works in section 4.4
You should regard the Camel Bean component as the Camel implementation of the Service Activator pattern.
Figure 4.2 shows how the Camel route maps to the Service Activator EIP.
The service activator itself is the bean node, which is represented by the BeanProcessor in Camel.
You now know the theory behind how Camel works with beans—the Service Activator pattern.
But before you can use a bean, you need to know where to look for it.
When Camel works with beans, it looks them up in a registry to locate them.
Camel’s philosophy is to leverage the best of the available frameworks, so it uses a pluggable registry architecture to integrate them.
Spring is one such framework, and figure 4.3 illustrates how the registry works.
Figure 4.3 A requester looks up a bean using the Camel registry, which then uses the Spring ApplicationContext to determine where the bean resides.
Figure 4.3 shows that the Camel registry is an abstraction that sits between the caller and the real registry.
When a requester needs to look up a bean B, it uses the Camel Registry.
The Camel Registry then does the lookup via the real registry C.
This structure allows loose coupling but also a pluggable architecture that integrates with multiple registries.
All the requester needs to know is how to interact with the Camel Registry.
You’ll most often use one of the first two methods to look up a bean by its name.
For example, to look up the HelloBean, you would do this:
To get rid of that ugly typecast, you can use the second method instead:
Under the hood, Camel uses its typeconverter mechanism to convert the bean to the desired type, if necessary.
The last method, lookupByType, is mostly used internally by Camel to support convention over configuration—it allows Camel to look up beans by type without knowing the bean name.
The registry itself is an abstraction and thus an interface.
SimpleRegistry A simple implementation to be used when unit testing or running Camel in the Google App engine, where only a limited number of JDK classes are available.
JndiRegistry An implementation that uses an existing Java Naming and Directory Interface (JNDI) registry to look up beans.
This implementation is automatically used when you’re using Camel in a Spring environment.
This implementation is automatically used when using Camel in an OSGi environment.
In the following sections, we’ll go over each of these four registries.
The SimpleRegistry is a Map-based registry that’s used for testing or when running Camel standalone.
For example, if you wanted to unit test the HelloBean example, you could use the SimpleRegistry to enlist the HelloBean and refer to it from the route.
First you create an instance of SimpleRegistry and populate it with HelloBean under the helloBean name B.
To aid when testing, you create a ProducerTemplate, which makes it simple to send messages to Camel, as can be seen in the test method.
Finally, when the test is done, you clean up the resources by stopping Camel D.
In the route, you use the beanRef method to invoke HelloBean by the helloBean name you gave it when it was enlisted in the registry B.
You can try this test by going to the chapter4/bean directory and running this Maven goal:
Listing 4.4 Using SimpleRegistry to unit test a Camel route.
The JndiRegistry, as its name implies, integrates with a JNDI-based registry.
It was the first registry that Camel integrated, so it’s also the default registry if you create a Camel instance without supplying a specific registry, as this code shows:
The JndiRegistry (like the SimpleRegistry) is often used for testing or when running Camel standalone.
Many of the unit tests in Camel use the JndiRegistry because they were created before the SimpleRegistry was added to Camel.
The JndiRegistry is useful when you use Camel together with a Java EE application server that provides a JNDI-based registry out of the box.
Suppose you need to leverage the JNDI registry of a WebSphere Application Server—you would have to set up the pieces as follows:
You need to use a Hashtable B to store information about the JNDI registry you wish to use.
Camel also allows you to use the JndiRegistry with Spring XML.
All you have to do is define it as a Spring bean and Camel will automatically pick it up:
You can use the usual Spring lingo to pass the Hashtable parameter in the JndiRegistry constructor.
The next registry is for when you use Spring together with Camel.
More precisely, it’s the default when you set up Camel in the Spring XML, as this snippet illustrates:
This registry allows you to define beans in Spring XML files as you would normally do when using Spring.
For example, you could define the helloBean bean as follows:
When you use Camel with Spring, you can keep on using Spring beans as you would normally, and Camel will use those beans seamlessly without any configuration.
The final registry applies when you use Camel with OSGi.
When Camel is used in an OSGi environment, Camel uses a two-step lookup process.
First, it will look up whether a service with the name exists in the OSGi service registry.
Suppose you want to expose HelloBean as an OSGi service.
With help from the osgi:service namespace provided by Spring Dynamic Modules (Spring DM; http://www.springsource.org/osgi), you export the HelloBean into the OSGi registry under the name helloService.
You can use the HelloBean from a Camel route the same way you’ve already learned, by referring to its OSG service name:
All you have to remember is the name with which the bean was exported.
Camel will look it up in the OSGi service registry and the Spring bean container for you.
Next we’ll focus on how Camel selects which method to invoke on a given bean.
You’ve seen how Camel works with beans from the route perspective.
Now it’s time to dig down and see the moving parts in action.
You first need to understand the mechanism Camel uses to selects the method to invoke.
Remember, Camel acts as a service activator using the BeanProcessor, which sits between the caller and the actual bean.
At compile time there are no direct bindings, and the JVM can’t link the caller to the bean—Camel must resolve this at runtime.
Figure 4.4 illustrates how the BeanProcessor leverages the registry to look up the bean to invoke.
At runtime, a Camel exchange is routed, and at a given point in the route, it reaches the BeanProcessor.
The BeanProcessor then processes the exchange, performing these general steps:
We’ve covered how registry lookups are done in section 4.3
The reason why this is more complex in Camel is because Camel has to compute which bean and method to invoke at runtime, whereas Java code is linked at compile time.
Figure 4.4 To invoke a bean in Camel, the BeanProcessor looks it up in the registry, selects and adapts a method, invokes it, and passes the returned value as the reply to the Camel exchange.
We’ll first take a look at the algorithm Camel uses to select the method.
Then we’ll look at a couple of examples and see what could go wrong and how to avoid problems.
Unlike at compile time, when the Java compiler can link method invocations together, the Camel BeanProcessor has to select the method to invoke at runtime.
At compile time, you can express your code to invoke the echo method like this:
This will ensure that the echo method is invoked at runtime.
On the other hand, suppose you use the EchoBean in Camel in a route as follows:
When the compiler compiles this code, it can’t see that you want to invoke the echo method on the EchoBean.
From the compiler’s point of view, EchoBean.class and "echo" are parameters to the bean method.
All the compiler can check is that the EchoBean class exists; if you had misspelled the method name, perhaps typing "ekko", the compiler could not catch this mistake.
Camel also allows you not to explicitly name a method.
For example, you could write the previous route as follows:
Why does Camel need to select a method? Why is there more than one possible method name when you invoke a method? The answer is that beans can have overloaded methods, and in some cases the method name isn’t specified either, which means Camel has to pick among all methods on the bean.
There are a total of three methods for Camel to select among.
If you explicitly tell Camel to use the echo method, you’re still left with two methods to choose from.
Regardless of whether the method name is explicitly given or not, Camel has to compute which method to invoke.
The BeanProcessor uses a complex algorithm to select which method to invoke on a bean.
You won’t need to understand or remember every step in this algorithm—we simply want to outline what goes on inside Camel to make working with beans as simple as possible for you.
If a method is explicitly defined, Camel uses it, as we mentioned at the start of this section.
If the bean can be converted to a Processor using the Camel type-converter mechanism, the Processor is used to process the message.
This may seem a bit odd, but it allows Camel to turn any bean into a message-driven bean equivalent.
This method is rarely used by end users of Camel, but it can be a useful trick.
If the body of the Camel message can be converted into an org.apache.
This is also rarely used by end users of Camel.
Continued in the second part of the algorithm, shown in figure 4.6
If an explicit method name was given, does at least one method exist with that name?
Is there only one method marked with other kinds of Camel annotations?
Figure 4.6 is a bit more complex, but its main goal is to narrow down the number of possible methods and select a method if one stands out.
Don’t worry if you don’t entirely understand the algorithm; we’ll look at a couple of examples shortly that should make it much clearer.
Let’s continue with the algorithm and cover the last steps:
If only a single method has been marked with the @Handler annotation, it’s selected.
We’ll look at how Camel binds to method parameters using annotations in section 4.5.3
If, among all the methods on the bean, there’s only one method with exactly one parameter, that method is selected.
For example, this would be the situation for the EchoBean bean we looked at in section 4.4.1, which has only the echo method with exactly one parameter.
Single parameter methods are preferred because they map easily with the payload from the Camel exchange.
There are multiple candidate methods, and Camel must determine whether there’s a single method that stands out as the best fit.
The strategy is to go over the candidate methods and filters out methods that don’t fit.
Camel does this by trying to match the first parameter of the candidate method; if the parameter isn’t the same type and it’s not possible to coerce the types, the method is filtered out.
In the end, if there is only a single method left, that method is selected.
Clearly Camel goes through a lot to select the method to invoke on your bean.
Over time you’ll learn to appreciate all this—it’s convention over configuration to the fullest.
This method-selection algorithm may change in the future to accommodate new features.
Now it’s time to take a look at how this algorithm applies in practice.
To see how this algorithm works, we’ll use the EchoBean from section 4.4.1 as an example, but we’ll add another method to it—the bar method—to better explain what happens when there are multiple candidate methods.
If you send the String message "Camel" to the Camel route, the reply logger will surely output "Camel Camel" as expected.
Despite the fact that EchoBean has two methods, echo and bar, only the echo method has a single parameter.
To make the example a bit more challenging, let’s change the bar method as follows:
What do you expect will happen now? You now have two identical method signatures with a single method parameter.
How can you resolve this? One solution would be to provide the method name in the route, such as specifying the bar method:
But there’s another solution that doesn’t involve specifying the method name in the route.
You can use the @Handler annotation to select the method.
The @Handler is a Camel-specific annotation that you can add to a method.
It simply tells Camel to use this method by default.
This ensures that Camel picks the method you want, and you won’t be surprised if Camel chooses another method.
Suppose you change EchoBean to include two methods with different parameter types:
The echo method works with a String, and the double method with an Integer.
If you don’t specify the method name, the BeanProcessor will have to choose between these two methods at runtime.
It does so by inspecting the message payloads of two or more candidate methods and comparing those with the message body type, checking whether there is an exact type match in any of the methods.
Suppose you send in a message to the route that contains a String body with the word "Camel"
It’s not hard to guess that Camel will pick the echo method, because it works with a String.
On the other hand, if you send in a message with the Integer value of 5, Camel will select the double method, because it uses the Integer type.
Despite this, things can still go wrong, so let’s go over a couple of common situations.
There are a few things that can go wrong when invoking beans at runtime:
This only happens when you have explicitly specified the method name.
This can happen even when an explicit method name was defined because the method could potentially be overloaded, which means the bean would have multiple methods with the same name; only the number of parameters would vary.
Type conversion failure—Before Camel invokes the selected method, it must convert the message payload to the parameter type required by the method.
Let’s take a look at examples of each of these three situations using the following EchoBean:
First, you could specify a method that doesn’t exist by doing this:
On the other hand, you could omit specifying the method name:
In this case, Camel can’t single out a method to use because both the echo and hello methods are ambiguous.
The last situation that could happen is when the message contains a body that can’t be converted to the type required by the method.
And suppose you need to use that bean in this route:
By further looking into this stacktrace, you may notice that the cause of this problem is that the XML parser couldn’t parse the data to XML.
You may wonder what would happen if such a situation occurred at runtime.
In this case, the Camel error-handling system would kick in and handle it.
That’s all you need to know about how Camel selects methods at runtime.
Now we need to look at the bean parameter-binding process, which happens after Camel has selected the method.
In the last section, we covered the process that selects which method to invoke on a bean.
This section covers what happens next—how Camel adapts to the parameters on the method signature.
Any bean method can have multiple parameters and Camel must somehow pass in meaningful values.
We’ve already seen parameter binding in action in the many examples so far in this chapter.
What those examples had in common was using a single parameter to which Camel bound the input message body.
Figure 4.7 How BeanProcessor binds the input message to the first parameter of the method being invoked.
The BeanProcessor uses the input message B to bind its body to the first parameter of the method C, which happens to be the String name parameter.
Camel does this by creating an expression that type-converts the input message body to the String type.
This ensures that when Camel invokes the echo method D, the parameter matches the expected type.
This is important to understand, because most beans have methods with a single parameter.
The first parameter is expected to be the input message body, and Camel will automatically convert the body to the same type as the parameter.
So what happens when a method has multiple parameters? That’s what we’ll look at in the remainder of the chapter.
Figure 4.8 illustrates the principle of bean parameter binding when multiple parameters are used.
Many new types come into play when you deal with multiple parameters.
The big box entitled “Bean parameter bindings” contains the following four boxes:
Figure 4.8 Parameter binding with multiple parameters involves a lot more options than with single parameters.
Exchange—This is the Camel exchange, which allows binding to the input message, such as its body and headers.
The Camel exchange is the source of the values that must be bound to the method parameters.
Camel annotations—When dealing with multiple parameters, you use annotations to distinguish them.
Camel language annotations—This is a less commonly used feature that allows you to bind parameters to languages.
It’s ideal when working with XML messages that allow you to bind parameters to XPath expressions.
Let’s start by looking at using the Camel built-in types.
Camel provides a set of fixed types that are always bound.
All you have to do is declare a parameter of one of the types listed in table 4.2
This contains the values that will be bound to the method parameters.
It contains the body that is often bound to the first method parameter.
This can be used in special circumstances when you need access to all Camel’s moving parts.
This can be used when you need to convert types.
Working with multiple parameters Using multiple parameters is more complex than using single parameters.
It’s generally a good idea to follow these rules of thumb:
Use the first parameter as the message body, which may or may not use the @Body annotation.
Use either a built-in type or add Camel annotations for subsequent parameters.
In our experience, it becomes complicated when multiple parameters don’t follow these guidelines, but Camel will make its best attempt to adapt the parameters to the method signature.
Let’s look at a couple of examples using the types from table 4.2
First, suppose you add a second parameter that’s one of the built-in types to the echo method:
In this example, you bind the CamelContext, which gives you access to all the moving parts of Camel.
Or you could bind the registry, in case you need to look up some beans:
You aren’t restricted to having only one additional parameter; you can have as many as you like.
For example, you could bind both the CamelContext and the registry:
So far, you’ve always bound to the message body; how would you bind to a message header? The next section will explain that.
Camel provides a range of annotations to help bind from the exchange to bean parameters.
You should use these annotations when you want more control over the bindings.
For example, without these annotations, Camel will always try to bind the method body to the first parameter, but with the @Body annotation you can bind the body to any parameter in the method.
And you have a Camel message that contains the following data:
With the help of Camel annotations, you can bind the Exchange to the method signature as follows:
This allows you to look up beans in the registry.
Camel will only bind to this if the exchange has failed and contains an exception.
You’ve already seen the first two types in action, so let’s try a couple of examples with the other annotations.
For example, you could use @Headers to bind the input headers to a Map type:
You would use this when you have many headers, so you don’t have to add a parameter for every single header.
The @OutHeaders annotation is used when you’re working with request-response messaging (also identified as the InOut Message Exchange pattern)
OutHeaders provides direct access to the output message headers, which means you can manipulate these headers directly from the bean.
The idea is that you put the headers that you want to preserve in the output message into this map.
Finally, let’s look at Camel’s language annotations, which bind parameters to a language.
Camel provides additional annotations that allow you to use other languages as parameters.
This may sound a bit strange, but it will become clearer with an example.
This allows you to add headers to the output message.
The most common language to use is XPath, which allows you to evaluate XPath expressions on the message body.
For example, suppose the message contains the following XML document:
By using XPath expressions, you can extract parts of the document and bind them to parameters, like this:
You can bind as many parameters as you like—the preceding example binds two parameters using the @XPath annotations.
In the future, we may add additional languages to Camel, which often also means that a corresponding annotation for bean parameter binding is added as well.
Suppose you already have a service that must be used to stamp unique order IDs on incoming orders.
Simple Evaluates a Simple expression (Simple is a built-in language provided with Camel; see appendix A for more details)
As you can see, the service creates a new XML attribute with the value of the given order ID B.
Then it inserts this attribute in the XML document C using the rather clumsy XML API from Java C.
To generate the unique order ID, you have the following class:
In a real system, you’d generate unique order IDs based on another scheme.
In Camel, you have the following route that listens for new order files and invokes.
To do this, you need to declare a bean in the spring XML file with the ID generator, as follows:
Now you’re ready to connect the last pieces of the puzzle.
To do this, you use the @Bean annotation and change the method signature to the following:
We’ve prepared a unit test you can use to run this example.
Listing 4.5 A service that stamps an order ID on an XML document.
When it’s running, you should see two log lines that output the XML order before and after the service has stamped the order ID.
Here you can see that the second log line has an orderId attribute with the value of 7303381, whereas the first doesn’t.
If you run it again, you’ll see a different order ID because it’s a random value.
You can experiment with this example, perhaps changing how the order ID is generated.
When using namespaces the bean parameter binding must include the namespace(s) in the method signature as highlighted:
The prefix value isn’t required to be a certain value; instead of c you can use any value you like.
The source code for the book contains this example in the chapter4/bean directory; you can try using the following Maven goal:
Bean binding summary Camel’s rules for bean parameter binding can be summarized as follows:
Camel has a flexible mechanism that adapts to your existing beans, and when you have multiple parameters, Camel provides annotations to bind the parameters properly.
We’ve now covered another cornerstone of using beans with Camel.
It’s important that end users of Camel can use the POJO programming model and have Camel easily leverage those beans (POJOs)
Beans are just Java code, which is a language you’re likely to feel comfortable using.
If you hit a problem that you can’t work around or figure out how to resolve using Camel and EIPs, you can always resort to using a bean and letting Camel invoke it.
We unlocked the algorithm used by Camel to select which method to invoke on a bean.
You learned why this is needed—Camel must resolve method selection at runtime, whereas regular Java code can link method invocations at compile time.
We also covered what bean parameter binding is and how you can bind a Camel exchange to any bean method and its parameters.
You learned how to use annotations to provide fine-grained control over the bindings, and even how Camel can help bind XPath expressions to parameters, which is a great feature when working with XML messages.
Let’s pull out some of the key practices you should take away from this chapter:
Camel is capable of adapting to existing bean method signatures, so you can leverage any existing API you may have, even if it has no dependency on the Camel API.
Unit testing is also easier because your beans don’t depend on any Camel API.
You can even have developers with no Camel experience develop the beans, and then have developers with Camel experience use those beans.
Camel bean binding is much simpler when method signatures have as few parameters as possible.
Tell Camel which method you intend to invoke, so Camel doesn’t have to figure this out itself.
You can also use @Handler in the bean to tell Camel which method it should pick and use.
Use the powers that the various Camel bean parameter annotations offer.
We’ve now covered three crucial features of integration kits: routing, transformations, and using beans.
We’ll now take a leap into another world, one that’s often tackled as an afterthought in integration projects: how to handle situations when things go wrong.
We’ve devoted an entire chapter to Camel’s extensive support for error handling.
In the last three chapters, we’ve covered three key functions that any integration kit should provide: routing, transformation, and mediation.
In this chapter, we turn our focus to what happens when things go wrong.
We want to introduce you to error handling early in this book, because we firmly believe that error handling should not be an afterthought but a key piece in your design from the start.
Writing applications that integrate disparate systems are a challenge when it comes to handling unexpected events.
In a single system that you fully control, you can handle these events and recover.
But systems that are integrated over the network have additional risks: the network connection could be broken, a remote system might not respond in a timely manner, or it might even fail for no apparent Error handling.
Even on your local server, unexpected events can occur, such as the server’s disk filling up or the server running out of memory.
Regardless of which errors occur, your application should be prepared to handle them.
In these situations, log files are often the only evidence of the unexpected event, so logging is important.
Camel has extensive support for logging and for handling errors to ensure your application can continue to operate.
In this chapter, you’ll discover how flexible, deep, and comprehensive Camel’s error handling is and how to tailor it to deal with most situations.
We’ll cover all the error handlers Camel provides out of the box, and when they’re best used, so you can pick the ones best suited to your applications.
You’ll also learn how to configure and master redelivery, so Camel can try to recover from particular errors.
We’ll also look at exception policies, which allow you to differentiate among errors and handle specific ones, and at how scopes can help you define general rules for implementing routescoped error handling.
Finally, we’ll look at what Camel offers when you need finegrained control over error handling, so that it only reacts under certain conditions.
Before jumping into the world of error handling with Camel, we need to take a step back and look at errors more generally.
There are two main categories of errors, recoverable and irrecoverable, and we need to look at where and when error handling starts, because there are some prerequisites that must happen beforehand.
When it comes to errors, we can divide them into recoverable and irrecoverable errors, as illustrated in figure 5.1
An irrecoverable error is an error that remains an error now matter how many times you try to perform the same action again.
In the integration space, that could mean trying to access a database table that doesn’t exist, which would cause the JDBC driver to throw an SQLException.
A recoverable error, on the other hand, is a temporary error that might not cause a problem on the next attempt.
On a subsequent attempt, the network issue could be resolved and your application could continue to operate.
Figure 5.1 Errors can be categorized as either recoverable or irrecoverable.
Irrecoverable errors continue to be errors on subsequent attempts; recoverable errors may be quickly resolved on their own.
In your daily life as a Java developer, you won’t encounter this division of errors into recoverable and irrecoverable often.
Generally, exception handling code uses one of the two patterns illustrated in the following two code snippets.
The first snippet illustrates a common error-handling idiom, where all kinds of exceptions are considered irrecoverable and you give up immediately, throwing the exception back to the caller, often wrapped:
The next snippet improves on this situation by adding a bit of logic to handle redelivery attempts before eventually giving up:
Around the invocation of the service is the logic that attempts redelivery, in case an error occurs.
After five attempts, it gives up and throws the exception.
What the preceding example lacks is logic to determine whether the error is recoverable or irrecoverable, and to react accordingly.
In the recoverable case, you could try again, and in the irrecoverable case, you could give up immediately and rethrow the exception.
For example, to set "Unknown customer" as a fault message, you would do the following:
The fault flag must be set using the setFault(true) method.
So why are the two types of errors represented differently? There are two reasons:
First, the Camel API was designed around the Java Business Integration (JBI) specification, which includes a fault message concept.
Second, Camel has error handling built into its core, so whenever an exception is thrown back to Camel, it catches it and sets the thrown exception on the Exchange as a recoverable error, as illustrated here:
Using this pattern allows Camel to catch and handle all exceptions that are thrown.
Camel’s error handling can then determine how to deal with the errors—retry, propagate the error back to the caller, or do something else.
End users of Camel can set irrecoverable errors as fault messages, and Camel can react accordingly and stop routing the message.
Now that you’ve seen recoverable and irrecoverable errors in action, let’s summarize how they’re represented in Camel:
Now let’s look at when and where Camel’s error handling applies.
Figure 5.2 Camel’s error handling only applies within the lifecycle of an exchange.
You have a file consumer and producer as the input and output facilities, and in between is the Camel routing engine, which routes messages encompassed in an exchange.
It’s during the lifecycle of this exchange that the Camel error handling applies.
That leaves a little room on the input side where this error handling can’t operate—the file consumer must be able to successfully read the file, instantiate the Exchange, and start the routing before the error handling can function.
So what happens if the file consumer can’t read the file? The answer is componentspecific, and each Camel component must deal with this in its own way.
Some components will ignore and skip the message, others will retry a number of times, and others will gracefully recover.
You can learn more about this on the Camel website, at http://camel.apache.org/polling-consumer.html.
That’s enough background information—let’s dig into how error handling in Camel works.
In the next section, we’ll start by looking at the different error handlers Camel provides.
This means error handlers in Camel will only react to exceptions set on the exchange.
By default, they won’t react if an irrecoverable error has been set as a fault message.
Transactions are covered in chapter 9 and are only briefly touched on in this chapter.
At first glance, having five error handlers may seem overwhelming, but you’ll learn that the default error handler is used in most cases.
That class contains the majority of the error-handling logic that the first three error handlers all leverage.
We’ll look at each of these error handlers in turn.
The default error handler is preconfigured and doesn’t need to be explicitly declared in the route.
So what happens if an exception is thrown from the validate method on the order service bean?
To answer this, we need to dive into Camel’s inner processing, where the error handler lives.
In every Camel route, there is a Channel that sits between each node in the route graph, as illustrated in figure 5.3
The Channel is in between each node of the route path, which ensures it can act as a controller that monitors and controls the routing at runtime.
This is the feature that allows Camel to enrich the route with error handling, message tracing, interceptors, and much more.
For now, you just need to know that this is where the error handler lives.
Turning back to the example route, imagine that an exception was thrown from the order service bean during invocation of the validate method.
In figure 5.3, the processor D would throw an exception, which would be propagated back to the previous channel C, where the error handler would catch it.
For example, Camel could try again (redeliver), or it could route.
NoErrorHandler This handler is used to disable error handling altogether.
Figure 5.3 A detailed view of a route path, where channels act as controllers between the processors.
With the default settings, Camel will propagate the exception back to the caller.
These settings match what happens when you’re working with exceptions in Java, so Camel’s behavior won’t surprise Camel end users.
Let’s continue with the next error handler, the dead letter channel.
The DeadLetterChannel error handler is similar to the default error handler except for the following differences:
The dead letter channel is the only error handler that supports moving failed messages to a dedicated error queue, which is known as the dead letter queue.
Unlike the default error handler, the dead letter channel will, by default, handle exceptions and move the failed messages to the dead letter queue.
The dead letter channel supports using the original input message when a message is moved to the dead letter queue.
Let’s look at each of these in a bit more detail.
The DeadLetterChannel is an error handler that implements the principles of the Dead Letter Channel EIP.
This pattern states that if a message can’t be processed or delivered, it should be moved to a dead letter queue.
As you can see, the consumer B consumes a new message that is supposed to be routed to the processor D.
The channel C controls the routing between B and D, and if the message can’t be delivered to D, the channel invokes the deal letter channel error handler, which moves the message to the dead letter queue E.
This keeps the message safe and allows the application to continue operating.
Instead of allowing a failed message to block new messages from being picked up, the message is moved to a dead letter queue to get it out of the way.
Figure 5.4 The Dead Letter Channel EIP moves failed messages to a dead letter queue.
The same idea applies to the dead letter channel error handler in Camel.
This error handler has an associated dead letter queue, which is based on an endpoint, allowing you to use any Camel endpoint you choose.
For example, you can use a database, a file, or just log the failed messages.
When you choose to use the dead letter channel error handler, you must configure the dead letter queue as an endpoint so the handler knows where to move the failed messages.
This is done a bit differently in the Java DSL and Spring XML.
For example, here is how you’d log the message at ERROR level in Java DSL:
And here is how you’d do it in Spring XML:
Now, let’s look at how the dead letter channel error handler handles exceptions when it moves the message to the dead letter queue.
By default, Camel handles exceptions by suppressing them; it removes the exceptions from the exchange and stores them as properties on the exchange.
After a message has been moved to the dead letter queue, Camel stops routing the message and the caller regards it as processed.
Suppose you have a route in which the message goes through a series of processing steps, each altering a bit of the message before it reaches its final destination, as in the following code:
Now imagine that an exception occurs at the validate method, and the dead letter channel error handler moves the message to the dead letter queue.
Suppose a new message arrives and an exception occurs at the enrich method, and this message is also moved to the same dead letter queue.
If you want to retry those messages, can you just drop them into the inbox queue?
In theory, you could do this, but the messages that were moved to the dead letter queue no longer match the messages that originally arrived at the inbox queue—they.
What you want instead is for the original message content to have been moved to the dead letter queue, so that you have the original message to retry.
The useOriginalMessage option instructs Camel to use the original message when it moves messages to the dead letter queue.
You configure the error handler to use the useOriginalMessage option as follows:
Chapter 9 focuses on transactions and discusses this error handler in detail, so we won’t say much about it here.
For now, you just need to know that it exists and it’s a core part of Camel.
The remaining two error handlers are seldom used and are much simpler.
The current architecture of Camel mandates that an error handler must be configured, so if you want to disable error handling, you need to provide an error handler that’s basically an empty shell with no real logic.
The logger uses standard log format from log kits such as log4j, commons logging, or the Java Util Logger.
Let’s now look at the major features these error handlers provide.
At this point, you may be eager to see the error handlers in action.
In section 5.4.6 we’ll build a use case that introduces error handling, so there will be.
Using error handlers with redelivery plenty of opportunities to try this on your own.
Exception policies and error handling will be covered in section 5.4
Communicating with remote servers relies on network connectivity that can be unreliable and have outages.
Luckily these disruptions cause recoverable errors—the network connection could be reestablished in a matter of seconds or minutes.
Remote services can also be the source of temporary problems, such as when the service is restarted by an administrator.
To help address these problems, Camel supports a redelivery mechanism that allows you to control how recoverable errors are dealt with.
In this section, we’ll take a look at a real-life error-handling scenario, and then focus on how Camel controls redelivery and how you can configure and use it.
We’ll also take a look at how you can use error handlers with fault messages.
We’ll end this section by looking at error-handling scope and how it can be used to support multiple error handlers scoped at different levels.
Suppose you have developed an integration application at Rider Auto Parts that once every hour should upload files from a local directory to an HTTP server, and your boss asks why the files haven’t been updated in the last few days.
You’re surprised, because the application has been running for the last month without a problem.
This could well be a situation where neither error handling nor monitoring was in place.
Redelivery policies Redelivery policies allow you to define policies for whether or not redelivery should be attempted.
The policies also define settings such as the maximum number of redelivery attempts, delays between attempts, and so on.
Scope Camel error handlers have two possible scopes: context (high level) and route (low level)
The context scope allows you to reuse the same error handler for multiple routes, whereas the route scope is used for a single route only.
Exception policies Exception policies allow you to define special policies for specific exceptions.
Error handling This option allows you to specify whether or not the error handler should handle the error.
You can let the error handler deal with the error or leave it for the caller to handle.
But there is no explicit error handling configured, so if an error occurs, the default error handler is triggered.
That handler doesn’t handle the exception but instead propagates it back to the caller.
Because the caller is the file consumer, it will log the exception and do a file rollback, meaning that any picked-up files will be left on the file system, ready to be picked up in the next scheduled poll.
At this point, you need to reconsider how errors should be handled in the application.
You aren’t in major trouble, because you haven’t lost any files—Camel will only move successfully processed files out of the upload folder—failed files will just stack up.
The error occurs when sending the files to the HTTP server, so you look into the log files and quickly determine that Camel can’t connect to the remote HTTP server due to network issues.
Your boss decides that the application should retry uploading the files if there’s an error, so the files won’t have to wait for the next hourly upload.
But let’s take a closer look at how to use redelivery with Camel.
The first three error handlers in table 5.1 all support redelivery.
A redelivery policy defines how and whether redelivery should be attempted.
Table 5.3 outlines the options supported by the redelivery policy and what the default settings are.
RedeliveryDelay long 1000 Fixed delay in milliseconds between each redelivery attempt.
This is used when you specify nonfixed delays, such as exponential backoff, to avoid the delay growing too large.
When a redelivery is scheduled to be redelivered in the future, Camel would normally have to block the current thread until it’s time for redelivery.
By enabling this option, you let Camel use a scheduler so that an asynchronous thread will perform the redelivery.
This ensures that no thread is blocked while waiting for redelivery.
BackOffMultiplier double 2.0 Exponential backoff multiplier used to multiply each consequent delay.
DelayPattern String - A pattern to use for calculating the delay.
The pattern allows you to specify fixed delays for interval groups.
LogStackTrace boolean true Specifies whether or not stacktraces should be logged when all redelivery attempts have failed.
LogRetryStackTrace boolean false Specifies whether or not stacktraces should be logged when a delivery has failed.
LogRetryAttempted boolean true Specifies whether or not redelivery attempts should be logged.
LogExhausted boolean true Specifies whether or not the exhaustion of redelivery attempts (when all redelivery attempts have failed) should be logged.
LogHandled boolean false Specifies whether or not handled exceptions should be logged.
Table 5.3 Options provided in Camel for configuring redelivery (continued)
In the Java DSL, Camel has fluent builder methods for configuring the redelivery policy on the error handler.
For instance, if you want to redeliver up to five times, use exponential backoff, and have Camel log at WARN level when it attempts a redelivery, you could use this code:
There are two things to notice in this Spring XML configuration.
By using the type option on the <errorHandler> tag, you select which type of error handler to use.
We’ve now established that Camel uses the information from the redelivery policy to determine whether and how to do redeliveries.
But what happens inside Camel? As you’ll recall from figure 5.3, Camel includes a Channel between every processing step in a route path, and there is functionality in these Channels, such as error handlers.
The error handler detects every exception that occurs and acts on it, deciding what to do, such as redeliver or give up.
This configuration first defines a context-scoped error handler B that will attempt at most two redeliveries using a 1-second delay.
When it attempts the redelivery, it will log this at the WARN level (as you’ll see in a few seconds)
The example is constructed to fail when the message reaches the enrich method C.
You can run this example using the following Maven goal from the chapter5/ errorhandler directory:
When running the example, you’ll see the following log entries outputted on the console.
These log entries show that Camel failed to deliver a message, which means the entry is logged after the attempt is made.
Camel also logs the exchangeId (which you can use to correlate messages) and the exception that caused the problem (without the stacktrace, by default)
When Camel performs a redelivery attempt it does this at the point of origin.
After all redelivery attempts have failed, we say it’s exhausted, and Camel logs this at the ERROR level by default.
You can customize this with the options listed in table 5.3
When the redelivery attempts are exhausted, the log entry is similar to the previous ones, but Camel explains that it’s exhausted after three attempts:
We encourage you to try loading this example into your IDE and playing with it.
Change the settings on the error handler and see what happens.
The preceding log output identifies the number of redelivery attempts, but how does Camel know this? Camel stores this information on the Exchange.
Table 5.4 Headers on the Exchange related to error handling.
The information in table 5.4 is only available when Camel performs a redelivery; these headers are absent on the regular first attempt.
It’s only when a redelivery is triggered that these headers are set on the exchange.
In the previous example, the error handler was configured to use delayed redelivery with a 1-second delay between attempts.
When a redelivery is to be conducted, Camel will wait for 1 second before carrying out the redelivery.
There will also be situations where you want to use asynchronous delayed redelivery.
The consumer will pick up the first order from the queue and process it.
In the synchronous case, the consumer thread is blocked while waiting to carry out the redelivery.
This means the second order on the queue can only be processed when the first order has been completed.
Instead of the consumer thread being blocked, it will break out and be able to pick up the second order from the queue and continue processing it.
This helps achieve higher scalability because threads aren’t blocked and doing nothing.
Instead the threads are being put to use servicing new requests.
The Delayer and Throttler EIPs have similar asynchronous delayed modes, which you can leverage by enabling the asyncDelayed option.
The source code for the book contains an example that illustrates the difference between synchronous and asynchronous delayed redelivery, in the chapter5/ errorhandler directory.
The example contains two methods: one for the synchronous mode and another for the asynchronous.
The console output for the synchronous mode should be displayed in the following order:
Compare that with the following output from the asynchronous mode:
Notice how the Camel in Action order is processed immediately when the first order fails and is scheduled for redelivery.
Also pay attention to the thread name that executes the redelivery, identified by [rRedeliveryTask] being logged.
As you can see, it’s not the consumer anymore; its a redelivery task.
Scopes can be used to define error handlers at different levels.
Camel supports two scopes: a context scope and a route scope.
Camel allows you to define a global context-scoped error handler that’s used by default, and, if needed, you can also configure a route-scoped error handler that applies only for a particular route.
Listing 5.1 is an improvement over the previous error-handling example.
The default error handler is configured as in the previous example B, but you have a new route that picks up files, processes them, and sends them to the second route.
This first route will use the default error handler B because it doesn’t have a route-scoped error handler configured, but the second route has a route-scoped error handler C.
It’s a Dead Letter Channel that will send failed messages to a log.
Notice that it has different options configured than the former error handler.
This example should fail for some messages when the enrich D method is invoked.
This demonstrates how the route-scoped error handler is used as error handler.
The most interesting part of this test class is the testOrderActiveMQ method, which will fail in the second route and therefore show the Dead Letter Channel in action.
The following snippets show what happens at the end when the error handler is exhausted.
As you can see, the Dead Letter Channel moves the message to its dead letter queue, which is the log://DLC endpoint.
After this, Camel also logs an ERROR line indicating that this move was performed.
We encourage you to try this example and adjust the configuration settings on the error handlers to see what happens.
So far, the error-handling examples we’ve looked at have used the Java DSL.
Let’s take a look at configuring error handling with Spring XML.
Let’s revise the example in listing 5.1 to use Spring XML.
To use a context-scoped error handler in Spring XML, you must configure it using an errorHandlerRef attribute B on the camelContext tag.
The errorHandlerRef refers to an <errorHandler>, which in this case is the default error handler with id "defaultEH" C.
There’s another error handler, a DeadLetterChannel error handler D, that is used at route scope in the second route E.
As you can see, the differences between the Java DSL and Spring XML mostly result from using the errorHandlerRef attribute to reference the error handlers in Spring XML, whereas Java DSL can have route-scoped error handlers within the routes.
You can try this example by running the following Maven goal from the chapter5/ errorhandler directory:
In the introduction to section 5.2, we mentioned that by default the Camel error handlers will only react to exceptions.
Because a fault isn’t represented as an exception but as a message that has the fault flag enabled, faults will not be recognized and handled by Camel error handlers.
There may be times when you want the Camel error handlers handle faults as well.
Suppose a Camel route invokes a remote web service that returns a fault message, and you want this fault message to be treated like an exception and moved to a dead letter queue.
We’ve implemented this scenario as a unit test, simulating the remote web service using a bean:
Now, imagine that the orderService bean returns the following SOAP fault:
Under normal situations, the Camel error handler won’t react when the SOAP fault occurs.
To make it do so, you have to instruct Camel by enabling fault handling.
To enable fault handling on the CamelContext (context scope), you simply do this:
To enable it on a per route basis (route scope), do this:
Once fault handling is enabled, the Camel errors handlers will recognize the SOAP faults and react.
Under the hood, the SOAP fault is converted into an Exception with the help of an interceptor.
You can enable fault handling in Spring XML as follows:
We’ll continue in the next section to look at the other two major features that error handlers provide, as listed in table 5.2: exception policies and error handling.
Exception policies are used to intercept and handle specific exceptions in particular ways.
For example, exception policies can influence, at runtime, the redelivery policies the error handler is using.
They can also handle an exception or even detour a message.
We’ll cover exception policies piece by piece, looking at how they catch exceptions, how they works with redelivery, and how they handle exceptions.
Then we’ll take a look at custom error handling and put it all to work in an example.
We’ll start by looking at how Camel inspects the exception hierarchy to determine how to handle the error.
This will give you a better understanding of how you can use onException to your advantage.
Camel will traverse the hierarchy from the bottom up to the root searching for an onException that matches the exception.
For each of those three exceptions, Camel will compare the exception to the defined onExceptions to select the best matching onException policy.
If no suitable policy can be found, Camel relies on the configured error handler settings.
We’ll drill down and look at how the matching works, but for now you can think of this as Camel doing a big instanceof check against the exceptions in the hierarchies, following the order in which the onExceptions were defined.
The aforementioned ConnectException is being thrown, and the Camel error handler is trying to handle this exception.
Because you have an exception policy defined, it will check whether the policy matches the thrown exception or not.
No more matching takes place—Camel got an exact match, and the exception policy will be used.
When an exception policy has been selected, its configured policy will be used by the error handler.
Any value configured on the exception policy will override options configured on the error handler.
Because the onException has the same option configured, its value of 3 will be used instead.
It has multiple test methods, each showing a scenario of how onException works.
Let’s make the example a bit more interesting and add a second onException definition:
This allows you to define different strategies for different kinds of exceptions.
In this example, it is configured to use more redelivery attempts for connection exceptions than for order failures.
But what if there are no direct matches? Let’s look at another example.
In this case, there are no onException definitions that match, and Camel will fall back to using the configuration of the current error handler.
You can see this in action by running the following Maven goal from chapter 5/ onexception directory:
Can Camel do better if there isn’t a direct hit? Yes, it can, because Camel uses a gapdetection mechanism that calculates the gaps between a thrown exception and the onExceptions and then selects the onException with the lowest gap as the winner.
This may sound confusing, so let’s look at an example.
Suppose you have these three onException definitions, each having a different redelivery policy:
Because there are no direct matches, Camel uses gap detection.
In the case of a tie, Camel will always pick the first match, because the cause exception is most likely the last in the hierarchy.
Gap detection allows you to define coarse-grained policies and also to have a few finegrained policies that overrule the coarse-grained ones.
Does this sound familiar? Yes, it’s related to the scoping that we covered in section 5.3
So far, you’ve only seen examples with one exception per onException, but you can define multiple exceptions in the same onException:
Even though we’ve touched on this already in our examples, we’ll go into the details in the next section.
You use the Camel Jetty component to expose an HTTP service where statuses of pending orders can be queried.
The order status information is retrieved from a remote ERP system by the MINA component using low-level socket communication.
You’ve learned how to configure this on the error handler itself, but it’s also possible to configure this on the onException.
Suppose you want Camel to retry invoking the external TCP service, in case there has been an IO-related error, such as a lost network connection.
To do this, you can simply add the onException and configure the redelivery policy as you like.
In the following example, the redelivery tries at most 5 times:
Camel will use the default redelivery policy settings outlined in table 5.3 and then override those values with values defined in the onException.
Because the delay was not overridden in the onException, the default value of 1 second is used.
This is convention over configuration, because you only need to configure the differences, which is often just the number of redelivery attempts or a different redelivery delay.
What would the redelivery delay be now, if an IOException were thrown? I am sure you’ll say the answer is 3—the value defined on the error handler.
The reason why Camel implements this behavior is our next topic: using onException to handle exceptions.
Suppose you have a complex route that processes a message in multiple steps.
Each step does some work on the message, but any step can throw an exception to indicate that the message can’t be processed and that it should be discarded.
This is where handling exceptions with onException comes into the game.
Handling an exception with onException is similar to exception handling in Java itself.
You can think of it as being like using a try ...
Imagine you need to implement an ERP server-side service that serves order statuses.
This is the ERP service you called from the previous section:
This snippet of pseudocode involves multiple steps in generating the response.
If something goes wrong, you catch the exception and return a failure response B.
We call this pseudocode because it shows your intention but the code won’t compile.
This is because the Java DSL uses the fluent builder syntax, where method calls are stacked together to define the route.
Listing 5.3 shows how you can make the code compile and work at runtime as you would expect with a try ...
The blocks only work in the route in which they’re defined.
OnException, on the other hand, works in both context and route scopes, so you can try revising listing 5.3 using onException.
A difference between doCatch and onException is that doCatch will handle the exception, whereas onException will, by default, not handle it.
That’s why you use handled(true) B to instruct Camel to handle this exception.
As a result, when a JmsException is thrown, the application acts as if the exception were caught in a catch block using the regular Java try ...
In listing 5.4, you should also notice how the concerns are separated and the normal route path is laid out nicely and simply; it isn’t mixed up with the exception handling.
Imagine that a message arrives on the TCP endpoint, and the Camel application routes the message.
The message passes the validate processor and is about to be sent to the JMS queue, but this operation fails and a JmsException is thrown.
Figure 5.5 is a sequence diagram showing the steps that take place inside Camel in such a situation.
It shows how onException is triggered to handle the exception.
Figure 5.5 shows how the JmsProducer throws the JmsException to the Channel, which is where the error handler lives.
The route has an OnException defined that reacts when a JmsException is thrown, and it processes the message.
Figure 5.5 Sequence diagram of a message being routed and a JmsException being thrown from the JmsProducer, which is handled by the onException.
OnException generates a failure that is to be returned to the caller.
This is important to remember, because it must be specified when you want to handle the exception.
Handling an exception will not continue routing from the point where the exception was thrown.
Camel will break out of the route and continue routing on the onException.
If you want to ignore the exception and continue routing, you must use continued(true), which will be discussed in section 5.4.5
Before we move on, let’s take a minute to look at the example from listing 5.4 revised to use Spring XML.
The syntax is a bit different, as you can see:
Notice how onException is set up—you must define the exceptions in the exception tag.
Also, handled(true) B is a bit longer because you must enclose it in the <constant> expression.
There are no other noteworthy differences in the rest of the route.
Listing 5.5 uses a custom processor to generate a failure response C.
Suppose you want to return a custom failure message, as in listing 5.5, that indicates not only what the problem was but that also includes details from the current Camel Message.
Listing 5.5 laid out how to do this using onException.
Listing 5.6 shows how the failure Processor could be implemented.
First, you grab the information you need: the message body and the exception B.
You do that because you’ve marked onException to handle the exception; this was done at B in listing 5.5
The rest of the processor builds the custom failure message that’s to be returned to the caller.
You may wonder whether there are other properties Camel sets during error handling, and there are.
But from an end-user perspective, it’s only the first two properties in table 5.5 that matter.
The other two properties are used internally by Camel in its error-handling and routing engine.
One example of when the FAILURE_ENDPOINT property comes in handy is when you route messages through the Recipient List EIP, which sends a copy of the message to a dynamic number of endpoints.
Without this information, you wouldn’t know precisely which of those endpoints failed.
It’s worth noting that in listing 5.6 you use a Camel Processor, which forces you to depend on the Camel API.
Listing 5.6 Using a processor to create a failure response to be returned to the caller.
Table 5.5 Properties on the Exchange related to error handling.
String The URL of the endpoint that failed if a failure occurred when sending to an endpoint.
If the failure did not occur while sending to an endpoint, this property is null.
Boolean Whether or not the error handler handled the exception.
Or true if the Exchange was moved to a dead letter queue.
As you can see, you can use Camel’s parameter binding B to declare the parameter types you want to use.
The first parameter is the message body, and the second is the exception.
There will be situations where you’ll want to simply ignore the exception and continue routing.
In section 5.4.3 we learned about how onException can handle exceptions.
Handling an exception means that Camel will break out of the route.
But there are times when all you want is to catch the exception and continue routing.
All you have to do is to use continued(true) instead of handled(true)
As you can see, all you have to do is add another onException that leverages continued(true) B.
Now imagine that a message once again arrives on the TCP endpoint, and the Camel application routes the message.
When the message arrives at the next Channel, it’s as if the exception were not thrown.
This is much different from what you saw in section 5.4.3 when using handled(true), which causes the processing to break out and not continue routing.
You’ve learned a bunch of new stuff, so let’s continue with the error handler example and put your knowledge into practice.
This time, the remote HTTP server used for uploading files is unreliable, and he wants you to implement a secondary failover to transfer the files by FTP to a remote FTP server.
You have been studying Camel in Action, and you’ve learned that Camel has extensive support for error handling and that you could leverage onException to provide this kind of feature.
With great confidence, you fire up the editor and alter the route as shown in listing 5.8
If there is still an error after the redelivery attempts, Camel will handle the exception and.
Listing 5.8 Route using error handling with failover to FTP.
The exception is handled and continued by the onException policy, causing the message to continue being routed as if the exception were not thrown.
The power and flexibility of the Camel routing engine shines here.
The onException is just another route, and Camel will continue on this route instead of the original route.
The onException has been configured to redeliver up till 3 times before giving up and being exhausted.
The book’s source code contains this example in the chapter5/usecase directory, and you can try it out yourself.
The example contains a server and a client that you can start using Maven:
Both the server and client output instructions on the console about what to do next, such as copying a file to the target/rider folder to get the ball rolling.
Before we finish up this chapter, we must take a look at a few more error-handling features.
They’re used rarely, but they provide power in situations where you need more fine-grained control.
We’ll end this chapter by looking at some of the other features Camel provides for error handling:
The onWhen predicate filter allows more fine-grained control over when an onException should be triggered.
Suppose a new problem has emerged with your application in listing 5.8
This time the HTTP service rejects the data and returns an HTTP 500 response with the constant text “ILLEGAL DATA”
Your boss wants you to handle this by moving the file to a special folder where it can be manually inspected to see why it was rejected.
First, you need to determine when an HTTP error 500 occurs and whether it contains the text “ILLEGAL DATA”
You decide to create a Java method that can test this, as shown in listing 5.9
This allows you to determine if it’s an HTTP error code 500 with the “ILLEGAL DATA” body text.
It would be better if you had more fine-grained control over when this onException triggers.
How could you incorporate your code from listing 5.9 with the onException?
I am sure you have guessed where we’re going—yes, you can use the onWhen predicate.
All you need to do is insert the onWhen into the onException, as shown here:
Camel adapts to your POJO classes and uses them as is, thanks to the power of Camel’s parameter binding, which we covered in the previous chapter.
This is a powerful way to develop your application without being tied to the Camel API.
Next, let’s look at onRedeliver, which allows fine-grained control when a redelivery is about to occur.
The purpose of onRedeliver is to allow some code to be executed before a redelivery is performed.
This gives you the power to do custom processing on the Exchange before Camel makes a redelivery attempt.
You can, for instance, use it to add custom headers to indicate to the receiver that this is a redelivery attempt.
OnRedeliver can be configured on the error handler, on onException, or on both, as follows:
OnRedeliver is also scoped, so if an onRedeliver is set on an onException, it overrules any onRedeliver set on the error handler.
In Spring DSL, onRedeliver is configured as a reference to a spring bean, as follows:
RetryWhile is used when you want fine-grained control over the number of redelivery attempts.
It’s also a predicate that’s scoped, so you can define it on the error handler or on onException.
You can use retryWhile to implement your own generic retry ruleset that determines how long it should retry.
Listing 5.10 shows some skeleton code demonstrating how this can be done.
Using your own MyRetryRuleset class, you can implement your own logic determining whether it should continue retrying or not.
If the method returns true, a redelivery attempt is conducted; if it returns false, it give up.
To use your ruleset, you configure retryWhile on the onException as follows:
Listing 5.10 Skeleton code to illustrate principle of using retryWhile.
That gives you fine-grained control over the number of redelivery attempts performed by Camel.
That’s it! We’ve now covered all the features Camel provides for fine-grained control over error handling.
In this chapter, you saw how recoverable and irrecoverable errors are represented in Camel.
We also looked at all the provided error handlers, focusing on the most important of them.
You saw how Camel can control how exceptions are dealt with, using redelivery policies to set the scene and exception policies to handle specific exceptions differently.
Finally, we looked at what Camel has to offer when it comes to fine-grained control over error handling, putting you in control of error handling in Camel.
Let’s revisit some of the key ideas from this chapter, which you can take away and apply to your own Camel applications:
Realize from the beginning that the unexpected can happen and that dealing with errors is hard.
The challenge keeps rising when businesses have more and more of their IT portfolio integrated and operate it 24/7/365
When IT systems are being integrated, they exchange data according to agreed-upon protocols.
Those protocols should also specify how errors will be dealt with.
Camel allows you to separate routing logic from error-handling logic.
This avoids cluttering up your logic, which otherwise could become harder to maintain.
Use Camel features such as error handlers, onException, and doTry ...
If the order of messages processed from consumers doesn’t matter, leverage asynchronous redelivery to achieve higher scalability.
If you use components such as JBI, CXF, or SOAP, which may return fault messages, you can enable fault handling in Camel to let the error handlers react to those faults.
Use tooling to monitor your Camel applications so it can react and alert personnel if severe errors occur.
Build unit tests that simulate errors to see if your error-handling strategies are up to the task.
In the next chapter, we’ll look at a topic that can help make you a successful integration specialist, and without it, you’ll almost certainly be in trouble: testing with Camel.
We’ll also look at how you can simulate errors to test whether your error handling strategies work as expected.
In the last chapter, we covered error handling and learned that it’s hard to handle and cater for all difficulties that can possibly arise.
To help address this problem, you can test as many situations as possible.
In this chapter, we’ll look at how to test with Camel—not only testing your projects when everything goes well, but also simulating errors and testing whether your error handling strategies are up to the job.
Testing is vital to ensuring that your integration projects are successful.
JUnit has become the standard API for unit testing, and the Camel Test Kit builds on top of JUnit, leveraging the existing JUnit tooling.
If you aren’t familiar with JUnit, you can read about it in JUnit in Action, second edition (http://www.manning.com/tahchiev)
A good way to perform unit testing on a Camel application is to start the application, send messages to the application, and verify that the messages are routed as expected.
You send a message to the application, which transforms the message to another format and returns the output.
You can then verify that the output is as expected.
This is how the Camel Test Kit is used for testing.
You’ll learn to set up expectations as preconditions for your unit tests, start the tests by sending in messages, and verify the results to determine whether the tests passed.
The Mock component is based on this principle, and we’ll cover it thoroughly.
Then we’ll look at several techniques for simulating errors, so you can test your error handling as well.
Camel provides rich facilities for testing your projects, and it includes a test kit that gets you writing unit tests quickly in familiar waters using the regular JUnit API.
In fact, it’s the same test kit that Camel uses for testing itself.
Figure 6.2 gives a high-level overview of the Camel Test Kit.
The JUnit extensions are a number of classes on top of JUnit that make unit testing with Camel much easier.
Let’s now look at the Camel JUnit extensions and see how to use them to write Camel unit tests.
So what are the Camel JUnit extensions? They are six classes in a small JAR file, cameltest.jar, that ships with Camel.
Figure 6.2 The Camel Test Kit is provided in two JAR files containing the JUnit extensions, Mock component, and producer template.
Figure 6.1 Testing a Camel application by sending a message to the application and then verifying the returned output.
We’ll start simply and use the following route for testing:
This is the “Hello World” example for integration kits that moves files from one folder to another.
So how do you go about unit testing this route?
You could do it the traditional way and write unit test code with the plain JUnit API.
This would require at least 30 lines of code, because the API for file handling in Java is very low level, and you need a fair amount of code when working with files.
An easier solution is to use the Camel Test Kit.
In the next couple of sections, you’ll work with the CamelTestSupport class—it’s the easiest to get started with.
In this chapter, we’ve kept the dependencies low when using the Camel Test Kit.
All you need to include is the following dependency in the Maven pom.xml file:
JUnit 3.x abstract base test class with additional assertion methods.
JUnit 3.x base test class prepared for testing Camel routes.
This is the test class you should use when using JUnit 3.x.
JUnit 3.x base test class prepared for testing Camel routes defined using Spring DSL.
JUnit 4.x abstract base test class with additional assertion methods.
JUnit 4.x base test class prepared for testing Camel routes.
This is the test class you should use when using JUnit 4.x.
JUnit 4.x base test class prepared for testing Camel routes defined using Spring DSL.
We won’t go into detail here on how to set up your Java editor for developing with Camel; chapter 11 will cover this in detail.
You want to build a unit test to test a Camel route that copies files from one directory to another.
By overriding the createRouteBuilder method, you can provide any route builder you wish.
You use an inlined route builder, which allows you to write the route directly within the unit test class.
All you need to do is override the configure method B and include your route.
The test methods are regular JUnit methods, so the method must be annotated with @Test to be included when testing.
Instead of using the low-level Java File API, this example leverages Camel as a client by using ProducerTemplate to send a message to a file endpoint C, which writes the message as a file.
In the test, you sleep one second after dropping the file in the inbox folder; this gives Camel a bit of time to react and route the file.
By default, Camel scans twice per second for incoming files, so you wait one second to be on the safe side.
Finally you assert that the file was moved to the outbox folder D.
You can try it on your own by running the following Maven goal from the chapter6/firsttest directory:
When you run this example, it should output the result of the test as shown here:
This indicates that the test completed successfully; there are no failures or errors.
The unit test in listing 6.1 could be improved in a few areas, such as ensuring that the starting directory is empty and that the written file’s content is what you expect.
The former is easy, because the CamelTestSupport class has a method to delete a directory.
Camel can also test the written file’s content to ensure it’s what you expect.
You may remember that Camel provides a very elaborate type converter system, and that this system goes beyond converting between simple types and literals.
The Camel type system includes file-based converters, so there is no need to fiddle with the various cumbersome Java IO file streams.
All you need to do is ask the type converter system to grab the file and return it to you as a String.
Just as you had access to the template in listing 6.1, the Camel Test Kit also gives you direct access to the CamelContext.
The testMoveFile method in listing 6.1 could have been written as follows:
The preceding examples cover the case where the route is defined in the unit test class as an anonymous inner class.
But what if you have a route defined in another class? How do you go about unit testing that route instead? Let’s look at that next.
It’s common to define Camel routes in separate RouteBuilder classes, as in the FileMoveRoute class here:
How could you unit test this route from the FileMoveRoute class? You don’t want to copy the code from the configure method into a JUnit class.
Fortunately, it’s quite easy to set up unit tests that use the FileMoveRoute, as you can see here:
Yes, it’s that simple! Just return a new instance of your route class.
Now you have learned how to use CamelTestSupport for unit testing routes based.
The next section shows how to test using Spring XMLbased routes.
Notice that the route is the same route defined in listing 6.1
So how can you unit test this route? Ideally you should be able to use unit tests regardless of the language used to define the route.
This mechanism is entirely Spring-based, so you can also use.
Listing 6.3 A first unit test using Spring XML routes.
The testMoveFile method is exactly the same as it was in listing 6.1, which means you can use the same unit testing code regardless of how the route is defined.
In real life projects, you’ll have different deployment environments, such as local, test, preproduction, and production.
In the next section, we’ll look at how you can test the same project in those different environments with minimal effort.
A Camel route is often tested in different environments—you may want to test it locally on your laptop, then later on a dedicated test platform, and so forth.
But you don’t want to rewrite tests every time you move to a new environment.
We’ll cover two solutions for externalizing dynamic parts using property files.
The first solution is based on the Camel Properties component and the second leverages Spring property placeholders.
Camel has a Properties component to support externalizing properties defined in the routes.
The Properties component works in much the same way as Spring property placeholders, but it has a few noteworthy improvements:
It is built in the camel-core JAR, which means it can be leveraged without the need for Spring or any third-party framework.
It can be used in all the DSLs, such as the Java DSL, and is not limited to Spring XML files.
Suppose you wanted to test the file-move unit test in two environments: production and test.
To use the Camel Properties component in Spring XML, you have to declare it as a Spring bean with the id properties, as shown:
The camelContext element can then take advantage of the externalized properties directly in the endpoint URI, as shown in bold in this route:
Your next goal is to create a reusable unit test that, with minimal effort, can be configured to test in either environment.
Listing 6.4 A reusable unit test for the test and production environments.
In the testMoveFile method, you start the unit test by creating a file in the inbox directory, and to help with that you retrieve the ProducerTemplate.
Note that you use the @EndpointInject annotation and refer to the inbox endpoint by the placeholder B.
In the setUp method, you use the CamelContext to resolve the placeholders C, because you’ll later need to know the actual values for file.inbox and file.outbox.
If you had the route defined in multiple files targeted for specific environments, you’d put the burden on yourself to synchronize those routes if you change something in the route.
By using this approach, you can unit test the route in different environments with minimal effort.
This example is included in the book’s source code in the chapter6/firsttest directory.
You can use @EndpointInject in your RouteBuilder class to dynamically inject endpoints for the environment you wish to test.
The Camel Properties component can also be used without Spring.
The following listing sets up the Camel Properties component and uses it in a Java DSL–based route.
The setUp and testMoveFile methods are omitted because they’re the same as in listing 6.4
You can do this by overriding the createCamelContext method, which ensures the Properties component is available to the RouteBuilder when it encounters the property placeholders in the endpoints used in the route.
You can run try this example using the following Maven goals from the chapter6/ firsttest directory:
For example, you may not want to have passwords in clear text in the properties file.
You can read about the Jasypt component at the Camel website: http://camel.apache.org/jasypt.
We’ll now cover the same example but using Spring property placeholders instead of the Camel Properties component.
The Spring Framework supports externalizing properties defined in the Spring XML files using a feature known as Spring property placeholders.
We’ll review the example from the previous section using Spring property placeholders instead of the Camel Properties component.
Unfortunately the Spring Framework doesn’t support using placeholders directly in endpoint URIs in the route, so you must define endpoints that include those placeholders by using the <endpoint> tag.
Note that this XML file is based on the production environment.
In the route, you must refer to these endpoints D instead of using the regular URI notations.
This example is included in the book’s source code in the chapter6/firsttest directory.
The Camel Properties component versus Spring property placeholders The Camel Properties component is more powerful than the Spring property placeholder mechanism.
The latter only works when defining routes using Spring XML, and you have to declare the endpoints in dedicated <endpoint> tags for the property placeholders to work.
The Camel Properties component is provided out of the box, which means you can use it without using Spring at all.
And it supports the various DSL languages you can use to define routes, such as Java, Spring XML, Groovy, and Scala.
On top of that, you can declare the placeholders anywhere in the route definitions.
You have now seen the Camel Test Kit and learned to use its JUnit extension to write your first unit tests.
Testing an application that leverages many protocols has always been challenging.
By using mocks, you can simulate real components and reduce the number of variables in your tests.
The Mock component is a cornerstone when testing with Camel—it makes testing much easier.
In much the same way as a car designer uses a crash test dummy to simulate vehicle impact on humans, the Mock component is used to simulate real components in a controlled way.
When the real component doesn’t yet exist or isn’t reachable in the development and test phases.
For example, if you only have access to the component in preproduction and production phases.
When the real component is slow or requires much effort to set up and initialize, such as a database.
When you would have to incorporate special logic into the real component for testing purposes, which isn’t practical or possible.
When the component returns nondeterministic results, such as the current time, which would make it difficult to unit test at any given time of day.
When you need to simulate errors caused by network problems or faults from the real component.
Without the Mock component, your only option would be to test using the real component, which is usually much harder.
You may already have used mocking before; there are many frameworks out there that blend in well with testing frameworks like JUnit.
Camel takes testing very seriously, and the Mock component was included in the first release of Camel.
The fact that it resides in camel-core JAR indicates its importance—the Mock component is used rigorously in unit testing Camel itself.
In this section, we’ll look at how to use the Mock component in unit tests and how to add mocking to existing unit tests.
Then we’ll spend some time on how you can use mocks to set expectations to verify test results, as this is where the Mock component excels.
The three basic steps of testing are illustrated in figure 6.3
Before the test is started, you set the expectations of what should happen B.
Finally, you verify the outcome of the test against the expectations D.
The Camel Mock component allows you to easily implement these steps when testing Camel applications.
On the mock endpoints, you can set expectations that are used to verify the test results when the test completes.
Mock components can verify a rich variety of expectations, such as the following:
Mock components allow you to configure coarse- and fine-grained expectations and to simulate errors such as network failures.
As we look at how to use the Mock component, we’ll use the following basic route to keep things simple:
This route will consume messages from a JMS topic, named quote, and route the messages to a mock endpoint with the name quote.
Table 6.2 lists the most commonly used methods on the mock endpoint.
Figure 6.3 Three steps for testing: set expectations, run the test, and verify the result.
To obtain the MockEndpoint, you use the getMockEndpoint method from the CamelTestSupport class.
Then you set your expectations—in this case, you expect one message to arrive B.
You start the test by sending a message to the JMS topic, and the mock endpoint verifies whether the expectations were met or not by using the assertIsSatisfied method C.
Specifies the expected minimum number of messages arriving on the endpoint.
Specifies the expected message bodies and their order arriving at the endpoint.
Specifies the expected message bodies arriving at the endpoint; ordering doesn’t matter.
Listing 6.6 uses JMS, but, for now, let’s keep things simple by simulating JMS using the SEDA component.
We’ll look at testing JMS with ActiveMQ in section 6.4
You can simulate JMS by registering the SEDA component as the JMS component, like this:
You override the createCamelContext method and add the SEDA component as the JMS component.
By doing this, you fool Camel into using the SEDA component when you refer to the JMS component.
You can try it by running the following Maven goal from the chapter6/firsttest directory:
You may have noticed in listing 6.5 that the expectation was coarse-grained in the sense that you just expected a message to arrive.
You did not specify anything about the message’s content or other characteristics, so you don’t know whether the message that arrived was the same “Camel rocks” message that was sent.
It doesn’t dictate anything about the content of the message.
Let’s improve the unit test in listing 6.6 so that it expects the message being sent to match the message that arrives at the mock endpoint.
This is intuitive and easy to understand, but the method states bodies in plural as if there could be more bodies.
Camel does support expectations of multiple messages, so you could send in two messages.
Camel now expects two messages to arrive in the specified order.
Camel will fail the test if the “Hello Camel” message arrives before the “Camel rocks” message.
But if you expect a much larger number of messages to arrive, the bodies you pass.
How can you do that? The answer is to use a List containing the expected bodies as a parameter:
The Mock component has many other features we need to cover, so let’s continue and see how you can use expressions to set fine-grained expectations.
Suppose you want to set an expectation that a message should contain the word “Camel” in its content.
One way of doing this is shown in listing 6.7
First you set up your expectation that the mock:quote endpoint will receive two messages B.
You then send in two messages to the JMS topic to start the test.
This method is more convenient to use than having to invoke the assertIsSatisfied method on every mock endpoint you may have in use.
You use this method to get hold of the two received message bodies so you can assert that they contain the word “Camel”
At first you may think it a bit odd to define expectations in two places—before and after the test has run.
Is it not possible to define the expectations in one place, such as before you run the test? Yes, of course it is, and this is where Camel expressions come into the game.
It allows you to work with the exchanges directly, giving you the ability to do whatever you want with them.
Table 6.3 lists some additional MockEndpoint methods that let you use expressions to set expectations.
You can use the message method to improve the unit test in listing 6.7 and group all your expectations together, as shown here:
Notice that you can use the message(int index) method to set an expectation that the body of the message should contain the word “Camel”
Instead of doing this for each message based on its index, you can use the allMessages() method to set the same expectation for all messages:
So far you’ve only seen expectations based on the message body, but what if you want to set an expectation based on a header? That’s easy—you use header(name), as follows:
You probably noticed the contains and isEqualTo methods we used in the preceding couple of code snippets.
Table 6.4 Builder methods for creating predicates to be used as expectations.
At first it may seem odd that the methods in table 6.4 often use Object as the parameter type—why not a specialized type such as String? This is because of Camel’s strong type-converter mechanism, which allows you to compare apples to oranges—Camel can regard both of them as fruit and evaluate them accordingly.
You can compare strings with numeric values without having to worry about type mismatches, as illustrated by the following two code lines:
Now suppose you want to create an expectation that all messages contain the word “Camel” and end with a period.
You could use a regular expression to set this in a single expectation:
This will work, but Camel allows you to enter multiple expectations, so instead of using the regex method, you can create a more readable solution:
Table 6.4 Builder methods for creating predicates to be used as expectations (continued)
You have learned a lot about how to set expectations, including fine-grained ones using the builder methods listed in table 6.4
Now it’s time to move on and test the ordering of the messages received.
Suppose you need to test that messages arrive in sequence-number order.
The Mock component provides features to test ascending and descending orders.
For example, you can use the expectsAscending method like this:
The preceding expectation will test that the received messages are in ascending order, judged by the Counter value in the message header, but it doesn’t dictate what the starting value must be.
That’s because the expectsAscending and expectsDescending methods don’t detect whether there are gaps between messages.
These methods use generic comparison functions that work on any types, not only numbers.
To detect gaps in the sequence, you need to use a custom expression that implements gap-detection logic.
When the provided expressions and predicates don’t cut it, you can use a custom expression.
By using a custom expression, you have the full power of Java code at your fingertips to implement your assertions.
Camel doesn’t provide any expressions for that, so you must do it with a custom expression.
Listing 6.8 Using a custom expression to detect gaps in message ordering.
To set up a custom expression, you use the expects method, which allows you to provide your own logic as a Runnable B.
In the Runnable, you can loop through the exchanges received and extract the current counter header.
Then you can verify whether all the counters are incremented by one and don’t have any gaps.
You can use the JUnit fail method to fail when a gap is detected.
To test whether this works, you send in three messages, each of which contains a Counter.
Next, you test a positive situation where no gaps exist.
To do so, you use the assertIsSatisfied method and send in three messages in sequence, as follows:
That’s all there is to developing and using a custom expression.
Now let’s get back to the mock components and learn about using mocks to simulate real components.
This is useful when the real component isn’t available or isn’t reachable from a local or test environment.
Suppose you have a route like the following one, in which you expose an HTTP service using Jetty so clients can obtain an order status:
The message is then sent to Miranda using TCP, and Camel waits for the reply to come back.
Now suppose you have been asked to write a unit test to verify that clients can obtain the order status.
The challenge is that you don’t have access to Miranda, which contains the actual order status.
You have been asked to simulate this server by replying with a canned response.
Camel provides the two methods listed in table 6.5 to help simulate a real component.
You can simulate a real endpoint by mocking it with the Mock component and controlling the reply using the methods in table 6.5
To do this, you need to replace the actual endpoint in the route with the mocked endpoint, which is done by replacing it with mock:miranda.
Because you want to run the unit test locally, you also need to change the HTTP hostname to localhost, allowing you to run the test locally on your own laptop.
Table 6.5 Methods to control responses when simulating a real component.
Uses a custom processor to set a canned reply when the n’th message is received.
Listing 6.9 Simulating a real component by using a mock endpoint.
In the testMiranda method, you obtain the mock:miranda endpoint, which is the mock that simulates the Miranda server, and you set an expectation that the input message contains the body "ID=123"
Then you start the unit test by sending a message to the http://localhost:9080/service/order?id=123 endpoint; the message is an HTTP GET using the requestBody method from the template instance.
You then assert that the reply is "IN PROGRESS" using the regular JUnit assertEquals method C.
You use two processors (D and E) to transform the data to and from the format that the Miranda server understands.
You can find the code for this example in the chapter6/miranda folder of the book’s source code, which you can try using the following Maven goal:
You’ve now learned all about the Camel Test Kit and how to use it for unit testing with Camel.
You also saw how to use the Mock component to simulate a real component.
You may wonder whether there is a more cunning way to simulate a real component than by using a mock, and there is.
We’re going to look at how to simulate errors next, but the techniques involved could also be applied to simulating a real component.
In the previous chapter, you learned how to use error handling to act upon errors.
Now the question is how to test that your code works when errors happen.
You could test for errors by unplugging network cables and swinging an axe at the servers, but that’s a bit extreme.
Instead we’ll look at how to simulate errors in unit tests using the three different techniques listed in table 6.6
Errors are simulated in Camel by throwing exceptions, which is exactly how errors occur in real life.
For example, Java will throw an exception if it can’t connect to a remote server.
Throwing such an exception is easy—you can do that from any Java code, such as from a Processor.
To illustrate this, we’ll take the use case from the previous chapter—you’re uploading reports to a remote server using HTTP, and you’re using FTP as a fallback method.
Processor Using processors is easy, and they give you full control, as a developer.
Mocks are fairly easy to apply, and they provide a wealth of other features for testing, as you saw in section 6.2
Interceptor This is the most sophisticated technique because it allows you to use an existing route without modifying it.
Interceptors aren’t tied solely to testing; they can be used anywhere and anytime.
Listing 6.10 Route using error handling with a failover to FTP.
What you want to do now is simulate an error when sending a file to the HTTP service, and you’ll expect that it will be handled by onException and uploaded using FTP instead.
Because you want to concentrate the unit test on the error-handling aspect and not on the actual components used, you can just mock the HTTP and FTP endpoints.
This frees you from the burden of setting up HTTP and FTP servers, and leaves you with a simpler route for testing:
Notice that the file endpoint is stubbed with a direct endpoint that allows you to start the test by sending a message to the direct endpoint; this is much easier than writing an actual file.
To simulate a communication error when trying to send the file to the HTTP endpoint, you add a processor to the route that forces an error by throwing a ConnectException exception:
You then write a test method to simulate this connection error, as follows:
You expect no messages to arrive at the HTTP endpoint because you predicted the error would be handled and the message would be routed to the FTP endpoint instead.
You can try it by running the following Maven goal from the chapter6/error directory:
Using the Processor is easy, but you have to alter the route to insert the Processor.
When testing your routes, you might prefer to test them as is without changes that could introduce unnecessary risks.
What if you could test the route without changing it at all? The next two techniques do this.
You saw in section 6.2.6 that the Mock component could be used to simulate a real component.
But instead of simulating a real component, you can use what you learned there to simulate errors.
If you use mocks, we don’t need to alter the route; you write the code to simulate the error directly into the test method, instead of mixing it in with the route.
That Processor can simulate the error by throwing the connection exception.
By using mocks, you put the code that simulates the error into the unit test method, instead of in the route, as is required by the processor technique.
Now let’s look at the last technique for simulating errors.
Suppose your boss wants you to write integration tests for listing 6.10 that should, among other things, test what happens when communication with the remote HTTP server fails.
How can you do that? This is tricky because you don’t have control over the remote HTTP server, and you can’t easily force communication errors in the network layer.
We’ll get to that in a moment, but first we need to look at interceptors, which provide the means to simulate errors.
Listing 6.11 Simulating an error by throwing an exception from the mock endpoint.
In a nutshell, an interceptor allows you to intercept any given message and act upon it.
Figure 6.4 illustrates where the interception takes place in a route.
Figure 6.4 shows a low-level view of a Camel route, where you route messages from a file consumer to an HTTP producer.
In between sits the channel, which acts as a controller, and this is where the interceptors (among others) live.
The three types of interceptors that Camel provides out of the box are listed in table 6.7
When a message is about to be sent to the HTTP endpoint, it’s intercepted by Camel and the message is routed to your custom processor, where you simulate an error.
Table 6.7 The three flavors of interceptors provided out of the box in Camel.
This interceptor is invoked continuously as the message is routed.
Channels play a key role This may look familiar—we looked at channels in figure 5.3
It’s the same channel that sits between every node in the route path and acts as a controller.
Channels play a key role in the Camel routing engine, handling such things as routing the message to the next designated target, error handling, interception, tracing messages and gathering metrics.
Figure 6.4 The channel acts as a controller, and it’s where messages are intercepted during routing.
You can use these techniques to intercept multiple endpoints or to be lazy and just match all HTTP endpoints.
Because you’re doing an integration test, you want to keep the original route untouched, which means you can’t add interceptors or mocks directly in the route.
Because you still want to use interceptors in the route, you need another way to somehow add the interceptors.
The adviceWith method is available during unit testing, and it allows you to add such things as interceptors and error handling to an existing route.
To see how this works, let’s look at an example.
The following code snippet shows how you can use adviceWith in a unit test method:
The key issue when using adviceWith is to know which route to use.
Because you only have one route in this case, you can refer to the first route enlisted in the route definitions list.
The route definitions list contains the definitions of all routes registered in the current CamelContext.
When you’ve got the route, it’s just a matter of using the adviceWith method B, which leverages a RouteBuilder—this means that in the configure method you can use the Java DSL to define the interceptors.
Notice that the interceptor uses a wildcard to match all HTTP endpoints.
We’ve included this integration test in the book’s source code in the chapter6/error directory.
For example, when you’re testing production routes, you can use interceptors to detour messages to mock endpoints.
The last section of this chapter covers how to do integration testing without mocks.
So far in this chapter, you’ve learned that mocks play a central role when testing Camel applications.
For example, integration testing often involves real live components, and substituting mocks isn’t an option, as the point of the integration test is to test with live components.
In this section, we’ll look at how to test such situations without using mocks.
Rider Auto Parts has a client application that business partners can use to submit orders.
The client dispatches orders over JMS to an incoming order queue at the Rider Auto Parts message broker.
A Camel application is then used to further process these incoming orders.
The client application is written in Java, but it doesn’t use Camel at all.
The challenge you’re facing is how to test that the client and the Camel application work as expected? How can you do integration testing?
Integration testing the scenario outlined in figure 6.5 requires you to use live components, which means you must start the test by using the client to send a message to the order queue.
When this is complete, you’ll have to inspect whether the message ended up in the right queuethe confirm or the invalid queue.
Figure 6.5 The client sends orders to an order queue, which is routed by a Camel application.
The order is either accepted and routed to a confirm queue, or it’s not accepted and is routed to an invalid queue.
All you’re required to do is provide an IP address to the remote Rider Auto Parts message broker, and then use its sendOrder method to send the order.
The following code has been simplified in terms of the information required for order details:
The client has sent an order to the order queue on the message broker.
The Camel application will now react and process the message according to the route outlined in figure 6.5
The problem you’re facing now is that the client doesn’t provide any API you can use to wait until the process is complete.
What you need is an API that provides insight into the Camel application.
All you need to know is when the message has been processed, and optionally whether it completed successfully or failed.
We’ll cover the NotifyBuilder in more detail in section 6.4.2, but the following code shows how to have NotifyBuilder notify you when Camel is finished processing the message:
First, you configure NotifyBuilder to notify you when one message is done.
Invoking the matches method on the notify instance will cause the test to wait until the condition applies, or the 5-second timeout occurs.
The last task tests whether the message was processed correctly.
After the message has been processed, you need to investigate whether the message arrived at the correct message queue.
If you want to test that a valid order arrived in the confirm queue, you can use the BrowsableEndpoint to browse the messages on the JMS queue.
By using the BrowsableEndpoint, you only peek inside the message queue, which means the messages will still be present on the queue.
Doing this requires a little bit of code, as shown in here:
By using BrowsableEndpoint, you can retrieve the exchanges on the JMS queue using the getExchanges method.
You can then use the exchanges to assert that the message arrived as expected.
The source code for the book contains this example in the chapter6/notify directory, which you can try using the following Maven goal:
We’ve now covered an example of how to do integration testing without mocks.
Along the road, we introduced the NotifiyBuilder, which has many more nifty features.
It uses the Builder pattern, which means you stack methods on it to build an expression.
You use it to define conditions for messages being routed in Camel.
Then it offers methods to test whether the conditions have been meet.
We already used it in the previous section, but this time we’ll raise the bar and show how you can build more complex conditions.
This condition will match when one or more messages have been processed in the entire Camel application.
Suppose you have multiple routes, and another message was processed as well.
That would cause the condition to match even if the message you wanted to test was still in progress.
To remedy this, you can pinpoint the condition so it applies only to messages originating from a specific endpoint, as shown in bold:
Now you’ve told the notifier that the condition only applies for messages that originate from the order queue.
Suppose you send multiple messages to the order queue, and you want to test whether a specific message was processed.
You can do this using a predicate to indicate when the desired message was completed.
This is done using the whenAnyDoneMatches method, as shown here in bold:
In this example we want the predicate to determine if the body is equal to the expected result which is the string starting with "OK,123,..."
We’ve now covered some examples using NotifyBuilder, but the builder has many methods that allow you to build even more complex expressions.
Consult the online Camel documentation to see all the supported methods: http://camel.apache.org/notifybuilder.html.
The EventNotifier then invokes callbacks during the routing of exchanges.
This allows the NotifyBuilder to listen for those events and react accordingly.
Done—This means the message is done, regardless of whether it completed or failed.
The names of these three ways are also incorporated in the names of the builder methods: whenDone, whenCompleted, and whenFailed (listed in table 6.8)
The NotifyBuilder also supports using binary operations (and, or, not) to stack together multiple conditions.
The source code for the book contains some example of using NotifyBuilder in the chapter6/notify directory.
You can use wildcards and regular expressions in the given URI to match multiple endpoints.
Matches when messages are done with the specified bodies in the given order.
Matches when any message is done and matches the predicate.
Returns true if it matched, or false if a timeout occurred.
We encourage you to take a look at this source code and also the online documentation.
That’s it for testing without mocks, and that marks the end of this chapter.
It’s generally considered bad practice to only do testing at the end of a project, so testing often begins when development starts and continues through the remainder of the project lifecycle.
You should do unit testing while you develop the application.
And you should also implement integration testing to ensure that the different components and systems work together.
You also have the challenge of ensuring you have the right environments for testing.
Camel can’t eliminate these challenges, but it does provide a great Test Kit that makes writing tests with Camel applications easier and less time consuming.
We looked at this Test Kit, and we also looked at how to externalize dynamic parts using property placeholders, so you can reuse and test the same test cases in different environments.
We also reviewed how you can simulate real components using mocks in the earlier phases of a project, allowing you to test against systems you may not currently have access to.
In chapter 5 you learned about error handling, and in this chapter you saw how you can use the Camel Test Kit to test error handling by simulating errors.
We reviewed techniques for integration testing that don’t involve using mocks.
Doing integration testing, using live components and systems, is often harder than unit testing, where mocks are a real advantage.
In integration testing, mocks aren’t available to use, and you have to use other techniques such as setting up a notification scheme that can notify you when certain messages have been processed.
This allows you to inspect the various systems to see whether the messages were processed as expected (such as by peeking into a JMS queue or looking at a database table)
Here are a few best practices to take away from the chapter:
Use the Camel Test Kit from the beginning, and write unit tests in your projects.
The Mock component is a powerful component for unit testing.
Use the techniques you’ve learned in this chapter to simulate errors and test that your application is capable of dealing with these failures.
Build and use integration tests to test that your application works when integrated with real and live systems.
The next chapter will cover the use of components with Camel.
You’ve already used components, such as the file and SEDA components.
But there is much more to components, so we’ve devoted an entire chapter to cover them in detail.
So far, we’ve only touched on a handful of ways that Camel can communicate with external applications, and we haven’t gone into much detail on most components.
It’s time to take your use of the components you’ve already seen to the next level, and to introduce new components that will enable your Camel applications to communicate with the outside world.
First, we’ll discuss exactly what it means to be a component in Camel.
Then, although we can’t describe every component in Camel—that would at least triple the length of this book—we’ll look at the most commonly used components.
Table 7.1 lists the components we’ll cover in this chapter and lists the URLs for their official documentation.
Over the years since Camel’s inception, the list of components has really grown.
Camel saves you from having to code these integrations yourself, thus it achieves its primary goal of making integration easier.
What does a Camel component look like? Well, if you think of Camel routes as highways, components are roughly analogous to on and off ramps.
A message traveling down a route will need to take an off ramp to get to another route or external service.
If the message is headed for another route, it will need to take an on ramp to get onto that route.
See appendix D for information on some of these community sites.
From an API point of view, a Camel component is simple, consisting of a class implementing the Component interface, shown here:
The main responsibility of a component is to be a factory for endpoints.
To do this, a component also holds on to a reference of the CamelContext.
The CamelContext provides access to Camel’s common facilities, like the registry, class loader, and type converters.
There are two main ways in which components are added to a Camel runtime: by manually adding them to the CamelContext and through autodiscovery.
In chapter 2, you had to add a configured JMS component to the CamelContext to utilize a ConnectionFactory.
This was done using the addComponent method of the CamelContext interface, as follows:
This component can be selected in a URI by using the “jms” scheme.
The other way components can be added to Camel is through autodiscovery.
Autodiscovery is the way the components that ship with Camel are registered.
Files in this directory determine what the name of a component is and what the fully qualified class name is.
Figure 7.1 A component creates endpoints and may use the CamelContext’s facilities to accomplish this.
Most of the components in Camel are in separate Java modules from the camelcore module, because they usually depend on third-party dependencies that would bloat the core.
For example, the Atom component depends on Apache Abdera to communicate over Atom.
We wouldn’t want to make every Camel application depend on Abdera, so the Atom component is included in a separate camel-atom module.
The camel-core module has 13 useful components built in, though.
Browse Allows you to browse the list of exchanges that passed through a browse endpoint.
This can be useful for testing, visualization tools, or debugging.
DataSet Allows you to create large numbers of messages for soak or load testing.
Direct Allows you to synchronously call another endpoint with little overhead.
Language Executes a script against the incoming exchange using one of the languages supported by Camel.
Log Logs messages to a number of different logging providers.
Figure 7.2 To autodiscover a component named “bean”, the component resolver searches for a file named “bean” in a specific directory on the classpath.
This file specifies that the component class that will be created is BeanComponent.
You may find this strange, as new systems often provide nice web services and other remoting APIs to serve as integration points.
The problem is that in integration, we often have to deal with older legacy systems, and file-based integrations are common.
For example, you might need to read a file that was written by another application—it could be sending a command, an order to be processed, data to be logged, or anything else.
This kind of information exchange, illustrated in figure 7.3, is called a file transfer in EIP terms.
Another reason why file-based integrations are so common is that they’re easy to understand.
Even though they’re easy to understand, file-based integrations are difficult to get right.
Developers commonly have to battle with complex IO APIs, platform-specific filesystem issues, concurrent access, and the like.
Mock Tests that messages flow through a route as expected.
Properties Allows you to use property placeholders in endpoint URIs.
You’ll learn more about the Timer component and a more powerful scheduling endpoint based on Quartz in section 7.8 of this chapter.
Produce Consume Figure 7.3 A file transfer between two applications is a common way to integrate with legacy systems.
Working with files (File and FTP components) Camel has extensive support for interacting with filesystems.
In this section, we’ll look at how to use the File component to read files from and write them to the local filesystem.
We’ll also cover some advanced options for file processing and discuss how to access remote files with the FTP component.
As you saw before, the File component is configured through URI options.
Let’s first see how Camel can be used to read files.
As you’ve seen in previous chapters, reading files with Camel is pretty straightforward.
Table 7.3 Common URI options used to configure the File component.
By default, Camel will move files to the .camel directory after processing them.
To stop this behavior and keep the original files in place, set the noop option to true.
For consumers, this acts as a filename filter; in producers, it’s used to set the name of the file being written.
If Ignore is set, an exception won’t be thrown and the file won’t be written.
Camel will process only those files that match this expression.
This route will read files from the data/inbox directory and print the contents of each to the console.
The printing is done by sending the message to the System.out stream, accessible by using the Stream component.
As stated in table 7.3, the noop flag tells Camel to leave the original files as is.
This is a convenience option for testing, because it means that you can run the route many times without having to repopulate a directory of test files.
To run this yourself, change to the chapter7/file directory in the book’s source code, and run this command:
What if you removed the noop flag and changed the route to the following:
By default, Camel will also lock any files that are being processed.
Both of the two preceding routes will consume any file not beginning with a period, so they will ignore files like .camel, .m2, and so on.
You can customize which files are included by using the include and exclude options.
You just saw how to read files created by other applications or users.
Now let’s see how Camel can be used to write files.
This example uses the Stream component to accept input from the console.
The stream:in URI will instruct Camel to read any input from System.in on the console and create a message from that.
The promptMessage option displays a prompt, so you know when to enter text.
The file:data/outbox URI instructs Camel to write out the message body to the data/outbox directory.
To see what happens firsthand, you can try the example by changing to the chapter7/file directory in the book’s source code and executing the following command:
Working with files (File and FTP components) When this runs, you’ll see an “Enter something:” prompt.
Enter some text into the console, and press Enter, like this:
This text (in this case, “Hello”) will be read in by the Stream component and added as the body of a new message.
This message’s body (the text you entered) will then be written out to a file in the data/outbox directory (which will be created if it doesn’t exist)
If you run a directory listing on the data/outbox directory now, you’ll see a single file that has a rather strange name:
Because you did not specify a filename to use, Camel chose a unique filename based on the message ID.
To set the filename that should be used, you can add a fileName option to your URI.
For example, you could change the route so it looks like this:
Now, any text entered into the console will be saved into the prompt.txt file in the data/outbox directory.
Camel will by default overwrite prompt.txt, so you now have a problem with this route.
If text is frequently entered into the console, you may want new files created each time, so they don’t overwrite the old ones.
To implement this in Camel, you can use an expression for the filename.
You can use the Simple expression language to put the current time and date information into your filename:
Now if you enter text into the console at 2:00 p.m.
The simple techniques for reading from and writing to files discussed here will be adequate for most of the cases you’ll encounter in the real world.
For the trickier cases, there are a plethora of configuration possibilities listed in the online documentation.
We’ve started slowly with the File component, to get you comfortable with using components in Camel.
Next we’ll look at the FTP component, which builds on the File component but introduces messaging across a network.
Probably the most common way to access remote files is by using FTP, and Camel supports three flavors of FTP:
The FTP component inherits all the features and options of the File component, and it adds a few more options, as shown in table 7.4
For a complete listing of options for the FTP component, see the online documentation (http://camel.apache.org/ftp2.html)
Because the FTP component isn’t part of the camel-core module, you need to add an additional dependency to your project.
If you use Maven, you just have to add the following dependency to your POM:
Table 7.4 Common URI options used to configure the FTP component.
You can also specify the username by prefixing username@ to the hostname in the URI.
You can also specify the password by prefixing the hostname in the URI with username:password@
By default, Camel will transfer in ASCII mode; set this option to true to enable binary transfer.
If all these attempts are unsuccessful, Camel will throw an exception.
Asynchronous messaging (JMS component) To demonstrate accessing remotes files, let’s use the Stream component as in the previous section to interactively generate and send files over FTP.
A route that accepts text on the console and then sends it over FTP would look like this:
This is a Spring-based route—Spring makes it easy to hook start and stop methods to an embedded FTP server.
This FTP endpoint URI specifies that Camel should send the message to an FTP server on the localhost listening on port 21000, using rider as the username and secret as the password.
It also specifies that messages are to be stored in the data/outbox directory of the FTP server.
To run this example for yourself, change to the chapter7/ftp directory and run this command:
After Camel has started, you’ll need to enter something into the console:
You can now check to see if the message made it into the FTP server.
As you can see, using the FTP component is similar to using the File component.
Now that you know how to do the most basic of integrations with files and FTP, let’s move on to more advanced topics, like JMS and web services.
It promotes loose coupling in application design, has built-in support for reliable messaging, and is by nature asynchronous.
As you saw in chapter 2, when we looked at JMS, it’s also easy to use from Camel.
In this section, we’ll expand on what we covered in chapter 2 by going over some of the more commonly used configurations of the JMS component.
Camel doesn’t ship with a JMS provider; you need to configure it to use a specific JMS provider by passing in a ConnectionFactory instance.
For example, to connect to an Apache ActiveMQ broker listening on port 61616 of the local host, you could configure the JMS component like this:
The URI tells ActiveMQ to connect to a broker using TCP on port 61616 of the local host.
If you wanted to connect to a broker over some other protocol, ActiveMQ supports connections over VM, SSL, UDP, multicast, and so on.
Throughout this section, we’ll be demonstrating JMS concepts using ActiveMQ as the JMS provider, but any provider could have been used here.
Camel’s JMS component has a daunting list of configuration options—over 60 to date.
Many of these will only be seen in very specific JMS usage scenarios.
To use the JMS component in your project, you’ll need to include the camel-jms module on your classpath as well as any JMS provider JARs.
If you’re using Maven, the JMS component can be added with the following dependency:
The ActiveMQ component By default, a JMS ConnectionFactory doesn’t pool connections to the broker, so it will spin up new connections for every message.
The way to avoid this is to use connection factories that use connection pooling.
For convenience to Camel users, ActiveMQ ships with the ActiveMQ component, which configures connection pooling automatically for improved performance.
When using this component, you’ll also need to depend on the activemq-camel module from ActiveMQ:
This module contains the ActiveMQ component and type converters for ActiveMQ data types.
Table 7.5 Common URI options used to configure the JMS component.
If set to false, you’ll need to invoke the start() method on the consumer manually at a later time.
The client ID set in the ConnectionFactory overrides this one if set.
It’s a good idea to increase this for high-volume queues, but it’s not advisable to use more than one concurrent consumer for JMS topics, because this will result in multiple copies of the same message.
Set this if you don’t want Camel to send a reply back to the destination specified in the JMSReplyTo header.
If clientId is also set, the topic subscription is made durable automatically.
By setting this, Camel will use a fixed reply queue.
After this time expires, the JMS provider may discard the message.
The best way to show that Camel is a great tool for JMS messaging is with an example.
Let’s look at how to send and receive messages over JMS.
In chapter 2, you saw how orders are processed at Rider Auto Parts.
It started out as a step-by-step process: they were first sent to accounting to validate the customer standing and then to production for manufacture.
This process was improved by sending orders to accounting and production at the same time, cutting out the delay involved when production waited for the OK from accounting.
Figure 7.4 illustrates another possible solution, which is to use a JMS topic following a publish-subscribe model.
In that model, listeners such as accounting and production could subscribe to the topic, and new orders would be published to the topic.
In this way, both accounting and production would receive a copy of the order message.
To implement this in Camel, you’d set up two consumers, which means there will be two routes needed:
When a message is sent (published) to the xmlOrders topic, both the accounting and production queues will receive a copy.
To run this example, go to the chapter7/jms directory in the book’s source, and run this command:
Listing 7.1 Topics allow multiple receivers to get a copy of the message.
Figure 7.4 Orders are published to the xmlOrders topic, and the two subscribers (the accounting and production queues) get a copy of the order.
Asynchronous messaging (JMS component) This will output the following on the command line:
Why did you get this output? Well, you had a single order file named message1.xml, and it was published to the xmlOrders topic.
Both the accounting and production queues were subscribed to the topic, so each received a copy.
Testing routes consumed the messages on those queues and output the messages.
Messages can also be sent “by hand” to a JMS destination using a ProducerTemplate.
A template class, in general, is a utility class that simplifies access to an API; in this case, the Producer interface.
For example, to send an order to the topic using a ProducerTemplate, you could use the following snippet:
This is a useful feature for getting direct access to any endpoint in Camel.
All of the JMS examples so far have been one-way only.
Let’s look at how you can deliver a reply to the sent message.
Messages are sent to a destination, and the client doesn’t wait for a reply.
But there are times when it’s useful to be able to wait and get a reply after sending to a destination.
One obvious application is when the JMS destination is a frontend to a service—in this case, a client sending to the destination would be expecting a reply from the service.
Camel takes care of this style of messaging, so you don’t have to create special reply queues, correlate reply messages, and the like.
By changing the message exchange pattern (MEP) to InOut, Camel will enable request-reply mode for JMS.
To demonstrate, let’s take a look at an order validation service within Rider Auto Parts’ backend systems that checks orders against the company database to make sure the parts listed are actual products.
The route exposing this service over JMS could be as simple as this:
Figure 7.5 In request-reply messaging, a requestor sends a message to a request queue and then waits for a reply in the reply queue.
The replier waits for a new message in the request queue, inspects the JMSReplyTo address, and then sends a reply back to that destination.
When calling this service, you just need to tell Camel to use request-reply messaging by setting the MEP to InOut.
You can use the exchangePattern option to set this as follows:
You can also specify the MEP using the inOut DSL method:
With the inOut method, you can even pass in an endpoint URI as an argument, which shortens your route:
By specifying an InOut MEP, Camel will send the message to the validate queue and wait for a reply on a temporary queue that it creates automatically.
When the ValidatorBean returns a result that message is propagated back to the temporary reply queue, and the route continues on from there.
Rather than using temporary queues, you can also explicitly specify a reply queue.
This can be done by setting the JMSReplyTo header on the message or by using the replyTo URI option described in table 7.5
A handy way of calling an endpoint that can return a response is by using the request methods of the ProducerTemplate.
For example, you can send a message into the incomingOrders queue and get a response back with the following call:
The command will run a unit test demonstrating request-reply messaging as we’ve discussed in this section.
In the JMS examples we’ve looked at so far, several data mappings have been happening behind the scenes—mappings that are necessary to conform to the JMS specification.
Camel could be transporting any type of data, so that data needs to be converted to a type that JMS supports.
Camel hides a lot of the details when doing JMS messaging, so you don’t have to worry about them.
But one detail you should be aware of is that Camel maps both bodies and headers from the arbitrary types and names allowed in Camel to JMS-specific types.
Although Camel poses no restrictions on what a message’s body contains, JMS specifies different message types based on what the body type is.
Asynchronous messaging (JMS component) The conversion to one of these five JMS message types occurs when the exchange reaches a JMS producer; said another way, it happens when the exchange reaches a route node like this:
At this point, Camel will examine the body type and determine which JMS message to create.
This newly created JMS message is then sent to the JMS destination specified.
Table 7.6 shows what body types are mapped to JMS messages.
Another conversion happens when consuming a message from a JMS destination.
Although this automatic message mapping allows you to utilize Camel’s transformation and mediation abilities fully, you may sometimes need to keep the JMS message.
Table 7.6 When sending messages to a JMS destination, Camel body types are mapped to specific JMS message types.
Table 7.7 When receiving messages from a JMS destination, JMS message types are mapped to Camel body types.
An obvious reason would be to increase performance; not mapping every message means it will take less time for each message to be processed.
Another reason could be that you’re storing an object type that doesn’t exist on Camel’s classpath.
In this case, if Camel tried to deserialize it, it would fail when finding the class.
To disable message mapping for body types, set the mapJmsMessage URI option to false.
Headers in JMS are even more restrictive than body types.
In Camel, a header can be named anything that will fit in a Java String and its value can be any Java object.
This presents a few problems when sending to and receiving from JMS destinations.
Header names that start with “JMS” are reserved; you can’t use these header names.
These include boolean, byte, short, int, long, float, and double.
To handle these restrictions, Camel does a number of things.
First, any headers that you set starting with “JMS” will be dropped before sending to a JMS destination.
Camel also attempts to convert the header names to be JMS-compliant.
If this message is consumed by a Camel route at some point down the line, the header name will be converted back.
To conform to the JMS specification, Camel will drop any header that has a value not listed in the list of primitives or their corresponding object types.
Camel also allows CharSequence, Date, BigDecimal, and BigInteger header values, all of which are converted to their String representations to conform to the JMS specification.
You should now have a good grasp of what Camel can do for your JMS messaging applications.
For messaging with the external world, web services can be used.
We’ll look at how Camel uses Apache CXF to access and serve up web services next.
Web services (CXF component) 7.4 Web services (CXF component) You would be hard pressed to find any modern enterprise project that doesn’t use web services of some sort.
Web services are often associated with service-oriented architecture (SOA), where each service is defined as a web service.
You can think of a web service as an API on the network.
The API itself is defined using the Web Services Description Language (WSDL), specifying what operations you can call on a web service and what the input and output types are, among other things.
Messages are typically XML, formatted to comply with the Simple Object Access Protocol (SOAP) schema.
As illustrated in figure 7.7, web services allow you to write Java code and make that Java code callable over the Internet, which is pretty neat!
We’ll mainly be focusing on developing web services using the Java API for XML Web Services (JAX-WS) specification.
JAX-WS defines annotations that allow you to tell a tool like CXF how your POJO should be represented on the web.
We’ll be covering two types of web services development with CXF in this section:
Contract-first development—Recall that WSDLs define what operations and types a web service provides.
This is often referred to as a web services contract, and in order to communicate with a web service, you must satisfy the contract.
Contract-first development means that you start out by writing a WSDL file (either by hand or with the help of tooling), and then generating stub Java class implementations from the WSDL file by using a tool like CXF.
Code-first development—The other way to develop web services is by starting out with a Java class and then letting the web service framework handle the job of generating a WSDL contract for you.
This is by far the easiest mode of development, but it also means that the tool (CXF in this case) is in control of what the contract will be.
When you want to fine-tune your WSDL file, it may be better to go the contract-first route.
Figure 7.7 A client invokes a remote web service over HTTP.
To the client, it looks as if it’s calling a Java method on the service endpoint interface (SEI)
Under the hood, this method invocation passes through the web services framework, across a network, and finally calls into the service endpoint implementation on the remote server.
To show these concepts in action, let’s going back to Rider Auto Parts, where they need a new piece of functionality implemented.
What we didn’t say then was that this HTTP link to the backend order processing systems needed to be a web service.
Before you jump into creating this web service, let’s take a moment to go over how CXF can be configured within Camel.
There are two main ways to configure a CXF component URI: by referencing a bean containing the configuration or by configuring it within the URI.
These options can also be used to configure a reusable CXF endpoint bean in Spring.
Table 7.8 Common URI options used to configure the CXF component.
The SEI is required if the CXF data format mode is POJO.
If you already have an instance of a concrete class, you can reference it using the #beanName style.
When using a CXF endpoint bean in Spring, you have much more power than by configuring CXF via URI options.
In the CXF endpoint bean, you can configure things like CXF interceptors, JAX-WS handlers, and the CXF bus.
The URI for configuring the CXF component looks like this:
The beanName name specifies the ID of the CXF endpoint bean defined in your Spring XML file.
This bean supports the URI options listed in table 7.8 as well as an address attribute that tells Camel what address to use for the web service.
Listing 7.2 shows how a CXF endpoint bean is configured.
After configuring an endpoint as shown in listing 7.2, you can use it in a producer or consumer using the following URI:
Note that if there is only one port in a WSDL, Camel will choose this as the default port.
If there is more than one port defined per service, you need to set the portName property.
We’ll only be covering POJO mode in this chapter; you can find more information on the other two modes on the CXF component page in the Camel online documentation: http://camel.apache.org/cxf.html.
Table 7.8 Common URI options used to configure the CXF component (continued)
There is a notable difference when using producers versus consumers.
In the context of a web service, a producer in Camel calls a remote web service.
This web service could be defined by Camel or by some other web framework.
To invoke a web service in Camel, you use the familiar to Java DSL method:
Consumers are a little more interesting, as they expose an entire route to the world as a web service.
A Camel route could be a complex process, with many branches and processing nodes, but the caller will only see it as a web service with input parameters and a reply.
Say you start out with a route that consists of several steps, like this:
To expose this route to the web, you can add a CXF endpoint to the beginning:
Now, when the web service configured by myCXFEndpointBean is called, the whole route will be invoked.
In the web services world, a consumer is typically a client that calls a remote service.
In Camel, a consumer is a server, so the definition is reversed!
In order to use the CXF component, you’ll have to add some dependencies.
That will get you most of the way to a usable CXF component, but you also need to add a module for the CXF transport you’re using.
In most cases, this will be HTTP, so you’ll need to add another dependency to your POM:
Web services (CXF component) CXF supports several other transports as well, and you can find more information about them on the CXF website at http://cxf.apache.org/docs/transports.html.
Now that you have a sense of the configuration details, let’s take a hands-on look at how to develop web services with Camel.
In contract-first development, you start by creating a WSDL document and then getting a web service tool to generate the necessary Java code.
Creating the WSDL contract for a particular web service is a non-trivial task.
It’s often best to think about what methods, types, and parameters you’ll need before starting.
In this case, to place an order at Rider Auto Parts with a web service, you need a single method call named order.
This method will accept part name, amount, and customer name parameters.
When the method is complete, it will return a result code to the client.
The web service should be exposed on the server’s http://localhost:9000/order address.
The WSDL for this web service is shown in listing 7.3
Figure 7.8 In contract-first web service development, you start out by creating a WSDL document and letting a tool generate the required source interfaces and stubs.
As you can see in listing 7.3, a WSDL contract is quite a mouthful! Writing this kind of document from scratch would be pretty hard to get right.
Typically, a good way to start one of these is to use a wizard or GUI tooling.
Tweaking this skeleton file is much easier than starting from scratch.
Once you have a portType element defined, you can pass the WSDL fragment through CXF’s wsdl2xml tool (http://cxf.apache.org/docs/wsdl-to-xml.html), which will add a binding element for you.
When the binding element is defined, the wsdl2service tool (http://cxf.apache.org/docs/wsdl-to-service.html) can then generate a service element for you.
This is also the most common WSDL version you’ll see in use.
Web services (CXF component) There are five main elements specified in the WSDL file shown in listing 7.3, and all WSDL files follow this same basic structure:
You first define what parameters the web service will be passing around B.
This configuration is done using the XML schema, which may make it a bit more familiar to you.
You specify a name and a type for each parameter.
The next section of listing 7.3 defines the messages used by the web service C.
These messages allow you to assign parameters to use as input versus output.
You then define the portType D, which is the interface that you’ll be exposing over the web.
On this interface, you define a single operation (method) that takes a purchaseOrder message as input and returns an orderResult message.
The binding section E then specifies the use of the HTTP transport for the messages and that the messages should be encoded over the wire using document literal style.
Document literal means that the SOAP message body will be an XML document.
The format of this XML document is specified using the XML schema.
An excellent introduction is available from the IBM developerWorks website: http://www.ibm.com/developerworks/webservices/library/ws-whichwsdl.
Finally, the service section F exposes a port using a specific binding on an address.
In this example, you use the port and binding definitions from before and set the web service address to http://localhost:9000/order.
The next step in contract-first web service development is taking the WSDL and generating Java code that implements it.
Listing 7.4 shows how this tool can be used from a Maven POM file.
The tool accepts your WSDL file C and an output location for the generated source B.
After this completes, you can look in the output directory and see that there are four files generated:
These files implement a stubbed-out version of the order web service.
If you were not using Camel, you would write your business logic in the OrderEndpointImpl file that was generated.
To use this web service in Camel, you need to define a CXF endpoint.
Because there is only one service defined in order.wsdl, CXF will choose that automatically.
If there were more than one service, you would need to set the serviceName and endpointName attributes on the endpoint bean.
The serviceName is the name of the WSDL service element, and endpointName is the name of the port element.
You can browse a web service’s WSDL yourself by appending ?wsdl to any web service URL in your browser.
This WSDL is the same as the file provided in the wsdlURL attribute of the endpoint bean.
With all that set up, you’re ready to start using the order web service within a Camel route.
Because you defined your CXF web service as an endpoint bean in listing 7.5, you just had to import the bean configuration B and refer to the bean ID to set up the consumer C.
Recall that setting up a CXF consumer effectively turns the entire route into a web service, so once the order data is sent to an internal queue for processing, the output produced by the route D is returned to the caller of the web service C.
How does one call this web service? Well, you could use pure CXF or another web services framework compatible with CXF.
You used an endpoint bean to configure CXF earlier, so you can use that to send to the web service as well.
You first need to prepare the parameters to be passed into the web service:
Recall that, in the WSDL, you specified that the web service accepted parameters for part name, number of parts, and customer name.
Next, you can use a ProducerTemplate to send a message to the web service:
This will run the wsdl2java tool to generate the code from the WSDL, and then run a test that loads up the web-enabled route and calls it using a ProducerTemplate.
If you call a web service with multiple operations, you need to specify which operation Camel should invoke.
You can do this by setting the operationName header on the message before sending it to a CXF endpoint.
In this case, you’re invoking the orderEndpoint, which only has one operation, but this demonstrates how you can use this header.
The header is set to the operation name order, which you can find in the WSDL under the wsdl:operation element.
Other ways of communicating over HTTP The CXF component provides extensive support for many web services standards.
In some cases, you may not need to or won’t be able to use those standards and you’ll just need to communicate over HTTP.
For example, you may be interfacing with an HTTP-based service that has been up since before the WS-* specifications were created.
You could also need a barebones web service where you manually handle things like parsing the messages.
Or maybe you want to download a remote file over HTTP—there are lots of reasons you might need HTTP support.
Camel provides two main ways of doing raw communications over HTTP: the Jetty component and the HTTP component.
The HTTP component can only be used for sending (producing) to a remote service, whereas the Jetty component can handle consuming and producing.
Web services (CXF component) Think contract-first development is hard? Well, some developers do, even though it gives you complete control over your web service contract—an important detail.
Next we’ll look at how to develop web services using a code-first approach.
Code-first web services development is often touted as a much easier alternative to contract-first development.
In code-first development, you start out with Java that’s annotated with JAX-WS annotations, and then you get the web services framework to generate the underlying WSDL contract for you.
To see how this is possible with Camel, let’s try implementing the solution presented in the previous section in a code-first manner.
You start much as you do with contract-first development—you need to think about what methods, types, and parameters you need.
Because you’re starting with Java, you’ll need an interface to represent the web service:
There are many annotations that allow you to fine-tune the generated WSDL, but for many cases the defaults work quite well.
In order to use this interface as a web service, you don’t have to change any of your Camel configuration from the previous section.
For the special case where you can’t start up an embedded Jetty server and need to hook in to the existing servlet container (like Apache Tomcat), you can use the Servlet component.
You can find more information on these components on the Camel website:
Figure 7.9 In code-first web services development, you start out by coding the service interface and implementation and then using a tool to generate the required WSDL.
To use this bean in a Camel route, you can reference it as before:
This will run a test that loads up the web-enabled route and calls it using a ProducerTemplate.
The Java to WSDL process happens automatically in the background.
Certainly, the code-first approach allows you to implement web services quickly.
But it’s good to understand what is happening under the hood of a web service, because it’s a complex technology.
Speaking of under the hood, several types of messaging that we’ve looked at before, like FTP, JMS, and now web services, all run on top of other protocols.
Let’s look at how you can use Camel for these kinds of low-level communications.
All of these can be considered essential in any integration framework.
Another essential mode of integration is using low-level networking protocols, such as the Transmission Control Protocol (TCP) and the User Datagram Protocol (UDP)
Even if you haven’t heard of these protocols before, you’ve definitely used them—protocols like email, FTP, and HTTP run on top of TCP.
To communicate over these and other protocols, Camel uses Apache MINA and Netty.
Both MINA and Netty are networking frameworks that provide asynchronous event-driven APIs and communicate over various protocols like TCP and UDP.
In this section, we’ll be using MINA to demonstrate low-level network communication with Camel.
For more information on using Netty with Camel, see the camel-netty component’s documentation (http://camel.apache.org/netty.html)
The MINA component is located in the camel-mina module of the Camel distribution.
You can access this by adding it as a dependency to your Maven POM like this:
The most common configuration options are listed in table 7.9
Networking (MINA component) In addition to the URI options, you also have to specify the transport type and port you want to use.
Let’s now see how you can use the MINA component to solve a problem at Rider.
Back at Rider Auto Parts, the production group has been using automated manufacturing robots for years to assist in producing parts.
What they’ve been lacking, though, is a way of tracking the whole plant’s health from a single location.
What they’d like to have is an operations center with a single-screen view of the entire plant.
To accomplish this, they’ve purchased sensors that communicate machine status over TCP.
The new operations center needs to consume these messages over JMS.
Table 7.9 Common URI options used to configure the MINA component.
Codecs need to be loaded into the registry and referenced using the #beanName style.
The textline codec understands bodies that have string content and end with a line delimiter.
This means that clients will be able to get a response back from the server.
Enable this property to serialize the entire exchange for transmission.
Hand-coding a TCP server such as this wouldn’t be a trivial exercise.
You’d need to spin up new threads for each incoming socket connection, as well as transform the body to a format suitable for JMS.
Not to mention the pain involved in managing the low-level networking protocols.
In Camel, a possible solution is accomplished with a single line:
Here you set up a TCP server on port 8999 using MINA, and it parses messages using the textline codec.
The sync property is set to false to make this route InOnly—any clients sending a message won’t get a reply back.
You may be wondering what a textline codec is, and maybe even what a codec is! In TCP communications, a single message payload going out may not reach its destination in one piece.
All will get there, but it may be broken up or fragmented into smaller packets.
It’s up to the receiver (in this case, the server) to wait for all the pieces and assemble them back into one payload.
A codec decodes or encodes the message data into something that the applications on either end of the communications link can understand.
As figure 7.11 illustrates, the textline codec is responsible for grabbing packets as they come in and trying to piece together a message that’s terminated by a specified character.
This example is provided in the book’s source in the chapter7/mina directory.
Figure 7.10 Sensors feed status messages over TCP to a server, which then forwards them to a JMS operations queue.
Figure 7.11 During TCP communications, a payload may be broken up into multiple packets.
A MINA textline codec can assemble the TCP packets into a full payload by appending text until it encounters a delimiter character.
If you had not specified the textline URI option in the previous example, the MINA component would have defaulted to using the object serialization codec.
This codec will take any Serializable Java object and send its bytes over TCP.
This is a pretty handy codec if you aren’t sure what payload format to use.
If you’re using this codec, you’ll also need to ensure that the classes are on the classpath of both the sender and the receiver.
There are times when your payload will have a custom format that neither textline or object serialization accommodates.
In this case, you’ll need to create a custom codec.
The TCP server you set up for Rider Auto Parts in the previous section has worked out well.
Sensors have been sending back status messages in plain text, and you used the MINA textline codec to successfully decode them.
But one type of sensor has been causing an issue: the sensor connected to the welding machine sends its status back in a custom binary format.
You need to interpret this custom format and send a status message formatted like the ones from the other sensors.
In this example, the sensor will be transmitting the message over TCP, so you don’t have to worry about this too much, except for testing that the server works.
You need to convert this to the plain text format used by the other sensors, as illustrated in figure 7.12
The first 7 bytes are the machine ID and the last byte represents a status.
Note that you need to change the port that it listens on, so as not to conflict with your other TCP server.
You also add a reference to the custom codec loaded into the registry.
In this case, the codec is loaded into a JndiRegistry like this:
Now that the setup is complete, you can get to the real meat of the custom codec.
If you recall, decoding the custom binary format into a plain text message was the most important task for this particular application.
To try this example yourself, go to the chapter7/mina directory of the book’s source and run the following unit test:
Now that you’ve tried out low-level network communications, its time to interact with one of the most common applications in the enterprise.
So it makes sense that Camel has first-class support for accessing databases.
Camel has five components that let you access databases in a number of ways:
You can find it at the camel-extra project (http://code.google.com/p/ camel-extra)
In this section, we’ll be covering both the JDBC and JPA components.
You can do pretty much any database-related task with them that you can do with the others.
For more information on the other components, see the relevant pages on the Camel website’s components list (http://camel.apache.org/components.html)
The Java Database Connectivity (JDBC) API defines how Java clients can interact with a particular database.
It tries to abstract away details about the actual database being used.
To use this component, you need to add the camel-jdbc module to your project:
The most common URI options are shown in table 7.10
After this is specified, the component is ready for action.
But you may be wondering where the actual SQL statement is specified.
The JDBC component is a dynamic component in that it doesn’t merely deliver a message to a destination but takes the body of the message as a command.
In EIP terms, this kind of message is called a command message.
Because a JDBC endpoint accepts a command, it doesn’t make sense to use it as a consumer, so, you can’t use it in a from DSL statement.
Of course, you can still retrieve data using a select SQL statement as the command message.
In this case, the query result will be added as the outgoing message on the exchange.
To demonstrate the SQL command-message concept, let’s revisit the order router at Rider Auto Parts.
In the accounting department, when an order comes in on a JMS queue, the accountant’s business applications can’t use this data.
So any incoming orders need to be put into the corporate database.
Using Camel, a possible solution is illustrated in figure 7.13
Table 7.10 Common URI options used to configure the JDBC component.
The default of 0 causes the readSize to be unbounded.
Figure 7.13 A message from the JMS accounting queue is transformed into an SQL command message by the OrderToSqlBean bean.
The JDBC component then executes this command against its configured data source.
Working with databases (JDBC and JPA components) The main takeaway from figure 7.13 is that you’re using a bean to create the SQL statement from the incoming message body.
This is the most common way to prepare a command message for the JDBC component.
You could use the DSL directly to create the SQL statement (by setting the body with an expression), but you have much more control when you use a custom bean.
The route for the implementation of figure 7.13 is simple on the surface:
The bean endpoint here is using the bean with the name orderToSql to convert the incoming message to an SQL statement.
The orderToSql bean uses XPath to parse an incoming order message with a body something like this:
The data in this order is then converted to an SQL statement like this:
This SQL statement then becomes the body of a message that will be passed into the JDBC endpoint.
In this case, you’re updating the database by inserting a new row.
If there were any problems running the SQL command, an SQLException would be thrown.
Listing 7.8 A bean that converts an incoming order to an SQL statement.
Camel would also set the CamelJdbcRowCount header to the number of rows returned from the query.
To run this example for yourself, change to the chapter7/jdbc directory of the book’s source, and run the following command:
Having raw access to the database through JDBC is a must-have ability in any integration framework.
There are times, though, that you need to persist more than raw data—sometimes you need to persist whole Java objects.
You can do this with the JPA component, which we’ll look at next.
There is a new requirement at Rider Auto Parts: instead of passing around XML order messages, management would like to adopt a POJO model for orders.
A first step would be to transform the incoming XML message into an equivalent POJO form.
In addition, the order persistence route in the accounting department would need to be updated to handle the new POJO body type.
You could manually extract the necessary information as you did for the XML message in listing 7.8, but there is a better solution for persisting objects.
The Java Persistence Architecture (JPA) is a wrapper layer on top of object-relational mapping (ORM) products such as Hibernate, OpenJPA, TopLink, and the like.
These products map Java objects to relational data in a database, which means you can save a Java object in your database of choice, and load it up later when you need it.
This is a pretty powerful ability, and it hides many details.
Because this adds quite a bit of complexity to your application, plain JDBC should be considered first to see if it meets your requirements.
To use the JPA component, you need to add the camel-jpa module to your project:
You’ll also need to add JARs for the ORM product and database you’re using.
The examples in this section will use OpenJPA and the HyperSQL database, so you need the following dependencies as well:
Working with databases (JDBC and JPA components) The JPA component has a number of URI options, many of which can only be applied to either a consumer or producer endpoint.
Table 7.11 Common URI options used to configure the JPA component.
The default of -1 means an unlimited number of results.
The default of 0 means an unlimited number of results.
This isn’t very portable, but it allows you to take advantage of features specific to a particular database.
Otherwise, they may stay in memory with the ORM tool until it decides to persist.
The term entity is borrowed from relational database terminology and roughly translates to an object in object-oriented programming.
This means that your new POJO order class needs to have this annotation if you wish to persist it with JPA.
For testing purposes, you can use a producer template to send a new PurchaseOrder to the accounting JMS queue, like so:
Your route from section 7.6.1 is now a bit simpler.
You send directly to the JPA endpoint after an order is received on the queue:
Working with databases (JDBC and JPA components) Now that your route is in place, you have to configure the ORM tool.
This is by far the most configuration you’ll have to do when using JPA with Camel.
There are two main bits of configuration: hooking the ORM tool’s entity manager up to Camel’s JPA component, and configuring the ORM tool to connect to your database.
For demonstration purposes here, we’ll be using Apache OpenJPA, but you could use any other JPA-compliant ORM tool.
The beans required to set up the OpenJPA entity manager are shown in listing 7.10
The Spring beans file shown in listing 7.10 does a number of things to set up JPA.
First off, it creates a Camel JpaComponent and specifies the entity manager to be used B.
This entity manager C is then hooked up to OpenJPA and the HyperSQL order database D.
It also sets up the entity manager so it can participate in transactions E.
There is one more thing left to configure before JPA is up and running.
This persistence unit defines what entity classes will be persisted, as well as the.
In JPA, this configuration is stored in the persistence.xml file in the META-INF directory on the classpath.
There are two main things in listing 7.11 to be aware of.
First, classes that you need persisted need to be defined here B, and there can be more than one class element.
Also, if you need to connect to another database or otherwise change the connection information to the database, you’ll need to do so here C.
Now that all of the setup is complete, your JPA route is complete.
To try out this example, browse to the chapter7/jpa directory and run the JpaTest test case with this Maven command:
This example sends a PurchaseOrder to the accounting queue and then queries the database to make sure the entity class was persisted.
Manually querying the database via JPA is a useful ability, especially in testing.
First off, you grab the instance of the JpaTemplate on the JpaEndpoint.
You then search for instances of your entity class in the database using JPQL, which is similar to SQL but deals with JPA entity objects instead of tables.
A simple check is then performed to make sure the object is the right type and that there is only one result.
Listing 7.11 Configuring the ORM tool with the persistence.xml file.
In-memory messaging (Direct, SEDA, and VM components) Now that we’ve covered accessing databases, and messaging that can span the entire web, we’re going to shift our attention to communication within the JVM.
Yet there is still another important messaging topic to cover: in-memory messaging.
Camel provides three main components in the core to handle in-memory messaging.
For asynchronous messaging, there are the SEDA and VM components.
The only difference between SEDA and VM is that the SEDA component can be used for communication within a single CamelContext, whereas the VM component is a bit broader and can be used for communication within a JVM.
If you have two CamelContexts loaded into an application server, you can send messages between them using the VM component.
The Direct component is about as simple as a component can get, but it’s extremely useful.
It’s probably the most common Camel endpoint you’ll see in a route.
There are no options that you can specify or backends to configure; there is just an endpoint name.
So what does this give you? The Direct component lets you make a synchronous call to a route or, conversely, expose a route as a synchronous service.
To demonstrate, say you have a route that’s exposed by a direct endpoint as follows:
Sending a message to the direct:startOrder endpoint will invoke a web service defined by the orderEndpoint CXF endpoint bean.
Let’s also say that you send a message to this endpoint using a ProducerTemplate, as you saw in section 7.4.2:
The ProducerTemplate will create a Producer under the hood that sends to the direct:startOrder endpoint.
In most other components, some processing happens in between the producer and the consumer.
For instance, in a JMS component, the message could be sent to a queue on a JMS broker.
And by directly, we mean that in the producer there is a method invocation on the consumer.
The only overhead of using the Direct component is a method call!
This simplicity and minimal overhead make the Direct component a great way of starting routes and synchronously breaking up routes into multiple pieces.
But even though there is little overhead to using the Direct component, its synchronous nature doesn’t fit well with all applications.
If you need to operate asynchronously, you need the SEDA or VM components, which we’ll look at next.
As you saw in the discussion of JMS earlier in the chapter (section 7.3), there are many benefits to using message queuing as a means of sending messages.
You also saw how a routing application can be broken up into many logical pieces (routes) and connected by using JMS queues as bridges.
But using JMS for this purpose in an application on a single host adds unnecessary complexity for some use cases.
If you want to reap the benefits of asynchronous messaging but aren’t concerned with JMS specification conformance or the built-in reliability that JMS provides, you may want to consider an in-memory solution.
By ditching the specification conformance and any communications with a message broker (which can be costly), an inmemory solution can be much faster.
Note that there is no message persistence to the disk, like in JMS, so you run the risk of losing messages in the event of a crash—your application should be tolerant of losing messages.
Table 7.12 Common URI options used to configure the SEDA and VM components.
The default is to only wait if its an InOut MEP.
A value less than or equal to 0 will disable the timeout.
In-memory messaging (Direct, SEDA, and VM components) One of the most common uses for SEDA queues in Camel is to connect routes together to form a routing application.
For example, recall the example presented in 7.3.1 where you used a JMS topic to send copies of an incoming order to the accounting and production departments.
In that case, you used JMS queues to connect your routes together.
Because the only parts that are hosted on separate hosts are the accounting and production queues, you can use SEDA queues for everything else.
Any JMS messaging that you were doing within a CamelContext could be switched over to SEDA.
You still need to use JMS for the accounting and production queues, because they’re located in physically separate departments.
You may have noticed that the JMS xmlOrders topic has been replaced with a SEDA queue in figure 7.14
In order for this SEDA queue to behave like a JMS topic (using a publish-subscribe messaging model), you need to set the multipleConsumers URI option to true, as shown in listing 7.12
Listing 7.12 A topic allows multiple receivers to get a copy of the message.
Figure 7.14  SEDA queues can be used as a low-overhead replacement for JMS when messaging is within a CamelContext.
For messages being sent to other hosts, JMS can be used.
In this case, all order routing is done via SEDA until the order needs to go to the accounting and production departments.
This example behaves in the same way as the example in section 7.3.1, except that it uses SEDA endpoints instead of JMS.
Another important detail in this listing is that SEDA endpoint URIs that are reused in consumer and producer scenarios need to be exactly the same as each other.
It’s not enough to specify the correct SEDA queue name; you need to use the queue name and all options.
To run this example, go to the chapter7/seda directory in the book’s source, and run this command:
Why did you get this output? Well, you had a single order file named message1.xml, and it was published to the xmlOrders topic.
Both the accounting and production queues were subscribed to the topic, so each received a copy.
The testing routes consumed the messages on those queues and output the messages.
So far you’ve been kicking off routes either by hand or by consuming from a filesystem directory.
How can you kick off routes automatically? Or better yet, how can you schedule a route’s execution to occur?
Camel supports this kind of service with the Timer and Quartz components.
The Timer component is useful for simple recurring tasks, but when you need more control of when things get started, the Quartz component is a must.
In this section, we’re first going to look at the Timer component and then move on to the more advanced Quartz component.
The Timer component comes with Camel’s core library and uses the JRE’s built-in timer mechanism to generate message exchanges at regular intervals.
This component only supports consuming, because sending to a timer doesn’t really make sense.
Table 7.13 Common URI options used to configure the Timer component.
Automating tasks (Timer and Quartz components) As an example, let’s print a message stating the time to the console every 2 seconds.
When this timer fires an event, Camel creates an exchange with an empty body and sends it along the route.
In this case, you’re setting the body of the message using a Simple language expression.
The firedTime header was set by the Timer component; for a full list of headers set, see the online documentation (http://camel.apache.org/ timer.html)
If you use the same timer name in another route, it will reuse the same Timer object.
You can run this simple example by changing to the chapter7/timer directory of the book’s source and running this command:
As you can see, an event was fired every 2 seconds.
But suppose you wanted to schedule a route to execute on the first day of each month? You couldn’t do this easily with the Timer component.
Like the Timer component, the Quartz component allows you to schedule the generation of message exchanges.
But the Quartz component gives you much more control over how this scheduling happens.
You can also take advantage of Quartz’s many other enterprise features.
We won’t be covering all of Quartz’s features here—only ones exposed directly in Camel.
For a complete look at how to use Quartz, please see the Quartz website: http://www.quartz-scheduler.org.
The common URI options for the Quartz component are listed in table 7.14
Before you can use the Quartz component, you’ll need to add the following dependency to your Maven POM file:
Let’s now reproduce the timer example from the previous section with Quartz.
Although this behaves in the same way as the Timer example, there are a few different things going on under the covers.
Timers in Quartz are made up of a Trigger and a JobDetail.
Triggers can also have a group name associated with them, which you can specify by adding the group name to your URI, as follows:
If the group name is omitted, as in the previous route, “Camel” is used as the group name.
You may be thinking that the option names are a bit long, but there is a reason for this.
As stated in table 7.14, options starting with trigger allow you to set properties on the Trigger object.
Table 7.14 Common URI options used to configure the Quartz component.
A value of -1 causes the timer to repeat indefinitely.
You can similarly set options on the JobDetail by using properties that start with job, followed by a valid property name.
For instance, you can set the job name by using the job.name URI option.
So far, you’ve replaced the Timer component example with a functionally equivalent Quartz-based example.
How would you schedule something more complex, like kicking off a route on the first day of each month? The answer is by using cron expressions.
Readers familiar with Linux or Unix will probably have heard of the cron scheduling application.
Quartz allows you to use scheduling syntax similar to the venerable cron application.
A cron expression is a string consisting of 6–7 fields separated by white space.
These accept numeric values (and optional textual ones) for the times you want a trigger to fire.
More information on cron expressions can be found on the Quartz website (http://www.quartz-scheduler.org/docs/tutorials/crontrigger.html)
The cron expression for occurring on the first day of each month at 6:00 a.m.
In this expression, the third digit denotes the hour at which to execute, and the fourth digit is the day of the month.
You can also see that a star was placed in the month column so that every month would be triggered.
Setting up Quartz to use cron triggers in Camel is easy.
You just need to use the cron option and make sure to replace all white space with plus characters (+)
Using this URI in a route will cause a message exchange to be generated (running the route) on the first day of each month.
You should be able to see now how the scheduling components in Camel can allow you to execute routes at specified times.
Congratulations on making it through the barrage of components we covered in this chapter.
By now, you should have a good understanding of how to use them in your own applications.
Here are some of the key ideas you should take away from this chapter:
We could only cover the most widely used and important components in this book, so you should be aware that if you need to use one of the many other components, documentation is available at http://camel.apache.org/components.html.
We briefly touched on how components are resolved at runtime in Camel.
Camel imposes no restrictions on where your components come from, so you can easily write your own (as described in chapter 11) and include it in your Camel application.
Don’t write to files manually; use the File and FTP components.
Camel’s File and FTP components have many options that will suit most file-processing scenarios.
Camel makes it easy to send messages to and receive them from JMS providers.
You will no longer have to write dozens of lines of JMS API calls to send or receive a simple message.
Use the CXF component for all your web services needs.
The CXF component allows you to make calls to a variety of web service types or to expose your Camel route to the world as a web service.
Network programming can be difficult, given the low-level concepts you need to deal with.
The MINA component handles these details for you, making it easy to communicate over network protocols such as TCP and UDP.
Hook your routes into databases using the JDBC and JPA components.
The JDBC component allows you to access databases using tried-and-true SQL, whereas the JPA component is all about persisting Java objects into databases.
Use in-memory messaging when reliability isn’t a concern but speed is.
Camel provides three choices for in-memory messaging: the Direct, SEDA, and VM components.
Kick off routes at specified intervals using the Quartz or Timer components.
Some tasks need to be executed at specified intervals, and the Quartz and Timer components come into play here.
Components in Camel fill the role of bridging out to other transports, APIs, and data formats.
They’re also the on and off ramps to Camel’s routing abilities.
Back in chapter 2, you were exposed to some of Camel’s routing capabilities by using some standard EIPs.
In the next chapter, we’ll look at some of the more complex EIPs available in Camel.
Unlike when you read chapter 2, you’re now armed with the knowledge of how to connect to many different services with Camel.
Keep your knowledge of components handy—you can think up some interesting integration scenarios!
Today’s businesses aren’t run on a single monolithic system, and most businesses have a full range of disparate systems.
There is an ever-increasing demand for those systems to integrate with each other and with external business partners and government systems.
To help deal with the complexity of integration problems, enterprise integration patterns (EIPs) have become the standard way to describe, document, and implement complex integration problems.
It would be impossible for this book to cover all the EIPs Camel supports, which currently total around 60 patterns.
This chapter is devoted to covering five of the most powerful and feature-rich patterns.
The patterns discussed in this chapter are listed in table 8.1
Let’s look at these patterns in a bit more detail.
The first two patterns listed in table 8.1 are related.
The Splitter can split out a single message into multiple submessages, and the Aggregator can combine those submessages back into a single message.
The EIPs allow you to build patterns LEGO style, which means that patterns can be combined together to form new patterns.
For example, you can combine the Splitter and the Aggregator into what is known as the Composed Message Processor EIP, as illustrated in figure 8.1
Aggregator Used to combine results of individual but related messages into a single outgoing message.
You can view this as the reverse of the Splitter pattern.
Splitter Used to split a message into pieces that are routed separately.
Routing Slip Used to route a message in a series of steps, where the sequence of steps isn’t known at design time and may vary for each message.
Dynamic Router Used to route messages with a dynamic router dictating where the message goes.
Load Balancer Used to balance the load to a given endpoint using a variety of different balancing policies.
Figure 8.1 The Composed Message Processor EIP splits up the message, routes the submessages to the appropriate destinations, and re-aggregates the response back into a single message.
The Aggregator EIP is likely the most sophisticated and most advanced EIP implemented in Camel.
It has many use cases, such as aggregating incoming bids for auctions or throttling stock quotes.
A question that is often asked on the Camel mailing list is how to route messages dynamically.
We covered Recipient List in chapter 2, and in this chapter we’ll show you how to use the Routing Slip and Dynamic Router patterns.
The EIP book doesn’t list the Load Balancer, which is a pattern implemented in Camel.
Suppose you route PDF messages to network printers, and those printers come and go online.
You can use the Load Balancer to send the PDF messages to another printer if one printer is unresponsive.
That covers the five EIPs we’ll cover in this chapter.
It’s now time to look at the first one in detail, the Aggregator EIP.
The Aggregator EIP is important and complex, so we’ll cover it well.
Don’t despair if you don’t understand the pattern in the first few pages.
The Aggregator combines many related incoming messages into a single aggregated message, as illustrated in figure 8.2
The Aggregator receives a stream of messages and identifies messages that are related, which are then aggregated into a single combined message.
Figure 8.2 The Aggregator stores incoming messages until it receives a complete set of related messages.
Then the Aggregator publishes a single message distilled from the individual messages.
Example uses of Aggregator The Aggregator EIP supports many use cases, such as the loan broker example from the EIP book, where brokers send loan requests to multiple banks and aggregate the replies to determine the best deal.
You could also use the Aggregator in an auction system to aggregate current bids.
Also imagine a stock market system that continuously receives a stream of stock quotes, and you want to throttle this to publish the latest quote every 5 seconds.
This can be done using the Aggregator to choose the latest message and thus trigger a completion every 5 seconds.
We’ll cover how this process works in detail in the next section.
When using the Aggregator, you have to pay attention to the following three configuration settings, which must be configured.
Failure to do so will cause Camel to fail on startup and to report an error regarding the missing configuration.
Correlation identifier—An Expression that determines which incoming messages belong together.
Completion condition—A Predicate or time-based condition that determines when the result message should be sent.
In this section, we’ll look at a simple example that will aggregate messages containing alphabetic characters, such as A, B, and C.
This will keep things simple, making it easier to follow what’s going on.
The Aggregator is equally equipped to work with big loads, but that can wait until we’ve covered the basic principles.
Suppose you want to collect any three messages together and combine them together.
Given three messages containing A, B, and C, you want the aggregator to output a single message containing “ABC”
When the first message with correlation identifier 1 arrives, the aggregator initializes a new aggregate and stores the message inside the aggregate.
In this example, the completion condition is when three messages have been aggregated, so the aggregate isn’t yet complete.
When the second message with correlation identifier 1 arrives, the EIP adds it to the already existing aggregate.
The third message specifies a different correlation identifier value of 2, so the aggregator starts a new aggregate for that value.
The fourth message relates to the first aggregate (identifier 1), so the aggregate has now aggregated three messages and the completion condition is fulfilled.
As a result, the aggregator marks the aggregate as complete and publishes the resulting message:
Figure 8.3 Illustrates the Aggregator EIP in action, with partial aggregated messages updated with arriving messages.
As mentioned before, there are three configurations in play when using the Aggregator EIP: correlation identifier, completion condition, and aggregation strategy.
To understand how these three are specified and how they work, let’s start with the example of a Camel route in the Java DSL (with the configurations in bold):
The correlation identifier is header("myId"), and it’s a Camel Expression.
We’ll cover this class in more detail in a moment.
Finally, the completion condition is based on size (there are five kinds of completion conditions, listed in table 8.3)
It simply states that when three messages have been aggregated, the completion should trigger.
This refers to a Spring <bean>, which is listed in the top of the Spring XML file.
The completion condition is also defined as a completionSize attribute.
The most noticeable difference is how the correlation identifier is defined.
You can run the examples using the following Maven goals:
This unit test sends the same messages as shown in figure 8.3—four messages in total.
When you run the test, you will see the output on the console:
Notice how the console output matches the sequence in which the messages were aggregated in the example from figure 8.3
As you can see from the console output, the messages with correlation key 1 were completed, because they met the completion condition, which was size based on three messages.
The last line of the output shows the published message, which contains the letters “ABC.”
So what happens with the F message? Well, its completion condition has not been met, so it waits in the aggregator.
You could modify the test method to send in additional two messages to complete that second group as well:
Let’s now turn our focus to how the Aggregator EIP combines the messages, which causes the A, B, and C messages to be published as a single message.
Listing 8.1 shows the strategy used in the previous example.
At runtime, the aggregate method is invoked every time a new message arrives.
In this example, it will be invoked four times: one for each arriving message A, B, F, and C.
To show how this works, we’ve listed the invocations as they would happen, in table 8.2
Notice in table 8.2 that the oldExchange parameter is null on two occasions.
This occurs when a new correlation group is formed (no preexisting messages have arrived with the same correlation identifier)
In this situation, you simply want to return the message as is, because there are no other messages to combine it with B.
On the subsequent aggregations, neither parameter is null so you need to merge the data into one Exchange.
In this example, you grab the message bodies and add them together C.
Then you replace the existing body in the oldExchange with the updated body.
The Aggregator also ensures ordering, which means the messages are aggregated in the same order as they are sent into the Aggregator.
You should now understand the principles of how the Aggregator works.
For a message to be published from the Aggregator, a completion condition must have been met.
In the next section, we’ll discuss this and review the different conditions Camel provides out of the box.
Completion conditions play a bigger role in the Aggregator than you might think.
Imagine a situation where a condition never occurs, causing aggregated messages.
Table 8.2 Sequence of invocations of aggregate method occurring at runtime.
A null A The first message arrives for the first group.
For example, suppose the C message never arrived in the example in section 8.2.1
To remedy this, you could add a timeout condition that would react if all messages aren’t received within a certain time period.
To cater for that situation and others, Camel provides five different completion conditions, which are listed in table 8.3
You can mix and match them according to your needs.
The Aggregator supports using multiple completion conditions, such as using both the completionSize and completionTimeout conditions.
When using multiple conditions, though, the winner takes all—the completion condition that completes first will result in the message being published.
Also the Aggregator documentation on the Camel website has more details: http://camel.apache.org/aggregator2
Table 8.3 Different kinds of completion conditions provided by the Aggregator EIP.
You can either use a fixed value (int) or use an Expression to dynamically decide a size at runtime.
This condition triggers if a correlation group has been inactive longer than the specified period.
Timeouts are scheduled for each correlation group, so the timeout is individual to each group.
You can either use a fixed value (long) or use an Expression to dynamically decide a timeout at runtime.
There is a single scheduled timeout for all correlation groups, which causes all groups to complete at the same time.
At the time of writing, the following components support this condition: File, FTP, Mail, iBatis, and JPA.
We’ll now look at how you can use multiple completion conditions.
You can run the example using the following Maven goals:
As you can see from the bold code in the route, using a second condition is just a matter of adding an additional completion condition.
If you run this example, it will use the following test method:
This example should cause the aggregator to publish two outgoing messages, as shown in the following console output; one for Honda and one for Toyota.
If you look closely at the test method and the output from the console, you should notice that the Honda order arrived first, but it was the last to be published.
This is because its completion was triggered by the timeout, which was set to 5 seconds.
In the meantime, the Toyota order had its completion triggered by the size of two messages, so it was published first.
Using multiple completion conditions makes good sense if you want to ensure that aggregated messages eventually get published.
For example, the timeout condition ensures that after a period of inactivity the message will be published.
In that regard, you can use the timeout condition as a fallback condition, with the price being that the published message will only be partly aggregated.
Suppose you expected two messages to be aggregated into one, but you only received one message; the next section reveals how you can tell which condition triggered the completion.
Camel enriches the published Exchange with the completion details listed in table 8.4
The information listed in table 8.4 allows you to know how a published aggregated Exchange was completed, and how many messages were combined.
For example, you could log to the console which condition completed, simply by adding this to the Camel route:
This information might come in handy in your business logic, when you need to know whether or not all messages were aggregated.
If the value is "size", all the messages were aggregated; if the value is "timeout", a timeout occurred, and not all expected message were aggregated.
The Aggregator has additional configuration options that you may need to use.
For example, you can specify how it should react when an arrived message contains an invalid correlation identifier.
The Aggregator is the most sophisticated EIP implemented in Camel, and table 8.5 lists the additional configuration options you can use to tweak it to fit your needs.
Table 8.5 Additional configuration options available for the Aggregator EIP.
Eager checking means Camel will check for completion conditions before aggregating.
If the option is false, the completion predicate will use the aggregated Exchange for evaluation.
This option uses an Integer parameter that represents a maximum bound for a least recently used (LRU) cache, which keeps track of closed correlation keys.
Note that this cache is inmemory only and will be reset if Camel is restarted.
You can run test examples using the following Maven goals:
In the next section, we’ll look at solving the problems with persistence.
The Aggregator, by default, uses an in-memory repository to hold the current in-progress aggregated messages, and those messages will be lost if the application is stopped or the server crashes.
To remedy this, you need to use a persisted repository.
The Aggregator is a stateful EIP because it needs to store the in-progress aggregates until completion conditions occur and the aggregated message can be published.
By default, the Aggregator will keep state in memory only.
If the application is shut down or the host container crashes, the state will be lost.
To remedy this problem, you need to store the state in a persistent repository.
Camel provides a pluggable feature so you can use a repository of your choice.
You can suppress this by setting this option to true, in which case Camel skips the invalid message.
Table 8.5 Additional configuration options available for the Aggregator EIP (continued)
We’ll look at how you can use HawtDB as a persistent repository.
To demonstrate how to use HawtDB with the Aggregator, we’ll return to the ABC example.
First, though, you must set up HawtDB, which is done as follows:
The repository name must be specified because you can have multiple repositories in the same file.
About HawtDB HawtDB is a lightweight and embeddable file-based key/value database.
It allows Camel to provide persistence for various Camel features, such as the Aggregator.
The name for the repository and the filename are configured as properties on the bean tag.
To demonstrate how the persistence store works, the example will start up and run for 20 seconds.
In that time, you can copy files in the target/inbox directory and have those files consumed and aggregated.
On every third file, the Aggregator will complete and publish a message.
The example will display instructions on the console about how to do this:
Sleeping for 20 seconds You can let the test terminate (or press ctrl + c) and then start it again Which should let you be able to resume.
For example, if you copy the first two files and then let the example terminate, you’ll see the following:
The console should indicate that it consumed two files and was shut down:
The next time you start the example, you can resume where you left off, and copy the last file:
Notice how it logs on startup how many exchanges are in the persistent repository.
In this example there is one existing Exchange on startup.
Let’s move on to look at using recovery with the Aggregator, which ensures that published messages can be safely recovered and be routed in a transactional way.
The examples covered in the previous section focused on ensuring that messages are persisted during aggregation.
But there’s another place where messages may be lost: messages that have been published (send out) from the Aggregator, could potentially fail during routing as well.
To remedy this problem you could use one of these two approaches:
Camel error handlers (covered in chapter 5)—these provide redelivery and dead letter channel capabilities.
Camel error handlers aren’t tightly coupled with the Aggregator, so message handling is in the hands of the error handler.
If a message repeatedly fails, the error handler can only deal with this by retrying or eventually giving up and moving the message to a dead letter channel.
It ensures published messages that fail will be recovered and redelivered.
You can think of this as what a JMS broker, such as Apache ActiveMQ, can do by bumping failed messages back up on the JMS queue for redelivery.
To better understand how recovery works, we’ve provided the following two figures.
Figure 8.4 shows what happens when an aggregated message is being published for.
This could also be the situation when a server crashes while processing the message.
Figure 8.4 An aggregated message is completed B, it’s published from the Aggregator C, and processing fails D, so the message is rolled back.
The message is then routed in Camel—but suppose it fails during routing D.
Now imagine the same message is recovered and redelivered, as shown in figure 8.5
The Aggregator uses a background task, which runs every 5 seconds, to scan for.
Any such messages will be republished C, and the message will be routed again.
This time, the message could be processed successfully, which lets the Aggregator issue a commit D.
The repository confirms E the message, ensuring it won’t be recovered on subsequent scans.
The transactional behavior is based on HawtDB’s own transaction mechanism.
The example is constructed to fail when processing the published messages, no matter what.
This means that eventually you’ll have to move the message to a dead letter channel.
Figure 8.5 The Aggregator recovers B failed messages, which are published again C, and this time the messages completed D successfully E.
In Spring XML, you can set this up as a spring <bean> tag, as follows:
The options may make sense as you read them now, but we’ll revisit them in table 8.7
In this example, the Aggregator will check for messages to be recovered every 3 seconds.
This means that after 4 failed recovery attempts, the message is exhausted and is moved to the dead letter channel.
If you omit the maximum redeliveries option, Camel will keep recovering failed messages forever until they can be processed successfully.
If you run the example, you’ll notice that the console outputs the failures as stack traces, and at the end you’ll see a WARN entry that indicates the message has been moved to the dead letter channel:
We encourage you to try this example and read the code comments in the source code to better understand how this works.
The preceding log output identifies the number of redelivery attempts, but how does Camel know this? Obviously Camel stores this information on the Exchange.
The information in table 8.6 is only available when Camel performs a recovery.
It’s only when a recovery is triggered that these headers are set on the Exchange.
We won’t go into more detail regarding the options in table 8.7, as we’ve already covered an example using them.
This concludes our extensive coverage of the sophisticated and probably most complex EIP implemented in Camel—the Aggregator.
In the next section, we’ll look at the Splitter pattern.
Messages passing through an integration solution may consist of multiple elements, such as an order, which typically consists of more than a single line item.
Each line in the order may need to be handled differently, so you need an approach that processes the complete order, treating each line item individually.
The solution to this problem is the Splitter EIP, illustrated in figure 8.6
In this section, we’ll teach you all you need to know about the Splitter.
We’ll start with a simple example and move on from there.
Figure 8.6 The Splitter breaks out the incoming message into a series of individual messages.
Using the Splitter in Camel is straightforward, so let’s try a basic example that will split one message into three messages, each containing one of the letters A, B, and C.
Listing 8.4 shows the example using a Java DSL–based Camel route and a unit test.
The test method sets up a mock endpoint that expects three messages to arrive, in the order A, B, and C.
Then you construct a single combined message body that consists of a List of Strings containing the three letters.
The Camel route will use the Splitter EIP to split up the message body B.
If you run this test, the console should log the three messages, as follows:
When using the Splitter EIP in Spring XML, you have to do this a bit differently because the Splitter uses an Expression to return what is to be split.
In the Java DSL we defined the Expression shown in bold:
Here, body() is a method available on the RouteBuilder, which returns an org.apache.
In Spring XML you need to do this as shown in bold:
In Spring XML, you use the Camel’s expression language, known as Simple (discussed in appendix A), to tell the Splitter that it should split the message body.
The source code for the book contains this example in the chapter8/splitter directory.
To better understand how you can tell Camel what it should split, you need to understand how it works.
The Splitter works something like a big iterator that iterates through something and processes each entry.
The sequence diagram in figure 8.7 shows more details about how this big iterator works.
Figure 8.7 A sequence diagram showing how the Splitter works internally, by using an iterator to iterate through the message and process each entry.
When working with the Splitter, you have to configure an Expression, which is evaluated B when a message arrives.
Then the Splitter uses the iterator D until there is no more data.
Each message to be sent out of the iterator is a copy of the message E, which has had its message body replaced with the part from the iterator F.
In listing 8.4, there would be three parts: each of the letters A, B, and C.
The message to be sent out is then processed G, and when the processing is done, the message may be aggregated H (more about this in section 8.3.4)
The Splitter will decorate each message it sends out with properties on the Exchange, which are listed in table 8.8
You may find yourself in a situation where you need more power to do the splitting, such as to dictate exactly how a message should be split.
And what better power is there than Java? By using Java code, you have the ultimate control and can tackle any situation.
Suppose you need to split messages that contain complex payloads.
Suppose the message payload is a Customer object containing a list of Departments, and you want to split by Department, as illustrated in figure 8.8:
Integer The total number of messages the original message has been split into.
Note that this information isn’t available in streaming mode (see section 8.3.3 for more details about streaming)
Boolean Whether or not this is the last message being processed.
What can be iterated? When Camel creates the iterator C, it supports a range of types.
Camel knows how to iterate through the following types: Collection, Iterator, Array, org.w3c.
The Customer object is a simple bean containing the following information (getter and setter methods omitted):
You may wonder why you can’t split the message as in the previous example, using split(body())? The reason is that the message payload (the message body) isn’t a List, but a Customer object.
Therefore you need to tell Camel how to split, which you do as follows:
The splitDepartments method returns a List of Department objects, which is what you want to split by.
In the Java DSL, you can use the CustomerService bean for splitting by telling Camel to invoke the splitDepartments method.
This is done by using the method call expression as shown in bold:
In Spring XML, you’d have to declare the CustomerService in a Spring bean tag, as follows:
Figure 8.8 Splitting a complex message into submessages by department.
The source code for the book contains this example in the chapter8/splitter directory.
The logic in the splitDepartments method is simple, but it shows how you can use a method on a bean to do the splitting.
In your use cases, you may need more complex logic.
The Splitter will usually operate on messages that are loaded into memory.
But there are situations where the messages are so big that it’s not feasible to have the entire message in memory at once.
Rider Auto Parts has an ERP system that contains inventory information from all its suppliers.
To keep the inventory updated, each supplier must submit updates to Rider Auto Parts.
Some suppliers do this once a day using good old-fashioned files as a means of transport.
Those files could potentially be very large, so you have to split those files without loading the entire file into memory.
This can be done by using streams, which allow you to read on demand from a stream of data.
This resolves the memory issue, because you can read in a chunk of data, process the data, read in another chunk, process the data, and so on.
Figure 8.9 shows the flow of the application used by Auto Rider Parts to pick up the files from the suppliers and update the inventory.
Figure 8.9 A route that picks up incoming files, splits them, and transforms them so they’re ready for updating the inventory in the ERP system.
We’ll revisit this example again in chapter 10, and cover it in much greater detail when we cover concurrency.
Implementing the route outlined in figure 8.9 is easy to do in Camel, as follows.
As you can see in listing 8.5, all you have to do is enable streaming mode using .streaming() B.
This tells Camel to not load the entire payload into memory, but instead to iterate the payload in a streaming fashion.
Also notice the use of end() C to indicate the end of the splitting route.
The end() in the Java DSL is the equivalent of the end tag </split> when using Spring XML.
In Spring XML, you enable streaming using the streaming attribute on the <split> tag, as follows.
The tokenizer is a powerful feature that works well with streaming.
The Scanner is capable of iterating, which means that it only reads chunks of data into memory.
Listing 8.6 Splitting big files using streaming mode in Spring XML.
In the preceding code, you use a newline (\n) as the token.
So, in this example, the Scanner will only read the file into memory on a line-by-line basis, resulting in low memory consumption.
You can use the tokenizer or convert the message body to a type that can be iterated, such as an Iterator.
The Splitter EIP in Camel includes an aggregation feature that lets you recombine split messages into single outbound messages, while they are being routed.
Being able to split and aggregate messages again is a powerful mechanism.
You could use this to split an order into individual order lines, process them, and then recombine them into a single outgoing message.
This pattern is known as the Composed Message Processor, which we briefly touched on in section 8.1
The Camel Splitter provides a built-in aggregator, which makes it even easier to aggregate split messages back into single outgoing messages.
Figure 8.10 illustrates this principle, with the help of the “ABC” message example.
Suppose you want to translate each of the A, B, and C messages into a phrase, and have all the phrases combined into a single message again.
This can easily be done with the Splitter—all you need to provide is the logic that combines the messages.
Implementing the Camel route outlined in figure 8.10 can be done as follows in the Java DSL.
Figure 8.10 The Splitter has a built-in aggregator that can recombine split messages into a combined outgoing message.
As you can see from listing 8.7, you combine the messages into a single String body, with individual phrases (from the message bodies) being separated with + signs.
The source code for the book contains this example in the chapter8/splitter directory.
Listing 8.7 Combining split messages back into a single outgoing message.
The example uses the three phrases: “Aggregated Camel rocks”, “Hi mom”, and “Yes it works”
When you run the example, you’ll see the console output the aggregated message at the end.
Before we wrap up our coverage of the Splitter, let’s take a look at what happens if one of the split messages fails with an exception.
The Splitter processes messages and those messages can fail when some business logic throws an exception.
Camel’s error handling is active during the splitting, so the errors you have to deal with in the Splitter are errors that Camel’s error handling couldn’t handle.
You have two choices for handling errors with the Splitter:
Stop—The Splitter will split and process each message in sequence.
In this situation, you could either immediately stop and let the exception propagate back, or you could continue splitting the remainder of the messages, and let the exception propagate back at the end (default behavior)
The first solution requires you to configure the stopOnException option on the Splitter as follows:
In Spring XML, you use the stopOnException attribute on the <split> tag, as follows:
The source code for the book contains this example in the chapter8/splitter directory.
The preceding example ignores the exception by returning the oldExchange B.
If you want to propagate back the exception, you need to keep it stored on the aggregated exception, which can be done as follows.
As you can see, it requires a bit more work to keep the exception.
On the first invocation of the aggregate method, the oldExchange parameter is null and you simply return the newExchange (which has the exception)
Otherwise you must transfer the exception to the oldExchange B.
If you don’t propagate the exception back, the Splitter will assume you have handled the exception and will ignore it.
The source code for the book contains this example in the chapter8/splitter directory.
Now you’ve learned all there is to know about the Splitter.
We’ll revisit the Splitter in chapter 10 when we look at concurrency.
In the next two sections, we’ll look at EIPs that support dynamic routing, starting with the Routing Slip pattern.
There are times when you need to route messages dynamically.
For example, you may have an architecture that requires incoming messages to undergo a sequence of processing steps and business rule validations.
Because the steps and validations vary widely, you can implement each step as a separate filter.
The filter acts as a dynamic model to apply the business rule and validations.
This architecture could be implemented using the Pipes and Filters EIP together with the Filter EIP.
But as often happens with EIPs, there’s a better way, known as the Routing Slip EIP.
The Routing Slip acts as a dynamic router that dictates the next step a message should undergo.
Figure 8.11 The incoming message has a slip attached that specifies the sequence of the processing steps.
The Routing Slip EIP reads the slip and routes the message to the next endpoint in the list.
The Camel Routing Slip EIP requires a preexisting header or Expression as the attached slip.
Either way, the initial slip must be prepared before the message is sent to the Routing Slip EIP.
We’ll start with a simple example that shows how to use the Routing Slip EIP to perform the sequence outlined in figure 8.11
In the Java DSL, the route is as simple as this:
This example assumes the incoming message contains the slip in the header with the key "mySlip"
The following test method shows how you should fill out the key:
As you can see, the value of the key is the endpoint URIs separated by commas.
The comma is the default delimiter, but the routing slip supports using custom delimiters.
For example, to use a semicolon, you could do this:
This example expects a preexisting header containing the routing slip.
But what if the message doesn’t contain such a header? In those situations, you have to compute the header in any way you like.
In the next example, we look at how to compute the header using a bean.
To keep things simple, the logic to compute a header that contains two or three steps has been kept in a single method, as follows:
All you how to do now is leverage this bean to compute the header to be used as routing slip.
In the Java DSL, you can use the method call expression to invoke the bean and set the header:
In this example, you use a method call expression to set a header that is then used by the routing slip.
But you might want to skip the step of setting the header and instead use the expression directly.
Instead of setting a header, you can use an Expression, such as the method call expression we covered in the previous section.
Another way of using the Routing Slip EIP in Camel is to use beans and annotations.
The @RoutingSlip annotation allows you to turn a regular bean method into the Routing Slip EIP.
As you can see, all this does is annotate the slip method with @RoutingSlip.
When Camel invokes the slip method, it detects the @RoutingSlip annotation and continues routing according to the Routing Slip EIP.
By doing this, Camel will double up using Recipient List EIP, which is not the intention.
Notice that there’s no mention of the routing slip in the DSL.
Why might you want to use this? Well, by using @RoutingSlip on a bean, it becomes more flexible in the sense that the bean is accessible using a endpoint URI.
Any Camel client or route could easily send a message to the bean and have it continued being routed as a routing slip.
For example, using a ProducerTemplate you could send a message to the bean:
That "Camel rocks" message would then be routed as a routing slip with the slip generated as the result of the myBean method invocation.
In the previous section, you learned that the Routing Slip pattern acts as a dynamic router.
So what’s the difference between the Routing Slip and Dynamic Router EIPs? The difference is minimal: the Routing Slip needs to compute the slip up front, whereas the Dynamic Router will evaluate on-the-fly where the message should go next.
Just like the Routing Slip, the Dynamic Router requires you to provide logic, which determines where the message should be routed.
Such logic is easily implemented using Java code, and in this code you have total freedom to determine where the message should go next.
For example, you might query a database or a rules engine to compute where the message should go.
Listing 8.10 shows the Java bean used in the example.
The idea with the Dynamic Router is to let Camel keep invoking the route method until it indicates the end.
The first time the route method is invoked, the previous parameter will be null B.
On every subsequent invocation, the previous parameter contains the endpoint URI of the last step.
Listing 8.10 Java bean deciding where the message should be routed next.
As you can see in the whereToGo method, you use this fact and return different URIs depending on the previous step.
When the dynamic router is to end, you return null C.
The same route in Spring XML is just as easy as shown:
There is also a Dynamic Router annotation you can use.
To demonstrate how to use the @DynamicRouter annotation let’s change the previous example to use the annotation instead.
To do that, just annotate the Java code from listing 8.10 as follows:
The next step is to invoke the route method on the bean, as if it were a regular bean.
That means you should not use the Routing Slip EIP in the route, but use a bean instead.
In the next section, you’ll learn about Camel’s built-in Load Balancer EIP, which is useful when an existing load-balancing solution isn’t in place.
You may already be familiar with the load balancing concept in computing.
Load balancing is a technique to distribute workload across computers or other resources, “in order to get optimal resource utilization, maximize throughput, minimize response time, and avoid overload” (http://en.wikipedia.org/wiki/Load_balancer)
This service can be provided either in the form of a hardware device or as a piece of software, such as the Load Balancer EIP in Camel.
In this section, we’ll introduce the Load Balancer EIP by walking through an example.
Then, in section 8.6.2, we’ll look at the various types of load balancers Camel offers out of the box.
The LoadBalancer offers methods to add and remove Processors that should participate in the load balancing.
By using Processors instead of Endpoints, the load balancer is capable of balancing anything you can define in your Camel routes.
But, that said, you’ll most often balance across a number of remote services.
Such an example is illustrated in figure 8.12, where a Camel application needs to load balance across two services.
When using the Load Balancer EIP, you have to select a balancing strategy.
A common and understandable strategy is to take turns among the services—this is known as the round robin strategy.
In section 8.6.2, we’ll take a look at all the strategies Camel provides out of the box.
Let’s look at how you can use the Load Balancer with the round robin strategy.
In this example, you use the SEDA component to simulate the remote services.
In a real-life situation, the remote services could be a web service.
The first message would be sent to the "seda:a" endpoint, and the next would go to "seda:b"
The third message would start over and be sent to "seda:a", and so forth.
Figure 8.12 A Camel application load balances across two services.
You can try it by using the following Maven goals:
If you run the example, the console will output something like this:
In the next section, we’ll review the various load-balancing strategies you can use with the Load Balancer EIP.
A load-balancing strategy dictates which Processor should process an incoming message—it’s up to each strategy how the Processor is chosen.
Camel allows the six different strategies listed in table 8.9
The first four strategies in table 8.9 are easy to set up and use in Camel.
For example, using the random strategy is just a matter of specifying it in the Java DSL:
Round robin Chooses a processor in a round robin fashion, which spreads the load evenly.
Sticky Uses an expression to calculate a correlation key that dictates the processor chosen.
You can think of this as the session ID used in HTTP requests.
The sticky strategy requires you provide a correlation expression, which is used to calculate a hashed value to indicate which processor should be used.
By using the sticky strategy, you can have messages with the same level chose the same processor over and over again.
In the Java DSL, you would provide the expression using a header expression as shown here:
To try the random, sticky, or topic strategies, use the following Maven goals:
The failover strategy is a more elaborate strategy, which we’ll cover next.
Load balancing is often used to implement failover—the continuation of a service after a failure.
The Camel failover load balancer detects the failure when an exception occurs and reacts by letting the next processor take over processing the message.
Given the following route snippet, the failover will always start by sending the messages to the first processor ("direct:a") and only in the case of a failure will it let the next processor ("direct:b") take over.
If you run the example, it will send in four messages.
The second message will failover and be processed by the "direct:b" processor.
The other three messages will be processed successfully by "direct:a"
In this example, the failover load balancer will react to any kind of exception being thrown, but you can provide it with a number of exceptions to react to.
Suppose you only want to failover if an IOException is thrown (which indicates communication errors with remote services, such as no connection)
This is easy to configure, as shown in the Java DSL:
In this example, only one exception is specified, but you can specify multiple exceptions, as follows:
You may have noticed in the failover examples that it always chooses the first processor, and sends the failover to subsequent processors.
You can think of this as the first processor being the master, and the others slaves.
But the failover load balancer also offers a strategy that combines round robin with failure support.
The Camel failover load balancer in round robin mode gives you the best of both worlds; it distributes the load evenly between the services, and it provides automatic failover.
In this scenario, you have three configuration options on the load balancer to dictate how it operates, as listed in table 8.10
To better understand the options in table 8.10 and how the round robin mode works, we’ll start with a fairly simple example.
In the Java DSL, you have to configure failover with all the options in bold:
If both attempts fail, Camel will propagate the exception back to the caller.
Specifies how many failover attempts to try before exhausting (giving up):
When enabled, the load balancer will let the error handler be involved.
If disabled, the load balancer will failover immediately if an exception is thrown.
The second parameter is set to false, which means it isn’t inheriting Camel’s error handling.
This allows the failover load balancer to failover immediately when an exception occurs, instead of having to wait for the Camel error handler to give up first.
The last parameter indicates that it’s using the round robin mode.
In Spring XML, you configure the options as attributes on the failover tag:
The next section explains how to implement and use your own custom strategy, which you may want to do when you need to use special load-balancing logic.
Custom load balancers allow you to be in full control of the balancing strategy in use.
For example, you could build a strategy that acquires load statistics from various services and picks the service with the lowest load.
Suppose you want to implement a priority-based strategy that sends gold messages to a certain processor and the remainder to a secondary destination.
Listing 8.11 shows how you can implement a custom load balancer.
In the process() method, you invoke the chooseProcessor() method, which is the strategy that picks the processor to process the message.
In this example, it will pick the first processor if the message is a gold type, and the second processor if not.
In the Java DSL, you use a custom load balancer as shown in bold:
In Spring XML, you need to declare a Spring bean tag:
We’ve now covered the Load Balancer EIP in Camel, which brings us to the end of our long journey to visit five great EIPs implemented in Camel.
Since the arrival of the Enterprise Integration Patterns book on the scene, we have had a common vocabulary, graphical notation, and concepts for designing applications to tackle today’s integration challenges.
In chapter 2 we reviewed the most common patterns, and this chapter reviews five of the most complex and sophisticated patterns in great detail.
You may view the EIP book as the theory and Camel as the software implementation of the book.
Here are some EIP best practices to take away from this chapter:
Take the time to study the EIPs, especially the common patterns we covered in chapter 2 and those we presented in this chapter.
Consider getting the EIP book to read more about the patterns—there’s great advice given in the book.
The patterns are universal and the knowledge you gain when using EIPs with Camel is something you can take with you.
If you have a problem you don’t know how to resolve, there’s a good chance others have scratched that itch before.
Consult the EIP book and the online Camel patterns catalog: http://camel.apache.org/enterpriseintegration-patterns.html.
When learning to use an EIP, you should create a simple test to try out the pattern and learn how to use it.
Having too many new moving parts in a Camel route can clutter your view and make it difficult to understand what’s happening and maybe why it doesn’t do what you expected.
If you’re going to use any of the five EIPs covered in this chapter, we recommend you reread the relevant parts of the chapter.
These patterns are very sophisticated and have many features and options to tweak.
The Transactional Client EIP is useful for controlling transactions, and it’s the topic of the next chapter.
With Camel’s core concepts under your belt, you may feel like you can tackle any integration problem with Camel.
In this final part of the book, we’ll cover the topics that are useful when you know the core concepts and want to build something for the real world.
One concept you’ll encounter in many real-world applications is transactions.
In chapter 9, we’ll explain how to use Spring’s transaction framework to let Camel routes participate in transactions.
In chapter 10, we’ll discuss the important, and sometimes complex, topic of concurrency.
We’ll also cover how you can improve the scalability of your Camel applications.
In this chapter, we’ll show you how to create new Camel projects, which could be Camel applications, custom components, or interceptors.
Once your application is running in the wild, you’ll need to know how to manage it and monitor its operations.
Chapter 12 discusses topics in this category ranging from viewing the Camel logs to controlling Camel with JMX, to extending the notification mechanism in Camel so it works with your own custom monitoring application.
A topic you’ll need to read about before your Camel application is in production is deployment.
Camel was designed as a framework, and, as such, it has virtually unlimited deployment possibilities.
In chapter 13, we’ll discuss some of the most popular deployment options for Camel.
We’ll also cover the various ways you can start and stop Camel.
In the last chapter of the book, chapter 14, we cover what we consider "extra features" of Camel: routing with beans and using remoting to hide Camel APIs.
We think of these as extra features because they perform routing without using any of Camel’s DSLs and, in some cases, without any Camel APIs at all.
They use a quite different approach than what has been discussed throughout the book.
To help explain what transactions are, let’s look at an example from real life.
You may well have ordered this book from Manning’s online bookstore, and if you did, you likely followed these steps:
What seems like an everyday scenario is actually a fairly complex series of events.
You have to put books in the basket before you can check out; you must fill in the shipping and credit card details before you can confirm the purchase; if your credit card is declined, the purchase won’t be confirmed; and so on.
The ultimate resolution of this transaction is either of two states: either the purchase was accepted and confirmed, or the purchase was declined, leaving your credit card balance uncharged.
This particular story involves computer systems because it’s about using an online bookstore, but the same main points happen when you shop in the supermarket.
Either you leave the supermarket with your groceries or without.
In the software world, transactions are often explained in the context of SQL statements manipulating database tables—updating or inserting data.
While the transaction is in progress, a system failure could occur, and that would leave the transaction’s participants in an inconsistent state.
That’s why the series of events is described as atomic: either they all are completed or they all fail—it’s all or nothing.
If you aren’t familiar with ACID, the Wikipedia page is a good place to start learning about it: http://en.wikipedia.org/wiki/ACID.
In this chapter, we’ll first look at the reasons why you should use transactions (in the context of Rider Auto Parts)
Then we’ll look at transactions in more detail and at Spring’s transaction management, which orchestrates the transactions.
You’ll learn about the difference between local and global transactions and how to configure and use transactions.
Toward the end of the chapter, you’ll see how to compensate for when you’re using resources that don’t support transactions.
But before we focus on using transactions with Camel, let’s look at what can go wrong when you don’t use transactions.
In this section, we’ll review an application Rider Auto Parts uses to collect metrics that will be published to an incident management system.
We’ll see what goes wrong when the application doesn’t use transactions, and then we’ll apply transactions to the application.
Lately Rider Auto Parts has had a dispute with a partner about whether or not their service meets the terms of the service level agreement (SLA)
When such incidents occur, it’s often a labor-intensive task to investigate and remedy the incident.
In light of this, Rider Auto Parts has developed an application to record what happens, as evidence for when a dispute comes up.
Why use transactions? the communication between Rider Auto Parts and its external partner servers.
The application records performance and uptime metrics, which are sent to a JMS queue, where the data awaits further processing.
Rider Auto Parts already has an existing incident management application with a web user interface for upper management.
What’s missing is an application to populate the collected metrics to the database used by the incident management application.
It’s a fairly simple task: a JMS consumer listens for new messages on the JMS queue B.
Then the data is transformed from XML to SQL C before it’s written to the database D.
In no time, you can come up with a route that matches figure 9.1:
The reports are sent to the JMS queue in a simple in-house XML format, like this:
The database table that stores the data is also mapped easily because it has the following layout:
That leaves you with the fairly simple task of mapping the XML to the database.
Because you’re pragmatic and want to make a simple and elegant solution that anybody should be capable of maintaining in the future, you decide not to bring in the.
Figure 9.1 Partner reports are received from the JMS broker, transformed in Camel to SQL format, and then written to the database.
You put the following mapping code in a good old-fashioned bean.
The code speaks for itself, but let’s go over it anyway.
First you define the method to accept the four values to be mapped.
Notice that you use the @XPath annotation to grab the data from the XML document B.
Then you use a StringBuilder to construct the SQL INSERT statement with the input values C.
To test this, you can crank up a unit test as follows:
Then you construct sample XML data and send it to the JMS queue using the Camel ProducerTemplate.
Because the processing of the JMS message is asynchronous, you must wait a bit to let it process.
At the end, you check that the database contains one row C.
Listing 9.1 Using a bean to map from XML to SQL.
To run this unit test, you need to use a local JMS broker and a database.
You can use Apache ActiveMQ as the JMS broker and HSQLDB (HyperSQL Database) as the database.
Apache ActiveMQ is an extremely versatile broker, and it’s even embeddable in unit tests.
All you have to do is master a bit of Spring XML magic to set up the JMS broker and the database.
Then, to allow Camel to connect to ActiveMQ, you must define it as a Camel component B.
Listing 9.2 XML configuration for the Camel route, JMS broker, and database.
Then you set up a local embedded ActiveMQ broker C, which is configured to use TCP connectors.
In the source code, you’ll also see how we prepared the database by creating the table and dropping it after testing.
The previous test is testing a positive situation, but what happens if the connection to the database fails.
Chapter 6 covered how to simulate a connection failure using Camel interceptors.
Writing a unit test is just a matter of putting all that logic in a single method, as shown in listing 9.3
Listing 9.3 Simulating a connection failure that causes lost messages.
Using VM instead of TCP with an embedded ActiveMQ broker If you use an embedded ActiveMQ broker, you can use the VM protocol instead of TCP; doing so bypasses the entire TCP stack and is much faster.
Actually, the localhost in vm://localhost is the broker name, not a network address.
A plausible reason why you’re using vm://localhost in listing 9.2 is that the engineers are lazy, and they changed the protocol from TCP to VM but left the broker name as localhost.
To test a failed connection to the database, you need to intercept the routing to the database and simulate the error.
You do this with the RouteBuilder, where you define this scenario B.
Next you need to add the interceptor with the existing route C, which is done using the adviceWith method.
The remainder of the code is almost identical to the previous test, but you test that no rows are added to the database D.
But what happened to the message you sent to the JMS queue? It was not stored in the database, so where did it go?
It turns out that the message is lost because you’re not using transactions.
By default, the JMS consumer uses auto-acknowledge mode, which means the client acknowledges the message when it’s received, and the message is dequeued from the JMS broker.
What you must do instead is use transacted acknowledge mode.
We’ll look at how to do this in section 9.3, but first we’ll discuss how transactions work in Camel.
The start of a transaction is often named begin, and the end is commit (or rollback if the transaction isn’t successfully completed)
To demonstrate the sequence in figure 9.2, you could write what are known as locally managed transactions, where the transaction is managed manually in the code.
The following code illustrates this; it’s based on using JPA-managed transactions.
Figure 9.2 A transaction is a series of events between begin and commit.
Then you have a series of events to do whatever work needs to be done.
At the end, you either commit or roll back the transaction, depending on whether an exception was thrown or not.
You may already be familiar with this principle, and transactions in Camel use the same principle at a higher level of abstraction.
In Camel transactions, you don’t invoke begin and commit methods from Java code—you use declarative transactions, which are configured in the Spring XML file.
We’ll look at the details of how this works in the next section, so don’t worry if it’s still a bit unclear.
What are the benefits of defining transactions declaratively? With Spring’s approach, you configure all this in the Spring XML regardless of which runtime environment you’re using.
This removes the need for changing Java code to match the targeted environment.
Spring also makes it easy to set up diverse environments using minimal configuration.
Spring’s transaction support is a great piece of technology, and that’s why Camel leverages it instead of rolling out it’s own transaction framework.
Now that we’ve established that Camel works with Spring’s transaction support, let’s look at how they work together.
To understand how Camel works together with Spring’s transaction support, take a look at figure 9.3
This figure shows that Spring orchestrates the transaction while Camel takes care of the rest.
Figure 9.4 adds more details, to illustrate that the JMS broker also plays an active part in the transaction.
Figure 9.3 Spring’s TransactionManager orchestrates the transaction by issuing begins and commits.
The entire Camel route is transacted, and the transaction is handled by Spring.
It’s now time to see how this works in practice.
In the next section, we’ll fix the lostmessage problem by adding transactions.
At the end of section 9.1, you left Rider Auto Parts with the problem of losing messages because you did not use transactions.
Your task now is to apply transactions, which should remedy the problem.
You’ll start by introducing Spring transactions to the Spring XML file and adjusting the configuration accordingly.
The first thing you do is turn on transacted for the ActiveMQ component B, which instructs it to use transacted acknowledge mode.
The transaction manager needs to know how to connect to the JMS broker, which refers to the connection factory.
So far you’ve only reconfigured beans in the Spring XML file, which is mandatory when using Spring.
In Camel, itself, you have not yet configured anything in relation to transactions.
When you specify <transacted/> in a route, Camel uses transactions for that particular route.
Under the hood, Camel looks up the Spring transaction manager and leverages it.
Using transacted in the Java DSL is just as easy, as shown here:
The convention over configuration only applies when you have a single Spring transaction manager configured.
In more complex scenarios, with multiple transaction managers, you have to do additional configuration to set up transactions.
This isn’t enforced in the DSL because the DSL is loosely defined to make it easy to maintain and develop Camel.
In this example, all you had to do to configure Camel was to add <transacted/> in the route.
You relied on the transactional default configurations, which greatly reduces the effort required to set up the various bits.
Let’s see if this configuration is correct by testing it.
When you test Camel routes using transactions, it’s common to test with live resources, such as a real JMS broker and a database.
For example, the source code for this book uses Apache ActiveMQ and HSQLDB as live resources.
We picked these because they can be easily downloaded using Apache Maven and they’re lightweight and embeddable, which makes them perfect for unit testing.
To demonstrate how this works, we’ll return to the Rider Auto Parts example.
Last time you ran a unit test, you lost the message when there was no connection to the database.
Let’s try that unit test again, but this time with transactional support.
When you run the unit test, you’ll notice a lot of stacktraces printed on the console, and they’ll contain the following snippet:
It will roll back the transaction if an exception is thrown.
So where is the message now? It should be on the JMS queue, so let’s add a little code to the unit test to check that.
Add the following code at the end of the unit test method in listing 9.3
Now you can run the unit test to ensure that the message wasn’t lost—and the unit test will fail with this assertion error:
We’re using transactions, and they’ve been configured correctly, but the message is still being lost.
What’s wrong? If you dig into the stacktraces, you’ll discover that the message is always redelivered six times, and then no further redelivery is conducted.
Among other things, this book explains how to use transactions and redelivery in more detail.
What happens is that ActiveMQ performs the redelivery according to its default settings, which say it will redeliver at most six times before giving up and moving the message to a dead letter queue.
ActiveMQ implements this pattern, which ensures that the broker won’t be doomed by a poison message that can’t be successfully processed and that would cause arriving messages to stack up on the queue.
Instead of looking for the message on the partner’s queue, you should look for the message in the default ActiveMQ dead letter queue, which is named ActiveMQ.DLQ.
If you change the code accordingly (as shown in bold), the test will pass:
You need to do one additional test to cover the situation where the connection to the database only fails at first, but works on subsequent calls.
You do this by relying on the fact that any message consumed from a JMS destination has a set of standard JMS headers, and the JMSRedelivered header is a Boolean type indicating whether the JMS message is being redelivered or not.
The interceptor logic is done in a Camel RouteBuilder, so you have the full DSL at your disposal.
You use the Content-Based Router EIP B to test the JMSRedelivered header and only throw the exception if it’s false, which means it’s the first delivery.
The rest of the unit test should verify correct behavior, so you first check that the database is empty before sending the message to the JMS queue.
Then you sleep a bit to let the routing complete.
After completion, you check that the database has one row.
Because you previously were tricked by the JMS broker’s dead letter queue, you also check that it’s empty C.
The example we’ve just covered uses what are called local transactions, because they’re based on using only a single resource in the transaction—Spring was only orchestrating the JMS broker.
But there was also the database resource, which, in the example, was not under transactional control.
Leveraging both the JMS broker and the database as resources participating in the same transaction requires more work, and the next section explains about using single and multiple resources in a transaction.
Listing 9.5 Testing a simulated rollback on the first try and a commit on the second try.
The Transactional Client EIP distills the problem of how a client can control transactions when working with messaging.
Figure 9.5 shows how this pattern was portrayed in Gregor Hohpe and Bobby Woolf’s Enterprise Integration Patterns book, so it may be a bit difficult to understand how it relates to using transactions with Camel.
What the figure shows is that both a sender and a receiver can be transactional by working together.
When a receiver initiates the transaction, the message is neither sent nor removed from the queue until the transaction is committed.
When a sender initiates the transaction, the message isn’t available to the consumer until the transaction has been committed.
Figure 9.5 A transactional client handles the client’s session with the receivers so the client can specify transaction boundaries that encompass the receiver.
Figure 9.6 A message is being moved from queue A to queue B.
Transactions ensure the message is moved in what appears to be an atomic operation.
The top section of figure 9.6 illustrates the route using EIP icons, with a message being moved from queue A to B using a transaction.
The remainder of the figure shows a use case when one message is being moved.
The middle section shows a snapshot in time when the message is being moved.
The message still resides in queue A and has not yet arrived in queue B.
The message stays on queue A until a commit is issued, which ensures that the message isn’t lost in case of a severe failure.
The bottom section shows the situation when a commit has been issued.
The message is then deleted from queue A and inserted into queue B.
Transactional clients make this whole process appear as an atomic, isolated, and consistent operation.
When talking about transactions, we need to distinguish between single- and multiple-resource transactions.
The former are also known as local transactions and the latter as global transactions.
In the next two sections, we’ll look at these two flavors.
Figure 9.7 depicts the situation of using a single resource, which is the JMS broker.
In the Rider Auto Parts example in section 9.1, the database didn’t participate as a resource in the transaction, but the approach seemed to work anyway.
This scenario isn’t exactly equivalent to enrolling the database in the transaction, because it still has failure scenarios that could leave the system in an inconsistent state.
For example, the JMS broker could fail after the database is successfully updated, but before the JMS message is committed.
To be absolutely sure that both the JMS broker and the database are in sync in terms of the transaction, you must use the much heavier global transactions.
Using transactions with a single resource is appropriate when a single resource is involved.
But the situation changes dramatically when you need to span multiple resources in the same transaction, such as JMS and JDBC resources, as depicted in figure 9.8
Camel consumes a message from the queue, and a begin is issued B.
The message is processed, updating the database, and it completes successfully C.
Both the JMS broker and the database participate in the transaction.
In Java, JTA is an implementation of the XA standard protocol, which is a global transaction protocol.
To be able to leverage XA, the resource drivers must be XA-compliant, which some JDBC and most JMS drivers are.
This is one of the benefits of JAVA EE servers, which have JTA out of the box, unlike some lightweight alternatives, such as Apache Tomcat.
Using JTA outside a JAVA EE server takes some work to set up because you have to find and use a JTA transaction manager, such as one of these:
Then you need to figure out how to install and use it in your container and unit tests.
The good news is that using JTA with Camel and Spring is just a matter of configuration.
When using JTA (XA), there are a couple of differences from using local transactions.
The same applies for the JDBC driver—you need to use an XA-capable driver.
In a real production system, you should prefer to use a JDBC driver that’s XA-capable, because the simulation has a few drawbacks.
You can find out more about this at the Atomikos website listed previously.
It should refer to the real XA transaction manager, which is Atomikos in this example:
Suppose you want to add an additional step in the route shown in figure 9.8
You’ll process the message after it has been inserted into the database.
This additional step will influence the outcome of the transaction, whether or not it throws an exception.
Suppose it does indeed throw an exception, as portrayed in figure 9.9
Because this scenario uses global transactions, both the database and the JMS broker will roll back, and the final result is as if the entire transaction hadn’t taken place.
The source code for the book contains this example in the chapter9/xa directory.
We’ll leave the topic of global transactions here and move on to learn more about configuring and using transactions.
So far, we’ve used convention over configuration when configuring transactions in Camel, by just adding <transacted/> to the route.
This is often all you’ll need to use, but there can be situations where you need more fine-grained control, such as when specifying transaction propagation settings.
That’s the first thing we’ll look at in this section.
Then we’ll look at how transactions work when multiple routes are used.
At the end of the section, we’ll look at how you can return custom responses to the caller when a transaction fails.
When you configure transactions, you’ll come across the term transaction propagation.
In this section, you’ll learn what that term means and why it’s related to configuring transactions.
If you have ever worked with Enterprise JavaBeans (EJBs), you may be familiar with transaction propagation already.
Transaction propagation options specify what will happen if a method is invoked and a transaction context already exists.
For example, should it join the existing transaction? Should a new transaction be started? Or should it fail?
To use transaction propagation, you must configure it in the Spring XML file as shown in the following example.
The bean must refer to both the transaction manager and the choice of transaction propagation to be used.
In the Camel route, you then refer to the required bean from within the <transacted> tag, using the ref attribute C.
If you have ever used Spring transactions, you may have named beans with the transaction propagation type directly, like this:
There is no practical difference between these two styles—it’s a matter of taste as to which you prefer.
This is because Camel uses convention over configuration to detect whether the bean id matches any of the known propagation behavior names.
Let’s look at what else is specified by convention over configuration.
In section 9.2, you used the default transaction configuration, which relies on convention over configuration.
This works well when you want to use the required transaction propagation, because it removes the need for some boilerplate configuration.
The first example from section 9.2.2 could be reduced to only the Camel route, as follows:
All you do here is declare <transacted/> in the Camel route, and Camel takes it from there.
Usually all you have to do is configure the Spring transaction manager and add <transacted/> in the Camel route.
You have now learned how to configure and use transactions with Camel.
In the next section, we’ll look at how transactions work when you have multiple routes and when you need different propagation behavior.
In Camel, it’s common to have multiple routes and to let one route reuse another by sending messages to it.
In this section, we’ll look at how this works when one or all routes are transacted.
Then we’ll look at some of the implications of using transactions with request-response messaging style.
We’ll start out simply and look at what happens when you use a non-transacted route from a transacted route.
Listing 9.6 shows the parts of a unit test that you can use to see what happens when a transacted route calls a non-transacted route.
In listing 9.6, you first import the Spring XML file, which contains all the Spring configuration to set up the JMS broker, Spring, and the Camel ActiveMQ component.
Listing 9.6 Unit test with a transacted route calling a non-transacted route.
First, the transacted route B moves messages from queue A to B.
During this move, the message is also processed by the non-transacted route C, which transforms the message using a content-based router.
Notice that if the message contains the word "Donkey", the route will force a failure by throwing an exception.
You can run this unit test by running the following Maven goal from the chapter9/ multuple-routes directory:
The unit test has three methods: two test situations that commit the transaction, and one rolls back the transaction because of the exception being thrown.
Here are two tests showing the commit and rollback situations:
What can you learn from this? The unit test proves that when a transacted route uses a non-transacted route, the transactional behavior works as if all routes are transacted, which is what you’d expect.
The last unit test proves that when the non-transacted route fails by throwing an exception, the transacted route detected this and issued a rollback.
You can see this because the message is moved to the JMS broker’s dead letter queue.
It’s safe for transacted routes to reuse existing non-transacted routes.
This means that when you use multiple routes, you must link them together in a way that ensures the message is processed in the same thread.
Using the Direct component does this—the Direct component was used in listing 9.6 to link the two routes together.
This won’t work with the SEDA component, which routes messages using another thread.
Let’s continue and see what happens when both routes are transacted.
Now let’s modify the unit test from listing 9.6 and create a new situation, where both routes are transacted, and see what happens.
You can run this example by running the following Maven goal:
Once again, the unit test will prove that there are no surprises here.
When the exception is thrown, the entire route is rolled back, which is what you’d expect.
When the message hits the second route and the second transacted, it participates in the existing transaction.
Next, we’ll make it more challenging by using two different transaction propagations.
In some situations, you may need to use multiple transactions with the same exchange, as illustrated in figure 9.10
In figure 9.10 an exchange is being routed in Camel.
It starts off using the required transaction, and then you need to use another transaction that’s independent of the existing transaction.
Figure 9.10 Using two independent transactions in a single exchange.
When the exchange completes, the transaction manager will issue commits to these two transactions, which ensures that they both commit at the same point.
In Camel, a route can only be configured to use at most one transaction propagation, which means figure 9.10 must use two routes.
Suppose you have an application that updates orders in a database.
The application must store all incoming orders in an audit log, and then it either updates or inserts the order in the order database.
The audit log should always insert a record, even if subsequent processing of the order fails.
Implementing this in Camel should be done using two routes, as follows:
Now suppose an error occurs while processing the second route—you could either let both routes roll back, or only roll back the second route.
Camel will, by default, roll back both routes, and because you only want the second route to roll back, you have to tell Camel this.
In the next section, we’ll return to Rider Auto Parts and look at an example that covers a common use case: using web services together with transactions.
How do you return a custom web service response if a transaction fails?
Rider Auto Parts has a Camel application that exposes a web service to a selected number of business partners.
As you can see in the figure, the business partners invoke a web service to submit an order B.
The received order is stored in a database for audit purposes C.
Configuring and using transactions order is then processed by the enterprise resource planning (ERP) system D, and a reply is returned to the waiting business partner E.
The web service is deliberately kept simple so partners can easily leverage it with their IT systems.
There is a single return code that indicates whether or not the order succeeded or failed.
The following code snippet is part of the WSDL definition for the reply (outputOrder):
The code field should contain "OK" if the order was accepted; any other value is considered a failure.
This means that the Camel application must deal with any thrown exceptions and return a custom failure message, instead of propagating the thrown exception back to the web service.
Your Camel application needs to do the following three things:
What you do is add an onException to the CamelContext, as shown here:
You first tell Camel that this onException should trigger for any kind of exception that’s thrown.
You then mark the exception as handled, which removes the exception.
Figure 9.11 A web service used by business partners to submit orders.
A copy of the order is stored in a database before it’s processed by the ERP system.
That means you must have prepared the reply message before you issue the <rollback/>
To construct the reply message, you use the order bean, invoking its replyError method:
You first define the replyError method to have an Exception as a parameter—this will contain the thrown exception.
You then create the OutputOrder object, which you populate with the "ERROR" text and the exception message.
You can start the application by using the following Maven goal:
To work with this example, you need to use web services.
Then you create a sample web service request and fill in the request parameters, as shown in figure 9.12
You then send the request by clicking the green play button, and it will display the reply in the pane on the right side.
Figure 9.12 shows an example where we caused a failure to occur.
Our example behaves according to what you specify in the refNo field.
You can force different behavior by specifying either FATAL or FAIL-ONCE in the refNo field.
Figure 9.12 A web service message causes the transaction to roll back, and a custom reply message is returned.
Compensating for unsupported transactions will cause the request to succeed.
As figure 9.12 shows, we entered FATAL, which causes an exception to occur and an ERROR reply to be returned.
So far we’ve been using resources that support transactions, such as JMS and JDBC, but the majority of components don’t support transactions.
So what can you do instead? In the next section, we’ll look at compensating when transactions aren’t supported.
The number of resources that can participate in transactions is limited—they’re mostly confined to JMS- and JDBC-based resources.
This section covers what you can do to compensate for the absence of transactional support in other resources.
First, we’ll look at how a unit of work is represented in Camel and how you can use this concept.
Then we’ll walk through an example demonstrating how the unit of work can help simulate the orchestration that a transaction manager does.
We’ll also discuss how you can use a unit of work to compensate for the lack of transactions by doing the work that a transaction manager’s rollback would do in the case of failure.
The concept of the unit of work is to batch together a group of tasks as a single coherent unit.
The idea is to use the unit of work as a way of mimicking transactional boundaries.
The done method is invoked when the unit of work is complete, and it invokes the registered callbacks.
The Synchronization callback is the interesting part for Camel end users because it’s the interface you use to execute custom logic when an exchange is complete.
When the exchange is done, either the onComplete or onFailure method is invoked, depending on whether the exchange failed or not.
Figure 9.13 illustrates how these concepts are related to each other.
As you can see from this figure, each Exchange has exactly one UnitOfWork, which you can access using the getUnitOfWork method from the Exchange.
The UnitOfWork is private to the Exchange and is not shared with others.
When an Exchange is done being routed, you hit the end boundary of the UnitOfWork, and the registered Synchronization callbacks are invoked one by one.
This is the same mechanism the Camel components leverage to add their custom Synchronization callbacks to the Exchange.
For example, the File and FTP components use this mechanism to perform after-processing operations such as moving or deleting processed files.
This ensures that all callbacks are invoked even if one happens to fail.
A good way of understanding how this works is to review an example, which we’ll do now.
Rider Auto Parts has a Camel application that sends email messages containing invoice details to customers.
First, the email content is generated, and then, before the email is sent, a backup of the email is stored in a file for reference.
Whenever an invoice is to be sent to a customer, the Camel application is involved.
Imagine what would happen if there were a problem sending an email.
You can’t use transactions to roll back, because filesystem resources can’t participate in transactions.
Instead, you can perform custom logic, which compensates for the failure by deleting the file.
Figure 9.13 An Exchange has one UnitOfWork, which in turn has from zero to many Synchronizations.
How UnitOfWork is orchestrated Camel will automatically inject a new UnitOfWork into an Exchange when it’s routed.
When the Exchange is done, this processor invokes the registered Synchronization callbacks.
The UnitOfWork boundaries are always at the beginning and end of Camel routes.
The compensation logic is trivial to implement, as shown here:
What you must do next is instruct Camel to use the FileRollback class to perform this compensation.
To do so, you can add it to the UnitOfWork by using the addSynchronization method, which was depicted in figure 9.13
This can be done using the Java DSL as highlighted:
The source code for the book contains this example in the chapter9/uow directory.
You can try it by using the following Maven goal:
If you run the example, it will output something like the following to the console:
Figure 9.14 Emails are sent to customers listing their invoice details.
Before the email is sent, a backup is stored in the file system.
One thing that may bother you is that you must use an inlined Processor to add the FileRollback class as a Synchronization.
Camel offers a convenient method on the Exchange, so you could do it with less code:
Isn’t there a more convenient way? Yes there is, and that’s where onCompletion comes into the picture.
OnCompletion takes the Synchronization into the world of routing, enabling you to easily add the FileRollback class as Synchronization.
As you can see from the code, <onCompletion> is defined as a separate Camel route.
It will be executed right after the regular route has completed.
You’re only interested in executing onCompletion when the exchange fails, so you can specify this by setting the onFailureOnly attribute to true.
The source code for the book contains this example, which you can run using the following Maven goal:
When you run it, you’ll find that it acts just like the previous example.
It will delete the backup file if the exchange fails.
OnCompletion can also be used in situations where the exchange did not fail.
Suppose you want to log activity about exchanges being processed.
For example, in the Java DSL you could do it as follows:
OnCompletion also supports scoping, exactly the same onException does at either context or route scope (as you saw in chapter 5)
You could create a Java DSL–based version of listing 9.8 using route-scoped onCompletion as follows:
Now you’ve learned all there is to know about onCompletion, which brings us to the end of this chapter.
Transactions play a crucial role when grouping distinct events together so that they act as a single, coherent, atomic event.
In this chapter, we looked at how transactions work in Camel and discovered that Camel lets Spring orchestrate and manage transactions.
By leveraging Spring transactions, Camel lets you use an existing and proven transaction framework that.
The difference between onCompletion and Synchronization There is one major difference between using onCompletion and using a Synchronization, and that’s the thread model in use.
Synchronization uses the same thread to perform the tasks, so it will block and wait until it completes.
In contrast, onCompletion transfers the exchange to be executed by a separate thread.
The reason for this design decision is that onCompletion should not affect the original exchange and its outcome.
Suppose during onCompletion an exception was thrown—what should happen then? Or what if onCompletion unexpectedly or deliberately changed the content of the exchange, which would affect the reply being sent back to the caller?
The bottom line is that onCompletion uses a separate route based on a copy of the completed exchange.
It will not affect the outcome of the original route.
Here are the best practices you should take away from this chapter:
Transactions can only be used by a limited number of resources, such as JMS and JDBC.
Therefore, it only makes sense to use transactions when you can leverage these kinds of resources.
If transactions aren’t applicable, you can consider using your own code to compensate and to work as a rollback mechanism.
If your route only involves one transactional resource, use local transactions.
Build unit and integration tests to ensure that your transactions work as expected.
We’ll now turn our attention to using concurrency with Camel.
You’ll learn to how to improve performance, understand the threading model used in Camel, and more.
Concurrency is another word for multitasking, and we multitask all the time in our daily lives.
We put the coffee on, start up the computer, and while it’s booting grab the paper to glance at the news.
Computers are also capable of doing multiple tasks—you may have multiple tabs open in your web browser while your mail application is fetching new email, for example.
Juggling multiple tasks is also very common in enterprise systems, such as when you’re processing incoming orders, handling invoices, and doing inventory management, and these demands only grow over time.
Camel processes multiple messages concurrently in Camel routes, and it leverages the concurrency features from Java, so we’ll first discuss how concurrency works in Java before we can move on to how thread pools work and how you define and use them in Camel.
The thread pool is the mechanism in Java that orchestrates multiple tasks.
After we’ve discussed thread pools, we’ll move on to how you can use concurrency with the EIPs, and we’ll dive into how message synchronicity works.
We’ll then look at Camel’s client concurrency API, which makes it easier for clients to work with concurrency.
The last section of this chapter focuses on how you can achieve high scalability with Camel and how you can leverage this in your custom components.
As we’ve mentioned, you can achieve higher performance with concurrency.
When performance is limited by the availability of a resource, we say it’s bound by that resource: CPU-bound, IO-bound, database-bound, and so on.
Integration applications are often IO-bound, waiting for replies to come back from remote servers, or for files to load from a disk.
This usually means you can achieve higher performance by utilizing resources more effectively, such as by keeping CPUs busy doing useful work.
Camel is often used to integrate disparate systems, where data is exchanged over the network.
This means there’s often a mix of resources, which are either CPU-bound or IO-bound.
It’s very likely you can achieve higher performance by using concurrency.
To help explain the world of concurrency, we’ll look at an example.
Rider Auto Parts has an inventory of all the parts its suppliers currently have in stock.
It’s vital for any business to have the most accurate and up-to-date information in their central ERP system.
Having the information locally in the ERP system means the business can operate without depending on online integration with their suppliers.
Supplier Figure 10.1 Suppliers send inventory updates, which are picked up by a Camel application.
This application is responsible for loading the files and splitting the file content on a line-by-line basis using the Splitter EIP, which converts the line from CSV format to an internal object model.
The model is then sent to another route that’s responsible for updating the ERP system.
Listing 10.1 shows the configure method of the Camel RouteBuilder that contains the two routes for implementing the application.
As you can see, the first route picks up the files and then splits the file content line by line B.
This is done by using the Splitter EIP in streaming mode.
The streaming mode ensures that the entire file isn’t loaded into memory; instead it’s loaded piece by piece on demand, which ensures low memory usage.
To convert each line from CSV to an object, you use a bean—the InventoryService class.
To update the ERP system, you use the updateInventory method of the InventoryService, as shown in the second route C.
Now suppose you’re testing the application by letting it process a big file with 100,000 lines.
In fact, you might end up in a situation where you can’t process all the files within the given timeframe.
In a moment, we’ll look at different techniques for speeding things up by leveraging concurrency.
But first we’ll set up the example to run without concurrency to create a baseline to compare to the concurrent solutions.
Figure 10.2 A route picks up incoming files, which are split and transformed to be ready for updating the inventory in the ERP system.
The source code for the book contains this example (both with and without concurrency) in the chapter10/bigfile directory.
First, you need a big file to be used for testing.
To create a file with 1000 lines, use the following Maven goal:
A bigfile.csv file will be created in the target/inventory directory.
The next step is to start a test that processes the bigfile.csv without concurrency.
When the test runs, it will output its progress to the console.
When the test completes, it should log the total time taken:
In the following section, we’ll see three different solutions to run this test more quickly using concurrency.
The application can leverage concurrency by updating the inventory in parallel.
Figure 10.3 shows this principle by using the Concurrent Consumers EIP.
As you can see in figure 10.3, the idea is to use concurrency D after the lines have been split C.
By doing this, you can parallelize steps E and F in the route.
In this example, those two steps could process messages concurrently.
The last step F, which sends messages to the ERP system concurrently, is only possible if the system allows a client to send messages concurrently to it.
There can be situations where a system does not permit concurrency, or it may only allow up to a.
Figure 10.3 Using the Concurrent Consumers EIP to leverage concurrency and process inventory updates in parallel.
Check the SLA (service level agreement) for the system you integrate with.
Another reason to disallow concurrency would be if the messages have to be processed in the exact order they are split.
Let’s try out three different ways to run the application faster with concurrency:
The first two solutions are features that the Splitter EIP provides out of the box.
The last solution is based on the SEDA principle, which uses queues between tasks.
The Splitter EIP offers an option to switch on parallel processing, as shown here:
Configuring this in Spring XML is very simple as well:
As you’ll see, the test is now much faster and completes in about a tenth of the previous time.
What happens is that when parallelProcessing is enabled, the Splitter EIP uses a thread pool to process the messages concurrently.
The test would not be 10 times faster if it were solely CPU-bound; for example, if all it did was “crunch numbers.”
This thread number is a sequential, unique number assigned to each thread as it’s created, in any thread pool.
This means if you use a second Splitter EIP, the second splitter will most likely have numbers assigned from 11 upwards.
This is a coincidence, because the 10 concurrent threads are independent and they run at their own pace.
The reason why they appear in order here is because we simulated the update by delaying the message for a tenth of a second, which means they’ll all take approximately the same amount of time.
You now know that parallelProcessing will use a default thread pool to achieve concurrency.
What if you want to have more control over which thread pool is being used?
To use this pool with the Splitter EIP, you need to configure it as shown here:
Creating the thread pool using Spring XML is done as follows:
The Splitter EIP uses the pool by referring to it, using the executorServiceRef attribute, as shown:
The test is now much faster and completes within a few seconds:
The reason is that the cached thread pool is designed to be very aggressive and to spawn new threads on demand.
It has no upper bounds and no internal work queue, which means that when a new task is being handed over, it will create a new thread if there are no available threads in the thread pool.
Many threads have been created because the Splitter EIP splits the file lines more quickly than the tasks update the inventory.
This means that the thread pool receives new tasks at a higher pace than it can execute them; new threads are created to keep up.
This can cause unpredicted side effects in an enterprise system—a high number of newly created threads may impact applications in other areas.
That’s why it’s often desirable to use thread pools with an upper limit for the number of threads.
For example, instead of using the cached thread pool, you could use a fixed thread pool.
You can use the same Executors factory to create such a pool:
Creating a fixed thread pool in Spring XML is done as follows:
The test is now limited to use 20 threads at most.
In Camel lingo, that means using internal memory queues to hand over messages between routes.
Direct is fully synchronized, and it works like a direct method call invocation.
Figure 10.4 shows how you can use SEDA to implement the example.
The second route uses concurrent consumers to process the messages that arrive on the SEDA endpoint, using multiple concurrent threads.
Listing 10.2 shows how to implement this solution in Camel by using the seda endpoints, shown in bold.
Figure 10.4 Messages pass from the first to the second route using SEDA.
By default, a seda consumer will only use one thread.
The test is fast and completes in about 6 seconds.
As you can see from the console output, you’re now using 20 concurrent threads to process the inventory update.
That’s why it’s best to leverage the concurrency features provided by the EIPs, such as the parallelProcessing on the Splitter EIP.
It will leverage a thread pool that can grow and shrink on demand, so it won’t consume as many resources as a SEDA endpoint will.
We’ve now covered three different solutions for applying concurrency to an existing application, and they all greatly improve performance.
In the next section, we’ll review thread pools in more detail and learn about the threading model used in Camel.
With this knowledge, you can go even further with concurrency.
In fact, thread pools were used in the example in the previous section.
It was a thread pool that allowed the Splitter EIP to work in parallel and speed up the performance of the application.
In this section, we’ll start from the top and briefly recap what a thread pool is and how it’s represented in Java.
Then we’ll look at the default thread pool profile used by Camel and how to create custom thread pools using Java DSL and Spring XML.
We’ll also look at how you can use a custom strategy to delegate the creation of thread pools to an external resource, such as a Java WorkManager on a JAVA EE server.
A thread pool is a group of threads that are created to execute a number of tasks in a task queue.
In the concurrency API, the ExecutorService interface is the client API that you use to submit tasks for execution.
Clients of this API are both Camel end users and Camel itself, because Camel fully leverages the concurrency API from Java.
If you want to learn in depth about the Java concurrency API, we highly recommend the book Java Concurrency in Practice by Brian Goetz.
In Java, the ThreadPoolExecutor class is the implementation of the ExecutorService interface, and it provides a thread pool with the options listed in table 10.1
Figure 10.5 Tasks from the task queue wait to be executed by a thread from the thread pool.
As you can see from table 10.1, there are many options you can use when creating thread pools in Java.
To make it easier to create commonly used types of pools, Java provides Executors as a factory, which you saw in section 10.1.2
In section 10.2.3, you’ll see how Camel makes creating thread pools even easier.
When working with thread pools, there are often additional tasks you must deal with.
For example, it’s important to ensure the thread pool is shut down when your application is being shut down; otherwise it can lead to memory leaks.
This is particularly important in server environments when running multiple applications in the same server container, such as a JAVA EE or OSGi container.
When using Camel to create thread pools, the activities listed in table 10.2 are taken care of out of the box.
By allowing Camel to name the threads using a common naming standard, you can better understand what happens when looking at log files (particularly if your application is running together with other frameworks that create their own threads)
For example, this log entry indicates it’s a thread from the Camel File component:
If Camel didn’t do this, the thread name would be generic and wouldn’t give any hint that it’s from Camel, nor that it’s the file consumer.
Shutdown Ensures the thread pool will be properly shut down, which happens when Camel shuts down.
Management Registers the thread pool in JMX, which allows you to manage the thread pool at runtime.
Unique thread names Ensures the created threads will use unique and human-readable names.
We’ll cover the options listed in table 10.1 in more detail in the next section, when we review the default thread profile used by Camel.
Thread pools aren’t created and configured directly, but via the configuration of thread pool profiles.
A thread pool profile is a profile that dictates how a thread pool should be created, based on a selection of the options listed earlier in table 10.1
Thread pool profiles are organized in a simple two-layer hierarchy with custom and default profiles.
There is always one default profile and you can optionally have multiple custom profiles.
The default profile is defined using the options listed in table 10.3
The rejectedPolicy option corresponds to the rejected option from table 10.1, and it’s an enum type allowing four different values: Abort, CallerRuns, DiscardOldest, and Discard.
The CallerRuns option will use the caller thread to execute the task itself.
The other three options will either abort by throwing an exception, or discard an existing task from the task queue.
There is no one-size-fits-all solution for every Camel application, so you may have to tweak the default profile values.
But usually you’re better off leaving the default values alone.
Only by load testing your applications can you determine that tweaking the values will produce better results.
You can configure the default thread pool profile from either Java or Spring XML.
It’s important to set the defaultProfile attribute to true to tell Camel that this is the default profile.
You can add additional options if you want to override any of the other options from table 10.3
There are situations where one profile isn’t sufficient, so you can also define custom profiles.
Defining custom thread pool profiles is much like configuring the default profile.
When Camel creates this route with the Splitter EIP, it refers to a thread pool with the name bigPool.
Camel will now look in the registry for an ExecutorService type registered with the ID bigPool.
If none is found, it will fall back and see if there is a known thread pool profile with the ID bigPool.
And because such a profile has been registered, Camel will use the profile to create a new thread pool to be used by the Splitter EIP.
All of which means that executorServiceRef supports using thread pool profiles to create the desired thread pools.
When using Spring XML, it’s simpler to define custom thread pool profiles.
Besides using thread pool profiles, you can create thread pools in other ways.
For example, you may need to create custom thread pools if you’re using a third-party library that requires you to provide a thread pool.
Or you may need to create one as we did in section 10.1 to leverage concurrency with the Splitter EIP.
Creating thread pools with the Java API is a bit cumbersome, so Camel provides a nice way of doing this in both Java DSL and Spring XML.
The ThreadPoolBuilder requires CamelContext in its constructor, because it will use the default thread pool profile as the baseline when building custom thread pools.
That means myPool will use the default value for keepAliveTime, which would be 60 seconds.
In Spring XML, creating a thread pool is done using the <threadPool> tag:
This is because it needs access to the default thread profile, which is used as baseline (just as the ThreadPoolBuilder requires CamelContext in its constructor)
The preceding route uses a <threads> tag, that references the custom thread pool B.
If a message is sent to the direct:start endpoint, it should be routed to <threads>, which will continue routing the message using the custom thread pool.
This can be seen in the console output that logs the thread names:
If none are found, Camel will fall back and see if a thread pool profile exists with the given name; if so, a new thread pool is created based on that profile.
In Spring XML, it’s easy because all you have to do is define a Spring bean.
So far in this chapter, we’ve mostly used thread pools in Camel routes, but they’re also used in other areas, such as in some Camel components.
Suppose you’re developing a custom Camel component and you need to run a.
Listing 10.3 illustrates the principle of using a scheduled thread pool to repeatedly execute a background task.
The custom component extends DefaultComponent, which allows you to override the doStart and doStop methods to create and shut down the thread pool.
The source code for the book contains this example in the chapter10/pools directory.
When it runs, you’ll see the following output in the console:
You now know that thread pools are how Java achieves concurrency; they’re used as executors to execute tasks concurrently.
You also know how to leverage this to process messages concurrently in Camel routes, and you saw several ways of creating and defining thread pools in Camel.
When modeling routes in Camel, you’ll often use EIPs to build the routes to support your business cases.
In section 10.1, you used the Splitter EIP and learned to improve performance using concurrency.
In the next section, we’ll take a look at other EIPs you can use with concurrency.
Some of the EIPs in Camel support concurrency out of the box—they’re listed in table 10.4
In this section, we’ll take a look at them and the benefits they offer.
Aggregate The Aggregator EIP allows concurrency when sending out completed and aggregated messages.
Multicast The Multicast EIP allows concurrency when sending a copy of the same message to multiple recipients.
All the EIPs from table 10.4 can be configured to enable concurrency in the same way.
You can turn on parallelProcessing to use thread pool profiles to apply a matching thread pool; this is likely what you’ll want to use in most cases.
Or you can refer to a specific thread pool using the executorService option.
You’ve already seen this in action in section 10.1.2, where you used the Splitter EIP.
In the following three sections, we’ll look at how to use the Threads, Multicast, and Wire Tap EIPs in a concurrent way.
The Threads EIP is the only EIP that has additional options in the DSL offering finegrained definition of the thread pool to be used.
For example, the thread pool from section 10.2.3 could be written as follows:
Figure 10.6 illustrates which threads are in use when a message is being routed using the Threads EIP.
There will be two threads active when a message is being routed.
The caller thread will hand over the message to the thread pool.
The thread pool will then find an available thread in its pool to continue routing the message.
The Recipient List EIP allows concurrency when sending copies of a single message to a dynamic list of recipients.
This works in the same way as the Multicast EIP, so what you learned there also applies for this pattern.
Splitter The Splitter EIP allows concurrency when each split message is being processed.
Threads The Threads EIP always uses concurrency to hand over messages to a thread pool that will continue processing the message.
Wire Tap The Wire Tap EIP allows you to spawn a new message and let it be sent to an endpoint using a new thread, while the calling thread can continue to process the original message.
The Wire Tap EIP always uses a thread pool to execute the spawned message.
You can run this example from the chapter10/pools directory using the following Maven goal:
You see, as expected, two threads in play: main is the caller thread, and Cool is from the thread pool.
A good example is the Camel file component, which uses a single thread to scan and pick up files.
By using the Threads EIP, you can allow the picked up files to be processed concurrently.
Let’s look at how Rider Auto Parts improves performance by leveraging concurrency with the Multicast EIP.
Rider Auto Parts has a web portal where its employees can look up information, such as the current status of customer orders.
When selecting a particular order, the portal needs to retrieve information from three different systems to gather an overview of the order.
Figure 10.6 Caller and pooled threads are in use when a message is routed.
Employee Figure 10.7 The web portal gathers information from three systems to compile the overview that’s presented to the employee.
Your boss has summoned you to help with this portal.
The employees have started to complain about poor performance, and it doesn’t take you more than an hour to find out why; the portal retrieves the data from the three sources in sequence.
This is obviously a good use case for leveraging concurrency to improve performance.
You tell your boss that you can improve the performance by gathering the data in parallel.
Back at your desk, you build a portal prototype in Camel that resembles the current implementation.
The prototype uses the Multicast EIP to retrieve data from the three external systems as follows:
The Multicast EIP will send copies of a message to the three endpoints and aggregate their replies using the aggregatedData bean.
When all data has been aggregated, the combineData bean is used to create the reply that will be displayed in the portal.
You decide to test this route by simulating the three systems using the same response times as from the production logs.
As you can see, the total time is 4.1 seconds when running in sequence.
Note that the logged lines aren’t in the same order as the sequential example.
With concurrency enabled, the lines are logged in the order that the remote services’ replies come in.
Without concurrency, the order is always fixed in the sequential order defined by the Camel route.
The source code for the book contains this example in the chapter10/eip directory.
You can try the two scenarios using the following Maven goals:
You have now seen how the Multicast EIP can be used concurrently to improve performance.
The Aggregate, Recipient List, and Splitter EIPs can be configured with concurrency in the same way as the Multicast EIP.
The next pattern we’ll look at using with concurrency is the Wire Tap EIP.
The Wire Tap EIP leverages a thread pool to process the tapped messages concurrently.
You can configure which thread pool it should use, and if no pool has been configured, it will fall back and create a thread pool based on the default thread pool profile.
Suppose you want to use a custom thread pool when using the Wire Tap EIP.
First you must create the thread pool to be used, and then you pass that in as a reference to the wire tap in the route, as highlighted in bold:
The source code for the book contains this example in the chapter10/eip directory.
You can run the example using the following Maven goals:
When you run the example, the console output should indicate that the tapped message is being processed by a thread from the LowPool thread pool.
You now have a better understanding of the overall concept of using thread pools for concurrency in Java.
We’ll next look at how the synchronicity of messages impacts the way thread pools are leveraged.
A caller can invoke a service either synchronously or asynchronously.
If the caller has to wait until all the processing steps are complete before it can continue, it’s a synchronous process.
If the caller can continue before the processing has been completed, it’s an asynchronous process.
The service being invoked can leverage as many threads as it wants to complete the message.
The number of threads doesn’t affect whether or not the caller is considered synchronous or asynchronous.
Now imagine from this point forward that the service being invoked is a Camel route.
As just mentioned, the service can use multiple threads to process the message.
In this section, we’ll focus on which factors affect how many threads are involved in processing messages in Camel.
Component—The Camel component that originates the exchange is either based on a fire-and-forget or a request-response messaging style.
Camel uses the terminology from the Java Business Integration (JBI) specification (http://en.wikipedia.org/wiki/JBI): InOnly means fire-andforget, and InOut means request-response.
We’ll discuss the pros and cons of each scenario and give an example of where it may be used in a real-life situation.
You can use these Maven goals to run the examples:
In figure 10.8, you’ll see that Camel uses the consumer thread all along the processing of the message.
In this figure, an arrow represents a thread, and the consumer thread is shown as one long arrow.
This scenario can be implemented in a simple Camel route:
Figure 10.8 In asynchronous InOnly mode, the caller doesn’t wait for a reply.
On the Camel side, only one thread is used for all the processing of the message.
You can try the route from a unit test by sending an InOnly message using the sendBody method from ProducerTemplate:
If you run this example, you should see output to the console that shows the threads in use during routing:
The first two log lines are the caller sending the message to Camel.
The last two show that the consumer thread [Camel Thread 0 - seda://start] is used to process the message in the entire route.
The caller is sending in a fire-and-forget message (InOnly), which means the caller doesn’t expect a reply (and it doesn’t wait for a reply)
As a result, the caller can continue while the message is being processed.
From the Camel perspective, only one thread is involved in processing the message, which simplifies things.
Table 10.5 outlines the pros and cons of this approach from the Camel perspective.
The asynchronous InOnly scenario is often used with JMS messaging, where it’s common to use Camel to route messages from JMS queues to other destinations.
Realworld systems might use this scenario when routing messages between JMS destinations, such as a new order queue that’s routed to a validated order queue if the order passes a sanity check.
Orders that are invalid would be routed to an invalid order queue for further manual inspection.
In this example, the caller didn’t expect a reply because it sent an InOnly message.
The next scenario shows what happens when the caller sends an InOut (requestresponse) message.
This scenario is only slightly different from the previous one.
In figure 10.9 you can see that Camel is still only using one thread (represented as one arrow)
Table 10.5 Pros and cons of using one thread from the Camel perspective.
The route in Camel is also a bit different, because you want to transform the message to return a reply to the caller: "Bye Camel"
You can test this by using the requestBody method from ProducerTemplate, which sends an InOut message:
If you run this example, you should see output to the console showing the threads in use during routing.
Notice how the caller waits for the reply while the consumer thread [Camel Thread 0 seda://start] is used to process the message for the entire route.
Figure 10.9 In synchronous InOut mode, the caller waits for a reply.
In Camel, the consumer thread is used for all the processing of the message, and it delivers the reply to the waiting caller.
Synchronicity and threading the caller is waiting—it will log to the console after Camel has processed the message.
Because the caller waits for a reply, we consider it synchronous.
The pros and cons of this configuration from the Camel perspective are the same as in the previous section and are listed in table 10.5
The synchronous InOut scenario can be used with JMS messaging because you can return replies if the JMSReply JMS property is provided on the incoming message.
Real-world systems may want to use this approach with components that natively support request-response messaging, such as web services.
A system could expose a web service that clients can call to query order status.
The next two scenarios we’ll cover show what happens when Camel uses multiple threads to process the messages.
This time you’re leveraging two threads in Camel to process the messages (represented by the two arrows)
This time there are two thread pools involved in Camel.
The consumer thread will process the first part of the routing, and then the message is transferred to another thread pool, which continues routing the message.
You use the Threads EIP to add the asynchronous behavior to the route:
Figure 10.10 In asynchronous InOnly mode, the caller doesn’t wait for a reply.
On the Camel side, multiple threads are involved during the routing of the message.
To test this scenario, you can use the following unit test:
If you run this example, you should see output to the console that shows the threads in use during routing:
The first two log lines indicate the caller sending the message to Camel.
The last two lines show the other two threads involved in routing the message inside Camel.
In this scenario, the caller is asynchronous because it can continue without waiting for a reply.
This model has a different set of pros and cons from the Camel perspective, as listed in table 10.6
In a real-world situation, you might want to use this scenario when consuming files, as we did in section 10.1
By not having the consumer thread process the file, it’s free to pick up new files.
And by using multiple threads in Camel, you can maximize throughput as multiple threads can work simultaneously on multiple files.
Another use case when multiple threads can be an advantage is when you process big messages that can be split into smaller submessages for further processing.
This is what we did in section 10.1 using the parallelProcessing option on the Splitter EIP.
The next scenario is similar to this one, but it uses a request-response messaging style.
The synchronous InOut scenario involving multiple threads inside Camel is illustrated in figure 10.11
In this scenario, the situation is a bit more complex because the caller is waiting for a reply and Camel is using multiple threads to process the message.
This means the consumer thread that received the request must block until the routing is.
Table 10.6 Pros and cons of using an asynchronous caller and having multiple threads, from the Camel perspective.
Synchronicity and threading complete, so it can deliver the reply back to the waiting caller.
We’ll unlock how this works when we look at the asynchronous client API in section 10.5
The route you use for testing this scenario is as follows:
The unit test uses the requestBody method to send an InOut message to Camel:
If you run this example, you should see output to the console that shows the threads in use during routing:
These lines reveal that the caller waits for the reply and that two threads are involved during the routing of the message in Camel.
Figure 10.11 In synchronous mode, the caller waits for a reply.
On the Camel side, multiple threads are involved during the routing of the message.
The consumer thread has to block, waiting for the reply, which it must send back to the waiting caller.
What the lines also reveal is that the caller received "Bye Camel" as the reply.
This may seem a bit like magic, as the "Bye Camel" message was constructed in the last part of the route.
That means the consumer thread somehow knew that it had to block until the reply message was ready.
Although this might seem like magic, there is no such magic in Camel or the Java language.
It’s the Java concurrency API that allows you to wait for an asynchronous task to complete, using what is called a Future handle.
Table 10.7 presents the pros and cons of this scenario.
This scenario can be used when you want to return an early reply to the waiting caller.
Suppose you expose a web service and want to return an OK reply as quickly as possible.
By dispatching the received messages asynchronously, you allow the consumer thread to continue and return the early reply to the caller.
This may sound easy, but the MEP impacts how this can be done correctly.
Consider an example in which a caller invokes a Camel service in a synchronous manner—the caller is blocked while waiting for a reply.
In the Camel service, you want to send a reply back to the waiting caller as soon as possible; the reply is an acknowledgement that the input has been received, so "OK" is returned to the caller.
In the meantime, Camel continues processing the received message in another thread.
Implementing this example as a Camel route with the Java DSL can be done as.
Table 10.7 Pros and cons of using a synchronous caller and having multiple threads, from the Camel perspective.
The service lets the wire tap continue processing the message asynchronously while the service returns an early reply to the waiting caller.
You leverage the Wire Tap EIP B to continue routing the incoming message in a separate thread.
This gives room for the consumer to immediately reply C to the waiting caller.
You can run the example using the following Maven goals:
When you run the example, you should see the console output showing how the message is processed:
Notice in the console output how the caller immediately receives a reply within the same second it sent the request.
The last log line shows that the Wire Tap EIP finished processing the message 3 seconds after the caller received the reply.
This is necessary because Jetty is stream-based, which causes it to only be able to read the message once.
So far in this chapter, you’ve seen concurrency used in Camel routes by the various EIPs that support them.
But Camel also has a strong client API, manifested in the ProducerTemplate and ConsumerTemplate classes (see appendix C)
These classes have easy-to-use methods for sending messages to any endpoint you choose.
In the next section, you’ll learn what those classes have to offer when it comes to concurrency.
You can use the concurrency client API directly from Java code, which means you’re in full control of what should happen.
You don’t have to use Camel routes and EIPs to achieve concurrency.
To fully understand the concurrency API from the client point of view, we’ll look at how you can achieve concurrency with pure Java.
Then we’ll look at the same example using Camel’s ProducerTemplate.
We’ll end this section by looking at how the Camel client API allows you to easily submit concurrent messages to different endpoints and leverage a callback mechanism to gather the replies when they come back.
All the concurrency behavior in Camel is built on top of this API.
For example, the Camel thread pools are all ExecutorService instances, which are capable of executing tasks concurrently and asynchronously.
Java’s concurrency API includes the following classes that are interesting to learn about and understand from a developer’s point of view:
Think of it as an improved Runnable that can return a result or throw an exception.
Future—This represents the lifecycle of an asynchronous task and provides methods to test whether the task has completed or been cancelled, to retrieve its result, and to cancel the task.
Figure 10.13 is a sequence diagram that depicts how these three concepts are related and how they’re involved in a typical use case where an asynchronous task is being executed.
Figure 10.13 shows how a client creates a new Callable, which represents the tasks (the code) you want to be executed asynchronously.
The task is then submitted to an ExecutorService, which is responsible for further processing the task.
The concurrency client API is executed, a Future is returned to the client.
The Future is a handle that the client can use at any point later on to retrieve the result of the task.
The task to be executed is located within the call method of the Callable B.
Note that you can use generics to specify the result type as a String.
The task is then submitted to the ExecutorService C, which returns a Future<String> handle; the generic type matches the type from the task.
While the task is being processed, you can do other computations, but in this example you just loop and wait for the task to be done D.
At the end, you can retrieve the result using the get method E.
Figure 10.13 The client submits tasks (Callable) to be executed asynchronously by ExecutorService, which returns a Future handle to the client.
The source code for the book contains this example in the chapter10/client directory.
You can use the following Maven goal to run the example:
When you run the example, the console should output what’s happening:
As you can see from the console output, the task executes in a thread named "pool-1thread-1" while the caller executes in the main thread.
This output also proves that the client waits until the task is done.
There’s a smarter way to retrieve the result than by looping and testing whether the task is done—you can use the get method on the Future handle which will automatically wait until the task is done.
Removing the while loop from the code in listing 10.4 and running the example will output the following:
As you can see, this time you don’t have to test whether the task is done.
Invoking the get method on Future causes it to wait until the task is done and to react promptly when it is done.
The source code for the book contains this example in the chapter10/client directory.
You can use the following Maven goal to run the example:
You’ve seen how clients leverage Future to retrieve the result of tasks that have been submitted for asynchronous execution.
Table 10.8 lists the most commonly used methods provided by Future.
Will throw an ExecutionException if the tasks throw an exception.
Waits, if necessary, for at most the specified time for the task to complete, and then returns the result if available.
Will throw an ExecutionException if the tasks throw an exception.
Understanding the principle of Future is important because it’s the same mechanism Camel leverages internally when it processes messages asynchronously.
Future also plays a role in the concurrency client API provided by Camel, which we’re going to take a look at now.
The client concurrency API in Camel is provided in the ProducerTemplate class.
It offers a range of methods that Camel end users can leverage to submit messages to Camel to be further processed asynchronously.
This allows us to compare this example with the previous one to see how easy it is in Camel to use the concurrency client API.
Sending a message asynchronously to the "seda:quote" endpoint is easy to do in Camel by using the asyncRequestBody method as shown here:
The source code for the book contains this example in the chapter10/client directory.
You can use the following Maven goal to run the example:
If you run this example, the console should output something like the following:
What you should notice in this example is that the Camel concurrency client API also uses the Future handle to retrieve the result.
This allows Camel end users to more easily learn and use the Camel concurrency API, as it’s based on and similar to the Java concurrency API.
Table 10.9 lists the most commonly used methods, provided by ProducerTemplate.
Notice that all the methods listed in table 10.9 start with async in their method name.
This makes them easy to remember when you need to send a message asynchronously.
The last three methods in table 10.9 support a callback mechanism, which makes sense in situations where you may need to use the same callback for several tasks.
Let’s look at an example now, to make this all a bit clearer.
Rider Auto Parts has a selected number of premium partners who are promoted exclusively on the Rider Auto Parts web store.
Whenever a customer browses the items catalog, the partners are listening and can provide feedback about related items.
For example, if you browse for bumper parts, the partners can suggest related items, such as bumper extensions or other car parts.
The partners have to return their feedback within a given time period, so the user experience of browsing the website isn’t slowed down noticeably.
Implementing such a use case is possible using the Camel concurrency client API.
You can use a callback to gather the partner feedback within the given time period.
Table 10.9 Commonly used asynchronous methods in the ProducerTemplate class.
Sends the body and header to the given endpoint using InOnly as the exchange pattern.
Sends the body and header to the given endpoint using InOut as the exchange pattern.
Sends the exchange to the given endpoint and invokes the callback when the task is done.
Sends the body to the given endpoint using InOnly as the exchange pattern, and invokes the callback when the task is done.
Sends the body to the given endpoint using InOut as the exchange pattern, and invokes the callback when the task is done.
The callback has two methods: the first is invoked when the Exchange is processed successfully, and the second is invoked if the Exchange fails.
Listing 10.5 shows how this can be implemented in Camel.
You use a CountDownLatch B to let you know when you’ve received all the replies or the given time period is up.
The callback is used to gather the replies in the relates list.
It allows you to override the onComplete and onFailure methods.
The onComplete method is invoked when the message is routed successfully, so we get a valid reply for the business partner.
In both situations, you need to count down the latch to keep track of the number of replies coming back.
Now you’re ready to send messages to the partners about which category the user is browsing.
This is done asynchronously, so you need to wait until the replies are gathered or the time period is up.
In this example, you wait until all five replies have been gathered or the timeout is triggered.
The source code for the book includes this example in the chapter10/client directory.
You can run it by invoking the following Maven goal:
If you run this example, you should get the following output on the console:
In this example, you send to five different partners but only three respond within the time period.
As you’ve seen, the Camel concurrency client API is powerful, as it combines the power from Camel with an API resembling the equivalent concurrency API in Java.
That’s all we have to say about the asynchronous client API.
The next section covers what you can do in Camel to improve scalability.
Camel uses its routing engine to route messages either synchronously or asynchronously.
In this section we focus on scalability and learn that higher scalability can be achieved with the help of the asynchronous routing engine.
For a system, scalability is the desirable property of being capable of handling a growing amount of work gracefully.
In section 10.1, we covered the Rider Auto Parts inventory application, and you saw you could increase throughput by leveraging concurrent processing.
In that sense, the application was scalable, as it could handle a growing amount of work in a graceful manner.
That application could scale because it had a mix of CPU-bound and IO-bound processes, and because it could leverage thread pools to distribute work.
In this section, we’ll look at scalability from a different angle.
We’ll look at what happens when messages are processed asynchronously.
Rider Auto Parts uses a Camel application to service its web store, as illustrated in figure 10.14
There are a variety of requests to handle, such as updating shopping carts, performing searches, gathering production information, and so on—the usual functions you expect from a web store.
But there’s one function that involves calculating pricing information for customers.
The pricing model is complex and individual for each customer—only the ERP system.
As a result, the Camel application communicates with the ERP system to gather the prices.
While the prices are being calculated by the ERP system, the web store has to wait until the reply comes back, before it returns its response to the customer.
The business is doing well for the company, and an increasing number of customers are using the web store, which puts more load on the system.
Lately there have been problems during peak hours, with customers reporting that they can’t access the web store or that it’s generally responding slowly.
The root cause has been identified: the communication with the ERP system is fully synchronous, and the ERP system takes an average of 5 seconds to compute the pricing.
This means each request that gathers pricing information has to wait (the thread is blocked) an average of 5 seconds for the reply to come back.
This puts a burden on the Jetty thread pool, as there are fewer free threads to service new requests.
You can see that the thread is blocked (the white boxes) while waiting for the ERP system to return a reply.
Figure 10.14 The Rider Auto Parts web store communicates with the ERP system to gather pricing information.
Figure 10.15 A scalability problem illustrated by the thread being blocked (represented as white boxes) while waiting for the ERP system to return a the reply.
Figure 10.15 reveals that the Jetty consumer is using one thread per request.
This leads to a situation where you run out of threads as traffic increases.
Let’s look into why, and look at what Camel has under the hood to help mitigate such problems.
It would be much better if the Jetty consumer could somehow borrow the thread while it waits for the ERP system to return the reply, and use the thread in the meantime to service new requests.
This can be done by using an asynchronous processing model.
In fact, there are no threads blocked while the ERP system is processing the request.
This is a huge scalability improvement because the system is much less affected by the processing speed of the ERP system.
The threads in the web store are much less IO-bound and are put to better use doing actual work.
Figure 10.17 shows a situation in which two customer requests are served by the same thread without impacting response times.
In this situation, customer 1 sends a request that requires a price calculation, so the ERP system is invoked asynchronously.
A short while thereafter, customer 2 sends a request that can be serviced directly by the web shop service, so it doesn’t leverage the.
Threads are much less blocked (represented by white boxes) when you leverage asynchronous communication between the systems.
In this example, you can successfully process two customers without any impact on their response time.
In the next section, we’ll look under the hood to see how this is possible in Camel using the asynchronous processing model.
The routing engine in Camel is capable of routing messages either synchronously or asynchronously.
The latter requires the Camel component to support asynchronous processing, which in turn depends on the underlying transport supporting asynchronous communication.
Figure 10.17 The same thread services multiple customers without blocking (white and grey boxes) and without impacting response times, resulting in much higher scalability.
Apache ServiceMix supports high scalability Apache ServiceMix (http://servicemix.apache.org/) is an enterprise service bus (ESB) that can host your Camel application.
In terms of high scalability, ServiceMix offers a message bus (the JBI and NMR components) for passing messages inside your application or between applications.
The message bus supports the asynchronous processing model described in this chapter, which means it’s highly scalable.
You can check the online documentation for an updated list of supported components: http://camel.apache.org/asynchronous-routing-engine.
In order to achieve high scalability in the Rider Auto Parts web store, you need to use asynchronous routing at two points.
The communication with the ERP system and with the Jetty consumer must both happen asynchronously.
To understand how this is possible with Camel, we’ll take a closer look at figure 10.16
The figure reveals that after the request has been submitted to the ERP system, the thread won’t block but will return to the Jetty consumer.
It’s then up to the ERP transport to notify Camel when the reply is ready.
When Camel is notified, it will be able to continue routing and let the Jetty consumer return the HTTP response to the waiting customer.
To enable all this to work together, Camel provides an asynchronous API that the components must use.
Camel supports an asynchronous processing model, which we refer to as the asynchronous routing engine.
Jetty and continuations The Jetty servlet engine uses continuations to achieve high scalability.
It allows Camel to park a request and later retrieve the request and continue processing it.
The asynchronous routing engine processing, compared to using the standard synchronous processing model.
The asynchronous processing model is manifested by an API that must be implemented to leverage asynchronous processing.
You’ve already seen a glimpse of this API in figure 10.16; the arrow between the Jetty consumer and the web store service has the labels Return false and Done.
Let’s see the connection that those labels have with the asynchronous API.
The AsyncProcessor is an extension of the synchronous Processor API:
A non-null AsyncCallback must be supplied; it will be notified when the exchange processing is completed.
The process method must not throw any exceptions that occur while processing the exchange.
Any such exceptions must be stored on the exchange’s exception property.
The process method must know whether it will complete the processing synchronously or asynchronously.
The method will return true if it completes synchronously; otherwise it returns false.
The doneSync parameter must match the value returned by the process method.
The preceding rules may seem a bit confusing at first.
Don’t worry, the asynchronous API isn’t targeted at Camel end users but at Camel component writers.
In the next section, we’ll cover an example of how to implement a custom component that acts asynchronously.
You’ll be able to use this example as a reference if you need to implement a custom component.
Table 10.11 Advantages and disadvantages of using the asynchronous processing model.
Processing messages asynchronously doesn’t use up threads, forcing them to wait for processors to complete on blocking calls.
It increases the scalability of the system by reducing the number of threads needed to manage the same workload.
The AsyncCallback API is a simple interface with one method:
It’s this callback that’s invoked when the ERP system returns the reply.
This notifies the asynchronous routing engine in Camel that the exchange is ready to be continued, and the engine can then continue routing it.
Let’s see how this all fits together by digging into the example and looking at some source code.
This example contains a custom ERP component that simulates asynchronous communication with an ERP system.
To simulate asynchronous communication, you use a thread pool to execute tasks asynchronously; this means you need to create a thread pool in the constructor.
To support the asynchronous processing model, the ErpProducer must also implement the asynchronous process method C.
To simulate the communication, which takes 5 seconds to reply, you submit ERPTask to the thread pool.
When the 5 seconds are up, the reply is ready, and it’s set on the exchange E.
According to the rules, when you’re using AsyncProcessor the callback must be notified when you’re done with a matching synchronous parameter F.
In this example, false is used as the synchronous parameter because the process method returned false D.
By returning false, you instruct the Camel routing engine to leverage asynchronous routing from this point forward for the given exchange.
This runs two test methods: one request is processed fully synchronously (not using the ERP component), and the other is processed asynchronously (by invoking the ERP component)
When running the test, pay attention to the console output.
The synchronous test will log input and output as follows:
Notice that both the input and output are being processed by the same thread.
The asynchronous example is different, as the console output reveals:
This time there are two threads used during the routing.
The first is the thread from Jetty, which received the HTTP request.
As you can see, this thread was used to route the message to the ErpProducer.
The other thread takes over communication with the ERP system.
When the reply is received from the ERP system, the callback is notified, which lets Camel highjack the thread and use it to continue routing the exchange.
You can see this from the last line, which shows the exchange routed to the log component.
In this chapter, we looked at thread pools, which are the foundation for concurrency in Java.
We saw how concurrency greatly improves performance and we looked at all the possible ways to create, define, and use thread pools in Camel.
You saw how easy it was to use concurrency with the numerous EIPs in Camel, and you also saw how synchronicity affects the way threading occurs in Camel.
Java provides a concurrency API, which we compared to the Camel concurrency API.
Both APIs offer you full control over submitting and executing asynchronous tasks.
Note that using concurrency requires business logic that can be invoked in a concurrent manner.
Only tweak the thread pools when you have a means of measuring the changes.
Understand the asynchronous API from Java, such as Callable and the Future handle.
If you require high scalability, try using the Camel components that support the asynchronous processing model (listed in table 10.10)
In the next chapter we get more practical and learn how to develop with Camel.
You will learn, among other things, how to start a new Camel project from scratch.
At this point you should know a thing or two about how to develop Camel routes and how to take advantage of many Camel features.
But do you know how to best start a Camel project from scratch? You could take an existing example and modify it to fit your use case, but that’s not always ideal.
And what if you need to integrate with a system that isn’t supported out of the box by Camel?
In this chapter, we’ll show you how to build your own Camel applications.
We’ll go over the Maven archetype tooling that’ll allow you to skip the boring boilerplate project setup and create new Camel projects with a single command.
We’ll also show you how to start a Camel project from Eclipse, when you need the extra power that an IDE provides.
After that, we’ll show you how to extend Camel by creating custom components and custom interceptors.
Finally, we’ll wrap up by showing you how Camel projects can be created in languages other than Java, like Scala.
Camel was built using Apache Maven right from the start, so it makes sense that creating new Camel projects is easiest when using Maven.
In this section, we’ll show you Camel’s Maven archetypes, which are preconfigured templates for creating various types of Camel projects.
After that, we’ll talk about using Maven dependencies to load Camel modules and their third-party dependencies into your project.
If you need a Maven refresher, you might want to review that section before continuing on here.
You mainly have to worry about creating a POM file and the various standard directories that you’ll be using in your project.
But if you’re creating many projects, this can get pretty repetitive because there’s a lot of boilerplate setup required for new projects.
Archetypes in Maven provide a means to define project templates and generate new projects based on those templates.
They make creating new Maven-based projects easy because they create all the boilerplate POM elements, as well as key source and configuration files useful for particular situations.
As illustrated in figure 11.1, this is all coordinated by the Maven archetype plugin.
This plugin accepts user input and replaces portions of the archetype to form a new project.
To demonstrate how this works, let’s look at the Maven quickstart archetype, which will generate a plain Java application (no Camel dependencies)
Figure 11.1 A Camel archetype and user input are processed by the Maven archetype plugin, which then creates a new Camel project.
The archetype plugin will ask you various questions, like what groupId and artifactId to use for the generated project.
When it’s complete, you’ll have a directory structure similar to this:
In this structure, myApp is the artifactId and camelinaction is the groupId.
The archetype plugin created a pom.xml file, a Java source file, and a unit test, all in the proper locations.
Without any additional configuration, Maven knows that it should compile the Java source under the src/main/java directory and run all unit tests under the src/test/ java directory.
To kick off this process, you just need to run the following Maven command:
If you want to take it a step further, you could tell Maven to create a JAR file after compiling and testing by replacing the test goal with package.
You could start using Camel right from this example project, but it would involve adding Camel dependencies like camel-core, starting up the CamelContext, and creating the routes.
Although this wouldn’t take that long, there’s a much quicker solution: you can use one of the six archetypes provided by Camel to generate all this boilerplate Camel stuff for you.
Table 11.1 lists these archetypes and their main use cases.
In section 11.5, we’ll talk more about the Scala DSL.
The project will be named order-router and the package name in the source will be camelinaction.
To create the skeleton project for this service, run the following Maven command:
You could replace this with any of the archetype names listed in table 11.1
The archetypeVersion property is set to the version of Camel that you want to use.
After a few seconds of activity, Maven will have created an order-router subdirectory in the current directory.
The order-router directory layout is shown in the following listing.
Create versus generate The Maven archetype plugin has two main goals: archetype:generate and archetype:create.
The generate goal is used when you need an interactive shell, prompting you through what you want to create.
You can select the Camel archetypes through this interactive shell as well, so it’s a useful option for developers new to Camel.
The create goal is useful when you know what you want to create up front and can enter it all on one command line.
The archetype gives you a runnable Camel project, with a sample route and test data to drive it.
The Readme.txt file tells you how to run this sample project: run mvn camel:run.
Camel will continue to run until you press Ctrl-C, which causes the context to stop.
While running, the sample route will consume files in the src/data directory and, based on the content, will route them to one of two directories.
If you look in the target/messages directory, you should see something like this:
You can start by setting up FTP and web service endpoints that route to a JMS queue for incoming orders:
At this point, if you try to run the application again using mvn camel:run, you’ll get the following error message:
Camel couldn’t find the FTP component because it isn’t on the classpath.
You’d get the same error message for the CXF and JMS endpoints.
There are, of course, other bits you have to add to your project to make this a runnable application: a test FTP server running on localhost, a CXF configuration, a JMS connection factory, and so on.
For now, we’ll focus on adding component dependencies using Maven.
To use it, you just need to add its JARs to your project’s classpath.
But using Maven to access these JARs will make your life a whole lot easier.
Camel itself was developed using Maven for this very reason.
In the previous section, you saw that using an FTP endpoint with only the camelcore module as a dependency won’t work.
You need to add the camel-ftp module as a dependency to your project.
Back in chapter 7 you saw that this was accomplished by adding the following to the dependencies section of the POM file:
This download URL is built up from Maven’s central repository URL (http://repo2.maven.org/maven2) and Maven coordinates (groupId, artifactId, and so on) specified in the dependency element.
After the download is complete, Maven will add the JAR to the project’s classpath.
One detail that may not be obvious at first is that this dependency also has transitive dependencies.
What are transitive dependencies? Well, in this case you have a project called order-router and you’ve added a dependency on camel-ftp.
The camel-ftp module also has a dependency on commons-net, among others.
So you can say that commons-net is a transitive dependency of order-router.
Transitive dependencies are dependencies that a dependency has—the dependencies of the camel-ftp module, in this case.
When you add camel-ftp as a dependency, Maven will look up camel-ftp’s POM file from the central Maven repository and look at the dependencies it has.
Maven will then download and add those dependencies to this project’s classpath.
When you add a dependency on camel-ftp to your project, you’ll also get its transitive dependencies added to your classpath.
This is a view of only a small number of dependencies, but you can recognize that the dependency tree can get quite complex.
Fortunately, Maven finds these dependencies for you and resolves any duplicate dependencies.
The bottom line is that when you’re using Maven, you don’t need to worry much about your project’s dependencies.
If you want to know what your project’s dependencies are (including transitive ones), Maven offers the dependency:tree command.
To see the dependencies in your project, run the following command:
After a few seconds of work, Maven will print out a listing like this:
Some dependencies are coming from several levels deep in the dependency tree.
Surviving without Maven As you can imagine, adding all these dependencies to your project without the help of Maven would be a bit tedious.
If you absolutely must use an alternative build system, you can still use Maven to get the required dependencies for you by following these steps:
The dependencies for camel-ftp will be located in the target/dependency directory.
You can now use these in whatever build system you’re using.
You now know all you need to develop Camel projects using Maven.
To make you an even more productive Camel developer, let’s now look at how you can develop Camel applications inside an IDE, like Eclipse.
We haven’t mentioned IDEs much so far, mostly because you don’t need an IDE to use Camel.
Certainly, though, you can’t match the power and ease of use an IDE gives you.
From a Camel point of view, having the Java or Spring DSLs autocomplete for you makes route development a whole lot easier.
The common Java debugging facilities and other tools will further improve your experience.
Because Maven is used as the primary build tool for Camel projects, we’ll show you how to use Maven tools to load up your Camel project in Eclipse.
In this section, we’ll demonstrate two ways of getting Camel projects into Eclipse: by using the Maven Eclipse plugin and by using the m2eclipse plugin for Eclipse.
The Maven Eclipse plugin can take any Maven-based project and generate an Eclipse project.
It allows you to get a Camel project into Eclipse as a plain Java project.
It offers a quick way to start Camel development, but you don’t get any frills beyond what a regular Java project would give you.
You can run this plugin on a project by executing the following command in the project’s root directory:
After this command completes, an Eclipse project will be available, having all the dependencies you listed in your POM as entries in the project’s build path.
If you run this command on the order-router project you created in the previous section, a directory listing will show that you now have three extra files and an additional directory:
Other than that, you will have to download the JARs yourself from the Maven central repo.
These are files that Eclipse interprets as a Java project.
The next step after this is to import the project into Eclipse.
The wizard dialog box should look something like what’s shown in figure 11.3
Click Finish, and your project will be imported into your Eclipse workspace.
Figure 11.4 shows an expanded view of what is inside the project.
It looks mostly like what you saw from the previous directory listing, but now it includes a list of project dependencies.
Listed to the right of each project dependency in figure 11.4 are details of where the artifact exists on your local disk.
This information contains a variable named M2_REPO, which points to your local Maven repository.
This is the area where Maven caches downloaded dependencies so you don’t download these things for every build.
This variable needs to be defined for Eclipse to access your project’s dependencies.
Open up the Preferences dialog box by selecting Window > Preferences.
In the Classpath Variables pane, you need to add a variable named M2_REPO with a path pointing to the directory of your local Maven repo (recall that this is Maven’s local cache of downloaded artifacts)
From this point on, you can develop as if this project were a regular Java project in Eclipse.
But keep in mind when adding new dependencies to your Maven POM that they won’t be automatically added to the Eclipse project.
The mvn eclipse:eclipse command will have to be run again and the project will have to be refreshed in the Package Explorer view.
When using the Maven Eclipse plugin, you’ll find yourself often darting back and forth between Eclipse and the command line.
Eclipse will be where you develop, and the command line will be where you build.
If you decide instead to use the m2eclipse plugin to develop your Camel project, you’ll experience a much nicer integration with Maven and never have to leave the IDE.
One thing that some developers will like right away is that you don’t have to leave the IDE to run Maven command-line tools during development.
You can even access the Camel archetypes right from Eclipse.
Click Next on the first screen, and you’ll be presented with a list of available archetypes, as shown in figure 11.5
For instance, if you already have a Maven project created, and you know you probably won’t be adding new dependencies, it’s much quicker to use the Maven Eclipse plugin.
It will also require a lot less system resources to develop the project in Eclipse.
M2eclipse has had performance issues in the past when you have many projects open at the same time.
The recommendation is to turn off automatic building for all projects.
This way you can control when builds get kicked off.
New versions of the plugin are improving performance all the time, so this may not be an issue in future builds.
Figure 11.5 The New Maven Project wizard allows you to generate a new Camel project right in Eclipse.
Using Camel archetypes in this way is equivalent to the technique you used back in section 11.1.1
The m2eclipse plugin will also allow you to add Maven dependencies without having to regenerate your project every time, which can be forgotten if you use the Maven Eclipse plugin.
At the time of writing, an error at Maven's central repository was preventing newer Camel archetypes from being shown in m2eclipse.
To get around this you'll need to do the following:
When creating a new project as in figure 11.5, make sure to select the catalog you just added.
This will bring up an Edit Configuration dialog box where you can specify the Maven goals to use as well as any parameters.
For the order-router project, use the camel:run goal, as shown in figure 11.6
Clicking Run in this dialog box will execute the mvn camel:run command in Eclipse, with console output showing in the Eclipse Console view.
Now you can say that you know how to create Camel projects from the command line and from Eclipse.
You’ve also seen the two ways you can develop Camel applications in Eclipse, and the pitfalls of each.
These projects only leverage what is built into Camel itself.
We’ll now move on to the more advanced topic of extending Camel itself, by developing custom components.
For most integration scenarios, there’s a Camel component available to help.
Sometimes, though, there’s no Camel component available, and you need to bridge Camel to another transport, API, data format, and so on.
You can do this by creating your own custom component.
Creating a Camel component is relatively easy, which may be one of the reasons that custom Camel components frequently show up on other community sites, in addition to the official Camel distribution.
In this section, we’ll look at how you can create your own custom component for Camel.
Just like a regular Camel project, you can start creating a new component by using a Maven archetype to generate a skeleton project.
This will generate a project structure like that shown here.
This is a fully functional “Hello World” demo component containing a simple consumer that generates dummy messages at regular intervals, and a producer that prints a message to the console.
You can run the test case included with this sample component by running the following Maven command:
One of the first things to do when developing a custom component is to decide what endpoint name to use.
This name is what will be used to reference the custom component in an endpoint URI.
For instance, to use mycomponent as the endpoint name, you need to rename the helloworld file C to mycomponent.
You should also rename the skeleton implementation classes B to better match your new component name.
This project, with the appropriate renaming, is available in the chapter11/custom directory of the book’s source.
When you change the component class name, to MyComponent, for example, you also need to modify the mycomponent file to point to this new class.
Your component can now be used in a Camel endpoint URI.
To understand how these classes make up a functioning component, you need to understand the implementation details of each.
The four classes that make up a component in Camel have been mentioned several times before.
To recap, it all starts with the Component class, which then creates an Endpoint.
We’ll first look into the Component and Endpoint implementations of the custom MyComponent component.
The first entry point into a Camel component is the class implementing the Component interface.
A component’s main job is to be a factory of new endpoints.
It does a bit more than this under the hood, but typically you don’t have to worry about these details because they’re contained in the DefaultComponent class.
This class is pretty straightforward, except perhaps for the way in which properties are set with the setProperties method.
This method takes in the properties set in the endpoint URI string, and for each will invoke a setter method on the endpoint through reflection.
Camel will take care of converting those values to the appropriate type.
The endpoint, itself, is also a relatively simple class, as shown here.
The first thing you’ll notice is that you’re deriving from another default implementation class from camel-core B.
It’s very common when creating a new Camel component to have the Component, Endpoint, Consumer, and Producer all derive from default implementations in camel-core.
This isn’t necessary, but it makes new component development much easier, and you always benefit from the latest improvements to the default implementations without having to code them yourself.
As we mentioned in chapter 7, the Endpoint class acts as a factory for both consumers and producers.
In this example, you’re creating both producers C and consumers D, which means that this endpoint can be used in a to or from Java DSL method.
Sometimes you may need to create a component that only has a producer or consumer, not both.
In that case, it’s recommended that you throw an exception, so users know that it isn’t supported:
The real bulk of most components is in the producer and consumer.
The Component and Endpoint classes are mostly designed to fit the component into Camel.
In the producers and consumers, which we’ll look at next, you have to interface with the remote APIs or marshal data to a particular transport.
The producer and consumer are where you get to implement how messages will get on or off a particular transport—in effect, bridging Camel to something else.
In your skeleton component project that was generated from an archetype, a producer and consumer are implemented and ready to go.
These were instantiated by the MyEndpoint class in listing 11.3
Like the component and endpoint classes, the producer also extends from a default implementation class from camel-core called DefaultProducer B.
The Producer interface extends from the Processor interface, so you use a process method C.
As you can probably guess, a producer is called in the same way a processor is, so the entry point into the producer is the process method.
Figure 11.8 A simplified view of a route where the consumer and producer handle interfacing with external systems.
Consumers take messages from an external system into Camel, and producers send messages to external systems.
The sample component that was created automatically has a very basic producer—it just prints the body of the incoming message to the screen D.
If you were sending to an external system instead of the screen, you’d have to handle a lot more here, such as connecting to a remote system and marshaling data.
In the case of data marshaling, it’s often a good idea to implement this using a custom TypeConverter, as described in chapter 3, which makes the converters available to other parts of your Camel application.
You can see how messages could be sent out of a route, but how do they get into a route? Consumers, like the MyConsumer class generated in your custom component project, get the messages into a route.
The Consumer interface, itself, doesn’t impose many restrictions or give any guidelines as to how a consumer should behave, but the DefaultConsumer class does, so it’s helpful to extend from this class when implementing your own consumer.
This consumer has a timer thread that will invoke the poll method every 500 milliseconds C.
Typically, a consumer will either poll a resource for a message or set up an eventdriven structure for accepting messages from remote sources.
In this example, you have no remote resource, so you can create an empty exchange and populate it with a “Hello World” message.
Here you create an empty exchange, populate it with data, and send it to the next processor in the route.
At this point, you should have a good understanding of what is required to create a new Camel component.
You may even have a few ideas about what you’d like to bridge Camel to next! Another useful way of extending Camel is by writing custom interceptors.
Interceptors in Camel are used to perform some action on a message as it goes in and out of a processor.
Features like the tracer discussed in chapter 12 use a custom interceptor to trace each message going in and out of processors.
We also talked about interceptors back in chapter 6, where you used them to simulate errors occurring on a particular endpoint.
Convenience methods built into Camel’s DSL were used in that case.
In this section, we’ll look at how you can create your own custom interceptor.
To create a new interceptor, you need to use the InterceptStrategy interface.
By implementing a custom InterceptStrategy, you gain complete control over what the interceptor does.
This method essentially wraps each processor within a route with another processor.
This wrapper processor will contain the logic you want for your interceptor.
In Camel, InterceptStrategy classes are used to implement a delay after each node in a route, to trace messages as they flow through a route, and to record performance metrics.
Figure 11.9 shows a conceptual view of how an InterceptStrategy modifies a route.
Every processor in the route shown in figure 11.9 is wrapped by an interceptor processor.
This work of modifying the route is done automatically when you add the.
You can add an InterceptStrategy directly to the CamelContext with a single method call:
You just add one as a bean, and Camel will automatically find it on startup and add it to the CamelContext.
What happens if you define more than one strategy? Figure 11.10 shows that in this case Camel will stack the interceptors used for each real processor.
You may be wondering what an actual interceptor looks like.
In the simplest case, you could just log an entry message before the processor and an exit message after the processor has completed.
Figure 11.9 Applying an InterceptStrategy to a route essentially wraps each processor with an interceptor processor.
Figure 11.10 Interceptors are stackable, meaning the more InterceptStrategy classes you add to the CamelContext, the more interceptor processors will be added before each real processor is executed.
First off, you have access to the entire CamelContext, which lets you access many different services, like the bean registry or the many type converters.
Next, and most importantly, you have access to the target processor C that you need to call, and its DSL object equivalent B.
Why was the DSL object provided? The DSL object provides richer description details than the runtime processor, so if your interceptor is, for example, graphically reporting the structure of a Camel route as it’s being used, more detailed descriptions of each node may be helpful.
It isn’t enforced by the interface, but interceptors are supposed to call the target processor D when they have done their work.
After the target processor is finished, the interceptor can do some more work before returning to the next node in the route.
In this way, an interceptor allows you to do operations before and after each processor in a route.
Sometimes, you don’t want to attach an interceptor to a particular processor.
In this case, instead of always returning a wrapped processor, you could return the target processor.
This would leave the target processor out of the interceptor scheme.
For example, you could ignore wireTap nodes from the interceptor scheme by using information from the processor’s model class:
This checks the name of the processor through its DSL object, and if it’s a wire tap, it doesn’t wrap it with an interceptor.
You’ve now seen how to develop custom Camel components and interceptors.
Let’s step outside the Java world and see how Camel can be used from other languages.
Throughout this book, we’ve focused on Camel’s two main methods of specifying routing rules: the Java DSL and Spring XML configuration.
We did this to focus on the concepts themselves, rather than how they end up being implemented, but Camel does provide advanced users with a number of options for creating routes in other JVM languages.
For instance, you can create routes in the Groovy, Scala, and Ruby languages.
The Scala DSL is probably the most mature of the three, having a custom DSL created to take advantage of language features in Scala.
In fact, another open source project called the Open eHealth Integration Platform (IPF) is a Groovy-based project built on top of Apache Camel.
In this section, we’ll take a look at how you can create Camel applications using Scala.
We’ll first look at some of the constructs you can use to create a route in Scala, and then we’ll see how to add these routes to a CamelContext.
As you may have assumed, when using the Scala DSL you’re coding in a real programming language—Scala.
In this way it’s more comparable to the Java DSL than Spring XML configuration.
Because this is the Java DSL, it also must be enclosed within a RouteBuilder class as follows:
This should look pretty familiar to you now—it’s about the simplest Camel route you can get: consuming messages from one endpoint and producing them into another endpoint.
Now let’s see what the Scala version of this route looks like:
It starts off mostly the same as the Java DSL version, with a MyRouteBuilder class extending from RouteBuilder.
You may notice that the Scala DSL route is a lot less verbose.
One of the aims of the Scala DSL was to eliminate text that didn’t add anything to the function of a route.
In the Java DSL, there’s a lot of text used to conform to the Java language.
Scala gives you a lot more freedom in creating your own operators and relaxes requirements for parentheses, dots, and semicolons.
In the previous one-line route, you have very few extraneous characters: there are two endpoint URI strings and a to operator.
The from method used in other Camel DSLs isn’t needed here; simply specifying an endpoint URI is enough to start a route.
The to operator can also be replaced with --> which may be more aesthetically pleasing to you, but it has exactly the same function as to.
There’s also no need to specify a configure method as there is in the Java DSL.
Note that in order to break this simple route into several lines of code, you would need to introduce a code block, as follows:
The ==> operator is used to start the code block, and the braces indicate the start and end of the block.
In this way, Camel will know how to end a route’s construction and add it into the CamelContext.
In the Scala DSL, a route ends after either a code line ends in the simple case, or when the code block ends if you’re using code blocks.
Learn more about Scala This isn’t a book about Scala, so many assumptions are made in this section about your knowledge of Scala.
Because Scala is quite different from Java, it’s recommended that you learn about the language fundamentals before trying to use the Scala DSL in Camel.
Otherwise, you may get frustrated by language features that are very different from Java.
The main online resource for Scala is http://www.scala-lang.org, and if you want indepth information about Scala, we recommend the book coauthored by the language’s creator, Programming in Scala by Martin Odersky, Lex Spoon, and Bill Venners.
Another must-have for Scala DSL development is a plugin for your IDE so you can avail yourself of code completion.
Scala routes are added to the CamelContext in much the same way as Java DSL routes are.
The reason you can use the same approach is that Scala ultimately compiles down to Java bytecode, so when the CamelContext is searching for a RoutesBuilder in a package you specified, it doesn’t care whether it originated from Java or Scala.
For example, to load a Scala-based route into a Spring CamelContext, you would just define the CamelContext like this:
This will pick up all Scala routes in the camelinaction package—exactly the same as for Java routes.
There may be times when you want to mix Java and Scala within a single project.
For instance, you may already have a working Java-based system using Camel, and you want to add a new route using the Scala DSL.
As we’ve said before, both Java and Scala compile down to Java bytecode, so it should be easy to mix the two.
It mostly involves setting up your Maven project to compile both types of sources and put the resultant bytecode class files in the same location.
Suppose you have a project that has Java and Scala source files as follows:
The Main class creates a new CamelContext and adds the Scala RouteBuilder MyRouteBuilder to the context as follows:
The Scala DSL and EIPs The Scala DSL doesn’t support all the EIPs that are available in the Java and Spring DSLs, but it does support most of them.
EIPs that don’t have a Scala DSL equivalent can be accessed from the Java DSL.
You can find examples of what the EIPs look like in Scala at the Apache Camel website: http://camel.apache.org/scala-dsl-eip.html.
Both Main and MyRouteBuilder are in the same package, so this should all work nicely, except that it doesn’t.
If you try to run the Main class now, you’ll get a compilation error saying MyRouteBuilder can’t be found.
It can’t be found because it hasn’t been compiled yet!
By default, Maven will compile all Java sources in src/main/java, but it has no such settings in place for Scala.
You can get around this by configuring the maven-scalaplugin as shown here.
You can configure the maven-scala-plugin to compile the Scala source in the processresources phase of your Maven build B.
The process-resources phase happens just before the compile phase C, which is where the Java source is compiled.
You didn’t specify where your Scala source was, so the maven-scala-plugin used the default location of src/main/scala.
Now all class files are saved into the target/classes folder and so will be on the same classpath when you run your application.
Listing 11.7 Configuring compilation of both Java and Scala sources.
You should now know some of the concepts needed to create routes in the Scala DSL.
This archetype was mentioned in table 11.1, earlier in the chapter.
Knowing how to create Camel projects is very important, and you may have wondered why we chose to discuss this so late in the book.
We felt it was best to focus on the core concepts first and worry about project setup details later.
Also, you should now have a better idea of what cool Camel applications you can create, having read about the features first.
At this point, though, you should be well-equipped to start your own Camel application and make it do useful work.
Before we move on, there are a few key ideas that you should take away from this chapter:
The easiest way to create Camel applications is with Maven archetypes.
Nothing is worse than having to type out a bunch of boilerplate code for new projects.
The Maven archetypes that are provided by Camel will get you started much faster.
The easiest way to manage Camel library dependencies is with Maven.
Camel is just a Java framework, so you can use whatever build system you like to develop your Camel projects.
Using Maven will eliminate many of the hassles of tracking down JAR files from remote repos, letting you focus more on your business code than the library dependencies.
It’s easy to load up a Maven-based Camel project in Eclipse.
If you find no component in Camel for your use case, create your own.
Camel allows you to write and load up your own custom components easily.
There’s even a Maven archetype for starting a custom component project.
Use interceptors to inject processing around nodes in a route.
They give you the additional power to control or monitor what’s happening inside a route.
You don’t have to write routes in Java or Spring if you don’t want to.
Next on the agenda is how to monitor and manage your Camel application.
Then we’ll look at how to deploy to a production environment.
That’s especially true for applications that sit at an intermediate tier and integrate all the business applications and partners—Camel is often in this role.
To help ensure high availability, your organization must monitor its production applications.
By doing so, you can gain important insight into the applications and foresee trends that otherwise could cause business processes to suffer.
In addition, monitoring also helps with related issues, such as operations reporting, service level agreement (SLA) enforcement, and audit trails.
It’s also vital for the operations staff to be able to fully manage the applications.
For example, if an incident occurs, staff may need to stop parts of the application Management and monitoring.
You’ll also need management capabilities to carry out scheduled maintenance or upgrades of your applications.
Management and monitoring are often two sides of the same coin.
For example, management tooling includes monitoring capabilities in a single coherent dashboard, allowing a full overview for the operations staff.
In this chapter, we’ll review different strategies for monitoring your Camel applications.
We’ll first cover the most common approach, which is to check on the health of those applications.
Then we’ll look at the options for tracking activity and managing those Camel applications.
It’s standard practice to monitor systems with periodic health checks.
For people, checking one’s health involves measuring parameters at regular intervals, such as pulse, temperature, and blood pressure.
By checking over a period of time, you not only know the current values but also trends, such as whether the temperature is rising.
All together, these data give insight into the health of the person.
For a software system, you can gather system-level data such as CPU load, memory usage, and disk usage.
You can also collect application-level data, such as message load, response time, and many other parameters.
This data tells you about the health of the system.
Checks on the health of Camel applications can occur at three levels:
Network level—This is the most basic level, where you check that the network connectivity is working.
The JVM exposes a standard set of data using the JMX technology.
Application level—Here you check the Camel application using JMX or other techniques.
To perform these checks, you need different tools and technologies.
Java Management Extensions (JMX) is another technology that offers similar capabilities to SNMP.
You might use a mix of both: SNMP is older and more mature and is often used in large system-management tools such as IBM Tivoli, HP OpenView, and Nagios.
JMX, on the other hand, is a pure Java standard and is used by Fuse HQ and Hyperic.
In the following sections, we’ll go over the three levels and look at some approaches you can use for performing automatic and periodic health checks on your Camel applications.
The most basic health check you can do is to check whether a system is alive.
You may be familiar with the ping command, which you use to send a ping request to a remote host.
Camel doesn’t provide a ping service out of the box, but creating such a service is easy.
The ping service only reveals whether Camel is running or not, but that will do for a basic check.
Suppose you have been asked to create such a ping service for Rider Auto Parts.
The service is to be integrated with the existing management tools.
You choose to expose the ping service over HTTP, which is a universal protocol that the management tool easily can leverage.
Implementing the service in Camel is easy using the Jetty component.
All you have to do is expose a route that returns the response, as follows:
When the service is running, you can invoke an HTTP GET, which should return the PONG response.
You can try this on your own with the book’s source code.
Then invoke the HTTP GET using either a web browser or the curl command:
The ping service can be enhanced to leverage the JVM and Camel APIs to gather additional data about the state of the internals of your application.
Another use for the ping service is when using a load balancer in front of multiple instances of Camel applications.
This is often done to address high availability, as shown in figure 12.2
The load balancer will call the ping service to assess whether the particular Camel instance is ready for regular service calls.
Monitoring tool HTTP Figure 12.1 A monitoring tool monitors Camel with a ping service by sending periodic HTTP GET requests.
Figure 12.2 The load balancer uses health checks to ensure connectivity before it lets the service calls pass through.
Network-level checks offer a quick and coarse assessment of the system’s state of health.
Let’s move on to the JVM level, where you monitor Camel using JMX.
The Simple Network Management Protocol (SNMP) is a standard for monitoring network-attached devices.
It’s traditionally used to monitor the health of servers at the OS level by checking parameters such as CPU load, disk space, memory usage, and network traffic, but it can also be used to check parameters at the application level, such as the JVM.
Java has a built-in SNMP agent that exposes general information, such as memory and thread usage, and that issues notifications on low memory conditions.
This allows you to use existing SNMP-aware tooling to monitor the JVM where Camel is running.
There is also a wide range of commercial and open source monitoring tools that use SNMP.
Some are simpler and have a shell interface, and others have a powerful GUI.
You may work in an organization that already uses a few selected monitoring tools, so make sure these tools can be used to monitor your Camel applications as well.
The SNMP agent in the JVM is limited to only exposing data at the JVM level; it can’t be used to gather information about the Java applications that are running.
JMX, in contrast, is capable of monitoring and managing both the JVM and the applications running on it.
In the next section, we’ll look at how you can use JMX to monitor Camel at the JVM and application levels.
Camel provides JMX monitoring and management out of the box in the form of an agent that leverages the JMX technology.
Figure 12.3 JConsole connects remotely to an MBean server inside the JVM, which opens up a world of in-depth information and management possibilities for Camel instances.
The JMX agent exposes remotely (over Remote Method Invocation) a wealth of standard details about the JVM, and some Camel information as well.
The former is standard in the JDK, and the latter is provided by Camel.
The most prominent feature the Camel JMX agent offers is the ability to remotely control the lifecycle of any service in Camel.
For example, you can stop routes and later bring those routes into action again.
So how do you use JMX with Camel? Camel comes preconfigured with JMX enabled at the developer level, by which we mean that Camel allows you to connect to the JVM from the same localhost where the JVM is running.
If you need to manage Camel from a remote host, you’ll need to explicitly enable this in Camel.
We think this is important to cover thoroughly, so we’ve devoted the next section to this topic.
To use JMX with Camel, you need the following four Spring JAR files on the classpath:
These JARs are needed because Camel uses Spring JMX to expose its managed beans to the JMX server.
Using Spring JMX is much easier than using the low-level clumsy JMX API.
With Spring JMX, you can add a few JMX annotations in the Camel codebase to expose the information you want to manage from JMX.
When Camel starts, it logs at INFO level whether JMX is enabled or not:
If those four Spring JARs are missing, Camel will report it as follows:
With Maven, it’s easy to ensure that the JARs are included in the classpath—you just add a dependency for the camel-spring component:
If you don’t want to use camel-spring, you can add the aforementioned four JAR files individually.
Now let’s look at how to use a simple management tool with Camel.
You’ll use it to connect to a Camel instance and see what information is available.
You can do this from the chapter12/ health directory using this Maven command:
Then, from another shell, you can start JConsole by invoking jconsole.
When JConsole starts, it displays a window with two radio buttons.
The Remote radio button is used for remote management, which we’ll cover shortly.
The Local should already list a process, and you can click the Connect button to connect JConsole to the Camel instance.
Figure 12.4 shows the Camel MBeans (Management Beans) that are visible from JConsole.
Figure 12.4 Camel registers numerous MBeans that expose internal details, such as usage statistics and management operations.
Camel registers many MBeans that expose statistics and operations for management.
Those MBeans are divided into nine categories, which are listed in table 12.1
Most MBeans expose a set of standard information and operations, concerning things such as lifecycle.
We encourage you to spend a moment browsing the MBeans in JConsole to see what information they provide.
When you need to monitor and manage a Camel instance from a remote computer, you must enable remote management in Camel.
To be able to remotely manage Camel, you need to instruct Camel to register a JMX connector.
We’ll go over each of these three methods in the following sections.
By specifying the following JVM property on JVM startup, you can tell Camel to create a JMX connector for remote management:
Consumers Lists all the input consumers for the Camel routes.
Some consumers have additional information and operations, such as the JMS, Timer, and File/FTP consumers.
This is the MBean you need if you want to shut down Camel.
You can manage error handling at runtime, such as by changing the number of redelivery attempts or the delay between redeliveries.
Here you can obtain route statistics, such as the number of messages completed, failed, and so on.
Here you can obtain statistics about the number of threads currently active and the maximum number of threads that have been active.
You can also adjust the core and maximum pool size of the thread pool.
The Tracer is a Camel-specific service that’s used for tracing how messages are routed at runtime.
We’ll cover the use of the Tracer in detail in section 12.3.4
If you do this, Camel will log, at INFO level on startup, the JMX service URL that’s needed to connect.
To connect to a remote JMX agent, you can use the Remote radio button from JConsole and enter the service URL listed in the log.
You can configure it to allow remote connections as shown here:
The agent can also configure the registry port by using the setRegistryPort method.
But there is a simpler way: you can configure the settings directly using the ManagementAgent, as follows:
If you use Spring XML with Camel, configuring a JMX connector is even easier.
You may have noticed that this example doesn’t provide any credentials when connecting to a JMX agent.
This may not be appropriate in production environments, so you can enable authentication with JMX.
Now that you’ve seen how to check the health of your applications, it’s time to learn how to keep an eye on what your applications are doing.
Beyond monitoring an application’s health, you need to ensure it operates as expected.
For example, if an application starts malfunctioning or has stopped entirely, it may harm business.
There may also be business or security requirements to track particular services for compliance and auditing.
A Camel application used to integrate numerous systems may often be difficult to track because of its complexity.
It may have inputs using a wide range of transports, and schedules that trigger more inputs as well.
Routes may be dynamic if you’re using content-based routing to direct messages to different destinations.
And there are errors occurring at all levels related to validation, security, and transport.
Confronted with such complexity, how can you keep track of the behavior of your Camel applications?
You do this by tracking the traces that various activities leave behind.
By configuring Camel to leave traces, you can get a fairly good insight into what’s going on, both in real time and after the fact.
Activity can be tracked using logs, whose verbosity can be configured to your needs.
Camel also offers a notification system that you can leverage.
Let’s look at how you can use log files and notifications to track activities.
Monitoring tools can be tailored to look for patterns, such as error messages in logs, and they can use pattern matching to react appropriately, such as by raising an alert.
Log files have been around for decades, so any monitoring tool should have good support for efficient log file scanning.
Even if this solution sounds basic, it’s a solution used extensively in today’s IT world.
Log files are read not only by monitoring tools but also by people, such as operations, support, or engineering staff.
That puts a burden on both Camel and your applications to produce enough evidence so that both humans and machines can diagnose the issues reported.
Camel offers four options for producing logs to track activities:
Using core logs—Camel logs various types of information in its core logs.
Using custom logging—You can leverage Camel’s logging infrastructure to output your own log entries.
You can do this from different places, such as from the.
You can also use regular logging from Java code to output logs from your custom beans.
Using Tracer—Tracer is used for tracing how and when a message is routed in Camel.
Camel logs, at INFO level, each and every step a message takes.
Camel emits a lot of information at DEBUG logging level and an incredible amount at TRACE logging level.
These levels are only appropriate for development, where the core logs provide great details for the developers.
In production, you’ll want to use INFO logging level, which generates a limited amount of data.
At this level, you won’t find information about activity for individual messages—for that you need to use notifications or the Tracer, which we’ll cover in section 12.3.4
The core logs in production usage usually only provide limited details for tracking activity.
Important lifecycle events such as the application being started or stopped are logged, as are any errors that occur during routing.
Custom logging is useful if you’re required to keep an audit log.
With custom logging, you’re in full control of what gets logged.
In EIP terms, it’s the Wire Tap pattern that describes this problem.
By tapping into an existing route, you can tap messages to an audit channel.
This audit channel, which is often an internal queue (SEDA or VM transport), is then consumed by a dedicated audit service, which takes care of logging the messages.
At Rider Auto Parts, you’re required to log any incoming orders.
Figure 12.5 shows the situation where orders flowing in from CSV files are wiretapped to an audit service before moving on for further processing.
Figure 12.5 Using a wire tap to tap incoming files to an audit service before the file is translated to XML and sent to an order queue for further processing.
Implementing the routes outlined in figure 12.5 in Camel is fairly straightforward:
These are wire-tapped to an internal SEDA queue ("seda:audit") for further processing.
The messages are then transformed from CSV to XML using the OrderCsvToXmlBean bean before being sent to a JMS queue.
It consumes the tapped messages and processes them with an AuditService bean, which follows:
This implementation of the AuditService bean has been kept simple by logging the audit messages using the Apache Commons Logging log kit.
The source code for the book contains this example in the chapter12/logging directory, which you can try using the following Maven goal:
Camel provides a Log component that’s capable of logging the Camel Message using a standard format at certain interesting points.
To leverage the Log component, you simply route a message to it, as follows:
In this route, you use the Log component in two places.
The first is to log the incoming file, and the second is after the transformation.
You can try this example using the following Maven goal from the chapter12/ logging directory:
If you run the example, it will log the following:
By default, the Log component will log the message body and its type at INFO logging level.
Notice that in the first log line, the type is GenericFile, which represents a java.io.File in Camel.
In the second log line, the type has been changed to String, because the message was transformed to a String using the OrderCsvToXmlBean bean.
You can customize what the Log component should log by using the many options it supports.
For example, to make the messages less verbose, you can disable showing the body type and limit the length of the message body being logged by using the following configuration:
The Log component is used to log information from the Exchange, but what if you want to log a message in a custom way? What you need is something like System.
It’s primarily meant for developers, so they can quickly output a message to the log console.
But that doesn’t mean you can’t use it for other purposes as well.
Suppose you want to log the filename you received as input.
This is easy with the Log EIP—all you have to do is pass in the message as a String:
You can run this example using the following Maven goal from the chapter12/ logging directory:
If you run this example, it will log the following:
The Log EIP will, by default, log at INFO level using the route ID as the logger name.
In this example, the route was not explicitly named, so Camel assigned it the name route1
Using the Log EIP from Spring XML is also easy, as shown here:
The Spring example is also provided in the source code for the book, which you can try using the following Maven goal:
The Log EIP also offers options to configure the logging level and log name, in case you want to customize those as well, as shown below in Spring XML:
In the Java DSL, the logging level and log name are the first two parameters.
When logging messages in a system, the messages being processed can easily get interleaved, which means the log lines will be interleaved as well.
What you need is a way to correlate those log messages so you can tell which log lines are from which messages.
You do this by assigning a unique ID to each created message.
To help understand how and when messages are being routed, Camel offers Tracer, which logs message activity as it occurs.
Tracer’s role is to trace how and when messages are routed in Camel.
It does this by intercepting each message being passed from one node to another during routing.
You may remember being told that Camel has a Channel sitting between each node in a route—at points B, C, and D in figure 12.6
The Channel has multiple purposes, such as error handling, security, and interception.
Because the Tracer is implemented as an interceptor, it falls under the control of the Channel, which at runtime will invoke it.
To use the Tracer, you need to enable it, which is easily done in either the Java DSL or Spring XML.
In Spring XML, you enable the Tracer from <camelContext> as follows:
When running with Tracer enabled, Camel will record trace logs at INFO level, which at first may seem a bit verbose.
To reduce the verbosity, we have configured the Tracer to not show properties and headers.
Figure 12.6 Tracer sits between each node in the route (at B, C, and D) and traces the message flow.
The interesting thing to note from the trace logs is that the log starts with the exchange ID, which you can use to correlate messages.
You may wonder why we have two IDs when there is only one incoming message.
That’s because the wire tap creates a copy of the incoming message, and the copied message will use a new exchange ID because it’s being routed as a separate process.
Next, the Tracer outputs which route the message is currently at, followed by the from --> to nodes.
This is probably the key information when using Tracer, because you can see each individual step the message takes in Camel.
Then the Tracer logs the message exchange pattern, which is either InOnly or InOut.
Finally, it logs the information from the Message, just as the Log component would do.
For example, you could delay and tail the log file, watching what happens in the log file while the message is being routed, to get a better understanding of what’s going on.
You can learn more about the Delay interceptor in the Camel documentation: http://camel.apache.org/delayinterceptor.html.
We just said that we had customized the Tracer to be less verbose.
This can be done by defining a bean in the Registry with the bean ID traceFormatter.
In Spring XML this is easy—all you do is this:
The formatter has many other options that you can read about in its online documentation (http://camel.apache.org/tracer)
If you have many routes, the Tracer will output a lot of logs.
Fortunately, you can customize the Tracer to only trace certain routes.
You can even do this at runtime using JMX, but we’ll get to that a bit later.
Suppose you only wanted to trace the first route—you could enable the Tracer on that particular route, as shown here:
If a route isn’t explicitly configured with a Tracer, it will fall back and leverage the configuration from the CamelContext.
This allows you to quickly turn tracing on and off from the CamelContext but still have some special routes with their own settings.
This allows you to enable tracing for a while to see what happens and identify issues.
The Tracer can be managed from the JMX console in two places.
You can enable or disable tracing at either the context or at routes.
For example, to enable tracing globally, you could change the tracing attribute to true at the CamelContext MBean.
You could do the same on a per route basis using the Routes MBeans.
You can configure what the Tracer logs from the Tracer MBean, as shown in figure 12.7
We’ve prepared an example for you to try in the source code for the book.
This will start an application that will run for a while.
Click on the value for the Tracing attribute, which should be editable.
You should be able to see the changes in the console logged by the application.
For example, change some of the other options on the Tracer.
Monitoring applications via the core logs, custom logging, and Tracer is like looking into Camel’s internal journal after the fact.
If the log files get very big, it may feel like you’re looking for a needle in a haystack.
Sometimes you might prefer to have Camel call you when particular events occur.
Figure 12.7 Managing the Tracer from JMX allows you to customize the trace logging and change many attributes at runtime.
For fine-grained tracking of activity, Camel’s management module offers notifiers for handling internal notifications.
These notifications are generated when specific events occur inside Camel, such as when an instance starts or stops, when an exception has been caught, or when a message is created or completed.
The notifiers subscribe to these events as listeners, and they react when an event is received.
Camel uses a pluggable architecture, allowing you to plug in and use your own notifier, which we’ll cover later in this section.
This means you can use log4j, which has a broad range of appenders that can dispatch log messages to remote servers using UDP, TCP, JMS, SNMP, email, and so on.
This allows you to leverage Camel transports to broadcast the message any way you want.
For example, management and monitoring tooling can be used to subscribe to the notifications.
You’ll learn in the following sections how to set up and use an event notifier and how to build and use a custom notifier.
Figure 12.8 To enable tracing, select the CamelContext under the Context node and change the Tracing attribute from false to true.
That’s why the notifier is configured by default to not generate new events during processing of events.
Camel doesn’t use event notifiers by default, so to use a notifier you must configure it.
This is done by setting the notifier instance you wish to use on the ManagementStrategy.
When using the Java DSL, this is done as shown here:
Then you set the log name you wish to use.
In this case, you’re only interested in some of the events, so you ignore the ones you aren’t interested in.
The configuration when using Spring XML is a bit different, because Camel will pick up the notifier automatically when it scans the registry for beans of type EventNotifier on startup.
This means you just have to declare a Spring bean, like this:
You can also write your custom EventNotifier instead of using the built-in notifiers.
Rider Auto Parts wants to integrate an existing Camel application with the company’s centralized error log database.
They already have a Java library that’s capable of publishing to the database, and this makes the task much easier.
The following listing shows the important snippets of how to implement this.
If you don’t want to extend this class, you can implement the EventNotifier interface instead.
You use an instanceof test to filter for the events you’re interested in, which are failure events B.
Then information is extracted from the event, such as the unique exchange ID and the exception message to be published.
This information is then published using the existing Java library C.
The source code for the book contains this example in the chapter12/notifier directory, which you can try using the following Maven goal:
Listing 12.1 A custom event notifier publishes failure events to a central log database.
Figure 12.9 Failure events must be published into the centralized error log database using the custom RiderEventNotifier.
You learned to use Camel’s standard logging capabilities and to roll a custom solution when needed.
In the next section, we’ll take a further look at how to manage both Camel and your custom Camel components.
We already touched on how to manage Camel in section 12.2, where we covered how to use JMX with Camel.
In this section, we’ll take a deeper dive into managementrelated use cases and show how you can management-enable your custom Camel components and services.
We’ll start by looking at how you can manage the lifecycles of your Camel applications.
It’s essential to be able to manage the lifecycles of your Camel applications.
You should be able to stop and start Camel in a reliable manner, and you should be able to pause or stop a Camel route temporarily, to avoid taking in new messages while an incident is being mitigated.
To do this, you connect to the application with JMX as you learned in section 12.2
Figure 12.10 shows JConsole with the route in question selected.
You can view its attributes, which reveal various stats such as the number of exchanges completed and failed, its performance, and so on.
The State attribute displays information about the lifecycle—whether it’s started or stopped.
To stop the route, select the Operations entry and click the stop operation.
Then return to the Attributes entry and click the Refresh button to update the attributes.
You should see the State attribute’s value change to Stopped.
Starting and stopping routes is a common thing to do, but what if you want to adjust how the routes behave at runtime? Camel allows you to manage the consumers, and you can adjust them at runtime.
Imagine you have a route that uses a file consumer to pick up new files, and you want to change the polling interval for the file consumer.
Figure 12.11 shows how you can do this by selecting the file consumer under consumers in the MBean tree.
You can then change the Delay attribute by clicking on it and editing it.
You have to restart the consumer, which is done by invoking the stop and then the start operation.
You may have built some Camel components of your own that you would like to manage.
Suppose Rider Auto Parts has developed a Camel ERP component to integrate with their ERP system, and the operations staff has requested that the component be managed.
The component has a verbosity switch that should be exposed for management.
Running with verbosity enabled allows the operations staff to retrieve additional information from the logs, which is needed when some sort of issue has occurred.
Listing 12.2 shows how you can implement this on the ERPEndpoint class, which is part of the ERP component.
This code listing has been abbreviated to show only the relevant parts of the listing—the full example is in the source code for the book in the chapter12/custom directory.
Figure 12.11 Adjusting a file consumer at runtime by changing the Delay attribute.
If you’ve ever tried using the JMX API to expose the management capabilities of your custom beans, you’ll know it’s a painful API to leverage.
It’s better to go for the easy solution and leverage Spring JMX.
In the same way, you can expose the verbose property as a managed attribute by using the @ManagedAttribute C annotation on the getter and setter methods.
What remains is to tell Camel to enlist this MBean for management, which is done by implementing the ManagementAware interface.
This interface brings in the getManagedObject method D, where you simply return this.
You can run the following Maven goal from chapter12/custom directory to try out this example:
When you do, the console will output a log line every 5 seconds, as the route below illustrates:
What you want to do now is turn on the verbose switch from your custom ERP component.
As you can see in figure 12.12, your custom component is listed under endpoints as erp://foo, which was the URI used in the route.
If you change this value to true, the console should immediately reflect this change.
The first two of the following lines are from before the verbose switch was enabled.
When the switch is enabled, it starts to output Calling ERP..., as shown below:
A Camel component consists of several classes, such as Component, Endpoint, Producer, and Consumer, and you can management-enable any of those.
For example, the schedule-based components, such as the Timer, allow you to manage the consumers to adjust how often they should trigger.
Congratulations! You have now learned all there is to managing Camel applications and enlisting your custom components for management.
Figure 12.12 Enabling the Verbose attribute at runtime using JConsole.
A sound strategy for monitoring your applications is necessary when you take them into production.
Your organization may already have strategies that must be followed for running and monitoring applications.
In this chapter, we looked at how you can monitor your Camel applications using health-level checks.
You learned that existing monitoring tools could be used via SNMP or JMX protocols.
Using JMX allows you to manage Camel at the application level, which is essential for lifecycle management, and performing functions such as stopping a route.
We also looked at what Camel has to offer in terms of logging.
You learned about the Camel logs and how you can use custom logging.
We also covered the Camel notification system, which is pluggable, allowing you to hook in your own notification adapter and send notifications to a third party.
You should involve the operations team early in the project’s lifecycle.
Your organization likely already has procedures for managing applications, which must be followed.
For example, develop a happy page that does an internal health check and reports back on the status.
A happy page can then easily be accessed from a web browser and monitoring tools.
When something goes wrong, you want the operations staff receiving the alert to be able to understand what the error is all about.
If you throw exceptions from business logic, include descriptive information about what’s wrong.
If messages aren’t being routed as expected, you can enable the Tracer to see how they’re actually being routed.
But beware; the Tracer can be very verbose and your logs can quickly fill up with lines if your application processes a lot of messages.
Have developers read the log files to see which exceptions have been logged.
This can help them preemptively fix issues that otherwise could slip into production.
Management and monitoring aren’t the sole tasks the operations staff plays with regards to your Camel applications.
The staff is also very much involved in the deployment process, taking your applications into production.
The next chapter covers this topic, walking through the various deployment strategies.
In the previous chapter, you learned all about monitoring and managing Camel.
We’ll now shift focus to another topic that’s important to master: running and deploying Camel applications.
We’ll start with the topic of running Camel—you’ll need to fully understand how to start, run, and shut down Camel reliably and safely, which is imperative in a production environment.
We’ll also review various options you can use to tweak how Camel and routes are started.
We’ll continue on this path, looking at how you can dynamically start and stop routes at runtime.
Your applications won’t run forever, so we’ll spend some time focusing on how to shut down Camel in a safe manner.
The other part of the chapter covers various strategies for deploying Camel.
We’ll take a look at four common runtime environments supported by Camel.
As we discuss these topics, we’ll work through an example involving Rider Auto Parts.
You’ve been asked to help move a recently developed application safely into production.
The application receives inventory updates from suppliers, provided via a web service or files.
In chapter 1, you learned how to download, install, and run Camel.
That works well in development, but the game plan changes when you take an application into production.
Starting up a Camel application in production is harder than you might think, because the order in which the routes are started may have to be arranged in a certain way to ensure a reliable startup.
It’s critical that the operations staff can safely manage the application in their production environment.
Often it’s the server (container) that Camel is running inside that invokes the start method on CamelContext, starting up Camel.
This is also what you saw in chapter 1, where you used Camel inside a standalone Java application.
A standalone Java application isn’t the only deployment choice—you can also run Camel inside a container such as Spring or OSGi.
Regardless of which container you use, the same principle applies.
The container must prepare and create an instance of CamelContext up front, before Camel can be started, as illustrated in figure 13.2
Figure 13.1 A Rider Auto Parts application accepting incoming inventory updates from either files or a web service.
Creates Figure 13.2 Using Camel with containers often requires the container in question to prepare and create CamelContext up front before it can be started.
Because Spring is a common container, we’ll outline how Spring and Camel work together to prepare a CamelContext.
When using Camel in the Spring XML file, you would define the <camelContext> tag as follows:
What happens next is the same regardless of which container or deployment option you’re using with Camel.
Figure 13.3 shows a flow diagram of the startup process.
The first step in figure 13.3 determines whether or not autostartup is enabled for Camel.
By default, Camel is set to autostart, which involves the following four steps.
Figure 13.3 Flow diagram showing how Camel starts by starting internal services, computing the starting order of routes, and preparing and starting the routes.
Start internal services—Prepares and starts internal services used by Camel, such as the type-converter mechanism.
Compute starting order—Computes the order in which the routes should be started.
By default, Camel will start up all the routes in the order they are defined in the Spring XML files or the RouteBuilder classes.
We’ll cover how to configure the order of routes in section 13.1.3
After step 4, Camel writes a message to the log indicating that it has been started and that the startup process is complete.
In some cases, you may need to influence how Camel is started, and we’ll look at that now.
Camel offers various options when it comes to starting Camel.
For example, you may have a maintenance route that should not be autostarted on startup.
You may also want to enable tracing on startup to let Camel log traces of messages being routed.
The options from table 13.1 can be divided into two kinds.
The first four options are related to startup and shutdown, and the remainder are miscellaneous options.
We’ll look at how to use the miscellaneous options first, and then we’ll turn our attention to the startup and shutdown options.
AutoStartup This option is used to indicate whether or not the route should be started automatically when Camel starts.
StartupOrder This option dictates the order in which the routes should be started when Camel starts.
ShutdownRoute This option is used to configure whether or not the route in question should stop immediately or defer while Camel is shutting down.
Tracing This option is used to trace how an exchange is being routed within that particular route.
Delayer This option is used to set a delay in milliseconds that slows down the processing of a message.
You can use this during debugging to reduce how quickly Camel routes messages, which may help you track what happens when you watch the logs.
The miscellaneous options are often used during development to turn on additional logging, such as the Tracing option, which we covered in the last chapter.
Or you may need to turn on stream caching if you use Camel with other stream-centric systems.
For example, to enable stream caching, you can do the following with the Java DSL:
The same example using Spring XML would look like this:
All the options from table 13.1 can be scoped at either context or route level.
The preceding stream cache example was scoped at context level.
HandleFault This option is used to turn fault messages into exceptions.
This is not a typical thing to do in a pure Camel application, but when deployed into a JBI container like Apache ServiceMix, you’ll need to set this option to let the Camel error handler react to faults.
StreamCaching This option is used to cache streams that otherwise couldn’t be accessed multiple times.
You may want to use this when you use redelivery during error handling, which requires being able to read the stream multiple times.
You can configure route-scoped stream caching in Spring XML as follows:
There is one last detail to know about the context and route scopes.
The context scope is used as a fallback if a route doesn’t have a specific configuration.
The idea is that you can configure the default setting on the context scope and then override when needed at the route scope.
For example, you could enable tracing on the context scope and then disable it on the routes you don’t want traced.
In the preceding example, you route messages using the JBI component.
The HandleFault option is used to control whether or not Camel error handling should react to faults.
Suppose sending to the jbi:service:http://rider.com/HtmlService endpoint fails with a fault.
Without HandleFault enabled, the fault would be propagated back to the consumer.
By enabling HandleFault, you can let the Camel error handler react when faults occur.
The following code shows how you can let the DeadLetterChannel error handler save failed messages to files in the error directory:
We’ll now look at how to control the ordering of routes.
The order in which routes are started and stopped becomes more and more important the more interdependent the routes are.
For example, you may have reusable routes that must be started before being leveraged by other routes.
Also, routes that immediately consume messages that are bound for other routes may have to be started later to ensure that the other routes are ready in time.
To control the startup order of routes, Camel provides two options: AutoStartup and StartupOrder.
The former dictates whether the routes should be started or not.
The latter is a number that dictates the order in which the routes should be started.
Let’s return to our Rider Auto Parts example, outlined at the beginning of the chapter.
Figure 13.4 shows the high-level diagram again, this time numbering the three routes in use, B, C, and D.
The following listing shows the Camel routes with the StartupOrder options in boldface.
Figure 13.4 Camel application with two input routes B and C which depend on a common route D.
Listing 13.1 shows how easy it is in the Java DSL to configure the order of the routes using StartupOrder.
Let’s take a moment to see how this works in Camel.
The StartupOrder option in Camel works much like the load-on-startup option for Java servlets.
As with servlets, you can specify a positive number to indicate the order in which the routes should be started.
All that matters is that the numbers must be unique.
You can also omit assigning a StartupOrder to some of the routes.
In that case, Camel will assign these routes a unique number starting with 1,000 upwards.
In practice, you may not need to use StartupOrder often.
It’s only important when you have route dependencies, as in the previous example.
The source code for the book contains this example in the chapter13/startup directory.
You can try it out using the following Maven goals:
You’ve now learned to control the order in which routes are started.
Let’s move on and take a look at how you can omit starting certain routes and start them on demand later, at runtime.
Table 13.1 listed the AutoStartup option, which is used to specify whether or not a given route should be automatically started when Camel starts.
Sometimes you may not want to start a route automatically—you may want to start it on demand at runtime to support business cases involving human intervention.
At Rider Auto Parts, there has been a demand to implement a manual process for updating the inventory based on files.
As usual, you’ve been asked to implement this in the existing application depicted in figure 13.4
You come up with the following solution: add a new route to the existing routes in listing 13.1
The new route listens for files being dropped in the manual directory, and uses these files to update the inventory.
As you can see, the route is merely a copy of the file-based route in listing 13.1
The route is always active, so if someone accidentally drops a file into the manual folder, it would be picked up.
To solve this problem, you use the AutoStartup option to disable the route from being activated on startup:
You can start the route when a manual file is meant to be picked up.
This can be done by using a management console, such as JConsole, to manually start the route, waiting until the file has been processed, and manually stopping the route again.
You’ve now learned how to configure Camel with various options that influence how it starts up.
In the next section, we’ll look at various ways of programmatically controlling the lifecycle of routes at runtime.
In chapter 12, you learned how to use management tooling, designed for operations staff, to start and stop routes at runtime.
Being able to programmatically control routes at runtime is also desirable.
For example, you might want business logic to automatically turn routes on or off at runtime.
In this section, we’ll look at how to do this.
You can start and stop routes at runtime in several ways, including these:
If you have remote management enabled, you can control the routes from another machine.
The use of JMX was covered in the previous chapter, so we’ll discuss using CamelContext and RoutePolicy in this chapter.
The CamelContext provides methods to easily start and stop routes.
To illustrates this, we’ll continue with the Rider Auto Parts example from section 13.1.4
About a month into production with the new route, one of the operations staff forgot to manually stop the route after use, as he was supposed to.
Not stopping the route leads to a potential risk because files accidentally dropped into the manual directory will be picked up by the route.
You are again summoned to remedy this problem, and you quickly improve the route with the two changes shown in bold in the following listing.
The first change uses the maxMessagesPerPoll option to tell the file consumer to only pick up one file at a time.
The second change stops the route after that one file has been processed.
This is done with the help of the inlined Processor, which can access the CamelContext and tell it to stop the route by name.
CamelContext also provides a startRoute method for starting a route.
Before you stop the route, you must unregister the current exchange from the in-flight registry, which otherwise would prevent Camel from stopping the route, because it detects there is an exchange in progress.
The source code for the book contains this example, which you can try from the chapter13/startup directory using the following Maven goal:
Even though the fix to stop the route was simple, using the inlined processor at the end of the route isn’t an optimal solution.
It would be better to keep the business logic separated from the stopping logic.
OnCompletion is a feature that allows you to do additional routing after the original route is done.
The classic example would be to send an email alert if a route fails, but it has a broad range of uses.
Listing 13.3 After a file has been processed, the route is stopped.
Instead of using the inlined processor to stop the route, you can use OnCompletion in the RouteBuilder to process the StopRouteProcessor class containing the logic to stop the route.
The implementation of the StopRouteProcessor is simple, as shown here:
This improves the readability of the route, as it’s shorter and doesn’t mix high-level routing logic with low-level implementation logic.
By using OnCompletion, the stopping logic has been separated from the original route.
Scopes can be used to define OnCompletions at different levels.
Camel supports two scopes: context scope (high level) and route scope (low level)
If you wanted to use route scope, you’d have to define it within the route as follows:
Notice the use of .end() to indicate where the OnCompletion route ends.
You have to do this when using route scope so Camel knows which pieces belong to the additional route and which to the original route.
This is the same principle as when you use OnException at route scope.
In addition, OnCompletion can be configured to only trigger when the route completes successfully or when it fails by using the OnCompleteOnly or OnFailureOnly options.
For example, you can use OnFailureOnly to build a route that sends an alert email to support personnel when a route fails.
The source code for the book contains this example in the chapter13/startup directory.
We’ve now covered how to stop a route at runtime using the CamelContext API.
We’ll now look at another feature called RoutePolicy, which can also be used to control the lifecycle of routes at runtime.
A RoutePolicy is a policy that can control routes at runtime.
For example, a RoutePolicy can control whether or not a route should be active.
But you aren’t limited to such scenarios—you can implement any kind of logic you wish.
The idea is that you implement this interface, and Camel will invoke the callbacks when a route has just begun and when it’s done.
You’re free to implement whatever logic you want in these callbacks.
Let’s build a simple example using RoutePolicy to demonstrate how to flip between two routes, so only one route is active at any time.
As you can see in this figure, the RoutePolicy is being used to control the two routes, starting and stopping them so only one is active at a time.
Figure 13.5 RoutePolicy changes the active state between the two routes so only one route is active at any time.
In the constructor, you identify the names of the two routes to flip B.
As you extend the RoutePolicySupport class, you only override the onExchangeDone method, as the flipping logic should be invoked when the route is done.
You then compute which of the two routes to stop and start with the help of the route parameter, which denotes the current active route.
Having computed that, you then use CamelContext to flip the routes C.
If an exception is thrown, you let the ExceptionHandler take care of it, which by default will log the exception.
To use FlipRoutePolicy, you must assign it to the two routes.
In the Java DSL, this is done using the RoutePolicy method, as shown in the following RouteBuilder:
If you’re using Spring XML, you can use RoutePolicy as shown here:
Listing 13.4 A RoutePolicy that flips two routes being active at runtime.
As you can see, you use the routePolicyRef attribute on the <route> tag to reference the flipPolicy bean defined in the top of the XML file.
When running either of the examples, you should see the two routes being logged interchangeably (foo and bar)
We’ve now covered both starting and controlling routes at runtime.
It’s time to learn about shutting down Camel, which is more complex than it sounds.
The new inventory application at Rider Auto Parts is scheduled to be in production at the end of the month.
You’re on the team to ensure its success and help run the final tests before it’s handed over to production.
Shutting down the Camel application is complex because there may be numerous in-flight messages being processed.
Shutting down while messages are in flight may harm your business because those messages could potentially be lost.
So the goal of shutting down a Camel application reliably is to shut it down when its quiet—when there are no in-flight messages.
All you have to do is find this quiet moment.
This is hard to do because while you wait for the current messages to complete, the application may take in new messages.
You have to stop taking in new messages while the current messages are given time to complete.
This process is known as graceful shutdown, which means shutting down in a reliable and controlled manner.
When CamelContext is being stopped, which happens when its stop() method is invoked, it uses a strategy to shut down.
The default implementation of this ShutdownStrategy interface uses the graceful shutdown technique.
For example, when you stop the Rider Auto Parts example, you’ll see these log lines:
You can see the graceful shutdown is using a 300-second timeout.
This is the maximum time Camel allows for shutting down gracefully before it starts to shut down more aggressively by forcing routes to stop immediately.
The default value is 300 seconds, which you can configure on the CamelContext.
For example, to use 20 seconds as the default timeout value, you can do as follows:
Doing this in Spring XML requires a bit more work, because you have to define a Spring bean to set the timeout value:
Then Camel logs the progress of the routes as they shut down, one by one, according to the order in which they were started.
Notice that the file route is suspended and deferred, and then later is shut down.
This is a little glimpse of the complex logic the graceful shutdown process uses to shut down Camel in a reliable manner.
We’ll cover what suspension and defer mean in a moment.
At the end, Camel logs the completion of the graceful shutdown, which in this case was really fast and completed in less than one second.
Camel also logs whether there were any in-flight messages just before it stops completely.
If Camel did not complete the graceful shutdown, it would log at WARN level how many in-flight messages were still in progress:
At Rider Auto Parts, you’re in the final testing of the application before it’s handed over to production.
One of the tests is based on processing a big inventory file, and you wanted to test what happens if you shut down Camel while it was working on the big file.
You expected Camel would continue processing the big file and only shut down when the file was completed.
At first, you see the usual logging about the shutdown in progress:
Then there is a log line indicating that Camel has noticed the one in-flight exchange, which is the big file.
Then the application logs the progress of the inventory update, which should happen for each line in the big file:
Next come a lot of WARN logs about there being no consumers to process the Exchange:
Finally, you see the last log lines, which report the end of the shutdown.
So what went wrong? The clues have been shown in the logs.
First, you noticed the WARN logs, which indicated that the direct:update consumer had been stopped.
This consumer is from the first route, which has startup order 1:
You then noticed that Camel stops this route as the first route during the shutdown process:
This is a shared route that the other routes depend upon, as illustrated in figure 13.4
That’s why it needed to be started before the other routes.
Now the problem is that this route is also stopped before the other routes.
The good news is that it’s possible to remedy this in Camel.
What you need to do is somehow tell Camel to defer shutting down this shared route.
This is done using the ShutdownRoute option, which was listed in table 13.1
All you have to do is add the option in the route as shown in bold here:
Now when you run the test, the application shuts down in a reliable manner.
The log shows that Camel detects that the big file is still in progress and patiently waits:
The application is now ready to be handed over to operations for deployment.
Camel now always defers direct endpoints, which means you no longer have to configure this manually.
The example illustrates the principle of how to shut down a Camel application in a reliable manner.
The source code for the book contains this example in the chapter13/shutdown directory.
You can try it by using the following Maven goals:
As you’ve just learned, Camel end users are responsible for configuring routes correctly to support reliable shutdown.
Some may say this is a trade-off, but we, the Camel team, think of it as flexibility and don’t believe computer logic can substitute for human logic in ensuring a reliable shutdown.
We think it’s best to give Camel users the power to configure their routes to support their use cases.
Camel will leverage the graceful shutdown mechanism when it stops or shuts down routes.
That means the example in listing 13.3 will stop the route in a graceful manner.
As a result, you can reliably stop routes at runtime, without the risk of losing inflight messages.
The difference between using the stopRoute and shutdownRoute methods is that the latter will also unregister the route from management (JMX)
Use stopRoute when you want to be able to start the route again.
Only use shutdownRoute if the route should be permanently removed.
It’s now time to review some of the deployment strategies that are possible.
Camel is described as a lightweight and embeddable integration framework.
This means that it supports more deployment strategies and flexibility than traditional ESBs and application servers.
Camel can be used in a wide range of runtime environments, from standalone Java applications, to web containers, to the cloud.
In this section, we’ll look at four different deployment strategies that are possible with Camel and present their strengths and weaknesses.
These four deployment strategies are the common ways of deploying Camel.
It’s appealing to embed Camel in a Java application if you need to communicate with the outside world.
By bringing Camel into your application, you can benefit from all the transports, routes, EIPs, and so on, that Camel offers.
Figure 13.6 shows Camel embedded in a standard Java application.
In the embedded mode, you must add to the classpath all the necessary Camel and third-party JARs needed by the underlying transports.
All you need to do is create a CamelContext and start it, as shown in the following listing.
It’s important to keep a reference to CamelContext for the lifetime of your application, because you’ll need to perform a shutdown of Camel.
As you may have noticed in listing 13.5, the code execution continues after starting the CamelContext.
To avoid shutting down your application immediately, the listing includes code to sleep for 10 seconds.
In your application, you’ll need to use a different means to let your application continue and only shut down when requested to do so.
Let’s look at the Rider Auto Parts application illustrated in figure 13.1, and embed it in a Java application.
Because the application is using Spring XML files to set up Camel, you just need to start Spring to start the application.
Starting Spring from a main class can be done as follows:
This code also reveals the problem of having the main method wait until you terminate the application.
The preceding code uses Thread.sleep to wait 10 seconds before terminating the application.
To remedy this, Camel provides a Main class that you can leverage instead of writing your own class.
You can change the previous InventoryMain class to leverage this Main class as follows:
This approach also solves the issue of handling the lifecycle of the application.
By enabling hang-up support, you tell Camel to shut down gracefully when the JVM is being terminated, such as when the Ctrl-C key combination is pressed.
You can obviously also stop the Camel application by invoking the stop method on the main instance.
You can try it out using the following Maven goal:
It has parameters to dictate which Spring XML file it should load.
By default, it loads all XML files from the classpath in the META-INF/spring location, so by dropping your Spring XML file in there, you don’t even have to pass any arguments to the Main class.
Table 13.2 summarizes the pros and cons of embedding Camel in a standalone Java application.
You now know how to make your standalone application leverage Camel.
Let’s look at what you can do for your web applications.
Embedding Camel in a web application brings the same benefits as were mentioned in section 13.4.1
Camel provides all you need to connect to your favorite web container.
If you work in an organization, you may have existing infrastructure to be used for deploying your Camel applications.
Deploying Camel in such a well-known environment gives you immediate support for installing, managing, and monitoring your applications.
Table 13.2 Pros and cons of embedding Camel in a standalone Java application.
When Camel is embedded in a web application, as shown in figure 13.7, you need to make sure all JARs are packaged in the WAR file.
The Camel instance embedded in your web application is bootstrapped by Spring.
By leveraging Spring, which is such a ubiquitous framework, you let end users use well-known approaches for deployment.
This also conveniently ties Camel’s lifecycle with Spring’s lifecycle management and ensures that the Camel instance is properly started and stopped in the web container.
The following code demonstrates that you only need a standard Spring context listener in the web.xml file to bootstrap Spring and thereby Camel.
This context listener also takes care of shutting down Camel properly when the web application is stopped.
In this file, you can embed Camel, as shown in listing 13.6
Specifying the location of your Spring XML file If you want to use another name for your Spring XML file, you’ll need to add a context parameter which specifies the filename as follows:
For example, this is done by having CXF defined in the camelcxf.xml file B.
The source code for the book contains this example in the chapter13/war directory.
You can try it out by using the following Maven goal:
To use the Jetty plugin in your projects, you must remember to add it to your pom.xml file in the <build><plugins> section:
If you run this goal, you should notice in the console that Jetty has been started:
Let’s look at how you can run Camel as a web application in Apache Tomcat.
To package the application as a WAR file, you can run the mvn package command, which creates the WAR file in the target directory.
You want to leverage the hot deployment of Apache Tomcat, so you must first start it.
Here’s how you can start it on a Unix-based system, such as our Mac OS X laptop, using the bin/startup.sh script:
To deploy the application, you need to copy the WAR file to the Apache Tomcat webapps directory:
Then Apache Tomcat should show the application being started in the log file.
You should see the familiar logging of Camel being started:
Now you need to test that the deployed application runs as expected.
This can be done by sending a web service request using SoapUI, as shown in figure 13.8
Doing this requires you to know the URL  to the WSDL the web service runs at, which is http://localhost:9000/inventory?wsdl.
Figure 13.8 Using SoapUI testing the web service from the deployed application in Apache Tomcat.
The web service returns “OK” as its reply, and you can also see from the log file that the application works as expected, outputting the inventory being updated:
There’s another great benefit of this deployment model, which is that you can tap the servlet container directly for HTTP endpoints.
In a standalone Java deployment scenario, you have to rely on the Jetty transport, but in the web deployment scenario, the container already has its socket management, thread pools, tuning, and monitoring facilities.
Camel can leverage this if you use the servlet transport for your inbound HTTP endpoints.
In the previously deployed application, you let Apache CXF rely on the Jetty transport.
Let’s change this to leverage the existing servlet transports provided by Apache Tomcat.
When using Camel in an existing servlet container, such as Apache Tomcat, you may have to adjust Camel components in your application to tap into the servlet container.
In the Rider Auto Parts application, it’s the CXF component you must adjust.
First, you have to add CXFServlet to the web.xml file.
Maven users need to adjust the pom.xml file to depend upon the HTTP transport instead of Jetty, as follows:
Next, you must adjust the camel-cxf.xml file, as shown in the following listing.
To use Apache CXF in a servlet container, you have to import the cxf-servlet.xml resource B.
This exposes the web service via the servlet container, which means the endpoint address has to be adjusted to a relative context path C.
In the previous example, the web service was available at http://localhost:9000/ inventory?wsdl.
By using Apache Tomcat, the web service is now exposed at this address:
Notice that the TCP port is 8080, which is the default Apache Tomcat setting.
Then the web service should be available at this address: http://localhost:8080/riderautoparts-war-servlet-1.0/services/inventory?wsdl.
You can find more information on the Apache Camel website at http://camel.apache.org/servlet.html.
Table 13.3 lists the pros and cons of the web application deployment model of Camel.
Embedding Camel in a web application is a popular, proven, and powerful way to deploy Camel.
Another choice for running Camel applications is using an application server such as JBoss Application Server.
A common way of deploying Camel applications in JBoss Application Server (JBoss AS) is using the web deployment model we discussed in the previous section.
But JBoss AS has a pesky classloading mechanism, so you need to leverage a special Camel JBoss component to remedy this.
This component isn’t provided out of the box at the Apache Camel distribution, because of license implications with JBoss AS’s LGPL license.
This component is hosted at Camel Extra (http://code.google.com/p/ camel-extra/), which is a project site for additional Camel components that can’t be shipped from Apache.
This example is based on the previous example with two minor additions.
To deploy the application to JBoss, you start it and copy the WAR file into the server/
For example, on our laptop, JBoss AS 5.1 is started as follows:
Table 13.3 Pros and cons of embedding Camel in a web application.
After a while, JBoss AS is ready, and this is logged to the console:
You can then keep an eye on the JBoss console as it outputs the progress of the deployment.
For example, Camel reports that it has picked up the JBoss classloader, as shown here:
JBoss AS uses an embedded Apache Tomcat as the servlet container, which means the web service of the application is available in a familiar location:
Table 13.4 lists the pros and cons of deploying Camel in JBoss Application Server.
Deploying Camel as a web application in JBoss AS is a fairly easy solution.
All you have to remember is to use the special Camel JBoss component to let the classloading work.
The last strategy we’ll cover is in a totally different ballpark: using OSGi.
OSGi is a fairly new deployment model in the Java enterprise space and brings promises of modularity to the extreme.
OSGi is a layered module system for the Java platform that offers a complete dynamic component model.
It’s a truly dynamic environment where components can come and go without requiring a reboot (hot deployment)
Apache Camel is OSGi-ready, in the sense that all the Camel JAR files are OSGi-compliant and are deployable in OSGi containers.
This section will show you how to prepare and deploy the Rider Auto Parts application in the Apache Karaf OSGi runtime.
Requires a special Camel JBoss component to remedy classloading issues on JBoss.
OSGi container, such as hot deployment, provisioning, local and remote shells, and many other goodies.
The example presented here is included with the source code for the book in the chapter13/osgi directory.
The basics are covered on Wikipedia (http://en.wikipedia.org/ wiki/OSGi), and if you’re interested in more information, we highly recommend OSGi in Action, by Richard S.
For more information on the Apache Karaf OSGi runtime, see the Karaf website: http://karaf.apache.org.
The first thing you need to do with the Rider Auto Parts application is make it OSGicompliant.
This involves setting up Maven to help prepare the packaged JAR file so it includes OSGi metadata in the MANIFEST.MF entry.
In the pom.xml file, you have to set the packaging element to bundle, which means the JAR file will be packaged as an OSGi bundle:
To generate the MANIFEST.MF entry in the JAR file, you can use the Apache Felix Maven Bundle plugin, which is added to the pom.xml file under the <build> section:
Camel route, and it needs to be accessible by Camel so it can load the routes when the application is started.
In terms of imports, the preceding code defines it as dynamic by using an asterisk, which means the OSGi container will figure it out.
When needed, you can specify the imports by package name.
The source code for the book contains this example in the chapter13/osgi directory.
You have now set up Maven to build the JAR file as an OSGi bundle, which can be deployed to the container.
The next step is to download and install Apache Karaf.
For this example, you can download and install the latest version of Apache Karaf from http://karaf.apache.org.
At the time of writing, this was Apache Karaf 2.1.2
Installing is just a matter of unzipping the zip file.
To run Apache Karaf, start it from the command line using one of these two commands:
This should start up Karaf and display a logo when it’s ready.
This will run in a shell mode, which means you can enter commands to manage the container.
Karaf makes installing easier by using features, which are like super bundles that contain a set of bundles installed as a group.
Installing features requires you to add the Camel feature descriptions to Karaf, which you do by typing the following command in the shell:
From a Unix shell, you can do this as follows:
The Apache Karaf team will fix this problem in the 2.2 release.
You can then type features:list to see all the features that are available to be installed.
The example application requires the http, camel, and camel-cxf features.
The shell has autocompletion, so you can press Tab to see the possible choices.
For example, type osgi and then press Tab to see the choices.
You’re now ready to deploy the Rider Auto Parts application.
Karaf can install OSGi bundles from various sources, such as the filesystem or the local Maven repository.
To install using Maven, you first need to install the application in the local Maven repository, which can easily be done by running mvn install from the chapter13/ osgi directory.
After the JAR file has been copied to the local Maven repository, you can deploy it to Apache Karaf using the following command from the shell:
Upon installing any JAR to Karaf (a JAR file is known as a bundle in OSGi terms), Karaf will output on the console the bundle ID it has assigned to the installed bundle, as shown:
You can then type osgi:list to see the application being installed:
You can start it by entering osgi:start 98, which changes the application’s status when you do an osgi:list again:
So how can you test that it works? You can start by checking the log with the log:display command.
Among other things, it should indicate that Apache Camel has been started:
You can then use SoapUI to send a test request.
When you’re done testing the application, you may want to stop the OSGi container, which you can do by executing the osgi:shutdown command from the shell.
Note that this isn’t done from within the Karaf shell but from the regular shell on your operating system.
You’ve now seen how to deploy the example into an OSGi container, which marks the end of our practical coverage of OSGi in this book.
Table 13.5 lists the pros and cons of deploying Camel in an OSGi container.
You’ve now seen the most popular deployment strategies for Camel and other products.
We’ve only scratched the surface of OSGi in this chapter.
The path of the web application is the beaten track, and there are plenty of materials and people who can help you if you come up against any problems.
In this chapter, we explored the internal details of how Camel starts up.
You learned which options you can control and whether routes should be autostarted.
You also learned how to dictate the order in which routes should be started.
More important, you learned how to shut down a running application in a reliable way without compromising the business.
You learned about Camel’s graceful shutdown procedures and what you can do to reorder your routes to ensure a better shutdown process.
You also learned how to stop and shut down routes at runtime.
You can do this programmatically, which allows you to fully control when routes are operating and when they are not.
In the second part of this chapter, we explored the art of deploying Camel applications as standalone Java applications, as web applications, and by running Camel in an OSGi container.
Remember that the deployment strategies covered in this book aren’t all of your options.
For example, Camel can also be deployed in the cloud, or they can be started using Java Web Start.
Table 13.5 Pros and cons of using OSGi as a deployment strategy.
Here are some pointers to help you out with running and deployment:
Take the time to configure and test that your application can be shut down in a reliable manner.
You application is bound to be shut down at some point, whether for planned maintenance, upgrades, or unforeseen problems.
In those situations, you want the application to shut down in a controlled manner without negatively affecting your business.
Camel is agile, flexible, and can be embedded in whatever production setup you may want to use.
Don’t introduce a new production environment just for the sake of using Camel.
Use what’s already working for you, and test early on in the project that your application can be deployed and run in the environment.
In the next (and final) chapter, we’ll revisit Camel’s routing capabilities, but we’ll focus on the power of using annotations on beans.
We’ll also see how you can hide the Camel API from clients but still let clients interact with Camel by hiding the middleware layer.
These techniques also provide approaches to solving integration problems that complement approaches we’ve discussed throughout this book.
First, you’ll learn to use Camel’s annotation-based routing, which allows regular Java beans to be used for routing.
This allows you to access all of Camel’s components and not write a single line of DSL code.
You sacrifice many of the routing abilities that are provided in Camel’s DSLs, but this isn’t a problem for simple use cases.
When using the routing annotations, you still have to code against Camel APIs, just not the Camel DSL.
We’ll take this a step further in the last part of the chapter and discuss the art of hiding middleware.
By hiding middleware, you allow users of your Camel application to only see the business interfaces; the complexity of remote transports and Camel APIs are hidden behind a clean client API.
Let’s get started by looking at how to route messages using Camel’s messaging annotations.
Throughout this book, you’ve seen how Camel’s unique and powerful DSLs can be used to easily create complex integration applications.
But in order to take advantage of this power, you need to learn a Camel DSL and its intricacies.
Using a DSL also means that your application—at least the integration and routing portion—is tied to Camel.
By using annotations, you can produce and consume (send and receive) messages to and from Camel endpoints by using a regular Java bean.
In this way, you don’t need to learn much about Camel at all.
You can write your application as you normally would in plain Java, and when you want to connect it to an external service, you can use an annotation from Camel.
This approach of using Camel is only recommended for simple integration scenarios or when you can’t invest the time to learn the Camel DSLs.
We’ll discuss when to use this approach in more detail in section 14.1.4
First, let’s see where this approach would be useful, and then we’ll dive into the details of the messaging annotations.
Back in chapter 10, we looked at how Rider Auto Parts keeps an inventory of all the parts its suppliers currently have in stock.
It was kept up to date by the suppliers periodically sending updates to Rider Auto Parts.
Storing this information locally within Rider Auto Parts means the business can operate without being dependent on expensive online integrations with all the suppliers.
Suppose that you want this automated update to happen over JMS, because it has built-in reliable messaging, among other things.
Messages on this queue are then used to update the inventoryDB database.
These updates are then used to update the internal inventory database.
Let’s also suppose you have a Java class already available that can write this inventory update into a database.
This class has an updateInventory method that accepts a single parameter, an Inventory object, which contains details about the partner and the inventory that’s being updated.
We’ll look at how the business partner sends to Rider Auto Parts in section 14.2, but for now we’ll look at how this inventory service will be implemented on the Rider Auto Parts side.
You also want to reuse the InventoryUpdater class shown in listing 14.1 as much as possible.
If you know how to create a route in one of Camel’s DSLs, a solution may seem pretty obvious.
Omitting the JMS component and bean setup, the route builder would look something like this:
Listing 14.1 A Java class that can update the inventory database.
To seasoned Camel users this will be simple to understand.
But how can we do this without using Camel’s DSLs?
The @Consume annotation accepts any Camel endpoint URI, so you can easily hook up a method to anything that Camel supports!
You may be wondering how you get from a JMS message to an Inventory object.
Just because you aren’t using a RouteBuilder doesn’t mean that automatic type conversion won’t take place.
In this case, Camel’s type converters automatically convert the body of the JMS message to an Inventory object, which is the parameter of the invoked method.
You may recall from chapter 4 that, by default, Camel assumes that if there is a single parameter in a method being called on a bean, the body of the message needs to be converted to match that type.
You can also use any of the parameterbinding annotations mentioned in section 4.5.3 to define more precisely what data to map from the incoming message.
Getting access to all of Camel’s components through a simple annotation may seem like a bit of magic.
As you may have guessed, there’s a little more setup required to use these annotations.
The first thing you’ll need to set up are the required dependencies: camel-core and camel-spring.
If it finds these annotations, it connects the bean to the specified Camel endpoints for you.
So all you have to do to use these annotations is create a SpringCamelContext and then create your bean within the Spring XML file, as follows:
If you have multiple beans consuming from the same endpoint URI, you may find it useful to define the endpoint once and reference it from each bean.
This way, if the URI changes, you only have to change it in one place.
For example, you can set up a Camel endpoint in the context so it can be accessed from any bean:
Now you can reference the inventoryQueue endpoint within the @Consume annotation as follows:
This will have the same end result as if you were specifying the endpoint URI in the annotation.
The only difference is that Camel won’t have to resolve the endpoint instance (or create a new instance on the fly) because it’s referencing an available instance.
If you have two CamelContext elements defined within one Spring XML file, you’ll need to take extra care in making sure the @Consume annotation specifies which CamelContext it should apply to.
The problem with this is that you’ll get a new consumer for each CamelContext defined! This may not be what you want to happen.
To get around this, you can specify the CamelContext id in the annotation definition.
When you use the @Consume annotation in your bean, you can specify the context by using the context attribute.
For example, to reference the context with ID equal to camel-1, you could do the following:
You now know all the details necessary for consuming messages from Camel endpoints using the @Consume annotation.
We mentioned before that you can similarly use annotations for producing messages to Camel endpoints.
We’ll look at the @Produce annotation that does this next.
You now have a new requirement for the InventoryUpdater bean.
When you receive an inventory update from a partner, in addition to updating the database, you must send the update to the JMS partnerAudit queue for processing.
Rider Auto Parts has added a new system that keeps track of how often partners send updates, whether updates had errors, and so on.
This addition would be dead simple if you were using a Camel DSL route already, but you need to add this to your existing InventoryUpdater bean.
The difference is that the @Produce annotation doesn’t attach to a method within a class; it attaches to a field or property setter within a class.
This field can be either a ProducerTemplate or an interface you use in your business logic.
In the case of a ProducerTemplate, Camel will simply inject a new ProducerTemplate that points to the URI you specify.
If a plain interface is supplied, Camel has to do some extra work by injecting a proxy object.
The ProducerTemplate class is a natural way of sending messages to Camel endpoints.
You’ve seen it used in previous chapters, so its use should be familiar.
A complete discussion of the ProducerTemplate is given in appendix C.
You can use the @Produce annotation to set up a ProducerTemplate for a particular endpoint URI.
The @Produce annotation B takes the endpoint URI jms:partnerAudit and creates a new ProducerTemplate for that URI.
At any other point in the bean’s use, you can then send messages to that endpoint using the ProducerTemplate that was created C.
It’s also possible to send messages without using the ProducerTemplate at all.
Camel allows you to specify an interface as the frontend for the endpoint specified.
This approach allows you to eliminate the dependence on more Camel APIs, like the ProducerTemplate.
So how can you use a plain interface as the frontend for an endpoint? The short answer is that Camel creates an instance of the interface—a smart proxy object.
The whole process is described in more detail in section 14.2.2
Suppose you define an interface for your backend audit processing systems as follows:
The single audit method is intended to mean that the Inventory object passed in should be audited.
The interface can then replace the ProducerTemplate, as shown here.
The bean looks much like before, except that now there’s no use of ProducerTemplate.
Instead, you use the PartnerAudit interface as the binding point for the @Produce annotation B.
This annotation will now tell Camel that a smart proxy object must be created that extends from PartnerAudit and passes on a message to the partnerAudit JMS queue.
Then, when you call the audit method on the interface C, Camel sends a message to the endpoint specified in the @Produce annotation.
You may be wondering when you should use the messaging annotations rather than one of Camel’s DSLs.
There’s no clear-cut answer to the question, but we can give you some guidelines to make your decision easier.
In general, we recommend that you use one of Camel’s DSLs if at all possible.
They have built-in functionality for setting up common integration scenarios and will most likely make your life a lot easier.
But they involve the added burden of learning more concepts.
You may want to use the messaging annotations in the following situations:
You have a simple message flow where there is a single well-defined input or output URI.
We want to stress that for complex integration scenarios, you should use one of Camel’s DSLs.
Trying to design a complex integration with the messaging annotations could lead to a messy solution—they were not designed for complex routings.
You’ve seen how you can reduce your dependence on Camel’s DSLs with these annotations.
Let’s now take a look at how you can take that a step further and completely hide Camel from users of your application.
Middleware is defined as the software layer that lies between an operating system and an application.
Middleware is used for interoperability among applications that are running in a coherent distributed system.
Examples include Enterprise Application Integration (EAI), enterprise service buses (ESBs), and message queuing software (such as Apache ActiveMQ)
Camel is also used for integrating and providing interoperability among applications that may run in a coherent distributed system.
You could potentially view Camel as middleware software, but that isn’t entirely accurate, because Camel leverages thirdparty software where appropriate.
For example, you can have Camel sitting on top of Apache ActiveMQ, and together they’re middleware software.
An important aspect of writing software these days is trying to write business logic that focuses on the domain concepts as much as possible.
You want your business logic to deal with the business domain rather than with the myriad of technology stacks out there, such as SOAP, REST, JMS, FTP, and XMPP.
One way to avoid this situation is to decouple as much middleware from your business logic as possible—to hide the middleware.
By keeping your business logic hidden from the middleware, your application will be much more flexible and easy to change.
This also makes the lives of clients who access the business logic easier, because they only have to deal with the business domain.
To demonstrate this, we’ll cover a use case from Rider Auto Parts.
You and your team have developed a starter kit, which is a piece of software new business partners can use to more easily integrate with Rider Auto Parts.
The situation without the starter kit is two businesses needing to integrate their business logic.
Because the business logic is distributed, the logic of one partner needs to communicate over the network in order to interact with the other partner’s logic.
That means the business logic needs to know about and use the transport.
You want to hide the complexity of transports, which you can depict by labeling it as middleware, as shown in figure 14.3
The starter kit is middleware software based on Camel and a selected third-party technology for the transport.
The transport must support networking to transfer data from one machine to another.
Such a transport could, for example, be HTTP- or messaging-based.
The transport technology that best fits the situation should be chosen.
For this example, the transport technology is messaging using Apache ActiveMQ.
The business partner deploys the starter kit in their infrastructure and uses it to communicate with Rider Auto Parts, as shown in figure 14.4
In this example, the starter kit takes care of all the complexity involved in sending messages over the network using Apache ActiveMQ.
All the business partner should focus on is a single client interface that defines the API they need to use.
In this section, you’ll learn how to develop such a starter kit.
We’ll start by defining the client API and creating a simple test that runs in a single JVM.
Figure 14.3 Each part of the business logic leverages middleware when communicating with the other parts.
Figure 14.4 The starter kit is used by business partners to hide the middleware and easily communicate with Rider Auto Parts.
Hiding middleware to change the middleware to switch transports without requiring any changes in the client.
In section 14.2.2, we’ll let the communication happen remotely between two JVMs using JMS as the transport, which is what you might use in a real-life situation.
The starter kit is a Camel application that defines a single interface for business partners to use when integrating their businesses with Rider Auto Parts.
To keep the use case simple, the interface will provide the following two methods:
The first method is used by clients to send updated inventory information to Rider Auto Parts.
This allows Rider Auto Parts to maintain current information about its suppliers’ inventory situation, with all data being stored in a datastore within Rider Auto Parts.
The second method is used by suppliers to find out which of the many Rider Auto Parts retail stores inventory should be shipped to.
In this example, the information on the domain objects is kept simple and limited, as the following code snippets show (we’ve omitted the getters and setters):
Using the RiderService interface, it should be easy for business partners to send inventory information to Rider Auto Parts, as the following code example shows:
This example demonstrates the concept of decoupling business logic from the middleware.
The example is pure business logic, focusing on assembling inventory information and sending it to Rider Auto Parts using the RiderService API.
The example has no middleware logic; there’s no logic present to indicate how the data is actually sent.
In this case, Camel is the middleware, and the example doesn’t use any Camel APIs at all.
You’ve fully decoupled your business logic from the integration logic.
With the domain in place, let’s turn our attention to setting up Camel.
First you’ll want to create a test that runs on a single JVM.
In Camel, you need to set up two things to implement your first test.
You need a mocked RiderService that can act as Rider Auto Parts and return dummy data.
This is easy to do—all it involves is implementing the RiderService interface.
First you have to define a Spring bean, riderMocked B (the class from listing 14.5), which is used to simulate the Rider Auto Parts business.
The next part is the interesting part—it’s the mechanism that decouples the business logic from the middleware.
This is done by proxying C the RiderService interface and having its method invocations proxied by sending a message to the given endpoint.
We’ll cover this in much more detail in section 14.2.2
What remains is to define a route D that sends the messages to Rider Auto Parts.
In this example, you route the message to the mocked bean that simulates Rider Auto Parts.
You can run this example by using the following Maven goal:
When you run the example, you should see the following lines, among others, on the console:
In the introduction to this section, we said that Camel can hide the middleware, allowing you to decouple your business logic from the transport.
You’ll now see this in action as you change the transport from direct to the SEDA component without requiring any changes in the business logic.
Changing the transport to SEDA is easily done in the Spring XML file, as follows:
You can run this example using the following Maven goal:
When you run the example, you should see the following lines on the console:
The difference between this example and the previous one is that by using SEDA you let another thread process the route (indicated by the [seda://rider] in the console output)
Using a Camel proxy is similar to using Spring remoting, which is a feature in the Spring Framework that offers remoting support for various technologies, making it easier to remote-enable services.
Spring has a limited set of technologies that can be used.
Camel takes this a big step forward by remote-enabling all of the Camel components.
To understand how a Camel proxy works, let’s start by adding a log in the route from listing 14.6 that will output information about the actual messages sent by the Camel proxy:
As you can see from the output, Camel uses a BeanInvocation type in the message body.
The purpose of the BeanInvocation is to hold information about a bean invocation.
It indicates that the updateInventory method is to be invoked with these parameters.
Because BeanInvocation is serializable, it’s possible to send it over a remote network and have it invoked on the remote side.
Let’s try this using JMS as the transport and using two JVMs.
Next, we’ll look at a client and server each in separate JVMs, using JMS as the transport.
First we’ll discuss the server and how to start it.
Then we’ll look at the client and run it to see it in action.
Here’s the Spring XML file you use to define the server.
On the server you embed an Apache ActiveMQ broker that uses TCP as the transport on port 61616 B.
As you have two JVMs, you need a remote protocol, which in this case is TCP.
In the route, you consume messages from the ActiveMQ rider queue C, which is the destination where the client will send the messages.
Because you use an embedded ActiveMQ broker, you don’t need to define an ActiveMQ component because Camel can leverage an intra-VM connection.
You can start the server using the following Maven command in the chapter14/ starterkit directory:
All you need to do is define the proxy and configure the ActiveMQ transport, as follows:
You can run the client using the following Maven command in the chapter14/ starterkit directory:
When the client is run, you should see activity in both the client and server consoles.
The server should log the message received, which is similar to what you saw previously when JMS wasn’t used as the transport:
Now you’ve seen how to decouple your business logic from the middleware and change the transport without any code changes to the business logic.
With that, it’s time to look under the hood at how this works.
In fact the <proxy/> tag you used in Spring XML is a facade that leverages the ProxyHelper class.
Figure 14.5 is a sequence diagram that depicts what happens at runtime when a client invokes the shipInventory method on a proxied RiderService interface.
In this figure, a client invokes the shipInventory method on RiderService.
This handler creates a BeanInvocation that contains information about the method (and its parameters) invoked on the proxy.
Then the BeanInvocation is sent to the endpoint using a Camel Producer, which waits for the response to.
Figure 14.5 A sequence diagram showing how a Camel proxy works under the covers, sending a BeanInvocation message to a remote endpoint and waiting for the reply, which eventually is returned to the caller.
The response is then adapted to the RiderService by converting it to the same type as the return type on the method.
This also applies to methods that don’t return a value (whose return type is void)
You can enforce a method to use the fire-and-forget messaging style (InOnly) by adding the @InOnly annotation to the method definition in the interface.
But keep in mind that when using @InOnly, the method call will be fully asynchronous, so you won’t know if the receiver processed the message successfully.
For example, exceptions thrown by the receiver won’t be propagated back to the method call.
When using a Camel proxy, there’s a single rule that must be adhered to.
Camel proxies use a BeanInvocation as the message body sent to the endpoint.
If the endpoint is representing a remote destination, the message body must be serialized so it can be sent over the wire.
This is why the information stored in BeanInvocation must be serializable.
For Camel end users, that means the parameters you pass to the proxied interface must be serializable.
For example, if you look at the updateInventory method in the RiderService interface, you can see that it uses an Inventory object as a parameter.
When you invoke the updateInventory method, as shown in the following test snippet, the Inventory object must be serializable.
You’ve now learned how to decouple your business logic from the integration logic by hiding the middleware with help from Camel proxies.
In this last chapter of Camel in Action, we’ve shown you ways of using Camel that minimize your dependence on Camel APIs and completely hide Camel from your application’s users.
These abilities are considered extra features of Camel, rather than core pieces.
They add functionality that experienced Camel users, which you now are, can appreciate.
There are a few things you should take away from this chapter:
When all you want to do is hook up a bean to a transport supported by Camel, the messaging annotations are an easy way to go.
There is little learning overhead with these, compared to using the Camel DSLs.
We still recommend the Camel DSLs for more complex scenarios.
Use hiding middleware principles when you don’t want to expose your transports.
In some cases, you may not want clients of your service to know what transport you’re using to communicate with the backend.
For instance, you may want to change the transport in the future without changing the client’s code.
You’ve now made it through many Camel and general enterprise integration concepts; you have the knowledge to tackle complex integration problems with Camel.
As a final suggestion, try to keep in touch with the Camel community.
It’s a busy and exciting place, and we’d love to hear from you there.
Camel offers a powerful expression language, which back in the earlier days wasn’t as powerful and was labeled Simple.
It has evolved to become much more since then, but don’t worry: it’s still simple to use.
The Simple language is provided out of the box in the camel-core JAR file, which means you don’t have to add any JARs on the classpath to use it.
A.1 Introducing Simple In a nutshell, the Simple expression language evaluates an expression on the current instance of Exchange that is under processing.
The Simple language can be used for both expressions and predicates, which makes it a perfect match to be used in your Camel routes.
For example, the Content-Based Router EIP can leverage the Simple language to define predicates in the when clauses, as shown here:
As you can see from the preceding examples, the Simple expression is understandable and similar to other scripting languages.
In these examples, Camel will evaluate the expression as a Predicate, which means the result is a boolean, which is either true or false.
A.3 Built-in variables The Simple language provides a number of variables that bind to information in the current Exchange.
The Simple language also has a set of built-in functions.
Will return null if the body could not be converted.
For example, to log a formatted date from the message header, you could do as follows:
In this example, the input message is expected to contain a header with the key myDate, which should be of type java.util.Date.
Suppose you need to organize received messages into a directory structure containing the current day’s date as a parent folder.
The file producer has direct support for specifying the target filename using the Simple language as shown in bold:
Now suppose the file must use a filename generated from a bean.
In this example, Camel will look up the bean with the ID uuidBean from the Registry and invoke the generate method.
The output of this method invocation is returned and used as the filename.
Will return null if the header could not be converted.
Camel will look up the bean with the given ID from the Registry and invoke the appropriate method.
You can optionally explicitly specify the name of the method to invoke.
The command must be either now or header.XXX: now represents the current timestamp, whereas header.XXX will use the header with the key XXX.
For example, you could store a property in a file containing a configuration for a big-spender threshold.
Then you could refer to the big properties key from the Simple language:
The Simple language also has built-in variables when working with the Camel File and FTP components.
A.5 Built-in file variables Files consumed using the File or FTP components have file-related variables available to the Simple language.
Among other things, the file variables can be used to log which file has been consumed:
The File and FTP endpoints have options that accept Simple language expressions.
For example, the File consumer can be configured to move processed files into a folder you specify.
Suppose you must move files into a directory structure organized by dates.
This can be done by specifying the expression in the move option, as follows:
Another example where the file variables come in handy is if you have to process files differently based on the file extension.
In this appendix, we’ve used the Simple language for predicates.
In fact, the previous example determines whether the file is a text file or not.
A.6 Built-in operators The first example in this appendix implemented the Content-Based Router EIP with the Simple expression language.
It used predicates to determine where to route a message, and these predicates use operators.
Tests whether the left side is equal to the right side.
Tests whether the left side is greater than the right side.
Tests whether the left side is greater than or equal to the right side.
Tests whether the left side is not equal to the right side.
Here you test whether the foo header is equal to the String value "Camel"
If you want to test for "Camel rocks", you must enclose the String in quotes (because the value contains a space):
Camel will automatically type coerce, so you can compare apples to oranges.
Suppose the bar header is a String with the value "100"
Camel will convert this value to the same type as the value on the right side, which is numeric.
You can use the range operator to test whether a value is in a numeric range.
A regular expression can be used to test a variety of things, such as whether a value is a four-digit value:
You can also use the built-in functions with the operators.
For example, to test whether a given header has today’s date, you can leverage the date function:
The Simple language also allows you to combine two expressions together.
The Simple language can combine expressions using the and or or operators.
From Camel 2.5 onwards you can combine any number of expressions.
In previous releases you could only combine exactly two expressions.
A.7 The OGNL feature Both the Simple language and Bean component support an Object Graph Navigation Language (OGNL) feature when specifying the method name to invoke.
Suppose the message body contains a Customer object that has a getAddress() method.
To get the ZIP code of the address, you would simply type the following:
You can use a shorter notation, omitting the get prefix and the parentheses.
If you want to avoid this, you can use the null-safe operator ?
The methods in the OGNL expression can be any method name.
For example, to invoke a sayHello method, you would do this:
This means that the method signature of sayHello can have parameters that are bound to the current Exchange being routed:
The OGNL feature has specialized support for accessing Map and List types.
For example, suppose the getAddress method has a getLines method that returns a List.
You could access the lines by their index values, as follows:
You can use the null-safe operator to suppress this exception:
If you want to access the last element, you can use last as the index value, as shown here:
The access support for Maps is similar, but you use a key instead of a numeric value as the index.
Suppose the message body contains a getType method that returns a Map instance.
You could even invoke a method on the gold entry like this:
This concludes our tour of the various features supported by the Camel Simple language.
We’ll now take a quick look at how to use the Simple language from custom Java code.
A.8 Using Simple from custom Java code The Simple language is most often used directly in your Camel routes, in either the Java DSL or a Spring XML file.
But it’s also possible to use it from custom Java code.
Here’s an example that uses the Simple language from a Camel Processor.
As you can see in listing A.1, all it takes is creating an instance of SimpleBuilder, which is capable of evaluating either a predicate or an expression.
In the listing, you use the Simple language as a predicate.
To use an expression to say “Hello,” you could do the following:
Notice how you specify that you want the response back as a String by passing in String.class to the evaluate method.
Listing A.1 uses the Simple language from within a Camel Processor, but you’re free to use it anywhere, such as from a custom bean.
Just keep in mind that the Exchange must be passed into the matches method on the SimpleBuilder.
A.9 Summary This appendix covered the Simple language, which is an expression language provided with Camel.
You saw how well it blends with Camel routes, which makes it easy to define predicates in routes, such as those needed when using the Content-Based Router.
We also looked at how easy it was with the Simple language to access information from the Exchange message by using the built-in variables.
You saw that Simple provides functions, such as a date function that formats dates and a bean function that invokes methods on beans.
Finally, we covered OGNL notation, which makes it even easier to access data from nested beans.
All together, the Simple language is a great expression language that should help you with 95 percent of your use cases.
Expressions and predicates are built-in types in Camel that you’ve seen used throughout this book.
They’re very versatile and are used in different places, but they’re most noticeable in the Camel routes.
Expressions are used for computing correlation keys for the Aggregator EIP, and appendix A covered the Simple expression language, which is another testament to the versatility of expressions.
The evaluate method uses generics to specify the desired return type.
Suppose you want to implement a route that can return a message consisting of “Hello ” plus the input message.
This can be done using the Message Translator EIP, which leverages an Expression to transform a message.
Alternatively, you could use the Simple expression language (covered in appendix A), which may be easier to understand in this example:
Simple comes in handy when using Spring XML, because it’s a scripting language that can be used in XML, as opposed to the former solution, which can’t easily be used in Spring XML.
That’s because it’s based on Java code, which you can’t use directly in Spring XML files.
Although Camel provides a lot of built-in expressions to support many common use cases, there could be situations where you need to implement a custom expression.
Suppose you need to transform the message in a different way, and only the power of the Java programming language can perform the transformation.
In this case, you can use a custom expression, as shown in listing B.1
Using a custom expression in the Java DSL is just a matter of providing an instance in the Transform EIP, as follows:
When using custom expressions in Spring XML, you have to define the expression as a bean, and then use the method call expression to invoke the expression:
You may have noticed that listing B.1 uses the Camel type converter to convert the answer to the given type.
Camel offers an ExpressionAdapter class that removes the need for converting.
For example, predicates are used with the Content-Based Router EIP.
There are standard predicates and also custom and compound predicates.
First we’ll cover the common use cases for using predicates.
Suppose you want to filter messages using the Message Filter EIP and only allow “Camel” messages to pass through the filter.
This can easily be defined in a Camel Java DSL route, as follows:
As you can see, you can define the predicate as if the body contained the word “Camel” using the fluent builder style.
Implementing this example using Spring XML requires a different approach, because Spring XML is not Java code and it doesn’t provide the same level of syntax sugar.
Although Camel provides a lot of built-in predicates to support many common use case, there may be situations where you need to implement a custom predicate.
Suppose you need to filter messages using a more complex algorithm, or you just feel more comfortable using Java code to compute the predicate.
As you can see in listing B.3, it’s easy to implement a custom predicate.
All you have to do is implement the matches method and return either true or false.
Using a custom predicate in a route is just as easy.
You simply provide an instance of it to the filter EIP:
When using custom predicates in Spring XML, you have to define the predicate as a bean, and then use the method call expression to invoke the predicate.
Before we end this appendix, we want to show you one last thing: how to combine other predicates into a compound predicate.
You may have a number of existing predicates you want to use together.
For example, you may want to define a predicate as follows: Is the message a String message and either a Camel or a secret quote?
A Is the message a String type? B Is the message a "Camel" quote? C Is the message a "Secret" quote?
You just have to use these three predicates together in a compound predicate:
Implementing this in Camel can be done with the help of PredicateBuilder, which provides a range of predicate-related methods.
The builder has methods to combine two predicates using the binary operators and and or.
You can then define this in your Camel routes, like this:
Then, to build the compound predicate, you first combine predicates b and c together using the or operator.
Then this combined predicate is combined with the a predicate using the and operator.
B.3 Summary This appendix covered two central concepts used in Camel: expressions and predicates.
In many normal use cases, the built-in predicates and expressions should be sufficient.
In this appendix, you learned how to use custom expressions and predicates.
This should give you enough information that you’ll have no trouble using predicates and expressions with Camel.
Throughout this book, you’ve seen the ProducerTemplate used as an easy way of sending messages to a Camel endpoint.
While it was simple to understand in those cases, there are many more options to the ProducerTemplate.
There is also an analog for consumers—the ConsumerTemplate, which makes consuming messages easy.
Both of these templates are inspired by the template utility classes in the Spring Framework that simplify access to an API.
In Spring, you may have used a JmsTemplate or JdbcTemplate to simplify access to the JMS and JDBC APIs.
In the case of Camel, the ProducerTemplate and ConsumerTemplate interfaces allow you to easily work with producers and consumers.
By “easily work,” we mean you can send a message to any kind of Camel component in only one line of code.
For example, the following code sends a JMS text message to the ActiveMQ JMS queue named quotes:
Anyone who has worked with the JMS API will know that it takes quite a bit of work to replicate what Camel does in that single line of code.
In this appendix, we’ll show you how to use the ProducerTemplate and ConsumerTemplate in detail.
C.1 The ProducerTemplate The ProducerTemplate has a lot of methods that at first may seem a bit overwhelming.
But these methods make it powerful and flexible, which in turn makes it a time saver in many situations.
Notice that the table lists two sets of methods: send and request methods.
Send methods are used for InOnly-style messaging, where you send a message to a given endpoint and don’t expect any reply.
Request methods are used for InOut-style messaging, where you send a message to a given endpoint and expect and wait for a reply.
The ProducerTemplate has many variations on these methods, which you’ll learn to appreciate over time.
Also, for each of these methods there’s a corresponding asynchronous method.
If you wanted to send a message body asynchronously, you could use the asyncSendBody method instead of the sendBody method.
Chapter 10 details these methods and how to use them.
Here’s an example of how to use the ProducerTemplate to send a message to a JMS topic that’s used to audit orders.
This template is then used when sending the audit messages C.
Listing C.1 Using a ProducerTemplate to send a message to a JMS topic.
To try this out for yourself, find the appendixC/producer directory in the book’s source and run the following Maven command:
If you were instead accessing an HTTP service that returned a reply, you would need to use one of the request methods from table C.1
Here you use the requestBody method B to invoke a remote HTTP service with a header id set to the specified order ID.
You then get the order status returned as a string.
Notice that you pass in null for the body because this particular web service only needs the id header.
The HTTP producer will send an HTTP GET request in this case.
This example is found in the appendixC/producer directory of the book’s source and can be tested using the following Maven command:
Rather than creating these templates by directly invoking the CamelContext, you can use features built into the Spring DSL to do this.
The template and consumerTemplate elements within the camelContext element allow you to create a template and then refer to it later by using its ID.
Listing C.2 Using a ProducerTemplate to get a reply from an endpoint.
Within the camelContext element, you declare reusable templates (C and D) that you can wire into the OrderStatusBean from listing C.2 by using the bean ID B.
Why not use the name producerTemplate to align with the consumerTemplate element? At first, in Camel, there was only the producer template so the XML element was named template.
When the consumer template was introduced, the template element name was kept to be backwards compatible.
You can find listing C.3 along with a test case in the appendixC/producer directory.
Next, we’ll focus on the ConsumerTemplate, which you may not have seen much of yet.
It only works using the InOnly messaging style, where you use it to poll a given endpoint for a message.
Table C.2 lists the methods you’re most likely to use.
Let’s take a moment to see how you could use the ConsumerTemplate to solve a problem that’s been asked about again and again on the Camel mailing lists: how can you use Camel to empty a JMS queue?
For example, you can use it to empty a JMS queue containing new orders, as shown in listing C.4
Notice how easily you can use the receiveBody method from table C.2 to retrieve a message from a JMS queue.
The OrderCollectorBean bean uses a setter for the ConsumerTemplate B so you can inject it using Spring as follows:
Of course, this requires that you already have a consumerTemplate element defined, as shown in listing C.3
If you have no need to refer to them by ID or configure any options on them, you can just inject them into your bean by type, using Spring’s @Autowired annotation.
This is possible because Camel creates a default instance of each on startup.
You can then empty the order queue by looping until a null body is returned C.
This example can be found in the appendixC/consumer directory of the book’s source.
The test case essentially populates the “orders” queue in ActiveMQ with a few messages and then invokes the OrderCollectorBean to retrieve them.
C.3 Summary In this appendix we looked at the extremely useful producer and consumer templates.
These two templates give you a way of quickly accessing any Camel endpoint with one method call.
In addition to the examples presented in this appendix, the ProducerTemplate is used throughout the book.
As with any open source project, the community behind it is extremely important.
We think of community as an all-encompassing term for the official website, mailing lists, the issue tracker, Camel users, projects based on or extending Camel, and much more.
It’s hard to measure how vibrant a community is when it has this many moving parts, but it’s important.
Having a stagnant or small community will make your (the user’s) experience more difficult when things go wrong and during development in general.
We think Camel’s community is highly active and expanding, so you are in luck!
In this appendix we cover some main aspects of the Camel community.
You may have already noticed that we reference pages from the Camel website throughout the book.
On the Camel website, you’ll find links for downloads, documentation, support, and many other topics.
D.2 FuseSource FuseSource is a company that offers a productized version of Apache Camel, as well as training, consulting, and enterprise subscriptions to help IT organizations build mission-critical applications with Apache Camel.
FuseSource does the same for other popular Apache projects, including ServiceMix, ActiveMQ, and CXF.
The FuseSource team includes founders, PMC members, and many of the committers to Apache Camel, and they know the code better than anyone else does.
D.3 Camel Tooling Rider is a visual designer tool from FuseSource (http://fusesource.com) for creating, editing, testing, and debugging Camel routes.
Rider lets you drag and drop all the enterprise integration patterns supported by Apache Camel onto a canvas and easily wire them together and configure them.
You can use Rider as a tool to visualize existing routes, modify them, or create brand new integrations.
Rider comes in two flavors: a web version which can be used with any modern web browser, or as an Eclipse plugin.
The web version is very handy for viewing and editing routing rules running inside your running application, whether it's in a standalone JVM or inside Apache Tomcat, Apache ServiceMix, or some Java EE container.
Figure D.1 shows using Rider inside the Google Chrome web browser to edit routing rules from a web application running on top of Apache Tomcat.
If you use Eclipse as your IDE, using the Rider Eclipse plugin might be an easier option for you to choose, particularly if you want to design and edit your Camel routes as part of your development process.
Visit the FuseSource Rider website (http://rider.fusesource.org) for links to all the various Rider documentation, screencasts, and download links.
You can drag and drop EIPs from the palette to the canvas to design the route at design time.
The main motivator for not including all Camel components in the main distribution is licensing.
The camel-extra project contains components that integrate with libraries that have GPL and LGPL licenses, which are incompatible with Apache.
At camel-extra, you’ll find components for integrating with the following, among others:
The components from camel-extra are not officially affiliated with or supported by Apache.
D.5 JIRA, mailing lists, and IRC When things don’t go as planned, you’ll need to get help from people in the Camel community.
From here, one of the Camel developers will assign the ticket to themselves and possibly commit a fix for the issue.
It’s also acceptable to attach a source code patch that fixes the issue directly to the JIRA ticket (http://camel.apache.org/contributing.html)
This allows a Camel developer to apply your patch to the Camel source.
When you have general questions, you can send a message to the Camel user list (http://camel.apache.org/mailing-lists.html), which will be answered by one of the Camel developers or another Camel user.
You can even chat in real time with a Camel developer or user on the Camel IRC chat room (http://camel.apache.org/irc-room.html)
D.6 Camel quick reference card There’s a printable quick reference card available for several of Camel’s EIPs at dzone.com (http://refcardz.dzone.com/refcardz/enterprise-integration)
This card contains a short description of each EIP, followed by Java DSL and Spring XML snippets that you can reuse in your own applications.
If you’ve written a blog entry or article, or your company uses Camel and wants to have a link added, please contact the Camel team on the mailing list.
Akka aims to be the platform for the next-generation, event-driven, scalable, and fault-tolerant architectures on the JVM.
One of the core features of Akka is an implementation of the Actor model.
It alleviates the developer from having to deal with explicit locking and thread management.
Using the Actor model raises the abstraction level and provides a better platform for building correct concurrent and scalable applications.
Akka comes with a Camel integration module that allows Akka actors to interact with communication partners over a great variety of protocols and APIs.
We’ll also look at a complete routing example that combines many of the features presented in this appendix.
The examples only scratch the surface of what can be done with Akka.
Interested readers may want to refer to the Akka online documentation for details (http://akkasource.org)
We’ll assume that you already have a basic knowledge of the Scala programming language.
E.1 Introducing the Akka-Camel integration In the Actor model, each object is an actor; an actor is an entity that has a mailbox and a behavior.
Messages can be exchanged between actors, and they’ll be buffered in the mailbox.
Upon receiving a message, the behavior of the actor is executed.
An actor’s behavior can be any piece of code, such as code that changes internal state, sends a number of messages to other actors, creates a number of actors, or assumes new behavior for the next message to be received.
An important property of the Actor model is that there’s no shared state between actors; all communications happen by means of messages.
Messages are exchanged asynchronously, but Akka supports waiting for responses as well.
There’s no concurrent execution of a single actor instance, but different actor instances can process their messages concurrently.
Akka, itself, is written in Scala, so applications often use Akka’s Scala API for exchanging messages with actors.
But this is not always an option, especially in the domain of application integration.
Existing applications often can’t be modified to use the Scala API directly, but can use file transfer on FTP servers or low-level TCP to exchange messages with other applications.
For existing applications to communicate with actors, a separate integration layer is needed, and this is where Camel fits in: Camel is designed around the messaging paradigm, and it supports asynchronous message exchanges as well.
With the akka-camel module, it’s almost trivial to implement message exchanges with actors over protocols and APIs such as HTTP, SOAP, TCP, FTP, SMTP, JMS, and others.
Actors can both consume messages from and produce messages for Camel endpoints.
Another important feature of the akka-camel module is that it fully supports Camel’s asynchronous, nonblocking routing engine: asynchronous message exchanges with actors can be extended to a number of additional protocols and APIs.
Furthermore, all Camel components are supported in a generic way: whenever a new Camel component is released by the Camel community, it can readily be used to exchange messages with Akka actors.
The following section gives a brief introduction to Akka’s Actor API and shows how to create actors and exchange messages with them.
E.2 Getting started with Akka actors Let’s start with a simple example: an actor that prints any message it receives to stdout.
When it receives a special stop message, the actor stops itself.
An actor implementation class must extend the Actor trait and implement the receive partial function.
Incoming messages are matched against the case patterns defined in receive.
If one of the patterns matches, the statement after => is executed.
Akka’s Actor API doesn’t impose any constraints on the message type and format—any Scala object can be sent to an actor.
Before sending a message to the preceding actor, clients need to create and start an instance of SimpleActor.
This is done with the actorOf factory method, which returns an actor reference, and by calling the start method on that reference.
This can be done as follows, where the client creates the actor and sends two messages to it:
The actor reference, once it’s created, is also used for sending messages to the actor.
With the ! (bang) operator, clients send messages with fire-and-forget semantics.
The ! operator adds the message to the actor’s mailbox, and the actor processes the message asynchronously.
The preceding example first sends a "hello akka" string that matches the second pattern in the receive method.
The "stop" message sent afterwards is matched by the first pattern, which stops the actor.
Note that sending a message to a stopped actor throws an exception.
All the examples in this appendix can be run by executing sbt run from the command line.
This command displays a menu, from which you can choose the example to run by its number.
The preceding example only uses a small part of Akka’s Actor API.
It demonstrates how clients can send messages to actors and how actors can match and process these messages.
The next step is to add an additional interface to the actor so that it can receive messages via a Camel endpoint.
E.3 Consuming messages from Camel endpoints If you want to make actors accessible via Camel endpoints, actor classes need to mixin the Consumer trait and implement the endpointUri method.
Consumer actors can be used for both one-way and request-response messaging.
The following listing extends the example from the previous section and enables the actor to receive messages from a SEDA endpoint.
The endpointUri method is implemented to return a SEDA endpoint URI.
This causes the actor to consume messages from the seda:example queue once it is started.
One important difference, compared to SimpleActor, is that the received messages are of type Message, which are immutable representations of Camel messages.
A Message object can be used for pattern matching, and the message body and headers can be bound to variables, as shown in listing E.1
For any consumer actor to receive messages, an application needs to start a CamelService before starting a consumer actor:
The started CamelService instance is returned from the startCamelService method call.
When a consumer actor is started, the CamelService is notified and it will create and start (activate) a route from the specified endpoint to the actor.
Listing E.1 Actor as consumer receiving messages from a SEDA endpoint.
This method blocks until the expected number of endpoints have been activated in the block that follows that method.
The application is then ready to produce messages to the seda:example queue.
If the CamelService has been started, the body of the for comprehension will be executed once with the current ProducerTemplate bound to the template variable.
If the CamelService hasn’t been started, the for body won’t be executed at all.
The application first sends a message that will be printed to stdout, and then it sends a special stop message that stops the actor.
Alternatively, clients can also send Message objects directly via the native Actor API:
SedaConsumer is an actor that doesn’t reply to the initial sender.
Listing E.2 shows how an actor can reply to the initial sender using the self.reply method.
In this example, the initial sender is an HTTP client that communicates with the actor over a Jetty endpoint.
This is an implementation detail: for the receiving actor, both initial sender types appear to be actor references.
When POSTing a message to http://localhost:8811/consumer1, the actor converts the received message body to a String and prepends "received " to it.
Listing E.2 Actor acting as consumer which sends back replies to sender.
The self object is the selfreference to the current actor.
The reply message is a plain String that’s internally converted to a Camel Message before returning it to the Jetty endpoint.
If applications additionally want to add or modify response headers, they can do so by returning a Message object containing the response body and headers.
The next example creates an XML response and sets the Content-Type header to application/xml.
Consumer actors wait for their clients to initiate message exchanges.
If actors themselves want to initiate a message exchange with a Camel endpoint, a different approach must be taken.
E.4 Producing messages to Camel endpoints For producing messages to Camel endpoints, actors have two options.
They can either use a Camel ProducerTemplate directly or mixin the Producer trait in the actor implementation class.
This section will cover the use of the Producer trait.
The use of the Camel ProducerTemplate is explained in appendix C.
The advantage of using the Producer trait is that actors fully leverage Camel’s asynchronous routing engine.
To produce messages to a Camel endpoint, an actor must implement the endpointUri method from the Producer trait, as follows.
In the following code example, an application sends a message to the producer actor with the !! (bangbang) operator, which means it sends and receives eventually:
Listing E.3 An actor sending back XML messages as reply to sender.
Listing E.4 An actor as a producer sending messages to the defined HTTP endpoint.
Producing messages to Camel endpoints the message is sent to the actor asynchronously, but the caller also waits for a response.
For a producer actor at runtime, the type can be one of the following:
The default value is 5000 (ms) and it can be changed by applications.
As you’ve probably realized, HttpProducer1 doesn’t implement a receive method.
This is because the Producer trait provides a default receive implementation that’s inherited by HttpProducer1
The default behavior of Producer.receive is to send messages to the specified endpoint and to return the result to the initial sender.
In the preceding example, the initial sender obtains the result from the !! method call.
In this case, the original sender should use the ! operator for sending the message; otherwise it will wait for a response until timeout.
In the following example, the producer actor simply writes the result to stdout instead of returning it to the sender.
A producer actor by default initiates in-out message exchanges with the specified endpoint.
For initiating in-only message exchanges, producer implementations must either override the Producer.oneway method to return true or mixin the Oneway trait.
The following code shows the latter approach by mixin the Oneway trait:
For producer and consumer actors to work with Camel, applications need to start the CamelService, which sets up the CamelContext for an application.
The next section shows some examples of how applications can customize the process of setting up a CamelContext.
But modifying a CamelContext after it’s been started isn’t always an option.
For example, applications may want to use their own CamelContext implementations or to make some modifications before the CamelContext is started.
This can be achieved either programmatically or declaratively, as explained in the following subsections.
If an application wants to disable JMX, for example, it should do so before the CamelContext is started.
When the CamelService is started, it will also start the user-defined CamelContext.
Alternatively, a CamelService can be created and configured within a Spring application context.
The following Spring XML configuration uses the Akka and Camel XML namespaces to set up a CamelService and a CamelContext respectively.
After creating an application context from the XML configuration, a CamelService B runs and listens for consumer actors to be started.
When the application context (appctx) is destroyed, the CamelService and the CamelContext are shut down as well.
In all the examples so far, routes to actors have been automatically created by the CamelService.
Whenever a consumer actor has been started, this was detected by the CamelService and a route from the actor’s endpoint to the actor itself was added to.
Alternatively, applications can also define custom routes to actors by using Akka’s ActorComponent.
E.6 The Actor component Accessing an actor from a Camel route is done with the Actor component, a Camel component for producing messages to actors.
For example, when starting SedaConsumer from listing E.1, the CamelService adds the following (simplified) route to the CamelContext:
The route starts from seda:example and goes to the started SedaConsumer instance, where <actoruuid> is the consumer actor’s UUID.
Endpoint URIs starting with the actor scheme are used to produce messages to actors.
The Actor component isn’t only intended for internal use but can also be used by user-defined Camel routes to access any actor; in this case, the target actor doesn’t need to implement the Consumer trait.
The Actor component also supports Camel’s asynchronous routing engine and allows asynchronous in-only and in-out message exchanges with actors.
If the communication with the HTTP service succeeds, the producer actor returns a Message object containing the service response or a Failure object with the cause of the failure.
If the producer can’t connect to the service, for example, the failure cause will be a ConnectException.
Other exceptions are possible, but they aren’t included here, to keep the example simple.
After starting the target actor and a CamelService, the application adds the userdefined route to the current CamelContext.
It then uses a ProducerTemplate to initiate an in-out exchange with the route and tries to match the response, where the response either comes from the HTTP service or from the error handler.
We’ll now move on to a more advanced example that applies many of the features described so far.
It combines different actor types to a simple integration solution for transforming the content of a web page.
E.7 A routing example Camel applications usually define message-processing routes with the Camel DSL.
Akka applications can alternatively define networks of interconnected actors, in combination with consumer and producer actors, to set up message-processing routes.
This section shows a simple example of how to set up a message-processing route with actors.
The goal of this example is to display the Akka homepage (http://akkasource.org) in a browser, with occurrences of Akka in the page content replaced with an uppercase AKKA.
The example combines a consumer and a producer actor with another actor that transforms the content of the homepage.
A consumer and a producer actor provide connectivity to external systems.
The consumer actor receives requests from a browser and forwards them to a producer actor, which fetches the HTML page.
The HTML page is then forwarded to an actor that transforms the content of the page and returns the transformation result to the initial sender, so that it can be displayed in the browser.
HttpConsumer is an actor that accepts HTTP GET requests on port 8875 and is configured to forward requests to an instance of HttpProducer.
When an actor forwards a message to another actor, it forwards the initial sender reference as well.
This reference is needed later for returning the result to the initial sender.
A forwarded message causes the HttpProducer to send a GET request to http:// akkasource.org.
Before doing so, it drops all headers B from the request message, except for the HTTP_PATH header, which is needed by the bridge endpoint.
The received HTML content from http://akkasource.org is then forwarded C to an instance of HttpTransformer.
The HttpTransformer D is an actor that replaces all occurrences of Akka in the message body with an uppercase AKKA and returns the result to the initial sender.
The reference to the initial sender has been forwarded by the producer actor C.
After starting the CamelService, the actors are wired and started.
Access http://localhost:8875 from a browser, and a transformed version of the Akka homepage should be displayed.
Finally, it should be noted that the actors and the Jetty endpoints in this example exchange messages asynchronously; no single thread is allocated or blocked for the full duration of an in-out message exchange.
Although it’s not critical for this example, exchanging messages asynchronously can help to save server resources, especially in applications with long-running request-response cycles and frequent client requests.
E.8 Summary This appendix shows you how to exchange messages with Akka actors over protocols and APIs supported by the great variety of Camel components.
You saw how consumer actors can receive messages from Camel endpoints and producer actors can send messages to Camel endpoints.
Setting up a Camel endpoint for an actor is as easy as defining an endpoint URI for that actor.
The prerequisite for running consumer and producer actors is a started CamelService that manages an application’s CamelContext.
Applications can configure the CamelService either programmatically or declaratively based on custom Spring XML schemas provided by Akka and Camel.
You also saw how to use Akka’s Actor component to access any actor from a userdefined Camel route.
Actor endpoints are implemented by defining an actor endpoint URI in the route.
A routing example finally demonstrated how to combine consumer and producer actors to develop a simple integration solution for transforming the content of a web page.
The features described in this appendix are those of Akka version 1.0
If you want to keep track of the latest development activities, get in touch with the Akka community via the Akka User List (http://groups.google.com/group/akka-user) and the Akka Developer List (http://groups.google.com/group/akka-dev)
Camel in Action brief contents contents foreword foreword preface acknowledgments Claus Jon.
Out in the wild Using transactions 9.1 Why use transactions?
