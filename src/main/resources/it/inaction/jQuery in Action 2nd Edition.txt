This is an excellent work, a worthy successor to others in Manning’s “In Action” series.
The Lab pages are a marvelous way to explore the library, which should become an important part of every web developer’s arsenal.
I highly recommend the book for learning the fundamentals of jQuery and then serving as a good reference book as you leverage the power of jQuery more and more in your daily development.
For those new to jQuery, this book is a good primer that covers a range of common uses of the framework....
The examples throughout the book are relevant, and make the point effectively.
The code snippets are easily distinguishable from the rest of the text, and the text is clear and easy to follow.
It works and makes for a very readable book that you can just breeze through very quickly and pick up and retain a lot of information.
Thanks to the authors Bear Bibeault and Yehuda Katz and their exemplary style, this comprehensive book, or operating manual as it might be called, can be taken in a front-to-back approach to learn from scratch, or as a reference to those already dabbling in jQuery and needing verification of best practices.
With its capable technical coverage, extensive use of sample code, and approachable style, jQuery in Action is a valuable resource for any Web developer seeking to maximize the power of JavaScript, and a must-have for anyone interested in learning jQuery.
I highly recommend this book to any novice or advanced JavaScript developers who finally want to get serious about JavaScript and start writing optimized and elegant code without all the hassle of traditional JavaScript code authoring.
I think that jQuery in Action is an excellent book that will help you learn and understand jQuery.
The publisher offers discounts on this book when ordered in quantity.
No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by means electronic, mechanical, photocopying, or otherwise, without prior written permission of the publisher.
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in the book, and Manning Publications was aware of a trademark claim, the designations have been printed in initial caps or all caps.
Recognizing the importance of preserving what has been written, it is Manning’s policy to have the books we publish printed on acid-free paper, and we exert our best efforts to that end.
Recognizing also our responsibility to conserve the resources of our planet, Manning books are printed on paper that is at least 15 percent recycled and processed without the use of elemental chlorine.
Why should web developers be forced to write long, complex, book-length pieces of code when they want to create simple pieces of interaction? There’s nothing that says that complexity has to be a requirement for developing web applications.
When I first set out to create jQuery I decided that I wanted an emphasis on small, simple code that served all the practical applications that web developers deal with day to day.
I was greatly pleased as I read through jQuery in Action to see in it an excellent manifestation of the principles of the jQuery library.
With an overwhelming emphasis on practical, real-world code presented in a terse, to-the-point format, jQuery in Action will serve as an ideal resource for those looking to familiarize themselves with the library.
What’s pleased me the most about this book is the significant attention to detail that Bear and Yehuda have paid to the inner workings of the library.
They were thorough in their investigation and dissemination of the jQuery API.
It felt like nary a day went by in which I wasn’t graced with an email or instant message from them asking for clarification, reporting newly discovered bugs, or recommending improvements to the library.
You can be safe knowing that the resource that you have before you is one of the best thought-out and researched pieces of literature on the jQuery library.
One thing that surprised me about the contents of this book is the explicit inclusion of jQuery plugins and the tactics and theory behind jQuery plugin development.
The reason why jQuery is able to stay so simple is through the use of its plugin.
It provides a number of documented extension points upon which plugins can add functionality.
Often that functionality, while useful, is not generic enough for inclusion in jQuery itself—which is what makes the plugin architecture necessary.
A few of the plugins discussed in this book, like the Forms, Dimension, and LiveQuery plugins, have seen widespread adoption and the reason is obvious: They’re expertly constructed, documented, and maintained.
Be sure to pay special attention to how plugins are utilized and constructed as their use is fundamental to the jQuery experience.
With resources like this book, the jQuery project is sure to continue to grow and succeed.
I hope the book will end up serving you well as you begin your exploration and use of jQuery.
Was it really necessary to update the book so soon?
Absolutely! Compared to the steady world of server-side languages such as Java, the client-side.
And jQuery isn’t eating anyone’s dust; rather, it’s at the forefront of the rush!
The jQuery team releases a major new version of the library just about every year (lately, striving for every January), in addition to the minor updates that are made throughout the calendar year.
That means that there have been numerous minor releases, and two major versions since the publication of the first edition, which was written against jQuery 1.2
With each major release, the capabilities of jQuery have been extended and xvii.
Whether it be the addition of custom events, event namespaces, function and effect queuing, or simply the large handful of really useful methods and functions that have been added, the range of capabilities that jQuery spans has increased significantly since the first edition hit the stands.
And that doesn’t even consider jQuery UI! In its nascent stages two years ago, jQuery UI merited a few sections in one chapter of the first edition.
Since then, jQuery UI has grown in scope and maturity and warrants a complete book part in this edition, consisting of three full chapters.
So it should come as no surprise that this second edition has made its way onto the shelves covering the advances that jQuery and jQuery UI have made over the past two years.
How wrong they were! It actually took longer to complete this second edition than to write the book in the first place.
You see, we didn’t want to fall into the trap of “phoning it in” by just adding updates here and there and calling it done.
We wanted this second edition to be much more than a warmed over version of the first edition.
This second edition isn’t just a tepid rehash of the first edition with some extra information sprinkled here and there.
Each and every paragraph in the text, and each and every line in the example code, has undergone a careful inspection.
After all, as a community, we’ve got two more years of experience writing highly interactive scripted pages using jQuery under our belts.
Every example has been examined and either updated to better show how to use jQuery 1.4 in practice, or replaced with an example that is better suited to showcasing the concepts being discussed.
For example, readers of the first edition may remember the comprehensive Bamboo Grille example at the end of chapter 4 that highlighted jQuery event handling.
Try as we might, we were unable to reshape that example to flaunt the newest jQuery event handling concepts, such as “live” and custom events.
So it has been completely replaced with the DVD Ambassador example that serves as a better vehicle for demonstrating the advanced event-handling concepts.
The second part of the book, focusing on jQuery UI, is completely new material, covering the extensive changes that jQuery UI has undergone since the first edition was published.
The other 50 percent has undergone extensive rework to ensure that it is up to date and reflective of modern best practices.
How did two people with such disparate backgrounds come together to work on a joint project?
The paths by which we came together over our affection for this most useful of client-side tools are as different as night and day.
I (Bear) first heard of jQuery while I was working on Ajax in Practice.
One of the chapters I contributed to Ajax in Practice surveys a number of Ajaxenabling client-side libraries, one of which I was already quite familiar with (Prototype) and others (the Dojo Toolkit and DWR) on which I had to come up to speed pretty quickly.
While juggling what seemed like a zillion tasks (all the while holding down a day job, running a side business, and dealing with household issues), the technical editor, Valentin Crettaz, casually drops this bomb: “So why don’t you have a section on jQuery?”
I was promptly treated to a detailed dissertation on how wonderful this fairly new.
I received a large number of positive responses, all enthusiastic and all agreeing that jQuery really was the cat’s pajamas.
On a rainy Sunday afternoon, I spent about four hours at the jQuery site reading documentation and writing little test programs to get a feel for the jQuery way of doing things.
Then I banged out the new section and sent it to the technical editor to see if I had really gotten it.
The section was given an enthusiastic thumb’s up, and we went on to finally complete the Ajax in Practice book.
That section on jQuery eventually went on to be published in the online version of Dr.
When the dust had settled, my frenzied exposure to jQuery had planted relentless little seeds in the back of my mind.
I’d liked what I’d seen during my headlong research into jQuery, and I set out to learn more.
I started replacing older code in previous projects to see how jQuery would simplify the pages.
Enthusiastic about this new discovery and wanting to share it with others, I took complete leave of my senses and submitted a proposal for jQuery in Action to Manning.
As penance for causing such mayhem, I asked the technical editor who started all the trouble to also be the technical editor for this book.
It’s at that point that the editor, Mike Stephens, asked, “How would you like to work with Yehuda Katz on this project?”
Yehuda came to this project by a different route; his involvement with jQuery predates the days when it even had version numbers.
After he stumbled on the Selectables Plugin, his interest in the jQuery core library was piqued.
Before too long, he was spearheading the push for better online documents, contributing to jQuery, and overseeing the plugin architecture and ecosystem, all while evangelizing jQuery to the Ruby community.
Then came the day when he received a call from Manning (his name having been dropped to the publisher by a friend), asking if he’d be interested in working with this Bear guy on a jQuery book…
Even geographic distance (I’m in the heart of Texas, and Yehuda is on the California coast) proved no barrier.
We think that the combination of our knowledge and talents brings you a strong and informative book.
We hope you have as much fun reading this book as we had working on it.
Similarly, the number of people involved in the writing of a book would probably be a big surprise to most people.
It takes a large collaborative effort on the part of many contributors with a variety of talents to bring the volume you are holding (or ebook that you are reading onscreen) to fruition.
The staff at Manning worked tirelessly with us to make sure that this book attained the level of quality that we hoped for, and we thank them for their efforts.
The “end credits” for this book include not only our publisher, Marjan Bace, and editor Mike Stephens, but also the following contributors: Lianna Wlasiuk, Karen Tegtmayer, Andy Carroll, xxii.
Enough cannot be said to thank our peer reviewers who helped mold the final form of the book, from catching simple typos to correcting errors in terminology and code and even helping to organize the chapters within the book.
Each pass through a review cycle ended up vastly improving the final product.
Very special thanks go to Valentin Crettaz, who served as the book’s technical editor.
In addition to checking each and every sample of example code in multiple environments, he also offered invaluable contributions to the technical accuracy of the text, located information that was originally missing, kept abreast of rapid changes to the libraries while we were writing to make sure that the book represented an up-todate and accurate view of jQuery and jQuery UI, and even provided the PHP versions of the examples requiring server-side code.
For this, my fourth published tome, the cast of characters I’d like to thank has a long list of “usual suspects,” including, once again, the membership and staff at javaranch.com.
Without my involvement in JavaRanch, I’d never have gotten the opportunity to start writing in the first place, and so I sincerely thank Paul Wheaton and Kathy Sierra for starting the whole thing, as well as fellow staffers who gave me encouragement and support, including (but probably not limited to) Eric Pascarello, Ben Souther, Ernest Friedman Hill, Mark Herschberg, Andrew Munkhouse, Jeanne Boyarski, Bert Bates, and Max Habbibi.
Thanks go out to Valentin Crettaz, not only for serving as a superb technical editor and code contributor (as noted above), but also for introducing me to jQuery in the first place.
My partner Jay, and my dogs, Little Bear and Cozmo (whose visages grace the pages of this book), get the usual warm thanks for putting up with the shadowy presence who shared their home but who rarely looked up from his MacBook Pro keyboard for all the months it took to write this book.
And finally, I’d like to thank my coauthor, Yehuda Katz, without whom this project would not have been possible, as well as John Resig and the rest of the jQuery and jQuery UI contributors.
To start, I’d like to thank Bear Bibeault, my coauthor, for the benefit of his extensive writing experience.
His talented writing and impressive abilities to navigate the hurdles of professional publishing were a tremendous part of what made this book possible.
While speaking of making things possible, it’s necessary that I thank my lovely wife Leah, who put up with the long nights and working weekends for far longer than I would have felt comfortable asking.
Her dedication to completing this book rivaled even my own; and, as in all things, she made the most difficult part of this project bearable.
Obviously, there would be no jQuery in Action without the jQuery library itself.
I also count him as a friend who, as a talented author himself, helped me to prepare for this tremendous undertaking.
Lastly, I want to thank my family, whom I don’t see nearly enough since my recent move across the country.
Growing up, my siblings and I shared a tight sense of camaraderie, and the faith my family members have in me has always made me imagine I can do just about anything.
Stated plainly and simply, that is the purpose of this book: to help you learn how to do more on your web application pages with less script.
Your authors, one an avid and enthusiastic user, and the other a jQuery contributor and evangelist, believe that jQuery is the best library available today to help you do just that.
This book is aimed at getting you up and running with jQuery quickly and effectively while having some fun along the way.
All the APIs for the core jQuery library and its companion jQuery UI library are discussed, and each API method is presented in an easy-to-digest syntax block that describes the parameters and return values of the method.
Many examples of effective use of the APIs are included; and, for those big concepts, we provide what we call Lab pages.
These comprehensive and fun pages are an excellent way for you to see the nuances of the jQuery methods in action, without xxv.
All example code and Lab pages are available for download at http://www.manning.
We could go on and on with some marketing jargon telling you how great this.
This book is aimed at web developers, from novice to advanced, who want to take control of the JavaScript on their pages and produce great, interactive web applications without the need to write all the raw, browser-dependent client-side code necessary to achieve such applications from scratch.
All web developers who wish to leverage the power of jQuery to create highly interactive and usable web applications that delight rather than annoy their users will benefit from this book.
Although novice web developers may find some sections a tad involved, this should not deter them from diving into this book.
We’ve included an appendix on essential JavaScript concepts that will help in using jQuery to its fullest potential, and such readers will find that the jQuery library itself is novice-friendly once they understand a few key concepts.
And even though jQuery is friendly to novices, it makes plenty of power available to more advanced web developers.
Whether novices or veterans of web development, client-side programmers will benefit greatly from adding jQuery to their repertoire of development tools.
We know that the lessons within this book will help add this knowledge to your toolbox quickly.
This book is organized to help you wrap your head around jQuery and jQuery UI in the quickest and most efficient manner possible.
It starts with an introduction to the design philosophies on which jQuery was founded and quickly progresses to fundamental concepts that govern the jQuery API.
We then take you through the various areas in which jQuery can help you write exemplary client-side code, from the handling of events all the way to making Ajax requests to the server.
To top it all off, we take an extensive tour through the jQuery UI companion library.
The book is divided into two parts: the first covering the core jQuery library, and the second dealing with jQuery UI.
In chapter 1, we’ll learn about the philosophy behind jQuery and how it adheres to modern principles such as Unobtrusive JavaScript.
We examine why we might want to adopt jQuery, and we run through an overview of how it works.
We delve into key concepts such as document-ready handlers, utility functions, Document Object Model (DOM) element creation, and how jQuery extensions are created.
Chapter 2 introduces us to the jQuery wrapped set—the core concept around which jQuery operates.
We’ll learn how this wrapped set-a collection of DOM elements that’s to be operated upon—can be created by selecting elements from the page document using the rich and powerful collection of jQuery selectors.
We’ll see that these selectors use standard CSS notation, which makes them quite powerful even as they leverage the CSS knowledge we most likely already possess.
In chapter 3, we’ll learn how to use the jQuery wrapped set to manipulate the page DOM.
Chapter 4 shows us how we can use jQuery to vastly simplify the handling of events on our pages.
After all, handling user events is what makes interactive web applications possible, and anyone who’s had to deal with the intricacies of event handlers across the differing browser implementations will certainly appreciate the simplicity that jQuery brings to this particular area.
Advanced event-handling concepts, such as event namespacing, custom event triggering and handling, and even establishing of proactive “live” handlers, are examined in detail and brought together in a comprehensive example project.
We’ll see how jQuery makes creating animated effects not only painless but also efficient and fun.
Function queuing, for serially running effects as well as general functions, is covered in detail.
In chapter 6, we’ll learn about the utility functions and flags that jQuery provides, not only for page authors, but also for those who will write extensions and plugins for jQuery.
We’ll see how jQuery makes it extraordinarily easy for anyone to write such extensions without intricate JavaScript or jQuery knowledge and why it makes sense to write any reusable code as a jQuery extension.
Chapter 8 concerns itself with one of the most important areas in the development of modern web applications: making Ajax requests.
We’ll see how jQuery makes it almost brain-dead simple to use Ajax on our pages, shielding us from all the usual pitfalls, while vastly simplifying the most common types of Ajax interactions (such as returning JSON constructs)
Another comprehensive example project brings all that we’ve learned about jQuery into focus.
In part 2, which consists of three chapters, we’ll explore jQuery’s essential companion library: jQuery UI.
Chapter 9 introduces jQuery UI, and explains how to configure and obtain a customized version of the library code, as well as the visual themes used to style the elements of the UI library.
The visual themes are dissected so that we can learn not only how they’re constructed, but also how we can modify them to our own needs.
Rounding out the chapter is a discussion of the extended effects that jQuery UI adds to the jQuery core, as well as how core methods are augmented to take advantage of those extensions.
In chapter 10, we explore the mouse interaction capabilities that jQuery UI provides.
This extends from dragging and dropping to handling the sorting, selection, and resizing of elements.
This includes such simple controls as buttons through to more sophisticated controls such as date pickers, autocompleters, tabbed panes, and dialog boxes.
To top it all off, we have provided an appendix highlighting key JavaScript concepts such as function contexts and closures—essential to making the most effective use of jQuery on our pages—for readers who are unfamiliar with, or who would like a refresher on, these concepts.
Throughout this book, unique Lab pages are introduced to help illustrate jQuery and jQuery UI concepts.
These labs pages are interactive web pages, provided with the downloaded example code, that you can run on your own local system.
When a new Lab page is introduced, a Labs Icon (the flask icon show at left) is placed in the left margin.
This makes it easy for you to find the location within the text where a lab is first described.
A handy list of the Lab pages is also included right after the Table of Contents, and links to the labs are provided in the index page of the downloaded example code.
You can also access the Labs, as well as the rest of the example code, remotely by pointing your browser at http://www.bibeault.org/jqia2 or from the publisher’s website at http://www.manning.com/jQueryinActionSecondEdition.
Another margin icon you will find sprinkled throughout the book is the Exercises Icon (the triangle and pencil), which pinpoints text passages where exercises that you should work through are presented.
Frequently, these exercises will be related to a particular Lab page, but sometimes they are logical extensions of other code examples described throughout the book, or simply standalone exercises that you should solve to make sure that the concepts are gelling in your mind.
All source code in listings or in the text is in a fixed-width font like this to separate it from ordinary text.
Method and function names, properties, XML elements, and attributes in the text are also presented in this same font.
In some cases, the original source code has been reformatted to fit on the pages.
In general, the original code was written with page-width limitations in mind, but sometimes you may find a slight formatting difference between the code in the book and that provided in the source download.
In a few rare cases, where long lines could not be reformatted without changing their meaning, the book listings contain linecontinuation markers.
Code annotations accompany many of the listings, highlighting important concepts.
In many cases, numbered bullets link to explanations that follow in the text.
For the convenience of those who may not be able to run the examples locally for whatever reason, a working version of the examples is available online at http://www.bibeault.org/jqia2/
The code examples for this book are organized into a web application, with separate sections for each chapter, ready to be easily served by a local web server such as the Apache HTTP Server.
You can simply unzip the downloaded code into a folder of your choice, and make that folder the document root of the application.
A launch page is set up at the application root in the index.html file.
With the exception of the examples for the Ajax chapter (chapter 8) and a handful from the jQuery UI chapters, most of the examples don’t require the presence of a web server at all and can be loaded directly into a browser for execution, if you so desire.
The Ajax examples require more backend interaction than Apache can deliver, so running them locally requires either setting up PHP for Apache, or running a web server capable of executing Java servlets and JavaServer Pages (JSP), such as Tomcat.
The purchase of jQuery in Action, Second Edition includes free accessto a private forum run by Manning Publications where you can make comments about the book, ask technical questions, and receive help from the authors and other users.
To access and subscribe to the forum, point your browser to http://www.manning.
This page provides information on how to get on the forum once you are registered, what kind of help is available, and the rules of conduct in the forum.
Manning’s commitment to our readers is to provide a venue where a meaningful dialogue between individual readers and between readers and the authors can take place.
It’s not a commitment to any specific amount of participation on the part of the authors, whose contribution to the book’s forum remains voluntary (and unpaid)
We suggest you try asking the authors some challenging questions, lest their interest stray!
The Author Online forum and the archives of previous discussions will be accessible from the publisher’s website as long as the book is in print.
Because he has two degrees in Electrical Engineering, Bear should be designing antennas or something; but, since his first job with Digital Equipment Corporation, he has always been much more fascinated with programming.
Bear has also served stints with companies such as Lightbridge Inc., BMC Software, Dragon Systems, Works.com, and a handful of other companies.
Military teaching infantry soldiers how to blow up tanks; skills that come in handy during those daily scrum meetings.
Bear is currently a Software Architect for a leading provider of cloud management software.
When not planted in front of a computer, Bear likes to cook big food (which accounts for his jeans size), dabble in photography and video, ride his Yamaha V-Star, and wear tropical print shirts.
He works and resides in Austin, Texas; a city he dearly loves except for the completely insane drivers.
In addition to being a core team member of the jQuery project, he is also a contributor to Merb, an alternative to Ruby on Rails (also written in Ruby)
Yehuda was born in Minnesota, grew up in New York, and now lives in sunny Santa Barbara, California.
He has programmed professionally in a number of languages including Java, Ruby, PHP, and JavaScript.
In his copious spare time, he maintains VisualjQuery.com and helps answer questions from new jQuery users in the IRC channel and on the official jQuery mailing list.
Dress codes have changed since then and the diversity by region, so rich at the time, has faded away.
It is now often hard to tell the inhabitant of one continent from another.
Perhaps, trying to view it optimistically, we have traded a cultural and visual diversity for a more varied personal life.
Or a more varied and interesting intellectual and technical life.
We at Manning celebrate the inventiveness, the initiative, and the fun of the computer business with book covers based on the rich diversity of regional life two centuries ago brought back to life by the pictures from this travel guide.
When someone hears the name jQuery, they inevitably think of the core jQuery library.
But one could also argue that outside of the core, jQuery has created an entire ecosystem around itself consisting of companion libraries such as jQuery UI (the subject of the second part of this book), the official plugins (see http://plugins.jquery.com/), and the myriad unofficial plugins that people have created that can easily be found with a web search.
Googling the term “jQuery plugin” results in over 4 million entries.
But just as the extensive market for third-party add-on products for Apple’s iPod would not exist if the iPod itself did not, the core jQuery library is the heart of it all.
In the eight chapters in part 1 of this book, we’ll cover the core library from stem to stern.
When you finish these chapters, you’ll know the jQuery library soup to nuts and be ready to tackle any web project armed with one of the most powerful client-side tools available.
You’ll also be prepared to use the jQuery companions, which, much like an iPod accessory, are useless without their core reason for being.
So turn the page, dig in, and get ready to learn how to make breathing life into your web applications not only easy, but fun!
The language has been forced to grow up quickly as client-side developers have tossed aside cut-and-paste JavaScript for the convenience of full-featured JavaScript libraries that solve difficult cross-browser problems once and for all, and provide new and improved patterns for web development.
A relative latecomer to this world of JavaScript libraries, jQuery has taken the web development community by storm, quickly winning the support of major companies for use in mission-critical applications.
Sneered at as a “not-very-serious” language by many web developers for much of its lifetime, JavaScript has regained its prestige in the past few years as a result of the.
Microsoft has even elected to distribute jQuery with its Visual Studio tool, and Nokia uses jQuery on all its phones that include their Web Runtime component.
Rather than spending time juggling the complexities of advanced JavaScript, designers can leverage their existing knowledge of Cascading Style Sheets (CSS), Hypertext Markup Language (HTML), Extensible Hypertext Markup Language (XHTML), and good old straightforward JavaScript to manipulate page elements directly, making rapid development a reality.
In this book, we’re going to take an in-depth look at what jQuery has to offer us as developers of highly interactive web applications.
Let’s start by finding out exactly what jQuery brings to the web development party.
You can obtain the latest version of jQuery from the jQuery site at http:// jquery.com/
Installing jQuery is as easy as placing it within your web application and using the HTML <script> tag to include it in your pages, like this:
The specific version of jQuery that the code in this book was tested against is included as part of the downloadable code examples (available at http://www.manning.com/ bibeault2)
If you’ve spent any time at all trying to add dynamic functionality to your pages, you’ve found that you’re constantly following a pattern of selecting an element (or group of elements) and operating upon those elements in some fashion.
You could be hiding or revealing the elements, adding a CSS class to them, animating them, or inspecting their attributes.
Using raw JavaScript can result in dozens of lines of code for each of these tasks, and the creators of jQuery specifically created that library to make common tasks trivial.
For example, anyone who has dealt with radio groups in JavaScript knows that it’s a lesson in tedium to discover which radio element of a radio group is currently checked and to obtain its value attribute.
The radio group needs to be located, and the resulting array of radio elements must be inspected, one by one, to find out which element has its checked attribute set.
Contrast that with how it can be done using jQuery:
Don’t worry if that looks a bit cryptic right now.
In short order, you’ll understand how it works, and you’ll be whipping out your own terse—but powerful—jQuery statements to make your pages come alive.
We identify all elements that possess a name attribute with the value someRadioGroup (remember that radio groups are formed by naming all their elements using the same name), then filter that set to only those that are in checked state, and find the value of that element.
There will be only one such element, because the browser will only allow a single element of the radio group to be checked at a time.
The real power in this jQuery statement comes from the selector, which is an expression used to identify target elements on a page.
It allows us to easily locate and grab the elements that we need; in this case, the checked element in the radio group.
If you haven’t downloaded the example code yet, now would be a great time to do so.
Unpack the code and either navigate to the files individually, or use the nifty index page at index.html in the root of the unpacked folder hierarchy.
This page, shown in figure 1.1, uses the jQuery statement that we just examined to determine which radio button has been checked.
Even this simple example ought to convince you that jQuery is the hassle-free way to create the next generation of highly interactive web applications.
But just wait until we show you how much power jQuery offers for taming your web pages as we progress through this book’s chapters.
We’ll soon study how to easily create the jQuery selectors that made this example so easy, but first let’s examine how the inventors of jQuery think JavaScript can be most effectively used on our pages.
You may recall the bad old days before CSS, when we were forced to mix stylistic markup with the document structure markup in our HTML pages.
Anyone who’s been authoring pages for any amount of time surely does, most likely with less than fondness.
The addition of CSS to our web development toolkits allows us to separate stylistic information from the document structure and gives travesties like the <font> tag the well-deserved boot.
Not only does the separation of style from structure make our documents easier to manage, it also gives us the versatility to completely change the stylistic rendering of a page by simply swapping out different style sheets.
Few of us would voluntarily regress back to the days of applying styles with HTML elements; yet markup such as the following is still all too common:
You can easily see that the style of this button element, including the font of its caption, isn’t applied via the use of the <font> tag and other deprecated style-oriented markup, but is determined by whatever CSS rules (not shown) are in effect on the page.
But although this declaration doesn’t mix style markup with structure, it does mix behavior with structure by including the JavaScript to be executed when the button is clicked as part of the markup of the button element via the onclick attribute (which, in this case, turns some Document Object Model (DOM) element with the id value of xyz red)
For all the same reasons that it’s desirable to segregate style from structure within an HTML document, it’s just as beneficial (if not more so) to separate the behavior from the structure.
Ideally, an HTML page should be structured as shown in figure 1.2, with structure, style, and behavior each partitioned nicely in its own niche.
Figure 1.2 With structure, style, and behavior each neatly tucked away within a page, readability and maintainability are maximized.
This strategy, known as Unobtrusive JavaScript, was brought into the limelight by the inventors of jQuery and is now embraced by every major JavaScript library, helping page authors achieve this useful separation on their pages.
As the library that popularized this movement, jQuery’s core is well optimized for producing Unobtrusive JavaScript quite easily.
Unobtrusive JavaScript considers any JavaScript expressions or statements embedded in the <body> of HTML pages, either as attributes of HTML elements (such as onclick) or in script blocks placed within the body of the page, to be incorrect.
Much simpler! But now, you’ll note, the button doesn’t do anything.
We can click it all day long, and no behavior will result.
Rather than embedding the button’s behavior in its markup, we’ll segregate the script by moving it to a script block in the <head> section of the page, outside the scope of the document body (see note below), as follows:
We place the script in the onload handler for the page to assign an inline function to the onclick attribute of the button element.
We add this script in the onload handler (as opposed to within an inline script block) because we need to make sure that the button element exists before we attempt to augment it.
In section 1.3.3 we’ll see how jQuery provides a better place for us to put such code.
The important concept is to avoid embedding behavioral elements within the structural elements.
If any of the code in this example looks odd to you (such as the concept of function literals and inline functions), fear not! The appendix to this book provides a look at the important JavaScript concepts that you’ll need to use jQuery effectively.
We’ll also examine, in the remainder of this chapter, how jQuery makes writing this code easier and quicker and makes the code more versatile all at the same time.
Unobtrusive JavaScript, though a powerful technique to add to the clear separation of responsibilities within a web application, doesn’t come without a price.
You might already have noticed that it took a few more lines of script to accomplish our goal than when we placed it into the button markup.
Unobtrusive JavaScript may increase the line count of the script that needs to be written, and it requires some discipline and the application of good coding patterns to the client-side script.
But none of that is bad; anything that persuades us to write our client-side code with the same level of care and respect usually allotted to server-side code is a good thing! But it is extra work—without jQuery, that is.
As mentioned earlier, the jQuery team has specifically focused jQuery on the task of making it easy and delightful for us to code our pages using Unobtrusive JavaScript techniques, without paying a hefty price in terms of effort or code bulk.
We’ll find that making effective use of jQuery will enable us to accomplish much more on our pages while writing less code.
Without further ado, let’s start looking at how jQuery makes it so easy for us to add rich functionality to our pages without the expected pain.
At its core, jQuery focuses on retrieving elements from HTML pages and performing operations upon them.
If you’re familiar with CSS, you’re already well aware of the power of selectors, which describe groups of elements by their type, attributes, or placement within the document.
With jQuery, we can employ that knowledge, and that degree of power, to vastly simplify our JavaScript.
Should we find that the library needs a bit more juice, jQuery has a simple but powerful built-in method for extending its functionality via plugins.
Many new jQuery programmers find themselves putting this versatility into practice by extending jQuery with their own plugins on their first day.
Let’s start by taking a look at how we can leverage our CSS knowledge to produce powerful, yet terse, code.
When CSS was introduced to web technologies in order to separate design from content, a way was needed to refer to groups of page elements from external style sheets.
The method developed was through the use of selectors, which concisely represent elements based upon their type, attributes, or position within the HTML document.
Those familiar with XML might be reminded of XPath as a means to select elements within an XML document.
To collect a group of elements, we pass the selector to the jQuery function using the simple syntax.
Although you may find the $() notation strange at first, most jQuery users quickly become fond of its brevity.
For example, to wrap the group of links nested inside any <p> element, we can use the following:
The $() function (an alias for the jQuery() function) returns a special JavaScript object containing an array of the DOM elements, in the order in which they are defined within the document, that match the selector.
This object possesses a large number of useful predefined methods that can act on the collected group of elements.
In programming parlance, this type of construct is termed a wrapper because it wraps the collected elements with extended functionality.
We’ll use the term jQuery wrapper or wrapped set to refer to this set of matched elements that can be operated on with the methods defined by jQuery.
A special feature of a large number of these methods, which we often refer to as jQuery wrapper methods, is that when they’re done with their action (like a hide operation), they return the same group of elements, ready for another action.
For example, say that we want to add a new class, removed, to each of the elements in addition to hiding them.
It’s not uncommon to find examples in the wild of jQuery chains dozens of methods long.
And because each method works on all of the elements matched by the original selector, there’s no need to loop over the array of elements.
Even though the selected group of objects is represented as a highly sophisticated JavaScript object, we can pretend it’s a typical array of elements, if necessary.
Because we’ve used an ID selector, only one element will match the selector.
The first example uses the jQuery html() method, which replaces the contents of a DOM element with some HTML markup.
The second example uses jQuery to retrieve an array of elements, selects the first one using an array index of 0, and replaces the contents using an ordinary JavaScript property assignment to innerHTML.
If we wanted to achieve the same results with a selector that results in multiple matched elements, the following two fragments would produce identical results (though the latter example is not a recommended way of coding using jQuery):
As things get progressively more complicated, making use of jQuery’s chainability will continue to reduce the lines of code necessary to produce the results we want.
Additionally, jQuery supports not only the selectors that you have already come to know and love, but also more advanced selectors—defined as part of the CSS specification—and even some custom selectors.
That’s powerful stuff! You’ll be able to leverage your existing knowledge of CSS to get up and running.
We’ll be covering jQuery selectors in great detail in chapter 2, and you can find a full list on the jQuery site at http://docs.jquery.com/Selectors.
Selecting DOM elements for manipulation is a common need in web pages, but some things that we’ll also need to do don’t involve DOM elements at all.
Let’s take a brief look at what jQuery offers beyond element manipulation.
Even though wrapping elements to be operated upon is one of the most frequent uses of jQuery’s $() function, that’s not the only duty to which it’s assigned.
One of its additional duties is to serve as the namespace prefix for a handful of general-purpose utility functions.
Because so much power is given to page authors by the jQuery wrapper created as a result of a call to $() with a selector, it’s somewhat rare for most page authors to need the services provided by some of these functions.
In fact, we won’t be looking at the majority of these functions in detail until chapter 6 as a preparation for writing jQuery plugins.
But you will see a few of these functions put to use in the upcoming sections, so we’ll briefly introduce them here.
The notation for these functions may look odd at first.
Let’s take, for example, the utility function for trimming strings.
Here it becomes clear that the trim() function is merely namespaced by jQuery or its $ alias.
We’ll put aside this technical distinction and use the term utility function to describe these methods so as not to introduce terminology that conflicts with the online documentation.
But first, let’s look at another important duty that jQuery’s $() function performs.
When embracing Unobtrusive JavaScript, behavior is separated from structure, so we’re performing operations on the page elements outside of the document markup that creates them.
In order to achieve this, we need a way to wait until the DOM elements of the page are fully realized before those operations execute.
In the radio group example, the entire body must load before the behavior can be applied.
Traditionally, the onload handler for the window instance is used for this purpose, executing statements after the entire page is fully loaded.
This causes the defined code to execute after the document has fully loaded.
Unfortunately, the browser not only delays executing the onload code until after the DOM tree is created, but also waits until after all external resources are fully loaded and the page is displayed in the browser window.
This includes not only resources like images, but QuickTime and Flash videos embedded in web pages, and there are more and more of them these days.
As a result, visitors can experience a serious delay between the time that they first see the page and the time that the onload script is executed.
Even worse, if an image or other resource takes significant time to load, visitors will have to wait for the image loading to complete before the rich behaviors become available.
This could make the whole Unobtrusive JavaScript proposition a non-starter for many real-life cases.
A much better approach would be to wait only until the document structure is fully parsed and the browser has converted the HTML into its resulting DOM tree before executing the script to apply the rich behaviors.
Accomplishing this in a cross-browser manner is somewhat difficult, but jQuery provides a simple means to trigger the execution of code once the DOM tree has loaded (without waiting for external resources)
The formal syntax to define such code (using our hiding example) is as follows:
First, we wrap the document instance with the jQuery() function, and then we apply the ready() method, passing a function to be executed when the document is ready to be manipulated.
We called that the formal syntax for a reason; a shorthand form, used much more frequently, is as follows:
By passing a function to jQuery() or $(), we instruct the browser to wait until the DOM has fully loaded (but only the DOM) before executing the code.
Even better, we can use this technique multiple times within the same HTML document, and the browser will execute all of the functions we specify in the order that they are declared within the page.
In contrast, the window’s onload technique allows for only a single function.
This limitation can also result in hard-to-find bugs if any included third-party code uses the onload mechanism for its own purpose (not a best-practice approach)
That’s another use of the $() function; now let’s look at yet something else it can do for us.
As you can see by now, the authors of jQuery avoided introducing a bunch of global names into the JavaScript namespace by making the $() function (which you’ll recall is merely an alias for the jQuery() function) versatile enough to perform many duties.
Well, there’s one more duty that we need to examine.
We can create DOM elements on the fly by passing the $() function a string that contains the HTML markup for those elements.
For example, we can create a new paragraph element as follows:
But creating a disembodied DOM element (or hierarchy of elements) isn’t all that useful; usually the element hierarchy created by such a call is then operated on using one of jQuery’s DOM manipulation functions.
Let’s examine the code of listing 1.1 as an example.
This example establishes an existing HTML paragraph element named followMe C in the document body.
In the script element within the <head> section, we establish a ready handler B that uses the following statement to insert a newly created paragraph into the DOM tree after the existing element:
Now that you’ve seen the basic syntax of jQuery, let’s take a look at one of the most powerful features of the library.
The jQuery wrapper function provides a large number of useful methods we’ll use again and again in these pages.
It could be argued that no library should even try to anticipate every possible need; doing so could result in a large, clunky mass of code that contains little-used features that merely serve to gum up the works!
The authors of the jQuery library recognized this concept and worked hard to identify the features that most page authors would need and included only those in the core library.
Recognizing also that page authors would each have their own unique requirements, jQuery was designed to be easily extended with additional functionality.
We could write our own functions to fill in any gaps, but once we’ve been spoiled by the jQuery way of doing things, we’ll find that doing things the old-fashioned way is beyond tedious.
By extending jQuery, we can use the powerful features it provides, particularly in the area of element selection.
Let’s look at a specific example: jQuery doesn’t come with a predefined function to disable a group of form elements.
If we’re using forms throughout an application, we might find it convenient to be able to write code such as the following:
Fortunately, and by design, jQuery makes it easy to extend its set of methods by extending the wrapper returned when we call $()
Let’s take a look at the basic idiom for how that’s accomplished by coding a new disable() function:
A lot of new syntax is introduced here, but don’t worry about it too much yet.
It’ll be old hat once you’ve made your way through the next few chapters; it’s a basic idiom that you’ll use over and over again.
Figure 1.3 Dynamically creating and inserting elements, usually requiring many lines of code, can be accomplished in a single line of jQuery code.
Inside that function, the this keyword is the collection of wrapped DOM elements that are to be operated upon.
Then, the each() method of this wrapper is called to iterate over each element in the wrapped collection.
Inside of the iterator function passed to each(), this is a reference to the specific DOM element for the current iteration.
Don’t be confused by the fact that this resolves to different objects within the nested functions.
After writing a few extended functions, it becomes natural to remember that this refers to the function context of the current function.
The appendix is also there to explain the JavaScript concept of the this keyword.
For each element, we check whether the element has a disabled attribute, and if it does, we set it to true.
We return the result of the each() method (the wrapper) so that our brand new disable() method will support chaining, like many of the native jQuery methods.
From the point of view of our page code, it’s as though our new disable() method was built into the library itself! This technique is so powerful that most new jQuery users find themselves building small extensions to jQuery almost as soon as they start to use the library.
Moreover, enterprising jQuery users have extended jQuery with sets of useful functions that are known as plugins.
Testing for existence You might have seen this common idiom for testing the existence of an item:
The idea here is that if the item doesn’t exist, the conditional expression will evaluate to false.
Although this works in most circumstances, the framers of jQuery feel that it’s a bit too sloppy and imprecise and recommend the more explicit test used in the $.fn.disable example:
This expression will correctly test for null or undefined items.
For a full list of the various coding styles recommended by the jQuery team, visit the jQuery documentation page at http://docs.jquery.com/JQuery_Core_Style_Guidelines.
Before we dive into using jQuery to bring life to our pages, you may be wondering if we’re going to be able to use jQuery with Prototype or other libraries that also use the $ shortcut.
Even though jQuery provides a set of powerful tools that will meet most of our needs, there may be times when a page requires that multiple JavaScript libraries be employed.
This situation could come about when we’re transitioning an application from a previously employed library to jQuery, or we might want to use both jQuery and another library on our pages.
The jQuery team, clearly revealing their focus on meeting the needs of their user community rather than any desire to lock out other libraries, have made provisions for allowing jQuery to cohabitate with other libraries.
First, they’ve followed best-practice guidelines and have avoided polluting the global namespace with a slew of identifiers that might interfere not only with other libraries, but also with names we might want to use on our pages.
The identifier jQuery and its alias $ are the limit of jQuery’s incursion into the global namespace.
Defining the utility functions that we referred to in section 1.3.2 as part of the jQuery namespace is a good example of the care taken in this regard.
Although it’s unlikely that any other library would have a good reason to define a global identifier named jQuery, there’s that convenient but, in this particular case, pesky $ alias.
Other JavaScript libraries, most notably the Prototype library, use the $ name for their own purposes.
And because the usage of the $ name in that library is key to its operation, this creates a serious conflict.
The thoughtful jQuery authors have provided a means to remove this conflict with a utility function appropriately named noConflict()
Anytime after the conflicting libraries have been loaded, a call to.
We’ve covered a great deal of material in this whirlwind introduction to jQuery, in preparation for diving into using jQuery to quickly and easily enable the development of next-generation web applications.
With this approach, behavior is separated from structure in the same way that CSS separates style from structure, achieving better page organization and increased code versatility.
Summary great deal of functionality by making that function highly versatile, adjusting the operation that it performs based upon the parameters passed to it.
In the chapters that follow, we’ll explore all that jQuery has to offer us as developers of rich internet applications.
We’ll begin our tour in the next chapter as we learn how to use jQuery selectors to quickly and easily identify the elements that we wish to act upon.
In the previous chapter, we discussed the many ways that the jQuery function can be used.
Its capabilities range from the selection of DOM elements to defining functions to be executed when the DOM is loaded.
In this chapter, we’ll examine (in great detail) how the DOM elements to be acted upon are identified by looking at two of the most powerful and frequently used capabilities of jQuery’s $() function: the selection of DOM elements via selectors and the creation of new DOM elements.
A good number of the capabilities required by interactive web applications are achieved by manipulating the DOM elements that make up the pages.
But before they can be manipulated, they need to be identified and selected.
Let’s begin our detailed tour of the many ways that jQuery lets us specify which elements are to be targeted for manipulation.
The first thing we need to do when using virtually any jQuery method (frequently referred to as jQuery wrapper methods) is to select some document elements to act upon.
Sometimes, the set of elements we want to select will be easy to describe, such as “all paragraph elements on the page.” Other times, they’ll require a more complex description like “all list elements that have the class listElement, contain a link, and are first in the list.”
Fortunately, jQuery provides a robust selector syntax we can use to easily specify sets of elements elegantly and concisely.
You probably already know a big chunk of the syntax: jQuery uses the CSS syntax you already know and love, and extends it with some custom means to perform both common and complex selections.
Figure 2.1 The jQuery Selectors Lab Page allows you to observe the behavior of any selector you choose in real time.
When displayed, the Lab should look as shown in figure 2.1 (if the panes don’t appear correctly lined up, you may need to widen your browser window)
The Selector pane at top left contains a text box and a button.
To run a Lab “experiment,” type a selector into the text box and click the Apply button.
Go ahead and type the string li into the box, and click the Apply button.
The selector that you type (in this case li) is applied to the HTML fragment loaded into the DOM Sample pane at upper right.
The Lab code that executes when Apply is clicked adds a class named wrappedElement to be applied to all matching elements.
A CSS rule defined for the page causes all elements with that class to be highlighted with a red border and pink background.
Note that the <li> elements in the sample fragment have been highlighted and that the executed jQuery statement, as well as the tag names of the selected elements, have been displayed below the Selector text box.
The HTML markup used to render the DOM sample fragment is displayed in the lower pane, labeled DOM Sample Code.
This should help you experiment with writing selectors targeted at the elements in this sample.
We’ll talk more about using this Lab as we progress through the chapter.
But first, your authors must admit that they’ve been blatantly over-simplifying an important concept, and that’s going to be rectified now.
Up to this point, we’ve been acting as if there were only one argument passed to jQuery’s $() function, but this was just a bit of hand waving to keep things simple at the start.
In fact, for the variants in which a selector or an HTML fragment is passed to the $() function, a second argument is accepted.
When the first argument is a selector, this second argument denotes the context of the operation.
As we’ll see with many of jQuery’s methods, when an optional argument is omitted, a reasonable default is assumed.
When a selector is passed as the first argument (we’ll deal with passing HTML fragments later), the context defaults to applying that selector to every element in the DOM tree.
That’s quite often exactly what we want, so it’s a nice default.
But there may be times when we want to limit our search to a subset of the entire DOM.
Selecting elements for manipulation can identify a subset of the DOM that serves as the root of the sub-tree to which the selector is applied.
The Selectors Lab offers a good example of this scenario.
When that page applies the selector that you typed into the text field, the selector is applied only to the subset of the DOM that’s loaded into the DOM Sample pane.
We can use a DOM element reference as the context, but we can also use either a string that contains a jQuery selector, or a wrapped set of DOM elements.
So yes, that means that we can pass the result of one $() invocation to another—don’t let that make your head explode just yet; it’s not as confusing as it may seem at first.
When a selector or wrapped set is provided as the context, the identified elements serve as the contexts for the application of the selector.
As there can be multiple such elements, this is a nice way to provide disparate sub-trees in the DOM to serve as the contexts for the selection process.
We’ll assume that the selector string is stored in a variable conveniently named selector.
When we apply this submitted selector, we only want to apply it to the sample DOM, which is contained within a <div> element with an id value of sampleDOM.
What we want is to limit the selection process to the sub-tree of the DOM rooted at the <div> element with the id of sampleDOM; so instead we write.
OK, now that we know how to control where to apply selectors, let’s see how to.
For applying styles to page elements, web developers have become familiar with a small, but powerful and very useful, group of selection expressions that work across all browsers.
Those expressions can select by an element’s ID, by CSS class names, by tag names, and by the hierarchy of the page elements within the DOM.
Table 2.1 provides some examples to give you a quick refresher.
We can mix and match these basic selector types to identify fairly fine-grained sets of elements.
With jQuery, we can easily select elements using the CSS selectors that we’re already accustomed to using.
With a few exceptions, jQuery is fully CSS3 compliant, so selecting elements this way will present no surprises; the same elements that would be selected in a style sheet by a.
Note that jQuery does not depend upon the CSS implementation of the browser it’s running within.
Even if the browser doesn’t implement a standard CSS selector correctly, jQuery will correctly select elements according to the rules of the World Wide Web Consortium (W3C) standard.
For some practice, play with the Selectors Lab and run some experiments with some basic CSS selectors until you feel comfortable with them.
These basic selectors are powerful, but sometimes we’ll need even finer-grained control over which elements we want to match.
These advanced selectors allow us to select the direct children of some elements, elements that occur after other elements in the DOM, and even elements with attributes matching certain conditions.
Sometimes, we’ll want to select only the direct children of a certain element.
For example, we might want to select list elements directly under some list, but not list elements belonging to a sublist.
Consider the following HTML fragment from the sample DOM in the Selectors Lab:
Suppose that we wanted to select the link to the remote jQuery site, but not the links to various local pages describing the different CSS specifications.
Using basic CSS selectors, we might try something like ul.myList li a.
Unfortunately, that selector would grab all links because they all descend from a list element.
You can verify this by entering the selector ul.myList li a into the Selectors Lab and clicking Apply.
A more advanced approach is to use child selectors, in which a parent and its direct child are separated by the right angle bracket character (>), as in.
This selector matches only links that are direct children of a <p> element.
Going back to our example, consider a selector such as.
This selector selects only links that are direct children of list elements, which are in turn direct children of <ul> elements that have the class myList.
Say that we want to attach a special behavior only to links that point to locations outside your site.
Let’s take another look at that portion of the Lab example that we previously examined:
What makes the link pointing to an external site unique is the http:// at the beginning of the string value for the link’s href attribute.
We could select links that have an href value starting with http:// with the following selector:
This matches all links with an href value beginning with the exact string http://
The caret character (^) is used to specify that the match is to occur at the beginning of a value.
As this is the same character used by most regular expression processors to signify matching at the beginning of a candidate string, it should be easy to remember.
Visit the Lab page again (from which the previous HTML fragment was lifted), type a[href^='http://'] into the text box, and click Apply.
To match an element that possesses a specific attribute, regardless of its value, we can use.
This matches any <form> element that has an explicit method attribute.
To match a specific attribute value, we use something like.
This selector matches all input elements with a type of text.
We’ve already seen the “match attribute at beginning” selector in action.
This selects all <div> elements with a title attribute whose value begins with my.
What about an “attribute ends with” selector? Coming right up:
This is a useful selector for locating all links that reference PDF files.
And here’s a selector for locating elements whose attributes contain arbitrary.
As we’d expect, this selector matches all <a> elements that reference the jQuery site.
Table 2.2 shows the basic CSS selectors that we can use with jQuery.
With all this knowledge in hand, head over to the Selectors Lab page, and spend.
Try to make some targeted selections like the <span> elements containing the text Hello and Goodbye (hint: you’ll need to use a combination of selectors to get the job done)
As if the power of the selectors that we’ve discussed so far isn’t enough, there are some more options that offer an even finer ability to slice and dice the page.
E>F Matches all elements with tag name F that are direct children of E.
E+F Matches all elements with tag name F that are immediately preceded by sibling E.
E~F Matches all elements with tag name F preceded by any sibling E.
E.C Matches all elements with tag name E with class name C.
E#I Matches all elements with tag name E with the id of I.
E[A] Matches all elements with tag name E that have attribute A of any value.
E[A=V] Matches all elements with tag name E that have attribute A whose value is exactly V.
E[A^=V] Matches all elements with tag name E that have attribute A whose value starts with V.
E[A$=V] Matches all elements with tag name E that have attribute A whose value ends with V.
E[A!=V] Matches all elements with tag name E that have attribute A whose value doesn’t match.
E[A*=V] Matches all elements with tag name E that have attribute A whose value contains V.
Sometimes, we’ll need to select elements by their position on the page or in relation to other elements.
We might want to select the first link on the page, or every other paragraph, or the last list item of each list.
This format of selector matches the first <a> element on the page.
As we might expect, we can also specify that evenly ordered elements be selected with.
There are a whole slew of these selectors, some defined by CSS, others specific to jQuery, and they can provide surprisingly elegant solutions to sometimes tough problems.
The CSS specification refers to these types of selectors as pseudo-classes, but jQuery has adopted the crisper term filters, because each of these selectors filter a base selector.
These filter selectors are easy to spot, as they all begin with the colon (:) character.
And remember, if you omit any base selector, it defaults to *
See table 2.3 for a list of these positional filters (which the jQuery documentation terms the basic and child filters)
This becomes second nature with practice, but it may be a bit confusing at first.
It contains a list of programming languages and some basic information about them:
Table 2.3 The positional filter selectors supported by jQuery (continued)
Let’s say that we wanted to get all of the table cells that contain the names of programming languages.
Because they’re all the first cells in their rows, we could use.
If we wanted the absolute last table cell (the one containing the text 1983), we’d use td:last.
Again, remember that :eq is zero-based, but :nth-child is one-based.
Before we move on, head back over to the Selectors Lab and try selecting entries two and four from the list.
Then, try to find three different ways to select the cell containing the text 1972 in the table.
Also, try and get a feel for the difference between the :nth-child type of filters and the absolute position selectors.
Even though the CSS selectors we’ve examined so far are incredibly powerful, let’s discuss ways of squeezing even more power out of jQuery’s selectors.
The CSS selectors that we’ve seen so far give us a great deal of power and flexibility to match the desired DOM elements, but there are even more selectors that give us further ability to filter the selections.
As an example, we might want to match all checkboxes that are in checked state.
You might be tempted to try something along these lines:
But trying to match by attribute will only check the initial state of the control as specified in the HTML markup.
What we really want to check is the real-time state of the controls.
As if that wasn’t enough, jQuery provides a whole handful of powerful custom filter selectors, not specified by CSS, that make identifying target elements even easier.
For example, the custom :checkbox selector identifies all check box elements.
Combining these custom selectors can be powerful; consider :checkbox:checked or :radio:checked.
As we discussed earlier, jQuery supports the CSS filter selectors and also defines a number of custom selectors.
Many of these CSS and custom jQuery filter selectors are form-related, allowing us to specify, rather elegantly, a specific element type or state.
For example, if we want to select only enabled and checked checkboxes, we could use.
Try out as many of these filters as you like in the Selectors Lab until you feel that you have a good grasp on their operation.
These filters are an immensely useful addition to the set of selectors at our disposal, but what about the inverse of these filters?
If we want to negate a selector, let’s say to match any input element that’s not a checkbox, we can use the :not filter.
For example, to select non-checkbox <input> elements, you could use.
But be careful! It’s easy to go astray and get some unexpected results! For example, let’s say that we wanted to select all images except for those whose src.
But if we used this selector, we’d find that not only did we get all the image elements that don’t reference “dog” in their src, we’d also get every element in the DOM that isn’t an image element!
Again, use the Lab page to conduct experiments until you’re comfortable with how to use the :not filter to invert selections.
Table 2.4 The CSS and custom jQuery filter selectors (continued)
As we saw earlier, CSS defines a useful selector for selecting elements that are descendants of particular parents.
But what if we wanted the opposite? What if we wanted to select all <div> elements.
This can be a powerful mechanism when we get to the point where we want to select elements that represent complex constructs.
For example, let’s say that we want to find which table row contains a particular image element that can be uniquely identified using its src attribute.
You can be sure that this, along with the other jQuery filters, will play a large part in the code we examine going forward.
But before we look at the manipulation methods, let’s look at how to use the $() function to create new HTML elements.
Sometimes, we’ll want to generate new fragments of HTML to insert into the page.
Such dynamic elements could be as simple as extra text we want to display under certain conditions, or something as complicated as creating a table of database results we’ve obtained from a server.
This expression creates a new <div> element ready to be added to the page.
Generating new HTML be run on the newly created fragment.
This may not seem impressive on first glance, but when we throw event handlers, Ajax, and effects into the mix (as we will in the upcoming chapters), you’ll see that it could come in mighty handy.
Note that if we want to create an empty <div> element, we can get away with this shortcut:
It’s almost embarrassingly easy to create such simple HTML elements, and thanks to the chainability of jQuery methods, creating more complex elements isn’t much harder.
We can apply any jQuery method to the wrapped set containing the newly created element.
For example, we can apply styles to the element with the css() method.
We could also create attributes on the element with the attr() method, but jQuery provides an even better means to do so.
We can pass a second parameter to the element-creating $() method that specifies the attributes and their values.
This parameter takes the form of a JavaScript object whose properties serve as the name and value of the attributes to be applied to the element.
Let’s say that we want to create an image element complete with multiple attributes, some styling, and let’s make it clickable to boot! Take a look at the code in listing 2.1
We also threw a bit of a curve ball at you here.
We used the attribute object to establish an event handler that issues an alert (garnered from the image’s title) when the image is clicked D.
We haven’t examined these methods yet, but we can set values for the following methods (which we’ll mostly discuss in the next chapter): val, css, html, text, data, width, height, and offset.
So, in listing 2.1 we could omit the call to the chained css() method, replacing it with the following property in the attribute parameter:
Regardless of how we arrange the code, that’s a pretty hefty statement—which we spread across multiple lines, and with logical indentation, for readability—but it also does a heck of a lot.
Such statements aren’t uncommon in jQuery-enabled pages, and if you find it a bit overwhelming, don’t worry, we’ll be covering every method used in this statement over the next few chapters.
Writing such compound statements will be second nature before much longer.
Figure 2.5a Creating complex elements on the fly, including this image, which generates an alert when it’s clicked upon, is easy as pie.
Up until now, we’ve applied wrapper methods to the entire wrapped set as created by the jQuery function when we pass a selector to it.
But there may be times when we want to further manipulate that set before acting upon it.
Once we’ve got a set of wrapped elements, whether identified from existing DOM elements with selectors, or created as new elements using HTML snippets (or a combination of both), we’re ready to manipulate those elements using the powerful set of jQuery methods.
We’ll start looking at those methods in the next chapter, but what if we want to further refine the set of elements wrapped by the jQuery function? In this section, we’ll explore the many ways that we can refine, extend, or subset the set of wrapped elements that we wish to operate upon.
This page, which looks a lot like the Selectors Lab we employed earlier in this chapter, is shown in figure 2.6
This new Lab page not only looks like the Selectors Lab, it also operates in a similar fashion.
Except in this Lab, rather than typing a selector, we can type in any complete jQuery operation that results in a wrapped set.
The operation is executed in the context of the DOM Sample, and, as with the Selectors Lab, the results are displayed.
In a sense, the jQuery Operations Lab is a more general case of the Selectors Lab.
Where the latter only allowed us to enter a single selector, the jQuery Operations Lab allows us to enter any expression that results in a jQuery wrapped set.
Be aware that you need to enter valid syntax, as well as expressions that result in a jQuery wrapped set.
Otherwise, you’re going to be faced with a handful of unhelpful JavaScript errors.
To get a feel for the Lab, display it in your browser and enter this text into the Operation field:
Figure 2.6 The jQuery Operations Lab Page lets us compose wrapped sets in real time to help us see how wrapped sets can be created and managed.
This operation is executed within the context of the DOM Sample, and you’ll see how the images disappear from the sample.
After any operation, you can restore the DOM Sample to its original condition by clicking the Restore button.
We’ll see this new Lab in action as we work our way through the sections that follow, and you might even find it helpful in later chapters to test various jQuery operations.
We mentioned before that the set of jQuery wrapped elements acts a lot like an array.
This mimicry includes a length property, just like JavaScript arrays, that contains the number of wrapped elements.
Should we wish to use a method rather than a property, jQuery also defines the size() method, which returns the same information.
The jQuery expression embedded in the statement matches all elements of type <a> and returns the number of matched elements using the size() method.
This is used to construct a text string, which is set as the content of an element with id of someDiv using the html() method (which we’ll see in the next chapter)
The formal syntax of the size() method is as follows:
OK, so now we know how many elements we have.
Usually, once we have a wrapped set of elements, we’ll use jQuery methods to perform some sort of operation upon them as a whole; for example, hiding them all with the hide() method.
But there may be times when we want to get our grubby little hands on a direct reference to an element or elements to perform raw JavaScript operations upon them.
Let’s look at some of the ways that jQuery allows us to do just that.
Because jQuery allows us to treat the wrapped set as a JavaScript array, we can use simple array indexing to obtain any element in the wrapped list by position.
For example, to obtain the first element in the set of all <img> elements with an alt attribute on the page, we could write.
If you prefer to use a method rather than array indexing, jQuery defines the get() method for that purpose:
The get() method will also accept a negative index value as a parameter.
In addition to obtaining a single element, get() can also return an array.
Although the toArray() method (discussed in the next section) is the preferred.
This method of obtaining an array is provided for backward compatibility with previous versions of jQuery.
The get() method returns a DOM element, but sometimes we’ll want a wrapped set containing a specific element rather than the element itself.
It would look really weird to write something like this:
So jQuery provides the eq() method, that mimics the action of the :eq selector filter:
If no parameter is specified, all elements in the wrapped set are returned in a JavaScript array.
If an index parameter is provided, the indexed element is returned.
Parameters index (Number) The index of the single element to return.
Returns A DOM element or an array of DOM elements.
Obtaining the first element of a wrapped set is such a common operation that there’s a convenience method that makes it even easier: the first() method.
As you might expect, there’s a corresponding method to obtain the last element in a wrapped set as well.
Now let’s examine the preferred method of obtaining an array of wrapped elements.
Parameters index (Number) The index of the single element to return.
If the original set is empty, so is the returned set.
If the original set is empty, so is the returned set.
If we wish to obtain all of the elements in a wrapped set as a JavaScript array of DOM elements, jQuery provides the toArray() method:
While get() finds an element given an index, we can use an inverse operation, index(), to find the index of a particular element in the wrapped set.
Let’s say that for some reason we want to know the ordinal index of an image with the id of findMe within the entire set of images in a page.
A JavaScript array of the DOM elements within the wrapped set.
If the element isn’t found, the value -1 is returned.
Parameters element (Element|Selector) A reference to the element whose ordinal value is to be.
If omitted, the first element of the wrapped set is located within its list of siblings.
Returns The ordinal value of the passed element within the wrapped set or its siblings, or -1 if not found.
The index() method can also be used to find the index of an element within its parent (that is, among its siblings)
This will set n to the ordinal index of the first <img> element within its parent.
Now, rather than obtaining direct references to elements or their indexes, how.
Once you have a wrapped element set, you may want to augment that set by adding to it or by reducing the set to a subset of the originally matched elements.
First, let’s look at adding elements to a wrapped set.
We may often find ourselves wanting to add more elements to an existing wrapped set.
This capability is most useful when we want to add more elements after applying some method to the original set.
Remember, jQuery chaining makes it possible to perform an enormous amount of work in a single statement.
We’ll look at some concrete examples of such situations in a moment, but first, let’s start with a simpler scenario.
Let’s say that we want to match all <img> elements that have either an alt or a title attribute.
The powerful jQuery selectors allow us to express this as a single selector, such as.
But to illustrate the operation of the add() method, we could match the same set of elements with.
Using the add() method in this fashion allows us to chain a bunch of selectors together, creating a union of the elements that satisfy either of the selectors.
Methods such as add() are also significant (and more flexible than aggregate selectors) within jQuery method chains because they don’t augment the original wrapped set, but create a new wrapped set with the result.
We’ll see in just a bit how this can be extremely useful in conjunction with methods such as end() (which we’ll examine in section 2.3.6) that can be used to “back out” operations that augment original wrapped sets.
Bring up the jQuery Operations Lab page in your browser, and enter this expression:
This will execute the jQuery operation and result in the selection of all images with either an alt or title attribute.
Inspecting the HTML source for the DOM Sample reveals that all the images depicting flowers have an alt attribute, the puppy images have a title attribute, and the coffee pot image has neither.
Therefore, we should expect that all images but the coffee pot will become part of the wrapped set.
We can see that five of the six images (all but the coffee pot) were added to the wrapped set.
The red outline may be a bit hard to see in the print version of this book with grayscale figures, but if you have downloaded the project (which you should have) and are using it to follow along (which you should be), it’s very evident.
Now let’s take a look at a more realistic use of the add() method.
The comma operator (,) of CSS selectors won’t help us with this one because we want to apply an operation to a wrapped set and then add more elements to it before applying another operation.
We could easily accomplish this with multiple statements, but it would be more efficient and elegant to use the power of jQuery chaining to accomplish the task in a single expression, such as this:
The expression can be a selector, an HTML fragment, a DOM element, or an array of DOM elements.
This parameter can be a jQuery selector, in which case any matched elements are added to the set.
If the parameter is an HTML fragment, the appropriate elements are created and added to the set.
If it is a DOM element or an array of DOM elements, they’re added to the set.
This is the same context that can be passed to the jQuery() function.
Returns A copy of the original wrapped set with the additional elements.
Enter this statement into the jQuery Operations Lab (which has predefined the referenced classes), and view the results as shown in figure 2.8
In these results, we can see that the flower images (those with alt) have thick borders, and all images but the coffee pot (the only one with neither an alt nor a title) are faded as a result of applying an opacity rule.
The add() method can also be used to add elements to an existing wrapped set, given direct references to those elements.
Figure 2.7 The expected image elements, those with an alt or title attribute, have been matched by the jQuery expression.
If we had an element reference in a variable named someElement, it could be added to the set of all images containing an alt property with this statement:
As if that wasn’t flexible enough, the add() method not only allows us to add existing elements to the wrapped set, but we can also use it to add new elements by passing it a string containing HTML markup.
Note that doing so only adds the new element to the wrapped set; no action has been taken in this statement to add the new element to the DOM.
We might then use the jQuery appendTo() method (patience, we’ll be talking about such methods soon enough) to append the elements we selected, as well as the newly created HTML, to some part of the DOM.
Augmenting the wrapped set with add() is easy and powerful, but now let’s look at the jQuery methods that let us remove elements from a wrapped set.
We saw that it’s a simple matter to augment wrapped sets from multiple selectors chained together with the add() method.
It’s also possible to chain selectors together to form an except relationship by employing the not() method.
This is similar to the :not filter selector we discussed earlier, but it can be employed in a similar fashion to the add() method to remove elements from the wrapped set anywhere within a jQuery chain of methods.
Let’s say that we want to select all <img> elements in a page that sport a title attribute except for those that contain the text “puppy” in the title attribute value.
By using the not() method, which removes any elements from a wrapped set that match the passed selector expression, we can express an except type of relationship.
Type this expression into the jQuery Operations Lab Page, and execute it.
You’ll see that only the tan puppy image has the highlight applied.
Figure 2.8 jQuery chaining allows us to perform complex operations in a single statement, as seen in these results.
Managing the wrapped element set included in the original wrapped set because it possesses a title attribute, is removed by the not() invocation because its title contains the text “puppy”
The not() method can be used to remove individual elements from the wrapped set by passing a reference to an element or an array of element references.
The latter is interesting and powerful because, remember, any jQuery wrapped set can be used as an array of element references.
When maximum flexibility is needed, a function can be passed to not(), and a determination of whether to keep or remove the element can be made on an elementby-element basis.
This expression will select all <img> elements and then remove any that don’t have the class “keepMe”
This method allows us to filter the wrapped set in ways that are difficult or impossible to express with a selector expression by resorting to programmatic filtering of the wrapped set items.
For those times when the test applied within the function passed to not() seems to be the opposite of what we want to express, not() has an inverse method, filter(), that works in a similar fashion, except that it removes elements when the function returns false.
For example, let’s say that we want to create a wrapped set of all <td> elements that contain a numeric value.
As powerful as the jQuery selector expressions are, such a requirement is impossible to express using them.
For such situations, the filter() method can be employed, as follows:
This jQuery expression creates a wrapped set of all <td> elements and then invokes the function passed to the filter() method for each, with the current matched.
If the parameter is a jQuery selector, any matching elements are removed.
If an element reference or array of elements is passed, those elements are removed from the set.
If a function is passed, the function is invoked for each item in the wrapped set (with this set to the item), and returning true from the invocation causes the item to be removed from the wrapped set.
Returns A copy of the original wrapped set without the removed elements.
The function uses a regular expression to determine whether the element content matches the described pattern (a sequence of one or more digits), returning false if not.
Elements whose filter function invocation returns false aren’t included in the returned wrapped set.
Again, bring up the jQuery Operations Lab, type the previous expression in, and execute it.
You’ll see that the table cells for the “Invented” column are the only <td> elements that end up being selected.
The filter() method can also be used with a passed selector expression.
When used in this manner, it operates in the inverse manner than the corresponding not() method, removing any elements that don’t match the passed selector.
This isn’t a super-powerful method, as it’s usually easier to use a more restrictive selector in the first place, but it can be useful within a chain of jQuery methods.
This chained statement selects all images, applies the seeThrough class to them, and then reduces the set to only those image elements whose title attribute contains the string dog before applying another class named thickBorder.
The result is that all the images end up semi-transparent, but only the tan dog gets the thick border treatment.
The not() and filter() methods give us powerful means to adjust a set of wrapped elements on the fly, based on just about any criteria concerning the wrapped elements.
But we can also subset the wrapped set, based on the position of the elements within the set.
If the parameter is a jQuery selector, any elements that don’t match are removed.
If an element reference or array of elements is passed, all but those elements are removed from the set.
If a function is passed, the function is invoked for each element in the wrapped set (with this referencing the element), and returning false from the invocation causes the element to be removed from the wrapped set.
Returns A copy of the original wrapped set without the filtered elements.
Sometimes you may wish to obtain a subset of a wrapped set based upon the position of the elements within the set.
This method creates and returns a new set from any contiguous portion, or a slice, of an original wrapped set.
If we want to obtain a wrapped set that contains a single element from another set, based on its position in the original set, we can employ the slice() method, passing the zero-based position of the element within the wrapped set.
For example, to obtain the third element, we could write.
This statement selects all elements on the page and then generates a new set containing the third element in the matched set.
Note that this is different from $('*').get(2), which returns the third element in the wrapped set, not a wrapped set containing the element.
To grab elements from the end of the wrapped set, the statement.
Another method we can use to obtain a subset of a wrapped set is the has() method.
Like the :has filter, this method tests the children of the wrapped elements, using this check to choose the elements to become part of the subset.
Parameters begin (Number) The zero-based position of the first element to be included in the.
If omitted, the slice extends to the end of the set.
We’ll often want to perform transformations on the elements of a wrapped set.
For example, what if we wanted to collect all the id values of the wrapped elements, or perhaps collect the values of a wrapped set of form elements in order to create a query string from them? The map() method comes in mighty handy for such occasions.
For example, the following code will collect all the id values of all images on the page into a JavaScript array:
If any invocation of the callback function returns null, no corresponding entry is made in the returned set.
Parameters test (Selector|Element) A selector to be applied to all descendents of the wrapped.
Only elements possessing an element that matches the selector, or the passed element, are included in the returned wrapped set.
Parameters callback (Function) A callback function that’s invoked for each element in the wrapped.
Two parameters are passed to this function: the zero-based index of the element within the set, and the element itself.
The element is also established as the function context (the this keyword)
The map() method is useful for iterating over the elements of a wrapped set in order to collect values or translate the elements in some other way, but we’ll have many occasions where we’ll want to iterate over the elements for more general purposes.
An example of using this method could be to easily set a property value onto all elements in a matched set.
This statement will invoke the passed function for each image element on the page, modifying its alt property using the order of the element and its id value.
As a convenience, the each() method will also iterate over arrays of JavaScript objects and even individual objects (not that the latter has a lot of utility)
This statement will invoke the iterator function for each element of the array that’s passed to $(), with the individual array items passed to the function as this.
And we’re not done yet! jQuery also gives us the ability to obtain subsets of a wrapped set based on the relationship of the wrapped items to other elements in the DOM.
Most of these methods accept an optional selector expression that can be used to choose the elements to be collected into the new set.
If no such selector parameter is passed, all eligible elements are selected.
Parameters iterator (Function) A function called for each element in the matched set.
The element is also established as the function context (the this reference)
All of the methods in table 2.5, with the exception of contents() and offsetParent() accept a parameter containing a selector string that can be used to filter the results.
Table 2.5 Methods for obtaining a new wrapped set based on relationships to other HTML DOM elements.
This is frequently used to obtain the contents of <iframe> elements.
If no matches are made to the selector, or if the selector is omitted, all following siblings are selected.
This includes the direct parents as well as the remaining ancestors all the way up to, but not including, the document root.
If no matches are made to the selector, or if the selector is omitted, all ancestors are selected.
If no matches are made to the selector, or if the selector is omitted, all previous siblings are selected.
Consider a situation where a button’s event handler (which we’ll be exploring in great detail in chapter 4) is triggered with the button element referenced by the this keyword within the handler.
Further, let’s say that we want to find the <div> block within which the button is defined.
We can refine the selector we pass to closest() to discriminate which elements are selected:
Now the ancestor <div> with the class myButtonContainer will be selected.
The remainder of these methods work in a similar fashion.
Take, for example, a situation in which we want to find a sibling button with a particular title attribute:
These methods give us a large degree of freedom to select elements from the DOM based on their relationships to the other DOM elements.
As if all that were not enough, there are still a few more tricks that jQuery has up its sleeve to let us refine our collections of wrapped objects.
The find() method lets us search through the descendants of the elements in a wrapped set and returns a new set that contains all elements that match a passed selector expression.
For example, given a wrapped set in variable wrappedSet, we can get another wrapped set of all citations (<cite> elements) within paragraphs that are descendants of elements in the original wrapped set:
Like many other jQuery wrapper methods, the find() method’s power comes when it’s used within a jQuery chain of operations.
Parameters selector (String) A jQuery selector that elements must match to become part of the.
This method becomes very handy when we need to constrain a search for descendant elements in the middle of a jQuery method chain, where we can’t employ any other context or constraining mechanism.
The last method that we’ll examine in this section is one that allows us to test a wrapped set to see if it contains at least one element that matches a given selector expression.
The is() method returns true if at least one element matches the selector, and false if not.
This statement sets the value of the hasImage variable to true if the current DOM has an image element.
This is a highly optimized and fast operation within jQuery and can be used without hesitation in areas where performance is of high concern.
We’ve made a big deal about the ability to chain jQuery wrapper methods together to perform a lot of activity in a single statement, and we’ll continue to do so, because it is a big deal.
This chaining ability not only allows us to write powerful operations in a concise manner, but it also improves efficiency because wrapped sets don’t have to be recomputed in order to apply multiple methods to them.
Depending upon the methods used in a method chain, multiple wrapped sets may be generated.
For example, using the clone() method (which we’ll explore in detail in chapter 3) generates a new wrapped set, which creates copies of the elements in the first set.
If, once a new wrapped set was generated, we had no way to reference the original set, our ability to construct versatile jQuery method chains would be severely curtailed.
Two wrapped sets are generated within this statement: the original wrapped set of all the <img> elements in the DOM, and a second wrapped set consisting of only those wrapped elements which also possess title attributes.
Parameters selector (String) The selector expression to test against the elements of the wrapped set.
Returns true if at least one element matches the passed selector; false if not.
Managing the wrapped element set with a single selector, but bear with us for illustration of the concept.
Imagine that we do something important in the chain before the call to filter()
But what if we subsequently want to apply a method, such as adding a class name, to the original wrapped set after it’s been filtered? We can’t tack it onto the end of the existing chain; that would affect the titled images, not the original wrapped set of images.
This method, when used within a jQuery chain, will “back up” to a previous wrapped set and return it as its value so that subsequent operations will apply to that previous set.
The filter() method returns the set of titled images, but by calling end() we back up to the previous wrapped set (the original set of all images), which gets operated on by the addClass() method.
Without the intervening end() method, addClass() would have operated on the set of clones.
It might help to think of the wrapped sets generated during a jQuery method chain as being held on a stack.
When end() is called, the top-most (most recent) wrapped set is popped from the stack, leaving the previous wrapped set exposed for subsequent methods to operate upon.
Another handy jQuery method that modifies the wrapped set “stack” is andSelf(), which merges the two topmost sets on the stack into a single wrapped set.
Whew! At the end of it all, the <div> elements end up with classes a and c, whereas the images that are descendants of those elements are given classes b and c.
We can see that jQuery provides the means to manage wrapper sets for just about any type of operations that we want to perform upon them.
This chapter focused on creating and adjusting sets of elements (referred in this chapter and beyond as the wrapped set) via the many means that jQuery provides for identifying elements on an HTML page.
These selectors include the CSS3 syntax currently supported by most modern browsers.
The creation and augmentation of wrapped sets using HTML fragments to create new elements on the fly is another important feature that jQuery provides.
These orphaned elements can be manipulated, along with any other elements in the wrapped set, and eventually attached to parts of the page document.
A robust set of methods to adjust the wrapped set in order to refine the contents of the set, either immediately after creation, or midway through a set of chained methods, is available.
Applying filtering criteria to an already existing set can also easily create new wrapped sets.
All in all, jQuery offers a lot of tools to make sure that you can easily and accurately identify the page elements we wish to manipulate.
In this chapter, we covered a lot of ground without really doing anything to the DOM elements of the page.
But now that we know how to select the elements that we want to operate upon, we’re ready to start adding life to our pages with the power of the jQuery DOM manipulation methods.
Remember those days (luckily, now fading into memory) when fledgling page authors would try to add pizzazz to their pages with counterproductive abominations such as marquees, blinking text, loud background patterns (that inevitably interfered with the readability of the page text), annoying animated GIFs, and, perhaps worst of all, unsolicited background sounds that would play upon page load (and only served to test how fast a user could close down the browser)?
Today’s savvy web developers and designers know better, and use the power given to them by DOM scripting (what us old-timers might once have called Dynamic HTML, or DHTML) to enhance a user’s web experience, rather than showcase annoying tricks.
Whether it’s to incrementally reveal content, create input controls beyond the basic set provided by HTML, or give users the ability to tune pages to their own liking, DOM manipulation has allowed many a web developer to amaze (not annoy) their users.
On an almost daily basis, many of us come across web pages that do something that makes us say, “Hey! I didn’t know you could do that!” And being the commensurate professionals that we are (not to mention being insatiably curious about such things), we immediately start looking at the source code to find out how they did it.
But rather than having to code up all that script ourselves, we’ll find that jQuery provides a robust set of tools to manipulate the DOM, making those types of “Wow!” pages possible with a surprisingly small amount of code.
Whereas the previous chapter introduced us to the many ways jQuery lets us select DOM elements into a wrapped set, this chapter puts the power of jQuery to work performing operations on those elements to bring life and that elusive “Wow!” factor to our pages.
Some of the most basic components we can manipulate, when it comes to DOM elements, are the properties and attributes assigned to those elements.
These properties and attributes are initially assigned to the JavaScript object instances that represent the DOM elements as a result of parsing their HTML markup, and they can be changed dynamically under script control.
Let’s make sure that we have our terminology and concepts straight.
Properties are intrinsic to JavaScript objects, and each has a name and a value.
The Appendix goes into great detail on this concept if you’re new to JavaScript.
Attributes aren’t a native JavaScript concept, but one that only applies to DOM elements.
Attributes represent the values that are specified on the markup of DOM elements.
In this element’s markup, the tag name is img, and the markup for id, src, alt, class, and title represents the element’s attributes, each of which consists of a name and a value.
This element markup is read and interpreted by the browser to create the JavaScript object instance that represents this element in the DOM.
The attributes are gathered into a list, and this list is stored as a property named, reasonably enough, attributes on the DOM element instance.
In addition to storing the attributes in this list, the object is given a number of properties, including some that represent the attributes of the element’s markup.
As such, the attribute values are reflected not only in the attributes list, but also in a handful of properties.
There remains an active connection between the attribute values stored in the.
Changing an attribute value results in a change in the corresponding property value and vice versa.
For example, setting the src attribute of the image element to image.gif will result in the src property being set to the full absolute URL of the image.
For the most part, the name of a JavaScript property matches that of any corresponding attribute, but there are some cases where they differ.
For example, the class attribute in this example is represented by the className property.
Which of these we choose to manipulate depends on what we want to do and how we want to do it.
Let’s start by looking at getting and setting element properties.
Figure 3.1 HTML markup is translated into DOM elements, including the attributes of the tag and properties created from them.
The browser creates a correspondence between the attributes and properties of the elements.
Rather, we use the native JavaScript notation to access the properties and their values.
The trick is in getting to the element references in the first place.
But it’s not really tricky at all, as it turns out.
As we saw in the previous chapter, jQuery gives us a number of ways to access the individual elements of the wrapped set.
As an example of using the each() method, we could use the following code to set the id property of every element in the DOM to a name composed of the element’s tag name and position within the DOM:
In this example, we obtain element references as the function context (this) of the callback function, and directly assign values to their id properties.
Dealing with attributes is a little less straightforward than dealing with properties in JavaScript, so jQuery provides more assistance for handling them.
As we’ll find is true with many jQuery methods, the attr() method can be used either as a read or as a write operation.
When jQuery methods can perform such bilateral operations, the number and types of parameters passed into the method determine which variant of the method is executed.
As one of these bilateral methods, the attr() method can be used to either fetch the value of an attribute from the first element in the matched set, or to set attribute values onto all matched elements.
The syntax for the fetch variant of the attr() method is as follows:
Parameters name (String) The name of the attribute whose value is to be fetched.
Returns The value of the attribute for the first matched element.
Even though we usually think of element attributes as those predefined by HTML, we can use attr() with custom attributes set through JavaScript or HTML markup.
To illustrate this, let’s amend the <img> element of our previous example with a custom markup attribute (highlighted in bold):
Note that we’ve added a custom attribute, unimaginatively named data-custom, to the element.
We can retrieve that attribute’s value, as if it were any of the standard attributes, with.
Regardless of how an attribute such as title is declared in the markup, we can access (or set, as we shall see) attributes using any variants of case: Title, TITLE, TiTlE, and any other combinations are all equivalent.
In XHTML, even though attribute names must be lowercase in the markup, we can retrieve them using any case variant.
At this point you may be asking, “Why deal with attributes at all when accessing the properties is so easy (as seen in the previous section)?”
The answer to that question is that the jQuery attr() method is much more than a wrapper around the JavaScript getAttribute() and setAttribute() methods.
In addition to allowing access to the set of element attributes, jQuery provides access to some commonly used properties that, traditionally, have been a thorn in the side of page authors everywhere due to their browser dependency.
This set of normalized-access names is shown in table 3.1
Custom attributes and HTML Under HTML 4, using a nonstandard attribute name such as data-custom, although a common sleight-of-hand trick, will cause your markup to be considered invalid, and it will fail formal validation testing.
Any attributes following this naming convention will be considered valid according to HTML 5’s rules; those that don’t will continue to be considered invalid.
In anticipation of HTML 5, we’ve adopted the data- prefix in our example.
In addition to these helpful shortcuts, the set variant of attr() has some of its own handy features.
There are two ways to set attributes onto elements in the wrapped set with jQuery.
Let’s start with the most straightforward, which allows us to set a single attribute at a time (for all elements in the wrapped set)
This variant of attr(), which may at first seem simple, is actually rather sophisticated in its operation.
In its most basic form, when the value parameter is any JavaScript expression that results in a value (including an array), the computed value of the expression is set as the attribute value.
Things get more interesting when the value parameter is a function reference.
In such cases, the function is invoked for each element in the wrapped set, with the return value of the function used as the attribute value.
When the function is invoked, it’s passed two parameters: one that contains the zero-based index of the element within the wrapped set, and one that contains the current value of the named attribute.
Additionally, the element is established as the function context (this) for the.
Parameters name (String) The name of the attribute to be set.
The function is invoked for each wrapped element, passing the index of the element and the current value of the named attribute.
The return value of the function becomes the attribute value.
Working with element properties and attributes function invocation, allowing the function to tune its processing for each specific element—the main power of using functions in this way.
This method will run through all elements on the page, modifying the title attribute of each element by appending a string (composed using the index of the element within the DOM and the id attribute of each specific element) to the previous value.
We’d use this means of specifying the attribute value whenever that value is dependent upon other aspects of the element, when we need the orginal value to compute the new value, or whenever we have other reasons to set the values individually.
The second set variant of attr() allows us to conveniently specify multiple attributes at a time.
This format is a quick and easy way to set multiple attributes onto all the elements of a wrapped set.
The passed parameter can be any object reference, commonly an object literal, whose properties specify the names and values of the attributes to be set.
This statement sets the value of all <input> elements to the empty string, and sets the title to the string Please enter a value.
If you want to change the name or type of <input> elements in Internet Explorer, you must replace the element with a new element possessing the desired name or type.
This also applies to the value attribute of file and password types of <input> elements.
Parameters attributes (Object) An object whose properties are copied as attributes to all elements in.
Now that we know how to get and set attributes, what about getting rid of them?
In order to remove attributes from DOM elements, jQuery provides the removeAttr() method.
Note that removing an attribute doesn’t remove any corresponding property from the JavaScript DOM element, though it may cause its value to change.
For example, removing a readonly attribute from an element would cause the value of the element’s readOnly property to flip from true to false, but the property itself isn’t removed from the element.
Now let’s look at some examples of how we might use this knowledge on our pages.
Let’s see how these methods can be used to fiddle with the element attributes in various ways.
Let’s say that we want to make all links on our site that point to external domains open in new windows.
This is fairly trivial if we’re in total control of the entire markup and can add a target attribute, as shown:
That’s all well and good, but what if we’re not in control of the markup? We could be running a content management system or a wiki, where end users will be able to add content, and we can’t rely on them to add the target="_blank" to all external links.
First, let’s try and determine what we want: we want all links whose href attribute begins with http:// to open in a new window (which we’ve determined can be done by setting the target attribute to _blank)
Well, we can use the techniques we’ve learned in this section to do this concisely, as follows:
First, we select all links with an href attribute starting with http:// (which indicates that the reference is external)
Parameters name (String) The name of the attribute to be removed.
Another excellent use for jQuery’s attribute functionality is helping to solve a longstanding issue with web applications (rich and otherwise): the Dreaded Double-Submit Problem.
This is a common dilemma for web applications when the latency of form submissions, sometimes several seconds or longer, gives users an opportunity to press the submit button multiple times, causing all manner of grief for the server-side code.
For the client side of the solution (the server-side code should still be written in a paranoid fashion), we’ll hook into the form’s submit event and disable the submit button after its first press.
That way, users won’t get the opportunity to click the submit button more than once and will get a visual indication (assuming that disabled buttons appear so in their browser) that the form is in the process of being submitted.
Don’t worry about the details of event handling in the following example (we’ll get more than enough of that in chapter 4), but concentrate on the use of the attr() method:
Within the body of the event handler, we grab all submit buttons that are inside our form with the :submit selector and modify the disabled attribute to the value "disabled" (the official W3C-recommended setting for the attribute)
Note that when building the matched set, we provide a context value (the second parameter) of this.
As we’ll find out when we dive into event handling in chapter 4, the this pointer always refers to the page element for which the event was triggered while operating inside event handlers; in this case, the form instance.
Adding this type of feature to the client code makes things nicer for the end user and helps prevent the.
When is “enabled” not enabling? Don’t be fooled into thinking that you can substitute the value enabled for disabled as follows:
According to W3C rules, it’s the presence of the disabled attribute, not its value, that places the element in disabled state.
So it really doesn’t matter what the value is; if the disabled attribute is present, the element is disabled.
So, to re-enable the element, we’d either remove the attribute or use a convenience that jQuery provides for us: if we provide the Boolean values true or false as the attribute value (not the strings “true” or “false”), jQuery will do the right thing under the covers, removing the attribute for false, and adding it for true.
It doesn’t protect against attacks or other hacking attempts, and server-side code must continue to be on its guard.
Element attributes and properties are useful concepts for data as defined by HTML and the W3C, but in the course of page authoring, we frequently need to store our own custom data.
Let’s see what jQuery can do for us on that front.
Let’s just come right out and say it: global variables suck.
Except for the infrequent, truly global values, it’s hard to imagine a worse place to.
Not only do we run into scope issues, they also don’t scale well when we have multiple operations occurring simultaneously (menus opening and closing, Ajax requests firing, animations executing, and so on)
The functional nature of JavaScript can help mitigate this through the use of closures, but closures can only take us so far and aren’t appropriate for every situation.
Because our page behaviors are so element-focused, it makes sense to make use of the elements themselves as storage scopes.
Again, the nature of JavaScript, with its ability to dynamically create custom properties on objects, can help us out here.
Being that DOM elements are represented by JavaScript object instances, they, like all other object instances, can be extended with custom properties of our own choosing.
Particularly, it can be easy to create circular references that can lead to serious memory leaks.
In traditional web applications, where the DOM is dropped frequently as new pages are loaded, memory leaks may not be as big of an issue.
But for us, as authors of highly interactive web applications, employing lots of script on pages that may hang around for quite some time, memory leaks can be a huge problem.
We can place any arbitrary JavaScript value, even arrays and objects, onto DOM elements by use of the cleverly named data() method.
Parameters name (String) The name of the data to be stored.
The function's returned value is used as the data value.
Data that’s write-only isn’t particularly useful, so a means to retrieve the named data must be available.
It should be no surprise that the data() method is once again used.
Here is the syntax for retrieving data using the data() method:
In the interests of proper memory management, jQuery also provides the removeData() method as a way to dump any data that may no longer be necessary:
Note that it’s not necessary to remove data “by hand” when removing an element from the DOM with jQuery methods.
The capability to tack data onto DOM elements is one that we’ll see exploited to our advantage in many of the examples in upcoming chapters, but for those who have run into the usual headaches that global variables can cause, it’s easy to see how storing data in-context within the element hierarchy opens up a whole new world of possibilities.
In essence, the DOM tree has become a complete “namespace” hierarchy for us to employ; we’re no longer limited to a single global space.
We mentioned the className property much earlier in this section as an example of a case where markup attribute names differ from property names; but, truth be told, class names are a bit special in other respects as well, and are handled as such by jQuery.
The next section will describe a better way to deal with class names than by directly accessing the className property or using the attr() method.
If we want to change the styling of an element, we have two options.
We can add or remove a class, causing any existing style sheets to restyle the element based on its new classes.
Or we can operate on the DOM element itself, applying styles directly.
Let’s look at how jQuery makes it simple to make changes to an element’s style via classes.
Parameters name (String) The name of the data to be retrieved.
Parameters name (String) The name of the data to be removed.
The class attribute of DOM elements is unique in its format and semantics and is crucially important to the creation of interactive interfaces.
The addition of class names to and removal of class names from an element are the primary means by which their stylistic rendering can be modified dynamically.
One of the aspects of element class names that make them unique—and a challenge to deal with—is that each element can be assigned any number of class names.
In HTML, the class attribute is used to supply these names as a space-delimited string.
Unfortunately, rather than manifesting themselves as an array of names in the DOM element’s corresponding className property, the class names appear as that same spacedelimited string.
How disappointing, and how cumbersome! This means that whenever we want to add class names to or remove class names from an element that already has class names, we need to parse the string to determine the individual names when reading it and be sure to restore it to valid space-delimited format when writing it.
Although it’s not a monumental task to write code to handle all that, it’s always a good idea to abstract such details behind an API that hides the mechanical details of such operations.
Adding class names to all the elements of a matched set is an easy operation with the following addClass() method:
Removing class names is just as straightforward with the following removeClass() method:
If a function, the function is invoked for each wrapped element, with that element set as the function context, and passing two parameters: the element index and the current class value.
The function’s returned value is used as the class name or names.
Often, we may want to switch a set of styles back and forth, perhaps to indicate a change between two states or for any other reasons that make sense with our interface.
One situation where the toggleClass() method is most useful is when we want to switch visual renditions between elements quickly and easily.
Let’s consider a “zebrastriping” example in which we want to give alternating rows of a table different colors.
And imagine that we have some valid reason to swap the colored background from the odd rows to the even rows (and perhaps back again) when certain events occur.
The toggleClass() method would make it almost trivial to add a class name to every other row, while removing it from the remainder.
Within the script defined for that page, a function is defined as follows:
This function uses the toggleClass() method to toggle the class named striped for all <tr> elements.
If a function, the function is invoked for each wrapped element, setting that element as the function context, and passing two parameters: the element index, and the class value prior to any removal.
The function’s returned value is used as the class name or names to be removed.
Note that each element is tested individually, so some elements may have the class name added, and others may have it removed.
If a function, the function is invoked for each wrapped element, passing that element as the function context.
The function’s returned value is used as the class name or names.
The first statement in the body of this handler applies the class striped to every other row of the table using the nth-child selector that we learned about in the previous chapter.
The second statement establishes event handlers for mouseover and mouseout events that both call the same swapThem function.
We’ll be learning all about event handling in the next chapter, but for now the important point is that whenever the mouse enters or leaves the table, the following line of code ends up being executed:
This (somewhat annoying) activity is shown in the two parts of figure 3.2
Toggling a class based upon whether the elements already possess the class or not is a very common operation, but so is toggling the class based on some other arbitrary condition.
For this more general case, jQuery provides another variant of the toggleClass() method that lets us add or remove a class based upon an arbitrary Boolean expression:
If a function, the function is invoked for each wrapped element, setting that element as the function context, and passing two parameters: the element index and the current class value.
The function’s returned value is used as the class name or names.
Figure 3.2 The presence or absence of the striped class is toggled whenever the mouse cursor enters or leaves the table.
It’s extremely common to need to determine whether an element has a particular class.
We may want to conditionalize our activity based upon whether an element has a certain class or not, or we may just be using it to identify a certain type of element by class.
With jQuery, we can do that by calling the hasClass() method:
This method will return true if any element in the matched set has the specified class.
Recalling the is() method from chapter 2, we could achieve the same thing with.
But arguably, the hasClass() method makes for more readable code, and internally, hasClass() is more efficient.
Another commonly desired ability is to obtain the list of classes defined for a particular element as an array instead of the cumbersome space-separated list.
Recall that the attr() method will return undefined if the attribute in question doesn’t exist, so this statement will throw an error if the <p> element doesn’t possess any class names.
We could solve this by first checking for the attribute, and if we wanted to wrap the entire thing in a repeatable, useful jQuery extension, we could write.
What’s important is that once we define such an extension, we can use getClassNames() anywhere in our script to obtain an array of class names or an empty array if an element has no classes.
Returns Returns true if any element in the wrapped set possesses the passed class name; false otherwise.
Manipulating the stylistic rendition of elements via CSS class names is a powerful tool, but sometimes we want to get down to the nitty-gritty styles themselves as declared directly on the elements.
Although modifying the class of an element allows us to choose which predetermined set of defined style sheet rules should be applied, sometimes we want to override the style sheet altogether.
Applying styles directly on the elements (via the style property available on all DOM elements) will automatically override style sheets, giving us more fine-grained control over individual elements and their styles.
The jQuery css() method allows us to manipulate these styles, working in a similar fashion to the attr() method.
We can set an individual CSS style by specifying its name and value, or a series of styles by passing in an object.
First, let’s look at specifying a single style name and value.
As described, the value argument accepts a function in a similar fashion to the attr() method.
This means that we can, for instance, expand the width of all elements in the wrapped set by 20 pixels as follows:
Next, let’s look at using the shortcut form of the css() method, which works exactly as the shortcut version of attr() worked.
Parameters name (String) The name of the CSS property to be set.
If a function is passed as this parameter, it will be invoked for each element of the wrapped set, setting the element as the function context, and passing two parameters: the element index and the current value.
The returned value serves as the new value for the CSS property.
We’ve already seen how useful this variant of this method can be in the code of listing 2.1, which we examined in the previous chapter.
To save you some page-flipping, here’s the relevant passage again:
As in the shortcut version of the attr() method, we can use functions as values to any CSS property in the properties parameter object, and they will be called on each element in the wrapped set to determine the value that should be applied.
Lastly, we can use css() with a name passed in to retrieve the computed style of the property associated with that name.
When we say computed style, we mean the style after all linked, embedded, and inline CSS has been applied.
Parameters properties (Object) Specifies an object whose properties are copied as CSS properties to.
Parameters name (String) Specifies the name of a CSS property whose computed value is to be.
Keep in mind that this variant of the css() method always returns a string, so if you need a number or some other type, you’ll need to parse the returned value.
That’s not always convenient, so for a small set of CSS values that are commonly accessed, jQuery thoughtfully provides convenience methods that access these values and convert them to the most commonly used types.
When it comes to CSS styles that we want to set or get on our pages, is there a more common set of properties than the element’s width or height? Probably not, so jQuery makes it easy for us to deal with the dimensions of the elements as numeric values rather than strings.
Specifically, we can get (or set) the width and height of an element as a number by using the convenient width() and height() methods.
Keep in mind that these are shortcuts for the more verbose css() function, so.
If a function, the function is invoked for each wrapped element, passing that element as the function context.
Returns The computed width or height as a number in pixels.
The fact that the width and height values are returned from these functions as numbers isn’t the only convenience that these methods bring to the table.
If you’ve ever tried to find the width or height of an element by looking at its style.width or style.height property, you were confronted with the sad fact that these properties are only set by the corresponding style attribute of that element; to find out the dimensions of an element via these properties, you have to set them in the first place.
The width() and height() methods, on the other hand, compute and return the size of the element.
Knowing the precise dimensions of an element in simple pages that let their elements lay out wherever they end up isn’t usually necessary, but knowing such dimensions in highly interactive scripted pages is crucial to be able to correctly place active elements such as context menus, custom tool tips, extended controls, and other dynamic components.
The dimensions of the test subject aren’t known in advance because no style rules specifying dimensions are applied.
The width of the element is determined by the width of the browser window, and its height depends on how much room will be needed to display the contained text.
Resizing the browser window will cause both dimensions to change.
We also add a call to the same function in a resize handler on the window that updates the display whenever the browser window is resized, as shown in the lower portion of figure 3.3
This ability to determine the computed dimensions of an element at any point is crucial to accurately positioning dynamic elements on our pages.
Listing 3.1 Dynamically tracking and displaying the dimensions of an element.
Figure 3.3 The width and height of the test element aren’t fixed and depend on the width of the browser window.
In addition to the very convenient width() and height() methods, jQuery also provides similar methods for getting more particular dimension values, as described in table 3.2
When dealing with the window or document elements, it’s recommended to avoid the inner and outer methods and use width() and height()
We’re not done yet; jQuery also gives us easy support for positions and scrolling values.
Both of these elements return a JavaScript object that contains two properties: top and left, which, not surprisingly, indicate the top and left values of the element.
The margin parameter causes the margin to be included if it’s true, or omitted.
The margin parameter causes the margin to be included if it’s true, or omitted.
The two methods use different origins from which their relative computed values are measured.
One of these methods, offset(), returns the position relative to the document:
The other method, position(), returns values relative to an element’s closest offset parent:
The offset parent of an element is the nearest ancestor that has an explicit positioning rule of either relative or absolute set.
Both offset() and position() can only be used for visible elements, and it’s recommended that pixel values be used for all padding, borders, and margins to obtain accurate results.
In addition to element positioning, jQuery gives us the ability to get, and to set, the scroll position of an element.
All methods in table 3.3 work with both visible and hidden elements.
Now that we’ve learned how to get and set the styles of elements, let’s discuss different ways of modifying their contents.
Returns A JavaScript object with left and top properties as floats (usually rounded to the nearest integer) depicting the position in pixels relative to the document origin.
Returns A JavaScript object with left and top properties as integers depicting the position in pixels relative to the closest offset parent.
When it comes to modifying the contents of elements, there’s an ongoing debate regarding which technique is better: using DOM API methods or changing the elements’ inner HTML.
Although use of the DOM API methods is certainly exact, it’s also fairly “wordy” and results in a lot of code, much of which can be difficult to visually inspect.
In most cases, modifying an element’s HTML is easier and more effective, so jQuery gives us a number of methods to do so.
First up is the simple html() method, which allows us to retrieve the HTML contents of an element when used without parameters or, as we’ve seen with other jQuery functions, to set its contents when used with a parameter.
Here’s how to get the HTML content of an element:
And here’s how to set the HTML content of all matched elements:
We can also set or get only the text contents of elements.
The text() method, when used without parameters, returns a string that’s the concatenation of all text.
For example, let’s say we have the following HTML fragment:
The returned value is identical to accessing the innerHTML property of that element.
Parameters content (String|Function) The HTML fragment to be set as the element content.
The function’s returned value is used as the new content.
We can also use the text() method to set the text content of the wrapped elements.
Note that setting the inner HTML or text of elements using these methods will replace contents that were previously in the elements, so use these methods carefully.
If you don’t want to bludgeon all of an element’s previous content, a number of other methods will leave the contents of the elements as they are but modify their contents or surrounding elements.
Manipulating the DOM of a page without the necessity of a page reload opens a world of possibilities for making our pages dynamic and interactive.
We’ve already seen a glimpse of how jQuery lets us create DOM elements on the fly.
These new elements can be attached to the DOM in a variety of ways, and we can also move or copy existing elements.
To add content to the end of existing content, the append() method is available.
Parameters content (String|Function) The text content to be set into the wrapped elements.
If a function, the function is invoked for each wrapped element, setting that element as the function context, and passing two parameters: the element index and the existing text.
The function’s returned value is used as the new content.
This method accepts a string containing an HTML fragment, a reference to an existing or newly created DOM element, or a jQuery wrapped set of elements.
This statement appends the HTML fragment created from the passed string to the end of the existing content of all <p> elements on the page.
A more semantically complex use of this method identifies already-existing elements of the DOM as the items to be appended.
This statement moves all links with the class appendMe to the end of the child list of all <p> elements with the class appendToMe.
If there are multiple targets for the operation, the original element is cloned as many times as is necessary and appended to the children of each target.
In all cases, the original is removed from its initial location.
This operation is semantically a move if one target is identified; the original source element is removed from its initial location and appears at the end of the target’s list of children.
It can also be a copy-and-move operation if multiple targets are identified, creating enough copies of the original so that each target can have one appended to its children.
In place of a full-blown wrapped set, we can also reference a specific DOM element, as shown:
Although it’s a common operation to add elements to the end of an elements content—we might be adding a list item to the end of a list, a row to the end of a table, or simply adding a new element to the end of the document body—we might also have a need to add a new or existing element to the start of the target element’s contents.
When such a need arises, the prepend() method will do the trick.
If a function, the function is invoked for each wrapped element, setting that element as the function context, and passing two parameters: the element index and the previous contents.
Sometimes, we might wish to place elements somewhere other than at the beginning or end of an element’s content.
If a function, the function is invoked for each wrapped element, setting that element as the function context, and passing two parameters: the element index and the previous contents.
The target wrapped elements must already be part of the DOM.
If a function, the function is invoked for each wrapped element, passing that element as the function context.
The target wrapped elements must already be part of the DOM.
If a function, the function is invoked for each wrapped element, passing that element as the function context.
These operations are key to manipulating the DOM effectively in our pages, so a Move and Copy Lab Page has been provided so that we can play around with these operations until they’re thoroughly understood.
The left pane of this Lab contains three images that can serve as sources for our move/copy experiments.
Select one or more of the images by checking their corresponding checkboxes.
Figure 3.4 The Move and Copy Lab Page will let us inspect the operation of the DOM manipulation methods.
Targets for the move/copy operations are in the right pane and are also selected via checkboxes.
Controls at the bottom of the pane allow us to select one of the four operations to apply: append, prepend, before, or after.
The Execute button causes any source images you have selected to be applied to a wrapped set of the selected set of targets using the specified operation.
After execution, the Execute button is replaced with a Restore button that we’ll use to put everything back into place so we can run another experiment.
Use the Move and Copy Lab to try various combinations of sources, targets, and.
Sometimes, it might make the code more readable if we could reverse the order of the elements passed to these operations.
If we want to move or copy an element from one place to another, another approach would be to wrap the source elements (rather than the target elements), and to specify the targets in the parameters of the method.
Well, jQuery lets us do that too by providing analogous operations to the four that we just examined, reversing the order in which sources and targets are specified.
They are appendTo(), prependTo(), insertBefore(), and insertAfter(), and their syntax is as follows:
Parameters targets (String|Element) A string containing a jQuery selector or a DOM element.
Each element of the wrapped set will be prepended to the content of each target element.
Parameters targets (String|Element) A string containing a jQuery selector or a DOM element.
There’s one more thing we need to address before we move on ...
Remember back in the previous chapter when we looked at how to create new.
This statement creates a friendly paragraph and inserts a copy of it after every image element within a paragraph element.
This is an idiom that we’ve already seen in listing 2.1 and that we’ll use again and again on our pages.
Sometimes, rather than inserting elements into other elements, we want to do the opposite.
Another type of DOM manipulation that we’ll often need to perform is to wrap an element (or series of elements) in some markup.
For example, we might want to wrap all links of a certain class inside a <div>
We can accomplish such DOM modifications by using jQuery’s wrap() method.
To wrap each link with the class surprise in a <div> with the class hello, we could write.
If we wanted to wrap the link in a clone of the first <div> element on the page, we could write.
Parameters targets (String|Element) A string containing a jQuery selector or a DOM element.
Parameters wrapper (String|Element) A string containing the opening and closing tags of the element.
When multiple elements are collected in a matched set, the wrap() method operates on each one individually.
If we’d rather wrap all the elements in the set as a unit, we can use the wrapAll() method instead:
Sometimes we may not want to wrap the elements that are in a matched set, but rather their contents.
The converse operation, removing the parent of a child element, is also possible with the unwrap() method:  :
Now that we know how to create, wrap, unwrap, copy, and move elements, we may wonder how we make them go away.
Parameters wrapper (String|Element) A string containing the opening and closing tags of the element.
Parameters wrapper (String|Element) A string containing the opening and closing tags of the element.
The child element, along with any siblings, replaces the parent element in the DOM.
Just as important as the ability to add, move, or copy elements in the DOM is the ability to remove elements that are no longer needed.
If we want to empty or remove a set of elements, this can be accomplished with the remove() method, whose syntax is as follows:
Note that, as with many other jQuery methods, the wrapped set is returned as the result of this method.
The elements that were removed from the DOM are still referenced by this set (and hence not yet eligible for garbage collection) and can be further operated upon using other jQuery methods, including the likes of appendTo(), prependTo(), insertBefore(), insertAfter(), and any other similar behaviors we’d like.
Note, however, that any jQuery data or events that were bound to the elements are removed when the elements are removed from the DOM using remove()
A similar method, detach(), also removes the elements from the DOM, but retains any bound events and data.
The detach() method is the preferred means of removing an element that we’ll want to put back into the DOM at a later time with its events and data intact.
To completely empty DOM elements of their contents, we can use the empty() method.
Parameters selector (String) An optional selector that further filters which elements of the wrapped set.
Parameters selector (Selector) An optional selector string that further filters which elements of the.
Sometimes, we don’t want to move elements, but to copy them ...
One more way that we can manipulate the DOM is to make copies of elements to attach elsewhere in the tree.
Making a copy of existing elements with clone() isn’t useful unless we do something with the carbon copies.
Generally, once the wrapped set containing the clones is generated, another jQuery method is applied to stick them somewhere in the DOM.
This statement makes copies of all image elements and appends them to all <fieldset> elements with the class name photo.
Event handlers are optionally copied depending upon the setting of the copyHandlers parameter.
This statement performs the same operation as the previous example, but after the insertion of the clones, the end() method is used to select the original wrapped set (the original targets) and hide them.
This emphasizes how the cloning operation creates a new set of elements in a new wrapper.
In order to see the clone operation in action, return to the Move and Copy Lab Page.
Just above the Execute button is a pair of radio buttons that allow us to specify a cloning operation as part of the main DOM manipulation operation.
When the yes radio button is selected, the sources are cloned before the append, prepend, before, or after methods are executed.
Repeat some of the experiments you conducted earlier with cloning enabled, and note how the original sources are unaffected by the operations.
We can insert, we can remove, and we can copy.
Using these operations in combination, it’d be easy to concoct higher-level operations such as replace.
For those times when we want to replace existing elements with new ones, or to move an existing element to replace another, jQuery provides the replaceWith() method.
Let’s say that, under particular circumstances, we want to replace all images on the page that have alt attributes with <span> elements that contain the alt values of the images.
Employing each() and replaceWith() we could do it like this:
The each() method lets us iterate over each matching element, and replaceWith() is used to replace the images with generated <span> elements.
The replaceWith() method returns a jQuery wrapped set containing the elements that were removed from the DOM, in case we want to do something other than just discard them.
As an exercise, consider how would you augment the example code to reattach these elements elsewhere in the DOM after their removal.
If a function, the function is invoked for each wrapped element, setting that element as the function context and passing no parameters.
The function’s returned value is used as the new content.
When an existing element is passed to replaceWith(), it’s detached from its original location in the DOM and reattached to replace the target elements.
If there are multiple such targets, the original element is cloned as many times as needed.
At times, it may be convenient to reverse the order of the elements as specified by replaceWith() so that the replacing element can be specified using the matching selector.
We’ve already seen such complementary methods, such as append() and appendTo(), that let us specify the elements in the order that makes the most sense for our code.
Similarly, the replaceAll() method mirrors replaceWith(), allowing us to perform a similar operation, but with the order of specification reversed.
But this set contains not the replaced elements, but the replacing elements.
The replaced elements are lost and can’t be further operated upon.
Keep this in mind when deciding which replace method to employ.
Now that we’ve discussed handling general DOM elements, let’s take a brief look at handling a special type of element: the form elements.
Because form elements have special properties, jQuery’s core contains a number of convenience functions for activities such as.
These functions will serve us well in most cases, but the Form Plugin—an officially sanctioned plugin developed by members of the jQuery Core Team—provides even more form-related functionality.
Parameters selector (Selector) A selector string expression identifying the elements to be replaced.
So what’s a form element? When we use the term form element, we’re referring to the elements that can appear within a form, possess name and value attributes, and whose values are sent to the server as HTTP request parameters when the form is submitted.
Dealing with such elements by hand in script can be tricky because, not only can elements be disabled, but the W3C defines an unsuccessful state for controls.
This state determines which elements should be ignored during a submission, and it’s a tad on the complicated side.
That said, let’s take a look at one of the most common operations we’ll want to perform on a form element: getting access to its value.
This method, although quite useful, has a number of limitations of which we need to be wary.
If the first element in the wrapped set isn’t a form element, an empty string is returned, which isn’t the most intuitive value that could have been chosen (undefined would probably have been clearer)
This method also doesn’t distinguish between the checked or unchecked states of checkboxes and radio buttons, and will simply return the value of checkboxes or radio buttons as defined by their value attribute, regardless of whether they’re checked or not.
For radio buttons, the power of jQuery selectors combined with the val() method saves the day, as we’ve already seen in the first example in this book.
Consider a form with a radio group (a set of radio buttons with the same name) named radioGroup and the following expression:
This expression returns the value of the single checked radio button (or undefined if none is checked)
That’s a lot easier than looping through the buttons looking for the checked element, isn’t it?
Because val() only considers the first element in a wrapped set, it’s not as useful for checkbox groups where more than one control might be checked.
Even though we haven’t formally covered extending jQuery (that’s still four chapters away), you’ve probably seen enough examples to give it a go.
See if you can refactor the preceding code into a jQuery wrapper method that returns an array of any checked checkboxes in the wrapped set.
Although the val() method is great for obtaining the value of any single form control element, if we want to obtain the complete set of values that would be submitted.
When the element is a multiselect element, the returned value is an array of all selections.
Dealing with form element values through a form submission, we’ll be much better off using the serialize() or serializeArray() methods (which we’ll see in chapter 8) or the official Form Plugin.
Another common operation we’ll perform is to set the value of a form element.
The val() method is also used bilaterally for this purpose by supplying a value.
Another way that the val() method can be used is to cause checkbox or radio elements to become checked, or to select options within a <select> element.
The syntax of this variant of val() is as follows:
Any checkboxes or radio buttons that are found to match will become checked, and any options that match will become selected.
This makes val() useful for much more than just the text-based form elements.
Parameters value (String|Function) Specifies the value that is to be set as the value property of.
If a function, the function is invoked for each element in the wrapped set, with that element passed as the function context, and two parameters: the element index and the current value of the element.
The value returned from the function is taken as the value to be set.
Parameters values (Array) An array of values that will be used to determine which elements are to be.
In this chapter, we’ve gone beyond the art of selecting elements and started manipulating them.
With the techniques we’ve learned so far, we can select elements using powerful criteria, and then move them surgically to any part of the page.
We can choose to copy elements, or to move them, replace them, or even create brand new elements from scratch.
We can append, prepend, or wrap any element or set of elements on the page.
And we’ve learned how to manage the values of form elements, all leading to powerful yet succinct logic.
With that behind us, we’re ready to start looking into more advanced concepts, starting with the typically messy job of handling events in our pages.
Anyone familiar with the Broadway show Cabaret, or its subsequent Hollywood film, probably remembers the song “Money Makes the World Go Around.” Although this cynical view might be applicable to the physical world, in the virtual realm of the World Wide Web, it’s events that make it all happen!
Like many other GUI management systems, the interfaces presented by HTML web pages are asynchronous and event-driven (even if the HTTP protocol used to deliver them to the browser is wholly synchronous in nature)
Whether a GUI is implemented as a desktop program using Java Swing, X11, or the .NET Framework, Events are where it happens!
The first step sets up the display of the user interface; the others define its behavior.
In web pages, the browser handles the setup of the display in response to the markup (HTML and CSS) that we send to it.
The script we include in the page defines the behavior of the interface.
This script takes the form of event handlers, also known as listeners, that react to the various events that occur while the page is displayed.
These events could be generated by the system (timers or the completion of asynchronous requests, for example) but are most often the result of some user activity (such as moving or clicking the mouse, entering text via the keyboard, or even iPhone gestures)
Without the ability to react to these events, the World Wide Web’s greatest use might be limited to showing pictures of kittens.
Although HTML itself does define a small set of built-in semantic actions that require no scripting on our part (such as reloading pages as the result of clicking an anchor tag or submitting a form via a submit button), any other behaviors that we wish our pages to exhibit require us to handle the various events that occur as our users interact with those pages.
In this chapter, we’ll examine the various ways that browsers expose these events, how they allow us to establish handlers to control what happens when these events occur, and the challenges that we face due to the multitude of differences between the browser event models.
Then we’ll see how jQuery cuts through the browser-induced fog to relieve us of these burdens.
Let’s start off by examining how browsers expose their event models.
JavaScript you need to know! One of the great benefits that jQuery brings to web applications is the ability to implement a great deal of scripting-enabled behavior without having to write a whole lot of script ourselves.
Up to this point, the ride has been pretty painless.
You only needed rudimentary JavaScript skills to code and understand the jQuery examples we introduced in the previous chapters.
In this chapter and the chapters that follow, you must understand a handful of important fundamental JavaScript concepts to make effective use of the jQuery library.
Long before anyone considered standardizing how browsers would handle events, Netscape Communications Corporation introduced an event-handling model in its Netscape Navigator browser; all modern browsers still support this model, which is probably the best understood and most employed by the majority of page authors.
You may have heard it termed the Netscape Event Model, the Basic Event Model, or even the rather vague Browser Event Model, but most people have come to call it the DOM Level 0 Event Model.
This model enjoys support from all modern standardscompliant browsers such as Firefox, Camino (as well as other Mozilla browsers), Safari, and Opera.
Internet Explorer continues to go its own way and supports a subset of the functionality in the DOM Level 2 Event Model, albeit using a proprietary interface.
Before we see how jQuery makes that irritating fact a non-issue, let’s spend some time getting to know how the various event models operate.
The DOM Level 0 Event Model is the event model that most web developers employ on their pages.
Under this event model, event handlers are declared by assigning a reference to a function instance to properties of the DOM elements.
These properties are defined to handle a specific event type; for example, a click event is handled by assigning a function to the onclick property, and a mouseover event by assigning a function to the onmouseover property of elements that support these event types.
Before we proceed, it’s time to make sure that you’ve wrapped your head around these core concepts.
If you’re already comfortable with the workings of the JavaScript Object and Function classes, and have a good handle on concepts like function contexts and closures, you may want to continue reading this and the upcoming chapters.
If these concepts are unfamiliar or hazy, we strongly urge you to turn to the appendix to help you get up to speed on these necessary concepts.
An example of defining such handlers is shown in listing 4.1
In this example, we employ both styles of event handler declaration: declaring under script control and declaring in a markup attribute.
The page first declares a ready handler in which a reference to the image element with the id of example is obtained (using jQuery), and its onmouseover property is set to an inline function B.
This function becomes the event handler for the element when a mouseover event is triggered on it.
Note that this function expects a single parameter to be passed to it.
We’ll be using this handy function in many of the examples throughout the remainder of the book.
In the body of the page, we define an <img> element upon which we’re defining the event handlers.
We’ve already seen how to define a handler under script control in the ready handler B, but here we declare a handler for a click event using the onclick attribute D of the <img> element.
Long before we reach the end of this chapter, we’ll see why we won’t need to embed event behavior in the DOM markup anymore!
We declared the click event handler in the <img> element markup using the following attribute:
This might lead us to believe that the say() function becomes the click event handler for the element, but that’s not really the case.
When handlers are declared via HTML markup attributes, an anonymous function is automatically created using the value of the attribute as the function body.
Assuming that imageElement is a reference to the image element, the construct created as a result of the attribute declaration is equivalent to the following:
Note how the value of the attribute is used as the body of the generated function, and note that the function is created so that the event parameter is available within the generated function.
When using jQuery in our pages, we should adhere to the principles of Unobtrusive.
Figure 4.1 Waving the mouse over the image and clicking it results in the event handlers firing and emitting their messages to the console.
We’ll shortly see that jQuery provides a much better way to declare event handlers than either of these means.
But first, let’s examine what that event parameter is all about.
When an event handler is fired, an instance of a class named Event is passed to the handler as its first parameter in most browsers.
Internet Explorer, always the life of the party, does things in its own proprietary way by tacking the Event instance onto a global property (in other words, a property on window) named event.
In order to deal with this discrepancy, we’ll often see the following used as the first statement in a non-jQuery event handler:
This levels the playing field by using feature detection (a concept we’ll explore in greater depth in chapter 6) to check if the event parameter is undefined (or null) and assigning the value of the window’s event property to it if so.
After this statement, the event parameter can be referenced regardless of how it was made available to the handler.
The properties of the Event instance provide a great deal of information regarding the event that has been fired and is currently being handled.
This includes details such as which element the event was triggered on, the coordinates of mouse events, and which key was clicked for keyboard events.
Not only does Internet Explorer use a proprietary means to get the Event instance to the handler, but it also uses a proprietary definition of the Event class in place of the W3C-defined standard—we’re not out of the object-detection woods yet.
We deal with this inconsistency by employing feature detection with a statement such as the following:
This statement tests whether event.target is defined and, if so, assigns its value to the local target variable; otherwise, it assigns event.srcElement.
We’ll be required to take similar steps for other Event properties of interest.
Up until this point, we’ve acted as if event handlers are only pertinent to the elements that serve as the trigger to an event—the image element of listing 4.1, for example—but events propagate throughout the DOM tree.
When an event is triggered on an element in the DOM tree, the event-handling mechanism of the browser checks to see if a handler has been established for that particular event on that element and, if so, invokes it.
After the target element has had its chance to handle the event, the event model checks with the parent of that element to see if it has established a handler for the event type, and if so, it’s also invoked—after which its parent is checked, then its parent, then its parent, and on and on, all the way up to the top of the DOM tree.
Because the event handling propagates upward like the bubbles in a champagne flute (assuming we view the DOM tree with its root at the top), this process is termed event bubbling.
Let’s modify the example from listing 4.1 so that we can see this process in action.
We do a lot of interesting things in the changes to this example.
First, we remove the previous handling of the mouseover event so that we can concentrate on the click event.
We also embed the image element that will serve as the target for our event experiment in a couple of nested <div> elements, merely to place the image element artificially deeper within the DOM hierarchy.
Listing 4.2 Events propagate from the point of origin to the top of the DOM.
For each matched element, we record its instance in the local variable current and establish an onclick handler C.
This handler first employs the browser-dependent tricks that we discussed in the previous section to locate the Event instance and identify the event target, and then emits a console message.
This message is the most interesting part of this example.
It displays the tag name and id of the current element, putting closures to work (please read the section on closures in the appendix if closures are a subject that gives you heartburn), followed by the id of the target.
By doing so, each message that’s logged to the console displays the information about the current element of the bubble process, as well as the target element that started the whole shebang.
This clearly illustrates that, when the event is fired, it’s delivered first to the target element and then to each of its ancestors in turn, all the way up to the root <html> element.
This is a powerful ability because it allows us to establish handlers on elements at any level to handle events occurring on its descendents.
Consider a handler on a <form> element that reacts to any change event on its child elements to effect dynamic changes to the display based upon the elements’ new values.
But what if we don’t want the event to propagate? Can we stop it?
There may be occasions when we want to prevent an event from bubbling any further up the DOM tree.
This might be because we’re fastidious and we know that we’ve already accomplished any processing necessary to handle the event, or we may want to forestall unwanted handling that might occur higher up in the chain.
Figure 4.2 The console messages clearly show the propagation of the event as it bubbles up the DOM tree from the target element to the tree root.
Regardless of the reason, we can prevent an event from propagating any higher via mechanisms provided on the Event instance.
In Internet Explorer, we set a property named cancelBubble to true in the Event instance.
As examples, a click event on an anchor element will cause the browser to navigate to the element’s href, and a submit event on a <form> element will cause the form to be submitted.
Should we wish to cancel these semantic actions—sometimes termed the default actions—of the event, we simply return the value false from the event handler.
A frequent use for such an action is in the realm of form validation.
In the handler for the form’s submit event, we can make validation checks on the form’s controls and return false if any problems with the data entry are detected.
You may also have seen the following on <form> elements:
This effectively prevents the form from being submitted in any circumstances except under script control (via form.submit(), which doesn’t trigger a submit event)—a common trick used in many Ajax applications where asynchronous requests will be made in lieu of form submissions.
Under the DOM Level 0 Event Model, almost every step we take in an event handler involves using browser-specific detection in order to figure out what action to take.
What a headache! But don’t put away the aspirin yet—it doesn’t get any easier when we consider the more advanced event model.
One severe shortcoming of the DOM Level 0 Event Model is that, because a property is used to store a reference to a function that’s to serve as an event handler, only one event handler per element can be registered for any specific event type at a time.
If we have two things that we want to do when an element is clicked, the following statements aren’t going to let that happen:
Because the second assignment replaces the previous value of the onclick property, only doSecondThing is invoked when the event is triggered.
Sure, we could wrap both functions in another single function that calls both, but as pages get more complicated, as is quite likely in highly interactive applications, it becomes increasingly difficult to keep track of such things.
Moreover, if we use multiple reusable components or libraries in a page, they may have no idea of the event-handling needs of the other components.
But all of these add complexity to pages that are likely to already be complex enough.
Besides the establishment of a standard event model, the DOM Level 2 Event Model was designed to address these types of problems.
Let’s see how event handlers, even multiple handlers, are established on DOM elements under this more advanced model.
Rather than assigning a function reference to an element property, DOM Level 2 event handlers—also termed listeners—are established via an element method.
Each DOM element defines a method named addEventListener() that’s used to attach event handlers (listeners) to the element.
The eventType parameter is a string that identifies the type of event to be handled.
These string values are, generally, the same event names we used in the DOM Level 0 Event Model without the on prefix: for example: click, mouseover, keydown, and so on.
The listener parameter is a reference to the function (or an inline function) that’s to be established as the handler for the named event type on the element.
As in the basic event model, the Event instance is passed to this function as its first parameter.
The final parameter, useCapture, is a Boolean whose operation we’ll explore in a few moments, when we discuss event propagation in the Level 2 Model.
Let’s once again change the example from listing 4.1 to use the more advanced event model.
We’ll concentrate only on the click event type; this time, we’ll establish three click event handlers on the image element.
This code is simple, but it clearly shows how we can establish multiple event handlers on the same element for the same event type—something we were not able to do easily with the Basic Event Model.
In the ready handler for the page B, we grab a reference to the image element and then establish three event handlers for the click event.
Note that even though the handlers fire in the order in which they were established, this order isn’t guaranteed by the standard! Testers of this code never observed an order other than the order of establishment, but it would be foolish to write code that relies on this order.
Always be aware that multiple handlers established on an element may fire in random order.
Now, let’s find out what’s up with that useCapture parameter.
We saw earlier that, with the Basic Event Model, once an event was triggered on an element the event propagated from the target element upwards in the DOM tree to all the target’s ancestors.
The advanced Level 2 Event Model also provides this bubbling phase but ups the ante with an additional capture phase.
Under the DOM Level 2 Event Model, when an event is triggered, the event first propagates from the root of the DOM tree down to the target element and then.
Figure 4.3 Clicking the image once demonstrates that all three handlers established for the click event are triggered.
The former phase (root to target) is called capture phase, and the latter (target to root) is called bubble phase.
When a function is established as an event handler, it can be flagged as a capture handler, in which case it will be triggered during capture phase, or as a bubble handler, to be triggered during bubble phase.
As you might have guessed by this time, the useCapture parameter to addEventListener() identifies which type of handler is established.
A value of false for this parameter establishes a bubble handler, whereas a value of true registers a capture handler.
Think back a moment to the example of listing 4.2 where we explored the propagation of the Basic Model events through a DOM hierarchy.
In that example, we embedded an image element within two layers of <div> elements.
Listing 4.4 Tracking event propagation with bubble and capture handlers.
In the ready handler B, we use jQuery’s powerful abilities to run through every element of the DOM tree.
On each, we establish two handlers: one capture handler and one bubble handler.
Each handler emits a message to the console identifying which type of handler it is, the current element, and the id of the target element.
Note that, because we defined both capture and bubble handlers for the target, two handlers were executed for the target and all its ancestor nodes.
Figure 4.5 Clicking the image results in each handler emitting a console message that identifies the path of the event during both capture and bubble phases.
Although it does have a proprietary model corresponding to the bubble phase of the Level 2 standard, it doesn’t support any semblance of a capture phase.
Before we look at how jQuery can help sort all this mess out, let’s briefly examine the Internet Explorer Model.
These versions of Microsoft’s browser provide a proprietary interface that closely resembles the bubble phase of the standard model.
This method accepts two parameters similar to those of the standard model:
The first parameter is a string that names the event type to be attached.
The standard event names aren’t used; the name of the corresponding element property from the DOM Level 0 Model is used—“onclick”, “onmouseover”, “onkeydown”, and so on.
The second parameter is the function to be established as the handler, and as in the Basic Model, the Event instance must be fetched from the window.event property.
And when using the more capable DOM Level 2 or Internet Explorer Model, we even have to diverge our code when establishing the handlers in the first place.
Well, jQuery is going to make our lives simpler by hiding these browser disparities from us as much as it possibly can.
Although it’s true that the creation of highly interactive applications requires a hefty reliance on event handling, the thought of writing event-handling code on a large scale while dealing with the browser differences is enough to daunt even the most intrepid of page authors.
We could hide the differences behind an API that abstracts the differences away from our page code, but why bother when jQuery has already done it for us?
The omission of the capture phase should not be an issue for the vast majority of page authors who never use it (or even know it exists) due to its lack of support in IE.
Using the jQuery Event Model, we can establish event handlers on DOM elements with the bind() method.
This statement binds the supplied inline function as the click event handler for every image on a page.
The full syntax of the bind() method is as follows:
Parameters eventType (String) Specifies the name of the event type or types for which the handler is to.
Multiple event types can be specified as a space-separated list.
These event types can be namespaced with a suffix affixed to the event name with a period character.
If omitted, the handler function can be specified as the second parameter.
When invoked, it will be passed the Event instance, and its function context (this) is set to the current element of the bubble phase.
The property names identify the event type (same as would be used for the eventType parameter), and the property value provides the handler.
The changes to this code, limited to the body of the ready handler, are minor but significant B.
We create a wrapped set consisting of the target <img> element and apply three bind() methods to it—remember, jQuery chaining lets us apply multiple methods in a single statement—each of which establishes a click event handler on the element.
But perhaps more importantly, it also works when loaded into Internet Explorer, as shown in figure 4.7
This was not possible using the code from listing 4.3 without adding browser-specific testing and branching code to use the correct event model for the current browser.
At this point, page authors who have wrestled with mountains of browser-specific event-handling code in their pages are no doubt singing “Happy Days Are Here Again” and spinning in their office chairs.
Another nifty little event-handling extra that jQuery provides for us is the ability to group event handlers by assigning them to a namespace.
Unlike conventional namespacing (which assigns namespaces via a prefix), the event names are namespaced by adding a suffix to the event name separated by a period character.
The jQuery Event Model fact, if you’d like, you can use multiple suffixes to place the event into multiple namespaces.
By grouping event bindings in this way, we can easily act upon them later as a unit.
Take, for example, a page that has two modes: a display mode and an edit mode.
When in edit mode, event listeners are placed on many of the page elements, but these listeners aren’t appropriate for display mode and need to be removed when the.
We could namespace the edit mode events with code such as this:
By grouping all these bindings into a namespace named editMode, we can later operate upon them as a whole.
For example, when the page leaves edit mode and it comes time to remove all the bindings, we could do this easily with.
This will remove all click bindings (the explanation of the unbind() method is coming up in the next section) in the namespace editMode for all elements on the page.
For occasions when we want to bind multiple event types to an element, we can do it with a single call to bind(), as shown.
In addition to the bind() method, jQuery provides a handful of shortcut methods to establish specific event handlers.
Because the syntax of each of these methods is identical except for the name of the method, we’ll save some space and present them all in the following single syntax descriptor:
The supported methods are as follows: blur change click dblclick error focus.
Note that when using these shortcut methods, we can’t specify a data value to be placed in the event.data property.
Parameters listener (Function) The function that’s to be established as the event handler.
It’s not hard to imagine scenarios where we’d want to handle focus and blur events.
For example, let’s say that we wanted to keep track of which fields in a form had been visited.
Rather than establishing a handler on each and every element, it’d be handy to establish a single handler on the form.
The focus and blur events, by their nature, do not bubble up the DOM tree.
Therefore, a focus handler established on the form element would never get invoked.
This is where the focusin and focusout events come in.
Handlers established for these events on focusable elements are invoked whenever the element receives or loses focus, as are any such handlers established on the ancestors of the focusable element.
Once the event handler executes the first time, it’s automatically removed as an event handler.
These methods give us many choices for binding an event handler to matched elements.
And once a handler is bound, we may eventually need to remove it.
Typically, once an event handler is established, it remains in effect for the remainder of the life of the page.
But particular interactions may dictate that handlers be removed based on certain criteria.
Consider, for example, a page where multiple steps are presented, and once a step has been completed, its controls revert to read-only.
For such cases, it would be advantageous to remove event handlers under script control.
We’ve seen that the one() method can automatically remove a handler after it has completed its first (and only) execution, but for the more general case where we’d like to remove event handlers under our own control, jQuery provides the unbind() method.
Parameters eventType (String) Specifies the name of the event type for which the handler is to be.
If omitted, the handler function can be specified as the second parameter.
This method can be used to remove event handlers from the elements of the matched set at various levels of granularity.
All listeners can be removed by omitting any parameters, or listeners of a specific type can be removed by providing just that event type.
Specific handlers can be removed by providing a reference to the function originally established as the listener.
To do this, a reference to the function must be retained when binding the function as an event listener in the first place.
For this reason, when a function that’s eventually to be removed as a handler is originally established as a listener, it’s either defined as a top-level function (so that it can be referred to by its top-level variable name) or a reference to it is retained by some other means.
Supplying the function as an anonymous inline reference would make it impossible to later reference the function in a call to unbind()
That’s a situation where using name-spaced events can come in quite handy, as you can unbind all events in a particular namespace without having to retain individual references to the listeners.
This statement will remove all event listeners in namespace fred.
When an event handler established with the bind() method (or any of its related convenience methods) is invoked, an Event instance is passed to it as the first parameter to the function regardless of the browser, eliminating the need to worry about the window.event property under Internet Explorer.
But that still leaves us dealing with the divergent properties of the Event instance, doesn’t it?
Thankfully, no, because truth be told, jQuery doesn’t really pass the Event instance to the handlers.
If no parameters are provided, all listeners are removed from the elements.
Parameters eventType (String) If provided, specifies that only listeners established for the specified.
Yes, we’ve been glossing over this little detail because, up until now, it hasn’t mattered.
But now that we’ve advanced to the point where we’re going to examine the instance within handlers, the truth must be told!
In reality, jQuery defines an object of type jQuery.Event that it passes to the handlers.
But we can be forgiven our simplification, because jQuery copies most of the original Event properties to this object.
As such, if you only look for the properties that you expected to find on Event, the object is almost indistinguishable from the original Event instance.
But that’s not the important aspect of this object—what’s really valuable, and the reason that this object exists, is that it holds a set of normalized values and methods that we can use independently of the containing browser, ignoring the differences in the Event instance.
The Alt key is labeled Option on most Mac keyboards.
This is the same object that’s set as the function context of the event handler.
The Meta key is the Ctrl key on PCs and the Command key on Macs.
For instance, the left arrow key has a code of 37, which works reliably on keyup and keydown events, but Safari returns nonstandard results for these keys on a keypress event.
We can get a reliable, case-sensitive character code in the which property of keypress events.
During keyup and keydown events, we can only get a case-insensitive key code (so a and A both return 65), but we can determine case by checking shiftKey.
This can be useful if you’re using one event handler function for multiple events.
This should be used instead of button, which can’t be relied on to function consistently across browsers.
Also, if we want to stop the propagation of the event (but not immediate propagation), as well as cancel its default behavior, we can simply return false as the return value of the listener function.
All of this gives us the ability to exert fine-grained control over the establishment and removal of event handlers for all the elements that exist within the DOM; but what about elements that don’t exist yet, but will?
With the bind() and unbind() methods (and the plethora of convenience methods), we can readily control which event handlers are to be established on the elements of the DOM.
The ready handler gives us a convenient place to initially establish handlers on the DOM elements that are created from the HTML markup on the page, or created within the ready handler.
But one of the whole reasons for using jQuery, as we saw in the last chapter, is the ease with which it allows us to dynamically manipulate the DOM.
And when we throw Ajax into the mix, a subject that we’ll address in chapter 8, it’s likely that DOM elements will be coming into and out of existence frequently during the lifetime of the page.
The ready handler isn’t going to be of much help in managing the event handlers for these dynamic elements that don’t exist when the ready handler is executed.
We can certainly manage event handlers on the fly as we use jQuery to manipulate the DOM, but wouldn’t it be nice if we could keep all the event management code together in one place?
Parameters eventType (String) Specifies the name of the event type for which the handler is to be.
Unlike bind(), a space-separated list of event types can’t be specified.
If omitted, the handler function can be specified as the second parameter.
When invoked, it will be passed the Event instance, and its function context (this) is set to the target element.
This methods looks and acts a lot like bind(), except that when a corresponding event occurs, it will be triggered for all elements that match the selector, even if those elements aren’t in existence at the time that live() is called.
Throughout the lifetime of the page, a click on any <div> element with class attendToMe will result in the handler being invoked as an event handler, complete with a passed event instance.
And the preceding code doesn’t need to be in a ready handler because, for “live” events, it doesn’t matter whether the DOM has been built yet or not.
The live() method makes it amazingly easy to establish all the event handlers needed on the page in one place and at the outset, without having to worry about whether the elements already exist or when the elements will be created.
Because of its similarity to bind(), you might expect “live events” to work in exactly the same manner as native events.
But there are differences that may or may not be important on your page.
When an event such as a click occurs, it propagates up through the DOM elements as described earlier in this chapter, invoking any event handlers that have been established.
Once the event reaches the context used to create the wrapped set upon which live() was called (usually the document), the context checks for elements within itself that match the live selector.
The live event handlers are triggered on any elements that match, and this triggered event doesn’t propagate.
If the logic of your page depends upon propagation and propagation order, live() might not be the best choice—especially if you mix live event handlers with native event handlers established via bind()
Secondly, the live() method can only be used on selectors, and can’t be used on derived wrapped sets.
The first will affect all images, the second all images within the context established by #someParent.
Note that when a context is specified, it must exist at the time of the call to live()
Even with these restrictions, live() is tremendously handy on any page with.
The jQuery Event Model comprehensive example that employs the handy DOM manipulation methods that we learned about in chapter 3 to create dynamic elements.
Handlers established using live() should be unbound with the (rather morbidly named) die() method, which bears a strong resemblance to its unbind() counterpart:
Event handlers are designed to be invoked when browser or user activity triggers the propagation of their associated events through the DOM hierarchy.
But there may be times when we want to trigger the execution of a handler under script control.
We could define such event handlers as top-level functions so that we can invoke them by name, but as we’ve seen, defining event handlers as inline anonymous functions is much more common and so darned convenient! Moreover, calling an event handler as a function doesn’t cause semantic actions or bubbling to occur.
To provide for this need, jQuery has provided methods that will automatically trigger event handlers on our behalf under script control.
The most general of these methods is trigger(), whose syntax is as follows:
Parameters eventType (String) If provided, specifies that only listeners established for the specified.
Parameters eventType (String) Specifies the name of the event type for which handlers are to be.
Each handler called is passed a populated instance of jQuery.Event.
Because there’s no real event, properties that report event-specific values, such as the location of a mouse event or the key of a keyboard event, have no value.
The target property is set to reference the element of the matched set to which the handler was bound.
Just as with actual events, triggered event propagation can be halted via a call to the jQuery.Event instance’s stopPropagation() method, or a false value can be returned from any of the invoked handlers.
The latter is placed into the jQuery.Event instance as the data property; the value passed to trigger() (and, as we’re about to see, triggerHandler()) is passed as a parameter to the listeners.
This allows both data values to be used without conflicting with each other.
For cases where we want to trigger a handler, but not cause propagation of the event and execution of semantic actions, jQuery provides the triggerHandler() method, which looks and acts just like trigger() except that no bubbling or semantic actions will occur.
In addition to the trigger() and triggerHandler() methods, jQuery provides convenience methods for triggering most of the event types.
The syntax for all these methods is exactly the same except for the method name, and that syntax is as follows:
Parameters eventType (String) Specifies the name of the event type for which handlers are to be.
In addition to binding, unbinding, and triggering event handlers, jQuery offers higher-level functions that further make dealing with events on our pages as easy as possible.
Interactive applications often employ interaction styles that are implemented using a combination of behaviors.
The first of these is the toggle() method, which establishes a circular progression of click event handlers that are applied on each subsequent click event.
On the first click event, the first registered handler is called, on the second click, the second is called, on the third click the third is called, and so on.
When the end of the list of established handlers is reached, the first handler becomes the next in line.
A common use for this convenience method is to toggle the enabled state of an element back and forth on each odd or even click.
For this, we’d supply two handlers; one for the odd clicks, and one for the even clicks.
The supported methods are as follows: blur change click dblclick error focus.
Establishes the passed functions as a circular list of click event handlers on all elements of the wrapped set.
The handlers are called in order on each subsequent click event.
Parameters listenerN (Function) One or more functions that serve as the click event handlers for.
Imagine that we have a site in which we want users to be able to view images in one of three sizes: small, medium, or large.
The interaction will take place through a simple series of clicks.
Clicking on the image bumps it up to its next bigger size, until we reach the largest size, and it reverts back to the smallest.
Examine the progression shown in the time-lapse screenshots in figure 4.8
Each time the image is clicked, it grows to the next bigger size.
If one more click were to be made, the image would revert to the smallest size.
Figure 4.8 jQuery’s toggle() method lets us predefine a progression of behaviors for click events.
The reason is that in earlier versions of jQuery, this method was limited to only two handlers and was later expanded to accept an arbitrary number of handlers.
Another common multi-event scenario that’s frequently employed in interactive applications involves mousing into and out of elements.
Events that inform us when the mouse pointer has entered an area, as well as when it has left that area, are essential to building many of the user interface elements that are commonly presented to users on our pages.
Among these element types, cascading menus used as navigation systems are a common example.
A vexing behavior of the mouseover and mouseout event types often hinders the easy creation of such elements: when a mouseout event fires as the mouse is moved.
This page displays two identical (except for naming) sets of areas: an outer area and an inner area.
Load this page into your browser as you follow the rest of this section.
For the top set of rectangles on the page, the following script in the ready handler establishes handlers for the mouseover and mouseout events:
This statement establishes a function named report as the event handler for both the mouseover and mouseout events.
We’ll see (from looking at the bottom of the page) that a mouseover event has fired.
As expected, we’ll see that a mouseout event has fired.
Let’s refresh the page to start over, clearing the console.
Now, let’s move the mouse pointer into Outer 1 (noting the event), but this time.
Figure 4.9 This page helps demonstrate when mouse events fire as the mouse pointer is moved over an area and its children.
This is the defined behavior, even if it’s rather unintuitive.
Even though the pointer is still within the bounds of Outer 1, when the pointer enters a contained element, the event model considers the transition to be leaving the outer area.
Often, we want to be informed when the pointer leaves the bounds of the outer area and don’t care whether the pointer is over a contained area or not.
Luckily, some of the major browsers support a nonstandard pair of mouse events, mouseenter and mouseleave, first introduced by Microsoft in Internet Explorer.
This event pair acts slightly more intuitively, not firing a mouseleave event when moving from an element to a descendant of that element.
For browsers not supporting these events, jQuery emulates them so that they work the same across all browsers.
Using jQuery we could establish handlers for this set of events using the following code:
But jQuery also provides a single method that makes it even easier: hover()
This is useful for those situations where we have no need for parent handlers to react when the mouse pointer passes over child elements.
With all these event-handling tools under our belts, let’s use what we’ve learned so far and look at an example page that makes use of them, as well as some of the other jQuery techniques that we’ve learned from previous chapters!
These handlers only fire when the area covered by the elements is entered and exited, ignoring transitions to child elements.
Parameters enterHandler (Function) The function to become the mouseenter handler.
This example uses not only events but also some jQuery techniques that we’ve explored in earlier chapters, including some heavyweight jQuery method chains.
For this comprehensive example, let’s pretend that we’re videophiles whose collection of DVDs, numbering in the thousands, has become a huge problem.
Not only has organization become an issue, making it hard to find a DVD quickly, but all those DVDs in their cases have become a storage problem—they’ve taken over way too much space and will get us thrown out of the house if the problem isn’t solved.
We’ll posit that we solved the storage side of the problem by buying DVD binders that hold one hundred DVDs each in much less space than the comparable number of DVDs in their cases.
But although that saved us from having to sleep on a park bench, organizing the DVD discs is still an issue.
How will we find a DVD that we’re looking for without having to manually flip through each binder until we find the one we’re seeking?
We can’t do something like sort the DVDs in alphabetic order to help quickly locate a specific disc.
That would mean that every time we buy a new DVD, we’d need to shift all the discs in perhaps dozens of binders to keep the collection sorted.
Imagine the job ahead of us after we buy Abbott and Costello Go to Mars!
Well, we’ve got computers, we’ve got the know-how to write web applications, and we’ve got jQuery! So we’ll solve the problem by writing a DVD database program to help keep track of what DVDs we have, and where they are.
Our DVD database program is faced with the same problem facing many other applications, web-delivered or otherwise.
How do we allow our users (in this case ourselves) to quickly find the information that they seek?
We could be all low-tech about it and just display a sorted list of all the titles, but that would still be painful to scroll through if there’s anything more than a handful of entries.
Besides, we want to learn how to do it right so that we can apply what we learn to real, customer-facing applications.
So no shortcuts! Obviously, designing the entire application would be well beyond the scope of this.
We’ll want the ability to filter on the DVD title, of course.
Putting events (and more) to work movie yet or not.
Your initial reaction may be to wonder what the big deal is.
After all, we can just put up a number of fields and be done with it, right?
A single field for something like the title is fine if, for example, we wanted to find all movies with the term “creature” in their title.
In order to provide a robust interface for specifying filters, we’ll need to allow the user to specify multiple filters for either the same or different properties of the DVD.
And rather than try to guess how many filters will be needed, we’ll be all swank about it and create them on demand.
For our interface, we’re going to steal a page from Apple’s user interface playbook and model our interface on the way filters are specified in many Apple applications.
If you’re an iTunes user, check out how Smart Playlists are created for an example.
Each filter, one per “line,” is identified by a dropdown (single-selection <select> element) that specifies the field that’s to be filtered.
Based upon the type of that field (string, date, number, and even Boolean) the appropriate controls are displayed on the line to capture information about the filter.
The user is given the ability to add as many of these filters as they like, or to remove previously specified filters.
They show the filter panel that we’ll be building: (a) when initially displayed, (b) after a filter has been specified, and (c) after a number of filters have been specified.
Let’s take a few moments to discuss how we’re going to go about that.
Figure 4.10a The display initially shows a single, unconfigured filter.
We can readily see that to implement this filtering control panel, we’re going to need to create a fair number of elements in response to various events.
For example, we’ll new to create a new filter entry whenever the user clicks the Add Filter button, and new controls that qualify that filter whenever a specific field is selected.
No problem! In the previous chapter we saw how easy jQuery makes it to dynamically create elements using the $() function.
And although we’ll do some of that in our example, we’re also going to explore some higher-level alternatives.
When we’re dynamically creating lots of elements, all the code necessary to create those elements and stitch together their relationships can get a bit unwieldy and a bit.
Figure 4.10b After a filter type is selected, its qualifier controls are added.
Figure 4.10c The user can add as many filters as required.
Putting events (and more) to work difficult to maintain, even with jQuery’s assistance.
What’d be great would be if we could create a “blueprint” of the complex markup using HTML, and then replicate it whenever we needed an instance of the blueprint.
Yearn, no more! The jQuery clone() method gives us just that ability.
The approach that we’re going to take is to create sets of “template” markup that.
We don’t want these templates to be visible to the end user, so we’ll sequester them in a <div> element at the end of the page that’s hidden from view using CSS.
As an example, let’s consider the combination of the “X” button and dropdown that identifies the filterable fields.
We’ll need to create an instance of this combination every time the user clicks the Add Filter button.
But it’d be easy to envision that anything more complex would get unwieldy quickly.
Using our template technique, and placing the template markup for that button and dropdown in a parent <div> used to hide all the templates, we create markup as follows:
The outer <div> with id of templates serves as a container for all our templates and will be given a CSS display rule of none to prevent it from being displayed in the browser B.
Within this container, we define another <div> which we give the classes template and filterChooser C.
We’ll use the template class to identify templates in general, and the filterChooser class to identify this particular template type.
We’ll use this value to determine what type of filter controls need to be used for the selected filter field.
Based upon which filter type is identified, we’ll populate the remainder of the filter entry “line” with qualifying controls that are appropriate for the filter type.
For example, if the filter type is stringMatch, we’ll want to display a text field into which the user can type a text search term, and a dropdown giving them options for how that term is to be applied.
We’ve set up the template for this set of controls as follows:
Again, we’ve used the template class to identify the element as a template, and we’ve flagged the element with the class stringMatch.
We’ve purposely made it such that this class matches the data-filter-type value on the field chooser dropdown.
Replicating these templates whenever, and wherever, we want is easy using the jQuery knowledge under our belts.
Let’s say that we want to append a template instance to the end of an element that we have a reference to in a variable named whatever.
In this statement, we select the template container to be replicated (using those convenient classes we placed on the template markup), select the child elements of the template container (we don’t want to replicate the <div>, just its contents), make clones of those children, and then attach them to the end of the contents of the element identified by whatever.
See why we keep emphasizing the power of jQuery method chains? Inspecting the options of the filterChooser dropdown, we see that we have a.
So we define qualifying control templates for those filter types as well with this code:
Now that we’ve got our replication strategy defined, let’s take a look at the primary markup.
If we refer back to figure 4.10a, we can see that the initial display of our DVD search page is pretty simple: a few headers, a first filter instance, and a couple of buttons.
Let’s take a look at the HTML markup that achieves that:
There’s nothing too surprising in that markup—or is there? Where, for example, is the markup for the initial filter dropdown? We’ve set up a container in which the filters will be placed B, but it’s initially empty.
Well, we’re going to need to be able to populate new filters dynamically—which we’ll be getting to in just a moment—so why do the work in two places? As we shall see, we’ll be able to leverage the dynamic code to initially populate the first filter, so we don’t need to explicitly create it in the static markup.
One other thing that should be pointed out is that we’ve set aside a container to receive the results C (the fetching of which is beyond the scope of this chapter), and we’ve placed these results inside the form so that the results themselves can contain form controls (for sorting, paging, and so on)
We have our very simple, mainline HTML laid out, and we have a handful of hidden templates that we can use to quickly generate new elements via replication.
Let’s finally get to writing the code that will apply the behavior to our page!
Upon a click of the Add Filter button, we need to add a new filter to the <div> element that we’ve set up to receive it, which we’ve identified with the id of filterPane.
Recalling how easy it is to establish event handlers using jQuery, it should be an easy matter to add a click handler to the Add Filter button.
We’ve already seen how we’re going to replicate form controls when users add filters, and we’ve got a good strategy for easily creating multiple instances of these controls.
But eventually, we’re going to have to submit these values to the server so it can look up the filtered results in the database.
And if we just keep copying the same name attributes over and over again for our controls, the server is just going to get a jumbled mess without knowing what qualifiers belong to which filters!
To help out the server-side code (there’s a good chance we’ll be writing it ourselves in any case) we’re going to append a unique suffix to the name attribute for each filter entry.
That way, the serverside code can group them together by suffix when they arrive as part of the request.
Depending upon what you are using for your server-side code, you may wish to choose alternative suffix formats that might work better in conjunction with the data-binding mechanisms that are available to you.
For example, the “.n” format would not play particularly well with Java backends using property-based POJO binding mechanisms (a format of “[n]” would be better suited for this environment)
To keep track of how many filters we’ve added (so we can use the count as the suffix for subsequent filter names), we’ll create a global variable, initialized to 0, as follows:
Although this compound statement may look complicated at first glance, it accomplishes a great deal without a whole lot of code.
The first thing that we do in this code is to establish a click handler on the Add Filter button B by using the jQuery click() method.
It’s within the function passed to this method, which will get invoked when the button is clicked, that all the interesting stuff happens.
Because a click of the Add Filter button is going to, well, add a filter, we create a new container for the filter to reside within C.
We give it the class filterItem not only for CSS styling, but to be able to locate these elements later in code.
After the element is created, it’s appended to the master filter container that we created with the id value of filterPane.
We also need to record the suffix that we want to add to the control names that will be placed within this container.
This value will be used when it comes time to adjust the names of the controls, and this is a good example of a value that’s not suited for a global variable.
Each filter container (class filterItem) will have its own suffix, so trying to record this value globally would require some sort of complex array or map construct so that the various values didn’t step all over each other.
Rather, we’ll avoid the whole mess by recording the suffix value on the elements themselves using the very handy jQuery data() method.
Later, when we need to know what suffix to use for a control, we’ll simply look at this data value on its container and won’t have to worry about getting it confused with the values recorded on other containers.
The value is attached to the filterItem container using the name suffix, and we can later retrieve it by that name whenever we need it.
The final statement of the click handler D replicates the template that we set up containing the filter dropdown using the replication approach that we discussed in the previous section.
You might think that the job is over at this point, but after the cloning and appending, we execute E the following fragment:
The trigger() method is used to trigger an event handler for an event named adjustName.
What we’ve done with this code is to trigger a custom event.
A custom event is a very useful concept—we can attach code to an element as a handler for a custom event, and cause it to execute by triggering the event.
The beauty of this approach, as opposed to directly calling code, is that we can register the custom handlers in advance, and by simply triggering the event, cause any registered handlers to be executed, without having to know where they’ve been established.
OK, so that will trigger the custom event, but we need to define the handler for that event, so within the ready handler, we also establish the code to adjust the control names of the filters:
Here we see a use of the live() method to proactively establish event handlers.
The input elements with name attributes will be popping into and out of existence whenever a filter is added or removed, so we employ live() to automatically establish and remove the handlers as necessary.
We specify our custom event name of adjustName and supply a handler to be applied whenever we trigger the custom event.
Because it’s a custom event, there’s no possibility of it being triggered by user activity the way that, say, a click handler can be.
The closest() method quickly locates the parent container, upon which we find the suffix value.
Pattern alert! The custom event capability in jQuery is a limited example of the Observer pattern, sometimes referred to as the Publish/Subscribe pattern.
We subscribe an element to a particular event by establishing a handler for that event on that element, and then when the event is published (triggered), any subscribed elements in the event hierarchy automatically have their handlers invoked.
This can greatly reduce the complexity of code by reducing the coupling necessary.
We called this a limited example of the Observer pattern because subscribers are limited to elements in the publisher’s ancestor hierarchy (as opposed to anywhere in the DOM)
We don’t want to adjust element names that we’ve already adjusted once, so we use a regular expression test to see if the name already has the suffix attached, and if so, simply return from the handler.
If the name hasn’t been adjusted, we use the attr() method to both fetch the original name and set the adjusted name back onto the element.
At this point, it’s worth reflecting on how implementing this as a custom event, and using live(), creates very loose coupling in our page code.
This frees us from having to worry about calling the adjustment code explicitly, or establishing the custom handlers explicitly at the various points in the code when they need to be applied.
This not only keeps the code cleaner, it increases the flexibility of the code.
Load this page into your browser and test the action of the Add Filter button.
Note how every time you click on the Add Filter button, a new filter is added to the page.
If you inspect the DOM with a JavaScript debugger (Firebug in Firefox is great for this), you’ll see that the name of each <select> element has been suffixed with a per-filter suffix, as expected.
The dropdowns don’t yet specify which field is to be filtered.
When a selection is made by the user, we need to populate the filter container with the appropriate qualifiers for the filter type for that field.
Whenever a selection is made from a filter dropdown, we need to populate the filter with the controls that are appropriate for that filter.
We’ve made it easy for ourselves by creating markup templates that we just need to copy when we determine which one is appropriate.
But there are also a few other housekeeping tasks that we need to do whenever the value of the dropdown is changed.
Let’s take a look at what needs to be done when establishing the change handler for the dropdown:
Once again, we’ve taken advantage of jQuery’s live() method to establish a handler up front that will automatically be established at the appropriate points without further action on our part.
This time, we’ve proactively established a change handler for any filter dropdown that comes into being B.
Once we’ve got those values in hand, we need to remove any filter qualifier controls that might already be in the container C.
After all, the user can change the value of the selected field many times, and we don’t want to just keep adding more and more controls as we go along! We’ll add the qualifier class to all the appropriate elements as they’re created (in the next statement), so it’s easy to select and remove them.
Once we’re sure we have a clean slate, we replicate the template for the correct set of qualifiers D by using the value we obtained from the data-filter-type attribute.
The qualifier class name is added to each created element for easy selection (as we saw in the previous statement)
Also note how once again we trigger the adjustName custom event to automatically trigger the hander that will adjust the name attributes of the newly created controls.
Finally, we want to remove the “choose a filter” <option> element from the filter dropdown E, because once the user has selected a specific field, it doesn’t make any sense to choose that entry again.
We could just ignore the change event that triggers when the user selects this option, but the best way to prevent a user from doing something that doesn’t make sense is to not let them do it in the first place!
Once again, refer to the example page in your browser.
And if you can view the DOM in a debugger, observe how the name attributes are augmented.
We’ve given the user the ability to change the field that any filter will be applied to, but we’ve also given them a remove button (labeled “X”) that they can use to remove a filter completely.
By this time, you should already have realized that this task will be almost trivial with the tools at our disposal.
When the button is clicked, all we need to do is find the closest parent filter container, and blow it away!
You may recall that when the page is first loaded, an initial filter is displayed, even.
We can easily realize this by simulating a click of the Add Filter button upon page load.
This causes the Add Filter button handler to be invoked, just as if the user had clicked it.
Although it’s beyond the scope of this example to deal with submitting this form to the server, we thought we’d give you a tantalizing glimpse of what’s coming up in future chapters.
Go ahead and click the Apply Filters button, which you may have noted is a submit button for the form.
But rather than the page reloading as you might have expected, the results appear in the <div> element that we assigned the id of resultsPane.
That’s because we subverted the submit action of the form with a handler of our own that cancels the form submission and instead makes an Ajax call with the form contents, loading the results into the resultsPane container.
We’ll see lots more about how easy jQuery makes Ajax in chapter 8, but you might be surprised (especially if you’ve already done some cross-browser Ajax programming) to see that we can make the Ajax call with just one line of code:
If you paid attention to those displayed results, you might have noted that the results are the same no matter what filters are specified.
Obviously, there’s no real database powering this example, so it’s really just returning a hard-coded HTML page.
But it’s easy to imagine that the URL passed to jQuery’s load() Ajax method could reference a dynamic PHP, Java servlet, or Rails resource that would return actual results.
That completes the page, at least as far as we wanted to take it for the purposes of this chapter, but as we know ...
Below we’ll list some additional functionality that this form either requires before being deemed complete, or that would be just plain nice to have.
Can you implement these additional features with the knowledge you’ve gained up to this point?
For example, the qualifying fields for the binder range should be numeric values, but we do nothing to prevent the user from entering invalid values.
We could just punt and let the server-side code handle it—after all, it has to validate the data regardless.
But that makes for a less-than-pleasant user experience, and as we’ve already pointed out, the best way to deal with errors is to prevent them from happening in the first place.
The operation of the code should be evident to you with the knowledge you’ve gained in this chapter, but if not, now would be a good time to go back and review the key points.
Later in the book, we’ll see how the jQuery UI plugin solves this problem for us handily, but for now put your event-handling knowledge to the test!
When qualifying fields are added to a filter, the user must click in one of the fields to give it focus.
Not all that friendly! Add code to the example to give focus to the new controls as they are added.
The use of a global variable to hold the filter count violates our sensibilities and limits us to one instance of the “widget” per page.
Replace it by applying the data() method to an appropriate element, keeping in mind that we may want to use this multiple times on a page.
Our form allows the user to specify more than one filter, but we haven’t defined how these filters are applied on the server.
Do they form a disjunction (in which any one filter must match), or a conjunction (in which all filters must match)? Usually, if unspecified, a disjunction is assumed.
But how would you change the form to allow the user to specify which?
What other improvements, either to the robustness of the code or the usability of the interface, would you make? How does jQuery help?
If you come up with ideas that you’re proud of, be sure to visit the Manning web page for this book at http://www.manning.com/bibeault2, which contains a link to the discussion forum.
You’re encouraged to post your solutions for all to see and discuss!
Building upon the jQuery knowledge that we’ve gained so far, this chapter introduced us to the world of event handling.
We learned that there are vexing challenges to implementing event handling in web pages, but such handling is essential for creating pages in interactive web applications.
Not insignificant among those challenges is the fact the there are three event models that each operate in different ways across the set of modern popularly used browsers.
Summary probably the most familiar to page authors and assigns event listeners to DOM elements by assigning references to the listener functions to properties of the elements—the onclick property, for example.
Although simple, this model limits us to only one listener for any event type on a particular DOM element.
We can avoid this deficiency by using the DOM Level 2 Event Model, a more advanced and standardized model in which an API binds handlers to their event types and DOM elements.
Versatile though this model is, it is supported only by standardscompliant browsers such as Firefox, Safari, Camino, and Opera.
Coding all event handling in a series of if statements—one clause for the standard browsers and one for Internet Explorer—is a good way to drive ourselves to early dementia.
Luckily jQuery comes to the rescue and saves us from that fate.
As if all that were not enough, jQuery provides the live() method to assign handlers proactively to elements that may not even exist yet, and allows us to specify custom methods to easily register handlers to be invoked when those custom events are published.
We looked at a few examples of using events in our pages, and explored a comprehensive example that demonstrated many of the concepts that we’ve learned up to this point.
In the next chapter, we’ll look at how jQuery builds upon these capabilities to put animation and animated effects to work for us.
In those early days, the capabilities afforded to page authors were severely limited, not only by the minimal APIs, but by the sluggishness of scripting engines and low-powered systems.
The idea of using these limited abilities for animation and effects was laughable, and for years the only animation was through the use of animated GIF images (which were generally used poorly, making pages more annoying than usable)
Today’s browser scripting engines are lightning fast, running on hardware that was unimaginable 10 years ago, and they offer a rich variety of capabilities to us as page authors.
But even though the capabilities exist in low-level operations, JavaScript has no easy-to-use animation engine, so we’re on our own.
Except, of course, that jQuery comes to our rescue, providing a trivially simple interface for creating all sorts of neat effects.
But before we dive into adding whiz-bang effects to our pages, we need to contemplate the question, should we? Like a Hollywood blockbuster that’s all special effects and no plot, a page that overuses effects can elicit a very different, and negative, reaction than what we intend.
Be mindful that effects should be used to enhance the usability of a page, not hinder it by just showing off.
With that caution in mind, let’s see what jQuery has to offer.
Perhaps the most common type of dynamic effect we’ll want to perform on an element, or any group of elements, is the simple act of showing or hiding them.
We’ll get to more fancy animations (like fading an element in or out) in a bit, but sometimes we’ll want to keep it simple and pop elements into existence or make them instantly vanish!
The methods for showing and hiding elements are pretty much what we’d expect: show() to show the elements in a wrapped set, and hide() to hide them.
We’re going to delay presenting their formal syntax for reasons that will become clear in a bit; for now, let’s concentrate on using these methods with no parameters.
As simple as these methods may seem, we should keep a few things in mind.
First, jQuery hides elements by changing their style.display properties to none.
If an element in the wrapped set is already hidden, it will remain hidden but still be returned for chaining.
Note that even though the first element was already hidden, it remains part of the matched set and takes part in the remainder of the method chain.
Second, jQuery shows objects by changing the display property from none to either block or inline.
Which of these values is chosen is based upon whether a previously specified explicit value was set for the element or not.
Otherwise it’s based upon the default state of the display property for the target element type.
You’re no doubt familiar with sites, some of which aggregate data from other sites, that present you with various pieces of information in configurable “modules” on some sort of “dashboard” page.
The iGoogle site is a good example, as shown in figure 5.1
This site lets us configure much about how the page is presented, including moving the modules around, expanding them to full-page size, specifying configuration information, and even removing them completely.
But one thing it doesn’t let us do (at least at the time of this writing) is to “roll up” a module into its caption bar so that it takes up less room, without having to remove it from the page.
Let’s define our own dashboard modules and one-up Google by allowing users to roll up a module into its caption bar.
In figure 5.2a, we’ve created a module with two major sections: a caption bar, and a body.
The body contains the data of the module—in this case, random “Lorem ipsum” text.
The more interesting caption bar contains a caption for the module and small button that we’ll instrument to invoke the roll-up (and roll-down) functionality.
Figure 5.1 iGoogle is an example of a site that presents aggregated information in a series of dashboard modules.
Once the button is clicked, the body of the module will disappear as if it had been rolled up into the caption bar.
A subsequent click will roll down the body, restoring its original appearance.
The HTML markup we’ve used to create the structure of our module is fairly straightforward.
We’ve applied numerous class names to the elements both for identification as well as for CSS styling.
Figure 5.2a We’ll create our own dashboard modules, which consist of two parts: a bar with a caption and roll-up button, and a body in which data can be displayed.
Figure 5.2b When the roll-up button is clicked, the module body disappears as if it had been rolled up into the caption bar.
In order to give this module the roll-up behavior, we’ll instrument the image in the caption with a click handler that does all the magic.
And with the hide() and show() methods up our sleeves, giving the module this behavior is considerably easier than pulling a quarter out from behind someone’s ear.
Let’s examine the code placed into the ready handler to take care of the roll-up behavior:
As would be expected, this code first establishes a click handler on the image in the caption B.
Within the click handler, we first locate the body associated with the module.
We need to find the specific instance of the module body because, remember, we may have many modules on our dashboard page, so we can’t just select all elements that have the body class.
We quickly locate the correct body element by finding the closest module container, and using it as the jQuery context, finding the body within it using the jQuery expression C:
If how this expression finds the correct element isn’t clear to you, now would be a good time to review the information in chapter 2 regarding finding and selecting elements.
Once the body is located, it becomes a simple matter of determining whether the body is hidden or shown (the jQuery is() method comes in mighty handy here), and either showing or hiding it as appropriate using the show() D or hide() E method.
In either case, it’s a handy way to remember that the variable contains a reference to a wrapped set rather than an element or other type of object.
If you surmise that the “take 1” part of this filename indicates that we’ll be revisiting this example, you’re right.
Instruments the button B Finds the related bodyCShows the bodyD.
That wasn’t difficult at all, was it? But as it turns out, it can be even easier!
Toggling the display state of elements between revealed and hidden—as we did for the collapsible module example—is such a common occurrence that jQuery defines a method named toggle() that makes it even easier.
Let’s apply this method to the collapsible module and see how it helps to simplify the code of listing 5.1
Listing 5.2 shows only the ready handler for the refactored page (no other changes are necessary) with the changes highlighted in bold.
Note that we no longer need the conditional statement to determine whether to hide or show the module body; toggle()takes care of swapping the displayed state on our behalf.
This allows us to simplify the code quite a bit, and the need to store the body reference in a variable simply vanishes.
Instantaneously making elements appear and disappear is handy, but sometimes we want the transition to be less abrupt.
Human cognitive ability being what it is, making items pop into and out of existence instantaneously can be jarring to us.
If we blink at the wrong moment, we could miss the transition, leaving us to wonder, “What just happened?”
Gradual transitions of a short duration help us know what’s changing and how we got from one state to the other—and that’s where the jQuery core effects come in.
Let’s look more closely at each of these effect sets.
The show(), hide(), and toggle()methods are a tad more complex than we led you to believe in the previous section.
When called with no parameters, these methods effect a simple manipulation of the display state of the wrapped elements, causing them to instantaneously be revealed or hidden from the display.
But when passed parameters, these effects can be animated so that the changes in display status of the affected elements take place over a period of time.
With that, we’re now ready to look at the full syntaxes of these methods.
If called with no parameters, the operation takes place instantaneously by setting the display style property value of the elements to none.
If a speed parameter is provided, the elements are hidden over a period of time by adjusting their width, height, and opacity downward to zero, at which time their display style property value is set to none to remove them from the display.
An optional callback can be specified, which is invoked when the animation is complete.
Parameters speed (Number|String) Optionally specifies the duration of the effect as a number of.
If omitted, no animation takes place, and the elements are immediately removed from the display.
No parameters are passed to this function, but the function context (this) is set to the element that was animated.
The callback is fired for each element that undergoes animation.
If called with no parameters, the operation takes place instantaneously by setting the display style property value of the elements to an appropriate setting (one of block or inline)
If a speed parameter is provided, the elements are revealed over a specified duration by adjusting their width, height, and opacity upward to full size and opacity.
An optional callback can be specified that’s invoked when the animation is complete.
Parameters speed (Number|String) Optionally specifies the duration of the effect as a number of.
If omitted, no animation takes place and the elements are immediately revealed in the display.
No parameters are passed to this function, but the function context (this) is set to the element that was animated.
The callback is fired for each element that undergoes animation.
We can exert a bit more control over the toggling process with another variant of the toggle() method:
Let’s do a third take on the collapsible module, animating the opening and closing of the sections.
Given the previous information, you’d think that the only change we’d need to make to the code in listing 5.2 would be to change the call to the toggle() method to.
But not so fast! Because that was just too easy, let’s take the opportunity to also add.
Let’s say that, to give the user an unmistakable visual clue, we want the module’s.
We could make the change before firing off the animation, but it’d be much more suave to wait until the animation is finished.
We can’t just make the call right after the animation method call because animations don’t block.
The statements following the animated method call would execute immediately, probably even before the animation has had a chance to commence.
See the syntax description of those methods for their semantics.
Parameters speed (Number|String) Optionally specifies the duration of the effect as a number of.
No parameters are passed to this function, but the function context (this) is set to the element that was animated.
The callback is fired for each element that undergoes animation.
Rather, that’s where the callback that we can register with the toggle() method comes in.
The approach that we’ll take is that, after the animation is complete, we’ll add a class name to the module to indicate that it’s rolled up, and remove the class name when it isn’t rolled up.
Your initial thoughts might have led you to think of using css() to add a background style property directly to the caption, but why use a sledgehammer when we have a scalpel?
This second rule causes the background image of the caption to change whenever its parent module possesses the rolledup class.
So, in order to effect the change, all we have to do is add or remove the rolledup class to the module at the appropriate points.
Listing 5.3 shows the new ready handler code that makes that happen.
Knowing how much people like us love to tinker, we’ve set up a handy tool that we’ll use to further examine the operation of these and the remaining effects methods.
Back in chapter 2, we introduced the concept of lab pages to help us experiment with using jQuery selectors.
Loading this page into your browser results in the display of figure 5.3
This Lab consists of two main panels: a control panel in which we’ll specify which.
Let’s use this page to demonstrate the operations of the methods we’ve discussed.
Display the page in your browser, and follow along with the ensuing exercises:
Exercise 1—With the controls left as is after the initial page load, click the Apply button.
The expression that was applied is displayed below the Apply button for your information.
Note how the two initially hidden test subject elements appear instantly.
Figure 5.3 The initial state of the jQuery Effects Lab Page, which will help us examine the operation of the jQuery effects methods.
Animating the display state of elements wondering why the belt image on the far right appears a bit faded, its opacity has been purposefully set to 50 percent.
Exercise 2—Select the Hide radio button, and click Apply to execute a parameter-less hide() method.
Take special notice that the pane in which they resided has tightened up.
This indicates that the elements have been completely removed from the display rather than merely made invisible.
It doesn’t mean that the element has been removed from the DOM tree; none of the effects will ever cause an element to be removed from the DOM.
You’ll note that each subsequent execution of toggle() flips the presence of the test subjects.
Exercise 4—Reload the page to reset everything to the initial conditions (in Firefox and other Gecko browsers, set focus to the address bar and press the Enter key—simply clicking the reload button won’t reset the form elements)
Note how the two initially visible subjects vanish and the two that were hidden appear.
This demonstrates that the toggle() method applies individually to each wrapped element, revealing the ones that are hidden and hiding those that aren’t.
Exercise 5—In this exercise, we’ll move into the realm of animation.
Refresh the page, leave Show selected, and select Slow for the Speed setting.
The two hidden elements, rather than popping into existence, gradually grow from their upper-left corners.
If you want to really see what’s going on, refresh the page, select Milliseconds for the speed and enter 10000 for the speed value.
This will extend the duration of the effect to 10 (excruciating) seconds and give you plenty of time to observe the behavior of the effect.
Exercise 6—Choosing various combinations of Show, Hide, and Toggle, as well as various speeds, experiment with these effects until you feel you have a good handle on how they operate.
Armed with the jQuery Effects Lab Page, and the knowledge of how this first set of effects operates, let’s take a look at the next set of effects.
If you watched the operation of the show()and hide()effects carefully, you will have noted that they scaled the size of the elements (either up or down as appropriate) and adjusted the opacity of the elements as they grew or shrank.
The next set of effects, fadeIn()and fadeOut(), only affects the opacity of the elements.
Other than the lack of scaling, these methods work in a fashion similar to the animated forms of show() and hide()
Let’s have some more fun with the jQuery Effects Lab Page.
Display the Lab, and run through a set of exercises similar to those in the previous section but using the Fade In and Fade Out selections (don’t worry about Fade To for now; we’ll attend to that soon enough)
It’s important to note that when the opacity of an element is adjusted, the jQuery hide(), show(), fadeIn(), and fadeOut()effects remember the original opacity of an element and honor its value.
In the Lab, we purposefully set the initial opacity of the belt image at the far right to 50 percent before hiding it.
Throughout all the opacity changes that take place when applying the jQuery effects, this original value is never stomped on.
This value is either the opacity originally applied to the element, or 100 percent.
The duration of the change in opacity is determined by the speed parameter.
Parameters speed (Number|String) Specifies the duration of the effect as a number of milliseconds.
No parameters are passed to this function, but the function context (this) is set to the element that was animated.
The duration of the change in opacity is determined by the speed parameter.
Parameters speed (Number|String) Specifies the duration of the effect as a number of milliseconds.
No parameters are passed to this function, but the function context (this) is set to the element that was animated.
Run though additional exercises in the Lab until you’re convinced that this is so and are comfortable with the operation of the fade effects.
Another effect that jQuery provides is via the fadeTo() method.
This effect adjusts the opacity of the elements like the previously examined fade effects, but it never removes the elements from the display.
Before we start playing with fadeTo() in the Lab, here’s its syntax.
Unlike the other effects that adjust opacity while hiding or revealing elements, fadeTo() doesn’t remember the original opacity of an element.
This makes sense because the whole purpose of this effect is to explicitly change the opacity to a specific value.
Bring up the Lab page, and cause all elements to be revealed (you should know how by now)
The test subjects will fade to 10 percent opacity over the course of four seconds.
All elements, including the initially semitransparent belt image, are adjusted to full opaqueness.
All elements fade away to invisibility, but note that once they’ve vanished, the enclosing module doesn’t tighten up.
Unlike the fadeOut() effect, fadeTo() never removes the elements from the display, even when they’re fully invisible.
Continue experimenting with the Fade To effect until you’ve mastered its workings.
Then we’ll be ready to move on to the next set of effects.
Parameters speed (Number|String) Specifies the duration of the effect as a number of milliseconds.
No parameters are passed to this function, but the function context (this) is set to the element that was animated.
As with hide()and show(), the slide effects have a related method that will toggle the elements between hidden and revealed: slideToggle()
Parameters speed (Number|String) Specifies the duration of the effect as a number of milliseconds.
No parameters are passed to this function, but the function context (this) is set to the element that was animated.
Parameters speed (Number|String) Specifies the duration of the effect as a number of milliseconds.
No parameters are passed to this function, but the function context (this) is set to the element that was animated.
Except for the manner in which the elements are revealed and hidden, these effects act similarly to the other show and hide effects.
Convince yourself of this by displaying the jQuery Effects Lab Page and running through exercises like those we applied using the other effects.
We may have a reason now and again to stop an animation once it has started.
This could be because a user event dictates that something else should occur or because we want to start a completely new animation.
Note that any changes that have already taken place for any animated elements will remain in effect.
If we want to restore the elements to their original states, it’s our responsibility to change the CSS values back to their starting values using the css() method or similar methods.
By the way, there’s also a global flag that we can use to completely disable all animations.
Setting the flag jQuery.fx.off to true will cause all effects to take place immediately without animation.
We’ll cover this flag more formally in chapter 6 with the other jQuery flags.
See the syntax description of those methods for their semantics.
Parameters speed (Number|String) Optionally specifies the duration of the effect as a number of.
No parameters are passed to this function, but the function context (this) is set to the element that was animated.
Now that we’ve seen the effects built into core jQuery, let’s investigate writing our own!
The number of core effects supplied with jQuery is purposefully kept small, in order to keep jQuery’s core footprint to a minimum, with the expectation that page authors would use plugins (including jQuery UI which we will begin to explore in chapter 9) to add more animations at their discretion.
It’s also a surprisingly simple matter to write our own animations.
An optional callback function can be specified that’s invoked when the animation is complete.
An alternative format specifies a set of options in addition to the properties.
Parameters properties (Object) An object hash that specifies the values that supported CSS styles.
The animation takes place by adjusting the values of the style properties from the current value for an element to the value specified in this object hash.
Be sure to use camel case when specifying multiword properties.
If omitted or specified as 0, no animation takes place and the elements’ specified properties are immediately, and synchronously, set to the target values.
Easing functions must be registered by name and are often provided by plugins.
Core jQuery supplies two easing functions registered as “linear” and “swing”
See chapter 9 for the list of easing functions provided by jQuery UI.
No parameters are passed to this function, but the function context (this) is set to the element that was animated.
The function context is set to the element under animation.
We can create custom animations by supplying a set of CSS style properties and target values that those properties will converge towards as the animation progresses.
Animations start with an element’s original style value and proceed by adjusting that style value in the direction of the target value.
The intermediate values that the style achieves during the effect (automatically handled by the animation engine) are determined by the duration of the animation and the easing function.
The specified target values can be absolute values, or we can specify relative values from the starting point.
To specify relative values, prefix the value with += or -= to indicate relative target values in the positive or negative direction, respectively.
The term easing is used to describe the manner in which the processing and pace of the frames of the animation are handled.
By using some fancy math on the duration of the animation and current time position, some interesting variations to the effects are possible.
The subject of writing easing functions is a complex, niche topic that’s usually only of interest to the most hard-core of plugin authors; we’re not going to delve into the subject of custom easing functions in this book.
We'll be taking a look at a lot more easing functions in chapter 9 when we examine jQuery UI.
The list of CSS style properties that can be animated is limited to those that accept numeric values for which there is a logical progression from a start value to a target value.
This numeric restriction is completely understandable—how would we envision the logical progress from a source value to an end value for a non-numeric property such as background-image? For values that represent dimensions, jQuery assumes the default unit of pixels, but we can also specify em units or percentages by including the em or % suffixes.
Frequently animated style properties include top, left, width, height, and opacity.
But if it makes sense for the effect we want to achieve, numeric style properties such as font size, margin, padding, and border dimensions can also be animated.
In addition to specific values for the target properties, we can also specify one of the strings “hide”, “show”, or “toggle”; jQuery will compute the end value as appropriate to the specification of the string.
Using any of these special strings has the added effect of automatically revealing or removing the element from the display (like the hide() and show() methods), and it should be noted that “toggle” remembers the initial state so that it can be restored on a subsequent “toggle”
Did you notice that when we introduced the core animations that there was no toggling method for the fade effects? That’s easily solved using animate() and “toggle” to create a simple custom animation as follows:
Taking this to the next logical step—creating a wrapper function—could be coded as follows:
Now, let’s try our hand at writing a few more custom animations.
Consider a simple scale animation in which we want to adjust the size of the elements to twice their original dimensions.
We’d write such an animation as shown in listing 5.4
To implement this animation, we iterate over all the elements in the wrapped set via each() to apply the animation individually to each matched element B.
This is important because the property values that we need to specify for each element are based upon the individual dimensions for that element C.
If we always knew that we’d be animating a single element (such as if we were using an id selector) or applying the exact same set of values to each element, we could dispense with each() and animate the wrapped set directly.
Within the iterator function, the animate() method is applied to the element (identified via this) with style property values for width and height set to double the element’s original dimensions.
The result is that over the course of two seconds (as specified by the duration parameter of 2000 D), the wrapped elements (or element) will grow from their original size to twice that size.
Let’s say that we want to conspicuously animate the removal of an element from the display, perhaps because it’s vitally important to convey to users that the item being removed is gone and that they should make no mistake about it.
The animation we’ll use to accomplish this will make it appear as if the element drops off the page, disappearing from the display as it does so.
If we think about it for a moment, we can figure out that by adjusting the top position of the element we can make it move down the page to simulate the drop; adjusting the opacity will make it seem to vanish as it does so.
Creating custom animations that’s done, we can remove the element from the display (similar to the animated hide() method)
We can accomplish this drop effect with the code in listing 5.5
There’s a bit more going on here than in our previous custom effect.
We once again iterate over the element set, this time adjusting the position and opacity of the elements.
But to adjust the top value of an element relative to its original position, we first need to change its CSS position style property value to relative B.
Then, for the animation, we specify a target opacity of 0 and a computed top value.
We don’t want to move an element so far down the page that it moves below the window’s bottom; this could cause scroll bars to be displayed where none may have been before, possibly distracting users.
We don’t want to draw their attention away from the animation—grabbing their attention is why we’re animating in the first place! So we use the height and vertical position of the element, as well as the height of the window, to compute how far down the page the element should drop C.
When the animation is complete, we want to remove the element from the display, so we specify a callback routine D that applies the non-animated hide() method to the element (which is available to the function as its function context)
If we were to specify the value of the opacity property as “hide” rather than 0, the removal of the element(s) at the end of the animation would be automatic, and we could dispense with the callback.
Now let’s try one more type of “make it go away” effect for good measure.
Rather than dropping elements off the page, let’s say we want an effect that makes it appear as if the element dissipates away into thin air like a puff of smoke.
To animate such an effect, we can combine a scale effect with an opacity effect, growing the element while fading it away.
One issue we need to deal with for this effect is that this.
We want the center of the element to stay in the same place as it grows, so in addition to its size we also need to adjust the position of the element as part of the animation.
The code for our puff effect is shown in listing 5.6
In this animation, we decrease the opacity to 0 while growing the element to five times its original size and adjusting its position by half that new size, resulting in the center of the element remaining in the same position C.
We don’t want the elements surrounding the animated element to be pushed out while the target element is growing, so we take it out of the layout flow completely by changing its position to absolute and explicitly setting its position coordinates B.
Because we specified “hide” for the opacity value, the elements are automatically hidden (removed from the display) once the animation is complete.
Figure 5.4 The custom effects we developed, Scale, Drop, and Puff, can be observed in action using the buttons provided on this example page.
We purposefully kept the browser window to a minimum size for the screenshot, but you’ll want to make the window bigger when running this page to properly observe the behavior of the effects.
And although we’d love to show you how these effects behave, screenshots have obvious limitations.
We’ll leave it to you to try out the various effects on this page and observe their behavior.
Up until this point, all of the examples we’ve examined have used a single animation method.
Let’s discuss how things work when we use more than one.
We’ve seen how multiple properties of elements can be animated using a single animation method, but we haven’t really examined how animations behave when we call simultaneous animation methods.
In this section we’ll examine just how animations behave in concert with each other.
What would you expect to happen if we were to execute the following code?
We know that the animate() method doesn’t block while its animation is running on the page; nor do any of the other animation methods.
We can prove that to ourselves by experimenting with this code block:
Figure 5.5 The Puff effect expands and moves the image while simultaneously reducing its opacity.
Recall that we introduced the say() function in chapter 4 as a way to spit messages onto an on-page “console” in order to avoid alerts (which would most definitely screw up our observation of the experiment)
So, what would we expect to happen when we run the code with two animation method calls? Because the second method isn’t blocked by the first, it stands to reason that both animations fire off simultaneously (or within a few milliseconds of each other), and that the effect on the test subject would be the combination of the two effects.
In this case, because one effect is adjusting the left style property, and the other the top style property, we might expect that the result would be a meandering diagonal movement of the test subject.
The Start button is instrumented as shown in listing 5.7
In the click handler for the button, we fire off four animations, one after the other, interspersed with calls to say() that show us when the animation calls were fired off.
But what of the animations? If we examine the code in listing 5.7, we can see that we have two animations changing the top property and two animations changing the left property.
In fact, the animations for each property are doing the exact opposite of each other.
So what should we expect? Might they just cancel each other out, leaving the Moon (our test subject) to remain completely still?
Upon clicking Start, we see that each animation happens serially, one after the other, such that the Moon makes a complete and orderly revolution around the Earth (albeit in a very unnatural square orbit that would have made Kepler’s head explode)
What’s going on? We’ve proven via the console messages that the animations aren’t blocking, yet they execute serially just as if they were (at least with respect to each other)
What’s happening is that, internally, jQuery is queuing up the animations and executing them serially on our behalf.
Refresh the Kepler’s Dilemma page to clear the console, and click the Start button three times in succession.
You’ll note how 15 messages get immediately sent to the console, indicating that our click handler has executed three times, and then sit back as the Moon makes three orbits around the Earth.
Each of the 12 animations is queued up by jQuery and executed in order.
The significance of the queue having a name will become clear in the next section.
The queuing of animations in this manner means that we can have our cake and eat it too! We can affect multiple properties simultaneously by using a single animate() method that specifies all the animated properties, and we can serially execute any animations we want by simply calling them in order.
What’s even better is that jQuery makes it possible for us to create our own execution queues, not just for animations, but for whatever purposes we want.
Figure 5.7 The console messages appear in rapid succession, proving that the animation methods aren’t blocking until completion.
Queuing up animations for serial execution is an obvious use for function queues.
But is there a real benefit? After all, the animation methods allow for completion callbacks, so why not just fire off the next animation in the callback of the previous animation?
Let’s review the code fragment of listing 5.7 (minus the say() invocations for clarity):
Compare that to the equivalent code that would be necessary without function queuing, using the completion callbacks:
It’s not that the callback variant of the code is that much more complicated, but it’d be hard to argue that the original code isn’t a lot easier to read (and to write in the first place)
And if the bodies of the callback functions were to get substantially more complicated ...
Well, it’s easy to see how being able to queue up the animations makes the code a lot less complex.
So what if we wanted to do the same thing with our own functions? Well, jQuery isn’t greedy about its queues; we can create our own to queue up any functions we’d like to have executed in serial order.
Queues can be created on any element, and distinct queues can be created by using unique names for them (except for fx which is reserved for the effects queue)
The method to add a function instance to a queue is, unsurprisingly, queue(), and it has three variants:
The second form adds the passed function to the end of the named queue for all elements in the matched set.
If such a named queue doesn’t exist on an element, it’s created.
The last form replaces any existing queue on the matched elements with the passed queue.
The queue() method is most often used to add functions to the end of the named queue, but it can also be used to fetch any existing functions in a queue, or to replace the list of functions in a queue.
Note that the array form, in which an array of functions is passed to queue(), can’t be used to add multiple functions to the end of a queue because any existing queued functions are removed.
In order to add functions to the queue, we’d fetch the array of functions, merge the new functions, and set the modified array back into the queue.
OK, so now we can queue functions up for execution.
That’s not all that useful unless we can somehow cause the execution of the functions to actually occur.
When dequeue() is invoked, the foremost function in the named queue for each element in the wrapped set is executed with the function context for the invocation (this) being set to the element.
Parameters name (String) The name of the queue to be fetched, added to, or replaced.
Returns An array of functions for the first form, and the wrapped set for the remaining forms.
Parameters name (String) The name of the queue from which the foremost function is to be removed.
If omitted, the default effects queue of fx is assumed.
In each queue, we place four functions B that identify themselves in order and emit the alt attribute of whatever DOM element is serving as the function context.
This way, we can tell which function is being executed, and from which element’s queue.
Upon clicking the Dequeue button, the button’s click handler C causes a single execution of the dequeue() method.
Go ahead and click the button once, and observe the messages in the console, as shown in figure 5.8
We can see that the first function we added to the chain queue for the images has been fired twice: once for the Earth image, and once for the Moon image.
Clicking the button more times removes the subsequent functions from the queues one at a time, and executes them until the queues have been emptied; after which, calling dequeue()has no effect.
In this example, the dequeuing of the functions was under manual control—we needed to click the button four times (resulting in four calls to dequeue()) to get all four functions executed.
Frequently we may want to trigger the execution of the entire set of queued functions.
For such times, a commonly used idiom is to call the dequeue() method within the queued function in order to trigger the execution of (in other words, create a chain to) the next queued function.
Consider the following changes to the code in listing 5.8:
Bring up that page in your browser, and click the Dequeue button.
Note how the single click now triggers the execution of the entire chain of queued functions.
If we want to remove the queued functions from a queue without executing them, we can do that with the clearQueue() method:
Figure 5.8 Clicking the Dequeue button causes a single queued instance of the function to fire, once for each image that it was established upon.
While similar to the stop() animation method, clearQueue() is intended for use on general queued functions rather than just animation effects.
Another queue-oriented activity we might want to perform is to add a delay between the execution of queued functions.
There’s one more thing to discuss regarding queuing functions before moving along ...
We previously mentioned that internally jQuery uses a queue named fx to queue up the functions necessary to implement the animations.
What if we’d like to add our own functions to this queue in order to intersperse actions within a queued series of effects? Now that we know about the queuing methods, we can!
Think back to our previous example in listing 5.7, where we used four animations to make the Moon revolve around the Earth.
Imagine that we wanted to turn the background of the Moon image black after the second animation (the one that moves it downward)
Parameters name (String) The name of the queue from which the functions are to be removed.
If omitted, the default effects queue of fx is assumed.
Parameters duration (Number|String) The delay duration in milliseconds, or one of the strings fast or.
If omitted, the default effects queue of fx is assumed.
Summary we’d be very disappointed because this would cause the background to change immediately, perhaps even before the first animation had a chance to start.
Here, we wrap the css() method in a function that we place onto the fx queue using the queue() method.
We could have omitted the queue name, because fx is the default, but we made it explicit here for clarity.
This puts our color-changing function into place on the effects queue where it will be called as part of the function chain that executes as the animations progress, between the second and third animations.
But note! After we call the css() method, we call the dequeue() method on the fx queue.
This is absolute necessary to keep the animation queue chugging along.
Failure to call dequeue() at this point will cause the animations to grind to a halt, because nothing is causing the next function in the chain to execute.
The unexecuted animations will just sit there on the effects queues until either something causes a dequeue and the functions commence, or the page unloads and everything just gets discarded.
Queuing functions comes in handy whenever we want to execute functions consecutively, but without the overhead, or complexity, of nesting functions in asynchronous callbacks; something that, as you might imagine, can come in handy when we throw Ajax into the equation.
This chapter introduced us to the animated effects that jQuery makes available out of the box, as well as to the animate() method that allows us to create our own custom animations.
The show() and hide() methods, when used without parameters, reveal and conceal elements from the display immediately, without any animation.
We can perform animated versions of the hiding and showing of elements with these methods by passing parameters that control the speed of the animation, as well as providing an optional callback that’s invoked when the animation completes.
The toggle() method toggles the displayed state of an element between hidden and shown.
A third method, fadeTo(), animates a change in opacity for its wrapped elements without removing the elements from the display.
A final set of three built-in effects animates the removal or display of our wrapped elements by adjusting their vertical height: slideUp(), slideDown(), and slideToggle()
For building our own custom animations, jQuery provides the animate() method.
Using this method, we can animate any CSS style property that accepts a numeric value, most commonly the opacity, position, and dimensions of the elements.
We explored writing some custom animations that remove elements from the page in novel fashions.
We also learned how jQuery queues animations for serial execution, and how we can use the jQuery queuing methods to add our own functions to the effects queue or our own custom queues.
When we explored writing our own custom animations, we wrote the code for these custom effects as inline code within the on-page JavaScript.
A much more common, and useful, method is to package custom animations as custom jQuery methods.
We’ll learn how to do that in chapter 7, and you’re encouraged to revisit these effects after you’ve read that chapter.
Repackaging the custom effects we developed in this chapter, and any that you can think up on your own, would be an excellent follow-up exercise.
But before we write our own jQuery extensions, let’s take a look at some high-level jQuery functions and flags that will be very useful for general tasks as well as extension writing.
Up to this point, we’ve spent a fair number of chapters examining the jQuery methods that operate upon a set of DOM elements wrapped by the $() function.
These functions could be thought of as top-level functions except that they’re defined on the $ instance rather than window, keeping them out of the global namespace.
Generally, these functions either operate upon JavaScript objects other than DOM elements (that’s the purview of the wrapper methods, after all), or they perform some non-object-related operation (such as an Ajax request)
In addition to functions, jQuery also provides some useful flags that are defined within the jQuery/$ namespace.
You may wonder why we waited until this chapter to introduce these functions and flags.
We wanted to guide you into thinking in terms of using jQuery wrapper methods rather than resorting to lower-level operations that might feel more familiar but not be as efficient or as easy to code as using the jQuery wrapper.
Because the wrapper methods take care of much of what we want to do when manipulating DOM elements on the pages, these lower-level functions are frequently most useful when writing the methods themselves (as well as other extensions) rather than in page-level code.
We’ll be tackling how to write our own plugins to jQuery in the next chapter.
In this chapter, we’ll finally get around to formally introducing most of the $-level utility functions, as well as a handful of useful flags.
We’ll put off talking about the utility functions that deal with Ajax until chapter 8, which deals exclusively with jQuery’s Ajax functionality.
Some of the information jQuery makes available to us as page authors, and even plugin authors, is available not via methods or functions but as properties defined on $
Many of these flags are focused on helping us divine the capabilities of the current browser, but others help us control the behavior of jQuery at a page-global level.
The jQuery flags intended for public use are as follows:
Let’s start by looking at how jQuery lets us disable animations.
There may be times when we might want to conditionally disable animations in a page that includes various animated effects.
We might do so because we’ve detected that the platform or device is unlikely to deal with them well, or perhaps for accessibility reasons.
In any case, we don’t need to resort to writing two pages, one with and one without animations.
When we detect we’re in an animation-adverse environment, we can simply set the value of $.fx.off to true.
This will not suppress any effects we’ve used on the page; it will simply disable the animation of those effects.
For example, the fade effects will show and hide the elements immediately, without the intervening animations.
Similarly, calls to the animate() method will set the CSS properties to the specified final values without animating them.
One possible use-case for this flag might be for certain mobile devices or browsers that don’t correctly support animations.
In that case, you might want to turn off animations so that the core functionality still works.
Let’s take a look at the flag that gives us information on the environment provided by the user agent (browser)
Thankfully, almost blissfully, the jQuery methods that we’ve examined so far shield us from having to deal with browser differences, even in traditionally problematic areas like event handling.
But when we’re the ones writing these methods (or other extensions), we may need to account for the differences in the ways browsers operate so that the users of our extensions don’t have to.
Before we dive into seeing how jQuery helps us in this regard, let’s talk about the whole concept of browser detection.
OK, maybe the word heinous is too strong, but unless it’s absolutely necessary, the browser detection technique should be avoided.
Browser detection might seem, at first, like a logical way to deal with browser differences.
After all, it’s easy to say, “I know what the set of capabilities of browser X are, so testing for the browser makes perfect sense, right?” But browser detection is full of pitfalls and problems.
One of the major arguments against this technique is that the proliferation of browsers, as well as varying levels of support within versions of the same browser, makes this technique an unscalable approach to the problem.
You could be thinking, “Well, all I need to test for is Internet Explorer and Firefox.” But why would you exclude the growing number of Safari users? What about Opera and Google’s Chrome? Moreover, there are some niche, but not insignificant, browsers that share capability profiles with the more popular browsers.
Camino, for example, uses the same technology as Firefox behind its Mac-friendly UI.
And OmniWeb uses the same rendering engine as Safari and Chrome.
There’s no need to exclude support for these browsers, but it is a royal pain to have to test for them.
Yet another reason is that if we test for a specific browser, and a future release fixes that bug, our code may actually stop working.
A final argument against browser detection (or sniffing, as it’s sometimes called) is that it’s getting harder and harder to know who’s who.
Browsers identify themselves by setting a request header known as the user agent string.
A JavaScript object named navigator gives us a partial glimpse into the user agent information, but even it has browser differences.
We almost need to do browser detection in order to do browser detection!
Imprecise, accidentally blocking browsers within which our code would actually work.
Unscalable, leading to enormous nested if and if-else statements to sort things out.
Inaccurate, due to users spoofing user agent information Obviously, we’d like to avoid using it whenever possible.
If we think about it, we’re not really interested in which browser anyone is using, are we? The only reason we’re even thinking about browser detection is so that we can know which capabilities and features we can use.
It’s the capabilities and features of a browser that we’re really after; using browser detection is just a ham-handed way of trying to determine what those features and capabilities are.
So why don’t we just figure out what those features are rather than trying to infer them from the browser identification? The technique known broadly as feature detection allows code to branch based on whether certain objects, properties, or even methods exist.
Let’s think back to chapter 4 on event handling as an example.
Both models define methods on the DOM elements that allow listeners to be established, but each uses different method names.
Using browser detection, and assuming that we’ve gone through the pain and aggravation of determining which browser is being used (maybe even correctly), we could write.
Using the jQuery flags flags accurately represent the browser being used.
Moreover, this code will throw an error if used in Opera, Chrome, Camino, OmniWeb, or a host of other lesser-known browsers that might perfectly support the standard model.
This code doesn’t perform a lot of complex, and ultimately unreliable, browser detection, and it automatically supports all browsers that support either of the two competing event models.
It’s more reliable, and it doesn’t accidentally block browsers that support the capability we’re testing for simply because we don’t know about the features of that browser, or even of the browser itself.
Did you account for Google Chrome in your most recent web application? iCab? Epiphany? Konqueror?
If we can come up with a cross-browser solution, it should be preferred over any type of branching.
But as superior to browser detection as feature detection may be, it can still be no walk in the park.
Branching and detection of any type can still be tedious and painful in our pages, and some feature differences can be decidedly difficult to detect, requiring nontrivial or downright complex checks.
The browser capability flags are exposed to us as properties of jQuery’s $.support object.
Table 6.1 summarizes the flags that are available in this object.
Table 6.2 shows the values for each of these flags for the various browser families.
But lest this lull you into thinking that you can just fall back on browser detection, that approach fails miserably because bugs and differences may be fixed in future versions of IE.
And bear in mind that the other browsers aren’t immune from inadvertently introducing problems and differences.
Feature detection is always preferred over browser detection when we need to make capability decisions, but it doesn’t always come to our rescue.
There are those rare moments when we’ll need to resort to making browser-specific decisions that can only be made using browser detection (we’ll see an example in a moment)
For those times, jQuery provides a set of flags that allow direct browser detection.
For those times when only browser detection will do, jQuery provides a set of flags that we can use for branching.
They’re set up when the library is loaded, making them available even before any ready handlers have executed, and they’re defined as properties of an object instance with a reference of $.browser.
Note that even though these flags remain present in jQuery 1.3 and beyond, they’re regarded as deprecated, meaning that they could be removed from any future release of jQuery and should be used with that in mind.
These flags may have made more sense during the period when browser development had stagnated somewhat, but now that we’ve entered an era when browser development has picked up the pace, the capability support flags make more sense and are likely to stick around for some time.
In fact, it’s recommended that, when you need something more than the core support flags provide, you create new ones of your own.
Note that these flags don’t attempt to identify the specific browser that’s being.
Browsers within each family will sport the same sets of characteristics, so specific browser identification should not be necessary.
The vast majority of commonly used, modern browsers will fall into one of these four browser families, including Google Chrome, which returns true for the safari flag due to its use of the WebKit engine.
The version property deserves special notice because it’s not as handy as we might think.
The value set in this property isn’t the version of the browser (as we might initially believe) but the version of the browser’s rendering engine.
This value is handy for distinguishing between versions of Internet Explorer, as the rendering engine versions and browser versions match.
We mentioned earlier that there are times when we can’t fall back on feature detection and must resort to browser detection.
One example of such a situation is when the difference between browsers isn’t that they present different object classes or different methods, but that the parameters passed to a method are interpreted differently across the browser implementations.
In such a case, there’s no object or feature on which to perform detection.
But that’s not a technique we often see used on many pages outside of jQuery.
Let’s take the add() method of <select> elements as an example.
Because there’s no way to perform feature detection to determine whether we should pass an object reference or an integer value (short of trying it out, as noted previously), we can resort to browser detection, as shown in the following example:
The jQuery team, however, recommends that we not directly use such browser detection in our code.
Rather, it’s recommended that we abstract away the browser detection by creating a custom support flag of our own.
Using other libraries with jQuery support flags vanish, our code is insulated from the change by merely finding another way to set the flag in one location.
For example, somewhere in our own JavaScript library code, we could write.
Should the browser detection flag ever be removed, we’d only have to change our library code; all the code that uses the custom flag would be insulated from the change.
Let’s now leave the world of flags and look at the utility functions that jQuery provides.
Back in chapter 1, we introduced a means, thoughtfully provided for us by the jQuery team, to easily use jQuery on the same page as other libraries.
Usually, the definition of the $ global name is the largest point of contention and conflict when using other libraries on the same page as jQuery.
As we know, jQuery uses $ as an alias for the jQuery name, which is used for every feature that jQuery exposes.
But other libraries, most notably Prototype, use the $ name as well.
Another idiom we may often see employed is to create an environment where the $ identifier is scoped to refer to the jQuery object.
This technique is commonly used when extending jQuery, particularly by plugin authors who can’t make any assumpFunction syntax: $.noConflict.
Once this function is executed, jQuery features will need to be invoked using the jQuery identifier rather than the $ identifier.
This method should be called after including jQuery but before including the conflicting library.
Parameters jqueryToo (Boolean) If provided and set to true, the jQuery identifier is given up in.
If this notation makes your head spin, don’t worry! It’s pretty straightforward, even if odd-looking to those encountering it for the first time.
This part declares a function and encloses it in parentheses to make an expression out of it, resulting in a reference to the anonymous function being returned as the value of the expression.
And because parameter declarations have precedence over any similarly named identifiers in the global scope, any value defined for $ outside of the function is superseded within the function by the passed argument.
As a result, the $ identifier refers to the jQuery object within the body of the function, regardless of whether it’s already defined by Prototype or some other library outside of the function.
When employing this technique, the external declaration of $ isn’t available within the body of the function.
But this time, we declare a single parameter to be passed to the ready handler using the $ identifier.
In this example, we import jQuery, which (as we know) defines the global names jQuery and its alias $
We then redefine the global $ variable to a string value B, overriding the jQuery definition.
We replace $ with a simple string value for simplicity within this example, but it could be redefined by including another library such as Prototype.
We then define the ready handler C whose only action is to display an alert showing the value of $
When we load this page, we see the alert displayed, as shown in figure 6.1
Note that, within the ready handler, the global value of $ is in scope and has the.
How disappointing if we wanted to use the jQuery definition of $ within the handler.
The following code shows only the portion of the document that has been modified; the minimal change is highlighted in bold.
The only change we made was to add a parameter to the ready handler function named $
When we load this changed version, we see something completely different, as shown in figure 6.2
Well, that may not have been exactly what we might have predicted in advance, but a quick glance at the jQuery source code shows that, because we declare the first parameter of the ready handler to be $ within that function, the $ identifier refers to the jQuery function that jQuery passes as the sole parameter to all ready handlers (so the alert displays the definition of that function)
A good number of the remaining jQuery utility functions are used to manipulate JavaScript objects.
The majority of jQuery features implemented as utility functions are designed to operate on JavaScript objects other than the DOM elements.
Generally, anything designed to operate on the DOM is provided as a jQuery wrapper method.
Although some of these functions can be used to operate on DOM elements—which are JavaScript objects, after all—the focus of the utility functions isn’t DOM-centric.
These functions run the gamut from simple string manipulation and type testing to complex collection filtering, serialization of form values, and even implementing a form of object inheritance through property merging.
Almost inexplicably, the JavaScript String type doesn’t possess a method to remove whitespace characters from the beginning and end of a string instance.
Such basic functionality is customarily part of a String class in most other languages, but JavaScript mysteriously lacks this useful feature.
Yet string trimming is a common need in many JavaScript applications; one prominent example is during form data validation.
Manipulating JavaScript objects and collections screen (hence its name), it’s easy for users to accidentally enter extra space characters before or after valid entries in text boxes or text areas.
During validation, we want to silently trim such whitespace from the data rather than alerting the user to the fact that something they can’t see is tripping them up.
To help us out, jQuery defines the $.trim() function as follows:
A small example of using this function to trim the value of a text field in-place is.
Be aware that this function doesn’t check the parameter we pass to ensure that it’s a String value, so we’ll likely get undefined and unfortunate results (probably a JavaScript error) if we pass any other value type to this function.
Now let’s look at some functions that operate on arrays and other objects.
Oftentimes when we have nonscalar values composed of other components, we’ll need to iterate over the contained items.
Whether the container element is a JavaScript array (containing any number of other JavaScript values, including other arrays) or instances of JavaScript objects (containing properties), the JavaScript language gives us means to iterate over them.
For arrays, we iterate over their elements using the for loop; for objects, we iterate over their properties using the for-in loop.
Pretty easy stuff, but some might think that the syntax is needlessly wordy and complex—a criticism frequently targeted at the for loop.
For general arrays and objects, jQuery provides an analogous utility function named $.each()
The really nice thing is that the same syntax is used, whether iterating over the items in an array or the properties of an object.
This unified syntax can be used to iterate over either arrays or objects using the same format.
With this function, we can write the previous example as follows:
Although using $.each() with an inline function may seem like a six-of-one scenario in choosing syntax, this function makes it easy to write reusable iterator functions or to factor out the body of a loop into another function for purposes of code clarity, as in the following:
Note that when iterating over an array or object, we can break out of the loop by returning false from the iterator function.
Bear in mind that if you need to be concerned with performance to that level, you’ll get the best performance from a good old-fashioned for loop.
Parameters container (Array|Object) An array whose items, or an object whose properties, are to be.
The first parameter to this callback is the index of the array element or the name of the object property.
The second parameter is the array item or property value.
The function context (this) of the invocation is also set to the value passed as the second parameter.
Sometimes we may iterate over arrays to pick and choose elements to become part of a new array.
Although we could use $.each() for that purpose, let’s see how jQuery makes that even easier.
Traversing an array to find elements that match certain criteria is a frequent need of applications that handle lots of data.
We might wish to filter the data for items that fall above or below a particular threshold or, perhaps, that match a certain pattern.
For any filtering operation of this type, jQuery provides the $.grep()utility function.
The name of the $.grep() function might lead us to believe that the function employs the use of regular expressions like its namesake, the UNIX grep command.
But the filtering criterion used by the $.grep() utility function isn’t a regular expression; it’s a callback function provided by the caller that defines the criteria to determine whether a data value should be included or excluded from the resulting set of values.
Nothing prevents that callback from using regular expressions to accomplish its task, but the use of regular expressions isn’t automatic.
We’d do that with a statement such as the following:
The callback function that we pass to $.grep() can use whatever processing it likes to determine if the value should be included.
The return value of the callback function determines whether the value is collected into a new array returned as the value of the $.grep() function.
If the invert parameter is omitted or false, a callback value of true causes the data to be collected.
If invert is true, a callback value of false causes the value to be collected.
Parameters array (Array) The traversed array whose data values are examined for collection.
A return value of true causes the current value to be collected, unless the value of the invert parameter is true, in which case the opposite occurs.
This function is passed two parameters: the current data value and the index of that value within the original array.
Even though the $.grep() function doesn’t directly use regular expressions (despite its name), JavaScript regular expressions can be powerful tools in our callback functions to determine whether to include or exclude values from the resultant array.
Consider a situation in which we have an array of values and wish to identify any values that don’t match the pattern for United States postal codes (also known as Zip Codes)
Notable in this example is the use of the String class’s match() method to determine whether a value matches the pattern or not and the specification of the invert parameter to $.grep() as true to exclude any values that match the pattern.
Collecting subsets of data from arrays isn’t the only operation we might perform upon them.
Data might not always be in the format that we need it to be.
Another common operation that’s frequently performed in data-centric web applications is the translation of a set of values to another set.
Although it’s a simple matter to write a for loop to create one array from another, jQuery makes it even easier with the $.map utility function.
Parameters array (Array) The array whose values are to be transformed to values in the new array.
This function is passed two parameters: the current data value and the index of that value within the original array.
This statement converts an array of values, a zero-based set of indexes, to a corresponding array of one-based indexes.
An important behavior to note is that if the function returns either null or undefined, the result isn’t collected.
In such cases, the resulting array will be smaller in length than the original, and one-to-one correspondence between items by order is lost.
Imagine that we have an array of strings, perhaps collected from form fields, that are expected to represent numeric values, and that we want to convert this string array to an array of corresponding Number instances.
Because there’s no guarantee against the presence of an invalid numeric string, we need to take some precautions.
We start with an array of string values, each of which is expected to represent a numeric value.
Our code handles this case by checking the Number instance created by the constructor to see if the conversion from string to numeric was successful or not.
If the conversion fails, the value returned will be the constant Number.NaN.
Because we can’t use a comparison operator to test for NaN (which stands for Not a Number, by the way), JavaScript provides the isNaN() method, which we employ to test the result of the string-to-numeric conversion.
In this example, we return null in the case of failure, ensuring that the resulting array contains only the valid numeric values with any error values elided.
If we want to collect all the values, we can allow the transformation function to return Number.NaN for bad values.
Another useful behavior of $.map()is that it gracefully handles the case where an array is returned from the transformation function, merging the returned value into the resulting array.
This statement transforms an array of strings into an array of all the characters that make up the strings.
After execution, the value of the variable characters is as follows:
This is accomplished by use of the String.split() method, which returns an array of the string’s characters when passed an empty string as its delimiter.
This array is returned as the result of the transformation function and is merged into the resultant array.
There are a handful of minor functions that we might find handy.
Have you ever needed to know if a JavaScript array contained a specific value and, perhaps, even the location of that value in the array?
A trivial but illustrative example of using this function is.
This results in the index value of 1 being assigned to the index variable.
Another useful array-related function creates JavaScript arrays from other array-like.
This populates the variable images with a NodeList of all the images on the page.
Dealing with a NodeList is a bit of a pain, so converting it to a JavaScript array.
Parameters value (Object) The value for which the array will be searched.
Returns The index of the first occurrence of the value within the array, or -1 if the value isn’t found.
Parameters object (Object) The array-like object (such as a NodeList) to be converted.
This function is intended for use in code that doesn’t make much use of jQuery, which internally handles this sort of thing on our behalf.
This function also comes in handy when dealing with NodeList objects while traversing XML documents without jQuery, or when handling the arguments instance within functions (which, you may be surprised to learn, isn’t a standard JavaScript array)
Another seldom-used function that might come in handy when dealing with arrays built outside of jQuery is the $.unique() function.
Again, this is a function that jQuery uses internally to ensure that the lists of elements that we receive contain unique elements.
It’s intended for use on element arrays created outside the bounds of jQuery.
Want to merge two arrays? No problem; there’s the $.merge function:
Now that we’ve seen how jQuery helps us to easily work with arrays, let’s see how it helps us manipulate plain old JavaScript objects.
Although we all know that JavaScript provides some features that make it act in many ways like an object-oriented language, we know that JavaScript isn’t what anyone.
Parameters array (Array) The array of DOM elements to be examined.
Returns An array of DOM elements consisting of the unique elements in the passed array.
The first array is modified by this operation and returned as the result.
Parameters array1 (Array) An array into which the other array’s values will be merged.
Returns The first array, modified with the results of the merge.
One of these important features is inheritance—the manner in which new classes are defined by extending the definitions of existing classes.
A pattern for mimicking inheritance in JavaScript is to extend an object by copying the properties of a base object into the new object, extending the new object with the capabilities of the base.
Because understanding such advanced topics isn’t a requirement in order to use jQuery effectively, this is a subject—albeit an important one—that’s beyond the scope of this book.
It’s fairly easy to write JavaScript code to perform this extension by copying, but as with so many other procedures, jQuery anticipates this need and provides a readymade utility function to help us out: $.extend()
As we’ll see in the next chapter, this function is useful for much more than extending an object.
Let’s take a look at this function doing its thing.
We’ll set up three objects, a target and two sources, as follows:
Parameters deep (Boolean) An optional flag that determines whether a deep or shallow copy.
This object is directly modified with the new properties before being returned as the value of the function.
Any properties with the same name as properties in any of the source elements are overridden with the values from the source elements.
When more than one source is provided and properties with the same names exist in the sources, sources later in the argument list override those earlier in the list.
This should take the contents of the source objects and merge them into the target.
Loading this page into a browser results in the display of figure 6.3
As we can see, all properties of the source objects have been merged into the target object.
Both the target and source1 contain a property named c.
The value of c in source1 replaces the value in the original target.
Although it’s evident that this utility function can be useful in many scenarios where one object must be extended with properties from another object (or set of objects), we’ll see a concrete and common use of this feature when learning how to define utility functions of our own in the next chapter.
But before we get to that, we’ve still got a few other utility functions to examine.
It should come as no surprise that in a dynamic, highly interactive application, submitting requests is a common occurrence.
Heck, it’s one of the things that makes the World Wide Web a web in the first place.
Frequently, these requests will be submitted as a result of a form submission, where the browser formats the request body containing the request parameters on our behalf.
Other times, we’ll be submitting requests as URLs in the href attribute of <a> elements.
In these latter cases, it becomes our responsibility to correctly create and format the query string that contains any request parameters we wish to include with the request.
Server-side templating tools generally have great mechanisms that help us construct valid URLs, but when creating them dynamically on the client, JavaScript doesn’t give us much in the way of support.
Remember that not only do we need to correctly place all the ampersand (&) and equal signs (=) that format the query string parameters, we need to make sure that each name and value is properly URI-encoded.
And, as you might have come to expect, jQuery anticipates that burden and gives us a tool to make it easier: the $.param() utility function.
Here, we pass an object with three properties to the $.param() function, in which the names and the values all contain characters that must be encoded within the query string in order for it to be valid.
Note how the query string is formatted correctly and that the non-alphanumeric characters in the names and values have been properly encoded.
This might not make the string all that readable to us, but server-side code lives for such strings!
The passed value can be an array of form elements, a jQuery wrapped set, or a JavaScript object.
The query string is properly formatted and each name and value in the string is properly URI-encoded.
If an array of elements or a jQuery wrapped set is passed, the name/value pairs represented by the included form controls are added to the query string.
If a JavaScript object is passed, the object’s properties form the parameter names and values.
One note of caution: if you pass an array of elements, or a jQuery wrapped set, that contains elements other than those representing form values, you’ll end up with a bunch of entries such as.
You might be thinking that this isn’t a big deal because, after all, if the values are form elements, they’re going to end up being submitted by the browser via the form, which is going to handle all of this for us.
In chapter 8, when we start talking about Ajax, we’ll see that form elements aren’t always submitted by their forms!
But that’s not going to be an issue, because we’ll also see later on that jQuery provides a higher-level means (that internally uses this very utility function) to handle this sort of thing in a more sophisticated fashion.
Trained by years of dealing with the limitations of HTTP and HTML form controls, web developers are conditioned to think of serialized parameters, aka query strings, as a flat list of name/value pairs.
For example, imagine a form in which we collect someone’s name and address.
The query parameters for such a form might contain names such as firstName, lastName and city.
As an object, that doesn’t really represent the way that we’d think about such data.
From a data organization point of view, we might think of this data as two major elements, a name and an address, each with their own properties.
But this nested version of the element, though more logically structured than the flat version, doesn’t easily lend itself to conversion to a query string.
Or does it? By using a conventional notation employing square brackets, such a construct.
In this notation, sub-properties are expressed using square brackets to keep track of the structure.
Many server-side frameworks such as RoR (Ruby on Rails) and PHP can handily decode these strings.
Java doesn’t have any native facility to reconstruct a nested object from such notation, but such a processor would be pretty easy to build.
If we want to cause $.param() to exhibit the older behavior, the traditional parameter should be passed as true.
This Lab lets us see how $.param() will serialize flat and nested objects, using its new algorithm, as well as the traditional algorithm.
Go ahead and play around with this Lab until you feel comfortable with the action of the function.
We even urge you to make a copy of the page and play around with different object structures that you might want to serialize.
You may have noticed that many of the jQuery wrapper methods and utility functions have rather malleable parameter lists; optional parameters can be omitted without the need to include null values as placeholders.
But if we have no data to pass to the event, we can simply call bind() with the handler function as the second parameter.
Testing parameters for various types, including whether they are functions or not, will certainly come in handy if we want to create our own functions and methods that are similarly friendly and versatile, so jQuery exposes a number of testing utility functions, as outlined in table 6.4
Now let’s look at a handful of miscellaneous utility functions that don’t really fit into any one category.
Warning: in Internet Explorer, built-in functions such as alert() and confirm(), as well as element methods are not correctly reported as functions.
This section will explore the set of utility functions that each pretty much define their own category.
We’ll start with one that doesn’t seem to do very much at all.
Hmmm, a function that is passed nothing, does nothing, and returns nothing.
Recall how many jQuery methods are passed parameters, or option values, that are optional function callbacks? $.noop() serves as a handy default for those callbacks when the user does not supply one.
When we want to test one element for containment within another, jQuery provides the $.contains() utility function:
Hey, wait a minute! Doesn’t this sound familiar? Indeed, we discussed the has() method back in chapter 2, to which this function bears a striking resemblance.
This function, used frequently internally to jQuery, is most useful when we already have references to the DOM elements to be tested, and there’s no need to take on the overhead of creating a wrapped set.
Let’s look at another function that closely resembles its wrapper-method equivalent.
Parameters container (Element) The DOM element being tested as containing another element.
Returns true if the containee is contained within the container; false otherwise.
Back in chapter 3, we examined the data() method, which allows us to assign data to DOM elements.
For those cases where we already have a DOM element reference, we can use the low-level utility function $.data() to perform the same action:
As might be expected, we can also remove the data via a utility function:
Now let’s turn our attention to one of the more esoteric utility functions—one that lets us have a pronounced effect on how event listeners are called.
As we’ve seen throughout our examination of jQuery, functions and their contexts play an important role in jQuery-using code.
The contexts of functions—what’s pointed to by this—is determined by how the function is invoked (see the appendix if you want to review this concept)
When we want to call a particular function and explicitly control what the function context will be, we can use the Function.call() method to invoke the function.
But what if we’re not the ones calling the function? What if, for example, the function is a callback? In that case, we’re not the ones invoking the function so we can’t use Function.call() to affect the setting of the function context.
Parameters element (Element) The DOM element upon which the data is to be established, or from.
Parameters element (Element) The DOM element from which the data is to be removed.
This utility function is named $.proxy(), and its syntax is as follows:
In this example page, a Test button is created within a <div> element with an id value of buttonContainer.
When the Normal radio button is clicked, a click handler is established on the button and its container as follows:
When the button is clicked, we’d expect the established handler to be invoked on the button and, because of event bubbling, on its parent container.
In each case, the function context of the invocation should be the element upon which the handler was established.
Parameters function (Function) The function to be prebound with the proxy object.
The results of the call to say(this.id) within the handler (which reports the id property of the function context) show that all is as expected—see the top portion of figure 6.6
The handler is invoked twice: first on the button and then on the container, with each element respectively set as the function context.
However, when the Proxy radio button is checked, the handler is established as follows:
This establishes the same handler as before, except that the handler function has been passed through the $.proxy() utility function, prebinding an object to the handler.
In this case, we bound the element with the id of controlPanel.
The bound object does not have to be an element—in fact, most often it won’t be.
We just chose it for this example because it makes the object easy to identify via its id value.
Figure 6.6 This example shows the effects of prebinding an object to the click handler for the Test button.
This ability is really useful for providing data to a callback that it might not normally have access to via closures or other means.
The most common use case for $.proxy() is when we want to bind a method of an object as a handler, and have the method’s owning object established as the handler’s function context exactly as if we had called the method directly.
If we were to call the hello() method via o.hello(), the function context (this) would be o.
And if our handler relies upon o, we’re rather screwed.
We can unwedge ourselves by using $.proxy() to force the function context to be o with one of these two statements:
Be aware that going this route means that you will not have any way of knowing the current bubble element of the event propagation—the value normally established as the function context.
As most JSON is also valid JavaScript expression syntax, the JavaScript eval() function has long been used to convert a JSON string to its JavaScript equivalent.
Modern browsers provide JSON.parse() to parse JSON, but not everyone has the luxury of assuming that all of their users will be running the latest and greatest.
Otherwise, it will use a JavaScript trick to perform the evaluation.
Bear in mind that the JSON string must be completely well-formed, and that the rules for well-formed JSON are much more strict than JavaScript expression notation.
For example, all property names must be delimited by double-quote characters, even if they form valid identifiers.
While the use of eval() is derided by some Internet illuminati, there are times when it’s quite useful.
When writing plugins and other reusable scripts, we might want to ensure that the evaluation always takes place in the global context.
Let’s wrap up our investigation of the utility functions with one that we can use to dynamically load new scripts into our pages.
But every now and again, we might want to load a script after the fact under script control.
We might do this because we don’t know if the script will be needed until after some specific user activity has taken place, and we don’t want to include the script unless it’s absolutely needed.
Or perhaps we might need to use some information not available at load time to make a conditional choice between various scripts.
Regardless of why we might want to dynamically load new scripts into the page, jQuery provides the $.getScript() utility function to make it easy.
Under its covers, this function uses jQuery’s built-in Ajax mechanisms to fetch the script file.
We’ll be covering these Ajax facilities in great detail in chapter 8, but we don’t need to know anything about Ajax to use this function.
After fetching, the script in the file is evaluated, any inline script is executed, and any defined variables or functions become available.
Any dynamically loaded script elements don’t become available until after the script block within which it is loaded relinquishes control back to the browser.
If your pages are going to support these older versions of Safari, plan accordingly!
This trivial script file contains an inline statement (which issues an alert that leaves no doubt as to when the statement gets executed), a variable declaration, and a declaration for a function that issues an alert containing whatever value is passed to it when executed.
Now let’s write a page to include this script file dynamically.
Parameters url (String) The URL of the script file to fetch.
This page defines two buttons D that we use to trigger the activity of the example.
The first button, labeled Load, causes the new.stuff.js file to be dynamically loaded through use of the $.getScript() function B.
Note that, initially, the second parameter (the callback) is commented out—we’ll get to that in a moment.
On clicking the Load button, the new.stuff.js file is loaded, and its content is evaluated.
As expected, the inline statement within the file triggers an alert message, as shown in figure 6.7
Clicking the Inspect button executes its click handler C, which executes the dynamically loaded someFunction() function, passing the value of the dynamically loaded someVariable variable.
If the alert appears as shown in figure 6.8, we know that both the variable and function are loaded correctly.
Figure 6.7 The dynamic loading and evaluation of the script file results in the inline alert statement being executed.
This callback executes the click handler for the Inspect button, calling the dynamically loaded function with the loaded variable as its parameter.
In browsers other than Safari 2, the function and variable loaded dynamically from the script are available within the callback function.
In this chapter we surveyed the features that jQuery provides outside of the methods that operate upon a wrapped set of matched DOM elements.
These included an assortment of functions, as well as a set of flags, defined directly on the jQuery top-level name (as well as its $ alias)
We saw how jQuery informs us about the capabilities of the containing browser using the various flags in the $.support object.
After calling this function, all jQuery operations must use the jQuery name rather than $
Figure 6.8 The appearance of the alert shows that the dynamic function is loaded correctly, and the correctly displayed value shows that the variable was dynamically loaded.
We also saw how jQuery lets us construct properly formatted and encoded query strings with $.param()
To merge objects, perhaps even to mimic a sort of inheritance scheme, jQuery also provides the $.extend() function.
This function allows us to unite the properties of any number of source objects into a target object.
We also saw a bevy of functions for testing objects to see if they’re functions, JavaScript objects, or even empty objects—useful for many situations, but particularly when inspecting variable argument lists.
And for those times when we want to load a script file dynamically, jQuery defines $.getScript(), which can load and evaluate a script file at any point in the lifetime of a page, even from domains other than the page source.
With these additional tools safely tucked away in our toolbox, we’re ready to tackle adding our own extensions to jQuery.
Over the course of the previous chapters, we’ve seen that jQuery gives us a large toolset of useful methods and functions, and we’ve also seen that we can easily tie these tools together to give our pages whatever behavior we choose.
Sometimes that code follows common patterns we want to use again and again.
When such patterns emerge, it makes sense to capture these repeated operations as reusable tools that we can add to our original toolset.
In this chapter, we’ll explore how to capture these reusable fragments of code as extensions to jQuery.
But before any of that, let’s discuss why we’d want to pattern our own code as extensions to jQuery in the first place.
When writing our own code, we can write it however we please, but most experienced developers agree that having all of the code on a site, or at least the great majority of it, adhere to a consistent style is a good practice.
So one good reason to pattern our code as jQuery extensions is to help maintain a consistent code style throughout the site.
Not reason enough? Need more? The whole point of jQuery is to provide a set of reusable tools and APIs.
The creators of jQuery carefully planned the design of the library and the philosophy of how the tools are arranged to promote reusability.
By following the precedent set by the design of these tools, we automatically reap the benefits of the planning that went into these designs—a compelling second reason to write our code as jQuery extensions.
Still not convinced? The final reason we’ll consider (though it’s quite possible others could list even more reasons) is that, by extending jQuery, we can leverage the existing code base that jQuery makes available to us.
For example, by creating new jQuery methods (wrapper methods), we automatically inherit the use of jQuery’s powerful selector mechanism.
Why write everything from scratch when we can layer upon the powerful tools jQuery already provides?
Given these reasons, it’s easy to see that writing our reusable components as jQuery extensions is a good practice and a smart way of working.
In the remainder of this chapter, we’ll examine the guidelines and patterns that allow us to create jQuery plugins, and we’ll create a few of our own.
In the following chapter, which covers a completely different subject (Ajax), we’ll see even more evidence that creating our own reusable components as jQuery plugins in real-world scenarios helps to keep the code consistent and makes it a whole lot easier to write those components in the first place.
Sign! Sign! Everywhere a sign! Blocking out the scenery, breaking my mind.
Do this! Don’t do that! Can’t you read the sign?
Although the Five Man Electrical Band may have lyrically asserted an antiestablishment stance against rules back in 1971, sometimes rules are a good thing.
These guidelines help us ensure that not only does our new code plug into the jQuery architecture properly, but also that it will work and play well with other jQuery plugins, and even other JavaScript libraries.
In the remainder of this section, we’ll go over some guidelines common to both types of extensions.
Then, in the following sections, we’ll tackle the guidelines and techniques specific to writing each type of plugin.
To Tell the Truth was an American game show, first airing in the 1950s, in which multiple contestants claimed to be the same person with the same name, and a panel of celebrities was tasked with determining which of the contestants was in reality the person they all claimed to be.
Although fun for a television audience, name collisions aren’t fun at all when it comes to programming.
We’ll discuss avoiding name collisions within our plugins, but first let’s address naming the files within which we’ll write our plugins so that they don’t conflict with other files.
The guideline recommended by the jQuery team is simple but effective, advocating the following format:
The use of the “jquery” prefix eliminates any possible name collisions with files intended for use with other libraries.
After all, anyone writing non-jQuery plugins has no business using the “jquery” prefix, but that leaves the plugin name itself still open for contention within the jQuery community.
When we’re writing plugins for our own use, all we need to do is avoid conflicts with any other plugins that we plan to use.
But when writing plugins that we plan to publish for others to use, we need to avoid conflicts with any other plugin that’s already published.
The best way to avoid conflicts is to stay in tune with the goings-on within the jQuery community.
A good starting point is the page at  http://plugins.jquery.com/, but beyond being aware of what’s already out there, there are other precautions we can take.
One way to ensure that our plugin filenames are unlikely to conflict with others is to subprefix them with a name that’s unique to us or our organization.
For example, all of the plugins developed in this book use the filename prefix “jquery.jqia” (jqia being short for jQuery in Action) to help make sure that they won’t conflict with anyone else’s plugin filenames, should anyone wish to use them in their own web applications.
Likewise, the files for the jQuery Form Plugin begin with the prefix “jquery.form”
Not all plugins follow this convention, but as the number of plugins increases, it will become more and more important to follow such conventions.
Similar considerations need to be taken with the names we give to our functions, whether they’re new utility functions or methods on the jQuery wrappers.
When creating plugins for our own use, we’re usually aware of what other plugins we’ll use; it’s an easy matter to avoid any naming collisions.
But what if we’re creating our plugins for public consumption? Or what if our plugins, which we initially intended to use privately, turn out to be so useful that we want to share them with the rest of the community?
Once again, familiarity with the plugins that already exist will go a long way in avoiding API collisions, but we also encourage gathering collections of related functions under a common prefix (similar to the proposal for filenames) to avoid cluttering the namespace.
But when writing plugins that may end up in other people’s pages, we can’t be quite so cavalier.
We can now happily use $ to our heart’s content in the definition of the plugin.
Before we dive into learning how to add new elements to jQuery, let’s look at one.
Most plugins tend to be simple affairs that require few, if any, parameters.
We’ve seen ample evidence of this in the vast majority of the core jQuery methods and functions, which either take a small handful of parameters or none at all.
Intelligent defaults are supplied when optional parameters are omitted, and parameter order can even take on a different meaning when some optional parameters are omitted.
The bind() method is a good example; if the optional data parameter is omitted, the listener function, which is normally specified as the third parameter, can be supplied as the second.
The dynamic and interpretive nature of JavaScript allows us to write such flexible code, but this sort of thing can start to break down and get complex (both for web developers and ourselves as plugin authors) when the number of parameters grows larger.
The possibility of a breakdown increases when many of the parameters are optional.
Consider a somewhat complex function whose signature is as follows:
This function accepts seven arguments, and let’s say that all but the first are optional.
There are too many optional arguments to make any intelligent guesses about the intention of the caller when optional parameters are omitted.
If a caller of this function is only omitting trailing parameters, this isn’t much of a problem, because the optional trailing arguments can be detected as nulls.
Web developers using this function are forced to carefully keep track of counting nulls and the order of the parameters; plus, the code is difficult to read and understand.
But short of not allowing the caller so many options, what can we do? Again, the flexible nature of JavaScript comes to the rescue; a pattern that allows.
Using this pattern, optional parameters are gathered into a single parameter in the guise of a JavaScript Object instance, whose property name/value pairs serve as the optional parameters.
Using this technique, our first example could be written as.
Much better! We don’t have to account for omitted parameters with placeholder nulls, and we.
Neither approach is deemed more correct than the other, so choose whichever best suits your code.
Although this is obviously a great advantage to the caller of our complex functions, what about the ramifications for us as the plugin authors? As it turns out, we’ve already seen a jQuery-supplied mechanism that makes it easy for us to gather these optional parameters together and merge them with default values.
Let’s reconsider our complex example function with a required parameter and six options.
By merging the values passed by the web developer in the options parameter with an object containing all the available options with their default values, the settings variable ends up with the default values superseded by any explicit values specified by the web developer.
That would cut down on one reference on the stack, but let’s keep on the side of clarity for the moment.
Easy, versatile, and caller-friendly! We’ll see examples of this pattern in use later in this chapter and in jQuery functions that will be introduced in chapter 8, but, for now, let’s look at how we extend jQuery with our own utility functions.
In this book, we use the term utility function to describe functions defined as properties of jQuery (and therefore $)
These functions aren’t intended to operate on DOM elements—that’s the job of methods defined to operate on a jQuery wrapped set—but to either operate on non-element JavaScript objects or perform some other operation that doesn’t specifically operate on any objects.
In this section, we’ll learn how to add our own similar functions.
Adding a function as a property to an Object instance is as easy as declaring the.
If this seems like black magic to you, and you have not yet read through the appendix, now would be a good time to do so.
Creating a trivial custom utility function should be as easy as.
Get thee to the appendix if the concept of a method of a function makes your head hurt.
This isn’t a problem for a private function that we know will never be shared, but even then, what if some future changes to the pages reassign the $? It’s a good idea to err on the side of caution.
This seems like an easy way out, but it proves to be less than optimal for more complex functions.
What if the function body utilizes lots of jQuery methods and functions internally to get its job done? We’d need to use jQuery rather than $ throughout the function.
That’s rather wordy and inelegant; besides, once we use the $, we don’t want to let it go!
So looking back to the idiom we introduced in section 7.2.2, we can safely write our function as follows:
Should the function ever need to become more complex, we could extend and modify it without wondering whether it’s safe to use the $ or not.
With this pattern fresh in our minds, let’s implement a nontrivial utility function of our own.
Often, when emitting fixed-width output, it’s necessary to take a numeric value and format it to fit into a fixed-width field (where width is defined as the number of characters)
Usually such operations will right-justify the value within the fixed-width field and prefix the value with enough fill characters to make up any difference between the length of the value and the length of the field.
Let’s write such a utility function with the following syntax:
The implementation of this function is shown in listing 7.1
The passed value is converted to its string equivalent, and the fill character is determined either from the passed value or the default of 0 B.
If the numeric value exceeds the specified length, its higher order digits will be truncated to fit the length.
If we end up with negative padding (the result is longer than the passed field length), we truncate from the beginning of the result to end up with the specified length D; otherwise, we pad the beginning of the result with the appropriate number of fill characters E prior to returning it as the result of the function F.
Simple stuff, but it serves to show how easily we can add a utility function.
As with most examples in books, the error checking is minimal because we’re focusing on the lesson at hand.
How would you beef up the function to account for caller errors such as not passing numeric values for value and length? What if they don’t pass them at all?
We were careful to truncate numeric values that were too long, in order to guarantee that the result was always the specified length.
But if the caller passes more than a single-character string for the fill character, all bets are off.
Now, let’s tackle a more complex function in which we can make use of the $.toFixedWidth() function that we just wrote.
If you’ve come to the world of client-side programming from the server, one of the things you may have longed for is a simple date formatter; something that the JavaScript Date type doesn’t provide.
Because such a function would operate on a Date instance, rather than any DOM element, it’s a perfect candidate for a utility function.
Namespacing utility functions If you want to make sure that your utility functions aren’t going to conflict with anybody else’s, you can namespace the functions by creating a namespace object on $ that, in turn, serves as the owner of your functions.
For example, if we wanted to namespace all our date formatter functions under a namespace called jQiaDateFormatter, we’d do the following:
This ensures that functions like toFixedWidth() can never conflict with another similarly named function.
Of course, we still need to worry about conflicting namespaces, but that’s easier to deal with.
The implementation of this function is shown in listing 7.2
We’re not going to go into great detail regarding the algorithm used to perform the formatting (after all, this isn’t an algorithms book), but we’ll use this implementation to point out some interesting tactics that we can use when creating a somewhat complex utility function.
The most interesting aspect of this implementation, aside from a few JavaScript tricks used to keep the amount of code in check, is that the function B needs some ancillary data to do its job.
We could have included each of these as var definitions within the function body, but that would clutter an already somewhat involved algorithm, and because they’re constants, it makes sense to segregate them from variable data.
We don’t want to pollute the global namespace, or even the $ namespace, with a bunch of names needed only by this function, so we make these declarations properties of our new function itself.
Remember, JavaScript functions are first-class objects, and they can have their own properties like any other JavaScript object.
As for the formatting algorithm itself? In a nutshell, it operates as follows:
This value is pushed onto the end of the results array, and the matched token is removed from the beginning of the pattern.
Removes the first character from the pattern and adds it to the end of the results array if a token isn’t matched at the current beginning of the pattern.
Joins the results array into a string and returns it as the value of the function when the entire pattern has been consumed.
Operating on run-of-the-mill JavaScript objects is all well and good, but the real power of jQuery lies in the wrapper methods that operate on a set of DOM elements collected via the power of jQuery selectors.
Next, let’s see how we can add our own powerful wrapper methods.
The true power of jQuery lies in the ability to easily and quickly select and operate on DOM elements.
Luckily, we can extend that power by adding wrapper methods of our own that manipulate selected DOM elements as we deem appropriate.
By adding wrapper methods, we automatically gain the use of the powerful jQuery selectors to pick and choose which elements are to be operated on without having to do all the work ourselves.
Given what we know about JavaScript, we probably could have figured out on our own how to add utility functions to the $ namespace, but that’s not necessarily true of wrapper functions.
There’s a tidbit of jQuery-specific information that we need to know: to add wrapper methods to jQuery, we must assign them as properties to an object named fn in the $ namespace.
Let’s concoct a trivial wrapper method to set the color of the matched DOM elements to blue:
As with utility functions, we make the declaration within an outer function that guarantees that $ is an alias to jQuery.
Within the body of the method, the function context (this) refers to the wrapped set.
We can use all of the predefined jQuery methods on it; in this example, we call the css() method on the wrapped set to set the color to blue for all matched DOM elements.
You must take care when using this under such circumstances to make sure that it’s referring to what you think it is! For example, if you use the each() jQuery method with its iterator function, this within the iterator function references the DOM element for the current iteration.
We can do almost anything we like to the DOM elements in the wrapped set, but there is one very important rule when defining new wrapper methods: unless the function is intended to return a specific value, it should always return the wrapped set as its return value.
This allows our new method to take part in any jQuery method chains.
In our example, because the css() method returns the wrapped set, we simply return the result of the call to css()
In the previous example, we applied the jQuery css() method to all the elements in the wrapped set by applying it to this.
If, for some reason, we need to deal with each wrapped element individually (perhaps because we need to make conditional processing decisions), the following pattern can be used:
In this pattern, the each() method is used to iterate over every individual element in the wrapped set.
Note that, within the iterator function, this refers to the current DOM element rather than the entire wrapped set.
The wrapped set returned by each() is returned as the new method’s value so that this method can participate in chaining.
In this variation, we want to apply the color blue or the color red based upon a condition that’s unique to each element (in this case, whether it has an id attribute or not), so we iterate over the wrapped set so that we can examine and manipulate each element individually.
That’s all there is to it, but (isn’t there always a but?) there are some techniques we should be aware of when creating more involved jQuery wrapper methods.
Let’s define a couple more plugin methods of greater complexity to examine those techniques.
Let’s develop another new plugin method that performs more than a single operation on the wrapped set.
Imagine that we need to be able to flip the read-only status of text fields within a form and to simultaneously and consistently affect the appearance of the field.
We could easily chain a couple of existing jQuery methods together to do this, but we want to be neat and tidy about it and bundle these operations together into a single method.
We’ll name our new method setReadOnly(), and its syntax is as follows:
Iteration via methods that accept functions for values Note that the “blue or red” example is a tad contrived to show how each() can be used to traverse the individual elements in the wrapped set.
Because the css() method accepts a function for its value (which automatically iterates over the elements), the astute among you might have noted that this custom method could also have been written without each() as follows:
This is a common idiom across the jQuery API; when a function can be passed in place of a value, the function is invoked in an iterative fashion over the elements of the wrapped set.
The variant of the example using each() is illustrative of cases where there’s no such automatic iteration of elements.
This example is only slightly more complicated than our initial example, but it exhibits the following key concepts:
How might we put this method to use? Often, when defining an online order form, we may need to allow the user to enter.
Much more often than not, these two addresses are going to be the same, and making the user enter the same information twice decreases our user-friendliness factor to less than we’d want it to be.
We could write our server-side code to assume that the billing address is the same as the shipping address if the form is left blank, but let’s assume that our product manager is a bit paranoid and would like something more overt on the part of the user.
We’ll satisfy him by adding a checkbox to the billing address that indicates whether the billing address is the same as the shipping address.
Any elements in the wrapped set other than text fields are ignored.
Unchecking the box will clear the value and read-only status from the fields.
Listing 7.4 Implementation of the test page for the setReadOnly() wrapper method.
Figure 7.1a Our form for testing the setReadOnly() custom wrapper method before checking the checkbox.
We won’t belabor the operation of this page, as it’s relatively straightforward.
The only truly interesting aspect of this page is the click handler attached to the checkbox in the ready handler.
When the state of the checkbox is changed by a click, we do three things:
Copy the checked state into the variable same for easy reference in the remainder of the listener.
If they’re to be the same, we set the values from the corresponding fields in the shipping address information.
Call the new setReadOnly() method on all input fields in the billing address container.
But, oops! We were a little sloppy with that last step.
The wrapped set that we create with $('#billingAddress input') contains not only the text fields in the billing address block but the checkbox too.
The checkbox element doesn’t have read-only semantics, but it can have its opacity changed—definitely not our intention!
Luckily, this sloppiness is countered by the fact that we were not sloppy when defining our plugin.
Recall that we filtered out all but text fields before applying the remainder of the methods in that method.
We highly recommend such attention to detail, particularly for plugins that are intended for public consumption.
What are some ways that this method could be improved? Consider making the following changes:
We forgot about text areas! How would you modify the code to include text areas along with the text fields?
The opacity levels applied to the fields in either state are hard-coded into the function.
Modify the method to allow the levels to be caller-supplied.
Oh heck, why force the web developer to accept the ability to affect only the opacity? How would you modify the method to allow the developer to determine what the renditions for the fields should be in either state?
For our more complex plugin example, we’re going to develop a jQuery method that will easily allow a web developer to whip up a quick slideshow page.
We’ll create a jQuery plugin, which we’ll name Photomatic, and then we’ll whip up a test page to put it through its paces.
When complete, this test page will appear as shown in figure 7.2
We also want to grant web developers as much freedom for layout and styling as possible; we’ll define our plugin so that developers can set up the elements in any manner they like and then tell us which page element should be used for each purpose.
Furthermore, in order to give web developers as much leeway as possible, we’ll define our plugin so that they can provide any wrapped set of images to serve as thumbnails.
Usually, thumbnails will be gathered together as in our test page, but developers are free to identify any image on the page as a thumbnail.
To start, let’s introduce the syntax for the Photomatic plugin.
Because we have a nontrivial number of parameters for controlling the operation of Photomatic (many of which can be omitted), we utilize an object hash to pass them, as was discussed in section 7.2.3
The possible options that we can specify are shown in table 7.1
Parameters options (Object) An object hash that specifies the options for Photomatic.
Table 7.1 The options for the Photomatic custom plugin method.
With a nod to the notion of test-driven development, let’s create the test page for this plugin before we dive into creating the Photomatic plugin itself.
If omitted, the default transformation substitutes all instances of thumbnail with photo in the URL.
Table 7.1 The options for the Photomatic custom plugin method (continued)
If that looks simpler than you thought it would, you shouldn’t be surprised.
By applying the principles of Unobtrusive JavaScript and by keeping all style information in an external style sheet, our markup is tidy and simple.
In fact, even the on-page script has a tiny footprint, consisting of a single statement that invokes our plugin B.
The HTML markup consists of a container that holds the thumbnail images C, an image element (initially sourceless) to hold the full-sized photo D, and a collection of images E that will control the slideshow.
To start, let’s set out a skeleton (we’ll fill in the details as we go along)
This defines our initially empty wrapper function, which (as expected from our syntax description) accepts a single hash parameter named options.
First, within the body of the function, we merge these caller settings with the default settings described in table 7.1
This will give us a single settings object that we can refer to throughout the remainder of the method.
We perform this merge operation using the following idiom (which we’ve already seen a few times):
We’re also going to need to keep track of a few things.
In order for our plugin to know what concepts like next relative image and previous relative image mean, we need not only an ordered list of the thumbnail images, but also an indicator that identifies the current image being displayed.
The list of thumbnail images is the wrapped set that this method is operating on—or, at least, it should be.
We don’t know what the developers collected in the wrapped set, so we want to filter it down to only image elements, which we can easily do with a jQuery selector.
We could easily create another variable to hold it, but there’s a lot to be said for keeping things corralled.
Let’s store the list as another property on settings, as follows:
Another piece of state that we need to keep track of is the current image.
We’ll do that by maintaining an index into the list of thumbnails by adding another property to settings named current:
There is one more setup step that we need to take with regard to the thumbnails.
If we’re going to keep track of which photo is current by keeping track of its index, there will be at least one case (which we’ll be examining shortly) where, given a reference to a thumbnail element, we’ll need to know its index.
The easiest way to handle this is to anticipate this need and use the handy jQuery data() method to record a thumbnail’s index on each of the thumbnail elements.
This statement iterates through each of the thumbnail images, adding a data element named photomatic-index to it that records its order in the list.
Wait a minute! Initial state? How can we expect to keep track of state in a local variable within a function that’s about to finish executing? Won’t the variable and all our settings go out of scope when the function returns?
In general, that might be true, but there is one case where such a variable sticks around for longer than its usual scope—when it’s part of a closure.
We’ve seen closures before, but if you’re still shaky on them, please review the appendix.
You must understand closures not only for completing the implementation of the Photomatic plugin but also when creating anything but the most trivial of plugins.
When we think about the job remaining, we realize that we need to attach a number of event listeners to the controls and elements that we’ve taken such great pains to identify to this point.
And because the settings variable is in scope when we declare the functions that represent those listeners, each listener will be part of a closure that includes the settings variable.
So we can rest assured that, even though settings may appear to be transient, the state that it represents will stick around and be available to all the listeners that we define.
Speaking of those listeners, here’s a list of click event listeners that we’ll need to attach to the various elements:
Looking over this list, we immediately note that all of these listeners have something in common: they all need to cause the full-sized photo of one of the thumbnail images to be displayed.
And being the good and clever coders that we are, we want to factor out that common processing into a function so that we don’t need to repeat the same code over and over again.
But how? If we were writing normal on-page JavaScript, we could define a top-level function.
If we were writing object-oriented JavaScript, we might define a method on a JavaScript object.
We don’t want to infringe on either the global namespace, or even the $ namespace, for a function that should only be called internally from our plugin code, so what can we do? Oh, and just to add to our dilemma, let’s try to make it so that the function participates in a closure including the settings variable so that we won’t have to pass it as a parameter to each invocation.
The power of JavaScript as a functional language comes to our aid once again, and allows us to define this new function within the plugin function.
By doing so, we limit its scope to within the plugin function itself (one of our goals), and because the settings variable is within scope, it forms a closure with the new function (our other goal)
So we define a function named showPhoto(), which accepts a single parameter indicating the index of the thumbnail that’s to be shown full-sized, within the plugin function, as follows:
This new function, when passed the index of the thumbnail whose full-sized photo is to be displayed, uses the values in the settings object (available via the closure created by the function declaration) to do the following:
Look up the src attribute of the thumbnail identified by index.
Pass that value through the transformer function to convert it from a thumbnail URL to a photo URL.
Assign the result of the transformation to the src attribute of the full-sized image element.
Record the index of the displayed photo as the new current index.
With that handy function available, we’re ready to define the listeners that we listed earlier.
Let’s start by instrumenting the thumbnails themselves, which simply need to cause their corresponding full-size photo to be displayed.
In this handler, we obtain the value of the thumbnail’s index (which we thoughtfully already stored in the photomatic-index data element), and call the showPhoto() function using it.
The simplicity of this handler verifies that all the setup we coded earlier is going to pay off!
Instrumenting the photo display element to show the next photo in the list is just as simple:
We add a thoughtful title attribute to the photo so users know that clicking on the photo will progress to the next one, and we set the cursor to indicate that the element is clickable.
We then establish a click handler, in which we call the showPhoto() function with the next index value—note how we use the JavaScript modulo operator (%) to wrap around to the front of the list when we fall off the end.
The handlers for the First, Previous, Next, and Last controls all follow a similar pattern: figure out the appropriate index of the thumbnail whose full-sized photo is to be shown, and call showPhoto() with that index:
The instrumentation of the Play control is somewhat more complicated.
Rather than showing a particular photo, this control must start a progression through the entire photo set, and then stop that progression on a subsequent click.
Let’s take a look at the code we use to accomplish that:
First, note that we use the jQuery toggle() method to easily swap between two different listeners on every other click of the control.
That saves us from having to figure out on our own whether we’re starting or stopping the slideshow.
We store the handle of that interval timer in the settings variable for later reference.
We also add the class photomatic-playing to the control so that the web developer can effect any appearance changes using CSS, if desired.
As the last act in the handler, we emulate a click on the Next control to progress to the next photo immediately (rather than having to wait for the first interval to expire)
In the second handler of the toggle() invocation, we want to stop the slideshow, so we clear the interval timeout using clearInterval() and remove the photomaticplaying class from the control.
We have two final tasks before we can declare success: we need to display the first.
This plugin is typical of jQuery-enabled code; it packs a big wallop in some compact code.
But it serves to demonstrate an important set of techniques—using closures to maintain state across the scope of a jQuery plugin and to enable the creation of private implementation functions that plugins can define and use without resorting to any namespace infringements.
Also note that because we took such care to not let state “leak out” of the plugin, we’re free to add as many Photomatic widgets to a page as we like, without fear that they will interfere with one another (taking care, of course, to make sure we don’t use duplicate id values in the markup)
But is it complete? You be the judge and consider the following exercises:
How would you go about making the plugin as bulletproof as possible?
Leveraging your knowledge from chapter 5, change the plugin so that photos cross-fade to one another.
Going one step further, how would you go about allowing the developer to use a custom animation of his or her choice?
For maximum flexibility, we coded this plugin to instrument HTML elements already created by the user.
How would you create an analogous plugin, but with less display freedom, that generated all the required HTML elements on the fly?
You’re now primed and ready to write your own jQuery plugins.
When you come up with some useful ones, consider sharing them with the rest of the jQuery community.
This chapter introduced us to writing reusable code that extends jQuery.
Writing our own code as extensions to jQuery has a number of advantages.
Not only does it keep our code consistent across our web application regardless of whether it’s employing jQuery APIs or our own, but it also makes all of the power of jQuery available to our own code.
Following a few naming rules helps avoid naming collisions between filenames, as well as problems that might be encountered when the $ name is reassigned by a page that will use our plugin.
If plugin authoring intrigues you, we highly recommend that you download and comb through the code of existing plugins to see how their authors implemented their own features.
You’ll see how the techniques presented in this chapter are used in a wide range of code, and you’ll learn new techniques that are beyond the scope of this book.
Having yet more jQuery knowledge at our disposal, let’s move on to learning how jQuery makes incorporating Ajax into our interactive applications practically a nobrainer.
It can be successfully argued that no single technology shift has transformed the landscape of the web more than Ajax.
The ability to make asynchronous requests back to the server without the need to reload entire pages has enabled a whole new set of user-interaction paradigms and made DOM-scripted applications possible.
Ajax is a less recent addition to the web toolbox than many people may realize.
Although OWA was a moderate success, few people seemed to take notice of the underlying technology.
A few years passed, and a handful of events launched Ajax into the collective consciousness of the web development community.
The non-Microsoft browsers implemented a standardized version of the technology as the XMLHttpRequest (XHR) object; Google began using XHR; and, in 2005, Jesse James Garrett of Adaptive Path coined the term Ajax (for Asynchronous JavaScript and XML)
As if they were only waiting for the technologies to be given a catchy name, the web development masses suddenly took note of Ajax in a big way, and it has become one of the primary tools by which we can enable DOM-scripted applications.
In this chapter, we’ll take a brief tour of Ajax (if you’re already an Ajax guru, you might want to skip ahead to section 8.2), and then we’ll look at how jQuery makes using Ajax a snap.
Let’s start off with a refresher on what Ajax technology is all about.
Although we’ll take a quick look at Ajax in this section, please note that this isn’t intended as a complete Ajax tutorial or an Ajax primer.
If you’re completely unfamiliar with Ajax (or worse, think that we’re talking about a dishwashing liquid or a mythological Greek hero), we encourage you to familiarize yourself with the technology through resources that are geared toward teaching you all about Ajax; the Manning books Ajax in Action and Ajax in Practice are both excellent examples.
Some people may argue that the term Ajax applies to any method of making server requests without the need to refresh the user-facing page (such as by submitting a request to a hidden <iframe> element), but most people associate the term with the use of XMLHttpRequest (XHR) or the Microsoft XMLHTTP ActiveX control.
A diagram of the overall process, which we’ll examine one step at a time, is shown in figure 8.1
Let’s take a look at how those objects are used to generate requests to the server, beginning with creating an XHR instance.
In a perfect world, code written for one browser would work in all commonly used browsers.
We’ve already learned that we don’t live in that world, and things are no different when it comes to Ajax.
There is a standard way to make asynchronous requests via the JavaScript XHR object, and an Internet Explorer proprietary way that uses an ActiveX control.
This is good news for us! By using jQuery for our Ajax needs, we know that the best approaches have been researched and will be utilized.
The problem is that different browsers implement XHR in different ways, and we need to create the instance in the manner appropriate for the current browser.
Using this technique, we try to figure out what the browser’s features are, not which browser is being used.
Feature detection results in more robust code because it can work in any browser that supports the tested feature.
The code in listing 8.1 shows a typical idiom used to instantiate an instance of XHR using this technique.
After it’s created, the XHR instance sports a conveniently consistent set of properties and methods across all supporting browser instances.
These properties and methods are shown in table 8.1, and the most commonly used of these will be discussed in the sections that follow.
Listing 8.1 Capability detection resulting in code that can use Ajax in many browsers.
Now that we’ve got an XHR instance created, let’s look at what it takes to set up and fire off the request to the server.
Sets the HTTP method (GET or POST) and destination URL of the request.
Optionally, the request can be declared synchronous, and a username and password can be supplied for requests requiring container-based authentication.
See the HTTP specificationa for the full set of codes.
Before we can send a request to the server, we need to perform the following setup steps:
We set up the first two items by calling the open() method of XHR as follows:
In the third step, we must provide a means for the XHR instance to tap us on the shoulder to let us know what’s going on.
We accomplish this by assigning a callback function to the onreadystatechange property of the XHR object.
This function, known as the ready state handler, is invoked by the XHR instance at various stages of its processing.
By looking at the settings of the other properties of XHR, we can find out exactly what’s going on with the request.
We’ll take a look at how a typical ready state handler operates in the next section.
The final steps to initiating the request are to provide any body content for POST requests and send it off to the server.
Both of these steps are accomplished via the send() method.
For GET requests, which typically have no body, no body content parameter is passed, as follows:
When request parameters are passed to POST requests, the string passed to the send() method must be in the proper format (which we might think of as query string format) in which the names and values are properly URI encoded.
Now let’s see what the ready state handler is all about.
An XHR instance informs us of its progress through the ready state handler.
This handler is established by assigning a reference to the function to serve as the ready handler to the onreadystatechange property of the XHR instance.
Once the request is initiated via the send() method, this callback will be invoked numerous times as the request makes transitions through its various states.
The current state of the request is available as a numeric code in the readyState property (see the description of this property in table 8.1)
That’s nice, but more times than not, we’re only interested in when the request completes and whether it was successful or not.
Frequently we’ll see ready handlers implemented using the idiom shown in listing 8.2
This code ignores all but the DONE state, and once that has been detected, examines the value of the status property to determine whether the request succeeded or not.
Now let’s explore dealing with the response from a completed request.
Once the ready handler has determined that the readyState is complete and that the request completed successfully, the body of the response can be retrieved from the XHR instance.
Despite the moniker Ajax (where the X stands for XML), the format of the response body can be any text format; it’s not limited to XML.
In fact, most of the time, the response to Ajax requests is a format other than XML.
It could be plain text or, perhaps, an HTML fragment; it could even be a text representation of a JavaScript object or array in JavaScript Object Notation (JSON) format (which is becoming increasingly popular as an exchange format)
Regardless of its format, the body of the response is available via the responseText property of the XHR instance (assuming that the request completes successfully)
If the response indicates that the format of its body is XML by including a content type header specifying a MIME type of text/xml, application/xml, or a MIME type that ends with +xml, the response body will be parsed as XML.
Listing 8.2 Ready state handlers are often written to ignore all but the DONE state.
JavaScript (and jQuery itself, using its selector API) can then be used to process the XML DOM.
Processing XML on the client isn’t rocket science, but—even with jQuery’s help—it can still be a pain.
Although there are times when nothing but XML will do for returning complex hierarchical data, frequently page authors will use other formats when the full power (and corresponding headache) of XML isn’t absolutely necessary.
But some of those other formats aren’t without their own pain.
When JSON is returned, it must be converted into its runtime equivalent.
When HTML is returned, it must be loaded into the appropriate destination element.
And what if the HTML markup returned contains <script> blocks that need evaluation? We’re not going to deal with these issues in this section because it isn’t meant to be a complete Ajax reference and, more importantly, because we’re going to find out that jQuery handles most of these issues on our behalf.
At this point, you might want to review the diagram of the whole process shown in figure 8.1
In this short overview of Ajax, we’ve identified the following pain points that page authors using Ajax need to deal with:
The remainder of this chapter will describe how the jQuery Ajax methods and utility functions make Ajax a lot easier (and cleaner) to use on our pages.
There are a lot of choices in the jQuery Ajax API, and we’ll start with some of the simplest and mostused tools.
Perhaps one of the most common uses of Ajax is to grab a chunk of content from the server and stuff it into the DOM at some strategic location.
The content could be an HTML fragment that’s to become the child content of a target container element, or it could be plain text that will become the content of the target element.
Setting up for the examples Unlike all of the example code that we’ve examined so far in this book, the code examples for this chapter require the services of a web server to receive the Ajax requests to server-side resources.
Because it’s well beyond the scope of this book to discuss the operation of server-side mechanisms, we’re going to set up some minimal server-side resources that send data back to the client without worrying about doing it for real, treating the server as a “black box”; we don’t need or want to know how it’s doing its job.
To enable the serving of these smoke-and-mirrors resources, you’ll need to set up a web server of some type.
Let’s imagine that, on page load, we want to grab a chunk of HTML from the server using a resource named someResource, and make it the content of a <div> element with an id of someContainer.
For the final time in this chapter, let’s look at how we’d do this without jQuery’s assistance.
Using the patterns we set out earlier in this chapter, the body of the onload handler is as shown in listing 8.3
Omit the port specification of :8080 if using Apache, and leave it in if using Tomcat.
In future URLs in this chapter we’ll use the notation [:8080] to indicate that the port number might or might not be needed, but be sure not to include the square brackets as part of the URL.
Listing 8.3 Using native XHR to fetch and include an HTML fragment.
The JSP resources can be used if you’re running (or wish to run) a servlet/JSP engine; if you want to enable PHP for your web server of choice, you can use the PHP resources.
If you want to use the JSP resources but aren’t already running a suitable server, instructions on setting up the free Tomcat web server are included with the sample code for this chapter.
And don’t be concerned; even if you’ve never looked at a single line of Java, it’s easier than you might think!
The examples found in the downloaded code are set up to use either of the JSP or PHP resources, depending upon which server you have set up.
The latter assumes that you have set up your web server (Apache or any other you have chosen) to use the example code root folder as a document base.
When you can successfully view the appropriate test page, you’ll be ready to run the examples in this chapter.
Alternatively, if you don’t want to run these examples locally, you can run the example code remotely from http://bibeault.org/jqia2
Although there’s nothing tricky going on here, that’s a non-trivial amount of code; 20 lines, without even counting the blank lines that we added for readability.
The equivalent code we’d write as the body of a ready handler using jQuery is as follows:
We’re betting that we know which code you’d rather write and maintain! Let’s take a close look at the jQuery method we used in this statement.
The simple jQuery statement at the end of the previous section easily loads content from the server-side resource using one of the most basic, but useful, jQuery Ajax methods: load()
The full syntax description of this method is as follows:
A callback function can be specified that’s invoked when the request completes and the DOM has been modified.
The response text replaces the content of all matched elements.
This argument can be a string that will be used as the query string, an object whose properties are serialized into properly encoded parameters to be passed to the request, or an array of objects whose name and value properties specify the name/value pairs.
If specified as an object or array, the request is made using the POST method.
If omitted or specified as a string, the GET method is used.
The parameters passed to this function are the response text, a status string (usually “success”), and the XHR instance.
This function will be invoked once for each element in the wrapped set with the target element set as the function context (this)
Though simple to use, this method has some important nuances.
For example, when the parameters parameter is used to supply the request parameters, the request is made using the POST HTTP method if an object hash or array is used; otherwise, a GET request is initiated.
If we want to make a GET request with parameters, we can include them as a query string on the URL.
But be aware that when we do so, we’re responsible for ensuring that the query string is properly formatted and that the names and values of the request parameters are URI-encoded.
Most of the time, we’ll use the load() method to inject the complete response into whatever elements are contained within the wrapped set, but sometimes we may want to filter elements coming back as the response.
If we want to filter response elements, jQuery allows us to specify a selector on the URL that will be used to limit which response elements are injected into the wrapped elements.
We specify the selector by suffixing the URL with a space followed by the selector.
For example, to filter response elements so that only <div> instances are injected, we write.
When it comes to supplying the data to be submitted with a request, sometimes we’ll be winging it with ad hoc data, but frequently we’ll find ourselves wanting to gather data that a user has entered into form controls.
As you might expect, jQuery’s got some assistance up its sleeve.
If the data that we want to send as request parameters come from form controls, a helpful jQuery method for building a query string is serialize(), whose syntax is as follows:
The serialize() method is smart enough to only collect information from form control elements in the wrapped set, and only from those qualifying elements that are deemed successful.
A successful control is one that would be included as part of a form submission according to the rules of the HTML specification.1 Controls such as unchecked checkboxes and radio buttons, dropdowns with no selections, and disMethod syntax: serialize.
Loading content into elements abled controls aren’t considered successful and don’t participate in form submission, so they’re also ignored by serialize()
If we’d rather get the form data in a JavaScript array (as opposed to a query string), jQuery provides the serializeArray() method.
The array returned by serializeArray() is composed of anonymous object instances, each of which contains a name property and a value property that contain the name and value of each successful form control.
Note that this is (not accidentally) one of the formats suitable for passing to the load() method to specify the request parameter data.
With the load() method at our disposal, let’s put it to work solving some common real-world problems that many web developers encounter.
Often in business applications, particularly for commerce web sites, we want to grab real-time data from the server in order to present our users with the most up-to-date information.
After all, we wouldn’t want to mislead customers into thinking that they can buy something that’s not available, would we? In this section, we’ll begin to develop a page that we’ll add to throughout the course of the chapter.
This page is part of a web site for a fictitious firm named The Boot Closet, an online retailer of overstock and closeout motorcycle boots.
Unlike the fixed product catalogs of other online retailers, this inventory of overstock and closeouts is fluid, depending on what deals the proprietor was able to make that day and what’s already been sold from the inventory.
It will be important for us to always make sure that we’re displaying the latest info!
To begin our page (which will omit site navigation and other boilerplate to concentrate on the lessons at hand), we want to present our customers with a dropdown containing the styles that are currently available and, when a style is selected, display detailed information regarding that style.
On initial display, the page will look as shown in figure 8.2
After the page first loads, a dropdown with the list of styles currently available in the inventory is displayed.
When no style is selected, we’ll display a helpful message as a placeholder for the selection: “— choose a style —”
This invites the user to interact with the dropdown, and when a user selects a boot style from this dropdown, here’s what we want to do:
Remove the “— choose a style —” entry; once the user picks a style, it’s served its purpose and is no longer meaningful.
Let’s start by taking a look at the HTML markup for the body that defines this page structure:
Not much to it, is there? As would be expected, we’ve defined all the visual rendition information in an.
The most interesting parts of this markup are a container B that holds the <select> element that will allow customers to choose a boot style, and another container C into which product details will be injected.
Note that the boot style control needs to have its option elements added before the user can interact with the page.
So let’s set about adding the necessary behavior to this page.
Figure 8.2 The initial display of our commerce page with a simple dropdown inviting customers to click on it.
The first thing we’ll add is an Ajax request to fetch and populate the boot style dropdown.
But there are circumstances where prefetching data via Ajax may be appropriate, and we’re doing that here, if only for instructional purposes.
To add the options to the boot style control, we define a ready handler, and within it we make use of the handy load() method:
One of the nice things about using Ajax (with the ease of jQuery making it even nicer) is that it’s completely independent of the server-side technology.
Obviously the choice of server-side tech has an influence on the structure of the URLs, but beyond that we don’t need to worry ourselves much about what’s going to transpire on the server.
We simply make HTTP requests, sometimes with appropriate parameter data, and as long as the server returns the expected responses, we could care less if the server is being powered by Java, Ruby, PHP, or even old-fashioned CGI.
In this particular case, we expect that the server-side resource will return the HTML markup representing the boot style options—supposedly from the inventory database.
Our faux backend code returns the following as the response:
This response then gets injected into the <select> element, resulting in a fully functional control.
Our next act is to instrument the dropdown so that it can react to changes, carrying out the duties that we listed earlier.
In this code, we select the boot style dropdown and bind a change handler to it B.
In the callback for the change handler, which will be invoked whenever a customer changes the selection, we obtain the current value of the selection by applying the val() method to the event target, which is the <select> element that triggered the event.
After the customer chooses an available boot style, the page will appear as shown in figure 8.3
The most notable operation performed in the ready handler is the use of the load() method to quickly and easily fetch snippets of HTML from the server and place them within the DOM as the children of existing elements.
This method is extremely handy and well suited to web applications that are powered by servers capable of server-side templating with technologies such as JSP and PHP.
Figure 8.3 The server-side resource returns a preformatted fragment of HTML to display the detailed boot information.
We’ll be revisiting this page to add further capabilities to it as we progress through this chapter.
The load() method is tremendously useful when we want to grab a fragment of HTML to stuff into the content of an element (or set of elements)
But there may be times when we either want more control over how the Ajax request gets made, or we need to do something more esoteric with the returned data in the response body.
Let’s continue our investigation of what jQuery has to offer for these more complex situations.
The load() method makes either a GET or a POST request, depending on how the request parameter data (if any) is provided, but sometimes we want to have a bit more control over which HTTP method gets used.
Why should we care? Because, just maybe, our servers care.
Web authors have traditionally played fast and loose with the GET and POST methods, using one or the other without heeding how the HTTP protocol intends for these methods to be used.
A GET request should, therefore, be used whenever the purpose of the request is to merely get data; as its name implies.
It may be required to send some parameter data to the server for the GET; for example, to identify a style number to retrieve color information.
But when data is being sent to the server in order to effect a change, POST should be used.
Browsers make decisions about caching based upon the HTTP method used, and GET requests are highly subject to caching.
Using the proper HTTP method ensures that you don’t get crossways with the browser’s or server’s expectations regarding the intentions of the requests.
This is just a glimpse into the realm of RESTful principles, where other HTTP methods, such as PUT and DELETE, also come into play.
But for our purposes, we’ll limit our discussion to the GET and POST methods.
With that in mind, if we look back to our phase one implementation of The Boot Closet (in listing 8.4), we discover that we’re doing it wrong! Because jQuery initiates a POST request when we supply an object hash for parameter data, we’re making a POST when we really should be making a GET.
If we glance at a Firebug log (as shown in figure 8.4) when we display our page in Firefox, we can see that our second request, submitted when we make a selection from the style dropdown, is indeed a POST.
Does it really matter? That’s up to you, but if we want to use HTTP in the manner in which it was intended, our request to fetch the boot detail should be a GET rather than a POST.
We could simply make the parameter that specifies the request information a string rather than an object hash (and we’ll revisit that a little later), but for now, let’s take advantage of another way that jQuery lets us initiate Ajax requests.
Figure 8.4 An inspection of the Firebug console shows that we’re making a POST request when we should be making a GET.
Get Firebug Trying to develop a DOM-scripted application without the aid of a debugging tool is like trying to play concert piano while wearing welding gloves.
One important tool to have in your tool chest is Firebug, a plugin for the Firefox browser.
As shown in figure 8.4, Firebug not only lets us inspect the JavaScript console, it lets us inspect the live DOM, the CSS, the script, and many other aspects of our page as we work through its development.
One feature most relevant for our current purposes is its ability to log Ajax requests along with both the request and response information.
For browsers other than Firefox, there’s Firebug Lite, which simply loads as a JavaScript library while we’re debugging.
You can get Firebug at http://getfirebug.com and Firebug Lite at http://getfirebug.com/lite.html.
Google’s Chrome browser comes built in with Firebug-like debug capabilities, which you can display by opening its Developer Tools (look around the menus for this entry—it keeps moving)
Rather, a handful of utility functions are provided to make various types of GET requests.
When we want to fetch some data from the server and decide what to do with it ourselves (rather than letting the load() method set it as the content of an HTML element), we can use the $.get() utility function.
The $.get() utility function allows us to initiate GET requests with a lot of versatility.
We can specify request parameters (if appropriate) in numerous handy formats, provide a callback to be invoked upon a successful response, and even direct how the response is to be interpreted and passed to the callback.
If even that’s not enough versatility, we’ll be seeing a more general function, $.ajax(), later on.
We’ll be examining the type parameter in greater detail when we look at the $.ajax() utility function, but for now we’ll let it default to html or xml depending upon the content type of the response.
Parameters url (String) The URL of the server-side resource to contact via the GET method.
This parameter can be a string that will be used as the query string, an object whose properties are serialized into properly encoded parameters to be passed to the request, or an array of objects whose name and value properties specify the name/value pairs.
The response body is passed as the first parameter to this callback, interpreted according to the setting of the type parameter, and the text status is passed as the second parameter.
A third parameter contains a reference to the XHR instance.
See the description of $.ajax() later in this chapter for more details.
The changes for this second phase of our page are subtle, but significant.
We call $.get() B in place of load(), passing the same URL and the same request parameters.
Because $.get() does no automatic injection of the response anywhere within the DOM, we need to do that ourselves, which is easily accomplished via a call to the html() method C.
In this example, we returned formatted HTML from the server and inserted it into the DOM, but as we can see from the type parameter to $.get(), there are many other possibilities than HTML.
In fact, the term Ajax began its life as the acronym AJAX, where the X stood for XML.
When we pass the type as xml (remember, we’ll be talking about type in more detail in a little bit), and return XML from the server, the data passed to the callback is a parsed XML DOM.
And although XML is great when we need its flexibility and our data is highly hierarchical in nature, XML can be painful to traverse and to digest its data.
Let’s see another jQuery utility function that’s quite useful when our data needs are more straightforward.
Listing 8.5 Changing the Boot Closet to use a GET when fetching style details.
Figure 8.5 Now we can see that the second request is a GET rather than a POST, as befitting the operation.
As stated in the previous section, when an XML document is returned from the server, the XML document is automatically parsed, and the resulting DOM is made available to the callback function.
When XML is overkill or otherwise unsuitable as a data-transfer mechanism, JSON is often used in its place.
One reason for this choice is that JSON is astoundingly easy to digest in client-side scripts.
For times when we know that the response will be JSON, the $.getJSON() utility function automatically parses the returned JSON string and makes the resulting JavaScript data item available to its callback.
This function, which is simply a convenience function for $.get() with a type of json, is great for those times when we want to get data from the server without the overhead of dealing with XML.
Sometimes we want to make a GET, but at other times we want (or even need) to make a POST request.
There are any number of reasons why we might choose a POST over a GET.
First, the intention of the HTTP protocol is that POST will be used for any non-idempotent requests.
Therefore, if our request has the potential to cause a change in the serverside state, resulting in varying responses, it should be a POST.
The response is interpreted as a JSON string, and the resulting data is passed to the callback function.
Parameters url (String) The URL of the server-side resource contacted via the GET method.
This parameter can be a string that will be used as the query string, an object whose properties are serialized into properly encoded parameters to be passed to the request, or an array of objects whose name and value properties specify the name/value pairs.
The data value resulting from digesting the response body as a JSON representation is passed as the first parameter to this callback, and the status text is passed as the second parameter.
A third parameter provides a reference to the XHR instance.
Making GET and POST requests practices and conventions aside, a POST operation must sometimes be used when the data to be passed to the server exceeds the small amount that can be passed by URL in a query string—a limit that’s a browser-dependent value.
And sometimes, the serverside resource we contact may only support POST operations, or it might even perform different functions depending upon whether our request uses the GET or POST method.
Now, getting back to our Boot Closet project, we’ve made a really good start, but there’s more to buying a pair of boots than just selecting a style; customers are sure to want to pick which color they want, and certainly they’ll need to specify their size.
We’ll use these additional requirements to show how to solve one of the most-asked questions in online Ajax forums, that of ...
The implementation of cascading dropdowns—where subsequent dropdown options depend upon the selections of previous dropdowns—has become sort of a poster child for Ajax on the web.
And although you’ll find thousands, perhaps tens of thousands, of solutions, we’re going to implement a solution on our Boot Closet page that demonstrates how ridiculously simple jQuery makes it.
Parameters url (String) The URL of the server-side resource to contact via the POST method.
This parameter can be a string that will be used as the query string, an object whose properties are serialized into properly encoded parameters to be passed to the request, or an array of objects whose name and value properties specify the name/value pairs.
The response body is passed as the single parameter to this callback, and the status text as the second.
A third parameter provides a reference to the XHR instance.
We’ve already seen how easy it was to load a dropdown dynamically with serverpowered option data.
We’ll see that tying multiple dropdowns together in a cascading relationship is only slightly more work.
Let’s dig in by listing the changes we need to make in the next phase of our page:
We’re also going to revert to using load() again, this time coercing it to initiate a GET rather than a POST.
It’s not that we have anything against $.get(), but load() just seems more natural when we’re using Ajax to load HTML fragments.
To start off, let’s examine the new HTML markup that defines the additional dropdowns.
A new container for the select elements is defined to contain three labeled elements:
The previous style selection element remains, but it has been joined by two more: one for color, and one for size, each of which is initially empty and disabled.
That was easy, and it takes care of the additions to the structure.
Not only must it continue to fetch and display the boot details when a selection is made, its change handler must now also populate and enable the color selection dropdown with the colors available for whatever style was chosen.
We want to use load(), but we also want to force a GET, as opposed to the POST that we were initiating earlier.
In order to have load() induce a GET, we need to pass a string, rather than an object hash, to specify the request parameter data.
Luckily, with jQuery’s help, we won’t have to build that string ourselves.
By using the serialize() method, we create a string representation of the value of the style dropdown, thereby coercing the load() method to initiate a GET, just as we wanted.
The second duty that the change handler needs to perform is to load the colorchoice dropdown with appropriate values for the chosen style, and then enable it.
Let’s take a look at the rest of the code to be added to the handler:
It’s just another use of load(), this time referencing an action named fetchColorOptions, which is designed to return a set of formatted <option> elements representing the colors available for the chosen style (which we again passed as request data) B.
This time, we’ve also specified a callback to be executed when the GET request successfully returns a response.
The call to load() injected the <option> elements, but once populated it would still be disabled if we did not enable it.
Second, the callback disables and empties the size-chooser control D.
Even though the size control will already be disabled and empty the first time the style chooser’s value is changed, what about later on? What if, after the customer chooses a style and a color (which we’ll soon see results in the population of the size control), he or she changes the selected style? Because the sizes displayed depend upon the combination of style and color, the sizes previously displayed are no longer applicable and don’t reflect a consistent view of what’s chosen.
Therefore, whenever the style changes, we need to blow the size options away and reset the size control to initial conditions.
Before we sit back and enjoy a lovely beverage, we’ve got more work to do.
We still have to instrument the color-chooser dropdown to use the selected style and color values to fetch and load the size-chooser dropdown.
Upon a change event, the size information is obtained via the fetchSizeOptions action, passing both the boot style and color selections, and the size control is enabled.
When each dropdown is initially populated, it’s seeded with an <option> element with a blank value and display text along the lines of “— choose a something —”
You may recall that in the previous phases of this page, we added code to remove that option from the style dropdown upon selection.
Well, we could add such code to the change handlers for the style and color dropdowns, and add instrumentation for the size dropdown (which currently has none) to add that.
One capability of the event model that often gets ignored by many a web developer is event bubbling.
Page authors frequently focus only on the targets of events, and forget that events will bubble up the DOM tree, where handlers can deal with those events in more general ways than at the target level.
If we recognize that removing the option with a blank value from any of the three dropdowns can be handled in the exact same fashion regardless of which dropdown is the target of the event, we can avoid repeating the same code in three places by establishing a single handler, higher in the DOM, that will recognize and handle the change events.
Recalling the structure of the document, the three dropdowns are contained within a <div> element with an id of selectionsPane.
We can handle the removal of the temporary option for all three dropdowns with the following, single listener:
This listener will be triggered whenever a change event happens on any of the enclosed dropdowns, and will remove the option with the blank value within the context of the target of the event (which will be the changed dropdown)
Using event bubbling to avoid repeating the same code in lower-level handlers can really elevate your script to the big leagues!
With that, we’ve completed phase three of The Boot Closet, adding cascading dropdowns into the mix as shown in figure 8.6
We can use the same techniques in any pages where dropdown values depend upon previous selections.
The full code of the page is now as shown in listing 8.6
Figure 8.6 The third phase of The Boot Closet shows how easy it is to implement cascading dropdowns.
As we’ve seen, with the load() method and the various GET and POST jQuery Ajax functions at our disposal, we can exert some measure of control over how our request is initiated and how we’re notified of its completion.
But for those times when we need full control over an Ajax request, jQuery has a means for us to get as picky as we want.
The functions and methods we’ve seen so far are convenient for many cases, but there may be times when we want to take the control of all the nitty-gritty details into our own hands.
In this section, we’ll explore how jQuery lets us exert such dominion.
For those times when we want or need to exert fine-grained control over how we make Ajax requests, jQuery provides a general utility function for making Ajax requests, named $.ajax()
Under the covers, all other jQuery features that make Ajax requests eventually use this function to initiate the request.
The options parameter can specify a large range of values that can be used to tune the operation of this function.
These options (in general order of their importance and the likelihood of their use) are defined in table 8.2
Parameters options (Object) An object whose properties define the parameters for this operation.
If the request is a GET, this data is passed as the query string.
If a POST, the data is passed as the request body.
In either case, the encoding of the values is handled by the $.ajax() utility function.
This parameter can be a string that will be used as the query string or response body, an object whose properties are serialized, or an array of objects whose name and value properties specify the name/value pairs.
This value determines what, if any, post-processing occurs upon the data before being passed to callback functions.
Any <script> blocks within the returned HTML fragment are evaluated.
Prior to any callbacks being invoked, the response is processed as a JavaScript statement or statements.
The server resource is responsible for setting the appropriate content-type response header.
If this property is omitted, the response text is passed to the callbacks without any processing or evaluation.
Defaults to true except when dataType is specified as either script or jsonp.
If the request doesn’t complete before the timeout expires, the request is aborted and the error callback (if defined) is called.
These are jQueryspecific custom events that trigger at various points or conditions during the processing of an Ajax request.
We’ll be discussing them in detail in the upcoming section.
If omitted, the default (true) is to enable the triggering of global events.
The response body is returned as the first parameter to this function and evaluated according to the specification of the dataType property.
The second parameter is a string containing a status value—in this case, always success.
A third parameter provides a reference to the XHR instance.
That’s a lot of options to keep track of, but it’s unlikely that more than a few of them will be used for any one request.
Even so, wouldn’t it be convenient if we could set default values for these options for pages where we’re planning to make a large number of requests?
Three arguments are passed to this function: the XHR instance, a status message string (in this case, one of: error, timeout, notmodified, or parseerror), and an optional exception object, sometimes returned from the XHR instance, if any.
Two arguments are passed: the XHR instance and a status message string of either success or error.
If either a success or error callback is also specified, this function is invoked after that callback is called.
This function is passed the XHR instance and can be used to set custom headers or to perform other prerequest operations.
This function is passed the raw response data and the dataType value, and is expected to return the “sanitized” data.
Obviously the last question in the previous section was a setup.
As you might have suspected, jQuery provides a way for us to define a default set of Ajax properties that will be used when we don’t override their values.
This can make pages that initiate lots of similar Ajax calls much simpler.
The function to set up the list of Ajax defaults is $.ajaxSetup(), and its syntax is as follows:
At any point in script processing, usually at page load (but it can be at any point of the page authors’ choosing), this function can be used to set up defaults to be used for all subsequent calls to $.ajax()
For example, setting a default type of GET won’t cause $.post() to use the GET HTTP method.
Let’s say that we’re setting up a page where, for the majority of Ajax requests (made with the utility functions rather than the load() method), we want to set up some defaults so that we don’t need to specify them on every call.
We can, as the first statement in the header <script> element, write this:
This would ensure that every subsequent Ajax call (except as noted previously) would use these defaults, unless explicitly overridden in the properties passed to the Ajax utility function being used.
Now, what about those global events we mentioned that were controlled by the global option?
Parameters options (Object) An object instance whose properties define the set of default Ajax options.
This function should not be used to set callback handlers for success, error, and completion.
We’ll see how to set these up using an alternative means in an upcoming section.
Throughout the execution of jQuery Ajax requests, jQuery triggers a series of custom events for which we can establish handlers in order to be informed of the progress of a request, or to take action at various points along the way.
We’ve been handling local events all along, without even knowing it, whenever we’ve registered a callback function to any jQuery Ajax function.
Global events are those that are triggered like other custom events within jQuery, and for which we can establish event handlers via the bind() method (just like any other event)
The global events, many of which mirror local events, are: ajaxStart, ajaxSend, ajaxSuccess, ajaxError, ajaxStop, and ajaxComplete.
When triggered, the global events are broadcast to every element in the DOM, so we can establish these handlers on any DOM element, or elements, of our choosing.
When executed, the handlers’ function context is set to the DOM element upon which the handler was established.
Because we don’t need to consider a bubbling hierarchy, we can establish a handler on any element for which it would be convenient to have ready access via this.
If we don’t care about a specific element, we could just establish the handler on the <body> for lack of a better location.
But if we have something specific to do to an element, such as hide and show animated graphics while an Ajax request is processing, we could establish the handle on that element and have easy access to it via the function context.
In addition to the function context, more information is available via parameters passed to the handlers; most often these are the jQuery.Event instance, the XHR instance, and the options passed to $.ajax()
Exceptions to this parameter list will be noted in Table 8.3, which shows the jQuery Ajax events in the order in which they are delivered.
For concurrent requests, this event is triggered only for the first of the requests.
Once again (to make sure things are clear), local events represent callbacks passed to $.ajax() (and its cohorts), whereas global events are custom events that are triggered and can be handled by established handlers, just like other event types.
In addition to using bind() to establish event handlers, jQuery also provides a handful of convenience functions to establish the handlers, as follows:
Let’s put together a simple example of how some of these methods can be used to easily track the progress of Ajax requests.
An optional fourth parameter referencing the thrown error, if any, is passed.
Parameters callback (Function) The function to be established as the Ajax event handler.
This page exhibits three controls: a count field, a Good button, and a Bad button.
These buttons are instrumented to issue the number of requests specified by the count field.
The Good button will issue requests to a valid resource, whereas the Bad button will issue that number of requests to an invalid resource that will result in failures.
Within the ready handler on the page, we also establish a number of event handlers as follows:
This statement establishes a handler for each of the various jQuery Ajax event types that emits a message to the on-page “console” (which we placed below the controls), showing the event type that was triggered.
Leaving the request count at 1, click the Good button and observe the results.
You’ll see that each jQuery Ajax event type is triggered in the order depicted in table 8.3
But to understand the distinctive behavior of the ajaxStart and ajaxStop events, set the count control to 2, and click the Good button.
Figure 8.7 The initial display of the page we’ll use to examine the jQuery Ajax events by firing multiple events and observing the handlers.
Figure 8.8 When multiple requests are active, the ajaxStart and ajaxStop events are called around the set of requests rather than for each.
Here we can see how, when multiple requests are active, the ajaxStart and ajaxStop events are triggered only once for the entire set of concurrent requests, whereas the other event types are triggered on a per-request basis.
Now try clicking the Bad button to generate an invalid request, and observe the event behavior.
Before we move on to the next chapter, let’s put all this grand knowledge to use, shall we?
Let’s put a little of everything we’ve learned so far to work: selectors, DOM manipulation, advanced JavaScript, events, effects, and Ajax.
And to top it all off, we’ll implement another custom jQuery method!
For this example, we’ll once again return to The Boot Closet page.
To review, look back at figure 8.6 to remind yourself where we left off, because we’re going to continue to enhance this page.
In the detailed information of the boots listed for sale (evident in figure 8.6), terms are used that our customers may not be familiar with—terms like “Goodyear welt” and “stitch-down construction.” We’d like to make it easy for customers to find out what these terms mean, because an informed customer is usually a happy customer.
We could be all 1998 about it and provide a glossary page that customers navigate to for reference, but that would move the focus away from where we want it—the pages where they can buy our stuff! We could be a little more modern about it and open a pop-up window to show the glossary or even the definition of the term in question.
If you’re thinking ahead, you might be wondering if we could use the title attribute of DOM elements to display a tooltip (sometimes called a flyout) containing the definition when customers hover over the term with the mouse cursor.
Good thinking! That would allow the definition to be shown in-place without requiring customers to move their focus elsewhere.
But the title attribute approach presents some problems for us.
First, the flyout only appears if the mouse cursor hovers over the element for a few seconds—and we’d like to be a bit more overt about it, displaying the information immediately after clicking a term.
But more importantly, some browsers will truncate the text of a title flyout to a length far too short for our purposes.
So we’ll build our own! We’ll somehow identify terms that have definitions, change their appearance to.
Subsequently clicking the flyout will remove it from the display.
We’re also going to write it as a generally reusable plugin, so we need to make sure of two very important things:
In figure 8.9a, we see the description of the item with the terms “Full-grain” and “oil-tanned” highlighted.
We need to make sure that the plugin code allows for such flexibility.
Figure 8.9a The terms “fullgrain” and “oil-tanned” have been instrumented for “termifying” by our handy new plugin.
Figure 8.9b The Termifier pane deployed using simple styling specified by CSS external to the plugin.
Figure 8.9c The Termifier pane with fancier styling—we need to give a user of our plugin this kind of flexibility.
As you’ll recall, adding a jQuery method is accomplished by using the $.fn property.
Because we’ve called our new plugin the Termifier, we’ll name the method termifier()
The termifier() method will be responsible for instrumenting each element in its matched set to achieve the following plan:
Establish a click handler on each matched element that initiates the display of the Termifier flyout.
Once clicked, the term defined by the current element will be looked up using a server-side resource.
Once received, the definition of the term will be displayed in a flyout using a fade-in effect.
The class name termified is added to all wrapped elements.
Parameters url (String) The URL of the server-side action that will retrieve term definitions.
This is in addition to the class name termifier, which is always added.
If omitted, the origin is placed exactly at the cursor position.
This skeleton uses the pattern outlined in the previous chapter to ensure that we can freely use the $ in our implementation, and creates the wrapper method by adding the new function to the fn prototype.
Also note how we set up the return value right away to ensure that our new method plays nice with jQuery chaining.
We want to merge the user-supplied options with our own defaults:
Having gathered all the data, we’ll now move on to defining the click handler on the wrapped elements that will create and display the Termifier pane.
When a termified element is clicked, we want to get rid of any previous Termifier panes that are lying around before we create a new one.
Otherwise, we could end up with a screen littered with them, so we locate all previous instances and remove them from the DOM.
With that, we’re now ready to create the structure of our Termifier pane.
You might think that all we need to do is create a single <div> into which we can shove the term definition, but although that would work, it would also limit the options that we offer the users of our plugin.
Consider the example of figure 8.9c, where the text needs to be placed precisely in relation to the background “bubble” image.
This won’t only be useful for placement; consider the situation of figure 8.10, in which we have a fixed-height construct and text that’s longer than will fit.
The presence of the inner <div> allows the page author to user the overflow CSS rule to add scrollbars to the flyout text.
In this code, we create a new <div> element B and proceed to adjust it.
First, we assign the class name termifier to the element C so that we can easily find it later, as well as to give the page author a hook onto which to hang CSS rules.
If the caller provided an addClass option, it’s also added.
All we do here is the minimum that’s necessary to make the whole thing work (we’ll let the page author provide any additional styling through CSS rules)
The element is initially hidden, and it’s absolutely positioned at the location of the mouse event, adjusted by any origin provided by the caller.
The latter is what allows a page author to adjust the position so that the tip of the bubble’s pointer in figure 8.9c appears at the click location.
After that, we establish a click event handler E that removes the element from the display when clicked upon.
Now we need to create the inner <div>—the one that will carry the text—and append it to the element we just created, so we continue like this:
Note that this is a continuation of the same statement that created the outer <div>—have we not been telling you all along how powerful jQuery chaining is?
In this code fragment, we create and append B the inner <div> and initiate an Ajax request to fetch and inject the definition of the term C.
Because we’re using load() and want to force a GET request, we need to supply the parameter info as a text string.
In the completion callback for the request, we find the parent (marked with the termifier class) and fade it into view E.
Before dancing a jig, we need to perform one last act before we can declare our plugin complete; we must add the class name termified to the wrapped elements to give the page author a way to style termified elements:
There! Now we’re done and can enjoy our lovely beverage.
The code for our plugin is shown in its entirety in listing 8.7, and it can be found in.
The easy part should be putting the Termifier to use on our Boot Closet page—at least, if we did it right.
Because we rolled all the complex logic of creating and manipulating the Termifier flyout into the termifier() method, using this new jQuery method on the Boot Closet page is relatively simple.
For example, we need to decide how to identify the terms on the page that we wish to termify.
Remember, we need to construct a wrapped set of elements whose content contains the term elements for the method to operate on.
We could use a <span> element with a specific class name; perhaps something like this:
In this case, creating a wrapped set of these elements would be as easy as $('span.term')
But some might feel that the <span> markup is a bit wordy.
Because the tag is intended purely for identifying document elements, none of the browsers do much with these tags, either in the way of semantics or visual rendition, so it’s perfect for our use.
Therefore, the first thing we need to do is modify the server-side resource that returns the item details to enclose terms that have glossary definitions in <abbr> tags.
But because the browsers don’t do anything with the <abbr> tag, you might not have even noticed, unless you’ve already taken a look inside the action file or inspected the action’s response.
Note how the terms “Full-grain”, “Vibram”, and “Goodyear welt” are identified using the <abbr> tag.
Starting with the code of phase three (listing 8.6) as a starting point, let’s see what we need to add to the page in order to use the Termifier.
We need to bring the new method into the page, so we add the following statement to the <head> section (after jQuery itself has loaded):
We need to apply the termifier() method to any <abbr> tags added to the page when item information is loaded, so we add a callback to the load() method that fetches the product detail information.
That callback uses the Termifier to instrument all <abbr> elements.
The augmented load() method (with changes in bold) is as follows:
The added callback creates a wrapped set of all <abbr> elements and applies the termifier() method to them, specifying a server-side action of fetchTerm and letting all options default.
Because we wisely encapsulated all the heavy lifting in our reusable jQuery plugin, using it on the page is even easier than pie! And we can as easily use it on any other page or any other site.
We built into our plugin the removal of any Termifier flyouts when another one is displayed, but what happens if the user chooses a new style? Whoops! We’d be left with a Termifier pane that’s no longer relevant.
So we need to remove any displayed Termifiers whenever we reload the product detail.
We could just add some code to the load() callback, but that seems wrong, tightly coupling the Termifier to the loading of the product details.
We’d be happier if we could keep the two decoupled and just listen for an event that tells us when its time to remove any Termifiers.
If the ajaxComplete event came to mind, treat yourself to a Maple Walnut Sundae or whatever other indulgence you use to reward yourself for a great idea.
Now let’s take a look at how we applied those various styles to the Termifier flyouts.
In our style sheet we can easily apply rules to make the termified terms, and the Termifier pane itself, look like the display of figure 8.9b.
These rules give the terms a link-ish appearance that invites users to click the terms, and gives the Termifier flyouts the simple appearance shown in figure 8.9b.
To take the Termifier panes to the next level, shown in figure 8.9c, we only need to be a little clever and use some of the options we provided in our plugin.
For the fancier version, we call the Termifier plugin (within the load() callback) with this code:
This call differs from the previous example only by specifying that the class name fancy be added to the Termifiers, and that the origin be adjusted so that the tip of the bubble appears at the mouse event location.
To the style sheet we add this (leaving the original rule):
This adds all the fancy stuff that can be seen in figure 8.9c.
Our new plugin is useful and powerful, but as always, we can make improvements.
Our brand-spankin’-new jQuery plugin is quite useful as is, but it does have some minor issues and the potential for some major improvements.
To hone your skills, here’s a list of possible changes you could make to this method or to the Boot Closet page:
Add an option (or options) that allows the page author to control the fade durations or, perhaps, even to use alternate effects.
The Termifier flyout stays around until the customer clicks it, another one is displayed, or the product details are reloaded.
Add a timeout option to the Termifier plugin that automatically makes the flyout go away if it’s still displayed after the timeout has expired.
Clicking the flyout to close it introduces a usability issue, because the text of the flyout can’t be selected for cut-and-paste.
Modify the plugin so that it closes the flyout if the user clicks anywhere on the page except on the flyout.
How would you enhance the code to gracefully deal with invalid caller info, or server-side errors?
We achieved the appealing drop shadows in our images by using PNG files with partial transparencies.
Although most browsers handle this file format well, IE 6 doesn’t and displays the PNG files with white backgrounds.
To deal with this, we could also supply GIF formats for the images without the drop shadows.
While we’re talking about the images, we only have one photo per boot style, even when multiple colors are available.
Assuming that we have photo images for each possible color, how would you enhance the page to show the appropriate image when the color is changed?
Can you think of other improvements to make to this page or the termifier() plugin? Share your ideas and solutions at this book’s discussion forum, which you can find at http://www.manning.com/bibeault2
Not surprisingly, this is one of the longest chapters in this book.
Ajax is a key part of the new wave of DOM-scripted applications, and jQuery is no slouch in providing a rich set of tools for us to work with.
For loading HTML content into DOM elements, the load() method provides an easy way to grab the content from the server and make it the contents of any wrapped set of elements.
Whether a GET or POST method is used is determined by how any parameter data to be passed to the server is provided.
When maximum flexibility is required, the $.ajax() utility function, with its ample assortment of options, lets us control the most minute aspects of an Ajax request.
All other Ajax features in jQuery use the services of this function to provide their functionality.
To round out the Ajax toolset, jQuery also allows us to monitor the progress of Ajax requests by triggering Ajax events at the various stages, allowing us to establish handlers to listen for those events.
We can bind() the handlers, or use the convenience methods: ajaxStart(), ajaxSend(), ajaxSuccess(), ajaxError(), ajaxComplete(), and ajaxStop()
With this impressive collection of Ajax tools under our belts, it’s easy to enable rich functionality in our web applications.
And remember, if there’s something that jQuery doesn’t provide, we’ve seen that it’s easy to extend jQuery by leveraging its existing features.
In the first part of this book, focusing on the jQuery core library, we made a big deal about how easy it is to extend jQuery.
And we were correct to do so, because the ease with which jQuery can be extended is a big deal.
And nowhere is it more evident than in the official plugins, the score of available unofficial plugins, and the companion library: jQuery UI.
We’ll start by learning how the library can be obtained and configured—it’s not quite as simple as just copying a single file, as we were able to do with the core library.
Then we’ll take a look at some of the basic capabilities that jQuery UI adds to the features of the core library.
From there we’ll see how jQuery UI layers upon the core library, and we’ll look at the extended capabilities that it adds, all of which brings us user interface interactions such as the ability to drag and drop, sort, and resize elements.
And then, layering further upon that, we’ll explore the user interface widgets that jQuery UI adds to our toolbox of input controls.
After finishing this part, and hence the book, you’ll be fully prepared to take on just about any user interface project that the web might throw at you.
More than a plugin, but not part of the jQuery core, jQuery UI enjoys a status as an official extension of the jQuery core library aimed at providing extended user interface (UI) capabilities to jQuery-enabled web application pages.
The tools available for us to use within the browser environment (JavaScript, DOM manipulation, HTML, and even the core jQuery library) give us low-level abilities to put together pretty much any kind of user interactions we might want to provide for our users.
But even so, building complex interactions using basic building blocks can be a large and daunting task.
We can create our own interactions and controls (often called widgets) with the help of the jQuery methods we’ve learned to this point.
But the jQuery UI library provides us with a fair number of generally desired extended features or gives us higherlevel building blocks to create them ourselves.
Imagine a commonly needed widget such as a progress bar.
We could analyze its requirements and figure out how to implement it using core jQuery, but the UI library has already anticipated that need and provides a progress bar widget right out of the box.
Unlike the core jQuery library, jQuery UI is a confederation of loosely coupled elements.
We’ll see, in the first section of this chapter, how we can download a library that contains all of these pieces, or just the ones we’re going to need.
It’s important to note that the interactions and widgets make heavy use of CSS to “theme” the visible elements.
This is an essential tool for making the elements work correctly, as well as to match the design and appearance of our own pages, and it’s a topic that we’ll be examining later in this chapter.
And because jQuery UI is an important extension to jQuery, we’re devoting three chapters to it.
We have also provided an extensive set of UI-focused Lab pages—pretty much one for each major area of jQuery UI.
These chapters, along with the Labs, should give you a good starting point for using jQuery UI.
Without further blather, let’s get going and get our hands on jQuery UI.
The jQuery UI library consists of a fairly large number of elements.
Depending upon the needs of your application, you might want to use all of these elements, or perhaps just a subset of them.
For example, your application might not need to make use of the widgets, but it might need drag-and-drop capability.
The jQuery UI team has provided the ability to construct a library that consists of only the essential required pieces, plus any features that you need for your application.
This eliminates the need to load a larger library than your application will use.
Before we can use the library, we need to download it.
The download page for jQuery UI can be found at http://jqueryui.com/download, depicted in figure 9.1
As you can see in the figure, the most recent version as of this writing is jQuery UI 1.8
On that page, you’ll find a list of the available components for the jQuery UI library, each with a checkbox that you can check to select that component.
You’ll need to check the box for UI Core in order to be able to use any of the interactions and most of the widgets.
But don’t worry too much about what you select—the page will automatically select dependencies, and it won’t let you put together an invalid combination of elements.
Once you’ve identified the components that you want (for now, we recommend selecting them all for exploratory purposes), pick a theme from the dropdown in the right-most column, and then click the Download button.
Figure 9.1 The jQuery UI download page allows us to configure and download a jQuery UI library configuration customized to the needs of our application.
It doesn’t matter which theme you choose at this point; we’ll be addressing CSS themes later in this chapter.
For now, just pick any theme, though we recommend avoiding the No Theme option at this point.
You want to download the CSS rather than building it from scratch.
The differences between themes are limited to the style sheet and images associated with the theme.
The jQuery UI library configuration that’s provided with the example code for this book contains all components and uses the Cupertino theme.
Once you’ve clicked the Download button, a set of zipped custom jQuery UI library files is downloaded to your system (exactly where depends upon your browser settings)
You can use this as a quick check to make sure that the widgets you want are included, and that the theme matches your expectations.
The subfolder will bear the name of the theme that you chose; for example, cupertino or trontastic.
Explore this at your leisure; there’s lots of good stuff there.
You’ll also need the jQuery core library file if it’s not already present.
Although the locations in which you place these files can be specific to the needs of your web application, it’s important to retain the relationship between the theme’s CSS file and its images.
Unless you want to change the references to all the images within the CSS file, be sure to leave the theme’s images folder in the same folder as the CSS file.
A commonly used application layout, supporting multiple themes, is shown in figure 9.2
Here, we’re supporting three of the canned themes available for download.
Switching between themes is as easy as changing the URLs that reference the CSS files in the application’s pages.
For example, we could import the files into the index.html file in the application layout depicted in figure 9.2 with the following markup:
Switching themes is as easy as changing the theme folder name in the <link> tag.
Within this chapter, we’ll begin with a closer look at themes, and then look at the ways jQuery UI extends core methods and capabilities, especially in the area of effects.
In the next two chapters, we’ll explore the mouse interactions and then the widgets.
Figure 9.2 A conventional layout for the script and theme files within an application using jQuery UI–your mileage may vary.
There are a number of ways to set up the themes that jQuery UI relies upon.
Let’s start by taking a look at how the predefined CSS files and class names are organized.
Although the predefined themes are all very nice, it’s unlikely that we’d find one that precisely matches the look of our own web applications.
We could, of course, pick a canned theme first, and use it as the definitive look for our site, but that may not be a luxury we often have.
Which one of us has never had a marketing or product manager looking over our shoulder and asking, “What if we make that blue?”
The ThemeRoller, which we’ll discuss in the next section, can help us make a theme that has exactly the colors and textures we want for our applications, but even so, we may still need to make page-by-page tweaks.
As such, it behooves us to understand how the CSS classes are laid out and used by jQuery UI.
The class names defined and used by jQuery are extensive, but well organized.
They were carefully chosen to convey not only their meaning, but where and how they’re used.
Even though there are a lot of names, they make logical sense and are easy to manage once you get the hang of how they’re constructed.
First, in order to keep from stepping on anyone else’s names in the class namespace, all jQuery UI class names begin with the prefix ui-
Names are always in lowercase, and hyphen characters are used to separate words; for example, uistate-active.
It’s used by all components of the UI library to indicate that an element is in an active state.
For example, the Tab widget will use it to mark the active table, whereas the Accordion widget will use it to identify the open accordion pane.
When a class is specific to a particular component, be it an interaction or a widget, the name of the component will immediately follow the ui- prefix.
For example, classes specific to the Autocomplete widget will all begin with ui-autocomplete, whereas those specific to the Resizable interaction will begin with ui-resizable.
We’ll take a closer look at the cross-library class groupings in the remainder of this section.
The component-specific classes will be discussed as we examine the various components over the next few chapters.
It isn’t our intention to cover every one of the hundreds of class names defined by jQuery UI.
Rather, we’ll look at the most important, and the ones that we’re likely to need to know about on our pages.
When widgets are created by the jQuery UI library, some elements that compose the widget may be created by the library, and some may be existing elements that are already resident on the page.
In order to identify the elements that comprise the widgets, jQuery UI uses a set of class names that begin with ui-widget.
The class ui-widget is used to identify the master element of the widget—usually a container that’s the parent of all the elements that form the widget.
Other class names, such as ui-widget-header and ui-widget-content, are used as appropriate for the widget’s elements.
Just how a widget uses these classes is specific to each widget.
At any point in time, various parts of widget or interaction elements may be in various states.
We can use these names in our own scripts or CSS to track state or affect the styling of elements in the various states.
For example, icon indicators on the tab elements of the Tab widget, or icons directly on Button widgets.
All the individual icon images are defined in a grid on a single image—an icon sheet, if you will.
That way, once this image has been downloaded and cached by the browser, no further trips to the server are needed to display any of the available icons—and there are a lot of them (173 as this is being written)
The icon class definitions merely identify how to move the origin of this sheet image as a background image, causing the desired icon to appear as the background of an element.
If you’ve already taken a glimpse at the widgets defined by jQuery UI, you’ve probably already seen a lot of rounded corners.
These corner-rounding classes aren’t limited to just the JQuery UI widgets! We can use these classes on any element of our page.
The checkbox controls allow us to choose which, if any, of the ui-corner classes are applied to the test subjects.
When a checkbox is checked, the corresponding class name is applied; when unchecked, the class name is removed.
Spend a few moments clicking the various checkboxes to see how the application of the classes affects the corners of the test subjects.
If you take a quick look through the CSS file generated when we downloaded jQuery UI, you’ll probably quickly come to the conclusion that trying to write such a file from scratch would be nothing short of madness.
A quick glance at the images accompanying the CSS firmly cements that notion.
Figure 9.3 The Rounded Corners Mini-Lab lets us see how rounded corners can be applied to elements via simple class assignments.
When one of the canned themes doesn’t match what we need for our site, we have some sane choices:
As it turns out, the ThemeRoller tool is the best way to achieve either of these options.
With the ThemeRoller tool, we can start from scratch and specify every detail of a theme using an easy and intuitive interface, or we can preload it with one of the predefined themes and adjust it to our liking.
The ThemeRoller can be found at http://jqueryui.com/themeroller/, and it appears as shown in figure 9.4
We’re not going to go into a great deal of detail on using the ThemeRoller—it’s pretty easy to figure out.
But there are a few things you should know that are worth spending some time on.
Figure 9.4 The jQuery UI ThemeRoller tool lets us create custom themes interactively with an intuitive and easy-to-use interface.
The control panel for the ThemeRoller on left side of the interface has three tabs:
Roll Your Own—This is where we’ll do most of the work.
The various panels (click on a panel header to open it) let us specify all the details of the theme.
Changes are shown in real time in the display area that shows how the settings we make affect the various widgets.
When we’re satisfied with the settings of our theme, the Download Theme button on the Roll Your Own tab sends us to the Build Your Download page so that we can download the custom theme.
The theme settings are passed on the URL as request parameters.
Clicking the Download button on the Build Your Download page downloads the theme as we discussed in section 9.1
Often, one of the canned themes might make a better starting point for a custom theme than starting completely from scratch.
If you want to load the settings for one of the predefined themes and make adjustments from there, follow these simple steps:
The downloaded CSS file and images will reflect the settings that you selected for the custom theme, and within the download, the folder containing the theme within the css folder will be named custom-theme.
Inevitably, just as you’re admiring your custom theme in your web application, someone will come along and demand a change.
But try as you might, you can’t find an upload or reload control on the ThemeRoller.
Do we really have to start over and recreate a custom theme each time in order to make a change? Of course not.
Cut and paste this URL into your browser, and it will bring you to the ThemeRoller page, loaded with the settings for the custom theme (which are encoded onto the URL as request parameters)
Any necessary changes can be made to the theme settings and the new files downloaded when ready.
OK, we now have a themed jQuery UI installation ready and waiting to use.
Let’s dig into the extended effects that jQuery UI provides.
Back in chapter 5, we saw how easy it is to create custom effects using the jQuery animation engine.
We’ll take a close look at those effects, but we’ll also see how jQuery UI infuses these effects into core jQuery by providing extended versions of core methods that normally don’t support effects.
We’ll also see a few new effect-focused methods that jQuery UI provides for us.
All of the effects that jQuery UI provides can be used on their own—without other methods—via the effect() method.
This method launches the effect on the elements of the wrapped set.
Although table 9.1 attempts to describe what each effect does, it’s a lot clearer to actually see it in action.
The jQuery UI Effects Lab has been set up for just this purpose.
No arguments are passed to this function, and the function context is set to the element being animated.
As you read through the descriptions of the effects in table 9.1, use this Lab page to see exactly what the effect does, and how the options affect the operation of the effect.
In table 9.1, the various effects are described, along with their options.
All effects (except explode) accept an easing option that specifies the easing function to be used with the effect.
We’ll examine the concept of easing in the upcoming section 9.3.5
As you read through the entries in table 9.1, use the jQuery Effects Lab to see each effect in action.
Thinking back to our examination of the animate() method in chapter 5, you’ll recall how that method allows us to animate CSS properties expressed by numeric values that have a logical progression from a start value to an end value.
Color properties, you may recollect, were not among the supported animatable properties.
So how, then, does jQuery UI implement the highlight effect, which animates the background color of an element? Let’s find out.
Figure 9.5 The jQuery UI Effects Lab lets us see how the UI effects operate in real time with various options.
Note that the algorithm may optimize your value to a different number.
This is the same as the core fade effects, but without options.
Effect name fold Shows or hides the element by adjusting opposite borders in or out, and then doing the same for the other set of borders.
If omitted or specified as false, the vertical borders are moved first.
Possible values are: top, middle, bottom, and left, center, right.
Similar to scale except for how the target size is specified.
Possible values are: top, middle, bottom, and left, center, right.
The properties that are saved are undocumented, but include margin and padding settings and are highly dependent upon the other options and environment of the element.
Use this option only if some property is not turning out as you intend to see if it rectifies the issue.
The value should be less than the width or height of the element (depending upon direction), and the default is the current width (for left or right) or height (for up or down) of the element.
The appearance of the outline element must be defined via CSS rules for the uieffects-transfer class, or the class specified as an option.
There is no default; this option must be specified for the effect to work.
If we dissect the majority of effects that we’ve discussed throughout this book, including the list provided by jQuery UI (shown in table 9.1), we can determine that most of them are implemented by changes in the position, dimensions, and opacity of the animated elements.
And although that gives us (not to mention jQuery UI) a great deal of latitude for creating effects, the range of effects that can be created is greatly expanded if the ability to animate color is thrown into the mix.
The core jQuery animation engine doesn’t possess this ability, so jQuery UI extends the capabilities of the core animate() method to allow the animation of CSS properties that specify color values.
And because all effects are eventually executed by this augmented capability, it doesn’t matter how the effect is initiated—all means of specifying effects can take advantage of this extended capability.
We’ll shortly see how this is significant when we examine other extensions to the core library that jQuery UI provides.
As we discussed in chapter 5, the primary visibility methods of core jQuery—show(), hide(), and toggle()—when provided with a duration value, show or hide the target elements with a predefined effect that adjusts the width, height, and opacity of the elements.
Parameters effect (String) The effect to use when adjusting the element visibility.
Whether you realize it or not, you’ve already seen an example of using these augmented visibility effects.
In the jQuery UI Effects Lab, when the value of the effect dropdown is changed, any option controls not appropriate for the newly selected effect are removed with.
And the controls that are appropriate for the selected effect are shown via.
As an advanced exercise, make a copy of the jQuery UI Effects Lab, and turn it into the jQuery UI Show, Hide, and Toggle Lab:
Add a set of radio controls that allow you to select one of the three visibility methods: show(), hide(), and toggle()
When the Apply button is clicked, determine which method has been selected, and execute that method in place of the effect() method.
The visibility methods aren’t the only core methods that jQuery UI extends with added capabilities.
As you might recall, the animate() method of core jQuery allows us to specify a set of CSS properties that the animation engine will progressively modify in order to create animated effects.
Because CSS classes are collections of CSS properties, it seems a natural extension to allow the animation of class transitions.
And indeed, that’s exactly what jQuery UI provides: extensions to the class transition methods addClass(), removeClass(), and toggleClass() to allow animating the changes to the CSS properties.
No arguments are passed to this function, and the function context is set to the element being animated.
If the speed parameter is omitted, these methods act exactly like the unextended core methods.
In addition to extending these core class transition methods, jQuery adds a useful new class manipulation method, switchClass(), whose syntax is as follows:
Between the effect() method and the extensions to the core visibility and class transition methods, jQuery UI gives us a lot of choices regarding how we write code that manipulates elements in an animated manner.
Could we just use the animate() method for all such occasions? Sure we could.
But thinking in terms of code clarity, it makes a lot more sense to use a method named hide() to hide an element—even in an animated fashion—than a method named animate()
Another extension that jQuery UI provides in the area of animation is a rather large set of easings beyond that provided by jQuery core.
See the description of animate() in chapter 5 for more information.
Parameters removed (String) The CSS class name, or space-delimited list of class names, to be.
See the description of animate() in chapter 5 for more information.
See the description of animate() in chapter 5 for more information.
When we originally discussed animation back in chapter 5, we introduced the concept of easing functions (casually termed easings) that control the pace at which animations progress.
We can specify an easing in any animation method that accepts an options hash.
As noted earlier, these options are eventually passed to the animate() core method, which all animation methods eventually call to execute the animation or effect.
One of those core options is easing, which identifies the name of the easing function to be used.
When jQuery UI is loaded, the entire list of available easings is as follows:
It’d be practically impossible to describe in words how each easing operates—we really need to see them in action to understand how any specific easing affects the progression of an animation.
And so the jQuery UI Easings Lab page is available to let us see how the easings operate when applied to the various animations.
This Lab lets us try out the various easings paired with the various effects.
For best results in seeing what transpires as each easing function progresses, we recommend trying the following:
Set the speed to very slow—slower than the slow setting.
Now let’s look at one more utility that jQuery UI provides.
Throw jQuery into the mix, and it becomes almost trivial—if we know where we want to position the elements.
For example, if we knew that we wanted an element to be moved to some absolute position, we’d write this:
But what if we wanted to position the element relative to another element? For example, place the element to the right of another element, but with the tops aligned? Or place it below another element with their centers in alignment?
Figure 9.6 The jQuery UI Easings Lab shows us how the various easings operate when applied to an animation effect.
We can grab the dimension and position information of the elements in question using core jQuery methods, do some math, and use the results to absolutely position the target element.
But although it’s not a problem, it’s rather a fair amount of code, and it could be rather fragile if we’re not careful about assumptions made in the formulas that calculate the new position.
It probably wouldn’t be the most readable code in the world, either; most likely it’d be less than a snap to figure out what that code did by casual inspection, especially for someone who didn’t write the formulas in the first place.
This method is an overloading of the position() method we examined in chapter 3 (which obtains the position of an element relative to its offset parent)
As you read through the options in table 9.2, use the Positioning Lab to familiarize yourself with the operation of the options.
Give yourself bonus points if you can pin the tail in the proper location in one try!
You might be looking at the names of the options and saying to yourself, “What were they thinking? at? my? of? What on Earth?”
If you inspected the generated statement in the Positioning Lab as you were experimenting with it, you’ve already seen it.
It almost reads like an English sentence! Even someone who’s never seen a fragment of computer code in his or her life would most likely be able to figure out what this statement does (while wondering why computer gear-heads insist on all that gnarly punctuation)
Parameters options (Object) Provides the information that specifies how the elements of the wrapped.
Most APIs could benefit from a touch of this sort of “madness.”
Two of: top, left, bottom, right, and center, separated by a space character, where the first value is the horizontal value, and the second the vertical.
If a single value is specified, the other defaults to center.
Whether the specified single value is considered horizontal or vertical depends upon which value you use (for example, top is taken as vertical, while right is horizontal)
Figure 9.7 The jQuery UI Positioning Lab lets us observe the jQuery UI overload of position() in action.
In this chapter we dove head-first into jQuery UI, and we won’t be coming up for air until the end of this book.
We learned that jQuery UI enjoys a special status as an official companion to the core jQuery library, and how to download a customized version of the library (along with one of the predefined themes) from http://jqueryui.com/download.
We learned about the contents of the download, and how the library is typically added to a web application’s folder structure.
We then discussed the theming capability of the jQuery UI library and how the CSS classes that it defines are laid out, including how they’re organized by naming conventions.
We examined the official ThemeRoller online application, located at http://jqueryui.com/themeroller/, which can be used to tweak one of the predefined themes, or to create a new theme entirely from scratch.
The remainder of the chapter examined extensions that JQuery makes to the core library.
If a single value is specified, it applies to both left and top.
If neither side fits, center is used as a fallback.
If a single value is specified, it applies to both directions.
Called for each wrapped element with a single argument that consists of an object hash with the left and top properties set to the computed target position, and the element set as the function context.
We saw how the core animation engine has been extended to provide a good number of named effects that are easily launchable using the new effect() method.
We also saw how jQuery UI extends the visibility methods show(), hide(), and toggle() to work in conjunction with these new effects.
The same manner of extension has also been applied to the class transition methods: addClass(), removeClass(), toggleClass(), and the newly defined switchClass() method.
We then discussed the two and a half dozen easing functions that jQuery adds to be used by the animation engine to control the progression of an animation.
Finally, we looked at an extension to the core position() method that allows us, in a remarkably readable fashion, to position elements relative to each other, or to the location of a mouse event.
Read on to the next chapter, where we’ll learn about another major part of jQuery UI: mouse interactions.
Few usability experts would argue that direct manipulation isn’t key to good user interfaces.
Allowing users to directly interact with elements and immediately see the effects of their activities is a much better user experience than some abstraction that approximates the activities.
How would we allow users to specify a sort order for the elements? Using just the basic set of controls available in HTML 4, there’s not a whole lot of flexibility available to us.
Showing the list of elements followed by a text box next to them in which the user must type the ordinal value could hardly be presented as a paragon of usability.
But what if we could allow users to grab and drag the elements within the list to immediately move them around until they’re happy with the result? This jQuery UI mouse interactions: Follow that mouse!
The core interactions add advanced behavior to our pages that relate to the use of the mouse pointer.
We can use these interactions ourselves—as we’ll see throughout this chapter—and they’re also the bedrock upon which much of the remaining jQuery UI library is built upon.
As we’ll see while working our way through this chapter, the core interactions build upon one another.
To get the most out of this chapter, it’s recommended that you work through it sequentially.
This may be a long chapter, but there’s a level of consistency to the jQuery UI methods, mirrored in the structure of the chapter sections, that makes it easy to work through all the material once you get familiar with how the methods are arranged.
Interacting with the mouse pointer is an integral and core part of any GUI.
Although some simple mouse pointer interactions are built into web interfaces (clicking, for example), the web doesn’t natively support some advanced interaction styles available to desktop applications.
A prime example of this deficiency is the lack of support for drag and drop.
Drag and drop is a ubiquitous interaction technique for desktop user interfaces.
For example, in the GUI file manager for any desktop system, we can easily copy files or move them around the filesystem by dragging and dropping them from folder to folder, or even delete them by dragging and dropping them onto a trash or wastebasket icon.
But as prevalent as this interaction style is within desktop applications, it’s just as sparse in web applications, mainly because modern browsers don’t natively support drag and drop.
But in the same way that jQuery and its plugins have eased our pain before, they do so again with direct support for drag and drop.
But before we can drag and drop, we first need to learn how to drag, so that’s where we’ll start.
Although we’d be hard-pressed to find the term draggable in most dictionaries, it’s the term that’s commonly applied to items that can be dragged about in a drag-and-drop operation.
Likewise, it’s both the term that jQuery UI uses to describe such elements and the name of the method that applies this ability to elements in a matched set.
But before we introduce the syntax of the draggable() method, let’s take some time to talk about a convention used throughout jQuery UI.
In order to keep the incursion into the method namespace as minimal as possible, many of the methods in jQuery serve multiple purposes depending upon the nature of the parameters passed to them.
That’s not anything particularly new—we’ve seen quite a bit of that in core jQuery.
But jQuery UI takes method overloading to the next level.
We’ll see that the same method can be used for quite a number of related actions.
This one method is used to not only make elements draggable, but to control every aspect of the draggability of the elements, including disabling, destroying, and re-enabling the elements’ draggability, as well as to set and fetch individual draggability options.
Because the method name will be the same for all these operations, we only have the parameter list to differentiate among the intended operations.
Frequently, the differentiator takes the guise of a string, passed as the first parameter, that identifies the operation to be performed.
For example, to disable the draggability of draggable elements, we’d write.
Such methods no longer exist, having been replaced by more succinct multipurpose methods such as draggable()
The syntax for the various forms of the draggable() method are as follows:
Parameters options (Object) An object hash of the options to be applied to the elements in the.
If omitted (and no other parameters are specified) or empty, the elements become freely draggable anywhere within the window.
Let’s start digging in by examining how to make things draggable in the first place.
To make elements draggable, we need to call the draggable() method with a parameter consisting of an object whose properties specify the draggability options (as outlined in table 10.1), or with no parameter at all (to use all default settings)
We’ll see what the enable call does in short order.
When an item is made draggable, the class ui-draggable is added to it.
This helps not only in allowing us to identify the draggable elements, but as a hook to apply visual clues via CSS should we choose to do so.
There are a lot of draggability options, so to help us get familiar with them, a jQuery UI Draggables Lab page has been provided.
The options available for the draggable() method give us a lot of flexibility and control over exactly how drag operations will take place; they’re described in table 10.1
The options represented in the Draggables Lab page are identified in the In Lab column of table 10.1
Be sure to try them out as you go along.
The draggability of the elements isn’t removed, and can be restored by calling the 'enable' variant of this method.
Note that this method won’t add draggability to any non-draggable elements.
If specified, at least the optionName parameter must also be provided.
If a value parameter is provided, that value becomes the option’s value.
If no value parameter is provided, the named option’s value is returned.
Returns The wrapped set, except for the case where an option value is returned.
We might choose to do this for performance reasons if the class isn’t needed and we’re adding draggability to many elements on a page.
Figure 10.1 The Draggables Lab page will help us to familiarize ourselves with the many options for draggables in the jQuery UI.
If not specified, any helper is appended to the parent of the draggable element.
For example, specifying x allows movement in the horizontal direction only.
If unspecified, or specified as any other values, movement is unconstrained.
Note that this doesn’t prevent these elements from becoming draggable; it merely prevents the elements from being actively dragged around.
The elements are still considered draggable and the ui-draggable class is added to these elements.
If specified, the helper option should also be specified as clone.
This option is in support of sortables, which we’ll be taking a look at in section 10.3
If unspecified, or specified as document, the movement is unconstrained within the document.
The string window will constrain movement to the visible viewport, whereas the string parent will constrain movement within the element’s direct parent.
If an element, or selector identifying an element, is specified, movement is constrained within that element.
An arbitrary rectangle relative to the document can also be specified as an array of four numbers, identifying the top-left and bottom-right corners of the rectangle as follows: [x1,y1,x2,y2]
This can be used to help prevent accidental drags by only reacting if the user maintains the mouse button in the down position for the specified period.
By default, the value is 0, meaning that no delay is defined.
Table 10.1 Options for the jQuery UI draggable() method  (continued)
Dragging things around distance (Number) The number of pixels that must be dragged across before a drag operation is initiated.
This can also be used to help prevent accidental drags.
The origin of the grid is the initial position of the dragged element.
The handle element must be a child of the draggable for this to work correctly.
When specified, only a click on the handle element will cause a drag operation to commence.
By default, clicking anywhere within the draggable starts the drag.
If clone is specified, a copy of the draggable item is created and moved around during the drag operation.
A function can be specified that gives us the opportunity to create and return a new DOM element to use as the drag helper.
If specified as true, all iframes are masked during a drag operation.
If a selector is provided, any selected iframes are masked.
If omitted, the opacity of the element isn’t changed during dragging.
Use this only if it solves some problems you may be having on highly dynamic pages, because it comes with a heavy performance penalty.
If the string invalid is used, the element reverts only if it has not been dropped onto a droppable; if valid, the element reverts only if dropped onto a droppable.
If omitted, or specified as false, the dragged element doesn’t return to its original position.
Draggables with the same scope name as a droppable will automatically be accepted by that droppable.
If not specified, a default scope of default is used.
Table 10.1 Options for the jQuery UI draggable() method  (continued)
Draggables also give us the flexibility to control how the rest of our page conducts itself while a drag is under way.
We saw, in table 10.1, that there are three options that let us register event handlers on the draggables themselves: drag, start, and stop.
These options are a convenient way to bind event handlers for three custom events that jQuery triggers during various stages of a drag operation: dragstart, drag, and dragstop, all described in table 10.2
This table (and all event-description tables that follow) show the bindable custom.
Use lower values to slow the scrolling, and higher values to speed it up.
Specifying true is shorthand for the selector .ui-draggable, making all other draggables the target elements.
The string outer specifies that only the outside of the edge will be snapped to, whereas inner specifies that only the inside of the edge will be snapped to.
The string both (the default) will cause either side of the edge to be snapped to.
Whenever you drag an element, it becomes the highest (by z-index) of all other draggables in that group.
A minimum value that the z-index should never fall below can also be specified with the min property.
If omitted, the z-index of the draggables is unchanged during drag operations.
Table 10.1 Options for the jQuery UI draggable() method  (continued)
Dragging things around event name, the option name that can be used to specify a handler function, and a description of the event.
Handlers for each of these events can be established on any element in a draggable element’s ancestor hierarchy to receive notification whenever any of these events occurs.
We might want, for example, to react to dragstart events in some global manner by establishing a handler for that event on the document body:
Regardless of where the handler is established, and whether it was established via an option entry or with the bind() method, the handler is passed two parameters: the mouse event instance, and an object whose properties contain information on the current state of the drag event.
The Draggables Lab page establishes draggable event handlers and uses the information passed to them to show the position of the dragged element in its Console pane.
Once we’ve made an element draggable using this first form of the draggable() method (in which we pass an options object), we can use the other forms to control the element’s draggability.
As we learned in the previous section, calling the draggable() method with an options hash (or with no parameters at all) establishes the draggability of the wrapped elements.
Once an element is draggable, we may have occasion to want to suspend that draggability, but without losing all the options we’ve taken the effort to set up.
We can temporarily disable an element’s draggability by calling the following form of the draggable() method:
Any draggable elements in the wrapped set will become temporarily non-draggable.
In the preceding example, we’ve disabled draggability for all draggables on the page.
To reinstate the draggability of such elements, we’d use this statement:
This will re-enable the draggability of any draggable elements that have been disabled.
The enable form of the method will only re-enable the draggability of draggable elements that have been previously disabled.
If we wish to make draggable elements non-draggable permanently, restoring them to predraggable condition, then we’d use this statement:
The destroy variant of the method removes all vestiges of draggability from the elements.
The final format of the versatile draggable() method allows us to set or retrieve individual options at any time during a draggable’s lifetime.
For example, to set the revert option on a draggable element, use this line:
This will set the revert option to true for the first element in the wrapped set if that element is already draggable.
Trying to set an option on a non-draggable element won’t do anything useful.
If we want to fetch the value of a draggable’s option, we could write this:
This will fetch the value of the revert option for the first element in the wrapped set if that element is draggable (otherwise, you’ll just get undefined)
Dragging things around the screen is all well and good, but is it really useful? It’s fun for a time, but like playing with a yo-yo (unless we’re true aficionados), it loses its charm quickly.
In practical applications, we could use it to allow users to move modular elements around the screen (and if we’re nice, we’d remember their chosen positions in cookies or other persistence mechanisms), or in games or puzzles.
But drag operations truly shine when there’s something interesting to drop dragged elements on.
So let’s see how we can make droppables to go with our draggables.
Creating droppable items from page elements is similar to creating draggables; in fact, it’s even easier because there are fewer options to worry about.
Like the draggable() method, the droppable() method has a number of forms: one used to initially create the droppables, and the others to affect the droppable afterwards.
Elements are made droppable by collecting them into a wrapped set and calling the droppable() method with an object hash of options (or no parameters at all to accept the option defaults)
When made droppable, the class ui-droppable is added to the elements.
This is similar to the way we made things draggable, but there are fewer options, as listed in table 10.3
As with draggables, we’ve also provided a jQuery UI Droppables Lab page (shown in figure 10.2) that demonstrates most of the droppable options in action.
Parameters options (Object) An object hash of the options to be applied to the elements in the.
The droppability of the elements isn’t removed and can be restored by calling the enable variant of this method.
Note that this method won’t add droppability to any non-droppable elements.
If specified, at least the optionName parameter must also be provided.
If a value parameter is provided, that value becomes the option’s value.
If no value parameter is provided, the named option’s value is returned.
Returns The wrapped set, except for the case where an option value is returned.
Although there are fewer options available for droppables than for draggables, it’s also clear that there are more events and states associated with droppables.
Figure 10.2 The Droppables Lab page allows us to see the droppable options in action.
The function is invoked for all draggable elements, with a reference to that element as the first parameter.
Returning true from the function accepts the draggable for dropping.
See the description of the droppable events in table 10.4 for more details on this event.
You can specify more than one class name by separating them with space characters.
If omitted, no classes are added to the droppable during an acceptable drag operation.
We might choose to do this for performance reasons if the class isn’t needed and we’re adding droppability to many elements on a page.
See the description of the droppable events in table 10.4 for more details on this event.
See the description of the droppable events in table 10.4 for more details on this event.
If this option is set to true, this propagation is prevented.
Multiple class names can be provided by separating them with space characters.
If omitted, no classes are added to the droppable during an acceptable hover.
See the description of the droppable events in table 10.4 for more details on this event.
See the description of the droppable events in table 10.4 for more details on this event.
Draggables with the same scope name as a droppable will automatically be accepted by the droppable.
If not specified, a default scope of default is used.
Keeping track of the states of a drag event is pretty easy; either the element is being dragged or it’s not.
But when we add dropping into the mix, things become a bit more complex.
Not only do we have the draggable to take into account, but also its interaction with the droppables for which it’s acceptable.
Because a figure is worth many words, figure 10.3 depicts the states and the events that cause their transitions during a drag-and-drop operation.
Once established as a droppable, a droppable element will be in inactive state—it’s prepared to accept draggables, but because there’s no drag operation underway, all is peaceful and at rest.
But once a drag operation starts, things get more interesting:
Any handlers for dropactivate events (whether established via options or not) will be triggered according to the normal rules of event propagation unless the greedy option was specified as true, in which case only handlers on droppables will be invoked.
At this point, any class names provided by the activeClass option are applied to the droppable.
Table 10.3 Options for the jQuery UI droppable() method  (continued)
Figure 10.3 The states and transitions that a droppable can attain depend upon the interaction between the active draggable and the droppable element during a drag-and-drop operation.
This is the point at which any class names supplied by a hoverClass option are applied to the droppable.
There are two possible transitions from this point: the drag operation can terminate by the release of the mouse button, or the draggable can continue to be moved.
All droppable event handlers are passed two parameters: the mouse event instance, and an object whose properties contain information on the current state of the dragand-drop operation.
We can use the Droppables Lab to make sure that we understand these events and state transitions.
As in the other labs, there’s a Control Panel that lets us specify the options to be applied to the droppable after clicking the Apply button.
The Disable and Enable buttons serve to disable and enable the droppable (using the appropriate variants of the droppable() method), and the Reset button puts the form back to its initial state and destroys the droppable capability on the Lab’s drop target.
In the Test Subjects pane are six draggable elements and an element that will become droppable after clicking the Apply button (which we’ll call the Drop Zone)
When a corresponding droppable event is triggered, the appropriate text element, which we’ll refer to as an event indicator, is momentarily highlighted to indicate that the event has been triggered.
Let’s dig in and get the skinny on droppables using this Lab.
Exercise 1—In this exercise, we’re going to begin familiarizing ourselves with the accept option, which is what tells the droppable what constitutes an acceptable draggable.
Although this option can be set to any jQuery selector (or even a function that can programmatically make suitability determinations), for the purposes of the lab, we’ll concentrate on elements that possess particular class names.
In particular, we can specify a selector that includes any of the class names flower, dog, motorcycle, and water by checking the appropriate checkboxes of the accept option controls.
The six draggable image elements on the left side of the Test Subjects pane are each assigned one or two of these class names based on what appears in the image.
For example, the upper-left draggable possesses the class names dog and flower (because both a dog and some flowers appear in the photo), whereas the lower-middle image is defined with the class names motorcycle and water (a Yamaha V-Star and the Colorado River, to be precise)
Before clicking Apply, try to drag and drop any of these elements on the Drop Zone.
Carefully observe the event indicators, and note how they don’t change.
This should be no surprise because, at outset, no droppable even exists on the page.
Now, leaving all controls in their initial conditions (including all accept checkboxes checked), click the Apply button.
The executed command includes an accept option that specifies a selector that matches all four class names.
Once again, try to drag any of the images to the Drop Zone while observing the event indicators.
This time, you’ll see the Activate indicator briefly highlight, or throb, when you begin moving any of the images, indicating that a droppable has noticed that a drag operation has commenced using a draggable that’s acceptable for dropping, and has triggered a dropactivate event.
Drag the image over and out of the Drop Zone a number of times.
Corresponding dropover and dropout events are triggered (as shown by the corresponding indicators) at the appropriate times.
Now, drop the image outside the confines of the Drop Zone, and watch the Deactivate indicator throb.
Finally, repeat the drag operation, but this time drop the image on top of the Drop Zone.
The Drop indicator throbs (indicating that the drop event was triggered)
Note, also, that the Drop Zone is wired to display the most recent image that was dropped upon it.
Exercise 2—Uncheck all of the accept checkboxes, and click Apply.
This results in an accept option consisting of the empty string, which matches nothing.
No matter which image you choose, no callback indicators throb, and nothing happens when you drop an image onto the Drop Zone.
Without a meaningful accept option, our Drop Zone has become a brick.
Note that this isn’t the same as omitting accept, which causes all elements to be acceptable.
Exercise 3—Check only one accept checkbox, say flower, and note how only images with flowers in them (known to the page because the class name flower was defined for them) are construed to be acceptable items.
Try again with whatever combinations of acceptable class names you like until you’re comfortable with the concept of the accept option.
Exercise 4—Reset the controls, check the activeClass’s greenBorder radio button, and click Apply.
This supplies an activeClass option to the droppable that specifies a class name that defines (you guessed it) a green border.
Now, when you begin to drag an image that’s acceptable to the droppable (as defined by the accept option), the black border around the Drop Zone is replaced by a green border.
When an activeClass class name is applied, it must be able to override the rule that assigns the default visual rendition that you wish to supplant.
Sometimes the !important CSS qualifier is needed to override other style rules.
Exercise 5—Reset the Lab, check the hoverClass radio button labeled bronze, and click Apply.
When an acceptable image is dragged over the Drop Zone, the Drop Zone changes to a bronze color.
Continue to toy around with the lab page until you fully understand how drag-anddrop operations operate and are affected by the supported options.
Once we have dragging and dropping, we can imagine a whole range of user interactions where drag and drop can be used make things easy and intuitive for the user by letting them directly manipulate page elements.
One of those interactions, sorting, is so ubiquitous that jQuery UI provides direct support for it.
Arguably, sorting is one of the most useful interactions that utilizes drag and drop.
Putting a list of items into a specific order, or even moving them in order between lists, is a rather common interaction technique in desktop applications, but on the web it’s either been missing or approximated with a combination of <select> elements and buttons (to move items within, and sometimes between, multiple select lists)
Although such composite controls aren’t horrible, it’d be much more intuitive for a user to be able to directly manipulate the elements.
Drag and drop gives us that ability, and jQuery UI makes it pretty darn easy.
As with the draggable and droppable capabilities, jQuery UI provides sortability via a single, multi-purpose method, sortable(), whose syntax style should be familiar by now.
Parameters options (Object) An object hash of the options to be applied to the elements.
The sortability of the elements isn’t removed and can be restored by calling the enable variant of this method.
That’s a few more method variations than in the previous interactions, and we’ll examine some of those in detail, but first let’s make elements sortable.
That makes a lot of semantic sense and also allows the element to degrade gracefully should we decide not to apply sortability.
We’ll see how to do so when we examine the sortability options in table 10.5
Like the draggable and droppable interactions, sortability is applied by calling the sortable method with no parameters (to accept the defaults), or with an object that provides non-default options.
Note that this method won’t add sortability to any non-sortable elements.
If specified, at least the optionName parameter must also be provided.
This is most useful within handlers for the sortreceive and sortstop events.
Calling this method will cause new items added to the sortable to be recognized.
Unwise use can impair the performance of the operation, so use only within handlers when necessary to solve problems created by outdated cache information.
We’ll be examining the use of this method in more detail shortly.
If a value parameter is provided, that value becomes the option’s value.
If no value parameter is provided, the named option’s value is returned.
Returns The wrapped set, except for the cases where an option value, query string, or array is returned.
It should come as no surprise that quite a few of the options to sortable simply pass through to the lower-level drag or drop operations.
Figure 10.4 The Sortables Lab allows us to apply various sortability options to a list.
Sorting stuff description of these options isn’t repeated; rather, a reference to the table in which the option is first described is provided.
Most of these options are fairly self-explanatory, but the connectWith option deserves closer attention.
Appending to the body element may solve any issues with overlaying or zindex.
Frequently, this option is used to constrain movement to the orientation (horizontal or vertical) of the sorted list.
This allows items from one list to be moved to other lists—a frequent and useful user interaction.
The effect, when enabled, is for the drag helper to smoothly slide into place, as opposed to quickly snapping into place.
Table 10.5 Options for the jQuery UI sortable() method (continued)
It’s readily apparent how useful the sortable capability is for allowing users to order a single list of elements, but it’s also a common way to allow them to move items from one list to another.
This capability is frequently provided by a combination of two multi-select lists and a button (to move selected items from one list to another), and perhaps even more buttons to control the order of items within each of the lists.
Imagine, perhaps, a page in which we allow users to design reports that they’d like to receive.
There may be many possible data columns included in the report, but we can allow users to specify the subset of columns that they’d like included and the order in which they’d like them to appear.
We could include all possible columns in one list, and allow users to drag their desired columns from this list to a second list whose content represents the report’s columns in the order in which they’re to appear.
Code to set up this complex interaction could be as easy as this:
In the Sortables Lab page, you can experiment with dragging between two lists by checking the checkbox labeled connectWith.
With all those drag and drop operations going on—not to mention elements being moved around within (or between) lists—there are lots of events that we might want to know about so we can hook into what’s going on during a sort operation.
There’s a lot of moving and shaking during a sort operation; drag and drop events are firing, and the DOM is being manipulated—both to move elements around as the sort unfolds, and to handle any placeholder that we may have defined.
If all we care about is allowing the user to sort a list of items and then retrieve the result at a later point (which we’ll cover in the next section), we don’t need to be very concerned with all the events that are taking place during the operation.
But, as with draggables and droppables, if we want to hook into the operation during its interesting events, we can define handlers to be notified when these events take place.
As we’ve seen in the other interactions, we can establish these handlers either locally on the sortable via options passed to sortable(), or by establishing the handlers ourselves using bind()
The information passed to these handlers follows the customary interaction format, with the event as the first parameter, and a custom object with interesting information about the operation passed as the second.
Be aware that some of these properties may be undefined or null if they don’t make sense for the current state.
For example, there is no helper defined for the sortstop event because the drag operation is no longer underway.
The function context for these handlers is the element to which the sortable() method was applied.
The events that are triggered during a sort operation are shown in table 10.6
Note that a good number of these event types are triggered only during an operation involving connected lists; the number of events fired for a sort within a single list is fairly small.
The sortupdate event may be the most important because it can be used to let us know when a sort that has resulted in something actually changing has taken place.
If a sort operation takes place without anything changing, chances are we don’t really need to care.
When a sortupdate event fires, we probably want to know what the sorted order of the list is.
Any time we want to know what the sorted order of a sortables list is, there are two variants of the sortable() method that we can use, depending upon what type of information we need.
We can use this whenever we need to know the order of the items.
Using this variant requires that you use a specific format for the id values assigned to the sortable’s elements (the elements that will be sorted, not the sortable itself)
Each id needs to be of the format prefix_number where the prefix can be anything you want—as long as it’s the same for all the elements—followed by an underscore and a numeric value.
When this format is followed, serializing the sortable results in a query string that contains an entry for each sortable where the name is the prefix followed by [], and whose value is the trailing numeric value of the id.
In the Lab, leaving all options in their default state, click Apply, grab the orange tiger lily image (which has the id value subject_3), and drag it such that it becomes the first item in the list.
In the console, you’ll observe that the array of id values is now as follows:
This is exactly what we’d expect, showing the new order of the items with the third item now in the first position.
This shows how the prefix (subject) is used to construct the query parameter names, with the trailing numeric values becoming the parameter values.
The [], by the way, is a common notation meaning “array,” which is used to suggest that there are more than one of the same named parameters.
If this format isn’t to your liking, the array of ids can always be used as a basis to create your own query strings (in which case $.param() would come in quite handy)
As an exercise, hearken back to the “collapsible module” example in chapter 5 (when we animated the rolling up of a body into a caption bar)
How would you use sortables to let a user manage the position of a number of these modules (also termed portlets by some) in multiple columns?
With sortables, the basic drag and drop interactions have been combined to create a higher-order interaction.
Thinking again of the collapsible module example, in addition to allowing users to move these modules around on the page, wouldn’t it be nice to let them easily assign custom sizes to the modules?
With the interactions we’ve seen so far, the inclusion of the CSS file generated when you downloaded jQuery UI (which we discussed back in chapter 9) is not necessary.
But for the resizable interaction to function, the CSS file must be imported into the page, as in this example:
Other than that detail, the resizable() method is as easy to use as the other jQuery UI interactions, and its syntax follows the familiar pattern:
Nothing much new there—the overloaded interaction method’s pattern should be quite familiar by now—so let’s take a look at the options available when creating resizable elements.
One size rarely fits all, so as with the other interaction methods, the resizable() method offers a number of options that we can use to customize the interaction to our needs.
The Control Panel of this lab lets us play around with most of the options available for the resizable() method.
Follow along in this Lab as you read through the options list in table 10.7
As compared with some of the more involved interactions, resizable() has a modest set of options.
Parameters options (Object) An object hash of the options to be applied to the elements in the.
The resizability of the elements isn’t removed and can be restored by calling the enable variant of this method.
Note that this method won’t add resizability to any non-resizable elements.
If specified, at least the optionName parameter must also be provided.
If a value parameter is provided, that value becomes the option’s value.
If no value parameter is provided, the named option’s value is returned.
Returns The wrapped set, except for the cases where an option value, query string, or array is returned.
Figure 10.5 The Resizables Lab lets us see the operation of the various resizability options in action.
These other elements don’t need to have the resizable() method applied to them.
The standard animation strings slow, normal, or fast may be used, or the value can be specified as a number of milliseconds.
See chapter 5 for a more thorough discussion of easing.
A value of true enforces the original aspect ratio of the element, whereas a floating value can be used to specify the ratio using the formula width / height.
By default, no aspect ratio is maintained during the operation.
The built-in strings parent, or document can be specified, a specific element can be supplied, or you can use a selector to identify the containment element.
Only three simple events are triggered during a resize operation to let us know that a resize operation has started, that it’s underway, and that it has ended.
The information passed to these event handlers follows the customary interaction format of the event as the first parameter and a custom object with interesting information about the operation passed as the second.
These values can be supplied as a string with a comma-separated list of the possible values: n, ne, e, se, s, sw, w, nw, or all.
This format should be used when you want jQuery UI to handle the creation of the handles.
If you want to use child elements of the resizable as handles, supply an object with properties that define handles for each of the eight directions: n, ne, e, se, s, sw, w, and nw.
The value of the property should be a selector for the element to use as the handle.
We’ll address the handles a bit more after we talk about events.
If omitted, handles are created for the e, se, and s directions.
Helpers are enabled by using this option, but can also be implicitly enabled by other options such as ghost or animate.
Table 10.7 Options for the jQuery UI resizable() method (continued)
Be aware that some of these properties may be undefined or null if they don’t make sense for the current state.
The function context for these handlers is the element to which the resizable() method was applied.
The specific events that are triggered during a resize operation are summarized in table 10.8
The Resizables Lab uses these events to report the current position and size of the test subject elements in the Console pane of the Lab page.
Although resizable() is a fairly simple operation, at least as the jQuery UI interactions go, the handles deserve a bit of discussion of their own.
By default, handles are created for the east, southeast, and south directions, enabling resizing in those directions.
Any direction that has no resize handle defined isn’t enabled for resizing.
You might initially be confused by the fact that in your pages, as well as in the Resizables Lab, no matter how many directions are enabled, only the southeast corner gets a special “grip” icon when enabled.
And yet, all the other specified directions are enabled—they work fine, and the mouse cursor changes shape when the edge of the resizable is hovered over.
Figure 10.6 shows this grip handle, and the CSS handle that the mouse pointer displays when hovered near the resizable east edge.
If you find this too limiting, you can use the more complex version of the handles option to define child elements as handles that you can create yourself.
Now let’s take a look at the final interaction that jQuery UI provides.
Most of the interactions that we’ve examined so far involve direct manipulation of elements in order to change their state in some manner, be it to affect their position, size, or order within the DOM.
The selectable() interaction gives us the ability to set and clear a “selected” state on any DOM element.
In HTML forms, we’re used to using controls such as checkboxes, radio buttons, and yes, <select> elements to retain selection state.
In that example, we focused on the filtering set of controls, and didn’t pay much mind to the results returned from that filtering operation.
As a reminder, a screenshot of that example is shown in figure 10.7
The results (which, in the example, are the result of a hard-coded HTML fragment that in a real application would be generated from database information) are displayed as a list of elements on the page in a tabular format.
Figure 10.6 By default, jQuery UI places a “grip” handle in the southeast corner and uses CSS cursors for the other handles.
Let’s say that we wanted to allow users of DVD Ambassador to select one or more DVD titles and apply some sort of bulk operation upon them: deleting them from the database, for example, or perhaps marking them all as viewed or unviewed.
The traditional approach would be to add a checkbox control to every row, and to use it to indicate that the row is selected.
User interfaces shouldn’t be a game of hand-eye coordination, so we’d like to make it easier on our users.
We have the know-how to instrument the entire row with a click handler such that when the user clicks anywhere on the row, the handler finds the enclosed checkbox and toggles its value.
That gives the user a much bigger target to aim for, and the checkbox merely serves as a visual cue, and the means by which the selected state is remembered.
Figure 10.7 Revisiting the DVD Ambassador to instrument its result data set using jQuery UI selectables.
The elimination of the checkbox means that we’ll need to provide our own visual cues as to whether a row is selectable (without the checkbox, users have lost an important cue that we must make up for), and whether it is selected or not.
Changing the background color of the row is a conventional means to indicate changes in status, and it’s not a bad idea to also change the cursor shape to one that indicates that something wonderful will happened when the row is clicked upon.
With regards to remembering what’s selected and what’s not, jQuery UI selectables will maintain selection status using a class name (namely ui-selected) placed on selected elements.
With selectables, not only can we single-select with a click, but by dragging a rectangular marquee across the elements (or enclosing them, depending on how we set our options) our users will be able to select multiple adjacent elements in one fell swoop—much as we’re used to in many desktop applications.
Additionally, selectables allows elements to be added to an already selected set by holding down the Control key (the Command key on Macs) while clicking or dragging.
In this Lab, we use the DVD Ambassador tabular result set as the test subject.
Let’s try out a few interactions using the default options.
Exercise 1—Before changing anything or clicking any buttons, wave the mouse cursor over the data table, and try clicking on and dragging over the rows.
Note how the cursor pointer retains its normal appearance, and clicking has no effect at all.
Dragging just results in the normal browser selection of text.
Also note that as you click each row, causing it to become selected, any previously selected row becomes unselected.
Exercise 2—Without changing anything or clicking any buttons, select a row and then hold the Control/Command key down while selecting other rows.
Note how when the Control/Command key is depressed during a click, any previously selected elements are not unselected.
Exercise 3—Without changing anything or clicking any buttons, start a rectangular drag operation that cuts across a number of rows.
Be sure that the drag operation starts within a row.
Note that any row that the drag operation cuts across becomes selected.
Pressing the Control/Command key during a drag likewise causes any previous selection to be retained.
Figure 10.8 The Selectables Lab uses the HTML results fragment from the DVD Ambassador as its test subject.
Now that we’ve seen Selectables in action, let’s take a look at the selectable() method that makes it all happen:
The options that can be used when creating selectable elements are shown in table 10.9
Now that we’ve been introduced to the options, let’s try a few more exercises using the Selectables Lab.
Parameters options (Object) An object hash of the options to be applied to the elements in the.
The selectability of the elements isn’t removed and can be restored by calling the enable variant of this method.
Note that this method won’t add selectability to any non-selectable elements.
If specified, at least the optionName parameter must also be provided.
If a value parameter is provided, that value becomes the option’s value.
If no value parameter is provided, the named option’s value is returned.
Returns The wrapped set, except for the cases where an option value, query string, or array is returned.
This panel will display the events that take place during the select operations.
We’ll be discussing what information is passed to these events in the next section.
Although a selectable operation won’t make any changes to the position and size of selectable elements, they might have changed via CSS or scripting on the page.
If there are many selectable elements, this option can be disabled for performance, and the refresh method can be used to manually recompute the values.
Each of these elements is marked with the class ui-selectee.
This handler is passed the event, but no other information.
This handler is passed the event, but no other information.
If fit, a drag selection must completely encompass an element for it to be selected.
This can be problematic in some layouts because a drag selection must start within a selectable.
If touch, the drag rectangle only needs to intersect any portion of the selectable item.
Note that we can now select individual data cells as opposed to entire rows.
Exercise 6 —Change the value of the filter option to span, and click Apply.
Now click on the various text values within the data results.
Notice that only the text itself is selected rather than the entire cell.
Exercise 7—Reset the page, choose a tolerance value of touch, and click Apply.
Try various drag selections and note how the behavior hasn’t changed; any row that’s overlapped by the selection marquee becomes selected.
Now change the filter value to td and repeat the exercise, noting how any cell intersected by the marquee becomes selected.
Exercise 8—Leaving the filter value set at td, choose a tolerance value of fit, and click Apply.
Repeat the drag exercises and note how only cells that are completely enclosed by the marquee become selected.
Now change the filter value to tr, click Apply, and try again.
Any luck? Because a drag selection must begin within a selection, the tolerance setting requires that a selectable be completely enclosed to become selected, and the rows aren’t surrounded by other selectables, this combination makes it almost impossible to select any rows.
The list of options for selectable() is shorter than for the other interactions; in fact, the majority are shortcuts for establishing event handlers for the selectable events.
But those events are an important part of the selectables process.
For such a seemingly simple operation, a rich set of events is triggered during a selectable operation.
There aren’t only events that identify when the operation starts and stops, but when individual elements are selected or unselected, and even when elements are pending a change of selection state.
Unlike the other interaction events, selectable events don’t have a fixed construct that’s passed to the handlers.
Rather, the information, if any at all, is tuned to each event type.
Table 10.10 describes the selectable events and what data is passed to them.
If any of these events are unclear, especially the differences between events such as selecting and selected, repeat the exercises in the Selectables Lab, carefully observing the Console Pane to see how the events are triggered as selection operations of various types are carried out.
The event is passed as the first parameter to this handler, and an empty object is passed as the second.
The event is passed as the first parameter, and the second parameter is an object with a single property, selecting, that contains a reference to the element that’s about to become selected.
It’s not inevitable that an element reported by this event will eventually become selected.
If a user drags a marquee that includes an element, that element will be reported by this event.
But if the marquee is changed such that the element is no longer included, that element won’t become selected.
The event is passed as the first parameter, and the second parameter is an object with a single property, selected, that contains a reference to the element that has become selected.
The class name ui-selecting is removed and the class ui-selected is added to these elements.
The event is passed as the first parameter, and the second parameter is an object with a single property, unselecting, that contains a reference to the element that’s about to become unselected.
As with the selecting event, elements reported by this event won’t always become unselected.
The event is passed as the first parameter, and the second parameter is an object with a single property, unselected, that contains a reference to the element that has become unselected.
The event is passed as the only parameter to this handler.
The selectable event that’s bound most often is likely to be selectablestop, which informs us when a selection event has occurred and is concluded.
Within handlers for this event, we’ll almost invariably want to determine which elements ended up as selected.
Even if we’re not interested in the selections when the selection takes place, there almost always comes a time when we need to know what the selections are, such as when it comes time to contact the server.
The traditional state-retaining HTML controls submit their state as part of a form submission without any help on our part.
But if we need to communicate the selection state of our selectables as part of a form submission, or even as parameters to an Ajax request, we need to collect the selections.
You may recall that the sortables interaction provided a couple of methods that we could use to determine the final state of the sortables.
If we expected the same of selectables, we’ve been disappointed.
But only momentarily; the selected elements are so easy to obtain using jQuery selectors that a specialized method to fetch them isn’t necessary.
Because each selected element is marked with the class name ui-selected, fetching a wrapped set of all selected elements is as easy as this:
If we wanted to only grab selected <div> elements, we’d do this:
What we’ll probably want to do most often is collect the selected elements so that we can convey the selections to the server, much in the same way that checkboxes or radio buttons are conveyed using request parameters.
If we wanted to cause the selections to be submitted to the server as part of a form submission, an easy way to accomplish that is to add hidden <input> elements to the form just prior to submission, one for each selected element.
Let’s say that in our Selectables Lab, we wanted to submit all selected movie names as a request parameter array named title[]
We could accomplish that with the following code placed in the form’s submit handler:
As an exercise, write some code that would take the currently selected movie elements and submit them via an Ajax request using $.post()
As another exercise, capture the previous code sample that creates the hidden inputs on the form as a jQuery plugin method.
And that wraps up our examination of the jQuery UI interactions.
In this chapter we continued our examination of jQuery UI, focusing on the mouse interaction techniques that it provides.
We began with dragging, which provide a basic interaction used by the remaining interactions: dropping, sorting, resizing, and selecting.
We saw how the dragging interaction lets us free elements from the bounds of their page layout so that we can move them freely about the page.
Numerous options are available to customize the dragging behaviors to our needs (as well as to the needs of the remaining interactions)
The dropping interaction gives us something interesting to drop draggables on, in order to provide various user interface semantic actions.
One of those interactions is so common that it’s provided as an interaction of its own, sorting, which allows us to drag and drop elements to redefine their position within an ordered list, or even across multiple lists.
Not content with just letting us move things around, the resizing interaction lets us change the size of elements, with plenty of options to customize how and what can be resized.
And finally, we examined selecting, an interaction that lets us apply a persistent selected state to elements that don’t intrinsically have selectability.
Together, these interactions give us a lot of power to realize complex, but easy-touse, user interfaces to present to our users.
These interactions also serve as a basis for even more that jQuery UI has to offer.
In the next chapter, we’ll continue looking at jQuery UI, this time poking into the user interface widgets that it provides.
Since the dawn of the web, developers have been constrained by the limited set of controls afforded by HTML.
Although that set of controls runs the gamut from simple text entry through complex file selection, the variety of provided controls pales in comparison to those available to desktop application developers.
For example, how often have you heard the HTML <select> element referred to as a “combo box,” a desktop control to which it bears only a passing resemjQuery UI widgets: Beyond HTML controls.
Buttons and buttonsets blance? The real combo box is a very useful control that appears often in desktop applications, yet web developers have been denied its advantages.
But as computers have become more powerful, browsers have increased their capabilities, and DOM manipulation has become a commonplace activity, clever web developers have been taking up the slack.
By creating extended controls—either augmenting the existing HTML controls or creating controls from scratch using basic elements—the developer community has shown nothing short of sheer ingenuity in using the tools at hand to make the proverbial lemonade from lemons.
Standing on the shoulders of core jQuery, jQuery UI brings this ingenuity to us, as jQuery users, by providing a set of custom controls to solve common input problems that have traditionally been difficult to solve using the basic control set.
Be it making standard elements play well (and look good) in concert with other elements, accepting numeric values within a range, allowing the specification of date values, or giving us new ways to organize our content, jQuery UI offers a valuable set of widgets that we can use on our pages to make data entry a much more pleasurable experience for our users (all while making it easier on us as well)
Following our discussion of the core interactions provided by jQuery UI, we’ll continue our exploration by seeing how jQuery UI fills in some gaps that the HTML control set leaves by providing custom controls (widgets) that give us more options for accepting user input.
In this chapter, we’ll explore the following jQuery UI widgets:
Like the previous chapter, this is a long one! And as with interactions, the jQuery UI methods that create widgets follow a distinct pattern that makes them easy to understand.
But unlike interactions, the widgets pretty much stand on their own, so you can choose to skip around the sections in this chapter in any order you like.
We’ll start with one of the simpler widgets that lets us modify the style of existing control elements: buttons.
At the same time that we lament the lack of variety in the set of HTML 4 controls, it offers a great number of button controls, many of which overlap in function.
Moreover, the <button> element has subtypes of button, submit, and reset, whose semantics overlap those of the corresponding input element types.
The <button> element was added later; it can contain other elements and thereby offers more rendering possibilities.
The simpler <input> varieties were never deprecated, so we’ve ended up with the plethora of overlapping button types.
All these buttons types offer varying semantics, and they’re very useful within our pages.
But, as we’ll see when we explore more of the jQuery UI widget set, their default visual style may not blend well with the styles that the various widgets exhibit.
Remember back when we downloaded jQuery UI near the beginning of chapter 9? We were given a choice of various themes to download, each of which applies a different look to the jQuery UI elements.
To make our buttons match these styles, we could poke around the CSS file for the chosen theme and try to find styles that we could apply to the button elements to bring them more into line with how the other elements look.
But as it turns out, we don’t have to—jQuery UI provides a means to augment our button controls so their appearance matches the theme without changing the semantics of the elements.
Moreover, it will also give them hover styles that will change their appearance slightly when the mouse pointer hovers over them—something the unstyled buttons lack.
The button() method will modify individual buttons to augment their appearance, while the buttonset() method will act upon a set of buttons (most often a set of radio buttons or checkboxes) not only to theme them, but to make them appear as a cohesive unit.
This page fragment shows the unthemed display of some individual button elements, and some groupings of checkboxes, radio buttons, and <button> elements.
After applying the button() method to the individual buttons, and the buttonset() method to the button groups (in a page using the Cupertino theme), the display changes to that shown in figure 11.2
After styling, the new buttons make those shown in figure 11.1 look positively Spartan.
Not only has the appearance of the buttons been altered to match the theme, the groups have been styled so that the buttons in the group form a visual unit to match their logical grouping.
And even though the radio buttons and checkboxes have been restyled to look like “normal” buttons, they still retain their semantic behaviors.
We’ll see that in action when we introduce the jQuery UI Buttons Lab.
This theme’s styling is one we’ll become very familiar with as we progress through the jQuery UI widgets in the remainder of this chapter.
But first we’ll take a look at the methods that apply this styling to the button elements.
The methods that jQuery UI provides to create widgets follow the same style we saw in the previous chapter for the interaction methods: calling the button() method and passing an options hash creates the widget in the first place, and calling the same method again but passing a string that identifies a widget-targeted operation modifies the widget.
The syntax for the button() and buttonset() methods is similar to the methods we investigated for the UI interactions:
To apply button theming to a set of elements, we call the button() or buttonset() method with a set of options, or with no parameter to accept the default options.
The options that are available to use when creating buttons are shown in table 11.1
The button() method comes with plenty of options, and you can try them out in.
Follow along in this Lab as you read through the options list in table 11.1
Parameters options (Object) An object hash of the options to be applied to the elements in the.
If specified, at least the optionName parameter must also be provided.
If a value parameter is provided, that value becomes the option’s value.
If no value parameter is provided, the named option’s value is returned.
Returns The wrapped set, except for the case where an option value is returned.
Table 11.1 Options for the jQuery UI buttons and buttonsets.
The primary icon is identified by the primary property of the object, and the secondary icon is identified by the secondary property.
The values for these properties must be one of the 174 supported call names that correspond to the jQuery button icon set.
Figure 11.3 The jQuery UI Buttons Lab page lets us see the before and after states of buttons, as well as fiddle with the options.
You can show a single icon on the left (the primary icon), or one on the left and one on the right (as a secondary icon)
Icons are specified as a class name that identifies the icon.
For example, to create a button with an icon that represents a little wrench, we’d use this code:
If we wanted a star on the left, and a heart on the right, we’d do this:
Because we all know how many words a picture is worth, rather than just listing the available icon names here, we’ve provided a page that creates a button for each of the icons, labeled with the name of the icon.
You might want to keep this page handy for whenever you want to find an icon to use on your buttons.
Unlike the interactions and the remainder of the widgets, there are no custom events associated with jQuery UI buttons.
Because these widgets are merely themed versions of existing HTML 4 controls, the native events can be used as if the buttons had not been augmented.
To handle button clicks, we simply continue to handle click events for the buttons.
If omitted, the natural label for the element is displayed.
In the case of radio buttons and checkboxes, the natural label is the <label> element associated with the control.
If specified as false, text is suppressed if (and only if) the icons option specifies at least one icon.
Table 11.1 Options for the jQuery UI buttons and buttonsets (continued)
We can use these class names ourselves to augment or override the theme definitions on our pages.
For example, in the Button Icons page, the button text’s font size was adjusted like this:
The class name ui-button-text is applied to the <span> element that contains the button text.
It would be nearly impossible to cover all the permutations of elements, options, and class names for the widgets created by jQuery UI, so we’re not even going to try.
Rather, the approach that we’ll take is to provide, for each widget type, some tips on.
Figure 11.4 The jQuery UI Button Icons page lets us see all the available button icons along with their names.
The previous tip on restyling the button text is a good example.
Button controls are great for initiating actions, but except for radio buttons and checkboxes, they don’t represent values that we might want to obtain from the user.
A number of the jQuery UI widgets represent logical form controls that make it easy for us to obtain input types that have long been an exercise in pain.
Let’s take a look at one that eases the burden of obtaining numeric input.
Numeric input has traditionally been a thorn in the side of web developers everywhere.
The HTML 4 control set just doesn’t have a control that’s well suited to accepting numeric input.
A text field can be (and is most often) used to accept numeric input.
This is less than optimal because the value must be converted and validated to make sure that the user doesn’t enter “xyz” for their age or for the number of years they’ve been at their residence.
Although after-the-fact validation isn’t the greatest of user experiences, filtering the input to the text control such that only digits can be entered has its own issues.
Users might be confused when they keep hitting the A key and nothing happens.
In desktop applications, a control called a slider is often used whenever a numeric value within a certain range is to be obtained.
The advantage of a slider over text input is that it becomes impossible for the user to enter a bad value.
Any value that they can pick with the slider is valid.
A slider generally takes the form of a “trough” that contains a handle.
The handle can be moved along the trough to indicate the value selected within the range, or the user can click within the trough to indicate where the handle should move to within the range.
Figure 11.5 shows an example of a horizontal slider from a desktop application.
Unlike the button() method, sliders aren’t created by augmenting an existing HTML control.
The target <div> element is styled to form the trough of the slider, and anchor elements are created within it to form the handles.
The slider widget can possess any number of handles and can therefore represent any number of values.
Values are specified using an array, with one entry for each handle.
However, as the single-handle case is so much more common than the multi-handle case, there are methods and options that treat the slider as if it had a single value.
Figure 11.5 Sliders can be used to represent a range of values; in this example, from minimum to full brightness.
This prevents us from having to deal with arrays of a single element for the way that we’ll use sliders most often.
When creating a slider, there are a good variety of options for creating slider controls with various behaviors and appearance.
Parameters options (Object) An object hash of the options to be applied to the elements in the.
If specified, at least the optionName parameter must also be provided.
If a value parameter is provided, that value becomes the option’s value.
If no value parameter is provided, the named option’s value is returned.
If the values parameter is provided, sets the value for the handles.
Returns The wrapped set, except for the case where an option or handle value is returned.
Now let’s explore the events that slider controls can trigger.
Figure 11.6 The jQuery UI Sliders Lab shows the various ways that jQuery UI sliders can be set up and manipulated.
Can also be a duration value or one of the strings slow, normal, or fast.
See the description of the slider events in table 11.3 for details on the information passed to this handler.
If the slider has a single handle, specifying min or max creates a range element from the handle to the beginning or end of the slider respectively.
See the description of the slider events in table 11.3 for details on the information passed to this handler.
See the description of the slider events in table 11.3 for details on the information passed to this handler.
For example, a step value of 2 would allow only even numbers to be selected.
By default, step is 1 so that all values can be selected.
See the description of the slider events in table 11.3 for details on the information passed to this handler.
If there are multiple handles (see the values options), specifies the value for the first handle.
If omitted, the initial value is the minimum value of the slider.
As with the interactions, most of the jQuery UI widgets trigger custom events when interesting things happen to them.
We can establish handlers for these events in one of two ways.
We can bind handlers in the customary fashion at any point in the ancestor hierarchy, or we can specify the handler as an option, which is what we saw in the previous section.
For example, we might want to handle sliders’ slide events in a global fashion on the body element:
This allows us to handle slide events for all sliders on the page using a single handler.
If the handler is specific to an instance of a slider, we might use the slide option instead when we create the slider:
This flexibility allows us to establish handlers in the way that best suits our pages.
As with the interaction events, each event handler is passed two parameters: the.
In the Sliders Lab, the value and values properties are used to keep the value display below the slider up to date.
The events that sliders can trigger are summarized in table 11.3
The slidechange event is likely to be the one of most interest because it can be.
Let’s say that we have a single-handled slider whose value needs to be submitted to.
Let’s also suppose that a hidden input with a name.
This option should be an array of possible values, one for each handle.
Sliders of sliderValue is to be kept up to date with the slide value so that when the enclosing form is submitted, the slider’s value acts like just another form control.
We could establish an event on the form as follows:
Exercise 1—The preceding code is fine as long as there is only one slider in the form.
Change the preceding code so that it can work for multiple sliders.
How would you identify which hidden input element corresponds to the individual slider controls?
When an element is transformed into a slider, the class ui-slider is added to it.
Within this element, <a> elements will be created to represent the handles, each of which will be given the ui-slider-handle class.
We can use these class names to augment the styles of these elements as we choose.
In the Sliders Lab, create a slider and set focus to a handle by clicking upon it.
Now use the left and right arrow keys and see what happens.
This is a useful hook we can use to adjust the style of the slider based upon orientation.
In the Sliders Lab, for example, you’ll find the following style rules, which adjust the dimensions of the slider as appropriate to its orientation:
The class name testSubject is the class that’s used within the Lab to identify the element to be transformed into the slider.
Here’s another neat tip: let’s suppose that in order to match the rest of our site, we’d like the slider handler to look like a fleur-de-lis.
With an appropriate image and a little CSS magic, we can make that happen.
First, a PNG image with a transparent background and containing the fleur-de-lis was created, named handle.png.
Then the following style rule was added to the page:
Finally, after the slider was created, the fancy class was added to the handle.
One last tip: if you create a range element via the range option, you can style it using the ui-widget-header class.
We do so in the Lab page with this line:
Sliders are a great way to let users enter numeric values in a range without a lot of aggravation on our part or the user’s.
Let’s take a look at another widget that can help us keep our users happy.
Little irks a user more than sitting through a long operation without knowing whether anything is really happening behind the scenes.
Although users are somewhat more accustomed to waiting for things in web applications than in desktop applications, giving them feedback that their data is actually being processed makes for much happier, less anxious users.
Nothing good can come of a frustrated user clicking away on our interface and yelling, “Where’s my data!” at the screen.
The flurry of resulting requests will at best help to bog down our servers, and at worst can cause problems for the backend code.
When a fairly accurate and deterministic means of determining the completion percentage of a lengthy operation is available, a progress bar is a great way to give the user feedback that something is happening.
Figure 11.7 With a PNG image and a little CSS magic, we can make the slider handle look like whatever we want.
Visually, a progress bar generally takes the form of a rectangle that gradually “fills” from left to right with a visually distinct inner rectangle to indicate the completion percentage of an operation.
Figure 11.8 shows an example progress bar depicting an operation that’s a bit less than half complete.
Not surprisingly, progress bars are created using the progressbar() method, which follows the same pattern that’s become so familiar:
Parameters options (Object) An object hash of the options to be applied to the created progress.
When not to use progress bars Even worse than making the user guess when an operation will complete is lying to them about it.
Progress bars should only be used when a reasonable level of accuracy is possible.
If you can’t determine an accurate completion percentage, a good alternative to a progress bar is just some indication that something might take a long time; perhaps a text display along the lines of “Please wait while your data is processed—this may take a few minutes ...”, or perhaps an animation that gives the illusion of activity while the lengthy operation progresses.
For the latter, a handy website at http://www.ajaxload.info/ generates GIF animations that you can tailor to match your theme.
Figure 11.8 A progress bar shows the completion percentage of an operation by “filling” the control from left to right.
Progress bars are conceptually simple widgets, and this simplicity is reflected in the list of options available for the progressbar() method.
Once a progress bar is created, updating its value is as easy as calling the value variant of the method:
The options are simple enough, as are the events defined for progress bars.
The single event defined for progress bars is shown in table 11.5
Catching the progressbarchange event could be useful in updating a text value on the page that shows the exact completion percentage of the control, or for any other reason that the page might need to know when the value changes.
If specified, at least the optionName parameter must also be provided.
If a value parameter is provided, that value becomes the option’s value.
If no value parameter is provided, the named option’s value is returned.
Returns The wrapped set, except for the case where a value is returned.
See the description of the progress bar events in table 11.5 for details on the information passed to this handler.
The progress bar is so simple—only two options and one event—that a Lab page for this control has not been provided.
Rather, we thought we’d create a plugin that automatically updates a progress bar as a lengthy operation progresses.
When we fire off an Ajax request that’s likely to take longer to process than a normal person’s patience will accept, and we know that we can deterministically obtain the completion percentage, it’s a good idea to comfort the user by displaying a progress bar.
Let’s think of the steps we’d run through to accomplish this:
Use the result to update the progress bar and any text display of the completion percentage.
Sounds pretty easy, but there are a few nuances to take into account, such as making sure that the interval timer is destroyed at the right time.
As this widget is something that could be generally useful across many pages, and because there are non-trivial details to take into account, creating a plugin that’s going to handle this for us sounds like a great idea.
We call our plugin the auto-progressbar, and its method, autoProgressbar(), is defined as follows:
Two parameters are passed: the event instance, and an empty object.
The latter is passed in order to be consistent with the other jQuery UI events, but no information is contained within the object.
Parameters options (Object) An object hash of the options to be applied to the created progress.
The options that we’ll define for our plugin are shown in table 11.6
The first thing we’ll want to do is check to see if the first parameter is a string or not.
If it’s a string, we’ll use the string to determine which method to process.
If it’s not a string, we’ll assume it’s an options hash.
Returns The wrapped set, except for the case where a value is returned.
If this option is omitted, the method performs no operation.
Because processing the options is the meat of our plugin, we’ll start by tackling the else part.
First, we’ll merge the user-supplied options with the set of default options, as follows:
As in previous plugins that we’ve developed, we use the $.extend() function to merge the objects.
Note also that we continue with the practice of listing all options in the default hash, even if they have a null value.
This makes for a nice place to see all the options that the plugin supports.
After the merge, if the pulseUrl option hasn’t been specified, we return, performing no operation—if we don’t know how to contact the server, there’s not much we can do.
Now it’s time to actually create the progress bar widget:
Remember, within a plugin, this is a reference to the wrapped set.
We call the jQuery UI progress bar method on this set, specifying an initial value of 0, and passing on any change handler that the user supplied.
For each element in the wrapped set (chances are there will only be one, but why limit ourselves?) we want to start an interval timer that will check the status of the lengthy operation using the supplied pulseUrl.
There’s a lot going on here, so let’s take it one step at a time.
We want each progress bar that will be created to have its own interval timer.
We use the each() method B to deal with each wrapped element separately.
For both readability, as well as for use within closures that we’ll later create, we capture the wrapped element in the bar$ variable.
We then want to start the interval timer, but we need to keep in mind that later on we’re going to want to stop the timer.
So we need to store the handle that identifies the timer somewhere that we can easily get at later.
To this function we pass an inline function that we want to execute on every tick of the timer, and the interval value that we obtain from the interval option.
Within the timer callback, we fire off an Ajax request E to the URL supplied by the pulseUrl option, with any data supplied via pulseData.
We also turn off global events (these requests are happening behind the scenes, and we don’t want to confuse the page by triggering global Ajax events that it should know nothing about), and specify that we’ll be getting JSON data back as the response.
Finally, in the success callback for the request F, we update the progress bar with the completion percentage (which was returned as the response and passed to the callback)
If the value has reached 100, indicating that the operation has completed, we stop the timer by calling our own stop method.
In the if part of the high-level conditional statement (the one that checked to see if the first parameter was a string or not), we write this:
In this code fragment, we switch to different processing algorithms based on the string in the settings parameter B, which should contain one of: stop, value, or destroy.
For stop we want to kill off all the interval timers that we created for the elements in the wrapped set C.
If the method was specified as value, we simply pass the value along to the value method of the progress bar widget.
When destroy is specified, we want to stop the timer, so we just call our own stop method (why copy and paste the same code twice?), and then we destroy the progress bar.
And we’re done! Note how whenever we return from any call to our method, we return the wrapped set so that our plugin can participate in jQuery chaining just like any other chainable method.
In the interest of saving some space, we won’t examine every line of code in that file, but we will concentrated on the portions relevant to using our plugin.
First, let’s look at the markup that creates the DOM structures of note:
A Start button that will start a lengthy operation and use our plugin to monitor its progress.
In action, our test page will look like figure 11.9
Instrumenting the Start button is the most important operation on this page, and that’s accomplished with the following script:
Within the click handler for the Start button, we do two things: kick off the lengthy operation, and create the auto-progressbar.
We’ll get to the success callback in a moment, but first let’s skip ahead to the creation of the auto-progressbar.
We call our new plugin D with values that identify a server-side resource, /jqia2/ checkProgress, which identifies the process that checks the status of our long-running process and returns the completion percentage as its response.
How this is done on the server is completely dependent upon how the backend of the web application is written and that’s well beyond the scope of this discussion.
For our example, two separate servlets are used, using the servlet session to keep track of progress.
Figure 11.9 The auto-progressbar is monitoring a long-running operation on the server.
Autocompleters change handler for the progress bar causes the onscreen display of the completion value to be updated.
Now let’s backtrack to the success handler for the long-running operation C.
When the operation completes, we want to do two things: stop the progress bar, and make sure that the progress bar reflects that the operation is 100 percent done.
We easily accomplish this by first calling the stop method of our plugin, followed by a call to the value method.
The change handler for the progress bar will update the text display accordingly.
We’ve created a really useful plugin using a progress bar.
We can use these class names for CSS rules that augment the style of these elements as we see fit.
For example, you might want to fill the background of the inner element with an interesting pattern, rather than the theme’s solid color:
Or you could make the progress bar even more dynamic by supplying an animated GIF image as the background image.
Progress bars calm the psyches of our users by letting them know how their operations are progressing.
Next, let’s delight our users by limiting how much they need to type to find what they’re looking for.
The contemporary acronym TMI, standing for “too much information,” is usually used in conversation to mean that a speaker has revealed details that are a tad too intimate for the listening audience.
In the world of web applications, “too much information” refers not to the nature of the information, but the amount.
Although having the vast amount of information that’s available on the web at our fingertips is a great thing, it really is possible to have too much information—it’s easy to get overwhelmed when fed a deluge of data.
Another colloquial expression that describes this phenomenon is “drinking from a fire hose.”
When designing user interfaces, particularly those for web applications, which have the ability to access huge amounts of data, it’s important to avoid flooding a user with too much data or too many choices.
When presenting large data sets, such as report data, good user interfaces give the user tools to gather data in ways that are useful and helpful.
For example, filters can be employed to weed out data that isn’t relevant to the user, and large sets of data can be paged so that they’re presented in digestible chunks.
This is exactly the approach taken by our DVD Ambassador example.
As an example, let’s consider a data set that we’ll be using in this section: a list of DVD titles, which is a data set consisting of 937 titles.
It’s a large set of data, but still a small slice of larger sets of data (such as the list of all DVDs ever made, for example)
Suppose we wished to present this list to users so that they could pick their favorite flick.
We could set up an HTML <select> element that they could use to choose a title, but that would hardly be the friendliest thing to do.
Most usability guidelines recommend presenting no more than a dozen or so choices to a user at a time, let alone many hundreds! And usability concerns aside, how practical is it to send such a large data set to the page each time it’s accessed by potentially hundreds, thousands, or even millions of users on the web?
The jQuery autocomplete widget augments an existing <input> text element to fetch and present a menu of possible choices that match whatever the user types into the input field.
What constitutes a match depends on the options we supply to the widget upon creation.
Indeed, the autocomplete widget gives us a great deal of flexibility in how to provide the list of possible choices, and how to filter them given the data supplied by the user.
Parameters options (Object) An object hash of the options to be applied to the elements in the.
If specified, at least the optionName parameter must also be provided.
For such a seemingly complex control, the list of options available for autocomplete controls is rather sparse, as described in table 11.7
If a value parameter is provided, that value becomes the option’s value.
If no value parameter is provided, the named option’s value is returned.
Supply an empty string to see a menu of all possibilities.
Returns The wrapped set, except for the case where an option, element, search result, or handle value is returned.
See the description of the autocomplete events in table 11.8 for details on the information passed to this handler.
See the description of the autocomplete events in table 11.8 for details on the information passed to this handler.
This can help reduce thrashing when non-local data is being obtained by giving the user time to enter more characters before the search is initiated.
See the description of the autocomplete events in table 11.8 for details on the information passed to this handler.
This can prevent too large a value set from being presented when a few characters isn’t enough to whittle the set down to a reasonable level.
See the description of the autocomplete events in table 11.8 or details on the information passed to this handler.
As you might have guessed, an Autocompleters Lab (shown in figure 11.10) has been provided.
Leaving the source option at its default setting, use the Autocompleters Lab to observe the events that transpire and the behavior of the minLength and delay options until you feel that you have grasped them.
Now let’s see what it takes to provide source data for this widget.
The autocomplete widget gives us a lot of flexibility for providing the data values that match whatever the user types in.
Source data for the autocompleters takes the form of an array of candidate items, each of which has two properties:
These are the strings that are matched against as the user types into the control, and they’re the values that will be injected into the control when a menu item is selected.
A label property that represents the value, usually as a shorter form.
These strings are what is displayed in the autocomplete menu, and they don’t participate in the default matching algorithms.
See the description of the autocomplete events in table 11.8 for details on the information passed to this handler.
See the description of the autocomplete events in table 11.8 for details on the information passed to this handler.
A value must be provided or the autocomplete widget won’t be created.
This value can be a string representing the URL of a server resource that will return matching data, an array of local data from which the value will be matched, or a function that serves as a general callback from providing the matching values.
For cases where the data set is fairly small (dozens, not hundreds or more), the.
The following example is taken from the Autocompleters Lab and provides candidate data that uses usernames as labels and full names as the values:
When displayed, the labels (usernames) are what appear in the autocomplete menu, but matching is performed on the values (full names), and the value is what is set into the control upon selection.
This is handy when we want to represent longer data with shorter values in the menus, but for many cases, perhaps even most, the label and the value will be the.
Figure 11.10 The jQuery UI Autocompleters Lab shows us how a large result set can be narrowed down as more data is entered.
For these common cases, jQuery UI lets us specify the data as an array of strings, and takes the string value to be both the label and the value.
The entries don’t have to be in any particular order (such as sorted) for the widget to work correctly, and matching entries will be displayed in the menu in the order that they appear within the array.
When local data is used, the matching algorithm is such that any candidate value that contains what the user has typed, called the term, is deemed to match.
If this isn’t what you want—let’s say you only want to match values that begin with the term—fear not! There are two more-general ways to supply the source data that give us complete control over the matching algorithm.
For the first of these schemes, the source can be specified as the URL of a serverside resource that returns a response containing the data values that match the term, which is passed to the resource as a request parameter named term.
The returned data should be a JSON response that evaluates to one of the formats supported for local data, usually an array of strings.
Note that this variant of source is expected to perform the search and return only the matching elements—no further processing of the data will take place.
Whatever values are returned are displayed in the autocomplete menu.
When we need maximum flexibility, another scheme can be used: a callback function can be supplied as the source option, and it’s called whenever data is needed by the widget.
This callback mechanism offers the most flexibility, because we can use whatever mechanisms and algorithms we want to turn the term into a set of matching elements.
A skeleton for how to use this variant of source is as follows:
As with the URL variant of source, the result should contain only those values that are to be displayed in the autocomplete menu.
Play around with the source options in the Autocompleters Lab.
A few things to note about the different source options in the Lab:
The local string option provides a list of 79 values, all of which begin with the letter F.
The local object option provides a short list of usernames for labels, and full names as values.
Note how the matching occurs on the values, not the labels.
For the URL variant, the backend resource only matches values that begin with the term.
It uses a different algorithm than when local values are supplied (in which the term can appear anywhere within the string)
This difference is intentional and is intended to emphasize that the backend resource is free to employ whatever matching criteria it likes.
The callback variant simply returns the entire value set of 79 F-titles provided by the local option.
Make a copy of the Lab page, and modify the callback to play around with whatever algorithm you’d like to filter the returned values.
Various events are triggered while an autocomplete widget is doing its thing.
During an autocomplete operation, a number of custom events are triggered, not only to inform us of what’s going on, but to give us a chance to cancel certain aspects of the operation.
As with other jQuery UI custom events, two parameters are passed to the event handlers: the event and a custom object.
For the focus, change, and select events, this object contains a single property named item, which in turn contains the properties label and value, representing the label and value of the focused or selected value.
For all the event handlers, the function context (this) is set to the <input> element.
When triggered, this event will always come after the autocompleteclose event is triggered.
Unless canceled (for example, by returning false), the focused value is set into the <input> element.
The Autocompleters Lab uses all of these events to update the console display as the events are triggered.
Now let’s take a look at dressing up our autocompleters.
As with the other widgets, autocompleters inherit style elements from the jQuery UI CSS theme via the assignment of class names to the elements that compose the autocompleter.
When the autocomplete menu is created, it’s created as an unordered list element (<ul>) with class names ui-autocomplete and ui-menu.
The values within the menu are created as <li> elements with class name ui-menu-item.
And within those list items, anchor elements are created that get the ui-state-hover class when hovered over.
We can use these classes to hook our own styles onto the autocomplete elements.
For example, let’s say that we want to give the autocomplete menu a slight level of.
The autocomplete menu can end up pretty big if there are lots of matches.
Note that ui-menu-item isn’t a class name specific to the autocompleter (if it were, it would have the text autocomplete within it), so we qualify it with ui-autocomplete and ui-menu to make sure we don’t inadvertently apply the style to other elements on the page.
Canceling this event prevents the value from being set into the <input> element (but doesn’t prevent the menu from closing)
What if we really wanted to make hovered items stand out? We could change their border to red:
Autocompleters let us let our users hone down large datasets quickly, preventing information overload.
Now let’s see how we can simplify yet another long-standing pain point in data entry: dates.
Entering date information has been another traditional source of anxiety for web developers and frustration for end users.
A number of approaches have been tried using the basic HTML 4 controls, all of which have their drawbacks.
Many sites will present the user with a simple text input into which the date must be entered.
But even if we include instructions such as, “Please enter the date in dd/ mm/yyyy format”, people still tend to get it wrong.
How many times have you wanted to throw your computer across the room upon discovering, after 15 failed attempts, that you had to include leading zeroes when entering a single digit date or month value?
Another approach uses three dropdowns, one each for month, day, and year.
Although this vastly reduces the possibility of user error, it’s clumsy and requires a lot of clicks to choose a date.
When people think of dates, they think of calendars, so the most natural way to have them enter a date is to let them pick it from a calendar display.
Frequently called calendar controls or date pickers, scripts to create these controls have been around for some time, but they’ve generally been cantankerous to configure, and awkward to use on pages, including trying to match styling.
Leave it to jQuery and jQuery UI to make it easy with jQuery UI datepickers.
Creating a jQuery datepicker is easy, especially if you take the default values.
It may only seem complex because there are lots of options for configuring the datepicker in the manner that best suits our applications.
For <input> elements, the datepickeris displayed on focus; for other elements, creates an inline datepicker.
Parameters options (Object) An object hash of the options to be applied to the elements in the.
If specified, at least the optionName parameter must also be provided.
If a value parameter is provided, that value becomes the option’s value.
If no value parameter is provided, the named option’s value is returned.
If omitted, the dialog box is centered in the window.
Seemingly to make up for the Spartan set of options available for autocompleters, datepickers offer a dizzying array of options that make it the most configurable widget in the jQuery UI set.
Don’t get too overwhelmed; frequently the defaults are just what we want.
But the options are there in case we need to change the way the datepicker works to better fit into our sites.
But all those options do make for a rather complicated Datepickers Lab page—as shown in figure 11.11
As you work your way through the generous set of options described in table 11.9, try them out in the Datepickers Lab.
Absolute dates are specified using the date format for the control (specified by the dateFormat option, see table 11.9), or a string of values specifying a date relative to today.
The values are numbers followed by m for month, d for day, w for week, and y for year.
Returns The wrapped set, except for the cases where values are returned, as described above.
Figure 11.11 The jQuery UI Datepickers Lab helps us grasp the copious variety of options available for datepicker controls (too many to fit into one screenshot)
The altFormat option can be used to set the format for this value.
This is quite useful for setting date values into a hidden input element to be submitted to the server, while displaying a more user-friendly format to the user.
This function can return an options hash used to modify the datepicker.
This can be used to override some of the default behavior of the day elements.
An optional string to apply a tooltip to the day element.
If buttonText is also provided, the button text becomes the alt attribute of the button.
The showOn option must still be set to one of button or both for the image to appear.
If buttonImage is also specified, this text becomes the alt attribute of the image.
The default set is the full day names in English.
The default set is the first two letters of the English day names.
The default set is the first three letters of the English day names.
This can be a Date instance, the number of days from today, or a string specifying an absolute or relative date.
See the description of the date parameter in the method syntax for the datapicker() method for more details.
Can be one of slow, normal, (the default) or fast, or the number of milliseconds for the animation to span.
Date pickers hideIfNoPrevNext (Boolean) If true, hides the next and previous links (as opposed to merely disabling them) when they aren’t applicable, as determined by the settings of the minDate and maxDate options.
This can be a Date instance, the number of days from today, or a string specifying an absolute or relative date.
See the description of the date parameter in the datepicker setDate method syntax for more details.
This can be a Date instance, the number of days from today, or a string specifying an absolute or relative date.
See the description of the date parameter in the method syntax for the datapicker() method for more details.
The default set is the full month names in English.
The default set is the first three letters of the English month names.
This allows date formats to be supplied for those options that get replaced with the relevant values.
Note that the ThemeRoller replaces this text with an icon.
Note that the ThemeRoller replaces this text with an icon.
Such days aren’t displayed unless the showOtherMonths option is true.
If a string, the value undergoes a numeric conversion and is added to the current year.
If specified, must be one of show (the default), fadeIn, slideDown, or any of the jQuery UI show/hide animations.
The caption of these buttons can be provided via the currentText and closeText options.
The button’s appearance can be varied with the buttonText, buttonImage, and buttonImageOnly options.
Still with us? Although that may seem rather overwhelming when taken as a whole, the vast.
It’s not uncommon to create datepickers while specifying no options at all.
A number of the datepicker options listed in table 11.9 employ a string that represents a date format.
These are strings that specify a pattern for formatting and parsing dates.
Character patterns within the string represent parts of dates (for example, y for year, and MM for full month name) or simply template (literal) text.
Table 11.10 shows the character patterns used within date format patterns and what they represent.
These dates aren’t selectable unless the selectOtherMonths option is also set to true.
The calculateWeek option can be used to alter the manner in which this value is determined.
The prefix c can be used to make relative values offset from the selected year rather than the current year (example: c2:c+3)
The datepicker defines some well-known date format patterns as constant values, as shown in table 11.11
We’ll be addressing these patterns again when we discuss the datepicker utility functions in section 11.5.4
Now let’s turn our attention to the events that datepickers trigger.
Surprise! There aren’t any! The datepicker code in jQuery UI 1.8 is some of the oldest in the code base, and it.
Expect this to change in a future version of jQuery UI, to the point that the jQuery UI roadmap (which you can find at http://wiki.jqueryui.com/ Roadmap) states that the widget will be completely rewritten for version 2.0
For now, the options that allow us to specify callbacks when interesting things happen to a datepicker are beforeShow, beforeShowDay, onChangeMonthYear, onClose, and onSelect.
All the callbacks invoked via these options have the <input> elements set as their function contexts.
Although datepickers may lack the event triggering that other widgets sport, they do give us some extras: a handful of useful utility functions.
Just think of the nuances of dealing with years and leap years, months of differing lengths, weeks that don’t divide into months evenly, and all the other oddities that plague date information.
Luckily for us, the JavaScript Date implementation handles most of those details for us.
But there are a few areas where it falls short—the formatting and parsing of date values being two of them.
The jQuery UI datepicker steps up to the plate and fills in those gaps.
In the guise of utility functions, jQuery UI provides the means to not only format and parse date values, but also to make the large number of datepicker options a bit easier to handle for pages with more than one datepicker.
When our datepickers need to use multiple options to get the look and behavior we want, it seems just plain wrong to cut and paste the same set of options for every datepicker on the page.
We could store the options object in a global variable and reference it from every datepicker creation, but jQuery UI lets us go one better by providing a means to simply register a set of default options that supersedes the defined defaults.
Parameters options (Object) An object hash of the options to be used as the defaults for all.
As you’ll recall from the list of datepicker options, some of the options specify formats for how date values are to be displayed.
That’s a useful thing to be able to do in general, and jQuery UI makes it available directly to us.
That sort of obsoletes the date formatter we set up in chapter 7! But that’s OK, we learned a lot from that exercise, and we can always use it in projects that don’t use jQuery UI.
What other tricks does the datepicker have up its sleeve for us?
As useful as formatting date values into text strings is, it’s just as useful—if not even more so—to convert text strings into date values.
There’s one more utility function that the datepicker makes available.
The possible options are shortYearCutoff, dayNames, dayNamesShort, monthNames, and monthNamesShort.
If omitted, the default English names are used, and the rollover year is +10
We’ve seen jQuery UI widgets that allow us to gather data from the user in an intuitive manner, so we’re now going to turn our attention to widgets that help us organize our content.
If your eyes are getting bleary at this point, now might be a good time to sit back for a moment and enjoy a snack; preferably one containing caffeine.
When you’re ready, let’s forge on ahead to examine one of the most common organization metaphors on the web—tabs.
As a navigation method, they’ve become ubiquitous on the web, surpassed only by links themselves.
Mimicking physical card index tabs, GUI tabs allow us to quickly flip between sets of content logically grouped at the same level.
In the bad old days, switching between tabbed panels required full-page refreshes, but today we can just use CSS to show and hide elements as appropriate, and even employ Ajax to fetch hidden content on an as-needed basis.
As it turns out “just using CSS” turns out to be a fair amount of work to get right, so jQuery UI gives us a ready-made tabs implementation that, of course, matches the downloaded UI theme.
Tabs, by nature, start with a more complex HTML construct.
A canonical construct for a tabset with three tabs should follow this pattern:
Parameters date (Date) The date whose week number is to be calculated.
Each list item that represents a tab contains an anchor element (<a>) that not only defines the association between the tab and its corresponding panel, but also serves as a focusable element.
The href attribute of these anchors specifies an HTML anchor hash, useable as a jQuery id selector, for the panel that it’s to be associated with.
Each tab’s content can alternatively be fetched from the server via an Ajax request upon first selection.
In this case, the href of the anchor element specifies the URL of the active content, and it isn’t necessary to include a panel in the tabset.
If we were to create the markup for a three-tab tabset where all the content is fetched from the server, the markup could be as follows:
In this scenario, three <div> elements serving as panels to hold the dynamic content will be automatically created.
You can control the id values assigned to these panel elements by placing a title attribute on the anchor.
The value of the title, with spaces replaced by underscores, will be the id of the corresponding panel.
You can precreate the panel using this id, and the tab will be correctly hooked up to it, but if you don’t, it will be automatically generated.
Tabs the id value of the corresponding panel would be a_third_panel.
If such a panel already exists, it will be used; otherwise, it will be created.
Ajax and non-Ajax tabs can be freely mixed in a single tabset.
Once we have the base markup all squared away, we’ll create the tabset with the.
Parameters options (Object) An object hash of the options to be applied to the tabset, as.
A backdoor method to disable any set of tabs is to use the data() method to set a data value of disabled.tabs onto the widget element consisting of an array of zero-based indexes of the tabs to be disabled.
If a zero-based index is provided, the identified tab is enabled.
All tabs can be enabled by using the backdoor trick outlined above, specifying an empty array.
If specified, at least the optionName parameter must also be provided.
If a value parameter is provided, that value becomes the option’s value.
If no value parameter is provided, the named option’s value is returned.
Used with disable, enable, remove, select, add, load, and url.
As might be expected for such a complex widget, there are a fair number of options (see table 11.12)
As usual, we’ve provided a Tabs Lab to help you sort through the tabs() method options.
Alternatively, you can run this Lab remotely by visiting http://www.bibeault.org/jqia2/chapter11/tabs/lab.tabs.html.
The options available for the tabs() method are shown in table 11.12
The index parameter specifies the existing tab before which the new tab will be inserted.
If no index is provided, the tab is placed at the end of the tab list.
This can be an id selector for an existing element to become the panel, or the URL of a server-side resource to create an Ajax tab.
Returns The wrapped set, except for the cases where values are returned as described above.
Figure 11.12 The jQuery UI Tabs Lab page shows us how tabs can be used to organize content into panels for serial display.
See the description of the tab events in table 11.13 for details on the information passed to this handler.
By default, clicking on an already selected tab has no effect.
The properties of this object are those expected by the cookie plugin: name, expires (in days), path, domain, and secure.
See the description of the tab events in table 11.13 for details on the information passed to this handler.
See the description of the tab events in table 11.13 for details on the information passed to this handler.
Most often this is one of click (the default) or mouseover, but events such as mouseout can also be specified (even if a bit strange)
A duration property can be used to specify the duration with any value suitable for the animation method: milliseconds, normal (the default) , slow, or fast.
See the description of the tab events in table 11.13 for details on the information passed to this handler.
We trust that you’ve become experienced enough with the various Lab pages presented throughout this book to not need any help working through the basic options in the Tabs Lab.
But there are some important nuances we want to make sure you understand around Ajax tabs, so here are a few Lab exercises that you should do after playing around with the basic options:
Exercise 1—Bring up the Lab and, leaving all controls in their default state, click Apply.
The Food and Slow tabs are Ajax tabs whose panels aren’t loaded until the tabs are selected.
This tab is simply loaded from an HTML source and appears instantaneously.
This indicates that the content was loaded from the server.
Click the Flowers tab and then click the Food tab again.
Note how another tabsload event was triggered as the content was loaded again from the server.
This could be the result of an add method or automatic creation for an Ajax tab.
See the description of the tab events in table 11.13 for details on the information passed to this handler.
See the description of the tab events in table 11.13 for details on the information passed to this handler.
The value -1 can be used to cause no tabs to be initially selected.
See the description of the tab events in table 11.13 for details on the information passed to this handler.
The embedded HTML entity is the Unicode character for an ellipsis.
In order for the spinner to appear, the content of the tabs anchor element must be a <span> element.
Exercise 3—Reset the Lab and, leaving all controls in their default state, click Apply.
Repeat exercise 1 except click on the Slow tab instead of the Flowers tab.
The Slow tab is loaded from a server-side resource that takes about 10 seconds to load.
Note how the default spinner value of “Loading ...” is displayed during the lengthy load operation, and how the tabsload event isn’t delivered until the content has been received.
Exercise 4—Reset the Lab and, choosing the Image value for the spinner option, click Apply.
This supplies the HTML for an <img> element that’s displayed in the tab while loading.
There are many reasons that we may want to be notified when users are clicking on our tabs.
For example, we may want to wait to perform some initialization events on tabbed content until the user actually selects the tab.
After all, why do a bunch of work on content that the user may not even look at? The same goes with loaded content.
There may be tasks we want to perform after the content has been loaded.
As an example, let’s say we wanted to add a class name to all image elements in a tabbed panel that loaded via Ajax.
We could do that with a single tabsload handler established on the tabset:
The important points to take away from this small example are.
Now let’s turn our attention to what CSS class names are added to the elements so we can use them as styling hooks.
When a tabset is created, the following CSS class names are applied to various participating elements:
Do you think that the tabs are too big in their default rendition? Shrink them down to size with a style rules such as this:
Do you want your selected tabs to really stand out? Try this:
Tabs are a great and ubiquitous widget for organizing panels of related content so that users only see a single panel at a time.
But what if they’re a bit too ubiquitous and you want to achieve the same goal but with a less common look and feel?
Although the term accordion might conjure images of mustached men playing badly delivered tableside serenades, it’s actually an apt name for the widget that presents content panels one at a time (just like tabs) in a layout reminiscent of the bellows of the actual instrument.
Rather than having a set of tabs across the top of an area that displays the panels, accordions present choices as a stacked series of horizontal bars, each of whose content is shown between the associated bar and the next.
If you’ve been using the index page for the code examples (index.html in the root folder), you’ve already seen an accordion in action, as shown in figure 11.13
Like a tabset, only one panel can be open at a time, and, by default, accordions also adjust the size of the panels so that the widget takes up the same amount of room no matter which panel is open.
Let’s take a look at what it takes to create one.
As with the tabset, the accordion expects a particular HTML construct that it will instrument.
Because of the different layout of the accordion, and to make sure things degrade gracefully in the absence of JavaScript, the structure of the source for an accordion is rather different from that for a tabset.
The accordion expects an outer container (to which the accordion() method is applied) that contains pairs consisting of a header and associated content.
Figure 11.13 We used an accordion widget to organize the links to the many code examples for this book.
A typical construct for an accordion could look like the following:
Note that the header text continues to be embedded within an anchor—in order to give the user a focusable element—but the href is generally set to # and isn’t used to associate the header to its content panel.
There is one option where the anchor’s href value is significant, but generally they’re just set to #
Parameters options (Object) An object hash of the options to be applied to the accordion, as.
If specified, at least the optionName parameter must also be provided.
If a value parameter is provided, that value becomes the option’s value.
If no value parameter is provided, the named option’s value is returned.
The short, but capable, list of options available for the accordion() method is shown in table 11.14
Follow along in this Lab as you read through the options list in table 11.14
This should be called whenever something occurs that may cause the widget size to change; for example, resizing its container.
Returns The wrapped set, except for the cases where values are returned as described above.
This can be the zero-based index of the panel, or a means to identify the header element for the panel: an element reference, a selector, or a jQuery wrapped set.
If specified as false, no panel is initially opened unless the collapsible options is set to false.
One of: slide (the default), bounceslide, or any of the installed easings (if included on the page)
The autoHeight option must be set to false for this to apply.
See the description of the accordion events in table 11.15 for details on the information passed to this handler.
See the description of the accordion events in table 11.15 for details on the information passed to this handler.
By default, clicks on the open panel’s header have no effect.
After you’ve run through the basic options and tried out things in the Accordions Lab, here are a couple of exercises we want to make sure you don’t miss:
Exercise 1—Load the Lab and, leaving all settings at their default, click Apply.
Select various headers in any order and note how, as the panels open and close, the accordion itself never changes size.
Exercise 2—Reset the Lab, choose true for autoHeight, and click Apply.
Run through the actions of exercise 1, noticing that, this time, when the Flowers panel is opened, the height of the accordion shrinks to fit the smaller content of the Flowers panel.
Most often this is one of click (the default) or mouseover, but events such as mouseout can also be specified (even if a bit strange)
Use this only if you need to use a source construct for the accordion that doesn’t conform to the default pattern.
The icon to use for closed panels is specified as a property named header, whereas the icon to use for open panels is specified as a property named headerSelected.
The values of these properties are strings identifying the icons by class name, as defined earlier for button widgets in section 11.1.3
This can be used to cause specific accordion panels to be opened when the page is displayed.
For example, setting the href values to anchor hashes such as #chapter1 (and so on), will cause the corresponding panel to be opened when the page is displayed if the URL (or bookmark) is suffixed with the same hash value.
The index.html page for the code examples uses this technique.
You can use this function to change the behavior described in the navigation option description to any of your own choosing.
This callback will be invoked with no parameters, and the anchor tag for a header is set as the function context.
Return true to indicate that a navigation match has occurred.
Now we’re ready to tackle the events that are triggered while an accordion is being manipulated.
Accordions trigger only two event types when the user is opening and closing panels, as described in table 11.15
Figure 11.14 The jQuery UI Accordions Lab shows us how we can expose serial content panels to our users in a novel fashion.
Each of the handlers is passed the usual event instance and custom object.
The properties of the custom object are the same for both events and consist of the following:
This may be empty for collapsible accordions when all panels are being closed.
That’s a pretty sparse list of events, and it does offer some challenges.
For example, it’s disappointing that we get no notification when the initial panel (if any) is opened.
We’ll see how that makes things a tad harder for us when we try to use these events to instrument the accordion.
But before we tackle an example of using these events to add some functionality to our widget, let’s examine the CSS class names that jQuery UI adds to the elements that compose the accordion.
As with tabs, jQuery UI adds a number of CSS class names to the elements that go into making an accordion.
We can use not only use them as styling hooks, but to find the elements using jQuery selectors.
We saw an example of that in the previous section when we learned how to locate the panels involved in the accordion events.
These are the class names that are applied to the accordion elements:
Note that this is one of the generic jQuery UI class names shared across multiple widgets.
Using these class names, we can restyle accordion elements as we like, much like we did for tabs.
Try your hand at changing the style of the elements: the header text, for example, or maybe the border surrounding the panels.
Let’s also see how knowing these class names helps us to add functionality to an accordion widget.
One feature that the accordion widget lacks, present in its tabs widget kinfolk, is the innate ability to load content via Ajax.
Not wanting our accordions to suffer from an inferiority complex, let’s see how we can easily add that ability using the knowledge that we have at hand.
Tabs specify the location of remote content via the href of the anchor tags within them.
Accordions, on the other hand, ignore the href of anchor tags in their header unless the navigation option is being used.
Knowing this, we’ll safely use it to specify the location of any remote content to be loaded for the panel.
This is a good decision because it’s consistent with the way that tabs work (consistency is a good thing), and it means we don’t have to needlessly introduce custom options or attributes to record the location.
We’ll leave the anchor href of “normal” panels at #
In this handler we first locate the opening panel by using the reference provided in info.newContent.
If there’s none (which can happen for collapsible accordions), we simply return.
Then we locate the anchor within the activating header by finding the <a> element within the context of the reference provided by info.newHeader, and grab its href attribute.
If it doesn’t start with #, we assume it’s a remote URL for the panel content.
To load the remote content, we employ the handy load() method, and then change the href of the anchor to #
This last action prevents us from fetching the content again next time the panel is opened.
To force a load every time, simply remove the href assignment.
When using this handler, we might want to turn autoHeight off if not knowing the size of the largest panel in advance creates a problem.
Exercise 1—If we wanted to avoid using the href value so that we could use the navigation option, how would you rewrite the example to use custom attributes (or any other tactic of your choosing)?
Accordions give us an alternative to tabbed panels when we want to serially present related content to the user.
Now let’s wrap up our examination of the widgets, by looking at another widget that lets us present content dynamically.
A staple of desktop application design since the inception of the GUI, dialog boxes, whether modeless or modal, are a common means of eliciting information from the user, or delivering information to the user.
In web interfaces, however, they haven’t existed as an innate concept except for the built-in JavaScript alert prompt and confirm tools.
Deemed inadequate for a variety of reasons—not the least of which is their inability to be styled to conform to the theme of a site—these tools are often ignored except as debugging aids.
Internet Explorer introduced the concept of a web-based dialog box, but it failed to impress the standards community and remains a proprietary solution.
For years, web developers used the window.open() method to create new windows that stood in for dialog boxes.
Although fraught with issues, this approach was adequate as a solution for modeless dialog boxes, but truly modal dialog boxes were out of reach.
As JavaScript, browsers, DOM manipulations, and developers themselves have become more capable, it’s become possible to use these basic tools to create in-page elements that “float” over the rest of the display—even locking out input in a modal fashion—which better approximates the semantics of modeless and modal dialog boxes.
So although dialog boxes as a concept still don’t actually exist in web interfaces, we can do a darned good job of making it seem like they do.
Let’s see what jQuery UI provides for us in this area.
Although the idea of in-page dialog boxes seems simple—just remove some content from the page flow, float it with a high z-index, and put some “chrome” around it—there are lots of details to take into account.
Luckily, jQuery UI is going to handle that, allowing us to create modeless and modal dialog boxes, with advanced features such as the ability to be resized and repositioned, with ease.
This can include features such as resize borders, title bar, and the omnipresent little “x” icon that closes the dialog box.
Unlike the rather stringent requirements for the tabs and accordion widgets, just about any element can become the body of a dialog box, though a <div> element containing the content that’s to become the dialog box’s body is most often used.
To create a dialog box, the content to become the body is selected into a wrapped set, and the dialog() method is applied.
Parameters options (Object) An object hash of the options to be applied to the dialog box, as.
Note that destroying a dialog box doesn’t cause the contained elements to be restored to the normal document flow.
If specified, at least the optionName parameter must also be provided.
If a value parameter is provided, that value becomes the option’s value.
If no value parameter is provided, the named option’s value is returned.
It’s important to understand the difference between creating a dialog box and opening one.
Once a dialog box is created, it doesn’t need to be created again to be reopened after closing.
Unless disabled, a dialog box is automatically opened upon creation, but to reopen a dialog box that has been closed, we call dialog('open') rather than calling the dialog() method with options again.
Returns The wrapped set, except for the cases where values are returned as described above.
Figure 11.15 The jQuery UI Dialogs Lab lets us try out all the options that are available for jQuery UI dialog boxes.
Follow along in this Lab as you read through the options list in table 11.16
When false, the dialog box will be opened upon a call to dialog('open')
See the description of the dialog events in table 11.17 for details on the information passed to this handler.
See the description of the dialog events in table 11.17 for details on the information passed to this handler.
See the description of the dialog events in table 11.17 for details on the information passed to this handler.
See the description of the dialog events in table 11.17 for details on the information passed to this handler.
See the description of the dialog events in table 11.17 for details on the information passed to this handler.
See the description of the dialog events in table 11.17 for details on the information passed to this handler.
Dialog boxes height (Number|String) The height of the dialog box in pixels, or the string "auto" (the default), which allows the dialog box to determine its height based upon its contents.
See the description of the dialog events in table 11.17 for details on the information passed to this handler.
Can be one of the predefined positions: center (the default), left, right, top, or bottom.
Can also be a 2-element array with the left and top values (in pixels) as [left,top], or text positions such as ['right','top']
See the description of the dialog events in table 11.17 for details on the information passed to this handler.
See the description of the dialog events in table 11.17 for details on the information passed to this handler.
See the description of the dialog events in table 11.17 for details on the information passed to this handler.
By default, the title attribute of the dialog box element will be used as the title.
Most of these options are easy to see in action using the Dialogs Lab, but make sure you run through the differences between modal and modeless dialog boxes.
In the console of the Lab, the various events that are triggered (as the dialog box is interacted with) are displayed in the order that they’re received.
As the user manipulates the dialog boxes we create, various custom events are triggered that let us get our hooks into the page.
This gives us the opportunity to perform actions at pertinent times during the life of the dialog box, or even to affect the operation of the dialog box.
The events triggered during dialog box interactions are shown in table 11.17
Each of these handlers is passed the event instance and a custom object.
The function context, as well as the event target, is set to the dialog box element.
The custom object passed to the handler depends upon the event type:
For the drag, dragStart, and dragStop events, the custom object contains properties offset and position, which in turn contain left and top properties that identify the position of the dialog box relative to the page or its offset parent respectively.
For the resize, resizeStart, and resizeStop events, the custom object contains the properties originalPosition, originalSize, position, and size.
The position properties are objects that contain the expected left and top properties, while the size properties contain height and width properties.
For all other event types, the custom object has no properties.
Returning false prevents the dialog box from closing—handy for dialog boxes with forms that fail validation.
Before we can see a few clever uses of these events, let’s examine the class names that jQuery places on the elements that participate in the creation of our dialog boxes.
As with the other widgets, jQuery UI marks up the elements that go into the structure of the dialog box widget with class names that help us to find the elements, as well as to style them via CSS.
In the case of dialog boxes, the added class names are as follows:
Now let’s look at a few ways to specify content that’s not already on the page.
Generally, dialog boxes are created from <div> elements that are included in the page markup.
But what if we wanted to load the content dynamically upon dialogopen via Ajax? That’s actually surprisingly easy with code such as this:
In this code, we create a new <div> element on the fly, and turn it into a dialog box just as if it were an existing element.
The options specify its title, and a callback for dialogopen events that loads the content element (set as the function context) using the load() method.
In the scenarios we’ve seen so far, regardless of whether the content already existed on the page or was loaded via Ajax, the content exists within the DOM of the current page.
What if we want the dialog box body to be its own page?
Although it’s convenient to have the dialog box content be part of the same DOM as its parent, if the dialog box content and the page content need to interact in any way, we might want the dialog box content to be a separate page unto itself.
The most common reason may be because the content needs its own styles and scripts that we don’t want to include in every parent page in which we plan to use the dialog box.
How could we accomplish this? Is there support in HTML for using a separate page as a part of another page? Of course ...
Here we dynamically create an <iframe> element, specifying its source and an id, and make it into a dialog box.
The options we pass to the dialog() method give the dialog box its title and a Dismiss button that closes the dialog box.
But our self-admiration is short-lived when we display the dialog box and see a problem.
What we want, of course, is for the dialog box to appear as shown in the right half of the figure.
Because the <iframe> appears a bit too wide, we could attempt to narrow it with a CSS rule, but to our chagrin, we find that doesn’t work.
This overrides the style placed on the <iframe> when the dialog box is opened.
Bear in mind that this approach isn’t without its pitfalls.
This was a long chapter, but we learned a great deal from it.
We saw how jQuery UI builds upon the interactions and effects that it provides, and which we explored in the previous chapters, to allow us to create various widgets that help us present intuitive and easy-to-use interfaces to our users.
We learned about the button widget that augments the look and feel of conventional HTML buttons so that they play well in the jQuery UI sandbox.
Widgets that allow our users to enter data types that have traditionally been fraught with problems, namely numeric and date data, are provided in the guise of sliders and datepickers.
Autocomplete widgets round out the data entry widgets, letting users quickly filter through large sets of data.
Progress bars give us the ability to communicate completion percentage status to our users in a graphical, easy-to-understand display.
And finally, we saw three widgets that let us organize our content in varying fashions: tabs, the accordion, and the dialog box.
Added to our toolbox, these widgets give us a wider range of possibilities for our interfaces.
But that’s just the official set of widgets provided by jQuery UI.
As we’ve seen firsthand, jQuery is designed to extend easily, and the jQuery community hasn’t been sitting on its hands.
Hundreds, if not many thousands, of other plugin controls exist, just waiting for us to discover them.
The examples we presented were chosen specifically to lead you down the path of discovering how you can use jQuery to solve the problems that you encounter on a day-to-day basis on your web application pages.
Astoundingly so! Heck, it was quite a chore for your authors to keep up with the rapid developments in the libraries over the course of writing this book.
The core library is constantly evolving into a more useful resource, and more and more plugins are appearing on practically a daily basis.
And the pace of development for jQuery UI is practically exhausting.
We urge you to keep track of the developments in the jQuery community and sincerely hope that this book has been a great help in starting you on the path to writing better web applications in less time and with less code than you might have ever believed possible.
One of the great benefits that jQuery brings to our web applications is the ability to implement a great deal of scripting-enabled behavior without having to write a.
In the chapters on advanced topics such as event handling, animations, and Ajax, we must understand a handful of fundamental JavaScript concepts to make effective use of the jQuery library.
You may find that a lot of things that you, perhaps, took for granted in JavaScript (or took on blind faith) will start to make more sense.
We’re not going to go into an exhaustive study of all JavaScript concepts here—that’s not the purpose of this book.
The purpose of this book is to get us up and running with effective jQuery in the shortest time possible.
To that end, this appendix will concentrate on the fundamental concepts that we need to make the most effective use of jQuery in our web applications.
The most important of these concepts is that functions are first-class objects in JavaScript, which is a result of the way JavaScript defines and deals with functions.
What do we mean by that? In order to understand what it means for a function to be an object, let alone a first-class one, we must first make sure that we understand what a JavaScript object is all about.
A.1 JavaScript Object fundamentals The majority of object-oriented (OO) languages define a fundamental Object type of some kind from which all other objects are derived.
In JavaScript, the fundamental Object serves as the basis for all other objects, but that’s where the comparison stops.
At its basic level, the JavaScript Object has little in common with the fundamental object defined by most other OO languages.
At first glance, a JavaScript Object may seem like a boring and mundane item.
Once created, it holds no data and exposes little in the way of semantics.
But those limited semantics do give it a great deal of potential.
A new object comes into existence via the new operator paired with the Object constructor.
It could be even easier (as we’ll see shortly), but this will do for now.
But what can we do with this new object? It seemingly contains nothing: no information, no complex semantics, nothing.
Our brand-new, shiny object doesn’t get interesting until we start adding things to it—things known as properties.
Unlike those serverside brethren, these elements aren’t predeclared for an object; we create them dynamically as needed.
Here we create a new Object instance and assign it to a variable named ride.
We then populate this variable with a number of properties of different types: two strings, a number, and an instance of the Date type.
We don’t need to declare these properties prior to assigning them; they come into being merely by the act of our assigning a value to them.
That’s mighty powerful juju that gives us a great deal of flexibility.
But before we get too giddy, let’s remember that flexibility always comes with a price!
For example, let’s say that in subsequent code on our scripted HTML page, we want to change the value of the purchase date:
There’s no compiler to warn us that we’ve made a mistake; a new property named purcahsed is cheerfully created on our behalf, leaving us to wonder later why the new date didn’t take when we reference the correctly spelled property.
With great power comes great responsibility (where have we heard that before?), so type carefully!
Because typos such as these frequently result in no JavaScript errors, relying on JavaScript consoles or error dialog boxes is usually less than effective.
From this example, we’ve learned that an instance of the JavaScript Object, which we’ll simply refer to as an object from here forward, is a collection of properties, each of which consists of a name and a value.
The name of a property is a string, and the value can be any JavaScript object, be it a Number, String, Date, Array, basic Object, or any other JavaScript object type (including, as we shall see, functions)
This means the primary purpose of an Object instance is to serve as a container for a named collection of other objects.
This may remind you of concepts in other languages: a Java map for example, or dictionaries or hashes in other languages.
Properties aren’t limited to types such as String or Number.
An object property can be another Object instance, which in turn has its own set of properties, which can in turn be objects with their own properties, and so on, to any depth that makes sense for the data that we are trying to model.
This property is another JavaScript object that contains properties such as the name and occupation of the owner:
There are no limits to the nesting levels we can employ (except the limits of good sense)
When finished—up to this point—our object hierarchy is as shown in figure A.1
Note how each value in the figure is a distinct instance of a JavaScript type.
In a short while, we’ll see more efficient and compact ways to declare objects and their properties.
Up to this point, we’ve referenced properties of an object by using the dot (period character) operator.
But, as it turns out, that’s a synonym for a more general operator for performing property referencing.
What if, for example, we have a property named color.scheme? Do you notice the period in the middle of the name? It throws a monkey wrench into the works because the JavaScript interpreter will try to look up scheme as a nested property of color.
But what about space characters? What about other characters that could be mistaken for delimiters rather than part of a name?
Figure A.1 Our object hierarchy shows that Objects are containers for named references to other Objects or JavaScript built-in types.
And most importantly, what if we don’t even know what the property name is, but we have it as a value in another variable or as the result of an expression evaluation?
For all these cases, the dot operator is inadequate, and we must use the more general notation for accessing properties.
For example, all three of the following references are equivalent:
Building up objects by creating new instances with the new operator and assigning each property using separate assignment statements can be a tedious affair.
In the next section, we’ll look at a more compact and easy-to-read notation for declaring objects and their properties.
In the previous section, we created an object that modeled some of the properties of a motorcycle, assigning it to a variable named ride.
To do so, we used two new operations, an intermediary variable named owner, and a bunch of assignment statements.
This is tedious—as well as wordy and error-prone—and it is difficult for us to visually grasp the structure of the object during a quick inspection of the code.
Luckily, we can use a notation that’s more compact and easier to visually scan.
Its structure is simple; an object is denoted by a matching pair of braces, within which properties are listed delimited by commas.
Each property is denoted by listing its name and value separated by a colon character.
When used in script, the Date constructor is usually employed as shown in the previous example.
When used as an interchange format, dates are frequently expressed either as a string containing the ISO 8601 format or a number expressing the date as the millisecond value returned by Date.getTime()
Note also that when using JSON as an interchange format, there are some stricter rules that need to be followed, such as quoting property names.
As we can see by the declaration of the owner property, object declarations can be nested.
By the way, we can also express arrays in JSON by placing the comma-delimited list of elements within square brackets, as in the following:
As we’ve seen in the examples presented in this section, object references are frequently stored in variables or in properties of other objects.
Let’s take a look at a special case of the latter scenario.
Up to this point, we’ve seen two ways to store a reference to a JavaScript object: variables and properties.
These two means of storing references use differing notation, as shown in the following snippet:
These two statements each assign a String instance (created via literals) to something: a variable in the first statement, and an object property in the second.
Kudos to you if you can identify the source of the obscure quotes; no cheating with Google! There was a clue earlier in this appendix.
But are these statements really performing different operations? As it turns out, they’re not!
Any reference made in top-level scope is implicitly made on the window instance.
This means that all of the following statements, if made at the top level (that is, outside the scope of a function), are equivalent:
Regardless of which notation is used, a window property named foo is created (if it’s not already in existence) and assigned the value of bar.
Also, note that because bar is unqualified, it’s assumed to be a property on window.
It probably won’t get us into conceptual trouble to think of top-level scope as window scope because any unqualified references at the top level are assumed to be window properties.
The scoping rules get more complex when we delve deeper into the bodies of functions—much more complex, in fact—but we’ll be addressing that soon enough.
That pretty much covers things for our overview of the JavaScript Object.
These are the important concepts to take away from this discussion:
Now, let’s discuss what we meant when we referred to JavaScript functions as first-class objects.
A.2 Functions as first-class citizens In many traditional OO languages, objects can contain data and they can possess methods.
In these languages, the data and methods are usually distinct concepts; JavaScript walks a different path.
Functions in JavaScript are considered objects like any of the other object types that are defined in JavaScript, such as Strings, Numbers, or Dates.
Like other objects, functions are defined by a JavaScript constructor—in this case Function—and they can be.
Because functions are treated in the same way as other objects in the language, we say that functions are first-class objects.
But you might be thinking to yourself that functions are fundamentally different from other object types like String or Number because they possess not only a value (in the case of a Function instance, its body) but also a name.
A large percentage of JavaScript programmers operate under a false assumption that functions are named entities.
If you’re one of these programmers, you’ve been fooled by a Jedi mind trick.
As with other instances of objects—be they Strings, Dates, or Numbers—functions are referenced only when they are assigned to variables, properties, or parameters.
The Number instance isn’t all that useful unless it has been assigned to a property or a variable, or bound to a parameter name.
Otherwise, we have no way to reference the disembodied instance.
Although that notation may seem familiar and is ubiquitously used.
The function keyword automatically creates a Function instance and assigns it to a window property created using the function “name” (what we referred to earlier as a Jedi mind trick), as in the following:
If that looks weird to you, consider another statement using the exact same format, except this time using a Number literal:
If you’ve never seen the syntax for a function literal, it might seem odd.
It’s composed of the keyword function, followed by its parameter list enclosed in parentheses, then followed by the function body.
When we declare a top-level named function, a Function instance is created and assigned to a property of window that’s automatically created using the so-called function name.
The Function instance itself no more has a name than a Number literal or a String literal.
Remember that when a top-level variable is created in an HTML page, the variable is created as a property of the window instance.
Although this may seem like syntactic juggling, it’s important to understanding that Function instances are values that can be assigned to variables, properties, or parameters just like instances of other object types.
And like those other object types, nameless disembodied instances aren’t of any use unless they’re assigned to a variable, property, or parameter through which they can be referenced.
We’ve seen examples of assigning functions to variables and properties, but what about passing functions as parameters? Let’s take a look at why and how we do that.
It’s named only by references that are made to it.
Gecko browsers and function names Browsers based on the Gecko layout engine, such as Firefox and Camino, store the name of functions defined using the top-level syntax in a nonstandard property of the function instance named name.
Although this may not be of much use to the general development public, particularly considering its confinement to Gecko-based browsers, it’s of great value to writers of browser plugins and debuggers.
Top-level functions are all well and good when our code follows a nice and orderly synchronous flow, but the nature of HTML pages—once loaded—is far from synchronous.
Whether we’re handling events, instituting timers, or making Ajax requests, the nature of the code in a web page is asynchronous.
And one of the most prevalent concepts in asynchronous programming is the notion of a callback function.
But how does that method let us know when the timer has expired so that we can do whatever it is that we’re waiting around for? It does so by invoking a function that we supply.
In the first parameter to the setTimeout() method, we pass a function reference.
Passing a function as a parameter is no different than passing any other value—just as we passed a Number in the second parameter.
Because the setTimeout() method makes a call back to a function in our own code, that function is termed a callback function.
This code example would be considered naive by most advanced JavaScript coders because the creation of the hello name is unnecessary.
Unless the function is to be called elsewhere in the page, there’s no need to create the window property hello to momentarily store the Function instance to pass it as the callback parameter.
This is an idiom that we’ll often see used in jQuery code when there is no need for a function instance to be assigned to a top-level property.
The functions we’ve created in the examples so far are either top-level functions (which we know are top-level window properties) or assigned to parameters in a function call.
We can also assign Function instances to properties of objects, and that’s where things get really interesting.
In languages like Java and C++, a variable named this points to that current instance.
But OO programmers beware! The JavaScript implementation of this differs from its OO counterparts in subtle but significant ways.
In class-based OO languages, the this pointer generally references the instance of the class for which the method has been declared.
In JavaScript, where functions are first-class objects that aren’t declared as part of anything, the object referenced by this—termed the function context—is determined not by how the function is declared but by how it’s invoked.
This means that the same function can have different contexts depending on how it’s called.
That may seem freaky at first, but it can be quite useful.
In the default case, the context (this) of an invocation of the function is the object whose property contains the reference used to invoke the function.
Let’s look back to our motorcycle example for a demonstration, amending the object creation as follows (additions highlighted in bold):
To our original example code, we add a property named whatAmI that references a Function instance.
Our new object hierarchy, with the Function instance assigned to the property named whatAmI, is shown in figure A.3
Figure A.3 This model clearly shows that the function isn’t part of the Object but is only referenced from the Object property named whatAmI.
Remember that top-level functions are properties of window, so their function context, when called as top-level functions, is the window object.
Although that may be the usual and implicit behavior, JavaScript gives us the means to explicitly control what’s used as the function context.
We can set the function context to whatever we want by invoking a function via the Function methods call() or apply()
Yes, as first-class objects, even functions have methods as defined by the Function constructor.
The call() method invokes the function specifying, as its first parameter, the object to serve as the function context, while the remainder of the parameters become the parameters of the called function—the second parameter to call() becomes the first argument of the called function, and so on.
The apply() method works in a similar fashion except that its second parameter is expected to be an array of objects that become the arguments to the called function.
Listing A.1 The function context value depends on how the function is invoked.
In this example, we define three simple objects, each with a handle property that makes it easy to identify the object given a reference B.
We also add a handle property to the window instance so that it’s also readily identifiable.
We then define a top-level function that returns the value of the handle property for whatever object serves as its function context C and assign the same function instance to a property of object o1 named identifyMe D.
We can say that this creates a method on o1 named identifyMe, although it’s important to note that the function is declared independently of the object.
Finally, we issue four alerts, each of which uses a different mechanism to invoke the same function instance.
When loaded into a browser, the sequence of four alerts is as shown in figure A.4
Figure A.4 The object serving as the function context changes with the manner in which the function is called.
When the function is called directly as a top-level function, the function context is the window instance E.
Employing the call() method of Function causes the function context to be set to whatever object is passed as the first parameter to call()—in this case, o2 G.
As with call(), using the apply() method of Function sets the function context to whatever object is passed as the first parameter H.
The difference between these two methods only becomes significant when parameters are passed to the function (which we didn’t do in this example for simplicity)
This example page clearly demonstrates that the function context is determined on a per invocation basis and that a single function can be called with any object acting as its context.
As a result, it’s probably never correct to say that a function is a method of an object.
A function f acts as a method of object o when o serves as the function context of the invocation of f.
As a further illustration of this concept, consider the effect of adding the following statement to our example:
When using jQuery commands and functions that employ callbacks, this proves to be an important concept.
Now that we understand how functions can act as methods of objects, let’s turn our attention to another advanced function topic that will play an important role in effective usage of jQuery: closures.
Functions as first-class citizens programming background, they’re a familiar and cozy concept.
For the uninitiated, let’s answer the question: What are closures?
Stated as simply as possible, a closure is a Function instance coupled with the local variables from its environment that are necessary for its execution.
When a function is declared, it has the ability to reference any variables that are in its scope at the point of declaration.
This is expected and should be no surprise to any developer from any background.
But, with closures, these variables are carried along with the function even after the point of declaration has gone out of scope, closing the declaration.
The ability for callback functions to reference the local variables in effect when they were declared is an essential tool for writing effective JavaScript.
In this example, we define a ready handler that fires after the DOM loads.
As the callback for the timer, we specify an inline function that references the local variable and shows the current time and the value of local, by writing a <div> element into an element named display that’s defined in the page body E.
As part of the callback, the local variable’s value is also incremented D.
Prior to running this example, if we were unfamiliar with closures, we might look at this code and see some problems.
We might surmise that, because the callback will fire off three seconds after the page is loaded (long after the ready handler has finished executing), the value of local is undefined during the execution of the callback.
Listing A.2 Closures allow access to the scope of a function's declaration.
After all, the block in which local is declared goes out of scope when the ready handler finishes, right?
But on loading the page and letting it run for a short time, we see the display shown in figure A.5
It works! But how? Although it is true that the block in which local is declared goes out of scope.
A classic example of this is the creation of DOM elements that refer back to closure variables, preventing those variables from being reclaimed.
Another important feature of closures is that a function context is never included as part of the closure.
For example, the following code won’t execute as we might expect:
Remember that each function invocation has its own function context so that, in the preceding code, the function context within the callback function passed to each() is an element from the jQuery wrapped set, not the property of the outer function set to 'someID'
Each invocation of the callback function displays an alert box showing the id of each element in the wrapped set in turn.
Figure A.5 Closures allow callbacks to access their environment even if that environment has gone out of scope.
When access to the object serving as the function context in the outer function is needed, we can employ a common idiom to create a copy of the this reference in a local variable that will be included in the closure.
The local variable outer, which is assigned a reference to the outer function’s function context, becomes part of the closure and can be accessed in the callback function.
The changed code now displays an alert showing the string 'someID' as many times as there are elements in the wrapped set.
We’ll find closures indispensable when creating elegant code using jQuery commands that utilize asynchronous callbacks, which is particularly true in the areas of Ajax requests and event handling.
A.3 Summary JavaScript is a language that’s widely used across the web, but it’s often not deeply used by many of the page authors writing it.
In this appendix, we introduced some of the deeper aspects of the language that we must understand to use jQuery effectively on our pages.
We saw that a JavaScript Object primarily exists to be a container for other objects.
If you have an OO background, thinking of an Object instance as an unordered collection of name/value pairs may be a far cry from what you think of as an object, but it’s an important concept to grasp when writing JavaScript of even moderate complexity.
Functions in JavaScript are first-class citizens that can be declared and referenced in a manner similar to the other object types.
We can declare them using literal notation, store them in variables and object properties, and even pass them to other functions as parameters to serve as callback functions.
The term function context describes the object that’s referenced by the this pointer during the invocation of a function.
Although a function can be made to act like a method of an object by setting the object as the function context, functions aren’t declared as methods of any single object.
The manner of invocation (possibly explicitly controlled by the caller) determines the function context of the invocation.
Finally, we saw how a function declaration and its environment form a closure allowing the function, when later invoked, to access those local variables that become part of the closure.
With these concepts firmly under our belts, we’re ready to face the challenges that confront us when writing effective JavaScript using jQuery on our pages.
See caret character : See colon character * See asterisk character % operator, usage.
A   good web development framework anticipates your  needs—jQuery practically reads your mind.
You’ll fall   in love with it when you see 20 lines of code reduced to three.
And with version 1.4, there’s even more to love including new eﬀ ects and events, usability improvements, and more testing options.
An in-depth rewrite of the bestselling ﬁ rst edition, this edition provides deep and practical coverage of the latest jQuery and jQuery UI releases.
Th e book’s unique “lab pages” anchor the explanation of each new concept in a practical example.
You’ll learn how to traverse HTML documents, handle events, perform animations, and add Ajax to your web pages.
Th is comprehensive guide also teaches you how jQuery interacts with other tools and frameworks and how to build jQuery plugins.
Bear Bibeault is a software architect and JavaRanch senior moderator and coauthor of Manning’s Ajax in Practice and Prototype and Scriptaculous in Action.
He heads the jQuery plugin development team and runs Visual jQuery.
Energizing pages with animations and effects 5.1.1 Implementing a collapsible “module”
