Apache CouchDB is an exciting database management system that is steadily improving with each new version.
This book provides the skills and strategies you need to become a capable CouchDB administrator and programmer.
Specifically, I will provide you with all the information you need to get started with CouchDB, from installing and setting up a database to developing applications that are powered by a CouchDB database.
I begin by introducing CouchDB and qualifying what makes it unique when compared to traditional relational database systems.
I document CouchDB’s relatively short history and list some of the key advantages it has to offer.
Next, I provide you with a step-by-step guide to installing CouchDB on various distributions of the Linux operating system as well as on a Mac, before guiding you through the creation of your first database.
In the second part of this book, you will learn about Futon, CouchDB’s excellent web-based admin interface, and then be introduced to the JSON format, which is used to describe the data in CouchDB.
Next, you will learn all about CouchDB views and the sometimes difficult to grasp concept of map/reduce.
The final part of the book shows you how to create CouchApps, web applications stored entirely in the database.
You will also see how to work with CouchDB from your Python and Ruby applications.
Finally, you will explore some of the more advanced concepts of CouchDB, such as replication, conflict management, and deployment.
With the information provided in this book, you should have everything you need to start working with CouchDB.
I hope you find it as enjoyable to read as I found it to write.
Starting Apache CouchDB, the open source database for the Cloud.
No part of this work may be reproduced or transmitted in any form or by any means, electronic or mechanical, including photocopying, recording, or by any information storage or retrieval system, without the prior written permission of the copyright owner and the publisher.
Rather than use a trademark symbol with every occurrence of a trademarked name, we use the names only in an editorial fashion and to the benefit of the trademark owner, with no intention of infringement of the trademark.
For information on translations, please e-mail info@apress.com, or visit http://www.apress.com.
Apress and friends of ED books may be purchased in bulk for academic, corporate, or promotional use.
For more information, reference our Special Bulk Sales–eBook Licensing web page at http://www.apress.com/info/bulksales.
The information in this book is distributed on an “as is” basis, without warranty.
Although every precaution has been taken in the preparation of this work, neither the author(s) nor Apress shall have any liability to any person or entity with respect to any loss or damage caused or alleged to be caused directly or indirectly by the information contained in this work.
The source code for this book is available to readers at http://www.apress.com.
You will need to answer questions pertaining to this book in order to successfully download the code.
Joe Lennon is a web applications and database developer from Cork, Ireland.
He dabbled with web development in the late 1990s and was an expert in HTML, CSS, and JavaScript by the time he finished school.
He received a scholarship in 2006 for his performance in that.
As part of the program, Joe spent six months in Boston, Massachusetts, working as a systems analyst for Fidelity Investments.
Later that year, Joe joined Core International as a web applications developer.
Since joining Core, he has been involved in the development of several new web-based products, as well as the redevelopment and improvement of some existing ones.
He introduced the concept of JavaScript frameworks and Ajax to the company’s web division in 2008, developing a PL/SQL and JavaScript framework that is now used in every Core web product.
Aside from his work at Core, Joe has worked on several successful web development projects, including Learn French by Podcast, a language-learning web site that offers its members free highquality MP3 podcasts and allows them to purchase accompanying professional PDF guides for a small fee.
He also maintains a blog on his web site at http://www.joelennon.ie, where he has often posted tutorials about topics ranging from Oracle database development to Windows batch scripting.
In the past two years, Joe has written more than a dozen articles and tutorials for the IBM developerWorks web site, including articles on Adobe Flex, Facebook applications, ExtJS, Adobe AIR, IBM DB2, and more.
A native of Agency, Iowa, he attended the University of Iowa graduating in 2005 with a degree in electrical engineering.
During his studies at university, he got his first paid programming job as a research assistant under Prof.
Mackey’s tutoring, he moved from data analysis to system programming, working on the Large Scale Digital Cell Analysis System (LSDCAS)
After working for four years on LSDCAS, he moved eastward to a position with New England Biolabs.
After repeated attempts of trying to force biological data into a relational database, he quickly started searching for a better solution.
During this search, he found CouchDB and quickly became convinced that it was just the solution he had been searching for.
Beyond CouchDB, Paul contributes to a number of other open source projects.
You can find a majority of his contributions via http://github.com/davisp or on his web site at http://www.davispj.com.
Writing this book would not have been possible if it were not for the help and support of many people.
First, I’d like to thank Jill, the love of my life, who has been there for me throughout this whole project.
She has put up with so much the past few months—and never once complained about it.
Second, I’d like to thank my mother, Maria, who has always believed in me and pushed me to get the best out of myself.
Thank you to my father, Jim, who has always worked his socks off to make sure that I had everything I could ever need or want.
Thank you to my sisters, Laura and Kelly, who can always put a smile on my face, even when I’m being a cranky big brother!
Thank you to my grandparents, my aunts and uncles, and my cousins.
I hope you all enjoy this book, because you will be receiving a copy for Christmas this (and every) year.
Also a big thank you to the Mac Sweeneys—Jill, Mick, Susie, Patrick, and Sarah—I greatly appreciate all the support you have given me.
I owe an enormous debt of gratitude to a number of people who worked on this book project.
Without my lead editor, Frank Pohlmann, this book would not have been created.
I’d like to especially thank him for all of his guidance and for giving me the opportunity to fulfill one of my ambitions in life.
Special thanks to Paul Davis; without his expertise on CouchDB, this book would be far less useful.
Thank you to Anne Collett, who managed the difficult task of keeping me on schedule while also keeping me motivated at the same time.
Thank you to Kim Wimpsett for the kind words about my writing style, although in truth, her hard work and effort has made my writing look so much better than it really is.
Without your efforts, this book would never have had a reason for being written.
Apache CouchDB is an exciting database management system that is growing in popularity each day.
This book introduces you to CouchDB, guiding you through its relatively short history and what makes it different from the other database systems out there.
It offers simple, unassuming steps on getting CouchDB up and running on your computer that’s running Linux or Mac OS X.
It guides you through the process of creating a database and working with data; covers more complex topics such as views and map/reduce; and explores advanced database concepts such as replication, compaction, and deployment.
It also shows you how to develop applications that are housed entirely in the database itself, in addition to using Python, Django, and Ruby to interact with CouchDB from a traditional serverside application.
Who This Book Is For This book is written for anyone with an interest in CouchDB, document-oriented databases, or database development in general.
It does not assume any knowledge in relation to CouchDB, although some experience with UNIX commands and basic JavaScript skills are beneficial.
What You Need To follow the examples in this book, you will need access to a computer running the Linux operating system or Mac OS X.
You will need administrative access to this computer in order to install CouchDB.
If you are using a Windows PC, see the “CouchDB Resources” section for a link to an unofficial Windows binary installer for CouchDB that you may be able to use.
Alternatively, you can get a hosted version of CouchDB from http://couch.io.
CouchDB Resources This book is written as a guide to help you get started with CouchDB.
In this part, you will learn all about the CouchDB database and how it differs from.
CouchDB on Linux and Mac OS X operating systems, and you will see just how easy it is.
CouchDB is a relatively new database management system, designed from the ground up to suit modern software applications that tend to be web-based, document-oriented, and distributed in nature.
For several decades now, relational database management systems have reigned supreme in application and database development, with the likes of Oracle, SQL Server, and MySQL being used in every type of software application imaginable.
When object-oriented development started to gain traction in the early 1990s, many believed that object-oriented database systems would closely follow suit.
Since then, however, there has been a large shift in focus in software development.
The breakthrough of dynamic web applications and mobile technology has led to developers looking for lightweight, inexpensive, and well-documented solutions.
Many of these developers were prolific at SQL, and open source relational databases such as MySQL simply made the most sense.
Today, MySQL is used on millions of web sites across the world.
The relational model that these databases are built on, however, was designed many years ago, when the World Wide Web and Internet were unheard of.
Although the strict schema-based structure these databases adhere to is required in some web applications, such as transaction systems, it is not a good fit for many modern web projects, such as blogs, wikis, and discussion forums, which by their nature are a better fit to a document-oriented database.
What Is CouchDB? CouchDB is a document-oriented database management system, released under the open source Apache License.
In contrast to most database systems, it stores data in a schema-free manner.
This means that, unlike traditional SQL-based databases, there are no tables and columns, primary and foreign keys, joins, and relationships.
Instead, CouchDB stores data in a series of documents and offers a JavaScript-based view model for aggregating and reporting on the data.
If you are wondering where the name CouchDB came from, you may be surprised to hear that it is in fact an acronym.
According to the CouchDB wiki, Couch stands for “Cluster Of Unreliable Commodity Hardware,” indicating that CouchDB is intended to run distributed across a cluster of cheap servers.
Anyone who has dealt with replication in databases before will know that it is rarely a simple task, but the exact opposite applies when it comes to CouchDB.
Add to this the fact that CouchDB is developed in Erlang OTP, a fault-tolerant programming language that offers excellent concurrency features, and you know that your CouchDB database will scale well without a loss of reliability and availability.
Binary installers are available for Ubuntu, Fedora, CentOS, FreeBSD, and Mac OS X systems through each system’s individual package manager.
Alternatively, CouchDB can be built from source on virtually any POSIX system.
I will discuss how to install CouchDB on Linux and Mac OS X in the next two chapters.
You will also get a look at an unofficial application for Mac OS X called CouchDBX, which allows you to simply download and run a CouchDB server immediately, no installation or configuration necessary.
CouchDB: The Story So Far In April 2005, Damien Katz posted on his blog about a new database engine he was working on.
Details were sparse at this early stage, but what he did share was that it would be a “storage system for a large scale object database” and that it would be called CouchDB.
His objectives for the database were for it to become the database of the Internet and that it would be designed from the ground up with web applications in mind.
Katz began working on the database soon after his blog post, choosing C++ as the platform to build it on.
Right from the very beginning, CouchDB was designed to be schema-free and indexable, using a combination of append-only storage and atomic updates.
It was clear that Katz was heavily influenced by Lotus Notes, the product he worked tirelessly on for many years.
The choice of using append-only storage meant that data in a CouchDB database would never be overwritten, but rather it would become “outdated,” with the newer data taking precedence.
In November 2005, Katz announced that he was working on the Fabric formula language.
Katz was previously involved in the development of the Lotus Notes Formula language, which Fabric inherited many features from.
In December 2005, Katz published a blog post outlining his goals and ambitions for CouchDB, stating that it was “Lotus Notes built from the ground up for the Web.” It was in this blog post that many of the features that exist in CouchDB today were put forward, such as document orientation, distributed architecture, bidirectional replication, and offline access.
Further validating the notion that CouchDB would be the “database for the Web” was Katz’s hope that CouchDB would be a great database engine for applications such as e-mail, bug tracking, timesheet management, blogs, and RSS feeds, amongst others.
A big milestone in CouchDB development was the announcement in February 2006 that its underpinning codebase was being moved, in its entirety, from C++ to Erlang.
This purpose-built programming language was developed by Ericsson and is heavily used in the telecommunications industry.
It is highly centered on the ideas of concurrency control, fault tolerance, and distributed applications, and as a result, Katz believed it was the perfect fit for CouchDB.
Another breakthrough came in April 2006 when it was announced that CouchDB would be solely accessible via an HTTP-based RESTful API.
What this means is that rather than connecting to the database server using a client application, you would use any software capable of interacting with an HTTP web server to make requests, which would in turn perform database actions, returning an appropriate response when finished.
This means you can manage the database by simply visiting URLs in your web browser, using command-line tools such as curl or, more importantly, via any programming language that supports HTTP requests.
At the time, CouchDB would run only on Microsoft Windows.
This decision is arguably the most important one made to date in the CouchDB project, and it sparked a huge amount of interest in the project.
CouchDB now featured a JavaScript view engine based on Mozilla Spidermonkey and an attractive web-based.
This version of CouchDB was the first version that could actually be used as a proper database, and it quickly drew the attention of IBM, which backed the project, allowing Damien Katz (who previously worked for IBM) to work full-time on developing CouchDB.
Soon after IBM got involved, CouchDB’s license was changed to use the Apache License rather than the restrictive and cumbersome GNU General Public License (GPL)
In February 2008, it was announced that CouchDB would include support for Map/Reduce.
CouchDB views would be defined using a Map function and an optional Reduce function.
The Map function would take an input document and emit key/value pairs.
The Reduce function then takes each of these pairs and performs further calculation.
CouchDB’s implementation of Map/Reduce is designed to allow views to be updated incrementally, meaning that it will only reindex any documents that have been modified since the last time the index was updated.
This allows large sets of partitioned data to be queried extremely quickly, as the view has been generated over time.
This meant that potential CouchDB developers could get their feet wet by sampling what CouchDB has to offer, without getting their hands dirty with a full install.
If anything, this certified CouchDB as a credible project to developers around the world and has definitely worked to the project’s advantage.
Document-Oriented Databases A key feature of CouchDB is that it is a document-oriented database management system.
Basically, this means that the data stored in a CouchDB database comprises a series of documents, each of which can contain a series of fields and values.
Each document is independent of one another, and there is no strict schema that they must adhere to.
Traditional databases that adhered to the relational model stored data in a series of tables; they were made up of rows and columns of data.
In a relational database, you must predefine the schema that all data in each table will adhere to, and all the data contained in the table must strictly conform to that schema.
If you are used to SQL-based databases like Oracle, SQL Server, and MySQL, you are probably quite familiar with the concepts of relationships, primary keys, foreign keys, referential integrity, and so forth.
If you are not, don’t panic, because these concepts don’t exist in CouchDB.
In fact, it may take some time for a SQL developer to grasp the idea of a database without relationships and a row/column layout.
Instead of a primary key field, each document in a CouchDB database has a unique ID.
This unique ID can be assigned by the user or application, or it can use a universally unique identifier (UUID)—a random number generated by CouchDB that greatly reduces the chance of duplicate IDs being used.
All data relevant to the document in question is stored directly in that document itself.
The fact that CouchDB is a schema-free database management system is very important.
When developing a relational database, you must carefully think about how your database should be modeled before you create it.
Altering a SQL database can be a devastating experience for any database administrator, because a series of dependency and integrity issues come into play.
This is not the case with a document-oriented database like CouchDB.
Each document is self-contained, so you do not need to store redundant null values, and you can define new fields for each document independently of one another.
It may be easier to think of CouchDB as a collection of paper documents.
On a paper document, it doesn’t make any sense to list a field as null.
Naturally, a schema-free architecture has some disadvantages, such as a lack of defined structure and unnecessary replication of data across documents.
Of course, in cases where these criteria are of the utmost importance, CouchDB is probably not the database for you.
In fact, the developers openly state that they do not intend for CouchDB to be a direct replacement for a relational SQL-based database.
Instead, they see it as an alternative in scenarios where a document-oriented architecture is a viable solution.
In applications such as wikis, document management systems, discussion forums, blogs, support management systems, and so forth, documents are the way forward.
For years now, web developers have retrofitted their application model to fit around a relational database.
CouchDB Documents Data in a CouchDB database is stored in a series of uniquely named documents, objects made up of various named fields.
The values stored in the document can be strings, numbers, dates, booleans, lists, maps, or other data types.
Each document in the database has a unique ID, and the documents are stored in the database on a flat address space.
There is no limit to the number of fields a document may have or on the size of values stored in the document.
In addition to data fields, each document includes metadata that is maintained by the CouchDB server itself, such as a revision number and more.
The use of document revisions is important, because CouchDB itself does not impose a locking mechanism on data.
If two users are editing the same data at the same time, the first to commit their update will succeed, while the other will receive a conflict error.
When a conflict is detected, the user will be presented with the latest revision of the document and offered the opportunity to make their changes again.
Also important to note is that CouchDB will never overwrite existing documents, but rather it will append a new document to the database, with the latest revision gaining prominence and the other being stored for archival purposes.
This works in a similar way to the revision control of a document management system, except that it is taken care of by the database itself.
Note Although CouchDB stores previous revisions of documents, it is not safe to assume that these revisions will be available permanently.
To keep the size of the database to a minimum, CouchDB provides a feature allowing a database administrator to compact the database.
This will delete any previous revisions of documents, and hence the revision history will be lost.
If you are developing an application that requires revision history, it is highly recommended that you build an additional versioning layer rather than use CouchDB's internal layer.
The CouchDB layout and committing system adheres to the ACID properties (atomicity, consistency, isolation, and durability), which guarantee the reliable execution of database transactions.
Atomicity basically means that database transactions should be all or nothing—either the entire transaction completes successfully or none of it does.
Consistency refers to the database being in the same state before and after every database transaction.
Isolation means that each transaction must be isolated from others in that its new state should not be available until the transaction is complete.
Finally, durability means that when a transaction is complete and the user has been notified of the fact, the transaction cannot be reversed, even by a complete system failure or shutdown.
The JavaScript View Engine Because CouchDB is schema-less by design, the data stored in the database is highly unstructured.
Although this means the data is flexible and the fields can be easily changed without disrupting database integrity, it also means that the flat data can be difficult to report on.
Although it might be suitable and fast for general-purpose querying, it starts to become more cumbersome when you try to perform aggregation and reporting.
Fortunately, CouchDB provides a Spidermonkey-based JavaScript view engine that allows you to create ad hoc views that can perform aggregation and joins, allowing you to report on the documents in the database.
These views are not physically stored in the database, but rather they are generated when required, and as a result, they do not impact the actual data being reported on.
There is no limit to the number of views you can use.
In CouchDB, views are defined inside design documents, and just like data documents, they can be replicated across instances of the database.
Inside these design documents are JavaScript functions that run queries using CouchDB’s implementation of Map/Reduce.
In addition to stored views, ad hoc queries and reports can be run using a temporary view, although for performance reasons, this is not recommended.
Each time a client makes a read request, CouchDB will make sure that the requested views are upto-date.
If the requested view does not contain the most recent database changes, these edits are incrementally inserted into the view.
This alleviates the performance issues associated with generating a view dynamically each and every time it is run, especially on databases that store millions of records of data.
RESTful HTTP API Traditional relational databases are typically accessible using a client software application or module, and database transactions are committed using a language known as Structured Query Language (SQL)
CouchDB does things somewhat differently, depending on a RESTful HTTP API to provide users access to the data.
Representational State Transfer (REST) in this sense refers to the fact that data access is available via a series of simple web services that are implemented in Hypertext Transfer Protocol (HTTP) and adhere to the principles of REST.
JavaScript Object Notation (JSON) is a light, text-based data format for representing data.
An application programming interface (API) is the basic interface offered to developers so they can build applications that interact with the database.
Typically, programming languages would each have a client library for interacting with a particular database.
Although client libraries exist for CouchDB (for the sole purpose of making it easier to interact with the database), any platform that supports HTTP requests can interact with CouchDB without requiring any additional client libraries to be installed.
To use the CouchDB API, you issue an HTTP request to the CouchDB server.
What the server does with your request depends on the URI you are issuing the request to, the request method you are using (GET, POST, PUT, DELETE), and the data you send along with your request.
When the server has finished processing your request, it will return the data (or details of any error that may have been encountered) or a suitable JSON response.
You can then parse the JSON in your application and display the results of the transaction accordingly.
Parsing JSON is quite simple, and using a JavaScript framework such as Prototype or jQuery makes sending HTTP requests and parsing JSON responses very simple using Ajax methods.
As JSON increases in popularity, many languages are including support in their standard library.
For languages that don’t have built-in support, there is a wide selection of third-party extensions to almost all popular languages.
Futon If all this API nonsense isn’t making much sense to you, feel free to park it for now, because I will be covering it in more detail later, with detailed examples of how to use the API in your very own CouchDB applications.
Thankfully, the developers of CouchDB decided that you shouldn’t need a degree in computer science in order to interact with the database.
To allow users to interact with the database immediately, they created Futon, the web-based CouchDB administration tool (Figure 1-1)
This visually stunning web application comes bundled with every CouchDB install, and it actually runs on the same server as CouchDB.
As a result, when you start the CouchDB database, Futon is automatically available to you.
Futon is exceptionally feature rich for such a young piece of software.
It allows you to create, modify, and delete databases and documents as you please, and it has advanced pagination and sorting functionality on every screen.
It also allows you to easily compact your database, as well as run a series of diagnostics to ensure your database is working as it should be.
So...Now What? Now that you’ve learned what CouchDB is and how it works, you’re going to dive right in and get a CouchDB development environment up and running.
Over the next two chapters, I will walk you through the process of installing CouchDB on Linux and Mac OS X operating systems.
Then, in Chapter 4, you shall delve deep into CouchDB development by creating your first database.
If you already have some experience with CouchDB, feel free to plough ahead to Part 2 of this book, where I’ll discuss practices for managing CouchDB databases.
In this chapter, you will learn how to install CouchDB on the Linux operating system.
When it comes to setting up Couch on Linux, several options are available, depending on the particular Linux distribution you use.
Precompiled binary versions of CouchDB are available via various package managers; for example, you can use aptitude on newer versions of Ubuntu Linux and yum on Fedora Linux.
Even if your system’s package manager does not include CouchDB itself in its repository, it’s quite likely that it does feature some of Couch’s dependencies (Erlang, ICU, Spidermonkey, libcurl, and so on)
If your operating system does not support one of these package managers (or for some reason you can’t get it to work), all is not lost, because it is not that difficult to compile CouchDB (and its prerequisites) from source code.
Mozilla Spidermonkey is a JavaScript engine that CouchDB uses for creating views using JavaScript code.
You use it so that Spidermonkey can make HTTP requests.
I will cover all these options in great detail over the course of this chapter.
I will then show how to use the yum package manager to install CouchDB on Fedora Linux.
Finally, you will learn the more difficult task of building CouchDB and all dependencies from source code.
You should also be able to follow this guide to install CouchDB on later versions of Ubuntu.
If you are using an earlier version of Ubuntu, however, skip ahead to the “Building CouchDB (and Prerequisites) from Source Code” section for instructions on building CouchDB and its dependencies from source.
I will show you how to install CouchDB’s dependencies using the apt-get command, before downloading the latest release version of CouchDB (0.10.0 at the time of writing) and building it from source.
Before you can install CouchDB, you need to install a series of dependency packages.
If you are using version 8.10 or later of Ubuntu Linux, you can use the apt-get package manager utility to install all these dependencies.
In the Terminal window, issue the following commands to automatically download and install CouchDB’s dependencies.
If any of these packages have further dependencies, apt-get will automatically download and install them, too.
With CouchDB’s dependency packages installed, you are now ready to download and build CouchDB.
In this section, you will download the latest release version of CouchDB (0.10.0 at the time of writing) from an Apache mirror.
In this example, I’m downloading from an Irish Apache mirror site—if you want to find one closer to your location, visit the CouchDB web site at http://couchdb.apache.org.
The following commands will download and unpack the tarball for CouchDB 0.10.0
Let’s enter this directory and configure and build CouchDB from the source code:
You now have CouchDB installed on your system, but you need to do some final configuration before you can launch the CouchDB server.
First, let’s create a user account, couchdb, which will own the CouchDB system directories:
You will be asked a series of questions in order to set up the user account.
When asked for a password, repeatedly hit the Enter key (providing no password) until it stops asking for one.
With the user account created, let’s create the CouchDB system directories and assign ownership of them to the couchdb user.
Finally, you need to copy the couchdb service to the correct folder and configure the service to run at startup:
With that completed, you are now ready to launch the CouchDB server.
Use the following command to start CouchDB as a background service, which will be automatically started when you boot your machine:
You should see a message that the system is “starting database server couchdb,” which will be processed in the background.
If CouchDB is running, you should see a message like the one shown in Figure 2-2
Note It is quite possible that curl is not installed by default on Ubuntu Linux.
If you get a message informing you that curl is not available, simply use the command sudo apt-get install curl to download and install it automatically.
With CouchDB up and running, now is a good time to open the Futon web administration interface and run the Test Suite, ensuring that every component of the CouchDB server is running properly.
Open your favorite web browser, and navigate to the URL http://127.0.0.1:5984/_utils.
On the right side of the page, click the Test Suite link.
On the page that follows, click the Run All button near the top left of the page to begin the tests.
Your browser may become slow and unstable while the tests run, so be patient.
If all is well, you should receive a “Success” response for each test in the list (Figure 2-3)
If you’re set on using localhost, disabling IPv6 will also fix this issue.
That’s it—you now have a working CouchDB server on your Ubuntu system! Feel free to play around with CouchDB using the Futon interface, and when you’re ready, continue to Chapter 4 to learn how to create your first CouchDB database.
This command-line based software management utility will automatically update itself before fetching the requested software and any dependency packages required.
I am installing CouchDB on Fedora 11, but the process should be the same for earlier versions of Fedora.
You will now tell the yum application to install the couchdb package.
It is highly likely that you are logged in to Fedora as a standard user and hence will not have sufficient privileges to install packages with yum.
There’s no need to log out, however; we can use the su command to run a shell command as the root user.
Issue the following command in your Terminal window to begin the installation process:
It will ask you to confirm before the installation starts, as shown in Figure 2-5
Press the Y key on your keyboard, and hit Enter to begin the installation process.
On my system, the total download size amounted to 52 megabytes (MB)
When it has finished downloading all the required packages, it will automatically install them for you.
When it is done, it will give you a summary of what package was installed and what dependencies were installed along with it.
When the installation has finished, you will need to start the CouchDB server.
You should see a message similar to the one shown in Figure 2-7
You may notice that you no longer have a prompt in this terminal window.
Not to worry, just open another Terminal tab by hitting Shift+Ctrl+T.
You will now verify that the server is running properly using curl.
It is highly likely that you already have curl installed on your system, but if you do not, installing it is as simple as issuing the following command:
If curl is not installed, yum will automatically install it for you.
If you have an out-of-date version of curl installed, yum will update it for you.
If you already have the latest version of curl, yum will tell you that it has nothing to do and will quit.
When curl has installed, you can verify that the CouchDB server is running with the following command:
Congratulations, you have now set up CouchDB on your Fedora Linux system! Before you proceed to Chapter 4, it might be a good time to check that Futon, CouchDB’s web-based administration utility, is up and running correctly.
Fire up your favorite web browser, and point it to the following URL:
If Futon is working, you should see an attractive user interface like the one shown in Figure 2-8
I will now show how to run Futon’s Test Suite to perform several diagnostic checks on the CouchDB server.
Click the Test Suit link in the menu on the right side of the Futon screen.
On the Test Suite page, click the Run All link near the top left of the page to begin the tests.
The process should not take long, and with any luck, all the tests will return a success message, as per Figure 2-9
You are now ready to drive ahead and start developing CouchDB databases and applications.
Feel free to skip ahead to Chapter 4, where you’ll see how to create a CouchDB database.
Building CouchDB (and Prerequisites) from Source Code If your system does not have a package manager with a CouchDB package available or you want to be sure that you are installing the latest version of Couch, your best bet is to compile CouchDB from source code.
In this section, I will not only walk you through the process of building CouchDB from the source code for the latest trunk version, but you will also learn how to manually build the prerequisite applications you will need in order to use CouchDB—Erlang, libcurl, ICU, Spidermonkey, and Subversion.
Caution It is worth mentioning at this point that building software from source code is not for the fainthearted.
Things often go wrong, and you are pretty much on your own when it comes to fixing any issues that arise.
At the very least you should be comfortable working at the Linux command line.
This procedure has been tested on Slackware Linux 12.2, but they should work on any Linux distribution.
It is assumed that you have OpenSSL installed, as well as the following development tools:
Note Older versions of the client version of Ubuntu Linux did not install these tools by default.
If you have any trouble installing a particular package, the best place to look for help is the relevant application’s documentation or manual.
For the most part, you will be entering commands in the Terminal window, and you will need to run these commands with administrative privileges.
To do this, you will need to prefix your commands with su -c and wrap the command you are calling in single quotes.
You may be asked to authenticate the first time you use this.
For the most part, I will be working from my home directory.
Most of the software will be installed to various locations throughout the Linux filesystem, so where exactly you download and compile the applications is not important.
If you’re not sure where you are, use the command pwd to print your working directory.
Building Erlang The first application you are going to download and build is Erlang.
This was the latest stable release available at the time of writing.
Feel free to change the download URL to a newer version of Erlang if you want.
When the download has completed (it may take a while, because it’s quite a large file—around 5060MB), issue the following commands to create a new directory from which you will build Erlang:
This will create a new directory called otp_src_R13B01 under /usr/local/erlang.
Now you are ready to go ahead and build your Erlang installation.
Please note that each of these commands will take a considerable amount of time to run, because you are compiling the source code for the entire Erlang programming language.
When Erlang has finished compiling, you can test that it is working by running the Erlang prompt.
Simply enter the command erl to open the compiler, and you should see a prompt similar to that in Figure 2-10
Before you do so, return to your home directory (or wherever you’re using as your base for downloading packages) by issuing the following:
Building libcurl The libcurl library is very simple to build.
Now extract the contents of the archive using the following command:
Now issue the following commands to configure and build curl and libcurl:
Building ICU Installing ICU is relatively straightforward, and the steps are similar to those you followed to build Erlang.
The first step is to download the ICU source distribution.
The latest version of ICU available at the time of writing was 4.2
Check the ICU web site for newer versions if you so wish.
When the download has finished, decompress and extract the archive file using the following command:
This will extract the contents of the archive into the icu directory.
I will now show how to change to the source subdirectory inside this new directory and change the permissions of a few files to make sure they are ready for the build process:
Next, you need to run the configuration script and start the compilation process itself:
The next dependency for CouchDB you need to install is Spidermonkey.
Once again, navigate back to your home directory before proceeding to the next section.
Building Spidermonkey To build Spidermonkey, you will need to have several prerequisite packages installed on your system.
Most of these packages (Perl, gcc, GNU make, and so on) are preinstalled on most Linux distributions.
If you are using an older version of Ubuntu Linux, it is possible that you may not have all of these dependencies installed.
You can install all of Spidermonkey’s dependencies using the following commands:
Ensure you are in your home directory, and you can proceed to download and build Spidermonkey.
I’m going to install Spidermonkey 1.7.0, because it works well with recent versions of CouchDB.
If you want to use 1.8.0, be sure to build CouchDB from trunk.
If you are building this version of CouchDB, ensure you use Spidermonkey 1.7
When the distribution package has finished downloading, use the following command to decompress and extract it:
Now navigate into the src subdirectory of the js directory:
From here you can compile Spidermonkey using the following commands:
Spidermonkey is now installed! The final prerequisite you need to build before building CouchDB itself is the Subversion, the version control system you need to use to get the latest “trunk” version of CouchDB.
Building Subversion The CouchDB source code is maintained in a Subversion repository on Apache’s servers.
To download the latest build of CouchDB from trunk, you need to have a Subversion client installed on your machine.
In this section, I will show how to build Subversion from source code.
Note Subversion is only required to retrieve the latest version of CouchDB from trunk.
If you are building a release version of CouchDB, you can skip this step and download the source code from the CouchDB project web site instead.
Subversion has a number of dependencies that are required, which vary based on whether you are installing Subversion client or server.
Fortunately, an archive containing the dependencies for the client is available, which can be extracted so that the prerequisites are automatically built along with Subversion.
If you follow these instructions, you will not need to take any further steps to install Subversion’s dependencies.
First, download the Subversion source code and the dependency archive using the following commands (make sure you’re in your home directory):
The dependency archive will extract the dependencies into the same directory as the Subversion source code archive was extracted to.
In the next section, you will use Subversion to get the latest version of CouchDB from trunk, before building CouchDB itself.
Building CouchDB First and foremost, congratulations for making it this far! Building applications from source distributions is not light work.
You will now download the CouchDB source distribution from trunk using Subversion.
Navigate back to your home directory, and use the following command to check out the latest version of CouchDB from the project’s Subversion repository.
The first thing you need to do is bootstrap the source code.
When the bootstrapping has completed, you will see the message “You have bootstrapped Apache CouchDB, time to relax.” Now you will run the configuration script.
When the configuration process has completed, enter the following command to install CouchDB:
You’re nearly there! Before you start the CouchDB server, you just need to create a user for couchdb, create a few directories, and set some permissions.
Firstly, create a couchdb user by issuing the following command:
The system will ask you to enter a series of details for the new user.
Simply accept the default options, and make sure you supply no password when prompted.
You should see a message “Account setup complete” when the account has been created.
Now you will create some directories and change the ownership of those directories to the couchdb user.
With all that done, you are now ready to start the CouchDB server.
The following command will start the CouchDB server in the background:
You should see a message “Starting database server couchdb” to confirm that the server is indeed starting.
Let’s perform a quick check to see that it is indeed working:
If the CouchDB server is running, you should see a message like this:
If, for some reason, the server is not running and you get an error message when you try the previous line, it may be an issue with the initialization script.
If the build was successful, you should see a message saying “Apache CouchDB has started – Time to relax.” Open up a second Terminal window, and try the curl command shown previously again—this time it should work.
Before you move on, now would be a good time to test that Futon, CouchDB’s administration utility, is working correctly.
Futon provides a suite of diagnostic tests that will ensure that your CouchDB installation is healthy.
Now that you have Futon open, click the Test Suite link in the navigation menu on the right side of the screen.
From here, click the Run All link near the top left of the page to start the Futon diagnostic tests.
Ideally, all the tests will run and return a “success” status message, as in Figure 2-12
Congratulations, you have just successfully built CouchDB and its prerequisite packages from source code.
You are now armed with all the tools you need to go forward and start learning how to create CouchDB databases.
In the next chapter, you will learn how to install CouchDB on Mac OS X.
In Chapter 4, you will learn how to create your first CouchDB database.
In this chapter, you will learn how to install the CouchDB database on Mac OS X.
There are several ways of installing CouchDB on the Mac.
An unofficial “one-click” package, CouchDBX, is available and provides an easy-to-use way of trying CouchDB, if you don’t like to get your hands dirty.
I will talk about this in more detail later in this chapter.
At the other end of the spectrum is the option to build CouchDB directly from source code.
This is quite complicated and is recommended only to power users who want the highest level of flexibility with their CouchDB installation.
Thankfully, there’s a happy medium that offers relative simplicity in terms of installation while allowing you a high level of control in the configuration of your CouchDB setup.
This method is what I refer to as the “MacPorts” method.
Before you can install CouchDB using MacPorts, you need to take care of a few dependency issues.
You can install the tools from your Mac OS X installation CDs/DVD, or alternatively you can download them from the Apple Developer Connection web site.
Then you need to install MacPorts, an excellent open source package manager for Mac OS X.
Once you have these dependency issues sorted out, installing CouchDB is a piece of cake.
Installing the Xcode Developer Tools The Xcode developer tools are a suite of utilities for creating software applications that run on Mac OS X.
Although not installed by default, Xcode can be found on your Mac OS X installation DVD/CDs and installed in a few simple steps.
If you have lost the DVD/CDs that came with your Mac, you can download Xcode from Apple’s Developer Connection (ADC) web site free of charge.
In this section, I will walk you through the process of downloading Xcode from ADC and installing it on Mac OS X Leopard (10.5)
If you are installing Xcode on an earlier version of Mac OS X, you will need to download a different release of Xcode, because version 3.0 is not supported on older Mac OS X releases.
The first thing you need to do is download the latest version of the Xcode developer tools from ADC.
You should see a page similar to that in Figure 3-1
On this page you will see two options: Xcode for iPhone and Mac Development and Xcode for Maconly Development.
Click the Download Now button next to the second option.
Note that if your Mac has an Intel (not a PowerPC) processor, you can install the Xcode for iPhone and Mac Development option.
In addition to registering for ADC membership, you will need to register as an iPhone developer.
Please note that there may be small differences in the following steps if you choose to go down this path.
The next screen (Figure 3-2) asks you to log in as an ADC member with your Apple ID and password.
If you are not an ADC member but you have an Apple ID, enter those credentials; you will be brought to a page to complete your ADC membership registration.
If you do not have an Apple ID, you will need to use the “sign up” link at the bottom of the page to get one before you can log in and download the Xcode tools.
Once you have logged in to ADC, you will see a page similar to that shown in Figure 3-3
At the time of writing, the latest available version of Xcode was 3.1.2
Even on a decent broadband connection, the download may take over an hour.
If this is not an option for you, I recommend that you install Xcode from your Mac OS X installation media instead.
Although the download page says that this is a DVD disk image, it does not mean that you need to burn it to DVD before you can use it.
When the download has completed, the disk image should automatically mount and pop up a Finder window.
From here, you can launch the Xcode installation application by double-clicking the XcodeTools.mpkg icon, as shown in Figure 3-4
The Xcode Tools Installer will now load, and you can click the Continue button to begin the install.
On the screen that follows, click the Continue button once again, which will pop up a confirmation dialog box, asking you to agree to the terms of the software license agreement.
Click Read License to read these terms, and once you are satisfied, click the Agree button to move on.
On the Custom Install on “Macintosh HD” screen, you can accept the default selections and click the Continue button to advance to the next screen.
If you want to change the location where Xcode will be installed, you can click the Change Install Location button here; otherwise, simply click Install to begin the installation procedure.
You will now be asked for your Mac OS X system password.
Enter it (if you have one), and click OK to continue.
The installation procedure will now begin, and depending on your hardware, the process should take approximately ten minutes.
When the installation process has completed, you should see something similar to the screen shown in Figure 3-5
Installing MacPorts I am going to show how to install CouchDB using an excellent, open source package manager for Mac OS X called MacPorts.
Unfortunately, MacPorts is not included as part of Mac OS X, and therefore you need to install it before you can use it to install CouchDB.
You will install MacPorts by downloading the latest binary package from the MacPorts project web site.
Before beginning, please ensure that you have installed Xcode (see the previous section for detailed instructions on how to do this), because some of its components are required in order to install MacPorts.
Let’s dive in and get MacPorts up and running on your system.
Open your favorite webs browser, and visit the Installing MacPorts page on the MacPorts project web site:
This page should look something like the one shown in Figure 3-6
Simply click the relevant link for the version of the operating system installed on your Mac, and the download will start.
As soon as it has downloaded, the disk image will mount, and the installation application should open immediately.
When the installer starts, you will be informed that the package contains a program that determines whether the software can be installed, and it will ask whether you are sure that you want to continue.
Simply click the Continue button to close this message, and you will be brought to the MacPorts installer, which should look similar to Figure 3-7
When this window appears, click the Continue button to move to the next part of the installation, which gives you information about MacPorts, its requirements, where it will be installed, and how to use it.
On the Software License Agreement screen, click Continue to bring up the confirmation dialog box asking you to agree to the terms of the software license agreement.
If you like, read the license, and when you’re ready, click the Agree button to continue with the installation.
I don’t recommend changing the installation target location, but if you feel the need to do so, you can click the Change Install Location button on the next screen to change it.
Otherwise, just hit Install, and the installation procedure will commence.
As with Xcode, you will now be asked for your Mac OS X system password.
Enter it, if you have one, and click OK to start the install.
The entire process should only take a couple of minutes to complete.
When it is finished, you should see a message like the one in Figure 3-8
Before we move ahead and install CouchDB itself, let’s perform a quick test to ensure that MacPorts is working as expected.
The easiest way to do this is to open Spotlight (Cmd+Spacebar) and enter Terminal into the Spotlight text box.
You should see Terminal as the Top Hit items and under the Applications section, as shown in Figure 3-9
To verify that MacPorts is working correctly, type in the following command in the Terminal window:
If MacPorts has been installed and configured as required, you should see output similar to that in Figure 3-11
Now that you have MacPorts installed, you are only a short section away from having CouchDB up and running on your Mac OS X system.
Enter the quit command to exit the MacPorts interactive prompt and return to the shell.
Installing CouchDB In this section, you will use MacPorts to install CouchDB on your Mac.
CouchDB has many dependencies, but fortunately you do not need to worry about sourcing all of these because MacPorts will automatically download and install them for you prior to installing CouchDB.
As a result, installing CouchDB itself is not difficult at all.
At the end of the previous section, you checked that MacPorts was installed by opening the Mac OS X Terminal application and starting the MacPorts interactive prompt.
If you closed that window, simply follow the same steps to open a new Terminal window.
You may be presented with a warning about improper use of the sudo command and will then be asked to enter your password.
Enter your password, and after a short time MacPorts will begin fetching and automatically installing all of CouchDB’s dependency packages.
Please note that this may take some time (about an hour or maybe even longer on some systems), so it might be a good time to take a break!
Caution In Mac OS X Leopard (10.5), the sudo command will not work if the user you are logged in as does not have a password set.
If you simply hit the Return key when prompted for your password, sudo will just exit, and nothing will happen.
In the Accounts preferences pane in your Mac OS X System Preferences, set up a password for your user account before you attempt to use MacPorts to install CouchDB.
You can remove it after the installation has been completed if you want.
You’ll know that the installation of CouchDB and its dependencies is completed when you are returned to the prompt and your Terminal window looks like the one in Figure 3-12
Before you take CouchDB out for a test-drive, let’s make sure that all the dependencies are up-todate.
Back in the Mac OS X Terminal application, enter the following command (you’ll need to provide your password again):
In most cases, there should be nothing that needs updating, but if you already had MacPorts installed before reading this book, this command will ensure that any CouchDB dependencies that were already previously installed are up-to-date.
The final command you are going to run will configure CouchDB to run as a Mac OS X service and tell it to run CouchDB every time Mac OS X boots up.
This step is optional, but if you don’t complete, it you will need to start CouchDB manually every time you want to use it.
This command will have started CouchDB, but if you have chosen not to install as a Mac OS X service, you will need to manually start the server.
Remember, you do not need to do this if you ran the previous command.
If, for some reason, you need to stop the CouchDB server at any stage, you can use the following command to do so:
Now, let’s run a couple of quick checks to make sure your CouchDB setup is running nice and smoothly! First, you will make sure that the CouchDB server is working correctly.
The easiest way to do this is to use curl to make a CouchDB request.
If the CouchDB server is running, you should see a message similar to the following:
You can perform the same test by simply visiting http://127.0.0.1:5984 in your favorite web browser.
Doing so, you should see a result similar to the one shown in Figure 3-13
The final test you will run is a quick check that Futon, the CouchDB web-based administration interface, is up and running.
To check this, visit http://127.0.0.1:5984/_utils/index.html in your favorite web browser.
You should see a rather pretty page, like the one in Figure 3-14
From the Tools menu on the right side of the Futon interface, click the Test Suite link.
This will bring you to a page where you can run a series of diagnostic tests to make sure that all aspects of your CouchDB server are running as they should.
Click the Run All link at the top of this page to begin the tests.
All going well, you should have zero failures, and the result should look something like the page in Figure 3-15
Congratulations! You now have a fully operational installation of CouchDB running on your Mac OS X system.
If you chose to run the command to install CouchDB as a service, it will start up automatically each time you boot up your Mac.
Feel free to skip ahead to the next chapter, where you will learn how to create a database and the basics of database development with CouchDB.
CouchDBX: A One-Click CouchDB Package for Mac OS X If the idea of installing Xcode, installing MacPorts, and getting down and dirty with the Mac OS X Terminal are not your cup of tea, there is an alternative! An unofficial one-click CouchDB package known as CouchDBX will get you up and running with a CouchDB server without installing anything.
It doesn’t offer the flexibility or configurability of a full install, but it’s great for trying out CouchDB quickly.
It can even be used on a machine that has a full version of CouchDB installed!
To get CouchDBX, visit http://janl.github.com/couchdbx/, and click the Download link.
This particular version is approximately 12 megabytes in size, so it shouldn’t take too long to download, even on slower Internet connections.
When the download has completed, you should have a CouchDB icon in the folder where your browser downloads are stored.
Simply double-click this icon to run CouchDBX, and you should see a screen similar to that shown in Figure 3-16
That was much simpler, now wasn’t it? There’s no doubting the fact that CouchDBX is the fastest and easiest way of getting a CouchDB environment up and running on your Mac.
You can use CouchDBX to work through most of the content of this book, although if you are serious about CouchDB development, I highly recommend that you consider installing CouchDB on your system, either using MacPorts or building from the source code.
It offers far superior performance and higher levels of reliability and flexibility when it comes to your CouchDB setup.
In this chapter, you will learn how to interact with the CouchDB database server—primarily by means of learning how to perform basic tasks using the HTTP API, including the following:
If you have experience with traditional database management systems that use Structured Query Language (SQL) to interact with the database, the concepts introduced in this chapter may be quite alien at first.
Unlike SQL-based databases, CouchDB does not come with its own client application; rather, you communicate with the server using any application or language that supports HTTP requests.
Another thing that might seem strange is that I won’t discuss the design of your database before you go ahead and create it.
You don’t need to define the table structure for your database, because there are no tables.
You don’t need to draw up an entity relationship diagram (ERD) because there are no relationships.
CouchDB is a schema-free database management system, meaning you don’t have to worry about these things before you create your database; you can change any of these as required without negatively impacting your existing data.
Tools of the Trade As mentioned, CouchDB does not come with a client application for connecting to the database server (well, actually it does, in the form of a web-based interface called Futon, but I’ll discuss that in more detail later)
Instead, you can interact with the CouchDB server using any piece of software or any programming language that supports making HTTP requests to a web server.
CouchDB’s API defines a series of methods that allow you to create databases, create documents, modify existing documents, and do all the other features you’d expect from a database management system.
CouchDB then sends a response to the application in the form of JavaScript Object Notation (JSON), which can easily be parsed by most modern programming languages.
Note Up until this point, all UNIX commands have been prefixed with the prompt symbol ($)
This is the final chapter in which I will include the prompt before these commands.
In this chapter, you will issue commands to your CouchDB server using the curl utility.
If you want to check that curl is installed on your system, open a Terminal window or command prompt, and enter the following command:
If curl is installed (and assuming you have CouchDB running on your own computer), you should receive a response like the following:
Later in this book you will use other tools to interact with the CouchDB database, including CouchDB’s very own Futon web-based administration interface, the JavaScript client-side web development language, and the PHP, Ruby, and Python programming languages.
You probably recognize it from the start of web addresses (for example, http://www.apress.com)
In CouchDB, you really need to be concerned with only four of these methods—GET, POST, PUT, and DELETE.
CouchDB also uses an extension method provided by the HTTP protocol—COPY.
What each method is used for is actually quite self-explanatory: GET is used to retrieve data from the database, PUT is used to insert new data and modify existing data (POST can also be used, but it is not recommended in most cases), DELETE is used to delete data from the database, and COPY is used to copy documents in the database.
You will learn a lot more about how these request methods are used as you progress through this chapter.
The data is written in the form of a JavaScript object, which is where the name comes from.
A JSON object is opened and closed with curly braces, with a collection of comma-separated key/value pairs enclosed within these braces.
Using curl curl is a lightweight command-line tool for transferring data to or from a server using various protocols, such as HTTP, HTTPS, and FTP.
In this chapter, you will be using it to interact with CouchDB’s HTTP interface.
The most basic use of curl is to simply pass it a URL as an argument, and by default it will issue an HTTP GET request to the URL supplied.
You have already seen an example of this earlier in this chapter, where you passed http://127.0.0.1:5984 as an argument to the curl utility.
First, the -X flag allows you to tell CouchDB which HTTP request method you want to use.
This is important because the HTTP request method will define what exactly the CouchDB server will do (for example, GET retrieves, PUT creates/modifies, and DELETE destroys)
This allows you to define HTTP headers in your requests to the CouchDB server.
When you create documents in CouchDB, you define your documents in JSON and send this JSON data to the server.
Unfortunately, older versions of the CouchDB server have no way of knowing what type of content this is unless you explicitly tell it.
Luckily, you can use the -H flag and pass the string Content-Type: application/json, which does just that.
The final option you need to know about is the -d option.
This allows you to include data (the message part of the HTTP request) when communicating with the CouchDB server.
This is essential when you want to create meaningful documents or make any changes to existing documents.
You will be using the -d flag to send your JSON document definitions and JavaScript view definitions to CouchDB.
If this doesn’t make any sense to you at this point, don’t worry—it should become a lot clearer in the next section when you actually start working with the database.
Creating Your First Database Let’s dive right in and create your first CouchDB database—a simple contacts database where you will store information much like that in an address book or phone book.
Note In all the following examples, I am assuming that you have the CouchDB server installed and running on your local machine.
If you are interacting with a remote CouchDB server, replace the IP address 127.0.0.1 with the IP address of the machine where CouchDB is installed.
Creating the database is simple—just issue the following command in your Terminal window or command prompt:
Here you are making an HTTP PUT request to the /contacts resource of the CouchDB server.
CouchDB translates this as “Create a new database named contacts.” When the database has been created, CouchDB responds with the following JSON object:
The previous message basically means that the operation was successful and CouchDB encountered no errors in the process of creating the contacts database.
That’s great, but what would happen if CouchDB did encounter an error? Let’s investigate by trying to create another database with the same name.
Hit the up arrow in your Terminal window or, if required, retype the previous command:
This time around, you should receive a much different response than the last time:
As you can see, the CouchDB server attempted to create another database called contacts but could not do so because it already exists.
It then sent a JSON response with two fields—the error field with the error code value file_exists and the reason field with a user-friendly error message informing you that the database could not be created because the file already exists.
Now that you have created a database, let’s ask CouchDB to specify what databases are currently available on the server.
This is a JavaScript array of all the databases currently stored on the CouchDB server.
Let’s see how it looks when there are multiple databases; create a second database called books:
Now let’s ask CouchDB once more to list all the databases available:
These databases were automatically generated by the Futon administration tool’s Test Suite, which you earlier used to verify that CouchDB was working correctly.
You can safely ignore these databases and continue as if they didn’t exist.
You’ll be working on the contacts database for the remainder of this chapter, so you have no need for the books database.
Let’s get rid of it by issuing the following command:
Now let’s see whether you can generate another CouchDB error message.
Press the up key to bring back the last-issued command or, if required, reenter the following:
This time, the response you receive should be an error message saying that the database doesn’t exist:
Tip At this point, you may want to delete those extra databases that were automatically created by the Futon administration tool’s Test Suite.
For most of them, this is a simple case of using the previous command and replacing books with the name of the database you want to delete.
Before moving on to working with documents in your newly created database, let’s issue a command that will provide some information about the contacts database:
These values should change substantially over the course of the coming sections as you work with documents.
Creating Documents in Your Contacts Database If you were working with a traditional relational database management system, at this point you would be defining the schema for your database and mapping out the various tables, columns, and relationships that are required for a contacts database.
You would be trying to work out all the different fields that may be required—for example, some contacts may have a fax number, an MSN Messenger account, or a Skype account that you want to include.
So, in your table design, you would need to have columns for each of these fields.
You may want to allow each contact to have several phone numbers and put these into a separate table that holds the type of number and the number itself, as well as a foreign key to map these numbers back to the contact record.
With CouchDB, however, you don’t have to do any of this.
CouchDB databases are schema-free, meaning that their structure is not strictly defined, and as a result you can change them on the fly as your needs require.
If one contact has a fax number, you include it in that contact’s document.
If another contact doesn’t have a fax number, you simply don’t include it.
If a contact has several phone numbers, you can set the phone_number field to be an array of phone number objects—there is no need to define separate tables.
In the contacts database, each contact that you create is considered to be an individual document.
It may help to think of how a contact would be represented on a physical document—such as a business card.
Every business card is a separate document, and the same applies to the contacts in the CouchDB database.
You’ve just created a document with the document ID of johndoe.
The CouchDB server has automatically generated a revision number and included this in its response.
Tip When passing data to a CouchDB API using the -d flag, it is recommended that you encapsulate your JSON code using single quotes rather than double quotes.
Therefore, if you wrapped your -d argument in double quotes, you would need to escape every double quote you used in the code.
Now that your document is in the database, let’s issue a command to retrieve it from CouchDB:
At this point you’re probably thinking that this contact isn’t very useful.
All it has is a unique ID and a revision number; it has no contact-related data whatsoever.
Deleting a document in CouchDB is quite similar to deleting a database, except you must specify the latest revision number of the document you want to delete.
Issue the following command to delete your johndoe document from the database (be sure to replace the revision number after ?rev= with the actual revision number of your document):
All going well, you should receive a response similar to the following:
Note If you pass the wrong revision number as a parameter when attempting to delete a document, you will get an error such as “Document update conflict.” If you get this error, make sure your revision number is correct and try again.
Let’s make sure the johndoe record is deleted by trying to retrieve the document once again:
If the document has been deleted, you should receive the following response:
Now you will create a new contact, but this time around you will actually include some data for the document.
A document in CouchDB is simply a JSON object, and you simply include this JSON in your curl request using the -d flag to send it along with your HTTP request.
I am now going to create document of my own contact details with fields for my first name, last name, and e-mail address.
In nicely formatted JSON, this document looks like the following:
Let’s create this document now by issuing the following command:
When the contact has been created, you should receive a response like the following:
Caution You need to be careful of a couple of things when entering JSON data through curl.
The first is that although the JSON code may run over several lines, it’s important that you do not cause line breaks by pressing Enter or Return yourself.
Just let the commands wrap onto the next line themselves.
Second, JSON data must be escaped when passed as data in curl.
As you can see in the previous example, I am escaping every double quote character by inserting a backslash in front of it.
If you do not do this, you can expect an invalid_json error to be returned by the CouchDB server.
Now let’s get back this document from the database, with the following command:
You should see a more interesting result, like this one:
As you can see, your contact document now includes the data you specified as well as the document ID and revision number.
Let’s create another contact, but this time around let’s copy the existing contact details instead of starting from scratch.
The response this time just gives the revision ID for the new document:
Let’s check that the document looks right using a GET request:
As you can see, all the details from the joelennon contact were copied to a new document with the document ID johnsmith.
Now let’s update this document with John Smith’s actual contact details.
In this example, you are also going to include a phone number and a second e-mail address.
John Smith’s contact document in nicely formatted JSON looks like the following:
To update an existing document, you must include the revision field in your JSON document, with the revision identifier that the changes are based on.
This is for conflict detection purposes and will prevent multiple users from making changes to the same document at the same time.
So, to update the johnsmith contact, you can use the following:
Let’s check it out with a GET request at any rate:
This time you should get a response like the one shown here:
Getting Started with CouchDB Views If you have ever used a traditional relational database management system, you’re probably wondering at this stage how you are going to actually perform meaningful queries on the data in your database.
Note In this example, you will write your view using the JavaScript view engine that ships with CouchDB.
Views can be written in any language that has an engine written for it—at the time of this writing, engines existed for languages including Python, PHP, Ruby, and Erlang.
It is worth noting that support for native Erlang views is planned for CouchDB 0.10.0
This specialized built-in view returns a listing of all documents in a CouchDB database.
This will return a response with a count of the documents in the database, as well as document IDs and revision numbers for each document, as shown here:
The total_rows field tells you the number of documents stored in the database.
You can reverse the order by issuing the query string descending=true:
As you can see, the results are identical except the contents of the rows array appear in the reverse order:
You can limit the number of documents to return using the limit query parameter.
In the following example, I am limiting the results of the _all_docs view to just one, with the order still set to descending.
Be sure to escape the & character by prefixing it with a backslash.
This returns similar results to the previous queries, except that it also returns the actual data stored in each document.
The response should be similar in format to the following text:
The second and final built-in view I’ll cover is the _all_docs_by_seq view.
This view returns all documents in the database, including deleted ones, ordered by the last time they were modified.
This should return both of the documents that currently exist in the database, along with the johndoe contact you created and subsequently deleted earlier in this chapter:
In Chapter 1, you discovered what CouchDB is and how it differs from traditional relational database management systems.
You learned about CouchDB’s history and all about the building blocks of the database server.
In Chapter 2, you learned how to install the CouchDB server on the Linux operating system.
You first learned how to install CouchDB from source code on Ubuntu Linux, installing dependencies using the apt-get package utility.
In Chapter 3, you learned how to install CouchDB on a Mac OS X machine.
You also sourced and configured the MacPorts package manager, before using MacPorts to retrieve the CouchDB binary package and install it.
I also briefly discussed the CouchDBX one-click package available for Mac OS X.
Finally, in this chapter, you undertook the task of creating your first CouchDB database using the command-line tool curl.
You learned how to create and delete databases and how to retrieve a list of all available databases.
Next you looked at database documents and how they are created, deleted, copied, and modified.
I rounded up this chapter and this part of the book by covering some of CouchDB’s builtin specialized views for retrieving all documents and some of the parameters that can be used to manipulate the resultset returned by these views.
In the next part of the book, you will take an in-depth look at managing CouchDB databases, namely, using the Futon web-based administration interface, a more detailed investigation of CouchDB’s API, an overview of the concept of map/reduce and how to use it in CouchDB, and the creation of views using the JavaScript view engine.
Now that you have a working installation of CouchDB up and running and you’ve.
CouchDB features that you can use to manage your database.
Notation and how it is used to store documents in CouchDB databases.
You then conclude this part of the book with a.
As you saw in Chapter 4, CouchDB offers a powerful RESTful API that can be interacted with via any software that supports making HTTP requests.
You used the curl command-line utility to create a database and documents, modify documents, and delete documents.
Although the syntax and process of using curl for this purpose is quite straightforward, it’s not ideal for day-to-day database management.
Imagine retrieving all the documents in a database that contains thousands, or even millions, of documents.
Fortunately, CouchDB also comes with a graphical interface to the database: Futon.
Futon is a webbased administration tool that is built in HTML, CSS, and JavaScript.
It is an interface that is as simple to use as it is easy on the eye.
By default, you can access Futon by the /_utils URI of the CouchDB server.
So, if you have CouchDB installed on your local machine, you can access Futon via the URL http://127.0.0.1:5984/_utils.
Enter this URL into your favorite web browser to launch Futon.
On Futon’s start page (Figure 5-1), you will notice that the interface is divided into two key sections: the navigation bar located on the right and the main area on the left.
The navigation bar has links to some useful CouchDB tools, as well as links to some recent databases you have worked on.
This list may be empty at this point, but you will notice it populating as you start to use Futon.
You will take a look at the tools Futon provides later in this chapter.
The main area of the CouchDB interface is where you will spend most of your time interacting with CouchDB databases—creating databases and documents, uploading attachments, modifying documents, compacting databases, and deleting databases.
In the main section of the Futon interface, you should see an “Overview” heading at the top.
This is a breadcrumbs navigation trail, and when you start navigating into databases and documents, this area will give you an easy way of getting back to previous pages.
Beneath the heading bar, you should see a plus icon (+) and a Create Database link.
As you might expect, this link simply allows you to create a new CouchDB database.
If you followed Chapter 4 of this book, you should see a single row for the contacts database.
You’ll notice that the name of the database is highlighted in bold and is red.
This is because this is a link to navigate to a page where you can manage that particular database.
In the footer of the databases table, there is a pagination bar, which will tell you the total number of databases on the server, as well as allow you to define how many databases should be displayed per page (ten is the default setting)
If you have at least ten databases, you can navigate from page to page using the Previous Page and Next Page links on the right side of the pagination bar.
Don’t worry about these databases; you can delete them through Futon in due course if you so wish.
Alternatively, you can just leave them there; they’re not doing any harm.
As you create more CouchDB databases, the table on this page will start to populate with more rows.
Creating a Database Click the Create Database link near the top of the page, just beneath the Overview header.
This will pop up a modal dialog box, like the one shown in Figure 5-2
The dialog box asks you to enter a name for the database.
As a general rule of thumb, I prefer to name databases using only lowercase characters and the underscore (_) character.
This avoids any potential issues with URL encoding and escaping characters when using the API.
In this dialog box, enter books in the Database Name field, and click the Create button.
CouchDB will create a new database with the name books and will take you directly to its Futon page, http://127.0.0.1:5984/_utils/database.html?books.
You may notice that the books database has been added to the Recent Databases list.
Also, notice that in the heading bar in the main section of Futon, alongside Overview you have an arrow and the name of the database.
This will bring you back to the Futon start page.
On the right side of the heading bar, you will notice a small gray shape that looks like a signpost.
This is a link to the raw view of the database, showing the JSON code that it is made up of.
Click that link now to view what the raw code looks like.
You may recall this specialized view from Chapter 4, when you used curl to get this same data from the contacts database.
Try changing the books segment of the URL to contacts and see what happens.
Now, go back to the Browse Database page for the books database using your web browser’s Back button.
You should be back at the page that looks like Figure 5-3
These links are pretty selfexplanatory, and you will learn about them in more detail in a moment.
A bit further to the right of these links you’ll notice a “Select view” drop-down box.
If you expand the list, you should also see the Design Documents and Temporary View options.
Below these links and the “Select view” drop-down box, there is another table, similar to the one you saw on the Futon start page.
This time, however, there are only two columns: Key and Value.
You’ll notice that the Key column has a darker shade of gray background, and there is an arrow on the right side of the column heading.
This is used to change the sort order of the data in the table, and you will see it in action shortly when you start working with documents.
This table’s footer is identical to the one you saw previously, with pagination information and links.
It works exactly the same as the one in the table of databases.
Click the Overview link in the heading bar to return to the Futon start page.
You’ll notice that there are now two rows in this table—one for the books database and one for the contacts database (Figure 5-6)
Rows in this table are ordered alphabetically, so books will appear above contacts.
I used the name games, but it really doesn’t matter.
When CouchDB has created the database, you will be brought to the database’s page on Futon.
It should be pretty much identical to the page you saw moments ago for the books database.
This time, however, you’re just going to go ahead and delete the database.
Futon will ask you to confirm that you want to delete it, because it is irreversible (Figure 5-7)
You will now be back at the Futon start page, and you’ll notice that there is no sign of the database you just deleted.
Next you will look at creating documents in your database.
Creating a Document Click books to open the Futon page for that database once again.
A modal dialog box will appear asking you to enter a unique ID of the document or to leave the field empty to get an autogenerated ID (Figure 5-8)
For the first document, leave the Document ID field blank, and click the Create button.
CouchDB will automatically assign the document a universally unique identifier (UUID) and revision number.
When the document has been created, you will automatically be brought to a page that allows you to work with that document.
In the heading section, you will notice that the document ID has been added to the breadcrumbs trail.
Like in the database view page, you also get a link to view the raw data.
Below these links once again is a table, with Field and Value columns.
You will notice at the top right of the table there are two tabs: Field (currently selected) and Source.
Click the Source tab to view the JSON source code of the document.
The footer in this table is not like the ones you have seen previously, but rather it has Previous Version and Next Version links (which are likely grayed out at this point) for viewing other versions of the document.
As I pointed out in Chapter 1, every time you update a document in CouchDB, the existing document is not in fact modified, but rather a new revision is created to reflect the changes.
These links allow you to flick through previous versions of the document as you require.
Caution Previous versions of CouchDB documents are deleted when the database is compacted, so don’t assume that old revisions will always be available.
Let’s remove this document altogether by clicking the Delete Document link.
Again, you’ll be asked to confirm that you want to delete the document.
Click the Delete button, and you will be brought back to the books database page.
Now create another document, but this time give it a meaningful ID, rather than asking CouchDB to generate one.
Click the Create Document link, and this time when asked for a document ID, enter 978-1-4302-7237-3
Right now, this data isn’t exactly very useful; it merely tells you the ISBN of some book.
Let’s make it more useful by entering some more fields.
A new row will be added to the table, with a text box shown in the Field column, with the value “unnamed” selected.
After the text box, you will see two tiny images, a green check and a red cross.
Clicking the green check mark saves any changes you make; clicking the red cross cancels and reverts it to the previous value.
Enter title as the field name, and press Enter to close the text box.
You will notice that the text will now be a noneditable label, and it has a gray x icon to the left of it.
Try clicking the icon; the field will be removed immediately.
Changing the field name is very simple—simply double-click the name, and it will show up as an editable text box once again.
In the Value column, you will see that the title field is set to null.
This is modified in the same way as the field name column is, by double-clicking the current value to display an editable text box.
Enter Beginning CouchDB in this text box, and press Enter to leave the edit mode.
If you have entered it correctly, the text should turn green.
Caution It is important to include the surrounding double quotes when entering string values into the database—these tell CouchDB that you are entering a string.
If you forget the quotes, you will get an error message: “Please enter a valid JSON value (for example: “string”).” Simply wrap your value in double quotes, and it should save.
The following are the field names and values I have entered for this document:
In Figure 5-11, you will see how these fields look on the document page in Futon.
You will notice that the two price fields do not have double quotes wrapped around them.
The reason for this is that these values are numeric, not strings.
You will also notice that the tags field has an array of three string values: "database", "couchdb", and "beginner"
Futon nicely displays these values each on a separate line, prefixed by each tag’s index in the array.
An important thing to note at this point is that all these new fields have not yet been saved to the database.
To do so, you need to click the Save Document link above the table, which will commit these changes to the server.
Next, let’s take a look at how all of this looks in JSON representation.
Click the Source tab, located at the top right of the document table.
You can see a similar view of the data, albeit not as nicely formatted and without the syntax highlighting, by clicking the gray shape on the right side of the heading bar.
This will show the raw JSON data, as it is retrieved from the database.
Uploading Attachments CouchDB features built-in support for attaching files to documents in the database.
There are no limits on the number of attachments a document can have.
Futon makes it very easy to attach files to documents.
On the document’s page in Futon, click the Upload Attachment link.
A modal dialog box will appear asking you to select the file you want to attach to the document.
It informs you that a new revision of the document will be created immediately after the upload has completed, so there is no need to save the document to commit the changes.
In this example, I am going to attach an image file, specifically the cover image for this book.
If you want to download this image, you can find it at the following URL: http://www.apress.com/resource/bookcover/9781430272373?size=medium.
The image is in GIF format and is less than 4KB in size.
In the Upload Attachment dialog box, click the Choose File/Browse button, and select the file you want to attach.
Then click the Upload button to save the attachment to the database.
You’ll also notice that the name of the file that is attached to the document is in fact a link.
Clicking this link will display the image itself, because it is stored in the database.
You can delete attachments using the small delete icon to the left of the attachment filename.
You will not be asked to confirm the deletion, but it is worth noting that the attachment will not be deleted from the document until you click the Save Document link.
Feel free to add some more documents to the database.
For each book you add, you can have different fields if you so want.
There is no strict schema to adhere to, so if you have a book that does not.
Figure 5-14 shows how my books database looks, after I added some more book documents.
Compacting the Database At this point, you should have several books in the database.
I have 11 in my database, but whatever the number is, it doesn’t really matter.
Return to the Futon start page by clicking the Overview link in the breadcrumbs trail in the heading section of Futon.
The information about your books database should be significantly different from what it was earlier.
This is quite a large size for a database with only 11 documents.
This is caused in part by the fact that I have included image attachments for several of those documents.
This size is further padded, however, by the fact that the database retains deleted documents and older revisions of documents, including the attachments.
This can lead to wasted disk space, because much of the data is merely duplicated with each revision.
If you are satisfied that you do not need previous revisions and that you won’t need to restore previously deleted documents, you can help reduce the database size by compacting the database.
Futon includes a link to compact the database—simply click the database name on the Futon start page (in this case, the books database)
On this page, next to the Create Document link, you will see the link for Compact Database.
Before the process starts, you will be warned that deleted documents and previous revisions will be removed and that the operation is irreversible and can take a while for large databases (Figure 5-15)
Note When a CouchDB database is compacted, the database file is rewritten, permanently removing out-ofdate revisions and previously deleted documents from the file.
Once you run compaction, there is no way of recovering this data.
Because the database is still quite small, compaction will complete very quickly.
When it is done, you may be wondering what is different, because you will simply be returned to the database page in.
The first thing that will be different will be that previous revisions will no longer exist.
Click any document ID that has been previously revised to open that document’s page.
Now try to click the Previous Version link in the footer of the table.
You should get a message similar to that shown in Figure 5-16
Click the Overview link at the top of the page to return to the Futon start page.
The size of the books database should be much smaller.
As I’m sure you can imagine, these savings become even more important as the database grows in size.
You have already seen two of these links in great detail.
The Overview link simply brings you to the Futon start page, from where you can work with the databases stored on your CouchDB server.
The Test Suite option runs a series of tests to ensure that your CouchDB server is running and working properly.
So, now let’s look at the three options that you have not yet visited at this point.
Click Configuration to open the  CouchDB Configuration page (Figure 5-17)
This page lists all the different CouchDB configuration options, which can be found in the configuration files on the server.
It is can be easier to read and update the different options here than it is to change the settings in the configuration files.
Please note, however, that you will still need to restart the CouchDB server in order for some of these changes to take effect.
Generally speaking, you will not want to mess with these settings, because doing so could break your CouchDB installation.
One change you may want to make is the bind_address option in the httpd section.
If you try to connect to your CouchDB database from another computer on your network, you’ll notice that it will fail.
For example, my CouchDB server is on a Mac OS X machine with the IP address 192.168.1.8
I have a Windows laptop that should be able to access this CouchDB server’s Futon interface by visiting http://192.168.1.8:5984/_utils in my web browser.
However, when I do so, Firefox (my web browser of choice on Windows) gives a page load error.
By doing so, I was successfully able to open Futon on my Windows machine, as shown in Figure 5-18
You do not need to restart the server for this particular change to take effect.
Now let’s take a brief look at the Status page.
This will not be of much use to you at this point, because you will have no processes or tasks running that you can view on this page.
This is useful when you have large databases and are using the Futon Replicator to replicate these databases between instances or if you are compacting a large database.
Right now, however, all you should see is something similar to Figure 5-19
One of the key features of CouchDB is that it is easy to replicate across instances and servers, making it an excellent option for a highly scalable database.
Futon includes an easy-to-use replicator that allows you to replicate changes from one database to another.
The databases can reside on the same machine or on a remote machine; it does not matter.
You will revisit the topic of replication later in this book, but for now, let’s check out Futon’s Replicator tool by replicating the books database to a second local database.
First, click the Overview link (either at the top of the page or in the Tools menu in the right navigation bar) to return to the Futon start page.
From here, click Create Database, and give the database the name more_books.
If you like, you can create some new book documents in this database, but it’s not necessary.
To open Futon’s replication tool, click the Replicator link in the Futon navigation bar.
On this screen, you will see a box with some options for replicating a database.
Under the “Replicate changes from:” option, make sure the “Local database” radio button is selected, and from the dropdown list, ensure that you pick the books database.
Under the “to:” label, make sure that Local database is selected also, but from this drop-down, select the more_books database.
When you’re ready to replicate the database, click the Replicate button.
CouchDB will immediately begin the replication process, and it shouldn’t even take a second because the database is so small.
When it has completed, the Replicator screen will look similar to that in Figure 5-21
Note If you created some books in the more_books database before you performed the replication, those books will still be available, alongside the newly replicated books documents (assuming no conflicts between the two databases, of course)
Now return to the Overview page, and you’ll notice that the more_books database will have the same number of documents as the books database.
The size may be larger, but that is because it has kept placeholders for each revision of the database.
If you want, you can compact the more_books database to get it to match the size of the books database.
Of course, in a real scenario, replicating a database on the same server doesn’t have much use, and you’d be far more likely to replicate the database across a network to a remote CouchDB server.
This example simply shows how easy it is to replicate a CouchDB database.
Summary In this chapter, you learned all about Futon, CouchDB’s web-based administration tool.
You learned how to create and delete databases, create documents, add fields, upload attachments, delete documents, compact databases, replicate databases, and more.
As you have seen, Futon itself is quite powerful and is a very simple client for managing your CouchDB database.
In the next chapter, you will learn about JSON (JavaScript Object Notation), the format in which CouchDB documents are stored.
Documents in a CouchDB database are, put simply, data structures defined using JavaScript Object Notation (JSON)
Starting with the basics, you will learn what exactly JSON is and how it works.
You will see the different data types that a JSON object can work with, and then you’ll get your hands dirty by creating JSON structures and testing them using JavaScript and a web browser.
You will then investigate how CouchDB uses JSON, providing you with the knowledge you need to leverage the simplicity and power of this format in your CouchDB applications.
What Is JSON? JSON is an open, text-based, human-readable data interchange format derived from the JavaScript programming language.
This does not mean it is restricted to web applications, however; it can be used as a data format in any situation where information needs to be stored as text.
If you are already familiar with JSON, you may want to skim through this chapter, at least up until the “CouchDB and JSON” section, which introduces how JSON is employed in CouchDB.
Why JSON? The main advantage of using JSON as a data format is its pure simplicity.
It is very simple to write and read JSON, from both human and computer perspectives.
At its core, JSON is merely a collection of name/value pairs defined inside an object, and its basic structure makes it perfect for transporting data in an independent and lightweight manner.
Another advantage of JSON is its syntax, which uses conventions that programmers familiar with languages such as C, C++, Java, PHP, Python, and JavaScript should be able to follow.
The popular server-side web development language PHP includes native JSON support from version 5.2, and Python and JavaScript also have built-in JSON support.
Some modern web browsers include support for native JSON encoding and decoding.
Many web services and feed providers are making their APIs available with the option to return a response in JSON format.
For browsers that do not support JSON natively, the eval() function can be used to translate a string containing JSON code into JavaScript objects.
It is simple to map data from an existing database or XML to a JSON structure.
You will now look at each of these concepts in more detail.
These pairs each contain a piece of data that describes the object to which it belongs.
The name is the description of what the data represents, and the value is the data itself.
For example, a Car object may have the name/value pairs listed in Table 6-1
An array is an ordered list of values, indexed by the position of the value in the list.
An example of an array would be a list of the days of the week, as illustrated in Table 6-2
You define arrays in JSON using an opening bracket ([) and a closing bracket (]), separating each.
It is important to note that both of these structures can be nested.
In other words, an object can contain a value, which is itself an object or an array.
Likewise, an array can contain a value, which is itself an array or an object.
Each value in a JSON object or array must be represented using a valid data type.
There are six basic types available for use in JSON:
String: This is used for character data such as names, addresses, and e-mail addresses.
If your string needs to include a double quote, you can escape it with the backslash character (\)
Number: This is used for numeric data, including integers and floating-point numbers.
Boolean: This is a logical data type having one of two values: true or false.
Null: This is used where a field has no value or an unknown value.
Object: A value can itself be an object, another collection of name/value pairs.
Array: A value can also be an array, representing another list of ordered values.
This could have a field called previous_owners, which would be an array of previous owners.
Each value in this array could be a Person object.
Each value in the array is automatically assigned a numeric index based on its position in the array.
Later in this chapter, you will see the significance of this index value and the order in which array values are defined.
You have also added a field previous_owners, which is an array of objects, each of which contains two fields—name and mileage.
In the next section, you will investigate further examples and see how you can actually work with this data using JavaScript.
Working with JSON The best way to get to grips with JSON structures is to actually define and use them.
In this section, you will use some basic JavaScript to define objects and arrays and to access the data they contain.
To follow these examples, simply enter the code from the listings into a text file using your favorite text editor, save it to a location on your hard disk, and then open that file using your web browser.
Defining JSON Structures Let’s get a basic outline HTML document together so you can start working on some examples.
Open your favorite text editor, and create a new plain-text file.
Save the file as index.html, and store it somewhere on your hard disk that will be easy to find.
For example, on my Mac OS X environment, I have created a folder in my home folder (/Users/joe) called json and saved index.html in it.
Next, add the contents of Listing 6-6 to the file and save it again.
Now open this file in your favorite web browser; you should see something like Figure 6-1
The first thing you are going to do is create your JSON object.
You do this between the opening and closing <script> tag.
If you save the file and reload your web browser, you’ll notice that nothing has changed.
The reason is that you have simply defined your JavaScript object; you have not yet done anything with it.
Let’s make sure everything is working as it should be by adding some code to output the car’s details to the screen (Listing 6-8)
This time around, when you save the file and open it in your browser, you should see a more interesting result—like the one shown in Figure 6-2
In Listing 6-8, you’ll notice that you are using the function document.write repeatedly.
This merely tells JavaScript to output the value between the parentheses to the document.
In this example, you are creating a level-two HTML heading with the car object’s make and model values.
You then use a similar technique to get the year and body values.
The field previous_owners is a little trickier, because it is an array.
You are using the unordered list HTML tag (<ul>) to create a new list.
You need to use the array index to tell JavaScript which item in the array you want to display.
But how do you know how many values are in the array? It’s easy in this example because the number is small, but if it were large, it would be very difficult to keep track of, not to mention the amount of repetitive code to.
Also, if the contents of the array were to change in the object definition, you would also need to change the output code.
Looping Through JSON Arrays A much easier solution is to use a for loop to iterate through the items in the array and output them.
You are not restricted to just outputting the values in the object; you can also manipulate them and perform calculations on them where relevant.
When you are outputting your data to the screen, you will then calculate the total mileage for the car and output that too.
The first major change to this file is that you have added a new field to your Car object, current_owner.
This is an object with two fields, name and mileage, which are the same type as each object in the previous_owners array.
You will use this variable to hold the total mileage the car has done between all owners, past and present.
This will occur, of course, for every iteration of the loop, so each previous owner’s mileage will be added to the total.
Finally, after the loop has finished, you output the mileage_total to the screen.
If all goes according to plan, when you save your index.html file and reload it in your browser, you should see a result similar to that shown in Figure 6-3
Note If you are familiar with HTML, you may be thinking that this is all well and good, but couldn’t you do the same thing with some really basic HTML using many fewer lines of code? Yes, of course you could, but remember this is a very simple example.
In the real world, you might have cars stored in a database and use a programming language like PHP, Python, Ruby, and so on, to retrieve these records.
You could then leverage these languages to output the data into JSON, which can be returned to JavaScript as the response to an asynchronous HTTP request.
JavaScript can easily read the JSON response and update the web page without needing to refresh the page.
Figure 6-4 illustrates where JSON data fits in the flow of a typical asynchronous web application.
Where JSON fits in the traditional web application data flow.
Before moving on to the next section, let’s make one final modification to the JSON example.
Let’s assume that the web site you are working with is one for a car dealership.
Also assume that this dealership will have more than one car for sale, so let’s add a couple of other vehicles into the mix.
If you have followed the example and you are not familiar with programming, your instinct may be to create a second object, car2, and to copy and paste the code for outputting the data to output the second car’s details.
Again, this will work, but it becomes extremely tedious to manage with each subsequent car you create.
Instead, let’s create an array of car objects and then create a loop that will iterate through this array to output the details of each car (Listing 6-10)
In this example, you are creating an array named cars, which contains three items, each of which is a car object.
You then loop through this array, and for each iteration you create a total mileage variable, set it to zero, and create a horizontal rule, followed by output of the car details.
In this section, you have seen a practical example of how to define JSON objects and arrays and how to access the data in these containers using JavaScript.
I hope the practical nature of this section has provided you with some insight into how useful JSON is for storing simple data structures and how easy it is to read and produce.
CouchDB and JSON Up until this point, the primary focus of this chapter has been to serve as a primer for JSON.
In this section, you will explore the different ways CouchDB uses JSON.
The most important aspect of CouchDB’s use of JSON lies in the structure of the documents in the CouchDB database.
In essence, CouchDB documents are plain and simple JSON objects.
Every document can have as many fields as required, and these can be of any valid JSON type, such as strings, numbers, booleans, nulls, objects, or arrays.
These house the unique identifier for the document and the document revision number.
CouchDB’s special design documents, which house the views in a CouchDB database, are also defined as JSON objects.
The view functions are stored in a views field, which stores an array of the views contained in the design document.
Each item in this array represents an individual view, and each of these views contains a map and, optionally, a reduce function.
CouchDB uses JSON not only to define documents and design documents but also to return the results of a view.
This is the case for all views, be they special views included with CouchDB, views stored in design documents, or temporary views that are executed ad hoc.
The simplest example of this is the _all_dbs resource, which simply returns a JSON array with the names of all the databases stored on the CouchDB server.
Point your web browser to http://127.0.0.1:5984/_all_dbs (assuming CouchDB is installed on your local machine) to see this in action.
This time, let’s look at the special _all_docs resource for one of the databases that was returned in the previous example.
In this case, I’m using the employees database, so I point my browser to http://127.0.0.1:5984/employees/_all_docs.
Please note that I have reformatted the output to make it easier to read.
The rows value is a JSON array with each of the documents in the database represented as a JSON object, with three values: id, key, and value.
You will learn more about CouchDB views and how to create your own temporary and permanent views in the coming chapters.
You discovered how it came to be and what the advantages are of using JSON as a data interchange format.
You then learned the basics of JSON structures, namely, data types and the syntax of JSON objects and arrays.
You also looked at some practical examples of JSON in action using JavaScript, before discovering how it is used to power many aspects of CouchDB.
What you learned about JSON in this chapter should arm you with the knowledge you need to proceed through the next three chapters, which all relate to CouchDB views.
In Chapter 10, you will meet JSON again as you build full CouchDB applications in JavaScript using CouchApp.
Up to this point, your main focus has been on performing CRUD-style operations on your CouchDB data—creating, updating, and deleting documents and attachments and using the Futon web-based interface to manage your database.
In this chapter, you will investigate how to get some meaningful data out of your CouchDB database, using the built-in JavaScript view engine.
If you have experience with traditional relational database management systems such as Oracle, Microsoft SQL Server, or MySQL, you will be used to using Structured Query Language (SQL) queries to retrieve data from your database.
CouchDB databases, however, do not have a schema, and therefore using structured queries does not make much sense.
The best way to illustrate this is by means of an example.
Let’s take a basic contacts table and see how that might be represented in a traditional relational database (Figure 7-1)
As you can see in Table 7-1, the contacts table in a relational database has a strict structure, with.
If a particular contact doesn’t have a value for a particular column—for example, Jane Thomas and Charles Bing have no fax number, and Eric Quinn has no e-mail address—then a null value is inserted in that column.
Now, say you wanted to retrieve the name, e-mail address, and fax number of all your contacts.
To do this, you could use a SQL statement like the following:
This would successfully return all contacts from table, returning null values where no value is present in a particular column.
It can do this because although there is no value in that column, there is still physical data stored in that column in the form of a null value.
Now, let’s look at the same data but in a CouchDB database (Figure 7-1)
As you can see in Figure 7-1, CouchDB does not store data in a tabular, structured way but rather as individual, self-contained documents.
Because there is no strict schema to adhere to, documents do not include null values for fields they do not have data for.
Jane Thomas and Charles Bing have no fax numbers in their documents, and Eric Quinn has no e-mail address in his.
Because of this, it would be much more difficult to use a SQL SELECT statement to retrieve this data, because not all documents have a value for email and fax.
This is where CouchDB’s support for row-oriented view engines comes into play.
Using views, you can aggregate and report on the documents in your CouchDB database.
CouchDB views are completely separate from the documents they report on, and there is no restriction on the number of views you can have of any one document.
These views are stored in CouchDB in the form of special design documents.
As you will see later in this book, this means you can actually replicate entire web applications across CouchDB instances.
When a CouchDB view is queried for the first time, CouchDB runs through every document in the database and runs the view function against it.
It then takes the result of the view, which is stored in the form of rows of key/value pairs, and stores it in an individual B-tree file.
Although this can take quite some time, it occurs only the first time the view is queried.
With each subsequent change of a document, the view function is executed against that document only—everything else is already stored in the B-tree and remains unchanged.
Permanent views are views that are stored inside design documents in the database.
These views are stored and used until such time as their definition changes.
You can also create ad hoc temporary views, which are deleted when they are no longer being used.
These views are not stored in a design document, and they require the result to be calculated almost every time they are queried.
As a result, they are highly inefficient and should be avoided on production systems if possible.
Creating Views The easiest way to get started creating views is to run some temporary views using the Futon interface.
For a detailed overview of Futon, see Chapter 5 of this book.
I have created a database called contacts and populated it with the five records, as shown in in Figure 7-1
Futon makes it very simple to create temporary views of this data.
To the top right of the key/value table, you will see a “Select view” drop-down box.
Choose “Temporary view” from this list to navigate to the temporary view builder page (Figure 7-3)
On this page, you will notice that the key/value table has been replaced by a two-column View Code box.
In the left column you have the map function, and in the right column you have the optional reduce function.
Don’t worry about the reduce function for now, because I will discuss this in much further detail in Chapter 8 when you look at the concept of map/reduce in detail.
In the Map Function column, you will see the code shown in Listing 7-1
This is an example of the map function of a CouchDB view.
It takes the document object doc as an argument and outputs results using the emit(key, value) function.
Each call to emit corresponds to a row in the view, assuming that the document is successfully processed for all views in the design document.
Every time a view is requested, all documents that have been added, updated, or deleted will be processed and inserted in the view, before returning a response.
Beneath the Map Function column you will find a Run button.
Click this button to execute the temporary view (Figure 7-4)
As you can see, the results include key/value pairs that match up to the key and value you passed to the emit function in your view.
You passed null as the key and doc (the document object) as the value.
In the results, for each document the key is null, and the document itself is the value.
Let’s modify the temporary view function, this time passing the document ID as the key argument to the emit function.
This allows you to filter and sort your view by the document ID (Listing 7-2)
This time, the results in the Value column should be the same as before, but in the Key column you’ll see that it is showing the document ID for each document.
Because your view is written in JavaScript, you can use its power and flexibility to filter the results.
For example, you may want to return the names and phone numbers of only those contacts who have a fax number.
Note CouchDB views use a style of dynamic typing known as duck typing to determine the semantics of an object based on its current properties.
You can see an example of this in Listing 7-3, where you check that a document has fax, name, and phone properties before calling the emit function.
In addition, it returns the value for each contact as a key/value pair object with the fields Name and Phone.
Permanent Views The easiest way to create a permanent view in Futon is to first create a temporary view as described in the previous section.
When you are happy with the results your view returns, you can use the Save As button, found in the Reduce Function column, to save your view as a design document in the database.
To see this in action, let’s save the view you created to return the names and phone numbers of only those contacts with fax numbers in the previous section.
In the temporary view builder page, make sure the Map Function column contains the code from Listing 7-3, and check that it works as expected by clicking the Run button.
If the results look correct, save the view as a design document by clicking the Save As button.
When you’re ready, click the Save button to persist the view to a design document.
This page is similar to the temporary view builder page.
To show the code behind the view, click View Code in the box immediately above the Key/Value table.
The main differences between this page and the temporary view builder are that the “Select view” dropdown box now shows get_fax_contacts.
Also, in the top right of the View Code box, you will see the name of the design document the view is stored in, _design/contacts.
Another difference between this page and the temporary view builder is that when you modify the view on this page, the buttons Revert and Save become enabled.
The functionality of these buttons is exactly as you might expect—clicking Revert will undo any changes you have made since the previous save, and clicking Save persists the new view code to the design document.
First, change the code to anything you like (I entered blah), and try the Revert button to undo it.
Pretty mind-blowing stuff, eh? Next, let’s make a small change to the map function so that it returns the contacts’ fax numbers instead of phone numbers.
Click the Run button to make sure the view is working correctly; this time it should produce results with the Value column containing Name and Facsimile fields.
If you are happy with the results, click the Save button to persist your new and improved view to the design document.
When the view has been saved, you’ll notice that the Revert and Save buttons are disabled once again.
Now let’s create a similar view based on this view, this time returning only those contacts with an email address.
Rather than going back to the temporary view builder and creating the view that way, this time let’s just modify the get_fax_contacts view instead.
Change the code in the Map Function editor box to look like Listing 7-5
Again, click Run to ensure that the correct results are being returned by the view.
This time around, however, don’t click the Save button, because that will overwrite your get_fax_contacts view with this new view.
Design Documents As you discovered in the previous section, permanent views in CouchDB are stored in special documents called design documents.
These documents are stored in the same way as regular documents, but they typically contain view functions rather than data.
You can view all the design documents in a database by selecting “Design documents” from the “Select view” drop-down box (Figure 7-8)
The design document appears the same as a regular document—it has a document ID and a revision number, and you can save it, add fields, upload attachments, delete it, view the source code, and navigate between revisions.
These special documents usually have two important fields,  language and views (Figure 7-9)
The language field denotes the language the views in the document are written in, usually javascript (although the latest version of CouchDB also includes an Erlang view engine)
The views field includes the views that are contained in the document, which are themselves broken down into their map and reduce functions where available.
You can expand and collapse the function code using the small icon to the left of the view name.
As with regular documents, you can navigate through different revisions of the design document using the Previous Version and Next Version links.
It is worth keeping in mind that, like regular documents, previous revisions of design documents are deleted when the database is compacted.
You can also view the source code of the design document using the Source tab at the top right of the document details.
This will reveal the JSON source code the design document is made up of.
Design documents are just like regular CouchDB documents, but with special features; they will also appear in the “All documents” page.
Click “contacts” in the page header to go back to the contacts page, and from the “Select view” drop-down box select “All documents.” You will notice that in addition to the contact documents, this table now also includes the _design/contacts design document.
Views and the CouchDB API The Futon web interface makes it easy for you to create and work with the design documents and views in your databases.
That said, you will often want to work with CouchDB views using the powerful RESTful API that Couch provides, allowing you to employ them in your own applications.
Let’s create a very simple temporary view, which has the map function shown in Listing 7-6
Now use curl to make this POST request to the CouchDB server:
Assuming your contacts database is configured as in the previous examples, this should bring back a result similar to that in Listing 7-7
Please note that this listing has been formatted to make it easier to read; the raw output you get from the curl command will not be formatted like this.
Working with temporary views is nice and easy, but as discussed earlier in this chapter, their use is limited, and they should be avoided if possible.
Before you start creating permanent views using the API, let’s use the curl command to access the two existing views you created in your design document /_design/contacts.
All going well, you should get a result like Listing 7-8
Similarly, you can execute the get_email_contacts view the same way:
This should return the result set shown in Listing 7-9
Now that you’ve seen how the API returns the results of a view, let’s move forward and create a permanent view inside a new design document.
You create a design document the same way as you create a regular CouchDB document—using a PUT HTTP request and passing the document in JSON in the request body.
Listing 7-10 shows the definition of the new view you are creating.
Issue the following curl command to create this view in the database:
Now let’s test your new view by executing it using curl:
Before finishing, let’s check that your new design document and view are working as you would expect them to in Futon.
Fire up the Futon interface, and navigate to the contacts database.
Click this view to execute it, and the results will look similar to Figure 7-10
Summary In this chapter, you learned about CouchDB views and how they are used to aggregate and report on the data in a CouchDB database.
You discovered how CouchDB uses map/reduce views instead of SQL statements to interact with data.
You then learned how to create and execute temporary views using the Futon interface, before saving these views in special design documents in the CouchDB database.
Finally, you learned how to use the CouchDB RESTful HTTP API to run and create views and design documents.
In the next chapter, you will explore in depth the concept of map/reduce and how it applies to CouchDB views.
In Chapter 9, you will move on to some more advanced CouchDB view concepts and examples.
In the previous chapter, you learned how to create views in CouchDB; they allow you to query your data in different ways, much like you would use SQL for in traditional relational databases.
In creating these views, you may have noticed that each time you were putting your view code into something known as a map function.
In this chapter, you will explore the concept of map functions in more detail, and you will also look at the reduce function.
These two functions combine to form the concept of map/reduce, which CouchDB uses to determine the following:
What Is Map/Reduce? Map/reduce is a concept in software that has recently gained popularity in distributed computing.
The concept is based on two functions—map and reduce—both of which are intended to be used with a list of inputs.
The map function produces an output for each item in this list, while the reduce function produces a single output for the entire list.
CouchDB exploits the characteristics of these two functions to provide incremental calculation of views.
This means that each time a document is updated in a CouchDB database, only those documents that have been modified need to be reprocessed by the map and reduce functions.
Google use an implementation of map/reduce in its web index.
Google has thousands of machines working on hundreds of terabytes of data, spread across the World Wide Web.
Problems that would take a single machine months to process take a matter of hours over this distributed model.
Google’s MapReduce library includes features such as load balancing and disk optimization to further enhance the efficiency of the system, as well as to simplify its use.
It is also built to be robust so that machine failures do not have a negative impact on solving the original problem.
Map/Reduce in CouchDB In the previous chapter, you learned how to create CouchDB views using map functions.
When creating views in CouchDB, you must create a map function.
This function takes a single argument, which is the document itself, and uses the special emit function to produce a result.
This emit function accepts two arguments: a key and a value.
Every time the emit function is called, a row is added to the view.
Whenever a new document is created or an existing document is updated or deleted, the rows in the view are updated automatically.
Listing 8-1 shows the most basic map function (in this case, I am using the JavaScript view engine)
In this example, you can see that the map function has a single argument doc, which represents the CouchDB document.
This particular function simply adds every document in the database to the view, with no key defined and the entire document as the value.
If the database contains documents of different types, you might use a field type to differentiate between different types of documents.
Consider the example in Listing 8-2, where you emit only those rows that have a type car.
In this example, only those documents that have a type field with the value car will be added to the view.
Again, each of these documents will be represented by a row with a null key and an object comprising the car’s make, model, and year as the value.
This type of filtering should be used only where the lookup key is fixed.
Listing 8-3 provides an example that can be used for dynamic filtering.
In this example, you emit a key—the make of the car.
The rows in the view will be sorted by the key, so the display order of the results of the view will be based on the make of the car.
Additionally, you can filter the results of the view using URL query arguments that define the key(s) that should be included in the result.
In this example, you could pass the query argument ?key="Toyota" when executing your view, and only those cars that have "Toyota" as the key (the make field) will be returned.
CouchDB views must contain a map function, and they can also optionally include a reduce function.
Unlike the map function, which produces a row for each document it processes, the reduce function produces a single result for all the documents.
Listing 8-4 shows the simplest example of a reduce function.
Assuming that the view’s corresponding map function emits number values, this reduce function will return a result of the sum of the value of each row contained in the view.
Depending on the amount of data being processed, the reduce operation may be broken down into smaller chunks by CouchDB.
When this happens, the data will be processed by the reduce function before sending the result to the reduce function with the rereduce argument set to true.
Say CouchDB decides to break the data to be processed into three groups:
The view engine would first take each group individually, with rereduce set to false.
These results are then sent as an array to the reduce function, with rereduce set to true.
Reduce functions are invoked differently based on whether rereduce is true or false.
If rereduce is false, the keys argument will be a list of keys and IDs for each row emitted by the map function, and the values argument will be an array of the values emitted by the map function.
If rereduce is true, however, the keys argument will be null, and the values argument will be an array of the results produced by the previous invocations of the reduce function.
In Listing 8-4, the type of data in the values argument is always the same, regardless of whether rereduce is true or false, and as a result, you do not need to handle rereduce calls separately in the reduce function.
In Chapter 9, you will see an example of a reduce function where you need to take the value of rereduce into consideration.
Map/Reduce in Futon In Chapter 5, you learned how to use Futon, CouchDB’s web-based administration interface.
In Chapter 7, you saw how you can create JavaScript views in CouchDB using Futon.
Now, you’ll take this knowledge a step further and learn how to create views in CouchDB that have both map and reduce functions.
Some of these contacts had an email field, some had a fax field, and some had both.
In Chapter 7, you created views that returned rows based on whether contacts had an e-mail address or fax number.
However, this type of data is more likely to be used for reporting purposes.
For example, how many people have both, how many have a fax, how many have an e-mail address, and how many have neither? Using the methods described in Chapter 7, you would have to create separate views for each of these and look at.
Wouldn’t it be much more useful if you could have just one view which did this for you? Let’s find out how to create such a view.
If CouchDB is installed on your local computer, you can open Futon by opening your web browser and pointing it to http://127.0.0.1:5984/_utils.
When you navigate to the contacts database, you should be looking at the “All documents” view, as shown in Figure 8-2
As you are creating a new view, open the view design page by selecting the “Temporary view” option from the “Select view” drop-down box toward the top right of the main Futon window.
This should bring you to a page like the one shown in Figure 8-3
On this screen, you will see two large input boxes—Map Function and Reduce Function.
In the past, you have created views that required only map functions.
This time around, you will be creating a reduce function also.
The view you are going to create should return the number of documents in the database that have the following properties:
Enter the code in Listing 8-5 into the input box for the map function.
Out of interest, click the Run button, situated just below the Map Function box, and let’s see what it brings back (Figure 8-4)
This is because the map function is testing for all possible scenarios of the presence of a fax number or e-mail address.
Because there are only five documents in the sample database, it’s fairly easy to count the number of results for each key.
It would not be so simple, however, if your contacts database had hundreds or thousands of documents.
So, let’s see how you can aggregate this data to produce a count of the contacts for each key.
In the Reduce Function box, located to the right of the Map Function box, enter the code in Listing 8-6
Click the Run button once more to see the results of the view (Figure 8-5)
As you can see from Figure 8-5, the results are now much more readable, with the count for the number of rows for each key summed up to produce a total.
As you can see, there are no documents in the database that have neither a fax number nor an e-mail address.
Let’s change one of the documents with both of these fields to test that the "Neither" feature is working correctly.
First, save your view as a permanent view in the database by clicking the Save As button, located below the Reduce Function box.
Return to the “All documents” view of the contacts database by selecting the appropriate option from the “Select view” drop-down menu.
From there, click the document with ID 1 to navigate to the document for John Smith.
This document should look similar to the one in Figure 8-7
In this document, delete the e-mail and fax fields by clicking the small, gray x button to the left of the field name.
To save these changes to the database, click the Save Document link above the Fields table.
When you have saved the document, navigate to the “All documents” view of the contacts database by clicking the contacts link in the Futon header.
As you can see in Figure 8-8, the view results have been updated to reflect the document you just modified.
Now, the database includes a single document with both email and fax fields, two documents with just an e-mail field, one document with just a fax field, and one document with neither an email nor a fax field.
You simply add a reduce function to your view’s JavaScript definition to get the desired results.
Now let’s add this view to the contacts design document in the contacts CouchDB database:
As you can see from Listing 8-7, you simply include the reduce function alongside your map function when defining your view using JavaScript.
Complex views are much easier to create using Futon, because you don’t have to worry about escaping quote characters and missing braces and the like.
Of course, you could always create your own application for defining views.
Let’s now use curl to run the view you created in the previous section.
The results of this command should look similar to Listing 8-8
That doesn’t look right, does it? It’s simply returning the overall count of the number of documents in the database and not grouping the aggregation based on the key.
The reason for this is that you need to explicitly tell the CouchDB API to perform grouping on your view.
You did not need to do this in Futon because it does it for you automatically, but using the API, this is a manual process.
This command should result in the code in Listing 8-9 being returned.
That's more like it, isn't it? As you can see, by passing the group=true query parameter along with your view’s URI, you tell CouchDB to group the results by the view’s key.
In this SQL statement, you are retrieving the id, name, and email columns from the contacts table.
You are filtering the results so that it returns only those rows in the contacts table where the country field is equal to the string value "USA"
Finally, you are requesting that the results be returned sorted by the name field.
Now let’s look at how you would retrieve results from a CouchDB database using a map function (Listing 8-10)
In the previous map function, you check that the document type is contact, and if it is, you emit a complex key made up of the country and name fields,as well as a value object with name and email fields.
You can then use the startkey and endkey URI parameters to define which country you want to look up values for.
Now let’s compare the results from the SQL query and the map function (see Table 8-1)
Table 8-1 is the table of results you could expect from the SQL statement you looked at earlier.
You can see that in Table 8-2 the results are similar to those produced by the SQL statement.
CouchDB views always return the document ID, a key, and a value.
But what if you want to perform aggregation on this data? For example, let’s say you wanted to.
In the previous SQL statement, you use the COUNT function to return the number of contacts in the table, and you group these results by the country column to return the number of contacts in each country.
Now let’s look at how you would perform this aggregation in your CouchDB view (Listing 8-11)
You then create a reduce function that will aggregate the rows returned by the map function.
In this instance, the reduce function simply sums the values it receives as input.
Because you emit the value as 1 in the map function, it will act as a counter.
When calling this view, you pass the query string parameter group=true to tell CouchDB that it should group the results by the key.
Let’s take a look at the results returned by the SQL statement (Table 8-3)
As you can see, it has returned the number of rows in the contacts table, grouped by the country.
There are three contacts in the United States and a single contact in Ireland.
Now let’s look at what the CouchDB view returns (Table 8-4)
Look familiar? These results are the same as what was brought back by the SQL statement.
Word Count Example One of the most commonly used examples when explaining the concept of map/reduce is the word count example.
Basically, you take a document of text and use map and reduce functions to return the number of times each word appears in that document.
For this example, I have created a database named documents, and inside it I have created a single document, with the field content and its value set to the full text of U.S.
Now I want to create a view that takes this speech and counts the number of times each word in the speech was mentioned.
To do so, I created a new view, with the map function shown in Listing 8-12
In the previous function, I am taking the content field of the document, lowering it, and replacing any nonalphabetical characters with a space, before tokenizing the document into an array of words, split by a single whitespace token.
The reduce function is the same as you saw previously when performing count aggregation on your documents.
You simply take the values argument and return it summed up.
Figure 8-10 shows a snippet of the result returned by this view.
You can easily produce variations of this view; for example, say you want to count the number of occurrences of words starting with each letter of the alphabet.
Simply change the map function in the previous view to Listing 8-14
Summary In this chapter, you learned about map/reduce and how it is used in CouchDB views.
You learned about how to map a SQL statement into its counterpart map and reduce statements, how map functions are used to define what rows and fields are to be output in the view, and how the results should be sorted.
You then learned how to aggregate these results using reduce functions.
You walked through the process of creating map and reduce functions in the contacts database, which groups the number of contacts that have both e-mail addresses and fax numbers, either or, and neither nor.
You then saw the common map/reduce example of counting the number of occurrences of a word in a text, using the 2009 inauguration speech of U.S.
In this chapter, you will look at more advanced areas of CouchDB views—advanced aggregation functions such as average, maximum, and minimum; ordering and filtering results using keys; and the different approaches to performing join-like operations in CouchDB.
Advanced Aggregation For the purpose of examples in this section, I will be using a database of documents that hold employee information—their name, their salary, and the department they work in.
In the previous chapter, you learned to count grouped data.
This view will return a result like the one shown in Figure 9-1
Now let’s change the view slightly so that it returns the total salary for each department.
To do this, you simple emit the salary field as the value in the map function.
The new view should return a result like the one in Figure 9-2
This time, the map function can stay the same, but you need to change the reduce function, telling it to calculate the average salary instead of the total salary (Listing 9-3)
In this view, you are finding the total salary for each department, and then you are finding the average by dividing this total by the number of employees in the department.
In this example, you are using the Math.round JavaScript function to round your result to two decimal places.
Note Futon automatically groups results on views with reduce functions.
You can force this behavior by passing the parameter ?group=true to your view’s URI, however.
In all the examples so far, you have aggregated by department.
But what if you want an overall result for all employees? To do this, change the key in the map function to a string label such as "Average", as described in Listing 9-4
The two other common aggregate functions used when working with data are max and min, which, as you might expect from their names, return the maximum value and minimum values found in a resultset.
In the employee database, you might want to find out what the highest and lowest salaries are.
Let’s find out how to do this using a CouchDB view (Listing 9-5)
In Listing 9-5, you use the reduce function to initialize the max and min variables and then loop through the values sent to the reduce function to check whether the value is greater than or less than the current max and min values.
You will notice in this example that you check to see whether the value of the rereduce argument is false.
On large data sets, CouchDB breaks down the data sent to the reduce function and processes it in smaller batches.
When these batches are processed, they return a value to the reduce function and set the value of rereduce to true.
In this example, if rereduce is false, the values argument will be an array of the values emitted by the map function—in this case the salary field of each document.
You then process these salaries to find the maximum and minumum values and return a JSON object with two fields, max and min.
If rereduce is true, the values argument will be an array of values returned by previous calls to the reduce function, in this case, the JSON objects with max and min fields.
Once again, you return a JSON object with maximum and minumum values (Figure 9-4)
Of course, if you wanted the max and min values for each department, you can simply change the key in the map function to doc.department, and it will group the results by department accordingly.
You might be wondering what good this information is to you when you don’t know which employee has the.
So, let’s modify the view so that it tells you the name and salary of the highest and lowest earners (Listing 9-6)
The main change with Listing 9-6 is that the map function emits a value of a JSON object with name and salary fields.
This allows you to associate a name with each salary value when calculating the max and min values in the reduce function.
You can then return a result with the name and salary of the employees with the highest and lowest salaries, as shown in Figure 9-5
Finding the names and salaries of the highest and lowest earners.
Ordering and Filtering Results The results returned by a CouchDB view are ordered by the view’s key, ascending in direction by default.
Using the employees table from the previous section, let’s take a look at how this works.
Take the view shown in Listing 9-7 as an example.
This view simply returns all the documents in the database.
It does not emit a key, and the value is the document itself.
Because CouchDB automatically uses ID as part of the key in a view, the results are ordered by the document ID by default.
To order by name, you’d simply use the name field of the document as the key, and CouchDB will then order the results by name (Listing 9-8)
Similarly, you can order results by the employee’s salary (Listing 9-9)
Figure 9-6 shows the results of the last view (ordering results by salary)
What if you want to reverse the order the rows are displayed? In other words, what if you want the highest salary to appear first? In Futon, you can simply click the arrow in the Key column header in the results table.
To view the results in ascending order, simply click the arrow again.
But what if you are not using Futon? If you view the raw data by navigating straight to the view’s URI (or by clicking the gray tag icon in the top right of the main section of Futon), you will see that the results are brought back, ordered by salary in ascending order, with no way to change the order in which the results are displayed.
Fortunately, CouchDB provides a query parameter that you can use to change the order of results just by changing the URL.
To show results in descending order, simply append ?descending=true to the end of the URL in your browser, and CouchDB will reverse the results, as shown in Figure 9-7
In addition to the descending option, CouchDB provides a range of URL query arguments that you can use to manipulate the resultset returned by your views.
You will now look at some of the more useful arguments available.
You can search for a particular document using the key argument.
If you changed the key to the department field and then added ?key="Sales" to the URL, you would get back two results—the documents for Patrick Wood and Jack Sawyer, who both work in the sales department.
It’s important to note that you use the ? symbol only before the first argument.
Each subsequent argument you pass should be prefixed with the & symbol.
You can use this to define a maximum number of results the query can return.
If you don’t want to return the first rows of the resultset, you can use the skip argument to define the number of rows to skip when running the query.
Working with Related Data If you have experience with relational databases, you will be familiar with the concept of relationships.
Traditionally, data is separated into different tables, and keys are used to create relationships between these tables, allowing their data to be joined using SQL.
For example, an employee’s payroll advice data might be stored in a separate table called payslips, and this table would have a reference column that indicates which employee it is stored for.
You could then use SQL to join the data, retrieving the employee’s name from the employees table and the dates and amounts of their payslips from the payslips table.
So, how do you store related data? One way is to store the related data in the document itself.
If you were to store pay advice information inside this document, it might look something like the following:
This method is a very straightforward and simple way of storing related information.
Also, because everything is kept in one document, all the data is stored together.
This means that should you ever delete the document, all of the pay advice data is deleted along with the employee data.
This maintains the referential integrity of the database automatically, leaving no redundant documents lying around.
For example, if you wanted to get the total amount grouped by employee, you could create the view as described in Listing 9-10
The primary issue is that it is quite tedious to add new payslips to the document, because they would need to be inserted into the existing employee record structure.
It can also lead to an increase in conflict errors.
If someone tries to modify an employee’s details, for example, while another user is inserting a payslip into the record, they will get a “409 Conflict” error.
An alternative method of storing related data is to store it in a separate document; in that case, each employee would have one employee document and zero or more payslip documents.
To make it easy to distinguish one from the other, you might create a type field in each document to indicate whether it is an employee document or a payslip document.
The payslip document would also need to store a reference to the employee to which it belongs.
Using this method, the employee document would look like the following:
Adding new payslips is far easier with this method, because you simply create a new document.
It also doesn’t suffer from concurrency issues, because the employee and payslip data are stored independent of one another—so one user can change the employee record at the same time as another user changes a payslip record.
Getting the total amount paid for each employee is simple, as shown in Listing 9-11
The obvious downside to this method is that you would need to use a separate view to get back the employee’s information, such as their name.
As a result, a separate HTTP request is required, adding load to the server.
Fortunately, you can use view collation to bring back documents of different types alongside each other.
So, you could bring back the employee record and then all of their associated payslip documents after it.
To do this, you would use what is known as a complex key, using the employee_no field and an identifier to say which type of document should appear first.
This will first and foremost return the document containing the employee’s information, followed by any payslip documents associated with that employee.
Which method is best really depends on the data you are working with.
If your related data has many fields and requires constant additions and updates, you are probably better off storing this data in separate documents.
You learned how to do all sorts of aggregation, filter and sort your results, and store relational data in a CouchDB database.
In Part 3, you will see how to put all of this together to create CouchDB applications using CouchApp, and you will see how you can use a CouchDB database as the back end to applications created in Python, and Ruby.
In this part, you will take the knowledge you gained in the previous parts of this book.
Then, you will learn how to connect to CouchDB from.
In this part of the book, you will leverage the skills you learned in the first two parts of this book to create some CouchApps.
If you have experience with server-side web application development, you may be familiar with the process of creating a database in the vein of MySQL, Oracle, or another relational database management system and then developing your application using a programming language such as Python or Ruby.
You’ll learn how to develop CouchDB applications in these languages later.
First you will investigate CouchApp—a set of scripts that allow complete, stand-alone CouchDB applications to be built using just HTML and JavaScript.
These applications are housed in the CouchDB database, meaning that when the database is replicated, any applications stored in that database are also replicated.
Installing CouchApp CouchApp is a Python module and requires Python to be installed on your system to work.
If you are using Linux or Mac OS X, it is most likely that Python came preinstalled with your operating system.
To check, open a Terminal or shell window, and type the following command:
If Python is installed, you should see a response like the following:
If Python is not installed, you might get the following:
Note Installing Python is outside the scope of this book.
If you need assistance setting up Python on your system, refer to the Python documentation, available at (http://www.python.org/download/)
You can use a package manager like apt-get if you want, but for the sake of platform independence, I will install it manually.
When the download has completed and you are returned to the shell, issue the following command to install setuptools:
If all has gone according to plan, the script should install setuptools, and you will see messages similar to those shown in Figure 10-1
That’s it—CouchApp is now installed, and you can begin writing CouchDB applications using nothing but HTML and JavaScript! In the next section, you’ll look at getting up and running with CouchApp.
Your First CouchApp Now that you have installed CouchApp, you can start developing CouchApps right away.
The first thing to do is create a directory where you will store your CouchApps.
I usually create a subdirectory called couchapps below my home directory, as shown in Listing 10-2
From here, you use the following command to generate a new CouchApp:
Now you need to push your CouchApp to your CouchDB installation.
Assuming that your CouchDB server is installed on your local machine and you have not set up authentication, you should be able to push your CouchApp using the following command:
If that worked correctly, you should see a message like this:
Copy and paste this URL into your favorite web browser, and you should see a screen similar to Figure 10-2
Let’s make a few changes to the first CouchApp before you move on to a more advanced example.
In your shell, navigate to the directory where you store your CouchApps, such as ~/couchapps.
From here, enter the directory for the test CouchApp you just created and list its contents using the following commands:
You should see five directories: _attachments, lists, shows, vendors, and views, as well as a single couchapp.json file.
I’ll discuss these in more detail in the next section, but for now let’s just go into the _attachments directory and list its contents using this:
In this directory is a file index.html and a folder style.
Style sheets for the application are usually stored in the style directory.
Let’s worry about changing the styles later; for now let’s just make some rudimentary changes to the application’s content by modifying the index.html file.
Open this file in your favorite text editor (I like nano)
I decided to be hyperbolic and name my app Super CouchApp.
When you have finished making changes, save the index.html file, and reload your CouchApp browser window.
Hmmm, nothing has changed, has it? That’s because you need to push the CouchApp to CouchDB once again.
You will need to do this every time you make changes to your CouchApp’s files.
Use the following command to push the CouchApp from the current directory:
Once again you should get a message telling you the URL where you can visit your CouchApp.
Now head back to your browser window and try that URL once more.
This time you should see a more satisfying result, like the one in Figure 10-4
As you can see, working with CouchApps is very straightforward.
You simply edit the source files on the disk and push the app to CouchDB when you want to test your changes.
In the next section, you’ll start creating a more useful application.
By the end of this chapter, you will have developed a CouchApp that allows you to create a new task and delete existing tasks.
It will also display any existing tasks when it loads.
The application will use the jQuery JavaScript library that comes with CouchApp, as well as some CouchApp extensions to this library that neatly wrap the Ajax requests to the CouchDB database for you.
The first thing you need to do is generate a new CouchApp.
Open a Terminal window, and navigate to your CouchApps folder (mine is ~/couchapps)
From here, issue the following command to generate the couchtasks CouchApp folder:
This will create a new directory in your CouchApps folder named couchtasks.
Enter this directory, and navigate to the _attachments subdirectory using the following command:
As you saw in the previous section, CouchApp automatically creates an index.html file and a main.css file within the style subdirectory.
The first thing you are going to do is edit your index.html file.
Open the file in your favorite text editor, and replace the contents of the file with the code in Listing 10-4
Let’s push the progress to CouchDB so you can see what this HTML has produced.
If everything works as expected, you should see a message informing you that you can visit your CouchApp at the URL http://127.0.0.1:5984/couchtasks/_design/couchtasks/index.html.
Enter this URL into your web browser, and you should see a page similar to the one shown in Figure 10-6
The bare bones of the application are now there, but it looks a bit dreary, doesn’t it? Let’s spruce it up somewhat by adding a splash of color.
To do this, you will modify the main.css file that CouchApp kindly created for you when it generated your CouchTasks app.
This time, replace the contents with the CSS code in Listing 10-5
Save this file, and make sure you’re in the main CouchTasks directory in your Terminal window.
Now push the application to CouchDB once again using this:
Now reload your CouchTasks browser window, and you should see a much more attractive user interface, as shown in Figure 10-7
So, now the application looks pretty, but you’ll notice that it still doesn’t actually do anything.
Let’s implement the New Task form so that it creates new task documents in the CouchDB database.
To do this, you need to create some JavaScript code.
You could insert this directly into the index.html file, but to keep your code manageable, you’ll create a separate JavaScript file and link to that from the index.html file.
In your terminal or shell, navigate to the _attachments subdirectory within your couchtasks folder.
Currently, there should be just the index.html file and style subdirectory in this location.
Let’s create a second subdirectory called script and create a file named main.js inside it:
Now open this main.js file, and add the code from Listing 10-6 to it.
First you are opening an instance of CouchApp, which will automatically set up the database and design document variables for you.
Within this, you are capturing the submit event of the form with the ID add_task.
In this function, you first prevent the default action from being performed (in this case the form being submitted)
You then build up your new task’s document in JSON format, using the value of the Description textarea field for the value of the desc field.
Next, you check that the user has actually entered something in the Description field, displaying an error message if not.
If all appears fine, you save the document to the CouchDB database.
When CouchDB returns and confirms that the document was saved correctly, you add your new task to the My Tasks section of the page.
You then clear the description textarea value and increase the task count above your list of tasks.
Before you push the application to CouchDB, you need to make a small modification to the index.html file to tell it to read your new JavaScript file.
The new line is highlighted in bold in Listing 10-7
Now you are ready to push your application once again.
Again, making sure you are in the main couchtasks directory, issue the following command:
Now reload your CouchTasks browser window, and this time add a description and click the Create button.
Feel free to check that the document was indeed saved to the database in Futon.
Unfortunately, however, the application is not maintaining state between sessions.
If you refresh the CouchTasks browser window, you will notice that no tasks are displaying, and the counter is showing zero results.
That is because you have not told your application to bring back data from the CouchDB database yet.
To do so, you need to create a view and tell your CouchApp to read data from this view.
To create a view in your CouchApp, you need to define it in the special views subdirectory in the couchtasks directory.
The views directory is structured into subdirectories, each of which is the name of the view.
Within each of these subdirectories, you create a map.js file for your map function and an optional reduce.js file for reduce functions if required.
For this application, you need to retrieve the tasks that are currently stored in the database when the application first loads.
To do this, you need a simple view that you shall call get_tasks.
Open your shell window, and navigate to your couchtasks directory.
From here, issue the following commands to set up your view file structure:
Now open the map.js file in your text editor, and add the code in Listing 10-8 to it.
The new content of main.js is shown in Listing 10-9
When you have saved main.js, push your application to CouchDB again using this:
Now when you open CouchTasks in your web browser, you should see the task you previously entered.
Next, let’s make the list of tasks look a bit prettier with some padding and borders, and also let’s add a delete button next to each task so that the user can delete the task from the database.
Add the code in Listing 10-10 to the end of the main.css file.
Now you need to modify the main.js file to take care of two scenarios—first adding delete buttons to links generated when a user adds a new task and second adding delete buttons to links generated when the application launches.
Change the content of the main.js to match the code in Listing 10-11
Save this file, and push the application to CouchDB again.
When you refresh your CouchTasks browser window, you will notice that the task list items now appear in a nicer format, and each of them has a red delete button on the right side.
If you click the delete button, you will be asked for confirmation that you want to delete the task (Figure 10-9), and if you click OK, it will be deleted from the database.
Now the application is performing the functions outlined earlier in this section.
You can add tasks to the database using the form your application provides.
This application is displaying the tasks that already exist in the database using a CouchDB view, and you can delete existing and newly created tasks in the My Tasks list.
Suggested Improvements Obviously, the CouchTasks application is simple in its current form, but with a little knowledge of JavaScript and the jQuery framework, you can build on this sample application and create a powerful task management application.
Some features you could quite easily add to the application include the following:
Instead of deleting tasks, allow the user to mark them as completed and then provide a view of previously completed tasks.
Allow the user to rearrange the display order of tasks.
Summary In this chapter, you learned how to create fully functional web application using CouchApp—a development framework that allows you to build applications in HTML, CSS, and JavaScript that can interact with a CouchDB database.
You learned that the advantages that a 100 percent client-side application can offer in terms of flexibility and portability.
Finally, you put all of this into practice by creating a task management CouchApp.
In the next chapter, you will look at using CouchDB as a traditional database back end to a serverside application developed in Python.
In this chapter, you will learn how to develop software applications that are powered by a CouchDB database.
First you will look at the libraries available that allow you to connect to CouchDB from two programming languages: Python and Ruby.
In both cases, I will show how to use a software library to connect to a CouchDB server from the programming language.
You will then use this library to interact with CouchDB by creating and working with databases and documents.
Once I have walked you through the basics, you will develop a sample application using Python and the Django web application development framework, with the data stored in a CouchDB database.
Developing in Python with Couchdbkit A number of CouchDB libraries are available for the Python programming language, and in this section you will use the Couchdbkit library to connect to CouchDB from your Python applications.
You can check whether Python is installed on your system (and which version you have) by issuing the command python –version at the shell prompt or in a Terminal window.
If Python is not installed, or the version installed is not compatible with Couchdbkit, visit http://www.python.org/download to download a suitable version for your operating system.
With the prerequisites installed, you are almost ready to install Couchdbkit.
The easiest way to do so is using easy_install, which requires that a recent version of setuptools be installed.
If it is not (or you are not sure), issue the following commands in your shell or Terminal window:
With easy_install available, you can now proceed to install pycurl by issuing this command:
With pycurl installed, you are now ready to install Couchdbkit.
This will download Couchdbkit and its dependencies (simplejson, restclient, and httplib) and install them for you automatically.
When it’s finished, you’re ready to start developing CouchDB applications in Python!
Open the Python interpreter by issuing the following command in your shell or Terminal window:
Now let’s start using Python to work with the CouchDB server.
When you finish entering the third line from Listing 11-1, you should get a result like this:
Let’s be skeptics in this case, however, and verify that the database has been created.
Open your favorite web browser, and visit the Futon administration interface for your CouchDB server at http://127.0.0.1:5984/_utils.
If the database was successfully created, you should see it in all its glory, as shown in Figure 11-1
Next, let’s take things a step further by creating a CouchDB document using Couchdbkit.
First, let’s move from entering code at the interactive prompt to using source code files.
Now use your favorite text editor to create a new file in this folder, named Bookmark.py.
Now, try running this source code by issuing the following command:
If you don’t see any error messages, your class was evaluated successfully.
Now let’s create some code to utilize this class to create and save CouchDB documents.
Now run this source code by issuing the following command:
You should see the messages “Saving CouchDB document” and “Document Saved”—but once again, let’s not take the application’s word for it.
If you take a quick look in Futon, you can see that your python_test database now has a document, with the values from the previous code stored.
If you run the code again, you’ll see that a second document has been created.
It’s unlikely you’d want to store the data to be added to CouchDB in your source code, of course.
You’d probably want to allow the user to enter the URL and title of the bookmark.
Let’s make a few simple changes to the application to allow for user input.
Modify the BookmarksApp.py file, making the changes highlighted in Listing 11-4
This time around, you should be prompted for a URL and a title, as shown in Figure 11-2
It’s great that you can create CouchDB documents from Python, but what if you wanted to use Python to execute CouchDB views? You’d need to create a view.
Of course, you could use Futon or the CouchDB API to create this view, but you can also use Couchdbkit for this.
The first thing you need to do is create a valid directory structure for your view’s design document.
Now create a file in the all subdirectory named map.js.
Now you need to use the “loaders” feature of Couchdbkit to load this view and insert it into the CouchDB database.
This code will take the view you defined in Listing 11-5 and load it into CouchDB in a design document.
You then execute the view, which returns a ViewResults object.
You then use the count instance method of this object to print the number of bookmarks currently stored in the database.
As you have seen, Couchdbkit provides you with many utilities for working with CouchDB databases in your Python projects.
In fact, there is quite a bit more to Couchdbkit than the small sections we touched on in this section.
If you want to learn more about Couchdbkit, visit the project’s API at http://www.couchdbkit.org/docs/api/
In the next section, you will look at using the CouchRest Ruby library in the same way as you used Couchdbkit in this section.
You will then use the skills you learned in this section to develop a Django application that is powered by a CouchDB database.
Developing in Ruby with CouchRest If you worked through the previous section, you saw how simple it is to use Python to create applications that store data in CouchDB.
In this section, you will learn about how CouchRest offers the same simplicity to Ruby developers.
The requirements for CouchRest, at the time of writing, are as follows:
Ruby installed (I have tested on version 1.8.7, but other versions should work)
Note If you do not have Ruby installed, take a trip to http://rubyonrails.org, and follow the instructions there.
You will need to install Ruby and RubyGems for this section.
You do not need to install Rails, but if you are planning on developing Ruby on Rails applications in the future, you may as well install it now also.
Before installing CouchRest, you’ll need to make sure that your RubyGems install is up-to-date.
If you have just installed RubyGems, you should be fine, but if not (or you want to be sure), simply issue the following command in a shell or Terminal window:
This will use the RubyGems package manager to download CouchRest and any dependency packages, before automatically installing them.
With CouchRest installed, let’s hop into the Ruby interpreter and perform a quick test to see that CouchRest is working.
Unless you have previously installed the JSON gem, you will more than likely get an error like the one shown in Figure 11-3
Exit the Ruby interpreter by entering exit at the Ruby prompt.
From here, enter the following command to install the JSON RubyGem:
Now open the Ruby interpreter once again, and this time, enter the lines of code in Listing 11-7
Let’s remain skeptical, however, and head into Futon to check that it did indeed create a database.
Open your favorite web browser, and enter the URL http://127.0.0.1:5984/_utils.
In the previous section of this chapter, you learned how to work with documents in Python using the example of storing bookmarks in the CouchDB database.
I will use the same example in this section, except the application will be developed in Ruby using CouchRest.
In it, create a new file called Bookmark.rb, and enter the code in Listing 11-8 in it.
Now it’s time to compile the Bookmark class using the Ruby compiler.
In your Terminal window, navigate to the ruby_couch directory in your home folder, and run the following command:
Now let’s create a Ruby application that uses this class.
Create a new file called BookmarksApp.rb, and save it in the same location as the Bookmark.rb file.
Edit its contents so it is the same as the code in Listing 11-9
Now, compile this code using the following command at your shell prompt (not the Ruby prompt):
This should return with the JSON representation of the document that is being created and the message “Bookmark Saved,” as shown in Figure 11-6
Ever the skeptics, let’s double-check that it worked in Futon.
If you can find the document, which looks like in Figure 11-7, it worked!
Running the application again and again re-creates the same document.
Of course, it would be much nicer if you could define the URL and title you want to add to the database at runtime.
Modify the BookmarksApp.rb file, making the changes highlighted in bold in Listing 11-10
This time, you should be prompted for a website URL and title, and the values you enter here will be used to form the document that is saved in the database.
You can see the output returned by Ruby in Figure 11-8
Up until this point, working with CouchDB in Python using Couchdbkit and in Ruby using CouchRest has been quite similar, albeit with differing syntax.
CouchDB views is quite different from the method used in Couchdbkit.
The output should be each “Bookmark” document stored in your CouchDB database, as shown in Figure 11-9
In the next section, you will develop a web application using Python and Django that uses CouchDB to store its data.
If you want to learn more about CouchRest, visit http://github.com/jchris/couchrest/tree/master.
Creating a Bookmarks Application with CouchDB and Django In this section, you will create a sample bookmark application that is deployed as a web application using the Python-based Django framework.
Luckily, the Couchdbkit framework you used earlier in this chapter has Django extensions built into it, making it simple to build Django applications that use CouchDB to store data.
Note In this section, you are using wget to download Django.
If you are using Linux, this should be already installed on your system, but if you are using Mac OS X, you probably don’t have wget.
If you followed the instructions for installing CouchDB on Mac OS X in Chapter 3, you will have MacPorts installed on your system.
You can use this to download and install wget by issuing the following command in a Terminal window: sudo port install wget.
You will be asked to enter your administrator password, and once you do, MacPorts will download and install wget on your system automatically.
The first thing you need to do is install Django.
From your home directory, issue the following command to download and install Django 1.1 (the latest release version available at the time of writing):
That’s it! Django is now installed and ready to use! Let’s move on and create the Django project.
Make sure you are in your home directory, and issue the following command:
This will create a new Django project called myproject, automatically creating a directory of the same name beneath the directory you ran the command from.
This will create a new directory called bookmarks beneath the myproject directory.
The first thing you need to do is make a few changes to your project’s settings.py file, found in the myproject folder.
Open this file in your favorite text editor, and change it so that it matches Listing 11-12 (changes from the standard file are highlighted in bold)
Next, you need to change your urls.py file to tell Django what views to point what URLs to.
Modify this file in your favorite text editor so it matches the code in Listing 11-13
In the bookmarks directory, edit the models.py file, and modify it so that it reflects the code shown in Listing 11-14
This is where you will create the index view, which the main Django application URL will access.
You may have noticed in Listing 11-15 that you are returning the bookmarks stored in the database using a CouchDB view: bookmarks/all.
This view does not exist, however, so you need to create it.
In the bookmarks directory, create a nested directory structure as follows:
You can create this by issuing the command (assuming you are in the bookmarks directory):
Now you need to create a new file at the bottom of this structure (in other words, in the all subdirectory) called map.js, which will house your view’s map function.
This view will simply return a list of all documents in the database that have a doc_type field with the value Bookmark.
This allows you to display only data documents from your database (whereas the _all_docs view would include design documents also)
The final thing you need to do is create the template index.html file that is used by the Django view.
In the main project directory (myproject), create a new directory named templates as follows:
In this directory, create a new file named index.html, with the code in Listing 11-17
That’s it; your Django + CouchDB application is ready to be tested! Navigate to the main project directory (myproject), and issue the following command:
This will start creating some tables in the SQLite database for some preinstalled Django modules.
You may be asked to create a superuser; feel free to do so by answering the questions when prompted.
Does this mean that the bookmarks database has been created in CouchDB? Let’s check in Futon by visiting http://127.0.0.1:5984/_utils in a web browser.
You should see a positive result, as shown in Figure 11-10
But that’s nothing that you couldn’t do with some simple Python code yourself.
How about an actual Django web application? Head back to your shell prompt or Terminal window, and from the myproject directory, issue the following command:
You should see a message like the one shown in Figure 11-11
As instructed, visit the URL http://127.0.0.1:8000 in your web browser.
You should now be able to add new bookmarks, which will be retrieved from CouchDB and displayed in the table at the bottom of the page.
Congratulations, you have developed a bookmark web application in Python using the Django web application development framework that uses CouchDB to store its data.
Of course, this sample application barely scratches the surface in terms of potential features.
However, with some basic knowledge of Python, Django, and Couchdbkit, you can take the sample application you have developed here and turn it into a full-blown CouchDB-driven application.
Add more fields to the application, such as tags, description, rating, and so on.
Create more CouchDB views to give multiple representations of the data, such as tag clouds, sorting by fields, pagination, and so on.
Use JavaScript to allow bookmarks to be sorted using drag and drop.
Summary In this chapter, you learned how to work with CouchDB databases using two modern programming languages: Python and Ruby.
With Python, you learned how to leverage the Couchdbkit library to create and work with CouchDB databases and views.
You then saw how to do the same in Ruby using CouchRest.
Finally, you developed a basic bookmark storage web application using the Django framework for Python, with your data stored in CouchDB, of course.
In the next chapter, you will learn about some of the more advanced aspects of CouchDB, such as replication, compaction and working with documents in bulk.
In this chapter, you will learn about some of the more advanced aspects of CouchDB.
First, you will see how a CouchDB database can be replicated—to another database on the local CouchDB server and to a database on a remote CouchDB instance.
Then, you’ll learn about database compaction and how it reduces the size of the database file, as well as its impact on previous revisions of documents.
Next, you will learn how to fetch and write documents from and to the database in bulk.
Finally, you will see how show functions allow you to represent CouchDB data in different formats.
Replication CouchDB is designed to allow bidirectional replication in an efficient and reliable manner.
It does this through an incremental replication model, where only those documents that have changed since the last replication are processed.
By design, CouchDB’s replication system allows a failed replication process to pick up from the last saved checkpoint.
In addition to regular CouchDB documents that store data, the design documents that house CouchDB views are also replicated, as well as any document’s attachments.
This means that entire CouchDB applications can enjoy the benefits of this replication feature, not just the data.
Let’s take a look at how to perform replication in CouchDB.
The first method is using Futon, the web-based administration interface that comes with every CouchDB installation.
Open your web browser, and visit the URL http://127.0.0.1:5984/_utils (assuming CouchDB is installed on your local computer)
In Futon, create two databases—one called futon-one and the other called futon-two.
In the futon-one database, create three documents (you don’t need to worry about creating any fields because the aim is merely to get replication working)
When viewing Futon’s Overview page, you should see your two databases, similar to Figure 12-1
Note that futon-one has three documents and futon-two has zero documents.
Now, in the main menu of Futon on the right side, click the Replicator link to navigate to the Futon replication tool.
This page should look like the one shown in Figure 12-2
At the top of this page you will see two sides, one with the heading “Replicate changes from” and the other with the heading “to.” Under each you will see two options—“Local database” and “Remote database.” For this example, you will be replicating your local database futon-one to another local database, futon-two.
Make sure that under “Replicate changes from,” the “Local database” option is selected and that the futon-one database is selected.
Ensure that under “to” that “Local database” is also selected but that here the futon-two database is selected.
When you are ready to replicate the database, click the Replicate button.
The replication process will start and should finish almost immediately, because the database is very small.
When it is done, you will see a message in the Event area like the one shown in Figure 12-3
The message in the Event area is a JSON object with details about the replication and its results.
You can see in Figure 12-3 that, in my case, the replication took less than a second to complete, checked three documents to see whether they were missing, found that all three were missing, read the three of them, wrote them to the other database, and encountered zero failures.
Now let’s return to the Overview page of Futon, where you can see that the futon-two database now contains three documents, just as futon-one does (Figure 12-4)
From Futon’s Overview page, open the futon-two database, and create two new documents.
Again, you don’t need to create any real data, unless you feel a burning desire to do so, of course! Your databases should now look something like Figure 12-5, with futon-one containing three documents and futon-two containing five documents.
Head back over to the Replicator tool; this time select futon-two under the “Replicate changes from” heading, and select the futon-one database below the “to” heading.
The results will again show in the Event section, as shown in Figure 12-6
If you read through the JSON result object, you will see that this time around it checked five documents to see whether any were missing from the target database, and it found that two were missing (the two we just created)
It then read these two documents from the source database and wrote them to the target database.
For the purposes of this example, I will assume that you have CouchDB installed on two separate computers that are connected to the same network.
If you don’t have two machines, you can try installing two instances of CouchDB on the same computer, or of course you can create a virtual machine and install CouchDB there.
Be sure to replace these IP addresses with the addresses for your own computers.
Caution Before trying to replicate databases between CouchDB instances, it’s a good idea to test that the computers can find each other.
Open a shell or Terminal window on each machine, and use the ping command to see whether it can find the other.
If you fail to receive a response from the other computer, you will need to resolve this issue before you can try replicating CouchDB databases.
As a result, it will not be discoverable by other computers in your network.
To see what I mean, try to visit the CouchDB front page on machine B using your browser on machine A.
You should get a result like the one shown in Figure 12-7
To resolve this issue, you will need to modify CouchDB’s configuration file.
On each machine, visit the Futon page for the local instance of CouchDB at http://127.0.0.1:5984/_utils.
Click the Configuration link in the menu on the right to visit the CouchDB Configuration options page.
Double-click the “127.0.0.1” text, and an editable text box will open.
Enter 0.0.0.0, and click the green check icon to the right of the field to save the configuration.
With this configuration completed, try to connect to CouchDB on the remote machine once again.
This time you should have more success, as shown in Figure 12-9
Now let’s replicate the futon-one database from the machine you created it on earlier to the machine that doesn’t have the database.
First create a new database on the target instance called futoncopy.
Your target machine’s Futon interface should show this database with zero documents, as shown in Figure 12-10
Now open the Futon page for your source instance, and navigate to the Replicator tool.
Under the “Replicate changes from” heading, select the “Local database” option, and make sure futon-one is chosen in the drop-down list.
Under the “to” heading, select the “Remote database” option, and in the text box enter the URL http://192.168.1.14:5984/futon-copy.
If all goes well, you should see an outcome like Figure 12-11
Caution Be sure to replace the IP address in this URL with the IP address of the machine you are working with, or it will not work!
If the JSON response in the Event section looks like it’s in order, head over to the Futon interface for the target instance, and check that the database replicated as expected.
If it did, you should now see that the futon-copy database contains five documents, the five that were replicated from the futon-one database on the other machine (Figure 12-12)
Although Futon does a really good job at implementing CouchDB’s replication features, you will probably want to trigger database replication from your own applications.
This is also very simple to perform, thanks to CouchDB’s RESTful Replication API.
Before you investigate interacting with this API using curl, let’s create a new database that we will replicate data into.
On the same machine that you created the futon-copy database, create a new database called futon-copy-two.
Now open a shell or Terminal window on the machine that contains your source database, in this instance, the futon-two database.
At the prompt, enter the following command (replacing the IP address with the IP of the target instance):
This will test that curl is installed and that you can access the remote CouchDB server.
If you get a response with a JSON object containing a welcome message and version number, you’re ready to replicate using the API.
Enter the following command to replicate the local futon-two database to the remote futon-copy-two database:
When you press Enter, the futon-two database in the local instance will be replicated to the futoncopy-town database in the remote instance (on 192.168.1.14 in my case)
The result is similar to the one you received in Futon earlier, as shown in Figure 12-13
In this command, we are making a POST request to the URI http://127.0.0.1:5984/_replicate, which is the location of the CouchDB Replication API.
You are passing in a JSON object in the message body, with two properties—source and target.
If either of these two properties represents a database on the local machine, you merely specify the database name, but if it resides on a remote database, you must give the full URL to that database.
Compaction One of the features of CouchDB is that each time a document is modified, it does not overwrite the old document but rather creates a new revision of it.
This system is used by CouchDB to implement optimistic concurrency control—which basically means that if you edit an old revision of a document (that is, a new revision has been created between the time you started to edit the document and the time you saved it), a conflict error will be raised.
Although this is very useful, it requires that system resources (specifically disk space) need to be reclaimed periodically.
To counter this problem, CouchDB provides a compaction feature, which is used to purge old revisions of documents from the database.
When the database is compacted, the database file is rewritten, with out-of-date revisions and previously deleted documents permanently removed from the database.
It is an irreversible operation, so once you compact the database, there is no way to retrieve those purged documents.
Performing database compaction is very simple using the Futon interface.
For example, I have a database named my-database with four documents currently stored in it.
Now I’m going to use compaction to reclaim some of that lost space.
Click the database name to navigate to the database’s page.
From the menu near the top of the page, select the Compact Database option, which will open a confirmation dialog box, as in Figure 12-15
Click Compact to confirm, and when the page reloads, navigate to the Overview page to check the database size.
Once again, Futon makes this process so easy—but it is likely that you won’t always use it to perform these operations.
You will probably want to build compaction into your applications—and this is also very simple—using the Compaction API.
In this example, I am once again shaving down a database that contains a deleted document with a large attachment.
First, let’s see the current size of the database using the following command:
You should receive a response telling you that all went OK.
You can see the results of these three commands on my machine in Figure 12-17
Note Because CouchDB databases can (and should) be compacted in this manner, the document revisions in the database itself should never be used as the basis for version control of documents in your applications.
At the time of writing, compacting CouchDB databases can be performed manually only, one database at a time.
Future versions of CouchDB may include more advanced compaction features such as queuing compactions and processing multiple compactions with one API call.
Fetching Documents in Bulk CouchDB allows multiple documents to be fetched with a single HTTP request.
As you can see in Figure 12-18, I have six documents in this database, with each person’s first name as the document ID.
It’s not a very practical system, but let’s keep things simple!
Now, I open my Terminal window and issue the following command:
This brings back all the documents in the database, as you might expect (Figure 12-19)
This time, I’m going to make a POST request to this URI, passing a JSON array of the document IDs I want to bring back (in this case jill, kelly, laura, and maria) as the request message:
As you can see in Figure 12-20, this time around only those documents that match the document IDs I supplied are returned in the response.
What if you want to get back the documents? In my example, I have given each document a name field with the person’s full name.
I use the query parameter ?include_docs=true at the end of the URI in my HTTP request to tell CouchDB to include the documents in the response:
The result is shown in Figure 12-21—notice that each row has a doc field with the actual document inside.
This makes it much easier to import data into CouchDB from external data sources.
I can now use the Bulk Document API to load this JSON file into the database, creating the three new documents specified:
The CouchDB server returns a response with the document IDs and revision numbers, which looks pretty positive.
Pretty sweet, huh? In this example, I specified a document ID for my new documents.
If you omit the _id field, Couch will automatically assign the document a UUID.
Want to delete a document? Pass in the _deleted field with a value of true.
For example, if I wanted to modify the documents for Jill and Jim and delete the document for Joe, I would use the JSON code in Listing 12-2
As you can see from the temporary view shown in Figure 12-23, the jill and jim documents have been updated accordingly, and the joe document has been deleted from the database.
The default behavior of Bulk Document updates in CouchDB 0.9.0 and newer is that updates are nonatomic; that is, some of the document updates may have failed, while others may have succeeded, with documents that succeeded/failed clearly indicated in the response.
This behavior ensures that just because one document fails to update does not mean the entire bulk update will fail.
Additionally, with this method there is no conflict detection; documents are committed regardless, even if you supply an invalid revision number when trying to update a document.
The conflicting documents will not be overwritten, but rather you will have two documents with the same document ID after the bulk update.
Show Functions From version 0.9.0 of CouchDB on, you can store show functions in your design documents, which will present your JSON documents in a non-JSON format.
Each document is processed individually for efficiency, and the functions are designed to be cacheable.
These functions can be used only to represent JSON data in other document formats, and they cannot make HTTP requests.
These functions are stored in design documents, in the shows and lists keys, respectively.
I’m going to use Futon to create a new design document and modify it to include these keys with a sample of each type of function.
For this example I’m using the same database I used in the previous section (the people database)
In Futon, I navigate to the people database, and from there I select “Temporary view…” from the “Select view” drop-down list.
I don’t modify the map and reduce functions for the view and simply choose Save As to save the design document.
I name my design document _design/people; the view name is irrelevant in this case.
Now from the “Select view” drop-down I select Design Documents, which shows my newly created design document.
Clicking this allows me to modify this document’s keys and values.
To create my show functions, I add a new field named shows and add the JSON object shown in Figure 12-25 as its value.
Now I can have a look at my function in action by visiting the following URL in my browser: http://127.0.0.1:5984/people/_design/people/_show/name/jill.
Impressive, eh? If you use your imagination, I’m sure you can see the potential this offers.
In the previous URL, if I change the jill portion (the document ID) to another document ID, that person’s name will be displayed.
As well as show functions, CouchDB supports list functions, which can be used to format the results returned by a CouchDB view.
For example, if I have a view, which returns all rows in my people database sorted by the name key, I can use a list function to format this in pretty HTML, with links to a show function for each item in the list.
Unfortunately, the support for list functions is experimental in version 0.9.0, although drastic improvements are available in the trunk development version.
The API for list functions is volatile at present, so check the CouchDB wiki for the syntax to use for these functions.
They are saved the same way as show functions and are called using the following URL syntax: http://127.0.0.1:5984/[db_name]/_design/[design_doc_name]/[list_name]/[view_name]
Summary In this chapter, you saw some of the more advanced features of the CouchDB database such as how to replicate databases either locally or remotely across CouchDB servers.
You learned how to replicate databases using the Futon administration interface and using the raw CouchDB API.
Similarly, you saw how to use the Compaction API to remove old revisions and deleted documents from the database, freeing up valuable resources.
Again, you used both Futon and the API to do so.
Then you learned how to retrieve more than one document at a time using a single HTTP request.
You then used the _bulk_docs API to create, update, and delete multiple documents in the same request.
Finally, you saw how recent versions of CouchDB include show and list functions, allowing users to format their JSON data in different ways that are more meaningful to the user.
In the next and final chapter, I’ll cover some of the issues surrounding the deployment of CouchDB in a production environment, including topics such as security, configuration, load balancing, clustering, backup, and reverse proxies.
In this chapter, you will learn some of the key areas of ensuring your CouchDB installation is configured correctly for deployment to a production environment.
At the time of writing, CouchDB is in beta and has been used in production by a number of organizations.
In fact, the latest version of Ubuntu Linux, 9.10 Karmic Koala, includes a copy of CouchDB by default.
With that in mind, it is worth remembering that CouchDB is still beta software, and the API for new and existing features may change between versions.
Some older versions of CouchDB will also require a dump/load cycle of data as the database formats change.
Measuring Performance CouchDB 0.9.0 and newer includes a runtime statistics feature that allows you to measure your CouchDB installation’s performance.
To see all the statistics available, issue an HTTP GET request to the URI /_stats.
If you have CouchDB installed on your local machine, either you can use the following curl command:
You should see a response similar to the one shown in Listing 13-1
Please note that I have formatted this JSON response to make it easier to read.
This is because there were no responses of other HTTP status codes generated by my CouchDB install since I started the CouchDB server.
Every key in the response contains the same metrics: current, count, mean, max, min, stddev, and description.
The description provides a useful English description of what the metric actually measures.
By default, these statistics produce results that measure the interaction with the server since it was started.
You can also choose to view results for the last minute, the last five minutes, and the last fifteen minutes if you so wish.
You can also request only those statistics for a particular key if you want.
To do so, you simply issue a GET request to the URI /_stats/group/key.
Listing 13-2 show a sample result from this request, which I have formatted to make it easier to read.
Configuring CouchDB When you first build or install CouchDB on your system, there is zero configuration required to start creating CouchDB databases.
That does not mean there are not any configuration options, however.
CouchDB’s configuration file includes many options for customizing your CouchDB installation.
There are two primary ways of modifying the CouchDB configuration file.
The configuration file is one of the areas of CouchDB that has changed significantly over recent releases.
At the time of writing, the latest version of CouchDB provides two configuration files, default.ini and local.ini.
The default.ini file includes the standard CouchDB configuration options and is overwritten when you upgrade CouchDB.
As a result, any modifications you make to default.ini will be lost when you upgrade.
For that reason, any changes to the CouchDB configuration should be made in local.ini, which will not be overwritten in an upgrade.
The second, and easier way of changing configuration options, is to use the Futon web-based administration interface, which includes a utility for modifying CouchDB’s configuration file.
If CouchDB is installed on your local computer, you can open the Futon configuration utility by pointing your web browser to the address http://127.0.0.1:5984/_utils/config.html.
See Figure 13-1 for an example of this utility in action.
To change a particular option using this utility, you double-click the current value, which will switch that option’s value column to an editor field, as shown in Figure 13-2
You can then modify the text of the option, and either use the green accept icon to save the change or click the red reject icon to cancel.
Some changes will take effect immediately, but others may not have an impact until CouchDB is restarted.
This means that remote computers cannot access the CouchDB server.
A common question is how to make the Futon administration interface display when the user visits the root URI, in other words, http://127.0.0.1:5984/
By default this responds with a CouchDB welcome message and the version number of the CouchDB server that is installed on the machine.
Note Configuration changes made using the Futon administration utility may take several minutes to take effect.
Newer versions of CouchDB also facilitate working with the configuration file using the _config API.
You will see an example of this later when I cover how to implement security in CouchDB.
Conflict Resolution When CouchDB encounters a conflict in a document during the replication process, it adds a special field to that document called _conflicts.
To see all the conflicts that have occurred in your database, you can create a CouchDB view with the map function as defined in Listing 13-3
If there are no conflicts in the database, the response you will receive from the view should look something like this:
If a conflict is found, the result may look something like the following:
This response tells you that one document has had a conflict; also, the ID of that document was mydocument, and the revision 3-1185264872 of the version that lost the conflict.
This way, the current revision is returned first, with any conflicts following.
This saves you from making a second HTTP request to figure out which revision has won the conflict.
Security Security is an important issue for any database management system.
Data should be protected by security mechanisms such as authentication, authorization, encryption, and validation to ensure that the integrity of the data in the database is maintained and to keep sensitive data hidden from prying eyes.
CouchDB is still in the alpha stage of development, and as a result its security features are incomplete and constantly evolving.
At the time of writing, CouchDB has relatively mature support for basic HTTP authentication, which allows administrator accounts to be set up in the CouchDB configuration file.
To create an administrator account, edit your CouchDB installation’s local.ini configuration file with your favorite text editor.
You will see the following lines at the bottom of this file:
Uncomment these two lines by removing the semicolons at the beginning of each line.
Then change the value mysecretpassword to a more secure password.
This will automatically be hashed into an encrypted string when you restart the CouchDB server.
With this authentication enabled, you will be required to log in to complete certain operations such as creating or deleting a database or triggering database compaction.
You can see an example of how this authentication is implemented in Figure 13-3
An obvious problem with this is that the connection is not secure, and an attacker could potentially intercept the authentication credentials if the CouchDB server is exposed to remote connections.
Unfortunately, CouchDB does not support SSL at the time of writing.
A workaround would be to create an SSL proxy using nginx or Apache and mod_proxy.
Another issue is that this form of authentication is quite antiquated and will not be familiar to many users.
It is implemented via unfamiliar pop-up login dialog boxes like the one shown in Figure 13-3, rather than integrated login boxes in the application itself.
Recent developments in the trunk version of CouchDB include support for cookie authentication and OAuth authentication, which should allow for a much more streamlined security solution than the basic HTTP authentication option.
These solutions are not yet finalized, however, and may have changed dramatically by the time this book goes to print.
Authorization is an important security concept and refers to the concept of who can see or modify what data.
Unfortunately, CouchDB currently supports only a single role, which caters to administrators.
This means that it is not currently possible to restrict read access to the database, and as a result, anybody who can communicate with the database server can read the data within it.
By specifying the owner of the document in a field in the document itself, you can match this up with the login name of the user currently logged in before an update of that document is processed.
CouchDB’s security features are being constantly developed, and by the time the application reaches version 1.0, a strong security model should be in place.
Until then, basic controls like the ones provided and using reverse proxies such as nginx and Apache/mod_proxy provide you with ample options for securing your CouchDB databases.
Backup It goes without saying that it is a good policy to regularly back up your database and its associated data.
Individual CouchDB databases can be backed up to remote computers using replication.
For more information on this, see Chapter 12 of this book where CouchDB replication is described in more detail.
It is also good practice to regularly back up the CouchDB-related files on the file system.
The important files to back up are the database, configuration, and log files.
The directories you need to back up are as follows:
Caution Because CouchDB is beta software, certain features may be added, modified, or removed between versions.
Also, some new configuration options may be added with each release.
Before a final release version of CouchDB is available, you should ensure that when restoring a backed-up CouchDB database file and configuration file, you restore it to a CouchDB instance that is the same version as the one you backed up from.
If you have backed up a CouchDB database by replicating it to another CouchDB server and you need to restore that backup, simply create a new database on the primary CouchDB server and replicate the backed-up database to it.
Fault Tolerance and Load Balancing In the previous section, you learned that you could use replication to back up a CouchDB database to an off-site CouchDB database.
Every computer system suffers from faults at some point in the system.
You might have a second hard disk installed in a RAID 1 configuration so that if your primary disk fails, the secondary one can take over.
You can have a similar setup with CouchDB—simply set up a second server in a location separate from your primary CouchDB server, and make sure that changes are replicated across to it.
One way of doing this would be to set up a cron job that runs at a frequent interval, calling a script that uses curl to replicate your primary database to a database on your backup server.
The primary issue with the cron job is that, unless your cron job runs every second (which could lead to some serious performance issues), there may be a period of time during which your two servers are not in sync.
With this method, you can use the same script that the cron job calls, but the script will get called only when a document is modified.
To set this up, open the local.ini configuration file, and find the following lines:
All that’s left is to test that the script is working by adding a new document or modifying an existing document in your primary database and checking that it has successfully replicated across to the backup database.
This script would typically trigger replication in intervals of updates or seconds.
The CouchDB wiki features an example of a script that updates views for every tenth update or at most once a second.
You will now need to set up a failover system so that in the event of the primary server crashing, requests are redirected to the secondary server.
Clustering Fault tolerance accounts for situations where a server actually fails, but what about a scenario where the performance of a server is suffering under a heavy load? As your database requirements grow, you’ll quickly realize that a single server is not sufficient to process transactions on its own.
Sure, you could upgrade your server or purchase a new, more powerful server, but eventually this will also be insufficient.
A solution to this issue would be to set up a cluster of servers that share the load generated by the database between them.
At the time of writing, this framework only supports CouchDB 0.9.0 and is in a very early stage of development.
For more information, visit the project web site at http://code.google.com/p/couchdb-lounge/
Summary In this chapter, you learned about various topics that are relevant when readying your CouchDB installation for deployment to a production environment.
You learned how to view CouchDB runtime statistics to measure your instance’s performance.
I then showed you how to configure the installation to your requirements using the CouchDB configuration file.
Next, you saw how to identify any conflicts that have occurred after replication and how you can resolve them.
You then learned about security in CouchDB and the options currently available and those that are currently under development in trunk versions of the database.
Finally, you discovered how to ensure that your data is kept safe and consistent by backing up your databases and CouchDB-related files, how to automate replication to ensure a failover for fault tolerance, and the options that are available to you to ensure your CouchDB server keeps running smoothly under heavy loads.
This appendix is an overview of the API calls you can make to the CouchDB server.
Description: Returns a welcome message and the CouchDB version number.
Description: Returns all of CouchDB’s configuration options and their current values.
Request Parameters: count (integer, the number of UUIDs to return, default 1)
Description: Returns an array with the names of all databases on the server.
Request Body: JSON object with two fields, source and target, each represented by a database name (if local) or the URL (if remote)
Description: Deletes documents marked as deleted and old revisions of documents.
Description: Creates a new document in the database, with the document ID automatically generated by the server.
Description: Creates a new document in the database, with the specified document ID.
Ensure that the document has synced to disk before returning success.
It must include the _rev property, with the revision number of the document the update is based on as the value.
Description: Updates an existing document and replaces it with a new revision.
Request Parameters: rev (String, required, revision number of document to be deleted)
Description: Deletes a document from the database by creating a new revision of the document, which is marked as deleted.
The document will be removed permanently from the database the next time it is compacted.
Description: Copies a document to the document ID specified in the destination header.
Request Parameters: full (Boolean, return full documents including metadata, default false) revs (Boolean, return a list of previous revisions, default false) rev (String, set a specific revision number) attachments (Boolean, get attachments in Base64, default false)
Request Parameters: rev (String, revision number of document, omit to create new doc)
The response is the actual file attachment (in this example, a JPEG photo)
Ensure that the document has synced to disk before returning success.
Request Body: JSON object with docs field containing array of documents.
Documents that are to be updated or deleted must contain the _rev field, specifying the revision number to be deleted as the value.
To delete a document, it should include the field "_deleted":true.
Request Body: JSON document with views field for storing permanent views, shows field for storing show functions, and lists field for storing list functions.
Description: Creates a design document to store permanent CouchDB views, show functions, and list functions.
Request Body: Map function (required) and Reduce function (optional) of view.
Description: Performs a query on the database using a temporary view.
Description: Executes a permanent view stored in a CouchDB design document.
Description: Executes a permanent view stored in a CouchDB design document.
Request Parameters: format (String, file format to show document in)
Description: Presents a CouchDB document in a defined format, as set out in a show function.
The response is the document represented in the format set in the show function.
Description: Presents a list of the results of a CouchDB view, as defined in a list function.
The response is the results of the view, in a format as set out in the list function.
Description: Presents a list of the results of a CouchDB view, as defined in a list function.
The response is the results of the view, in a format as set out in the list function.
With each version, new features are added, and older features are deprecated.
You can find out more information on the CouchDB API in the handlers section of the default.ini configuration file or on the official CouchDB wiki at http://wiki.apache.org.
CouchDB’s API is made available using a RESTful HTTP interface.
The request line, indicating the method, resource, and HTTP version of the request.
Listing B-1 shows an example of an HTTP request with all four of these properties.
Please note that the COPY method is not part of the HTTP standard but is rather an extension to HTTP used by CouchDB.
In CouchDB, GET requests are used to request data from the database.
In CouchDB, POST requests are used to create new resources, typically where the URI of the request is different to the resource that is to be created.
Unlike POST requests, PUT requests are generally used to update existing data, at the same resource the URI is requested from.
The headers usually provide information such as the time of the response, information about the server, the type of content contained in the response body, and more meta-information.
Performing HTTP Requests with curl The curl command-line utility provides a convenient way to make HTTP requests.
The following is an example of the most basic curl HTTP request to CouchDB:
This command makes a GET request to the URL http://127.0.0.1:5984
By default, curl outputs the message body of the HTTP response, as shown here:
For example, if you want the response header to be displayed, you can use the -v (verbose) argument, for example:
Although you are requesting the same resource as before, the response is much different:
By default, if a request method is not supplied, curl will perform a GET request.
To make an HTTP request with a different method, such as PUT, you can use the -X argument.
The following command makes a PUT request to the URI /mydb, which will create a new database named mydb:
If you need to specify headers in your HTTP request, you use the -H argument.
The following example uses the Destination header to define where a document should be copied to:
Many of CouchDB’s API methods require you to include data in the message body.
You can supply this data using the -d argument, as shown in the following replication example:
The previous example works quite nicely, because the data being supplied in the request body is short.
But what if you need to supply a large set of data, such as a number of documents being added using the bulk document API? In this case, you can save the data in a file, for example documents.json, and then tell curl to load the data from this file.
The following is an example of this type of request:
A final argument that you may find useful, however, is the -o flag.
You can use this to output the response to a file, as follows:
This will store the document with document ID mydoc in the file mydoc.json.
See temporary views ADC (Apple’s Developer Connection), 32 administration tool.
