Wouldn’t it be dreamy if there was a book on Android.
O’Reilly Media books may be purchased for educational, business, or sales promotional use.
Many of  the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and O’Reilly Media, Inc., was aware of  a trademark claim, the designations have been printed in caps or initial caps.
While every precaution has been taken in the preparation of  this book, the publisher and the authors assume no responsibility for errors or omissions, or for damages resulting from the use of  the information contained herein.
Since then, he’s worked with all kinds of  phones, even the new ones with big fancy schmancy screens.
Before working with mobile devices, Jonathan spent a good six years working on Wall Street designing and building user interfaces for trading systems.
And no, it’s not his fault the stock market tanked, honest! He also can’t give you any stock tips.
When he’s not coding or designing, he’s probably hanging out with his wife, Felisa, or their dog, Billie.
Otherwise, he’s probably riding (or building) a bike or perfecting his espresso extraction.
Google provides all of the stuff you need to get started building Android apps.
You can build your Android apps on Macs, Windows, or Unix and publish.
Google provides all of the stuff you need to get started building Android apps.
You can build your Android apps on Macs, Windows, or Unix and publish.
In this chapter, you’re going to add some behavior to the.
And in the process you’ll learn how the XML resources.
In fact, the RSS feed publishers want you to use.
When things take time It would be great if  everything happened instantly.
You can make your apps faster with optimizations, but some things just.
But you can learn how to manage long-running processes better.
In this chapter, you’ll learn how Android classifies all of these different.
You’ll build an app with a couple of screens, and you’ll.
You’ll learn how to navigate between screens and even pass data.
You’ll also learn how to make your own Android context men- the.
In this chapter, you’ll learn to use the more robust SQLite database solution.
You learn how to create and manage your own SQLite database.
Building a list-based app Where would we be without lists? They display read-only information, provide a way for users to select from large data sets, or even act as navigational.
In this chapter, you’ll learn about a new layout manager called.
It’ll let you lay out your screens in ways that you just can’t do with.
LinearLayout and help you code your designs just the way you want them.
Make the best of what you can use You don’t want to reinvent the wheel, do you? Of course you don’t; you’ve got apps to build! Well, one of the awesome benefits of Android is the.
This allows you to layout Views on screen relative to.
It’s new way to layout your Views, and as you’ll see.
I can’t believe they put that in an Android book.
Do you prefer stimulating dinner party conversation to dry, dull, academic lectures?
Do you want to build mobile apps for an awesome mobile OS that runs on tons of devices?
Are you solid with the basic Android development fundamentals and are just looking for a guide to its super-advanced features, like ADL or services?
Have you done some Java programming, but don’t consider yourself a master?
Have you already mastered Android programming but need a solid reference?
Are you afraid to try something different? Would you rather have a root canal than mix stripes with plaid? Do you believe that a technical book can’t be serious if it anthropomorphizes control groups and objective functions?
It was built that way, and it helps you stay alive.
So what does your brain do with all the routine, ordinary, normal things you encounter? Everything it can to stop them from interfering with the brain’s real job—recording things that matter.
It doesn’t bother saving the boring things; they never make it past the “this is obviously not important” filter.
How does your brain know what’s important? Suppose you’re out for a day hike and a tiger jumps in front of  you, what happens inside your head and body?
This must be important! Don’t forget it! But imagine you’re at home, or in a library.
Or trying to learn some tough technical topic your boss thinks will take a week, ten days at the most.
It’s trying to make sure that this obviously non-important content doesn’t clutter up scarce resources.
Resources that are better spent storing the really big things.
Like how you should never have posted those “party” photos on your Facebook page.
And there’s no simple way to tell your brain, “Hey brain, thank you very much, but no matter how dull this book is, and how little I’m registering on the emotional Richter scale right now, I really do want you to keep this stuff  around.”
We know what your brain is thinking Your brain thinks THIS is important.
We think of a “Head First” reade r as a learner.
If  you really want to learn, and you want to learn more quickly and more deeply, pay attention to how you pay attention.
Most of  us did not take courses on metacognition or learning theory when we were growing up.
We were expected to learn, but rarely taught to learn.
But we assume that if  you’re holding this book, you really want to learn Android.
And you probably don’t want to spend a lot of  time.
If  you want to use what you read in this book, you need to remember what you read.
To get the most from this book, or any book or learning experience, take responsibility for your brain.
The trick is to get your brain to see the new material you’re learning as Really Important.
Otherwise, you’re in for a constant battle, with your brain doing its best to keep the new content from sticking.
So just how DO you get your brain to treat Android like it was a hungry tiger? There’s the slow, tedious way, or the faster, more effective way.
You obviously know that you are able to learn and remember even the dullest of  topics if  you keep pounding the same thing into your brain.
With enough repetition, your brain says, “This doesn’t feel important to him, but he keeps looking at the same thing over and over and over, so I suppose it must be.”
The faster way is to do anything that increases brain activity, especially different types of  brain activity.
The things on the previous page are a big part of  the solution, and they’re all things that have been proven to help your brain work in your favor.
For example, studies show that putting words within the pictures they describe (as opposed to somewhere else in the page, like a caption or in the body text) causes your brain to try to makes sense of  how the words and picture relate, and this causes more neurons to fire.
More neurons firing = more chances for your brain to get that this is something worth paying attention to, and possibly recording.
A conversational style helps because people tend to pay more attention when they perceive that they’re in a conversation, since they’re expected to follow along and hold up their end.
The amazing thing is, your brain doesn’t necessarily care that the “conversation” is between you and a book! On the other hand, if  the writing style is formal and dry, your brain perceives it the same way you experience being lectured to while sitting in a roomful of  passive attendees.
Here’s what WE did: We used pictures, because your brain is tuned for visuals, not text.
As far as your brain’s concerned, a picture really is worth a thousand words.
And when text and pictures work together, we embedded the text in the pictures because your brain works more effectively when the text is within the thing the text refers to, as opposed to in a caption or buried in the text somewhere.
We used redundancy, saying the same thing in different ways and with different media types, and multiple senses, to increase the chance that the content gets coded into more than one area of  your brain.
We used concepts and pictures in unexpected ways because your brain is tuned for novelty, and we used pictures and ideas with at least some emotional content, because your brain is tuned to pay attention to the biochemistry of  emotions.
That which causes you to feel something is more likely to be remembered, even if  that feeling is nothing more than a little humor, surprise, or interest.
We used a personalized, conversational style, because your brain is tuned to pay more attention when it believes you’re in a conversation than if  it thinks you’re passively listening to a presentation.
We included more than 80 activities, because your brain is tuned to learn and remember more when you do things than when you read about things.
We used multiple learning styles, because you might prefer step-by-step procedures, while someone else wants to understand the big picture first, and someone else just wants to see an example.
But regardless of  your own learning preference, everyone benefits from seeing the same content represented in multiple ways.
We include content for both sides of  your brain, because the more of  your brain you engage, the more likely you are to learn and remember, and the longer you can stay focused.
Since working one side of  the brain often means giving the other side a chance to rest, you can be more productive at learning for a longer period of  time.
And we included stories and exercises that present more than one point of  view, because your brain is tuned to learn more deeply when it’s forced to make evaluations and judgments.
We included challenges, with exercises, and by asking questions that don’t always have a straight answer, because your brain is tuned to learn and remember when it has to work at something.
Think about it—you can’t get your body in shape just by watching people at the gym.
But we did our best to make sure that when you’re working hard, it’s on the right things.
That you’re not spending one extra dendrite processing a hard-to-understand example, or parsing difficult, jargon-laden, or overly terse text.
In stories, examples, pictures, etc., because, well, because you’re a person.
And your brain pays more attention to people than it does to things.
These tips are a starting point; listen to your brain and figure out what works for you and what doesn’t.
Your brain works best in a nice bath of  fluid.
Dehydration (which can happen before you ever feel thirsty) decreases cognitive function.
Get your hands dirty! There’s only one way to learn to Android: get your hands dirty.
And that’s what you’re going to do throughout this book.
Android Development is a skill, and the only way to get good at it is to practice.
We’re going to give you a lot of  practice: every chapter has exercises that pose a problem for you to solve.
Don’t just skip over them—a lot of  the learning happens when you solve the exercises.
But try to solve the problem before you look at the solution.
And definitely get it working before you move on to the next part of  the book.
Groaning over a bad joke is still better than feeling nothing at all.
If  you find yourself  starting to skim the surface or forget what you just read, it’s time for a break.
Once you go past a certain point, you won’t learn faster by trying to shove more in, and you might even hurt the process.
If you’re trying to understand something, or increase your chance of  remembering it later, say it out loud.
Better still, try to explain it out loud to someone else.
You’ll learn more quickly, and you might uncover ideas you hadn’t known were there when you were reading about it.
Part of  the learning (especially the transfer to long-term memory) happens after you put the book down.
Your brain needs time on its own, to do more processing.
If  you put in something new during that processing time, some of  what you just learned will be lost.
They’re not optional sidebars, they’re part of  the core content! Don’t skip them.
Here’s what YOU can do to bend your brain into submission.
We put them in, but if  we did them for you, that would be like having someone else do your workouts for you.
There’s plenty of  evidence that physical activity while learning can increase the learning.
When the book asks you a question, don’t just skip to the answer.
The more deeply you force your brain to think, the better chance you have of  learning and remembering.
The more you understand, the less you have to memorize.
Brian Sawyer kept the ball rolling all through this process.
I had to learn a lot to pull this off, and he always made sure I was hooked up with the right folks to help me get it done!
Dawn Griffiths used her keen design sense and Head First touch to make these pages more beautiful and more learner friendly.
As with everything else in my life, this book would not have been possible without my totally super awesome wife, Felisa! She listened to countless hours of  discussion on Android, as well as the finer points of  teaching it Head First.
It’s a virtual library that lets you easily search thousands of  top tech books, cut and paste code samples, download chapters, and find quick answers when you need the most accurate, current information.
Ready to get started? Great! You’re going to start building.
No, wearing that suit with that tie is crazy! But, hey, you summed up Android pretty well.
Maybe your an Android user, you already know Java and want to get in on the mobile craze, or you just love the open operating system and hardware distribution choices of  Android.
With careful planning, you’re app can run on all of  these Android powered devices.
From phones and tablets, to TVs and even home automation, Android is spreading quickly.
There are or course games (because we all love playing games on our phones), but also really great apps that just make our lives better like navigation and commuting schedule apps.
There are a lot of  mobile platforms out there, but with Android’s presence and growth, everyone is building out their Android apps.
Before you dig into your first app, let’s take a look at exactly what Android is and who’s responsible for it...
The Android Market web view for an outdoor exploration app AllTrails.
Android is a mobile operating syetem, but it’s a lot more than that too.
There is a whole ecosystem, a complete platform, and community that supports Android apps getting built and on to new Android based hardware devices.
Google maintains Android Google maintains Android, but it’s free to use.
Device manufacturers and carriers can modify me, and developers can build apps for free.
Hardware manufactures can use the Android operating system and build special hardware around it.
Manufacturers can even modify Android to implement custom functionality for their devices.
Google gives you the tools Google freely distributes the tools for you to build your own Android apps.
And you can build your apps on multiple platforms: Mac, Windows, Linux...
This is where your users can download their apps right to their phones.
Google runs one market, but there are also others run by Amazon, and Verizon for example.
With all these different devices and OS variations, how do you build anything at all? Where do you even start?
In practice, it’s not so bad! It’s true that there are a bunch of  different Android devices out there, from all kinds of different manufacturers running different modifications of  Android.
Sounds crazy right? While it definitely takes some care tuning your apps for these different devices, you can get started building basic phone apps really easily.
Later on in the book, you’ll learn strategies for dealing with different types of  devices like phones with different resolutions and even designing for phones and tablets in the same app.
Meet Pajama Death It’s time to introduce you to an awesome rock duo called the Pajama Death! They love Android and love to sing about it!
They write all of their song lyrics in the form of a haiku.
They’re about to play their favorite song for you! This one’s called...
They want to make an app with the Android Love lyrics to hand out to their fans.
They heard that you were learning to build your own Android apps.
They were wondering if  you would build the app for them.
And how could you say no? Of  course you’ll do it, you’re a huge fan!
I dreamed of an phoneopen source and hackable Android for the win!
Getting started Just asking you to build an app isn’t a lot to go on.
So the Pajama Death made a napkin sketch of  what they want the app to look like.
It’s an app showing the haiku, with each line of  the haiku on a new line.
This looks great but how do I start building it?
First you’ve got some setup to do Since this is your first Android app, you’ll need to setup your development environment.
Let’s start with a quick look at what you need in your development environment to build Android apps.
Form there, you’ll install your own development environment, then build the app for Pajama Death!
Since it’s a haiku in three lines, each line of the haiku goes on its own line.
Since the song is called Android Love, call the app ‘Android Love’ too.
The Android development environment is made up of  several parts that seamlessly work together for you to build Android apps.
Eclipse is a generic IDE, not specific to Android development.
Software Development Kit (SDK) The Android Software Development Kit (SDK) contains all of  the lower level tools to build, run and test your Android apps.
The ADT is really just a user interface, and the guts of  the app building all happens here in the ADT.
Android Packages You can develop and support multiple versions of  Android from the same developmentw environment.
These packages add functionality to the base SDK to let you develop for that Android.
The full integrated Android development environment works well as a whole to help you easily build Android apps.
But everything you need to build and test your Android apps is the Android SDK and Android Packages.
Even though you can use the SDK without Eclipse, all of the examples in this book will use Eclipse and the ADT plugin.
Choosing your IDE Eclipse may be a fine IDE, but what if  you don’t want to use it.
You may have your own IDE of choice that you’d rather use...
Set up your development environment You won’t be able to build your apps until your development environment is setup! Follow our nifty Android development environment setup instructions over the next few pages and you’ll be ready to build your apps!
Turn the page for instructions on setting up your own Android development environment...
Eclipse is a free and open source IDE managed by the Eclipse foundation (started and managed by IBM, but a very open community)
There are a number of  different versions of  Eclipse optimized for different types of  development.
You should download the latest version of  Eclipse Classic  for your Operating System.
After you download Eclipse, follow the installation instructions for your platform and launch Eclipse.
When you launch Eclipse for the first time, you will be prompted to enter a workspace location; a directory where all of  your Eclipse projects and settings will be stored.
Feel free to use the default or enter your own.
The Android SDK contains the core tools needed to build and run Android apps.
Once you download the SDK zip file, unzip it to your hard drive and the SDK is ready to go.
The ADT is an Eclipse plugin, and it installs through the standard Eclipse plugin installation mechanism (so this should look very familiar if  you’re an experienced Eclipse user)
The ADT is just the glue between the SDK and Eclipse, so the ADT needs to know where the SDK is installed.
The SDK includes a number of command line tools and it’s convenient to be able to launch them without having to type in complete paths.
Install android packages The SDK is designed to allow you to work with multiple versions of  Android in the same development environment.
To keep downloads small, the SDK version packages are separated from the SDK.
This also allows you to update to new versions of  Android without having to redownload the entire SDK.
When you expand the tree node, you’ll see a combination of  SDK Tools, SDK platforms, samples documentation and more.
These are all plugins to the SDK that you can add to expand the functionality of  the SDK.
Q: What about the samples should I install those? A: Google put together a set of sample apps that show off a bunch of features and techniques in the platform.
They won’t be used in the book, but they are extremely useful.
If you want to learn about something not covered in the book, the samples are a great place to start.
Q: And what about Tools? Should I install those too? A: The tools inside the SDK can also get updated as new functionality is released in the Android platform.
It’s a good idea to keep these up to date.
Make a new Android app project Now that you have your environment setup, it’s time to make your first project.
The Eclipse ADT plugin comes with a Wizard to create new Android apps.
All you have to do is enter a few bits of information into the wizard, and it makes a fully functional (but very boring) application for you.
This will be used for the java package name in your project.
This will generate the behavior code for your screen displaying the hauki.
What’s in an Android project? Wizards are great because they do a lot of  basic setup for you.
But what did that wizard do anyway? Here’s a quick look at the basic Android project  that the wizard created.
To look at the project contents, click on the “Package Explorer” tab in Eclipse.
App Behavior in Java code The behavior of  Android apps is built with Java code.
This code controls what happens when buttons are pressed, calls to servers, and any other behavior that your app is doing.
Your android projects have a source directory where all of  the Java code lives.
You’ll be using images to style your app and give them custom polished looks.
The images and other raw binary resources in this directory are included in your app.
Resources and XML layouts For Android apps, layouts are primarily defined in XML rather than code.
All sorts of  other properties are defined in XML too.
Configuration files Your app now has Java code, XML resources, and binary assets that define it.
Configuration files are the glue that holds all of  it together.
Everything from the title of  your app on the Android home screen, to the different screens in your app are defined in these configuration files.
The Android SDK includes an Android emulator desktop application that simulates a complete running Android device.
It runs a full basic android operating system and the default set of  Android apps.
It’s obviously not a complete hardware Android device, but it’s about as close as you can get with hardware emulation!
You can simulate touch screen “presses” by clicking on the screen with your mouse.
The emulator also includes hardware buttons like a keyboard and the Android hard buttons.
At this point, your new project is all ready to run! The wizard not only setup a project for you, but also created a very basic runnable Android app.
But instead of  seeing an Android app running, you’ll see the following dialog.
Alternatively, you can run your android apps by pressing the “play” button on the Eclipse toolbar.
Wait, I thought you said I could run the app right out of the box! Were you lying to me?
The issue isn’t with the app the wizard generated, the issue is that there no way to run it.
Your Android development environment can built apps for multiple Android versions, hardware configurations and screen sizes.
So when you try and run your app, the Android tools don’t know what type of  device you want to run your app on.
The solution is to create Android Virtual Devices (or AVD for short) that defines a particular device’s software version and hardware format to run your app in.
You can think of  an AVD as like a saved emulator configuration.
Since you don’t have an AVD setup already (and there are no stock AVDs in the Android SDK) you have to make your own.
Click Yes on the dialog to take you to the AVD creation screen.
Why won’t the app run? The app didn’t run, and instead you were faced with a dialog with an error about a target not being found and asking you to create a Virtual Device.
Setup an emulator configuration Clicking yes on the dialog to create a new AVD takes you to the Android SDK and AVD Manager window.
This is the same place you configured the SDK, but now the “Virtual Devices” panel is selected.
From here, you’ll be able to create a new AVD.
Now that you have an emulator configuration set up, run the app again.
Run it the same was as before by pressing the play button in the toolbar.
This will first launch the emulator and automatically install your app on the emulator and start your app.
I wanted to start by thanking you for joining us tonight.
Android Emulator: Well, since I am software I do have to do what you tell me.
Head First: Fantastic! Just to clear the air here, there’s been some confusion out in the development community.
Are you a real Android device or, dare I say, an imposter?
I’m not a hardware device, but I’m as close to one as you’re going to get with pure software.
Head First: If  you’re not a real device, why exactly should we use you?
Android Emulator: There are some serious benefits to me being fully software.
For starters, it’s easy to quickly test and debug your software without having to carry around a hardware device.
Plus, since I’m fully virtual, I can run as different devices at the same time.
If  you didn’t use me you’d have to carry around a bag of  phones!
Android Emulator: Well that’s exactly what the emulator configurations are for! They tell me everything I need to know, from hardware configuration (like screen size), and device capabilities (like wireless latency), and even the version of  Android.
Everything I need to know about what device I’m supposed to act like is right there!
Head First: Neat! So not only is it easier to use you than a real device for testing, but I can test on all different kinds of  devices and Android versions using you instead of  keeping a stack of  Android devices.
Head First: That all sounds great, but if  there’s one thing I’ve learned it’s that nothing is ever that easy.
Android Emulator: The catch is that since I’m not a real device, there are some subtle differences in how I work than a real hardware device.
When I’m running, I sort of  spoof  a location based on your computers location, but I’m not really using GPS, so I can’t be your only test.
I don’t have my own camera, so I have to fake it a little.
You’re really useful for basic testing, with a number of  different configurations.
But if  I need to test something hardware specific, nothing beats real world hardware.
Thanks for joining us! Now, don’t you have some apps to run?
But take a step back and compare the app you have with the app that was sketched out.
Let’s get some feedback! You’ve just got your first (although pretty boring) app up and running.
I dreamed of an phone open source and hackable Android for the win!
Both have text in the body, but your app’s text (the hello world stuff) doesn;t match the sketch.
Check for differences The app you have and the sketch for the app you want are pretty similar.
The only difference is that the main text display is displaying a boring hello world message instead of  the haiku.
Now you just need to replace the boring string with the haiku and you’ll be done with the app.
Start by looking at the layout There is an XML layout that was generated by the wizard.
This is what control the visual display of your app.
Let’s take a look at the layout and locate where the string is being set.
But how do you change the string displaying in the app?
Locate the layout Android layouts are defined in XML  There was one layout created for you by the wizard called main.
Navigate to the main.xml file in the Eclipse package explorer.
I was expecting to see the raw XML, since this is an XML file.
When you double click main.xml and open it, you’ll this new pane opened up in Eclipse.
This is a graphical editor provided by the ADT Many of  the files used to build your Android apps are XML based.
The ADT Eclipse plugin includes graphical editors for these files that help you edit them.
Now that you’ve seen the visual representation of  the XML layout, you can also view the raw XML that the editor is displaying...
The graphical editors are just a facade over the XML underneath.
So don’t worry, if  you want feel all super-coder, you can always jump in edit the XML source.
Or you can use the graphical editors, or a mix of  both!
Click the main.xml tab on the bottom to view the XML.
Here is the same information from the graphical display in text XML format.
Q: Can I edit the XML text here, or do I have to use the graphic editor.
A: The graphical editor just graphically displayed the contents of the XML text file.
If you update the XML code, Android will keep the graphical editor in sync.
Q: Can I use both the graphical editor and the text editor, or do I have to choose?
A: Sure you can use both! If you make changes in the graphical editor and switch to the text view, you’ll see your changes.
Likewise, if you make changes in the text and switch to the graphical view, you’ll see your changes there too! So` switch back and forth as much as you like!
Android XML layouts consist of  a number of  user interface components called Views, and layout managers called ViewGroups.
The generated main.xml layout has one ViewGroup with a single View inside it.
Since the TextView is displaying text, the String must be set in there somehow.
The ViewGroup, in this case a LinearLayout fills the screen.
The View inside the layout is a TextView, a View specifically made to display text.
Take a closer look at the TextView Android Views are declared in XML layouts along with a number of  attributes to configure them.
Let’s take a look at the generated TextView from the layout and look at it’s properties.
These XML properties define the width and height of the view.
Hold on, not so fast! The property seems to be setting the TextView’s text to “@ string/hello” but the app says “Hello World, HaikuDisplay!”
Android loves resource properties It’s a good practice to move details of  your user interface to property files.
Similar needs hold true for colors, font sizes, image names and more!
The “@string/hello” isn’t the string itself, but rather a pointer into a String property file.
Now look at the property files and locate the String definition.
Android value files Right below layouts in the res folder is a folder called values.
This folder contains the Android resource value files for your app.
Open the folder and you’ll see a single file named strings.xml.
Here is the Android Resources file with the app’s strings.
Open the strings.xml file Opening the strings.xml file will display another Android graphical editor in the main Eclipse pane.
This editor is similar to the graphical layout editor, except that it display Android resources.
If you haven’t already, navigate to the res/values/ strings.xml file in the Eclipse package explorer  Double click on the file to open.
Click on the tab on the bottom right to view the raw XML if  you want.
Look at the values You can edit any of  the values by select an item from the list on the left of  the pane.
Once you select an item, a second panel will display showing the name and the value for that item.
Once selected, a new panel displays where you can edit the name and value of the item.
There is the hello world sting displaying in the app!
Now that you see where the string is located, where can you edit it? Can you edit the string in the graphical editor? In the raw XML?
But that underlying XML is just like any other kind of text file to Eclipse and has to be saved after editing.
After you make changes in a graphical editor, make sure to save before you run.
Changing them here will update the value in your app.
The \n’s make new lines so the haiku will display on three lines.
With the “hello” Resource Element updated with the poem, run the app again and make sure it shows your changes.
You built your first app using the tools Google provides to help you get started quickly.
Your development environment is up and running with Eclipse, the ADT plugin, and SDK configured to use an up-to-date Android version.
And you modified the basic generated app to make it your own.
Stay tuned for a new feature that Pajama Death want toadd to the app...
Great work, Now we have an awesome way for our fans to see the lyrics to our favorite song!
Binary assets (like images and fonts) included directly in the project.
Now that you built your first Android app, you’re starting to.
It’s a good idea to add the SDK directory to your path (while you’re in a configuration mindset) so you can easily run Android tools later from the command line.
And don’t limit yourself: feel free to setup a bunch of them!
From there, modify the generated app to make it your own.
Layouts are defined in XML and you can find them in /res/layouts.
Values (like strings) are defined in Android Resource XML files.
When you open an Android XML file in Eclipse, you’ll see a graphical editor to help you modify these files.
If you want to view or edit the raw XML text, click on the right tab on the bottom of the editor.
You can go back and forth editing XML files in the graphical editor or text.
Just remember to save your files when you use the graphic editor!
It’s like harding cattle trying to organize this crowd to do anything!
We want the app to rock! But right now it just displays the haiku...
Yeah, we want it to do something! I’m thinking we hide the haiku and add a button our fans have to push to show it! Let me sketch it out...
Pajama Death sketched out what they were thinking so you could build it.
They added a button on top of the haiku, and hide the haiku on launch.
Then when you push the button  the haiku shows up!
Add a button to the app to show the haiku.
If you’re thinking this looks great, but you have no idea where to start...
You’re going to add a new button to your app’s screen.
Eventually, this button will show the haiku, but not in this first step.
This is the first time you’ll be adding a brand new component to a screen and you’ll learn what components are available and how to add them to your app screens.
First off, you’ll be starting with the AndroidLove app project form Chapter 1, and making a few modifications to it.
The AndroidLove app as you left it at the end of the last chapter.
Open the AndroidLove project from Chapter 1 if you don’t already have it open.
After adding the button, you’re going to hide the haiku text.
The button still won’t do anything and you won’t see the haiku text at all, but hey, you’re making progress! Here you’re going to learn about the different attributes you can set on your widgets from XML.
Next, you’re going to wire up the button to show the haiku.
This is going to be your first taste of  Java coding as you connect the Java behavior to the XML screens.
You’ve got your project open and you’re ready to start working on this new action.
Which file do you need to open to add the button?
Add the button You worked with the main.xml layout file in Chapter 1 that defines the entire layout for your app’s screen.
This is where you’re going to add the new button to your app.
In Chapter 1, you edited the XML layout in the raw XML source.
Now you’re going to add a component using the graphical editor.
Click on the ‘Graphical Layout’ tab to view the layout in the graphical editor if  it isn’t already showing.
Notice all of  the Views in the list on the left side of  the screen.
These are all of the different Views available to you in Android.
You can add views to your screen by dragging them from the list onto your screen.
Adding a View Up Close Let’s take a closer look at adding the button using the Graphical Layout editor.
Click on the Button and drag it to the top of the layout.
Drag the button all the way to the top and you’ll see an orange dotted line  where the button will be added.
Click on the button on the left panel and drag it to the top of  the graphical layout.
You’ll notice an dotted line display where the button is going render.
You’ll the first View defined in the file is the Button you just added!
Fix the button text It’s great that the button is on the screen now, but not so great that the button text is showing up as “@+id/Button01”
Here’s the button with the weirdo button text showing up as “@+id/Button01”
To get to the bottom of  this, compare the View XML declarations of  the TextView displaying the hauki and the Button you just added.
The haiku TextView android:text property is referring to the haiku string property in strings.xml.
The android:text attribute is set to “@string/haiku” which references the haiku String resource in strings.xml.
Now look at the Button definition The Button definition’s android:text attribute value doesn’t have the “@string/” prefix.
Wait a second! There is no Button01 string property in strings.xml.
The value for the android:text property in the TextView is referring to a String resource in strings.xml.
That special prefix tells the view rendering code to look into the strings.xml file for a string property.
Q: If the Button is missing the @ string prefix, how is it displaying any text at all?
A: If the Android view rendering code doesn’t detect the @string prefix to look up a key in the strings.xml file, it renders the value in the android:text directly.
Q: Is that why the button says “@+id/Button01” because it’s rendering directly from the android:text property?
Q: Hey cool! So why are we messing with strings.xml file at all? Couldn’t I just put all of my strings directly in the layouts and call it a day?
The string resource element was designed to remove string constants from your layouts.
It’s a good idea to keep them separate, and Android is setup to handle this out of the box.
Add a new String property called “love_button_text” and give it a value of “Show me some Android love!”
The fix for this is going to include two changes.
You’ll need to add a new string property in strings.xml, and then you’ll need to update the Button definition in main.xml.
This is where you’re to add the new String property and you’ll do it directly in XML!
Give it a name, that’s what you’ll use to reference this string in your layout.
The value is the actual string you want to display.
You should have added a new String property called “love_button_text” and given it a value of “Show me some Android love!”
And the value is set to “Show me some Android love!”
Now you just need to use it! You just added the String resource for love_button_text.
Now it’s time to plug it into the Button declaration in main.xml to set the text.
Use the “@string/” prefix plus the String resource name here to have the Button reference the String resource you just added.
Here’s the prefix telling the view rendering to use a String resource.
And here’s the name of the String resource to use.
Whew! You added the  Button, which had some weird text.
And to fix that, you added a new String resource, and used that new String resource from the Button’s android:text attribute.
Let’s see if  it all worked! Run the app again...
The button is displayed with the correct text from the String resource.
Hide the haiku text Now that the Button is added and looking good, it’s time to move on to the next step: hiding the haiku text.
How are you going to do this? Well, two strategies are probably coming into your head right now.
You could remove the TextView and it back once the button is pushed or you could set the text to be invisible and make it visible once a user presses the button.
Let’s go with the invisible text option! OK, but that’s not a huge help, right? You need to know how to hide text.
This is something new that you haven’t done yet and you need to know where to find out about new things in Android.
This area lists all of the packes in the documentation.
Once a package is selected, this section will show all of the classes in that package.
When you click on a class or a package, the main panel will show the details for what you’ve selected.
If you know the class you’re looking for, but now the package, you can type it in here to search the documentation.
Let’s take a quick look around the Android online documentation to get acquainted.
You can navigate to what you’re looking for by either selecting the package and class name, or searching for a class name in the search box on the top right.
Now since you’re looking to update an attribute on the TextView, you need to look at the TextView documentation.
Browse the XML attributes As you browse the documentation for TextView, you’ll notice it has a number of  Java methods, but it also has XML attributes listed.
Since you’re working with the main.xml layout definition in XML, focus on the XML attributes.
Does any look interesting? You’re looking for something that can hide the text...
It says it can control the “visibility of  a view.” That’s exactly what you want! Using this you can make the entire TextView invisible when the app starts up.
View XML attribute details If  you click on any attribute, you’ll be taken to a section that details the usage of  that attribute.
It looks like you went to the documentation for View when you clicked on the android:visibility attribute.
Look in the URL after you go to the android:visibility details and you’ll see “View” in the URL now instead of “TextView”
View is a base class that other widgets inherit from The View.java class is a base class with several cross widget methods, attributes, and constants.
And if  you look at the headers for both Button and TextView, you’ll see that they both inherit from View.
The Android docs include superclass methods descriptions along with the locally implemented methods (but if  you look close you will see that the android:visibility attribute was located in a section called Inherited XML Attributes)
This will hide the TextView and with it the haiku text.
You should have updated this code with the android:visibility set to invisible.
This should hide the TextView and with it the haiku text.
You’ve hidden the TextView with the haiku on it with the android:visibility attribute.
Awesome! You’ve got the button displaying AND the text is hidden.
Now you just have to show the text when you press the button.
It’s time to start making that Button work! There is an attribute on the Button View for just this purpose called android:onClick.
The value for the attribute is the name of  the action you want to use.
Let’s use it now! Add the android:onClick property to the Button definition in main.xml.
You’ll get an error like this if you run your app now and press the button.
So far, you’ve updated the screen layout, added a new View to the screen, modified and added String resources.
All of  these changes control the way the app starts.
But for the button action, you’ll be making a change that a user can initiate while the app is runningadding behavior to the app.
Let’s start by taking a look at the Java source code in your project and it’s contents.
This is the only Java source file in your project created by the new project wizard.
Only one Java source file created by the wizard? Let’s take a closer look at it...
Think of an Activity as the Java code that supports a screen.
And in this case, AndroidLove is actually the Activity that supports your main screen you’re defining in main.xml.
Double click on AndroidLove.java and Eclipse will automatically open it in a Java editor.
The button is expecting to call a method in this class.
Since the AndroidLove Activity is setting the main.xml layout on the screen, the Android action code is going to look for the method defined in the android:onClick attribute here.
The action code is going to look for a method in the following format.
This code is setting the view defined in main.xml on the screen.
The method name needs to match the value of the android:onClick attribute.
The method needs to take one argument of a View.
You can run the app and click the button now.
Nothing will happen, but the app won’t force close either.
Once this is done, we can run the app and press the button and it shouldn’t break.
First, you need to get a reference to the TextView and then you need to set the visibility property to true.
From XML to Java You’ve got a disconnect right now.
But you action code is defined in Java in the AndroidLove Activity.
How are you supposed to get references to XML defined Views from your Java code?
To solve this, Android generated a special called the ‘R’ file.
This is a file of  constants that allow you to get Java references to the TextView you defined in main.xml In fact, you can get references to all kinds of  in app resources you define! But remember the String resources you defined in XML? You can get references to those too.
The R file consists of  a number of  public static final constants, each one referring to an XML resouce.
The constants are grouped into interfaces according to XML resource type.
Android provides a number of  utility methods for using these constants.
Take another look at the onCreate method from AndroidLove.java where the screen layout is set.
Setting the content view from the R file is nice and all, but what you really want to do is get a reference to the TextView! Well, Android provides another cool utility method called findViewById to do just that.
The findViewById method is in the base class of  Activity, so you can use it directly in the AndroidLove class since it’s a subclass of  Activity.
The findViewById method takes one parameter, the R constant for the View.
But since the method is meant to be generic, it returns a View not one of  the View subclasses (like Button, TextView, or any other View)
It’s easy enough though, you just need to cast the result to the View you’re expecting.
Let’s see how this works for retreiving a reference to the button on screen.
Cast the returned View to the appropriate View class you’re looking for.
Pass the R.id.Button01 to findViewById to get a reference to the on screen button.
There’’s no android:id attribute defined in the TextView declaration in main.xml, so no R file constant get’s generated.
Don’t worry though, you can just add one yourself! Below is the the TextView declaration in main.xml.
Add an android:id attribute and give it a value of “haikuTextView”
Give the textview an id Take another look at the id interface inside R.java.
There is a constant for the Button but not for the TextView.
Weird, huh? The issue here is that the R file constants for the Views are generated based on an android:id attribute in main.xml.
This android:id attribute controls the name of the constant created for the Button in the R file.
There’s no android:id attribute defined in the TextView declaration so no R file constant is created.
There wasn’t an android:id attribute defined in the TextView declaration in main.xml, so no R file constant get’s generated.
You should have added an android:id attribute and given it a value of.
Complementary Java methods Most of  the properties you can set from XML can also be set from code.
This is important since you need to make the haiku TextView visible from the v action in Java.
Let’s take another look at the TextView documentation for android:visibility and look for the complementary Java method.
The constants are in the View base class, so you can refer to them as View.VISIBLE, View.
The magnets below contain all of the code fragments you need to finish the method.
This is a constant you can pass into setVisibility to make the View visible.
You should have used the magnets to complete the implementation.
The text was hidden, but displayed when you clicked the button.
That so totally rocks! You are developing some mad Android coding skills!
You did it! When you started the chapter, the AndroidLove app had no behavior, it didn’t do anything.
But now you’ve made it do something! And to make that happen, you added a new view, created and used a new string resource for it’s text, built a button action in Java, and used the R file to help go back and forth between Java and XML.
Use the graphical layout editor to make adding new Views easy.
Add new String resources when you need them (and add them to Strings.xml)
Use the “@string/” prefix in your XML layout to refer to String resources.
Explore the online documentation for all of the attributes you can set in your XML layouts.
If you know what you’re looking for but don’t know where to find it, use the documentation search.
Get references to Views on screen by calling findViewById and passing in that View’s ID constant from the R file.
Make sure your Views in your XML layout have android:id attributes set if you need to get references using findViewById.
That action method will be called on the Activity that launched the screen, so make so to add the method.
Remember all of the Java source is in the /src folder.
Use the Button onClick attribute to declare the name of the action method.
Open the Activity that displays the layout with the Button.
Make sure the method takes in a single View as a parameter.
In fact, the RSS feed publishers want you to use them! In this chapter, you’ll.
Along the way, you’ll also learn a little more about layouts, permissions, and.
People put up RSS feeds on the Web and I can use them for my own apps? Every day is like my birthday on the Internet!
I really wanted a telescope, but all I can find are these binoculars.
Since I can’t see space, I’ve been checking out the NASA image of the day web site instead.
It’s got a cool new picture of something about space every day!
Yes! We can write an app for that! Let’s put your newly developed Android skills to use and build an app that will let Bobby see the NASA daily image on his phone.
The image of  the day site looks pretty good on a big computer, but not so hot on a phone.
It technically works, but not without a ton of  scrolling and zooming.
Plan out your app Before starting on your brand-new app, take a minute to plan it out.
Since you’ll be building the app from he image feed from NASA, start by taking a look at the feed to get a feeling of  what you have to work with.
You can find out more about RSS feeds with a quick search of  the Web, but for this app, just think of  it as pure XML.
Eclipse has a built-in XML editor that really helps to visualize the format of  feeds like this.
Then you can open the XML file in Eclipse (which will automatically open the built-in XML editor) and view away!
Image of the day feed saved locally as an XML file and opened in Eclipse’s XML editor.
There’s a whole bunch of stuff in that feed! If you show it all, you’re going to overload your users with information and miss the point of building a specialized mobile app for viewing the image of the day.
At the same time, just showing the image would be pretty boring.
Take a look at the XML view of the feed and pick a few things you think you should show.
This is an image of the day app, after all!
There’s a whole bunch of stuff in that feed! If you show it all, you’re going to overload your users with information and miss the point of building a specialized mobile app for viewing the image of the day.
At the same time, just showing the image would be pretty boring.
You were to look at the XML view of the feed, pick a few things you think you should show, and make say why you picked it.
The image title will help users quickly tell what the image is about.
If the image is cool, users will want to read more about it.
You’ll need to make sure you get the correct title and description, because the example feed contains many of each.
In the example feed, the image description is blank, but the item description is populated correctly.
But using the image URL, you’ll be able to doanload the image and diaply it on the screen.
Your answers may be slightly different and you may have picked a different field or two (and that’s perfectly OK)
We’ll use the properties here, but there are several other perfectly good ways you could build this app.
I definitely want display the image, so I’ll include the image URL.
This is an image of the day app, after all!
Screen Design Magnets To build your interface, add the View magnets at the bottom of this page to the screen.
There is one View for each of the properties you picked from the RSS feed.
Screen Design Magnet Solution You were to add the View magnets at the bottom of this page to the screen to build your interface.
There is one View for each of the properties you picked from the RSS feed.
The image is front and center, stretched to the size of the screen.
The date really could go anywhere, but it’s kind of a nice subheader isn’t it?
The description is nice to have, but it’s definitely not the most important piece of data.
It’s also really big! Best to keep it at the bottom of the screen, out of the way.
I’m late for a math test, so I’ve got to run.
But so far, this design looks awesome, I can’t want to see it working!
Time to start coding! Every good app starts with a good plan, and you’ve got one now (the selected fields from the RSS and the screen design)
Create a new project You’re building a new app, so start a new project.
Mobile apps are small and concise, so get used to having lots of  little apps (and projects) around!
Store feed information locally Removing variables from development is a good thing.
Store feed data locally, so you can focus on building your UI and not connecting to the feed.
Connect the app to the XML RSS feed Once the app is up and running, just plug it into the XML feed and get the live data.
Build the UI using the stored feed data You’ve got a design for the UI; now it’s time to execute it.
Create layouts, implement UI functionality, and get the app up and running!
But It’s better leave out spaces, because a directory is created with the project name in your workspace, and command-line navigation is usually easier without spaces.
This is shown to your users, so format it to be human readable.
Select the latest platform you have installed (2.3 at the time of this writing)
Web site plus application name is a pretty safe bet for a package name.
Naming the activity to match the project name is a good rule for single-screen apps.
Get rid of the autogenerated ‘Hello’ stuff You’re not going to need the autogenerated TextView showing the default “Hello World, NasaDailyImage” text.
So before you get going, delete the TextView and the the String.
You now have a nice, clean app, without the boilerplate hello app content.
Store feed information locally Start by saving text values as string resources.
Open strings.xml and add three new strings for the image title, date, and description.
The easiest way to do this is to copy the values directly from the sample XML feed file you saved at the beginning of  the chapter.
Watch out for places where you need to add escape characters.
Save the image in your project Images are stored in your Android project as resources in the res directory.
Can you find a folder called drawable inside your project’s res directory?
One of  the great things about Android is how many devices it runs on...
You’ll learn more about supporting different screen sizes and devices later.
The default emulator will use the images in this directory.
Here’s the res directory, the same place your layouts and string resources are located.
Do this! Open up a browser and navigate to the URL for the image in the RSS XML file.
Save the file to your project in the res/drawable_hdmi directory.
Now that you have stored your data locally, let’s build the layout!
Below are magnets with the XML layout declarations for the Views in your layout along with the the Views they represent.
Drag the the View XML magnets onto the layout on the next page of the exercise.
You’re using LinearLayout, so you just need to arrange them with the component at the top of the screen as the first in the layout and continuing down.
Below are magnets with the XML layout declarations for the Views.
You were to arrange the the View XML magnets to complete the layout for the app.
Run the app by selecting the project in the Exclipse explorer view and selecting run.
You’ll have to select Android Application in the “Run as” pop-up that displays.
Nice! The screen is looking good! The running screen matches your design.
Actually, scrolling would be a good idea! You never know how long the description might be.
The best we can do is make our app visually scalable.
A good way to do that is just to make the entire screen scroll.
Hey, how come the description is showing but getting cut off.
Wouldn't it be dreamy if you could just wrap up your entire layout into some kind of View that would automatically scroll? But I know it's just a fantasy…
Use ScrollView to show more content ScrollView is a View you can add to your screens to make content scroll.
Use ScrollView by adding a child component to it, and the ScrollView will automatically scroll.
The description TextView is big enough to overfill the screen by itself!
You can put one or more of  the existing Views into the ScrollView.
Any Views you add to the ScrollView will scroll, and the views not in the scrollview won’t.
Since your goal is visual scalability, just make the entire layout scroll.
This way, you can be gauranteed to have a scalable UI, even if  unepxected information comes through the feed (like a really long title, for example)
One catch using ScrollView is that it can have only a single child View.
In the example on this page, the TestView is added directly as a child to the ScrollView.
But for the whole screen to scroll, you need multiple Views to scroll.
The solution is to add a complete LinearLayout (with multiple child Views) as the ScrollView’s child.
Add and amend the following code to use the ScrollView to make the entire screen scroll.
And since the ScrollView can hold only one View, you need to add the entire LinearLayout as the one ScrollView child View.
Quick Tip: This needs to be in the root layout.
If you add this layout to a ScrollView, you’ll need to move this to the ScrollView.
You were to used the ScrollView to make the entire screen scroll.
And since the ScrollView can hold only one View, you should have added the entire LinearLayout as the one ScrollView child View.
Did you remember to move the xmlns:android attribute from the LinearLayout to the ScrollView (the root view)
Look how the ENTIRE LinearLayout is scrolling, not just one of the components.
Run your app to check the scrolling you just added.
See how the entire screen content scrolls up and down together? That’s because you added the entire LinearLayout as the child to the ScrollView.
Let’s show it to Bobby and see what he thinks!
Wow, that’s looking pretty slick! But what’s this about not hitting the actual NASA RSS feed?
Things are going really well with the design and layout.
Now it’s time to make it work the way you want...
There are plenty of  XML parsers out there, and Android has builtin support for three of  them: DOM (Document Object Model), SAX (Simple API for XML), and XMLPULL.
They each take a different approach to parsing the XML and each has benefits and drawbacks.
We’re going to skip the big XML parser smackdown here (don’t worry, though, you can find plenty on the Web) and just pick one.
Let’s review some Ready Bake parser code to keep you moving!
The parser begins at the beginning of  the XML, fires appropriate messages, and exits.
Here’s a quick sample of  a few events that get fired in the first three lines of  the NASA image feed.
The parser for the NASA feed will need to listen for the SAX start element messages for the fields in the app (the title, image URL, description, and date) and cache the values.
Now that you understand how the SAX parser conceptually works, here is a parser packaged up as Ready Bake code that you can just drop into your app.
Don’t worry about understanding everything; just add it to your project.
Since the events get called separately (like starting elements and their contents), keep track of what element you’re in ...
Download the IotdHandler code from the Head First Android Development site and add it to your project.
Connect the handler to the activity Now that you’ve added the feed parser code to your project, you need to use it in your activity.
Start by instantiating the handler in your Activities onCreate method.
The app’s not going to work with the parser yet.
You’re parsing the feed, but you’re not setting the values cached in the feed on the Views.
True, the values are cached in the handler, but never displayed.
Let’s make a method called resetDisplay that will set all of  the view data on screen.
Then you can call that method in onCreate() afterprocessFeed() returns.
Code Magnets Complete the resetDisplay() method below by retrieving references to the on-screen Views (using findViewById) and setting the values on those Views with the values passed in.
Once this method is complete, you can use it to pass in the values from the feed.
Then set the values on those Views to the cached values from the parser.
Code Magnets Solution You were to complete the resetDisplay() method below by retrieving references to the on screen Views (using findViewById) and setting the values on those Views with the values passed in.
With this method complete, you can use it to pass in the values from the feed.
Use the image from the feed parser and set it on the ImageView.
Get a reference to the title view and set the text to the cached value from the handler.
Same deal with date View: get the View reference and set the text to the value from the parser.Get a reference to.
Finish up by getting the description View reference and setting the text with the cached description value.
The parser is integrated with the activity, and the results from the parsing are displayed on the screen.
The resetDisplay method is a helper method you’re about to write to populate the fields on screen with the parsed data.
Now you can finish connecting the handler in the onCreate() method.
This will take the cached values in the parser and set them in the Views screen.
What broke? Where would you look to find out what’s broken?
Find errors with LogCat It’s OK; errors happen! The important thing is knowing where to go to find out what’s happening with your application, so you can fix things when they break.
Android uses a builtin logging mechanism that outputs to a screen included in the Android Development Tools (ADT) called LogCat.
After you click OK, you’ll see the new LogCat view in your Eclipse workspace.
Here you’re getting an IOException saying the host is not found.
That’s odd, because you just went to nasa.gov from your browser.
With all the cool stuff  you can do with Android devices, it’s hard to remember that they are mobile devices.
And because of  this, Android is built to be super careful about making sure each app has rights only to the system resources it absolutely needs.
The only way for your app to get those permissions is to request them.
When users install your app from the Android market, they are prompted with a list of  permissions that your app requsts.
If  they agree, they accept the permissions and the app installs.
As an example, let’s take a look at the Android market install page for the official Twitter app.
The permissions on the market page are generated from these constants.
Add a permission to access the internet The Twitter app had a lot of  permissions, but your app just needs permission to access the Internet.
Find the AndroidManifest XML file in the root of your project.
You can find it in the root of  your project.
Add a new permission to the manifest Just like all of  the other Eclipse XML editors you’ve been working with, there’s a custom editor for AndroidManifest file.
Click on the Permissions tab and press the Add button to add a new permission.
To apply the changes, save the file when you’re done.
Select the permission type When the dialog opens, select Uses Permission and click OK.
This tells Android that you want to use a permission in your application.
Select the permission There are a bunch of  different permissions that you can ad to your application.
What, seriously? I have to ask permission to do everything? Don’t you trust me at all? This is ridiculous!
But really, I have to tell you everything I do? Like everything? That’s lame!
I just need to be really careful about what I let you do unsupervised.
Well, listen, my user (who is also your user I might add) expects us all to work together to keep the whole phone secure.
We can’t allow any viruses, unauthorized data access, unecessary Internet access, or other security no-nos to spoil their experience.
That way, I can tell our user what you’re planning on doing and they can decide if they will let you do it.
How can I trust that if  the user says no to you you’ll actually listen? You wouldn’t even listen to me if  I couldn’t kill your process!
Now that the permissions are properly set, the app should run correctly, parsing the feed and displaying everything on the screen.
This is all great, but something is going wrong with the formatting.
If there’s a custom logger in the Android SDK, maybe there’s something for debugging layouts too.
This cool little tool from the Android SDK lets you do all kinds of  introspection on your layouts and Views to get to the bottom what’s going on.
Launch the Hierarchy Viewer by opening a terminal, going to your <SDK>/tools directory, and executing hierarchyviewer at the command line.
Find layout problems with HierarchyViewer When you launch the Hierarchy Viewer, the first thing you’ll see is the selection screen below.
There are two main views; the view you’re going to look at inspects the screenshot and allows you to view your Views in a tree and see visual details about them.
View hierarchy Zoomed in view (zooms where the crosshairs are)
After you select the emulator, click here to launch the main window.
You’ll see this screen when you launch the Hierarchy Viewer.
Set the adjustViewBounds property You can see from the Hierarchy Viewer that the ImageView is too big.
But why? The cause is actually that the apsect ratio is not preserved when the Bitmap from the Web is displayed.
The aspect ratio is what keeps the width to height proptionally the same when you resize an image, and the image is being resized by the internal layout code to fill the screen width.
Without keeping the aspect ratio the same, the image stretches and takes up too much space.
When set to true, the image stretches to the edges of the screen, and sets a height proprtional to that width.
If  you set the adjustViewBounds property to true in your layout XML, the extra space will go away.
It’s all coming together! The layout works just like you designed it, the feed parsing is up and running, and the layout issue with the ImageView is fixed.
With the adjustViewBounds properts upated in your layout, run the app again.
This time, you should see the image resized correctly in the layout.
This is looking great! I’m super psyched to see how far you’ve come with the app so quickly!
Really great work! You really did put your new Android development skills to use and built a whole new app! And you learned even more skills along the way.
But most importantly, you built a cool app that made your users happy!
Now that you have a cool RSS feed-parsing app in your toolbox, you can.
Start with SAX parsing, but explore the DOM and XMLPULL parsers to see if they will work better in your app.
It’s a good practice to break your app down into small development pieces.
For RSS feed apps that rely on the Internet, it’s perfectly acceptable (and even a good idea) to build out your app with test data and plug in the Internet services later.
These will get picked up by the Android compiler and the images will be available to your application.
Use ScrollView when your app’s content is too big for the screen.
When things go wrong, use LogCat to look at Android errors and log statements.
Make sure your app has the proper permissions configured in AndroidManifest.
Use HierarchyViewer to debug your layouts when your app isn’t displaying correctly.
This can be extremely helpful when layouts or views aren’t behaving as you might expect them to.
You can use it for small text like labels, or really big text like the Image descriptions.
You can add your own images to the res directory and display them in an ImageView.
ScrollView can have only one chid View, so wrap multiple child views in a layout to make them all scroll.
You can make your apps faster with optimizations, but some things just take time.
But you can learn how to manage long-running processes better.
But not before I eat my breakfast, drink my coffee, finish the paper ...
I’ve been using the NASA app, and I love it! One thing, though.
Do you think you could add a refresh button? Right now, I have to restart the app every time I want to check...
But why is a refresh button necessary? You’ll want to make enhancements to your apps from user feedback, but it’s a idea to understand why you’re being asked for something.
Let’s take a look at the Activity Lifecycle which will explain when the feed loads and why it isn’t enough for Bobby...
When does the feed refresh? The feed refreshes only when the activity starts and the onCreate() method is called.
Currently, the only way to get the app to refresh the feed is to exit the app and then restart it.
You could override more of  the lifecycle methods like onResume(), but that would only cover the case where the app is paused and restarted.
You could also build some sort of auto-refresh mechanism, but that is very processor and battery intensive.
Looks like the refresh button is a good idea after all.
This is called when your activity is displayed on the screen.
This is called when your activity is created and typically where layouts and configuration occurs.
This is where you process the feed and set the values for the on-screen views.
This could be caused by a phone call, an alert from another application, or a user switching to a different app.
This is only a portion of the full Activity lifecycle.
You can find the complete diagram in the online docs.
The Activity Lifecycle Activity has a number of  special methods (called lifecycle methods) that get called during the lifecycle of  the activity.
The onCreate() method where you set the layout is one of  these methods, and there are many more.
A few of  these methods are shown here, so you can see where the feed is (and is not) refreshed.
Update the user interface A recurring Android user interface design pattern for on-screen actions, the button bar is a gray panel on the bottom of  the screen holding one ore more buttons.
Let’s build the button bar as a standalone layout and then add it the app’s current layout.
Encapsulating parts of your fullscreen layout into separate smaller layouts can be a good way to organize layouts.
And since LinearLayout extends ViewGroup, which itself  extends View, you can add your entire new LinearLayout you’re making for the button bar as a child to your original ViewGroup.
Button bar on the Add screen in the contacts app.
A little space between the text and the button bar.
A little space between the button and the top and bottom of the button bar.
Start with a basic LinearLayout LinearLayout is a surprisingly functional layout manager for basic screen designs.
You’ve already built a few screens using LinearLayout, and you’re going to build the button bar with it too.
You will learn more about LinearLayout in the process, and don’t worry; you will also learn about other layout managers later in the book.
The key to using LinearLayout for the Button Bar is to center the refresh button using the android:gravity attribute.
This is overkill, because horizontal is the default, but it’s good to be safe.
You’re off to a great start! Now start fine-tuning the layout ...
The beginnings of the button bar layout: right now, just a LinearLayout with a centered button.
Use properties to fune-tune the layout With the button properly centered in the layout, let’s focus on finetuning the layout to get the colors and spacing looking like the button bar examples.
Use these properties to get the layout looking the way you want.
Use a solid color for the button panel background, which is defined in 8-digit hexadecimal format (two digits each for alpha, red, green, and blue)
Use Density Independent Pixels (DIP) to specify spacing rather than raw pixels to make your layouts really flexible.
Use Density Independent Pixels (DIP) to specify spacing rather than raw pixels to make your layouts really flexible.
Density Independent Pixels (DIP) Android supports too many screen sizes to keep track! Using raw pixel dimensions in layouts might make your layout look good on one device and terrible on others.
Android provides an ABSTRACT sizing measurement called Density Indepent Pixels that is derived from device attributes.
This means that you can define layout attributes in DIPs that will look great on all Android devices.
This way, it will be just as big as it needs to fit the “refresh” text.
This will make sure that the layout stretches to the edges of the screen.
Button Bar Layout Magnets Construct the button bar layout using the magnets below.
Think about the width and height for each the button and the LinearLayout.
And don’t worry; you’ll have a few extra magnets left over for widths and heights you didn’t use.
Now that you have the button bar layout, you need to add it to your screen.
Below is a graphical representation of your current View/Layout hierarchy.
Draw new views and layouts for the button bar Views (and any other views and layouts you need) to complete your layout.
Also, remember, just like ScrollView that can have only one child, there can be only one root layout.
Layout allowing more than one child View in the ScrollView.
Button Bar Layout Magnets Solution You were to construct the button bar layout using the magnets below.
Think about the width and height for each the button and the LinearLayout.
The width is set to fill parent, so it fills the width of the screen.
The height is set to wrap content; it shouldn’t be the full height (since there is also the scrollpane)
Add some spacing between the button panel and scroll pane.
Both the width and height are set to wrap content, so the button will size as it needs to based on the button text.
Now that you have the Button Bar layout, you needed to add it to your screen.
Below is a graphical representation of your current View/Layout hierarchy.
You were to draw new views and layouts for the button bar Views (and any other views and layouts you need) to complete your layout.
The complete original layout is added as the first child View to the root LinearLayout.
The button bar is added the second child (since it should be displayed under the ScrollView)
The root layout, which has both the ScrollView and the button bar as children.
Height changed to wrap-content; otherwise, it would fill the screen, leaving no room for the button bar.
Add the button bar to the app layout in main.xml.
Also, add the wrapper LinearLayout in the root, and add the button bar and the ScrollView to that layout.
Do this! Update your layout in main.xml, adding the code for the button bar and the wrapper LinearLayout.
And WHERE exactly is the button panel? All that time building it and it’s gone?!?
After you update your layout in main.xml, run the app to verify your layout updates.
The widths and height look OK, and the LinearLayout should be resizing everything...
LinearLayout lets you assign a weight property that controls the resizing behavior of  its child Views.
For the button bar, you want the button bar to be just as big as it needs to and then have the ScrollView fill the entire rest of  the screen.
A weight of 1 fills the screen with just enough space left for the button bar.
A weight of 0 makes the button bar just as big as needed.
All of  the properties used here (and many, many more) are documented in the Android online documentation.
To learn about more of  these properties, look at the documentation for your specific layout as well as the.
Run the app again, and check that the layout weight modifications made the desired layout changed.
Now just wire up the refresh button and you can show it to Bobby.
To keep your code clean and concise (and without duplicate code), move the feed-handling code to a new method called refreshFromFeed()
Then you can call the same feed-processing method from onRefresh() and onCreate()
Did the refresh work? Was the feed successfully processed? It’s totally unclear what exactly happens here when the user clicks on the refresh button.
Did the refresh work? I didn’t see anything change on the screen...
Use the debugger The debugger is an incredibly useful tool for figuring out what’s happening while your application is running.
The Android Eclipse plugin includes tools to seamlessly use the built-in Eclipse debugger to debug your Android apps, either in the emulator or even on a device.
Follow these steps to debug the app and see whether refreshFromFeed() is getting called.
The debugger automatically deploys and attaches to your app (on the emulator or a device)
There is just enough detail here to debug the NASA app.
Take a look at the Android and Eclipse documentation for more tips on using the Eclipse debugger.
Get a breakpoint The debugger works by setting stopping points in your app called breakpoints.
A breakpoint is like a scenic stop on a nice drive where you stop and take a look at what’s going on in that spot.
Launch the debugger The debug button is just to the left of  the play button in the Eclipse toolbar.
It uses the Android launch configurations you already set up.
This view shows you the values of variables that are in scope.
The arrow next to the breakpoint indicator lets you know the line was reached.
Monitor your app in the debug perspective The debug perspective is where you can see the state of  your app running.
A perspective is Eclipse’s name for a stored collection of  panels for specific work.
When you launch your app with the debugger, it will immediately hit a breakpoint, because onCreate() calls refreshFromFeed(), which is where you set your breakpoint.
Add a progress dialog The ProgressDialog is a utility that shows a modal progress pop-up with customized information for your app.
ProgressDialog is perfect here, because you can show your users status, but you also keep them from repeatedly pressing refresh and successively triggering refresh after refresh.
How do you show a progress dialog? Show a ProgressDialog by calling the static method show on ProgressDialog.
The show method returns a reference to a ProgressDialog isntance.
Make sure to cache the reference, as you’ll need it to dismiss the dialog when you’re done with it.
Call dismiss on the dialog when you’ve completed all of your work and the dialog will go away.
Modal means users can’t interact with the application at all.
Add the necessary code to show the ProgressDialog before the long-running work is shown.
And remember to dismiss the  dialog once the work is completed.
Dismiss the dialog here, now that all the work is done.
You were to add the necessary code to show the ProgressDialog before the long running work is shown.
You should have also dismissed when dialog once the work is completed.
Dismiss the progress screen, now that the work is done.
Run the app and click Refresh to verify that the ProgressDialog is working correctly.
The whole point of  putting in the ProgressDialog was to have it show while the long-running feed-processing work is occurring.
The dialog code is in the right place, but for some reason it’s not showing.
Dedicated UI thread Android has a dedicated thread for updating the user interface (UI)
It is responsible for repaints, layouts, and other graphical processing that helps keep the UI responsive and keeps animations smooth.
The UI thread has a queue of  work, and it continually gets the mot important chunk of  work to process.
The button action occurs in the UI thread by default.
When the progress screen is shown, successive calls to repaint the screen are made to support the animation effect.
But the process feed code also runs in the UI thread, which occupies the UI thread.
By the time the UI thread could run the repaint code, the dialog was hidden.
This expensive call on call on the UI thread keeps repaints from happening.
Keep the UI thread free of expensive processing for a responsive UI.
The solution is to keep non-UI work off  the UI thread and all UI work on the UI thread.
Feed processing completed, call the UI thread to hide progress screen.
Moving the feed processing work off  the UI thread and onto a separate thread allows the UI thread to focus on repaints.
The first repaint shows the progress dialog, and the successive repaints make the animation happen.
Then, when the feed processing is completed, the new thread puts an item in the UI queue to hide the progress screen.
This switch back to the  UI thread is important, because the non-UI thread can’t hide the dialog, which is a UI component.
Spawn a new thread for the long process The most straightforward way to get your long-running processing code on a different thread than the UI thread is to make an inner class extending Thread and implementing the run method inline.
There are about a million different ways to structure your code to deal with threads.
The goal here isn’t to debate them, but to understand how to work with the Android UI thread.
Run the app again, now with the expensive feed-processing code moved to the new thread.
What’s the problem? The problem is the dismissing of  the ProgressDialog.
Properly managing your work on and off  the UI thread means not only getting expensive work off the UI thread, but also making sure that all necessary UI code occurs on the UI thread.
You’ll see this error dialog when you run the app.
Use Handler to get code on the UI thread The dialog.dismiss() call needs to get back on the UI thread.
Getting off  of  the UI thread is a cinch by creating a new thread.
But that thread doesn’t have a reference to the UI thread to get code to execute back on the UI thread after the expensive work.
Handler works by keeping a reference to the thread it was created by.
You can pass it work and Handler ensures that the code is executed on the instantiated thread.
Handler actually works for more than just the UI thread.
Once you have a Handler instance, you can call post, passing it a Runnable to execute on the desired thread.
Cache a Handler reference as a member variable, so you don’t have to create Handlers over and over again.
Since onCreate() executes in the UI thread, creating the Handler here makes a handler with the ability to execute code on the UI thread.
Instantiate the Handler there, so you can get work back on the UI thread later.
Handler Magnets Use the magnets below to complete refreshFromFeed() with all of the necessary threading changes.
The expensive feed-processing code needs to execute on a new thread, and the call to dismiss the dialog has to happen on the UI thread using Handler.
Assume the Handler was already instantiated for you in onCreate()
Handler Magnet Solution You were to use the magnets below to complete refreshFromFeed() with all of the necessary threading changes.
The expensive feed-processing code should be executing on a new thread, and the call to dismiss the dialog should be executing on the UI thread using Handler.
Assume the Handler was already instantiated for you in onCreate()
The dialog is called from the UI thread (where refreshFromFeed is called from)
Call resetDisplay and dismiss the dialog from the UI thread.
Now run the app and you’ll see the progress screen show while the app loads from the feed during onCreate()
You’ll also see the the progress screen show when you click the refresh button.
No progress dialog, now that the feed processing is complete.
Great work! Now your users know that the app is doing something.
Give the app a few seconds to load the feed.
Don’t get me wrong, looking at the daily image is pretty cool...
I’d love to be able to save a particularly cool picture as my home screen wallpaper, so I can look at it later.
You’ve already got the image from the feed, so you just need to make the call to set the wallpaper using that.
And you’ve already got a button bar layout in place, so you can just add a second button to the bar.
You can set the wallpaper by retrieving the WallpaperManager and setting the wallpaper by Bitmap.
You’ve already got a reference to the Bitmap coming from the feed, so this should be a piece of  cake.
You already built the button bar to house the refresh button.
And that is an ideal place to add a button to set the wallpaper.
More than two buttons in the button bar could be a problem if  the button text is two long, but these two work great.
You can pass in the bitmap you decoded from the feed here.
Add the “Set Wallpaper” button The button bar is built with a LinearLayout, so you can just add the new Set Wallpaper button directly to the button bar layout.
LinearLayout defaults to horizontal orientation, but it’s a good idea to include the orientation attribute anyway.
It makes your code easier to understand later and proptects you in case defaults change.
Add the “Set Wallpaper” button as the second child in the button bar layout.
This will add it to the right of the refresh button.
Add the new button to the buton bar layout in main.xml:
Update strings.xml adding the new string for the Set Wallpaper button:
Since the current scope is an inner class; you can get a reference to.
Setting the wallpaper can take a while, so kick off a new thread to get it off the UI thread.
Update the activity for the button action The feed-processing code already downloads the image from the URL and creates a Bitmap from the web resource.
To complete onSetWallpaper (the onClick call declared in the layout), cache the Bitmap once decoded and pass that image to the WallpaperManager.
This will do a default dump of the exception to LogCat.
Store the bitmap in the image member variable after processing the feed.
Run the app to make sure the Set Wallpaper button is correctly configured in the layout.
The button is displaying correctly, horizontally positioned next to the Refresh button.
If  you go to the home screen, you’ll see that the wallpaper was in fact set to the feed image.
That said, the user experience is aweful! Remember that getting your app working is just one part of  bigger picture.
The issue here in setting the the wallpaper is that the change is happening off  screen away from the user’s view.
What you need is some positive reinforcement so your users know it worked.
Click on the home screen and you will see that the wallpaper was in fact set to the NASA feed image.
I clicked Set Wallpaper and now the app is just sitting there!
You could just show a ProgressDialog while the wallpaper is being set, but there’s a better way...
Use toast to give users reinforcement You could show a progress screen while the wallpaper is being set.
But one of  the inherent features of  the progress screen is that it blocks users from doing anything.
This is great when the feed is loading, because you want to block your users from interacting with the app.
This is what keeps users from repeatedly clicking on refresh.
You want to make sure to notify your users when the wallpaper is set, but you don’t want to keep them from doing something else in the app.
For example, it would be perfectly acceptable for the user to set the wallpaper and to scroll down to view the long description while the wallpaper is being set in the background.
This wouldn’t be possible if  you used a progress dialog, because it blocks all user interaction.
Android provides Toast for just such occasions Toast is a passive, non-blocking user notification that shows a simple message at the bottom of  the user’s screen.
A toast typically displays for a few seconds and disappears.
Meanwhile, the user can still completely interact with the application.
Here is what the app would look like with a Toast message when the wallpaper is set and the code to make it happen.
Complete the onSetWallpaper method below adding two Toast notifications: one for success and one in case of failure in the catch block.
The Toast call must be made from the UI thread.
Use the Handler reference cached previously to make both of the toast calls on the UI thread.
Add the code here to create the toast confirmation message for setting the wallpaper.
Add a toast message in the catch block with the message “Error setting wallpaper.”
You were to complete the onSetWallpaper method below adding two Toast notifications: one for success and one in case of failure in the catch block.
The Toast call must be made from the UI thread.
You should have used the Handler reference cached previously to make both of the toast calls on the UI thread.
Use the handler to post runnables to the UI thread.
Now you will see the wallpaper set and a nice toast conformation that lets you and your users know.
Fantastic work! Bobby and all of his friends are going to love this!
You’ll have the NASA app up on the market in the next chapter.
Use extended properties of LinearLayout to fine-tune your screens (padding, margin, background, gravity, and more)
Use fill_parent to maximize the size to fill the parent.
Use wrap_content to make a View just as big as it needs to be.
Use Density Independent Pixels (DIPs) when you need to define sizing or dimensions.
This will ensure your layouts work on the most possible number of devices.
Layouts can nest (you can add layouts as Views to other layouts)
Just remember that too much nesting will slow down the layout and rendering of your screens.
Use the debugger to trace code in the emulator or a device.
Both Toast and ProgressDialog can be extensively customized for your app.
Keep expensive work off the UI thread, and UI work only on the UI thread.
Use Handler to add UI work to the UI thread’s queue from non-UI threads.
Keep expensive work off the UI thread; otherwise, the responsiveness of the UI will suffer.
Calling UI code from non-UI threads will throw exceptions throughout your code.
Toast: Use toast to passively display a message to your users.
ProgressDialog: Use a ProgressDialog when you want to block user input and display a message and progress on the screen.
Using these groups, you’ll be able to make your app look great on these.
I hope this new app you’re talking about supports my fancy new high resolution phone.
All my friends love my app and want to use it too! Can you publish it on the Android Market?
Bobby and all of this friends love the app! Bobby has been using the NASA image app all around schools and his friends have all been asking him for a copy.
And the place to share Android apps with everyone is the Android Market.
But you would like to test the app out a bit before publishing it for the world.
You installed the app on Bobby’s phone using the direct ADB install, but you can’t do that with all of  Bobby’s friends since you don’t have access to all of  their phones.
Can you share the app without using the market? Sure! You can publish the apk on any webserver.
Then anyone can download the app by navigating to the hosted APK on their Android device.
Let’s get some of Bobby’s friends to download the app...
Upload your APK to a webserver You can upload the APK to any webserver.
You can find the APK in your project’s bin directory and transfer it to your webserver.
Navigate to the URL on the device Anyone who wants to install the app can navigate to the URL of  the hosted APK from the browser on their device.
Let’s see what Bobby’s friends have to say Bobby got a bunch of  his friends to download the app over the air and play with it for a few days.
But two of  his friends, Jesse and Shawn, came back with some great suggestions for improvement.
Jesse’s wants to see more of the image in landscape mode Jesse has a phone with slide-out keyboard, which forces the app into landscape mode.
Technically it works, but Jesse doesn’t like how much vertical space the buttons are taking up.
She would love to see more of  the images instead of  those buttons...
Shawn wants small screen phones to show more of the image too Shawn has a really small phone (300x350 pixels to be exact)
Like Jesse, shawn thinks the buttons on the bottom are a waste of  space on his extremely small phone.
You’ve got to do something about those buttons and that cheesy.
Shawn also pointed out that the home icon is pretty boring...
Shawn really thinks you should update it to make the app look more polished.
Is there a way we can make everyone happy? Leaving the app as is for portrait mode, but updating it for landscape and small phones?
You knew there are all kinds Android devices out in the wild with different sizes and resolutions.
But with such a simple layout, who would have though there would be so many issues?
Some of the issues are also device specific Jesse and Shawn both have suggestions for improving the app in landscape mode and for really small screened devices.
But you don’t want to change the regular app in portrait mode.
The app you built at the end of  Chapter 4 still works great for those devices.
On Android, you can make changes just for specific devices! With all of  the different device shapes and sizes in the vast world of  Android devices, you’ll often need to customize your apps for a few devices, like really big, or really small screens.
Luckily, Android provides a mechanism for using a default layout and overriding those layouts for specific devices.
Update the icon Shawn also pointed out the boring default Android home icon.
Update the layout for small screens Shawn brought up a good point that the buttons are wasting space on small screens.
But just like landscape mode, you want to be able to leave the regular layout alone and just make the modification for small screens.
Update the layout for landscape mode You can solve Jesse’s problem by creating a special layout for landscape mode.
This way, you can leave the regular portrait screen as it was and make adjustments for the landscape version.
Make a plan Making your app work on all kinds of  Android devices takes some careful planning.
In the case of  the NASA Image of  the Day app, Bobby’s friends tested it out on all kinds of  different devices and you’ve narrowed down just a few cases where you need to improve.
Here’s what you’re going to do to get this app market ready in no time!
Preview landscape mode in your emulator The first issue to address is the lack of  vertical space in landscape mode.
But before you can fix anything, you need to be able to duplicate the issue reported by your users in your own development environment.
In this case, you need to be able to view the app in landscape mode.
The screen and the emulator controls switch to landscape mode.
Update the design for landscape mode The main issue with landscape mode is the buttons.
With the button bar gone, you’ll gain a lot more vertical space to show the day’s image.
But where could you put those buttons? There are a number of  different solutions, but let’s move the buttons to the top right of  the screen in line with the title and date.
This will keep most of  the screen as is and move the buttons where there is currently blank space.
You’ll gain all of this vertical space by moving the buttons.
On this phone, this is almost one fifth of the entire screen height!
But how do you change the layout just for landscape mode?
Select the “Layout” radio button as the resource type and enter “main.xml” as the file name.
Entering the ‘-land’ at the end of the folder automatically adds the Landscape in the Chosen Qualifiers.
Where is the layout? The new layout you made is named the same as your existing layout, but your new layout is in a parallel directory called layout-land.
This special construct allows the Android runtime to determine the best layout based on the device’s state.
This doesn’t require any code changes to your Activity since both resources are still referenced by the same R constant at R.layout.main.
If the device is in portrait mode, the regular layout will be loaded.
Landscape Layout Magnets Since the portrait and landscape layouts are so similar, a good starting place is to copy and paste the layout.
Below is the copied beginning and end of the layout.
Use the magnets below to complete the layout with the buttons on the top right of the screen.
Landscape Layout Magnet Solution Since the portrait and landscape layouts are so similar, a good starting place is to copy and paste the layout.
Below is the copied beginning and end of the layout.
You should have used the magnets below to complete the layout with the buttons on the top right of the screen.
Here is a vertical LinearLayout for the title and date.
Yeah, that’s a huge improvement! It’s little details that will make your app so cool on the market.
That button bar looks great in portrait mode but sure was a huge waste of  space in landscape mode.
With those buttons moved to the top right, you can see almost all of  the image, even with the minimal screen height.
And with this change, portrait mode is left alone and just the landscape mode was altered.
Is this the only way to solve this button issue?
A: There are many different ways to have solved this design issue.
This is pretty common when you’re dealing with user interface design.
Q: What is another way you might have solved this? A: You’ll learn about Android menus in a few chapters.
These are actions that are hidden until you press the menu button.
Menus are often a good choice if you want to hide functionality but still allow it to be used.
A: You can change the screen all around and have entirely different functionality! That said, you probably want to keep landscape mode and portrait mode pretty similar since they are the same screen from your users perspective and they might go back and forth as they move their phone around.
Also, remember that the underlying Activity is the same for both landscape and portrait mode, so any features added to either orientation need to be supported by the same Activity.
Now that the landscape mode is taken care of  it’s time to move on to small screen devices.
But as with any other issue, the first step is always to replicate it in your local development environment.
Testing landscape mode was easy! All you had to do was switch the orientation of  the running emulator.
Create an AVD for a smaller screen device The whole point of  creating an AVD (which as a quick refresher stands for Android Virtual Device) is to be able to run an Android emulator mimicking a hardware device.
Switching between landscape and portrait mode worked on the same device, but making a smaller screen requires a new device.
Name the AVD API10300-350 (API version number and screen size)
Launch your new AVD The AVD is just a description of  a device.
Before you can test your app on that AVD, you need to start it.
Run the app on the small device Now that the new AVD is running you can run the app on it just like you would your original AVD.
Run your project now and you’ll see it running on the smaller emulator.
Woah! That’s not what the app looked like at all on the smaller phone.
Here is the NASA Daily Image app running on the small device emualtor!
This app looks totally different eben though it’s the same sized screen.
It looks really different! There are always going to be little differences between devices and emulators.
But there shouldn’t be this drastic of  a difference in display between  them! Let’s get to the bottom of  this...
You may have to select the emulator after trying to tun your app.
Your Android development environment knows about the emulators you have running.
And if  you have more than one emulator running, it will ask you which emulator you want to install and run your app on.
If  you closed your original emulator before launching the new smaller device, you won’t see this.
Screens Up Close There are two screen device properties that effect the way your application looks and runs on a device.
Per inch, the small screen phone actually has twice as many pixels as the big screen.
Super zoomed in view of 1x1 inch squares on the two screens.
Screen Size This refers to the number of  horizontal and vertical pixels on a screen.
Pixel Density This refers to the abstracted number of  pixels in an inch.
Under Hardware, there is a property called Abstracted LCD density.
If you edit your pixel density, you must set it to one of these values.
Once you start the updated AVD, run the app again and see how it looks.
Now the app looks right on the small screen emulator!
What updates would you make to the layout design for small screens?
Update the design for small screens Now that you can see what the small screen layout looks like, you can also see that you can’t make the same change you did for the landscape layout.
Even though they both want to get rid of  the buttons, the small screen doesn’t have room for the buttons next to the title and date.
What about just making the buttons scroll with the picture and the description just for small screens?
Scrolling the buttons is a great idea! You could relatively make a minor change to the layout, just for small screens, allowing the buttons to scroll on the screen after scrolling past the image and the description.
This is a bit of  the best-of-bothworlds as your regular screen sizes will still have the buttons on screen, and just the small screens will have to scroll.
But at least they’ll see more of  the image like the landscape layout.
Just like you created a landscape specific layout, you can create a small screen specific layout.
Open the new Android XML File Wizard and create a new layout XML file as you did before.
But this time, add the size by selecting size from the Available Qualifiers.
Once added, select small from the dropdown to indicate a small screen size.
When you click Finish, a new layout xml file will be created in the layoutsmall directory for small screen phones.
Small Screen Layout Magnets Below are the magnets you need to complete the custom small screen layout.
Just like the landscape mode, the small screen layout with the buttons in the ScrollView is going to be really similar to the original layout.
You just need to recreate the button bar inside the ScrollView.
Small Screen Layout Magnet Solution Below are the magnets you needed to complete the custom small screen layout.
Below are the magnets you need to complete the custom small screen layout.
Just like the landscape mode, the small screen layout with the buttons in the ScrollView is going to be really similar to the original layout.
You just need to recreate the button bar inside the ScrollView.
You should have used the magnets below to complete the layout.
Here are the title and date TextViews as children to the ScrollView’s vertical LinearLayout.
Here are the image and description Views, also as children to the ScrollView’s vertical LinearLayout.
Inside the button LinearLayout is the same, both the refresh and set wallpaper button are added to the horizontal LinearLayout.
Now that you have the layout customized for small screens, run the app and make sure your layout changes worked.
When the app stars up, the buttons are hidden, but you can now see the entire image!
When you scroll ALL the way down, you’ll see the full button bar.
What about small screen landscape mode? You’ve put a lot of  effort now into customizing the app for landscape mode, and small screens.
All of  this because you really want to make the app the best on all of  these different devices! But so far, the issues you knew about were raised by your users.
But it’s your job as the Android expert to think ahead for your users and anticipate these layout changes.
With that in mind, take a closer look at the small screen device again.
You customized the main layout, the landscape layout and the small screen layout.
But what about small screen landscape mode? Turn the emulator into landscape mode (by pressing CTRL-F12) and see how it looks.
Wait, how did it figure out the landscape small screen layout?
How Android determines the best layout As you’re building and customizing your app for multiple screen sizes and configurations, you can end up with a lot of  different layouts in your project.
It’s important to understand which is getting loaded and why.
Here’s a look at how the four layouts scenarios have loaded their layouts.
Shawn can see the entire space picture without scrolling (which he’s thrilled about)
And if  he wants to see the description, refresh the app or set my wallpaper, he can always scroll down.
Awesome! The app looks way better on my small phone.
Remember, Shawn did point out one other item that should be fixed before posting the app on the Android Market.
He mentioned the app icon was the default icon and it would be a good idea to change it.
It will definitely make the app more polished looking to your users, so let’s do that now.
After some looking around on the web, you found some free pictures of  earth.
One in particular looked great for the home screen icon.
As you saw in Chapter 3, app images are stored in the res directory.
And the home screen icon is in there in a PNG called icon.png.
You found this image on the web and want to use it as the app icon.
The icon.png image under these directories are used as the home screen app icon.
How can three separate images control one app icon? That’s crazy!
There are multiple images just like there are multiple layouts.
You have to build different layouts to optimize for different screens.
Different images for different pixel densities Earlier in this chapter, the first small screen AVD you created looked weird because the pixel density was wrong.
Buttons and images were too big and everything looked really squished on the screen.
The same weird appearance problems would happen if  you use an image that’s too big or too small for a device’s pixel density.
Android solves this problem by breaking devices down into groups of  pixel densities (high, medium, and large) and allows you to include images for each group.
Then just like the layouts getting chosen at runtime, image resources are dynamically loaded based on the screen size the app is running on.
This device density grouping is brand new, so old versions of Android won’t support it..
This way, once the images are displayed on the device, they are all about the same size.
Real size is the whole reason for the pixel density groupings.
Let’s say for example that you only had the large 240 pixel width icon.
That’s why the first AVD that you created had suck big buttons and icons, when the pixel density was wrong.
These all render on the respective screens to be around the same size.
Android divides these up into manageable groups to make things easier.
But that’s not enough to make a consistent look and feel.
To solve this problem, Android has a published set of  guidelines that encourage standards.
One of  these standards is the image size of  the home screen icon.
The guidelines define pixel dimensions for launcher icons at each pixel density.
Q: Are there any other design requirements for the icons? A: The icon design guidelines list a number of other design attributes to use for your home icons.
Q: Wow, that sounds like a lot of different requirements.
The icon design guidelines page includes a number of different example icons you can use for reference.
Q: The design requirements for these icons look really complicated! Is it worth it to seek a professional designer’s help?
Apps are becoming much more graphics intensive and can often benefit form the help of a professional designer.
Home Icon Magnets Below are the density specific folders under the res directory.
There are magnets for the picture of earth icon resized for each pixel density.
Drag the home icons on the squares to the right of the folder they belong to.
Drag the appropriate home screen icon to each density specific directory.
This 72x72 pixel icon is for the high resolution devices and goes in the hdpi directory.
Home Icon Magnet Solution Below are the density specific folders under the res directory.
There are magnets for the picture of earth icon resized for each pixel density.
You should have dragged the home icons on the squares to the right of the folder they belong to.
This 48x48 pixel icon is for the medium resolution devices and goes in the mdpi directory.
This 36x36 pixel icon is for the low resolution devices and goes in the ldpi directory.
Test Drive Now that you have optimized icons for each pixel density, run the app in both AVDs and navigate to the home screen.
On the large screen high pixel density device, the 72x72 icon is used.
On the small screen medium pixel density device, the 48x48 icon is used.
Two screen sizes, two pixel densities and different image to make the images look appropriate on each.
It looks like the app is ready for the market After building the app, tweaking the layouts for screen sizes and orientations, and polishing it off  with the home icons, it’s ready for people to download and run in from the Market.
TODO: Maybe some mention of the market deploy here, or explicityly if we do a chapter 5.5 for deploying to the market...
You’ve done some great work optimizing your layouts for different devices.
Here are some additional directions to explore if you’re looking for more!
Make more AVDs You currently have one AVD for large screens and one for small.
Try creating a few more so you can test your small and large layouts against multiple different sized AVDs.
Watch your layout managers dynamically resize based on screen size!
Rearrange the screens for orientation changes You made a small change between orientations, moving the buttons to a better location.
But think of some extreme changes you could make that would benefit orientation differences.
Think about adding features or drastic layout differences between orientations.
Is it beneficial or a distraction? Also, think about how the Activity might need to change if you have functionality in one orientation but not another.
Create landscape layouts using the New Android XML file wizard and adding the landscape qualifier.
Create small, normal, and large screen layouts using the New Android XML file wizard and adding the landscape qualifier.
You can combine qualifiers and make layouts just for one size and orientation, like small and landscape.
Adjust the pixel density as you create new AVDs to test the correct resource loading.
You can edit AVDs after you create them to adjust screen size and pixel density.
But it’s still a good idea to have a few AVDs created with configurations for testing.
Replace icon.png with a custom icon for your app, noting the specific icon sizes for each pixel density.
What he doesn’t get is that the whole band working together is way cooler than him by himself!
That may actually be the cheesiest thing I’ve ever heard.
Bobby wants to run the NASA app on a tablet Bobby’s school is running an experiment and gave everyone in his class an Android tablet.
Naturally, the first thing Bobby wanted to do was check and see how his NASA Image of the Day app looks on his brand new tablet!
I’ve been having a TON of fun with the NASA Image of the Day app.
And now that I’ve got this new tablet, I can wait to see the NASA app running on it!
The app is already up on the market, so you can download it from any device...
The app loaded the landscape layout, since this is in landscape mode.
Android tablet users describe apps like this as being humongified!
Since they act like they are running on humongous phones!
The title is really small on this huge screen, the image is centered with too much blank space, and the text goes all the way across the screen.
It looks bad because we are running a layout that was designed for a phone and running it straight on a tablet.
What about all that blank space? Right now, the app has a lot of  blank space when it runs on a tablet.
Why don’t you fill up some of that free space by displaying NASA educational news?
Adding a second feed sounds like a great way to fill out the app! Since the school gave out tablets, all of  Bobby’s classmates have them now.
And they all want to run the NASA Daily Image app.
While they are looking at the daily image, a NASA feed displaying information specifically oriented around education sounds like a perfect fit.
So you’re not just adding stuff  to fill out the screen, you’re going to be adding additional useful content for your tablet users.
The NASA education news feed activity Kevin thinks this is such a good idea that he built the Activity for you to display the NASA Educational News feed.
You’ll be taking this code and the code you’ve written in earlier chapters to make these two Activities work together for a tablet app.
You’ll learn all about them and how to build and customize your own in the next chapter.
For this chapter, you can use the sample code you’ve downloaded.
The design of the image of the day section is mostly unchanged.
The design of the news list also remains vasically unchanged, just a vertical list of news items.
There are a number of  different ways to design the app to include both the daily image and educational news.
Here is one design that uses space well, and also keeps the news off  to the side as secondary information.
In order to be able to develop tablet specific Android functionality, you’ll need to update your development environment to use an Android platform 3.0 or above.
The code for the Nasa Image of  the Day and the Education News feed are in two different Activities.
These need to be combined into a single Activity to they can be displayed on the screen.
There are a number of  different ways to design the app to include both the daily image and educational news.
Here is one design that uses space well, and also keeps the news off  to the side as secondary information.
You’re going to be moving a lot of  code around to make both Activities display on the screen together.
As always, you’ll need to test your code and make sure nothing is broken (and fix it if  it is)!
Android is built to handle these differences by allowing you to install multiple platforms at once in your development environment.
To work with Tablet specific functionality, start by installing Android 3.0
Q: How come Android versions have a version number and an API number?
A: Since your app will be running on multiple Android versions simultaneously, the Android platforms are very specific about API changes.
And the version number isn’t enough to let you know what version the API is.
Q: How come there are separate versions for Android and Google platforms for each release?
A: The base Android platform versions include the core Android platform.
Google provides an extended version of each platform with additional APIs including maps and other cool add ons.
Setup a tablet AVD Now that you have a new Android platform version installed, you need to setup an Android Virtual Device (AVD) that uses it.
Then when you launch that AVD, you’ll be running an emulator with the latest version.
And in this case, we’ll want to setup tablet dimensions since we’re testing tablets.
Using a combination of version and size will help you quickly tell your AVDs apart.
You’ll notice it looks a lot different from Android 2.3.3
These three buttons are the back button, the home screen button, and the menu button respectfully.
This takes you to all the apps installed on the device.
Android will check where you want to run your app.
If  you have both Android emulators running and you run your app, you’ll be shown a dialog with the available devices.
You can then choose where you want to run the app from the list of  devices.
Run the app on the tablet AVD Now that the tablet AVD is running, you can run your app on that AVD as you normally would (using the play button or right clicking on the app in Eclipse and selecting run)
If you have multiple AVDs running or devices connected, you’ll get a dialog like this when you run your app.
Combine the activities Now that you have the app running in the tablet specific emulator, it’s time to start implementing the design changes to combine the activities on one screen.
The code for this screen is in the NasaEdNews Activity.
One way to make this work would be to combine both the Image of  the Day and the Education News Feed Activities into one single combined Activity.
First, you would be duplicating code since you want to be able to keep the Activities separate to run just one at a time on a small screen device.
On top of  that, right now the code for each function (the image and the news feed) is encapsulated in an Activity.
And it would be great to keep them that way.
You could make one combined Activity to display both Activities on one screen...
Wouldn't it be dreamy if you could combine multiple Activities in a single screen without having to combine them into one giant Activity.
Use fragments It’s a natural progression to add more features per screen once you move to the larger screen sizes of tablets.
But since Android devices take on so many different shapes and sizes, it’s important to remain flexible and be able to arbitrarily combine parts of  different screens.
But it’s equally important that the functionality for the screen part stay tightly coupled to the screen part that is rendered.
To solve these needs, Android introduced the idea of  screen fragments.
And the logic to drive each screen art is in a separate fragment.
The fragments can be configured to run on separate screens, one for each fragment.
Without rewriting your app from from scracth, you need to convert those Activities to fragments.
Here are the steps you’ll take to convert your existing app to use fragments without rewriting it from scratch.
This will allow you to combine them into a single screen.
Create a new Activity that will display the two fragments.2
Change the class declaration from extending Activity to extending Fragment.
You told me to extend Fragment and now I have all these errors.
But there are a few other changes you’ll need to make in your development environment and the Fragment itself  for everything to work seamlessly.
Set the android version for your project If  you hover over the line in the margin of  the Eclipse editor, you’ll see an error saying that class Fragment is not found.
Right now, you’re probably wondering how the Fragment class couldn’t be found if  you’re running the app on a tablet running Android 3.2!
And Fragment’s hadn’t been released in Android 2.3.3 so the class Fragment couldn’t be found.
Update the Android version building this project by going to Project Properties (right click on the project) and select Android.
Why do you still get errors? After you select OK, setting the Android platform version for your project, Eclipse will automatically rebuild your project using the new platform.
The Fragment class should be found now, but there are still many other errors to contend with.
The implementation of  the NasaIotd relied on several methods inherited by subclassing Activity.
But Fragment doesn’t extend Activity, and now NasaIotd extends Fragment not Activity, so those methods are out of  scope.
Instead, your app will still be launched by an Activity, and that Activity is going to assemble the Fragments to display on the screen.
But the Fragment can get a reference to the Activity that added it to a screen using the method getActivity.
This code will throw a compiler error This line is from the iotdParsed method and is getting a reference to the Title TextView using the findViewById method.
Here is the same line of  code modified to work in a Fragment.
This gives a reference to the Activity that launched the Fragment.
Calling getActivity returns a reference to the Activity that displayed the fragment.
Below is the iotdParsed method that is called when the parser completes parsing and the results are displayed on the screen.
Modify the code below to use getActivity() to retrieve the Activity and make this Fragment work correctly.
Below is the iotdParsed method that is called when the parser completes parsing and the results are displayed on the screen.
You should have modified the code below to use getActivity() to retrieve the Activity and make this Fragment work correctly.
All of the findViewById calls need to be preceded by getActivity.
Do this! Go through the Activity and look for other errors that can be fixed by calling getActivity before the method call not being found.
Update the lifecycle methods The lifecycle methods of  a Fragment are also a bit different than Activity.
One of  the major differences are lifecycle methods that allow code to execute when lifecycle methods happen on the associated Activity.
Another major change is in onCreate in your Activity, you configured the Activity and set the view.
With Fragments, onCreate is separated into two methods, with an additional method added called onCreateView which returns a View.
This allows the Activity to control the view generation and query the Fragment for their Views.
These methods are based on lifecyle events in the Activity.
You set the view in Activity onCreate, but for fragments these are separated out into onCreate and onCreateView.
Just like Activity, there are a number of  lifecycle methods you can override from the Fragment base class.
Verify the lifecycle methods The only lifecycle method overridden in NasaIotd is onCreate, which contains all of  the initialization and configuration for the Activity.
When migrating to Fragments, this code needs to split up since the lifecycle includes separate creation.
The handler creation and invoking the feed refresh can still happen in onCreate.
Setting the content view needs to change since Fragments need to return their view in onCreateView rather than setting the content view for the entire Activity.But the view creation has to happen separately.
Fragment has a special lifecycle method that returns the View for the Fragment called onCreateView.
But rather than returning an R constant for the View XML, you return an instantiated View.
Wait, how are you supposed to instantiate a View? I thought Android did that for you!
The setContentView method is a helper method that takes an R file constant and creates a View.
This works internally by looking up the XML layout defined by that constant, parsing the file, and creating and configuring each View specified in the layout.
This creation of real Views from layout XML is called inflation.
The LayoutInflater processes the layout XML file and instantiates the Views that are described in the XML file.
It sounds like a LayoutInflater will do the job, but where do you get the LayoutInflater? There are a few parameters passed in to the onCreateView method, and one of  them is a LayoutInflater.
And you can use it to inflate your View defined in the Fragment’s layout.
Inflating the layout The inflate method on LayoutInflater take the R constant of  the layout you want to inflate as an input parameter.
It also takes a root ViewGroup that helps the LayoutInflater configure the internal layout inflation.
The method also takes a boolean parameter indicating whether or not to attach the layout to the ViewGroup being passed in.
The R constant for the layout you want to inflate.
Indicating whether or not to attach the inflated view to the ViewGroup.
Complete the methods with the magnets below paying close attention to which code belongs in each method.
Not all of the magnets will be used, so you will have some left over.
Call the refresh method in here to be sure the view was created.
You should have completed the methods with the magnets below paying close attention to which code belongs in each method.
There is no need to call setContentView since onCreateView returns the view.
Refresh the feed in on start, this way, onCreateView will have already been called and the views will have been created.
Inflate the layout using the layout inflater passed in, and inflating the activity_main layout.
Convert NasaEdNews to a fragment You’re done converting the NasaIotd to a Fragment, but now you have to do the same updating to NasaEdNews.
They both need to be Fragments so you can add them to the screen.
Update your version of NasaEdNews to be a Fragment according to these changes.
Make the surrounding activity Now you’ve converted both Activities to Fragments, but you can’t launch a Fragment on it’s own.
You can combine the Fragments in an Activity and display the Activity...
Now you’ll make a new Activity, and render the Image of  the Day and Education News Fragments in that new Activity.
This is the new Activity you’ll create to display the fragments.
These are the two Fragments you just converted from Activities.
Create a new Activity called NasaApp.java in the source folder.
Create a new layout file, NasaApp.xml in the layout directory.
Built out a basic Activity You just created a class and a layout for the Activity, but they are both empty.
Start by building out NasaApp.java to extend Activity, and create an onCreate method to render the layout.
How come I was supposed to get rid of the setContentView methods from the NasaIotd.java and NasaEdNews.java, but add it here?
You just converted both NasaIotd.java and NasaEdNews.java to be Fragments instead of  Activities, and Fragments should use onCreateView which returns a View instead of setting the Content View.
You first modified the manifest file in Chapter 3 to add permissions to access the network.
The manifest file also includes a reference to the Activity to launch.
And since you’re changing the Activity to launch (from NasaIotd to NasaApp) you need to update the manifest.
Update the android:name attribute in the Activity to point to the new Activity you just created.
Update the android:name attribute in the Activity to .NasaApp from .NasaIotd since NasaApp is the new Activity.
Run the app now to verify everything is starts and renders the Activity.
This isn’t surprising since you are displaying a layot that has no Views.
The layout you just created in NasaApp.xml does not contain any Views yet.
Wait now, I don’t want a blank screen, I want to see both Fragments on the screen!
You created the new Activity and layout, but you haven’t populated it yet.
The fragments need to be displayed on the screen too.
Now that you have the completed Fragments and an Activity to display them, let’s see how to display the Fragments on screen.
Add the fragments to your layout Fragments can be added to a screen in the XML layout.
There is a special <fragment> element added to XML layouts after Fragments were introduced.
The fully qualified class name of your fragment goes here.
It’s a good idea to add an android:id attribute for your fragment.
This will allow you to retrieve and configure the fragment from your activity later on.
You can use regular layout attributes on a fragment just like any other View.
Q: You’re defining a fragment in the layout, but assigning View layout attributes.
You’re defining the fragment attribute and referencing the fragment class.
But the view is rendered to the screen, and view attribute control how the view is laid out.
Q: Do I have to do any other configuration to make the fragment load?
A: No, defining the fragment in the layout renders the view and instantiates the fragment class.
Q: Do I have to start the fragment or call any of the other lifecycle methods?
Q: Do I have to declare it in the layout? What if I want to programatically decide which Fragment to add?
A: You can add fragments programatically in addition to declaring them in the layout.
Add both the NasaIotd and the NasaEdNews Fragments to this layout.
Make sure to give the Fragments android:id attributes as you would for other Views.
You should have add both the NasaIotd and the NasaEdNews Fragments to this layout.
You should have added them to the current horizontal LinearLayout below.
You also should have given the Fragments android:id attributes as you would for other Views.
At this point, you should see both of  the fragments displaying on the screen.
This screen is just a big horizontal LinearLayout with two large Views...
Test it on a small screen Right now you’re testing the app on the default tablet size for the emulator, WXGA, which is a sizable 1280x800
But not all of your users’ devices are going to be that big, even tablets.
Let’s make a small Android Version 3.2 AVD to see how the app looks.
I think this screen is too small to display both fragments on the screen.
There are no firm rules about how many fragments you can display on the screen.
These two fragments take up a lot of space, so they don’t work well together on small screens.
But one way or another, you’ll need to fix this on small screens...
In Chapter 5, you build optimized layouts for small screen devices and landscape.
Using the same R constant, layouts are dynamically loaded based on their screen size category (small, med, large, and a recent addition, x-large)
Android 3.0 introduced the idea of  minimium screen widths and heights to determine the dynamic layout loading.
So instead of  declaring small, med, or large screen widths, you can declare screen widths in Density Independent Pixels (DPs)
The name of  the folder determines in the screen size the layout applied for.
And just like the screen group following the layout in the folder name, so does the screen size.
The difference is that the width or height is specificed with a w or h, followed by the dimension in DPs.
Screens larger then the specified width or height load the layouts in the folder.
This folder’s layouts will be loaded if the width is greater than 800dp.
For newer versions of  Android, either the old style screen groupings or the new minimum screen size approach will work.
However, older versions of  Android require the older style screen grouping approach.
The new and old screen grouping approaches can work together, and you’ll need to do that if  you plan on supporting older versoins and new versions of Android in the same app.
One large layout If  the screen is large enough, display both of  the fragments side by side.
Depending on your target devices and application content, this size might vary.
For the Nasa App, let’s define the minimum size as 800 pixels for side by side fragments.
This will be a new layout specifying screen sozes 800 pixels wide or above.
One small layout If  the app is less that 800 pixels, just display the Image of  the Day fragment and not the Education News.
Create the large screen layout Just like the landscape mode, newer versions of  the Android Eclipse Plugin allow you to configure the minimum layout width directly from the new Android XML File wizard.
Launch the wizard now and create the large screen optimized XML layout.
Head First: Thanks for taking time out of  your busy schedule of  laying out screens and determining which layouts to use to come and talk to us.
Head First: You know, I thought the small, normal, and large screen sizes which seemed a little hard to keep track of.
Then I learned about screen pixel density and seemed like a LOT to keep track of.
Back then I just had one system of  screen sizes to keep track of.
Now I have to keep track of  all of  that, plus the new system of defining widths directly in the folder name.
Head First: I honestly don’t know how you do it.
I just have an algorithm I follow to figure out which resource to use.
It’s not like I’m making random decisions myself or anything.
Head First: But don’t developers get frustrated trying to nail down the different resources?
But they get used to my algorithm and then they know what layouts to build for what screen sizes.
And they know which to override to make some device work the way they want.
Head First: I’m still shocked that this doesn’t confuse you, all of  these different layouts in the same app! It would drive me nuts!
Screen Support: If  you want to really go nuts, check out all of  the other overrides you can do for each layout in addition to size and pixel density.
Head First: You’re kidding, there’s even more? I had a hard enough time keeping up with this already!
Screen Support: Sure! You can also override layouts by input type.
Say for example you have an app with an on screen numeric keyboard for touch screens.
You can customize the layout for 12-key devices to remove the keyboard since they already have hardware buttons.
Head First: OK, this is just getting out of  hand.
Screen Support: And I’m not even done! You can also customize your layouts by locale.
Say for example, you’re working with a language that reads right to left instead of  left to right.
You can add customized layouts that reverse parts of  the screen for those languages.
Head First: Enough already! You lost me with the 12 key devices!
Screen Support: Like I said though, it’s a piece of cake.
As long as we both follow the same rules, there will be no nasty surprises!
Head First: I’m going to take your word for it.
Screen Support: Suit yourself ! Just remember, I’m here when you need me.
Screen Support Exposed This week’s interview: How do you keep it all straight?
Below are the layouts for the main.xml in both the the res/layout folder and the res/layout-w800dp folder.
Modify the main.xml in the layout folder to display just the NasaIotd fragment for small screen devices.
Below are the layouts for the main.xml in both the the res/layout folder and the res/layout-w800dp folder.
Modify the main.xml in the layout folder to display just the NasaIotd fragment for small screen devices.
The small screen layout in layout/main.xml should only contain the NasaIotd fragment.
The entire contents of layout/main.xml move to the large screeb layout.
Now that you have optimized layouts for small screen and large (over 800dp width) devices, run the app again and make sure it works on both devices.
Use the AVD selection dialog in Eclipse to run the app on both AVDs if  you are running them at the same time.
That looks great! Add more content only where it works.
Fragments made is all possible This is a perfect example of  customizing your app to render more or less content based on screen size.
And with fragments, it was easy to just add or remove content (and the functionality to support the content like the feed refreshing) just from your layouts without having to move a lot of  code around.
Test the app functionality Speaking of  functionality, this is a great time to test the app and make sure everything works.
You already know the feed is refreshing correctly, but what about scrolling and the on screen buttons?
Why is the app crashing? The feeds are loading correctly, and scrolling works.
But when you press the butons, the app is crashing.
Can you figure out what the error is referring to? Why might this error be occurring? How would you fix it?
Add onClick methods to the activity To make the buttons work, you added android:onClick attributes to the buttons and corresponding methods in the NasaIotd Activity.
So even though you have the corresponding onClick methods in NasaIotd, the Android action code is looking for the android:onClick methods in NasaApp.
The methods aren’t in the Activity, they are in the fragment.
Make the buttons work Both of  these methods are already implemented in NasaIotd, they just aren’t receiving the event since they are a Fragment not an Activity.
So all you really need to do is pass the event to the Fragment.
You can pass the event to the Fragment, but first you need to get a reference to the Fragment from the Activity so you can call the onClick methods in the Fragment.
The following code implements both of  the onClick methods, retrieves the FragmentManager and calls the underlying method in the Fragment.
These receive the expected onClick calls and pass them along to the underlying Fragment.
Now that you added the onClick methods to the NasaApp Activity, run the app again and see if  the force close is resolved.
No errors! Now check the home screen to see if the wallpaper was set.
This is just a fantastic app! Cool images, optimized for tablets in various sizes.
Brilliant work You’ve got the complete Nasa Image of  the Day app is working great.
The tablet app is running with Fragments so you can easily add and remove on screen content based on screen size.
That was some great work you did Fragments in this chapter, and all of the other work on the Nasa Image of the Day.
New Activities for Small Devices In this chapter, you only showed the Image of the Day fragment for small devices.
But the Education News can be interesting! After reading chapters 7-9 and learning more about creating additional Activites in your app, create a second Activity using the same two fragments.
Then you should be able to show both fragments in one Activity or one Fragment each in two different Activities.
After moving the buttons out of the Image fragment, make the refresh button refresh both Fragments.
Move the buttons The refresh and set wallpaper buttons look a bit cluttered in the fragment on screen.
Move them to a button bar, or as menu items (after you learn about them later in the book)
Explore Additional Overrides In addition to screen size and pixel density, you can customize layouts based on device hardware form factors.
Try building a custom layout for a specific form factor (like a device without touch screen support)
Test that your override works and doesn’t effect other form factors.
Call getActivity() before any Activity method you called in the Activity you’re converting.
Update onClicks and other mechanisms relying on direct access to an Activity.
Put layouts in folders by minimum screen width in DPs.
You can also use smallest width which combines the two.
Set the Android version for your project in Project Preferences.
Convert existing Activities to Fragments, or write new Fragments from scratch.
Override Fragment lifecycle methods as needed, specifically onCreate, onCreateView and onStart.
Return the Fragment view in onCreateView, don’t set the content view from a Fragment.
Then the layout is inflated, your fragment will be automatically created, started and connected to the launching Activity.
Where would we be without lists? They display read-only information, provide a way for users to select from large data sets, or even act as navigational device.
I sure am! It says right here on my list to bug you about it.
Donna jogs all the time, but she hasn’t raced before.
There is a big race coming up and she wants to be in super shape to get a great time.
Donna knows the only way to improve is to train consistently and track her progress over time, constantly improving any issues.
She wants to track her progress on her Android phone since she always has it with her.
But she doesn’t like any of  the apps she’s found.
I just want a simple app where I can enter my time and notes.
She’s found lots of  tracking apps, but they all use GPS, have subscriptions, or just make things too complicated.
Donna asked you to build the simple time tracker app for her, and as a good friend how could you say no!
Donna gave you this sketch for the time tracker app’s time list screen.
It’s a pretty simple screen with the list of times and notes, just like she said.
Needs to be able to scroll vertically once there are too many times to fit on the screen.
Emphasize the time in each row using a larger font, since the time is the most important piece of information.
De-emphasize the notes for each row by using a smaller font.
This way users can still see the notes there, but the times are more in forefront.
But which View should you use to implement this sketch?
Plan the implementation You have a pretty clear sketch of  the app to build, and now you need to decide how you’re going to implement it.
You could create a LinearLayout and add Views dynamically based on the items to be displayed and then put that LinearLayout in a ScrollView.
You can get a reference to a ViewGroup using findViewById.
Once you have the ViewGroup reference in code, you can programatically add Views to that ViewGroup at runtime.
This isn’t done in any of the book examples, but it can be really useful way to declare most of your layout in XML and add a bit of dynamic behavior.
While that would technically work, it seems a little less than ideal.
You’d be repeating the same layout over and over again in the list and you’d have to somehow synchronize the views on screen with the data stored in your Activity.
Wouldn’t it be dreamy if there were a built in way to manage lists of information.
Here’s an example of a ListView used in the About Phone screen from the Android settings.
Use ListView ListView is a built in Android View that displays items in a vertical list.
It has built in functionality for most of  what you’d want a list to do- like automatically scrolling when the screen is filled with data, as well as a clean way to separate your data displayed in the list from the ListView itself.
ListView isn’t just a View, it actually a complete ViewGroup on its own.
A ListView contains Views for each of  the rows, which are then added to a single ViewGroup and added to the ScrollView so the list can scroll.
The end result is that a ListView is a ViewGroup, not just a View.
Add a ListView to your screen Any ViewGroup (like a LinearLayout or the ScrollView, or even any View) can be added as the root element of  the layout.
And since you want to stretch the ListView fill the entire screen, the ListView is the one and only View you need in your layout.
Add it to the layout in main.xml as the root View and adjust the width and height to fill the screen.
Don’t forget to add the xmlns attribute since this is the root element of the layout.
The screen is empty, as nothing has been added yet.
This isn’t surprising since you added the ListView, but the the ListView has no data to display yet.
Lists are populated with data from adapters ListViews don’t actually contain any data themselves.
That’s why you didn’t see anything on the screen for the first Test Drive.
The ListView was in fact on the screen, but it was empty so the screen appeared empty.
You can populate your ListView’s with using an Android Adapter.
Adapter is an interface whose implementations provide data and the display of that data used by the ListView.
Communication methods The Adapter interface includes a number of  methods to communicate data to the ListView.
This includes methods to determine how many elements need to be displayed, and to retrieve specific items.
Adapters control the content displayed in the list as well as how to display it.
Android ListViews and Adapters are not clearly separated according to Model View Controller (MVC) lines.
With MVC, you completely separate the data (the Model in MVC) from the display (the View in MVC) with communication facilitated by the Controller.
However, Adapters perform Controller functions as well as some View and Model functions.
This isn’t a problem, and you can still properly organize and encapsulate your View and Model code.
Just be aware that you won’t always have the clear MVC separation you have in some other UI frameworks.
Control methods The Adapter interface also includes methods that control the display of  that data like getView() that creates and populates a View that is displayed in the ListView.
Build your own Adapter You can populate your list with data by building your own Adapter.
Adapter is an interface and you can implement your own from scratch.
Buy why build your own Adapter completely from scratch when there is a much easier way to go! Android provides an Abstract class called BaseAdapter that has most of  the Adapter methods already implemented for you.
Start by creating a new class in your project called TimeTrackerAdapter and make it extend BaseAdapter.
Q: Do I have to use BaseAdapter? A: No, you can write your own Adapter implementation from scratch if you choose.
Q: When would I want to do that? A: There are a number of different reasons you may want to write your own.
BaseAdapter handles a lot of the Adapter implementation for you, but if you want something custom or extremely optimized for your app, you may need to write your own.
Q: Is there any downside to writing my own Adapter? A: Writing your own Adapter is completely fine.
But it does take some work to rebuild what you get for free with BaseAdapter.
Plus, if you use BaseAdapter, the BaseAdapter implementation could be improved pver time.
And if it is improved, you’ll get that benefit for free too.
Q: So is it a good idea to use BaseAdapter? A: For the most part, use BaseAdapter unless you have a good reason NOT to.
There are three data related methods you need to implement in BaseAdapter subclasses.
There is just one view mthod you have to implement in BaseAdapter subclasses...
Based on the app design, you’ll need to store a time and note for each time entered.
Rather than separately storing that information, create a data object to store both fields in a single object.
Now that you have the data object for a single time record, add an ArrayList to store these data objects in your Adapter.
Now that you have the ArrayList of  your data objects, you can finish implementing the Adapter based on the data stored in the ArrayList.
Now you have a BaseAdapter implementation, but it still doesn’t store any data for your list.
It’s just filled with autogenerated methods that will compiles, but don’t do anything useful yet.
Here’s what you;re going to do to make this adapter work for you!
Create a data object called TimeRecord to store information for a specific time entered.
Complete the methods using the new list of data objects.
Since it’s an object storing all of  the information for a specific time, call it TimeRecord.
It should have two variables, one for the time and one for the notes.
Below is the TimeTrackerAdapter code with the autogenerated methods Eclipse created when you implemented the BaseAdapter methods.
Using the TimeRecord data object, complete the data methods getCount,and getItem (getItemId is done for you)
You’ll also need to create a collection to store these objects.
This just needs to return a unique ID for the data.
And since the index ID is unique for a row, standard practice is just to return the index.
Add a collection to store TimeRecords as a member variable.
Most user interface frameworks are pretty serious about very clear Model View Controller (MVC) separation, but not you.
Head First: Aren’t you afraid the Design Pattern Police are going to come after you?
Adapter: One step ahead of  you! I was worried people would start clamoring about how I’m not pure MVC and all that, so I changed my name.
I’m not a Model, Controller, View, or any combination of  them.
Do you find it confusing to have all of  that logic for data and views in your implementations?
Most of  the time, the data I’m storing is directly related to me and why I’m on a screen in the first place.
Maybe I’m displaying a list of  States for selection in an Address entry process or maybe I’m displaying read only data like the times in the TimeTracker app.
I can also be used as a navigation device with nested menus.
Most of  the time my data storage is pretty minimal and directly related to displaying it.
Adapter: Absolutely! If  I’m displaying a huge list of information that’s stored elsewhere (say in a database on the phone) I don’t want to bloat myself  by storing that data inside me AND in the database.
Adapter: Well, there is nothing saying I have to store the data in me! I just have to facilitate providing that data to the ListView.
I could easily lop off  a piece of myself  and turn that into a pure data source.
As long as I have a reference to that new data source, I can ask it anything that the ListView asks me- how many rows, the data for a row and so on.
Head First: I like the fact that you can still separate out your data and provide it to the ListView.
Adapter, the renegade MVC recluse, with the ability to control it’s own data and display.
Below is the TimeTrackerAdapter code with the autogenerated methods Eclipse created when you implemented the BaseAdapter methods.
Using the TimeRecord data object, you should have completed the data methods getCount,and getItem (getItemId is done for you)
You also should have created a collection to store these objects.
A private ArrayList containing one TimeRecord for each row in the ListView.
Since there is one TimeRecord for each row, the size of the ListView is just the number of TimeRecords in the ArrayList.
Again, the one-to-one mapping keeps everything easy! The data for a row at the index is the TimeRecord in the ArrayList at that same index.
The data methods are complete now, but what about getView? The getView is the link between the data stored in the Adapter and how it’s displayed in the ListView.
In the getView implementation, you’ll retrieve the data for the row from the ArrayList, populate a view with that data and return the populated view.
This corresponds to the indeces in the array list of TimeRecords.
What view is going to be used here? Don’t you have to customize one for time tracker data?
You’ll need to create a custom view You’re storing custom data for you app in the Adapter.
That’s why you had to subclass BaseAdapter and create your own implementation.
Just like storing your custom data, you also need to create your own custom views to display your data.
Before you can wire up the View to the TimeRecord in getView, you need to design it! Here is a sketch of the layout for one row in the ListView.
The widths are all set to FILL_PARENT so they are as wide as possible.
The heights are set to WRAP_CONTENT so they can resize based on contents.
Q: How come all of the View height are set to wrap_content?
A: First of all, if you set the height to fill_parent, it will fill the whole list! That’s very bad! Likewise, setting the height to a fixed size would be a poor choice.
The time is fixed in length to one line, but the notes could be several lines.
Q: We’re making a new layout here, can you have more than one layout per screen?
Up to now, you’ve had exactly one layout for each Activity (which maps to a screen)
It doesn’t have to be that way! You can have as many (or as few) layouts per screen as you like.
Q: That sounds kind of cool, when would I want to use a lot of layouts?
A: Well, custom ListView rows are obviously one example but there are more.
There is a really cool technique where you can use the <include> directive in one of your layouts.
That takes another layout that you’re including and adds it inline making a big combined layout.
It’s a really useful way to organize and encapsulate complicated layouts.
We don’t have time to go over it in this book, but it’s definitely something worth checking out in the online Android documentation.
Instantiate the View The first time getView is called on your Adapter, the View passed in is null.
Since the Adapter knows how the data should be displayed, it’s up to the Adapter to instantiate the View the first time.
Successive calls to getView return the same View back to be repopulated with new data.
Repopulating the same View instead of  creating new Views for every cell is a performance optimization often used in user interface frameworks.
The getView method does some serious heavy lifting for the Adapter.
It’s really the method that bridges the gap between the data and the display.
Not surprisingly, there are a few basic tasks you’ll need to accomplish inside every getView implementation.
You’ll need to correlate the index passed in to the ArrayList of TimeRecords.
For this adapter, you have an correlated indices between the ListView and the TimeRecords in the ArrayList.
Set values on the view Using the selected TimeRecord, and the View, set properties on the view to reflect the data.
In this case, you’ll be setting text in the view to display the time and the notes from a TimeRecord.
The /res/layout folder will auto-populate when you select Layout as the resource type.
LinearLayout will default as the root layout for the new layout XML file.
Keep this selected since you’ll use LinearLayout for your cell layout.
Modify the layout to match the design you created for the list cell.
You should have modified the layout to match the design you created for the list cell.
Set the height to wrap_content so it won’t fill up the whole list.
Make the width as wide as possible but size the height to the content.
Make the width as wide as possible but size the height to the content.
Add some padding on the bottom so there is some space between the time and the notes.
It also has an ID for access later from findViewById.
Topic Title Magnets Now that you’ve completed the View, you have everything you need to write the getView method.
First you’ll need to check and make sure the View is not null, and if it is null, you’ll need to inflate it.
Once you’ve retrieved it, you need to populate the view with the information from that TimeRecord.
The TimeRecord in the ArrayList at the index has everything you need to populate the view.
For the time, get a reference to the time TextView and set the text to the time String from the TimeRecord.
Get a reference to the notes TextView and set the text to the notes String in the TimeRecord.
Topic Title Magnets Solution With the View completed, you had everything you needed to write the getView method.
First you should have checked that the View is not null, and if it is null, you should have inflated it.
Once retrieved, you should have populated the view with the information from that TimeRecord, completing the code with the magnets.
If it is, retrieve the layout inflater and inflate the view.
Connect the adapter to the ListView The Adapter is finished now, and the next step is to use the Adapter in the ListView.
To set the Adapter on the ListView, you’ll get a reference to the ListView using findViewById and call the setAdapter method passing in an instantiated TimeTrackerAdapter.
Start by adding an android:id to the ListView in the layout.
Now get a reference to the ListView in onCreate, instantiate the TimeTrackerAdapter and configure the ListView to use it.
Add test code to the adapter You custom Adapter implementation is now complete and being used in the ListView.
You’ve built the TimeRecords data object to hold times entered, and built the Adapter around an ArrayList of TimeRecords.
Create a few prepopulated TimeRecord objects to see in the ListView.
Now that the TimeTrackerAdapter is complete, connected to ListView and populated with test data, run the app again and make sure it all worked!
The cells look great too! The time is in a bigger font and the notes are in a small font.
And there’s a bit of space in between so things aren’t too crowded in the cells.
Next up, user entered times In this chapter, you created the new project, added a list,build your own adapter, custom views, and connected it all together.
In the next chapter, you’ll be adding a second screen to this app, so your users can enter their own times.
With all of this work wrapped on Adapter, you’re ready to move on with this app.
If you’re still wanting to learn more about Adapter and their Views, here are a couple of places to look.
Prebuilt List Views Although you built this list item view from scratch, sometimes you can use prebuilt views.
Built in Adapters Take a look at these built in Adapters for your apps.
ArrayAdapter: Adapter with everything implemented for you, just pass in an array!
SimpleAdapter: Adapter that uses data stored in XML resources to build the list.
CursorAdapter: An adapter that uses information stored in a SQLite database (you’ll learn more about these in a few chapters)
When working on a multi-screened app, always start with your post important use case.
Talk to your users to find out what they are.
If you build an Adapters that stores data, build your own data object to keep your data organized.
Implement Adapter by subclassing BaseAdapter, writing your own, or using a prebuilt Adapter.
Create an list item View or use a built in View.
Now that you created an Adapter and list item View.
In this chapter, you’ll learn how to build an app with.
You’ll learn how to navigate between screens and even pass data between.
You’ll also learn how to make your own Android context men- the menu that pops up.
Donna wants to enter her times Donna thinks the app is looking great, and she’s really looking forward to using it.
Think you can let me enter times when I get back?
Let’s get right on it! The only thing stopping Donna from using her perfect new time tracking app is that she can’t enter her own times yet.
Let’s build that now so she can get started tracking her times for her big race!
How is she going to add her own times? The list is displaying times, and you need to make a way to add times with notes inside the app.
You could combine it all into one screen and have an entry section at the bottom, but that would get cluttered very quickly.
The best way to do this is to add another screen specially designed for entering data.
Here’s a quick sketch of  what the new screen will look like.
It’s always a good idea to give your users an obvious way to get out of the action they are in.
An obvious action button to save the newly entered information (that will take users back to the list view)
This is an editable text area where the user will enter their time.
This is another editable text area where the user will enter free form notes about the time.
Adding the entry screen There are a few steps you’ll need to take to make the new entry screen and connect it to the list screen.
The new screen is sketched out, but you’ll have to build it.
You’ll be making a new XML layout and a brand new Activity for the screen.
The list screen is the main screen for this app and this is the screen that displays when you launch the app.
You’ll add an menu with an ‘Add’ menu item to this screen that will launch the entry screen.
You’ll build a new screen and an Activity to display it.
Click! Users can launch a time entry screen from the main time list screen.
Whether the user enters a new time or cancels out of  the entry screen, they need to return the list screen when they are done.
After writing the code to navigate to the entry screen, you’ll write the code to return back to the list screen with the user entered data.
This is where it all comes together! After building the navigation back and forth from the entry screen, you’ll implement logic to store the newly entered time and display it in the list.
Make sure not to slow down in the second half.
The newly entered time information is sent back to the list.
The newly entered time information gets added to the list.
Create the new layout xml file Launch the New Android XML File wizard and create a new layout.
This will have “Time” label, the text entry field to enter the time, followed by the.
At the bottom of the screen, you’ll have a horizontal LineatLayout with the save and cancel buttons centered.
Root vertical LinearLayout with the time and notes labels and entry fields.
The notes entry field should stretch vertically to fill the screen.
The bottom of the screen should be a horizontal LinearLayout with save and cancel buttons centered.
Use EditText for text entry This is the first time you’re adding a text entry component to one of  your screens.
All of  the other Views you’ve added to your screens have been read only.
But now you’re having users enter information, so they need an entry View.
There is a special text entry View called EditText that you can use.
From a layout perspective, just remember to give the EditText an ID so you can retrieve the View and it’s contents later on.
Do I have to use it to make new layout XML files?
The wizard is just creating the XML file and adding it to correct directory based on the XML type.
It also tries to add a little structure based on your XML file type like adding the root element of a LinearLayout if your making a layout file that you’ve declared in the wizard to be a LinearLayout.
Q: After all that time customizing layouts for different screens in the NASA app, how come we’re only adding one layout for this screen?
A: Just like the NASA app, you would want to test this app on multiple devices of various screen sizes and customize the layouts as necessary for your supported device.
Root vertical LinearLayout with the time and notes labels and entry fields.
You can apply View layout attributes to an EditText just like other Views.
Below are magnets with the XML layout declarations for the Views in your layout.
There is one main layout and one sublayout for the button bar similar to the one you made for the NASA Daily Image app.
Below are magnets with the XML layout declarations for the Views in your layout.
You should have arrange the magnets to complete the layout XML.
There is one main layout and one sublayout for the button bar similar to the one you made for the NASA Daily Image app.
This is the layout root, a vertically oriented LinearLayout for the screen.
It nas a gray background and the gravity is set to center_horizontal so the buttons will be centered.
The save and cancel buttons which both have onClick properties defined.
Now that you have the layout built for the entry screen, you need to display it in the app.
So far, you’ve displayed a layout when an Activity is created, you’ve created optimized layouts that dynamically display for different screen sizes, and displayed layouts as part of  a fragment.
But now you’re making an entirely new screen with new behavior.
Start creating a new Activity by adding a Java class called AddTimeActivity to your project that extends Activity.
Do I really need another one? A: In this case, yes.
You could have displayed the new layout in the TimeTracker Activity, but that Activity has functionality specific to the list screen, like finding the list view in the layout and setting the adapter.
If you just tried to display the entry layout in the TimeTracker Activity, the Activity would break when trying to find the list.
Q: When would be a good example of when I would have multiple layouts in one Activity?
The key is that the functionality and behavior were the same.
In the NASA app, once you had different behavior for the NasaEdNews, you had a second Activity.
Below is the code for the AddTimeActivity class you just created.
You’ll need to override onCreate and set the content view to your new layout.
In that method, write the code to display the layout for the add task screen.
Below is the code for the AddTimeActivity class you just created.
You should have complete the code below to display the screen.
You should have overrided onCreate and set the content view to your new layout.
Call setContentView with the R constant for the layout you just wrote to set the screen.
The Activity base class has logic needed to properly instantiate and configure an Activity for use by the Operating System.
If you don’t you’ll get a nasty runtime exception and your activity won’t run!
This looks good, but something tells me I should keep jogging and come back later.
There’s work left to do, but you’re getting there! So far, you’ve built the layout for the new ttime entry screen and the Activity to control the screen’s behavior.
Now it’s time to navigate to the new entry screen from the list.
Think about different Android apps you’ve used and how you navigate around them.
How would you build the navigation to the Add Time screen in this app? Write your answer below.
Use an Option Menu With the layout built and a new Activity created for the Time Entry screen, it’s time to navigate to it.
There are a few different ways you could implement the navigation including putting a button on the screen or using an options menu.
The options menu is the popup that displays when you press the Menu button on an Android device (or the on screen menu button on a tablet)
The options in the menu are controlled by the Activity in focus when the menu button is pressed.
Let’s add an options menu item to launch the time entry screen.
The list screen remains unchanged when the menu is not open...
Create the menu XML file Menus are defined in XML just like layouts and many other Android resources.
Just like layouts, you can create new menu XML files using the New Android XML File wizard.
Only this time instead of  selecting layout options, select menu options.
The /res/menu folder will auto-populate when you select Menu as the resource type.
The dropdown iwill be disabled since menu is the only possible root element for a menu resource.
Add a menu option The menu you just created with the wizard will be in your project under the res/menu directory.
Navigate to that directory in the Eclipse Package Explorer open it.
Just like the graphical layout editor, there is a graphical editor for creating menus.
Start by clicking add to add a new menu item.
Now you can configure the new menu item by setting the title and ID.
Show the menu Just like XML layouts, the menu is defined in XML, but you need to display it from your Activity.
The default implementation does nothing, but you can override it and display your custom menu.
Inflate the menu you defined in time_list_menu passing in the R file reference for the menu  description.
The MenuInflater takes a menu defined in XML and creates men items.
Run the app, and press the menu button when the time list appears on screen.
You should see the menu display with one single item “Add”
This method will be called for every menu item you add.
It’s a good habit to test which item was selected by comparing it to the id you assigned.
You can add your code to process the menu item inside the if  block testing for your menu item.
Now you have two independent Activities, and a menu item with an action that can move from one to the other.
Now turn the page to see how to launch new screens.
Use Intents to launch new screens You can launch new screen using an abstract object representation of  an action called an Intent.
You can create an Intent when the Add menu item is selected pointing to the AddTime Activity.
Then you can call a utility method on the current Activity called startActivity passing the Intent.
This starts a new Activity in your app, managing all of the lifecycle methods for you including stopping the old Activity as well as creating and startng the new Activity.
Launching a new Activity Magnets Below is the empty onMenuItemSelected method in the TimeTracker Activity.
Complete the method by creating and invoking an Intent to launch the AddTime Activity Even though you only have one menu item right now, check and make sure that the ID of the menu item passed in to onMenuItemSelected is the add action.
Pass the onMenuItemSelected call to super if you don’t process the action.
You should have completed the method by creating and invoking an Intent to launch the AddTime Activity Even though you only have one menu item right now, you should have checked and made sure that the ID of the menu item passed in to onMenuItemSelected is the add action.
You should have also passed the onMenuItemSelected call to super if you don’t process the action.
Check the item ID to see if the add action was selected.
Create and new intent to select AddTimeActivity and then start it.
Pass the call on to super for any menu items that may be in the menu.
When you created your app with the wizard, it created the Activity for you and added an Activity element in the Android Manifest file.
Before you test the app, add the new Activity declaration to your manifest file or you’ll get a nasty exception!
This configures the application to be launched from the home screen.
The android:name points to the Activity class, by appending the package name to the android:name.
The package name is appended to the android:name, so you just need to enter the class name here.which will give you the fully qualified class name for the AddTimeActivity.
You’ve got the new screen built, the Intent starting the new Activity from the menu and the new Activity configured in the Manifest.
Go ahead and run the app and test out all your hard work!
Click in these fields and you’ll see the on screen keyboard automatically popup.
Back Stack Up Close As you test the app, you’ll pretty quickly realize that the save and cancel buttons don’t work.
But even without implementing these buttons you’re not stranded on the new screen.
Press the back button and you’ll go back to the list screen automatically.
Press the back button and you’ll go back to the list screen.
Android maintains a stack of  Activities your app has started, beginning with the first Activity in your app.
As you start new Activites like you did with the time entry screen, it’s automatically added to the back stack of  Activities.
And when you press the back button, it automatically goes back to the previous Activity in the stack which in this case is the list screen.
The back stack and the back button do allow one way to navigate back to the list screen from the time entry screen, but it’s not the behavior you’re looking for.
You have the Save and Cancel buttons on screen, and you need to make them work.
It layout declaration for the button specifies an onClick method called onCancel.
You could follow the same pattern you used to launch the time entry screen and create a new Intent pointing to the TimeTracker Activity and starting that Intent.
The cancel button’s onClick parameter is configured to call a method called onCancel.
Every time you start an Activity, Android automatically adds it to the back stack.
If  you always start Activities to navigate between different screens, you’re going to end up having a huge back stack!
TimeTracker is automatically displayed and pressing back button from here will exit the app.
There are a few different ways to control the back stack.
One technique you can use is to call finish on the current Activity to end it.
This will remove it from the back stack and automatically navigate to the previous screen in the stack.
When the app starts, the screen stack only contains the TimeTracker Activity.
When a user presses the Add item, the AddTime Activity is started, adding it to the screen stack.
Cancel starting another instance of the TimeTracker Activity adds it to the screen stack a second time.
If  you implement onCancel using finish, you’ll remove the intent and the startActivity call and replace it with a call to finish.
This will stop the AddTime Activity, remove it from the stack and return the user to the list screen.
What about the save button? This implementation will work for the Cancel button, but what about the Save button? The Cancel button just needs to return to the list view, but the Save button needs to return to the list view and return the user entered data.
TimeTracker is automatically displayed and pressing back button from here will exit the app.
Wouldn't it be dreamy if you could handle the save and cancel button the same way, just returning data when you save? But I know it's just a fantasy…
And when the new Activity is finished, a method  called onActivityResult is invoked on the calling Activity with the resulting data.
The request code is used to link responses to requests.
This request code is passed back in to the calling Activity when onActivityResult is called so the you can correlate the responses to the screens you’ve started.
Implement onSave The Cancel flow looks great, so let’s move on to the Save flow.
You’ll start by implementing the onSave method invoked by the Save button when clicked.
Add the user entered values for time and notes into the calling intent.
You’ll need to retrieve reference to both EditTexts as well as the Intent.
Then use Intent’s putExtra method to add values to the Intent’s Map so that you can retrieve them later from the TimeTracker Activity.
Finally set the result of the Intent to RESULT_OK which you’ll use in the onActivityResult method to determine whether the Save or Cancel button was pressed.
You should have used the magnets below to complete the method.
You should have retrieved references to both EditTexts as well as the Intent.
Then using the Intent’s putExtra method, you should have added values to the Intent’s Map so that you can retrieve them later from the TimeTracker Activity.
Finally you should have set the result of the Intent to RESULT_OK which you’ll use in the onActivityResult method to determine whether the Save or Cancel button was pressed.
Calling getIntent() retrieves the starting intent from a running Activity.
Get a reference to the time EditText, and put its value in the intent using the string constant.
Get a reference to the notes EditText, and put its value in the intent using the string constant.
Set the result to OK and pass in the intent.
Implementing onActivityResult You’ve completed the onSave method, which packages up the user entered data in the calling intent.
It also calls finish on its Activity which pops that Activity off  the stack and returns to the TimeTracker Activity, calling its onActivityResult method.
Finish gets called, completing the Activity and removing itself from the stack.
Then onActivityResult gets called in TimeTracker with the Intent containing the result data.
In the TimeTracker onActivityResult method, you’ll retrieve the values from the Activity using the getStringExtra method, using the map keys used to add the values.
Then you’ll create a new TimeRecord object with the values and add it to the ListAdapter.
Create a new TimeRecord object with the data from the result intent.
Pool Puzzle Your job is to take the code fragments.
You may not use the same code fragment more than once.
Your goal is to make a new item display in the list..
Note: each thing from the pool can only be used once!
This check makes sure the requestCode is the code you passed in.
Since you didn’t set the result code in the onCancel, this will return instead of trying to add a new item.
Head First: Hi Intent, thanks for speaking with us tonight.
Intent: Happy to be here, try and tell my story a little bit, you know.
Head First: Wow, your story? Sounds like you have something on your mind.
I just don’t get a lot of  respect around here.
I mean, I can do an awful lot! I help start Activities, I let everyone know where to go, and I can store and communicate data myself as I move around the system.
But it sounds like you’re not too happy about it.
Intent: I feel bad coming here and complaining, but I just never get to see the spotlight you know? Activities get to interact with users! I just have to hang out in the background while they get to shine on the screen.
Head First: It must be awful for you to just sit there while the Activities are out there displaying themselves to users, getting their buttons pressed...
Intent: Hey! You don’t have to rub my face in it, Okay?
Head First: No, I’m telling you that you are really important.
You may be sitting in the background while the Activity is displayed, but you have to keep track of  really important information.You know how the Activity was launched, and you include any information passed in to the Activity.
Head First: And as you’re sitting there in the background while the Activity is displaying, you get asked for your information and new information gets passed to you.
Head First: I think you need to change your mindset.
Give Intent a big round of  applause before going back into the background and we forget about it!
Pool Puzzle Solution Your job is to take the code fragments.
You may not use the same code fragment more than once.
Your goal is to make a new item display in the list.
Note: each thing from the pool can only be used once!
Create a new TimeRecord and add it to the list adapter.
This method lets the list know the data has changed and to update the display.
Everything is all wired up! Run the app and run through the complete flow of  adding a new time.
Invoke the Add menu item, enter a time and some notes, and press  save.
And you’ll see a new item added to the list!
Press the menu button and select the Add menu item.
You just did some seriously heavy lifting to get data entry working.
Can’t get enough? Here are some more features you could implement to make the app even better!
Build edit and delete In this chapter, you built a mechanism to add items to the list..
But what if a user enters the wrong information? Allowing users to add information is great, but your users will eventually want to be able to edit and delete as well.
Try building another screen, like an about screen, that displays but doesn’t return data to the calling Activity.
Think about whether you want that Activity to be in the back stack and build it accordingly.
Create a new Activity and configure it to use a new Layout.
Create a menu XML file from the new XML file wizard.
Add menu items using the graphical editor, or edit the raw XML.
Create new Layouts using the new XML file wizard, or by creating the XML files yourself.
Reuse Activities with different layouts if the behavior is the same.
To launch a new Activity in your app, create an Intent and pass it to startActivity.
Implement onActivityResult to receive the data returned from the screen.
Call finish to complete a screen and automatically display the previous screen on the back stack.
And don’t worry, even if you’re brand new to SQL, you’ll.
But the app is useless if I can’t save times!
It’s a straightforward app where she can enter her times and notes.
And just like she wanted, it’s free of  clutter from features she won’t use.
When she closed the app and later reopened it, all of  her times were gone!
This is because newly entered times are stored in memory as objects inside the TimeTrackerAdapter.
And once you shut down the app, the in memory data is gone!
Android comes standard with a built in SQLite database implementation.
SQLite is a lightweight SQL database implementation that stores data to a text file on the device.
If  you store the times in the SQLite Database and read them back in after you restart the app, you’ll have persistent data.
The Adapter for your list is storing all the data in memory.
Persist the list data in the SQLite database and display the data from the database and you’l have persistent data storage.
You’ll be storing the time and note data in a SQLite database.
But before you can store data in the database, you have to create it.
You’ll have to touch several parts of  the app to get database storage fully integrated.
Let’s take a look at what you’ll be doing in the chapter to seamlessly persist data.
Once the database is created, you can save times in it.
Here you’ll define the database schema based on the data you’ll be saving.
Then add the code to insert records directly into the database.
It’s no fun to store data if  you can’t access it.
Here you’ll write the code to query the database and process the results.
The goal is not to save and load data from a database in isolation.
The goal is integrate database persistence in the existing app.
With store and retrieval working, you’ll finish up by integrating all of  your hard work back into the TimeTracker app.
You can create and open databases directly inside your app.
The best way to get off  the ground with a new database is to extend a built in abstract base class called SQLiteOpenHelper that provides you with all of  the basic behavior to manage a database.
There are three methods you’ll need to implement that descrive how to connect to your database, initially create tables, and upgrade from previous versions.
Pass the database name and the database version to super.
Instantiate the OpenHelper The database is created internally by the Open Helper when it is instantiated.
Instantiating your custom open helper will cause the database to be created.
Q: Do I have to call a method on the OpenHelper to create the database?
When you instantiate the OpenHelper, it automatically creates the database for you.
If you’re ever curious about what’s in the database, you can always open it up in SQLite databse browser and look at its contents.
Browse to the database file After running the app with the Open Helper being created, you won’t notice any visual differences.
When you instantiated the Open Helper, the database file was created and saved to your applications persistent storage.
This will allow you to save the entire database file locally and view it.
Here is a screenshot of  the sqlitebrowser (http://sourceforge.net/projects/ sqlitebrowser/) displaying the contents of  the database.
Right now the database is empty, it just includes some default metadata.
The ID field is the primary key for the database.
You now have the database being created with the open helper.
Now look at what you need to store and how to structure the database to store that information.
The data for this app are already stores in the TimeTrackerAdapter in a list of TimeRecord objects.
Now you need to store that same information in the database.
You can store this by creating a single table called timerecords with a column for time and notes.
The file’s name is controlled by the database name string you passed into the constructor of the SQLiteOpenHelper.
Q: How much SQL do I need to know for developing Android apps?
Some apps just set up a very basic database and display its contents.
Others do very complex things with their database, like very detailed queries using  very intricate database schemas.
We won’t go into a lot of detail about the SQL part of SQLite in this book.
If you’d like to know more, we can suggest you read Head First SQL.
Create the initial table The database design includes the one timerecords table that you’ll need to create when the database is created.
Now that you know what the database should look like, you need to include the code to create that creates the initial table.
Our very biased suggestion on where to learn more about SQL.
If  you run the app again, you still won’t see any visual or functional change in the app.
A SQLiteDatabase instance is passed in which is an Object wrapper around the SQLite Database.
Pass in the SQL statament to create the timerecords table.
Exactly why did the database not change? I’m not going to get very far with databases if I change the code and nothing happens.
It’s because the database is persistent The SQLiteOpenHelper is helper class for creating and managing the SQLite database, which you’ve seen is stored in a file for persistence.
This way, data stored in the file will be available after the app process is exited and restarted.
But the code that was just updated was for onCreate which only gets called when the database is created.
The database doesn’t get created each time your app runs though, only the very first time.
Implement onUpgrade At this point you have a database you need to update.
You need to add the timerecords table to the original empty database.
This pattern of  updating a database’s schema is common so the open helper provides a mechanism for it.
If  the version number changes, onUpgrade is called for you to update the database as needed.
You just need to drop the database and recreate it.
Drop the tables if they exist and then call onCreate.
Now that you’ve updated onCreate, updated the version number and implemented the onUpgrade method, it’s time to test this out.
Run the app again and inspect the sqlite file in a viewer.
The onUpdade method will only get called if the version number.is updated.
If you update your database schema, make sure to update the version number or the database will not get updated to the latest version.
Using the database in your app The OpenHelper isn’t a database itself.
But it does create the database for you, and gives you access to it.
You don’t have to manually create the database, that’s done for you when you instantiate the OpenHelper.
But you do need to call one of  the getDatabase method to retrieve a reference to the SQLiteDatabase object.
Once you have the SQLiteDatabase, you can call any of the methods to insert, delete, execute raw SQL statements, and more.
But first, you need to get a reference to the database from the OpenHelper.
Use the SQLiteDatabase instance returned to interact with the database.
I know it’s hard to time away from your server to join us here tonight.
SQLiteDatabase: Thanks! But you know, I don’t have a server, that’s just soooo old school.
I refuse to be downtrodden by the shackles of  a server...
You can just drop my library anywhere, and without any configuration, setup, additional processes or weird data storage, you have a perfectly functional SQL database.
Head First: Seriously? If  you don’t have your own process, where do you run?
Head First: Cool! And where do you store your data?
SQLiteDatabase: On the regular file system in a plain old file.
Head First: Between running as a configureless library and storing your data in a plain file, is your functionality limited?
I can do multiple tables, triggers, indeces and all kinds of  fancy stuff  like that in my one little file.
But when apps need me to be super small, I have a special diet I can go on and drop down to under 200k.
Head First: Stop, you’re killing me! How do you fit that all in there?
SQLiteDatabase: A lot of  folks use me, and they care a lot about making sure I’m super optimized.
You can see all of  the folks there that make me happen.
Head First: That’s amazing! Tell me a bit about your object representation on Android.
SQLiteDatabase: Well, as you can guess, I run inside an Android app’s process when I’m used.
So the Android engineers built be a nice Object wrapper called SQLiteDatabase.
Once you get an instance of  me and my wrapper, you’ve got a fully functional SQLiteDatabase at your disposal.
The power of  a rock solid, fully featured, yet small footprint database built into every Android app.
That’s all the time we have, but I’m sure I’ll be seeing you around!
Using the magnets below, complete the implementation using constants and string concatenation for all helper methods.
Call super here passing in constants instead of raw values.
Create the database here, also using constants for the execSQL call.
You should have completed the implementation using constants and string concatenation for all helper methods.
All of the constants for referencing the database internal values.
Store variables for the OpenHelper and the database it opens.
Now that you have a clean encapsulated helper class for managing your database, let’s implement saving time records into the database.
Passing in the time and notes values as input parameters and constructing a SQL statement using string concatenation, you could write this method.
Without proper spacing the SQL statement will throw an error.
The time and notes values are passed into the save method as input parameters.
The input parameters are properly escaped and concatenated in the SQL statement.
So if you have errors in your SQL statements, you won’t know until you run them.
In many ways, these dynamic SQL stataments where you’re concatenating multiple strings.
Dynamically generating SQL statements at runtime can be quite difficult to debug.
One of  these utilities is the insert method on SQLiteDatabase.
Insert takes a parameter called ContentValues consisting of  a set of  key/ value pairs consisting of  the table column name and the value to insert.
Q: Does executing an insert from a raw SQL function work?
A:There are a few things that make the insert method much better to use.
First of all, you don’t have to worry about the syntax to combine the strings.
With execSQL, you have to combine the insert and the database name with the fields you’re inserting in to, plus the values.
And all this has to be properly formatted with spaces, commas, parentheses, and other formatting.
Q: So I don’t have to do any of that formatting with insert?
You’re passing the same information, but organized in a data structure rather than a raw String.
This helps you avoid a lot of the nastiness of piecing together all of these bits of Strings in SQL statements.
Add database access to TimeTracker Now that you have a database setup and configured to save time records, you can start saving times entered in the app.
Leave that code for now and add an additional call in onActivityResult to save the new time.
Since the database helper is in view, just add a call to addTimeRecord with the new data after adding it tp the list adapter.
Save the newly entered time to the database by calling saveTimeRecord on your database helper.
Now let’s get rid of some dead code before testing it out....
Before you run your new code to save new times to the database, take a minute to clean up the old ,unused code you have in the app.
Remove all of the test code adding hard coded TimeRecords in the adapter.
You can also remove the code that adds the hard coded TimeRecords to the adapter.
They were only needed since you didn’t have data persistence.
Now that you’re storing times in the database, this will just be confusing.
With your latest changes to the TimeTracker, you’ll save to the new time to the database as well as the TimeTrackerAdapter.
You won’t see the database changes directly in the app.
You’ll be able to do this later, once you connect the ListView to display results directly from the database.
Meanwhile, you can view the data in the database directly and see that the new record is there.
Save the database file locally again from the File Explorer and open it in a SQLite browser.
Query the database It’s great that the time record is saving to the database, but in order to use the stored information, you need to be able to query the database.
Just like execSQL, SQLiteDatabase has a method called rawQuery that allows you to execute raw String based SQL queries on the database.
This method will execute a select all query against the database to return all of  the rows in the timerecords table.
There are no selection args since you’re selecting all of the records.
Your query is returning all of the data, but a more specific query may only return a smaller set.
A Cursor is an object wrapper around a database result set.
Think of  it as a mini spreadsheet with utility methods to navigate the results and retrieve specific data values.
The database query returns a Cursor which is being passed to the caller of getAllTimeRecords.
There are some disadvantages of using rawQuery just like using the raw executeSQL method.
For a simple select all method, this works, but for more complicated queries where you’ll be concatenating string values for column names and specific search criteria, this approach falls short.
But just like the insert method, SQLiteDatabase has a several query helper methods to simplify complex database queries.
Now you’ve queried the database and gotten a Cursor returned.
Now let’s take a look at how to navigate the Cursor and retrieve data values.
When you work with a spreadsheet, you have a selected row and column which brings a cell into focus.
The Cursor keeps track of  a selected row internally and includes several methods to update the Cursor’s selected row.
Make sure to set the cursor row before retrieving values.
Cursors start out with the selected row set to -1
So if you try and retrieve a value based on that row, you’ll get a.
Make sure to call moveToFirst or moveToPosition before attempting to retrieve a value.
Q: How do I know which type getter to use? A: When you create your database, you assign a column type to each column.
You can use whichever type you assigned to the column for the getter.
Q: What happens if I pick the wrong type? A: Android does it’s best to convert what’s stored in the database to the type of the getter method you called.
If it cant do the conversion it will throw an exception.
Move the cursor to the first row, checking the boolean response before continuing.
Retrieve the data values from  time and notes columns and print the value.
Always make sure to close the cursor when you’re done.
Iterating the cursor Sometimes you just need to get a single value from the cursor.
In those cases, you can go straight to the row and get the value you need.
Very often though, you’ll be iterating through a number of  results and processing them in bulk.
Next steps Now you have data saving in the database, a query to retrieve the Cursor, and a way to iterate the Cursor to get specific values.
Now you need to get the data from the Cursor into your ListAdapter.
Wouldn't it be dreamy if I could just put this Cursor in a special ListAdapter and everything would just work.
Use CursorAdapter The Android SDK includes a special adapter to easily get a Cursor working with a ListView called CursorAdapter.
You’ll be able to instantiate a CursorAdapter, passing in a Cursor.
The CursorAdapter then acts as a facilitator between the ListView and the Cursor to render the contents of  the Cursor.
Like BaseAdapter, CursorAdapter is an Abstract class with a few methods you need to override to integrate it with your list.
But unlike the BaseAdapter subclass overriding getView, CursorAdapter implementations override two separate method.
The other method, bindView, is responsible for populating the view with the selected data.
An Adapter to communicate between the Cursor and the ListView.
The cursor retrieved from the database helper with the time record data.
Q: Do I have to use CursorAdapter? A:You could follow the idea from a few pages back and implement the CursorAdapter on your own.
Unless you have a really good reason though, you should just use CursorAdapter.
It will save you a lot of headaches getting going.
Q: It looks like the getView implementation is split out into these two methods newView and bindView.
Just implement newView and getView and you’ll be all set!
Add a Cursor param to the constructor.Pass the cursor to super.
Implement newView to create the view and bindView to populate the view with data.
The cursor manages all iteration, so you just need to call the getter value methods and render the results.
The adapter handles all cursor iteration for you, you just need to display the values in the selected row.
You should have implemented newView to create the view and bindView to populate the view with data.
The cursor manages all iteration, so you just needed to call the getter value methods to render the results.
The time and notes fields are both retrieved and populated with data from getString calls to the cursor.
The LayoutInflater is retrieved and the layout in inflated and returned.
The last thing you need to do to use it is to update the TimeTracker Activity to use it.
Start by passing in the context (this) and the Cursor containing the list of  time records to the new adapter.
Pass in the Cursor and the context to the adapter.
Don’t add the time record to the adapter anymore or call the data change notification..
Now remove the call to add a time record to the adapter.
Save the new time record in the database, and update the cursor in the adapter.
The TimeTrackerAdapter is now updated to a CursorAdapter and connected to the ListView from the TimeTracker Activity.
There is one time record stored in the database, so if  everything works, you should see it in the list.
Find and fix the error so I can start tracking my times!
Uh oh! Looks like there’s an error in the code.
At first glace, it might seem strange as you have an id column in your database.
But look a little closer, and you’ll see it’s not looking for a column called id, it’s actually looking for a column called _id with an underscore in front.
The class overview in the online docs for CursorAdapter even specifies that you need an _ID column.
Now that you know the problem, how are you going to fix it? Think about all of the steps you would take to implement the fix before going on.
All of the changes you need to make to the database to update the table to use the _id column (with the underscore) instead of the id column (without an underscore) is in this class.
You should have made all of the database changes needed to update the table to use the _id column (with the underscore) instead of the id column (without an underscore)
This will cause your app to call onUpgrade, which drops and recreates the database.
You updated the database version which will drop and recreate the database, destroying all of stored data.
If you found this on a production system with real users and real data, this is when you would override onUpgrade to migrate the information from the old database format to the new one.
Since you updated the database version number, the database will be automatically wiped and recreated by the database management code when you start the app.
After all that, the screen is blank! I thought the time entered earlier would be in the database since it’s saved.
When you upgraded the database version to “3” and reran the app, onUpgrade was called which dropped the timerecords table and recreated it.
This wiped out any saved data you added while you were testing.
The database is starting off  empty because it was just dropped and recreated.
Add a new time and save it and you should see it in the list.
From the list screen, press the back button to exit the app and then relaunch it.
Excellent work! Your app is now storing and loading data from a SQLite database.
Simple, easy to use with no distractions, and now it saves my times.
Looks like another happy user! Although there are more features you could implement in this app, you’ll stop working on it here.
Try implementing new features on your own, like editing and deleting time records to really take the app to the next level and make Donna even happier.
Now that times are saving in the database, you’re ready to move on.
But if you’re still thirsty for more, here are a few additional features and exercises you could work on to start honing your Android database skills.
Implement onUpgrade You upgraded the database in this chapter without overriding onUpgrade to handle the schema change.
Go back and modify the detabase again, implementing a data migration in onUpgrade.
But just like execSql, this is limited and error prone.
Look into the database query() methods and implement a few more detailed queries against your database.
Implement delete and edit Right now you have the ability to create the database and add to it.
Try implementing methods on your database helper to edit previously entered time or delete them.
Create your own databases for your apps so you can persist your app data.
Wrap your SQLiteOpenHelper in a database helper class encapsulating your database and limiting access to it.
Expose helper methods on the databasehelper to manage database usage throughout the app.
Abstract constants and reusable pieces of your SQL statements to make your code resilient.
Use Database helper methods for inserting and querying rather than the raw SQL methods when possible.
Always take a look at Android’s built in components (like CursorAdapter)
Use CursorAdapter to connect your cursor to a list so you don’t have to write all that Cursor management code.
Remember to update your database version or delete the database if you make changes to your database schema.
If you do update your database schama, consider implementing onUpgrade to migrate production data.
Create a constructor that passes the Context to super, as well as a cursor.
Override newView to inflate an XML View (or create one programatically)
Override bindView and populate the View with data from the current cursor row.
You just built your first app with full persistent SQLite.
But don’t worry! Android comes with other layouts that you can use.
This guy is out of control! Ain’t nobody ever thought about taming him just a bit?
But sometimes we like to split up and skate at different places around the city.
They worry about each other when they skate apart Skating can be dangerous.
Design the app Like all good apps, building this app starts out with a good solid design.
After chatting with Sam and Scott, you found out that they want a really specific app.
Keep it simple! I want one big button that I can use to text Taylor.
But it does have to look good if I’m going to use it.
Focus on the layout first In this chapter, you’ll focus on the layout.
You’ll learn about a new layout called RelativeLayout that is much more powerful then plain old LinearLayout.
Nested LinearLayout implementation Based on the sketch, you could implement this layout using a combination of  nested LinearLayouts (layouts inside other layouts are called nested layouts)
Here is one way you could implement this layout using nested LinearLayouts.
This is getting complicated That’s a lot of  layouts! Before you start writing the code for this layout, let’s take a look at the view hierarchy with the layouts and their children on a tree.
The views on the left side of the contact display.
Layout used to center and position the “I’m Cool” button.
Too many nested layouts kill really slow down your app’s performance.
Not only is this nested layout structure complicated to code, but it will also slow the performance of your app.
The more layouts you have, the longer it takes to render your screens.
For really complex screens, this can make a HUGE difference!
Meet relative layout RelativeLayout is a layout that allows you to position Views on the screen relative to each other.
Where LinearLayout positions all Views in a line - either vertically or horizontally -RelativeLayout let’s you express layout positions like “put this View below this other View” or “put this view to the left another View”
Add a view positioned in the parent Making your own RelativeLayout starts with an anchored view.
This is a view that has an anchor on the screen referencing something about the parent view like the top left or right, the bottom left or right, or the center of  the screen.
Add (a bunch) of other views You can add (and keep adding) views positioned relative to any other view on the screen.
This positioning may be relative to an anchored view (like View B positioned relative to the View A) but it doesn’t have to be.
You can also add more anchored views, and then other views positioned relative to that new anchor view too.
This component is positioned on the top of the screen (the parent)
Sound impossible? Turn the page to get started laying out the screen with RelativeLayout and see for yourself!
Are you ready for a challenge? The Android layout manager thinks you can layout the entire screen using just one RelativeLayout.
You can layout this whole screen with just this one layout and no nesting.
Choose your anchor point The first step when you make a new RelativeLayout is to position a View in the parent.
This is a view that has an anchor on the screen referencing something about the parent view like the top, bottom, left, right or center of the screen.
From there you’ll position the rest of  the Views relative to the first anchored view.
For the layout, the first View that you’ll position in the parent is the contact Name TextView.
And it’s going to be positioned to the top left hand corner.
Once this first View is positioned, you’ll be able to layout the rest of the views around it.
You’ll start by adding the contact name TextView anchored to the top left of the screen.
The layout is declared with a type of RelativeLayout and its width and height are set to fill the screen.
The TextView for the Contact Name is also added, but not positioned.
You’ll need to use the magnets with position parameters below to position the View.
Remember, it should be positioned to the top left hand corner.
This attribute positions the view top the top of the parent.
This positions the View to the right side of the parent.
This positions the view to the left of the parent.
The layout is declared with a type of RelativeLayout and its width and height are set to fill the screen.
The TextView for the Contact Name is also added, but not positioned.
You should have used the magnets with position parameters below to position the View.
It should be positioned to the top left hand corner.
This lays out the View to the TOP of the parent.
This lays out the View to the LEFT of the parent.
These two attributes together position the Contact Name View at the top left of the screen.
Now that the first View is positioned, run the app and let’s make sure the View is positioned correctly.
The View is in fact positioned on the top left, but it needs some space so it’s not pinned to the edges.
Let’s make those updates to the layout before moving on.
The next view to add is the Phone Number view.
Attributes for relative positioning to other Views There are different layout positioning attributes for laying out Views relative to parents and relative to other Views on the screen.
The Contact Name view is positioned relative to the parent, but the Phone Number View is going to be positioned relative to the Contact Name view (another view on the screen)
Next, you’re going to position the phone number TextView under the Contact Name TextView.
Using these attributes You add these attributes to View declarations in the layout XML just like the other positioning attributes.
The difference is that instead of using a value of  true, you pass in the ID of  the view you want to position your view relative to.
Now that the Phone Number view is positioned, run the app and make sure it’s in the right place.
The phone number view is positioned under the contact name view, but all the way to the left of the screen.
How come the phone number field is all the way on the left?
But why is it showing up all the way to the left?
In this case, positioning the phone number field below the Contact Name field controls the vertical position, but not the horizontal position.
And since the horizontal position is not controlled it’s defaulting to the left side.
You can use alignment properties to fine tune the position.
When positioning isn’t enough, you can use the layout alignment properties to position a View.
There are attribute for aligning to the left, top, right, bottom, and baseline of  another View.
Contact name TextView positioned to the top left side of the screen.
Right under the contact name TextView and aligned to the left to match the contact name horizontal position.
The attribute aligning this TextView to match the horizontal position of the contact name TextView.
Adding bits and pieces at a time can make it hard to see the big picture.
Take a minute and look at your complete layout so far.
Now that you have both the contact name and phone number Views positioned in the layout, check and make sure your positioning worked correctly.
But this time, instead of  launching the app, just click on the Graphical Layout tab.
Not only will you be able to see if  your layout worked, but you can see graphical layout position and alignment indicators if  you click on a View on the screen.
This line indicates that the phone number view is aligned to the left of the contact name view.
Position the Button below the phone number View and aligning to the left of the Contact Name View.
You’ve already positioned two Views on the screen and just three to go! With the Contact Name View and the Phone Number View added, it’s time to add the Update Contact Button.
You should have positioned the Button below the phone number View and aligned it to the left of the Contact Name View.
Q: Why is the button aligned to the left of the contact name view and not the contact phone view?
The reason is that the contact phone view i aligned to the left of the contact name view.
So setting the button to align to the left of either the contact name or contact phone would both work.
Sometimes it’s better to have a single alignment view that is referenced by multiple views and other times is better to have the layout positioning and alignment refer to the save view.
It’s really up to you how you want to organize your layouts.
Q: What if I want to position a View relative to another View on the screen, but align with the parent? Can I mix and match like that?
A: You sure can! Say you wanted to position the button below the phone number view but align it on the right side of the screen.
It’s a good idea to test your layouts early and often, especially when you’re working with RelativeLayout! This way, you don’t go too far down a path if  a View isn’t positioned correctly.
The button is added to the view, and positioned to the left matching both the Contact name and phone number View.
Getting ready to add the contact portrait Your ready to add the portrait ImageView to the screen.
This ImageView is going to diaplay the avatar associated with the contact.
You’re going need an image to use to position it and make sure it looks OK.
This way, you can layout the view on the screen and make sure it’s positioned correctly.
Align it to the top of the Contact Name TextView and to the right hand side of the screen.
Also, add 20dp margin on the right to give the ImageView a border between it and the right edge of the screen.
Set the background to a light gray so you can easily see it to position it.
For everyone out in the audience, GridBagLayout was the magical layout in Java’s Swing desktop UI Toolkit that was supposed to be able to layout your whole screen in one layout.
Sure, except that you are impossible to use! You have made countless developers cry.
You just position a component somewhere on the screen and position other components around it.
I just wanted to point out that although we both can layout very complex sets of  components we do so very differently.
But I’m just saying I’m waaaaaay easier to work with than you are.
Talk about getting off  on the wrong foot! What’s wrong with being here with me?
Now wait a minute, that’s just unfair! It’s true I have a rather complex grid structure that my developers have to learn, then place each component in the right position in the grid...
You know, I don’t have to sit here and take this kind of  badgering from you!
I do require a person willing to devote effort learning and working with me.
You should have adjust the ImageView attributes below, aligning it to the top of the Contact Name TextView and to the right hand side of the screen.
You should have also added a 20dp margin on the right to give the ImageView a border between it and the right edge of the screen.
The ImageView for the portrait is aligned with the top of the Contact Name TextView and to the right of the screen.
Align the view to the top right of the screen.
Time to add the “I’m Cool” button OK, you’ve only got one more View to add to the screen...
This is looking awesome! Scott and I can’t wait to use it.
How would you position the I’m Cool button? What component would you align it with? How are you going to position it?
Positioning the “I’m Cool” button Did you think about how you could position the I’m Cool button? What did you come up with? One option you may have come up with is adding the button under the Update Contact and giving a little margin to the left.
The truth is, new Android deveices are coming out all the time with different screen sizes.
Your best bet is think ahead and try and plan for as many screen sizes as possible.
If  you position the I’m Cool button some distance below the Update contact button, it may look good on some screens that your testing on.
But with if the screen is really long? It’ll be pinned to the top!
So what can I do? There is another useful positioning element you can use to center the view in the parent- both vertically and horizontally.
If  you use that positioned element for the I’m Cool button, it would look ok on the smaller screen on the left AND the long screen on the right!
You’re done! Now let’s take a look at the completed layout.
All of  the Views are laid out on the screen and (hopefully) positioned properly.
Run the app in the emulator and make sure everything is where you expect it.
Contact name, number and update button all left aligned and the top of the screen.
One button right in the middle of the screen to send a message to the contact.
You may have noticed the I’m Cool butt is a little small.
There, you’ll learn some advanced graphics techniques and make this button a large graphic.
Comparing the layouts With the screen layout all finished using RelativeLayout, let’s go back and compare the tree of  the nested LinearLayouts with the new and improved RelativeLayout.
Now you have just one layout for the whole screen!
You’re quickly becoming a RealativeLayout master by the end of this chapter.
If you’re ready for more, here are a few pointers to more information on RealativeLayout and other cool layouts.
Other layouts RelativeLayout isn’t the only layout manager on the block.
Too many nested LinearLayout can slow down your application performance.
Align views to the parent positions using alignParentBotton, alignParentTop, alignParentRight, and alignParentLeft.
You’ll also learn how to query contacts stored on the.
The app is looking good, but now I want it to be able to use it! Sam and I are heading out for a little bit.
You just finished laying out all of  the views, but that still won’t allow Sam or Scott to send messages to each other.
Let’s get the guts of  the app built out and get Sam and Scott messaging each by the time they get back.
The app doesn’t have the functionality you need yet, but you laid the groundwork with the layout you built in the last chapter.
Here is what you’re going to do in this chapter to make the app work.
Select a contact Pressing the update contact button should show a screen allowing your users to select a contact from the phone.
This way, your users won’t have to enter contact information multiple times.
Update the display After the contact is selected, the contact display (the contact name, phone number and photo) should update to display the selected contact’s information.
Send a text message This is the real user goal of  the application.
Once the contact is selected, your users should be able to press one button and have a text message automatically sent to their selected contact.
When you first launch the app, no contact is selected.
In the last chapter, you designed and constructed the user interface with some temporary contact information.
But now that you’re making the app work, start by making it clear that no contact is selected when it launches.
Start by adding a new method called renderContact and call it from onCreate.
Right now this method will just display a message to select a contact.
Display a message in the name view and blank out the rest.
Right now this is just showing the “no contact” message but eventually this will display the contact iif there is one.
Run the app now and verify that the “Select a contact” text appears in the contact name View.
Here is the “Select a contact” text displaying in the displayName field.
How do I select a contact? You’re ready to select a contact now.
You could have them enter their contact’s name and phone number and select a picture to make the app work.
But they’ve already entered that information into their phone, in their contact list.
So just let your users select a contact from their contact list and you’ll save them a lot of  boring data entry, and leave your app focused on the cool stuff.
But how should you build a contact list selecting screen?
You could build a screen that loads and displays contacts stored on the phone...
Build this screen to display the contacts and allow a user to select one.
Return the user back to the main screen after selection.
Here is what the flow would look like if  you built your own contact screen.
When you press update contact, you’d go to your new screen and back to the main screen after you selected a contact.
Wouldn't it be dreamy if I could just show the native dialog allowing users to select contacts on the phone the same way they make calls.
This is used to select contacts for phone calls and other native apps.
But it can also be used by apps like yours so you don’t have top build it yourself.
After selecting a contact, the user it taken back to the main screen.
Q: Why is it better to use the native contact selection? A: First of all you don’t have to build it! But more importantly, it guarantees your users experience is the same as the native experience.
If there is a modified version of the contact selection on your users’ devices, they’ll see whatever is native when you invoke the selection request.
Also, if the native contact selection changes over time, you’ll get whatever the latest behavior is automatically.
If you built it yourself, it might look different than what your users are expecting.
But what if I really want to make a custom replacement for native behavior in my app?
You could query the contact store directly and build a custom screen or component displaying the content and allowing your users to select contacts that way.
But this chapter is going to focus on using the native selection.
Using the native contact selection screen will keep the same flow, but you won’t have to build it yourself.
Invoking the contact screen OK, so it looks like the built in contact selection is the way to go.
Intents are a generic mechanism for invoking an action that the system can respond to.
When you built the screen navigation in the TimeTracker app, you specified the Activity you wanted to invoke in the Intent.
When the Android action code processed that Intent, it saw the reference to the Activity and invoked it directly.
You don’t actually have to include a reference to an Activity in an Intent.
You can also supply a Uri or a combination of  Uri and an Action.
And if  you invoke the Intent, the Android action code looks for an Activity that responds to that Uri and invokes it.
You can find extensive documentation for the Uris and Actions you can pass into an Intent in the Intent’s online documentation.
Using this action, you can view a list of all contacts in the contact list.
You need to create an Intent to select a contact from the contact list.
You can create this Intent using the constructor that takes an Action and Uri.
The Uri is a reference to data on the device, while the Action says what to do with the data.
But what about the Uri? Uris are actually human readable descriptions of  where to find the data.
But to make the types work with the constructor, you need to convert the string in a Uri object which you can do using Uri.parse.
You have a constant for the action but not the Uri.
Is it a good idea to use a String to create the Uri or is there a constant you can use.
Use constants when you can The Uri created by parsing the string will work, but raw strings are just a hassle to keep in your codebase.
The format could change in the future or you could just have a typo in your code that the compiler wouldn’t catch.
And there is just such a constant you can use.
But in this case, you want to have the selected contact returned after the contact selection is complete.
In onActivityResult, print the returned Intent to the Log to see what comes back.
Create the intent here with the action and the Uri.
Print a message printing out the returned intent to the log.
In onActivityResult, you should have printed the returned Intent to the Log to see what comes back.
Print the intent to the log so you can see what’s passed back.
Without it, you’ll get an error when you try and access the contacts in your app.
After all, a users contacts are sensitive information so you need to ask and they need to give you permission.
This should also clue you in to being really sensitive to what you do with that access.
Getting ready to test contact selection The contact selection code is all ready to go, but there are a couple of  things to update in your project before you run it.
First you need to add the onClick property to the Update Contact button on the screen to invoke the onUpdateContact method.
Now that the Intent is created and being started, you should see the contact lost display when you press the Update Contact button.
Go ahead and run the app and check to make sure it’s working.
Wait a second! It looks like the contacts page is displaying but there are no contacts.
You don’t have any contacts in your setup in the emulator.
The reason you’re seeing this screen is because the app is running in an emulator that doesn’t have any contacts configured.
You could create the contacts on the phone, but we also want to test images and images are hard to test on the phone.
And you’ll want to test the text message sending anyway which you can’t do from the emulator.
Sometimes it’s best to test your app on a hardware device.
And when you select one, you’re taken back to the home screen of  your app.
Run the app on a device Plug in your Android device using USB and remember to turn on the option to allow non-market apps.
Then just run the app again from Eclipse and select your hardware device.
Now that you’re running the app on your device, when you go to the Contact Selection screen, you should see a populated list of  contacts.
Click on a contact and you’ll be taken back to the home screen.
I like that selecting a contact looks like my other apps.
Now you’re going to display the details, right? This way, I’ll know I’ve selected Scott so I know I’m texting the right person.
Definitely! Displaying the sected contact is next on the list.
Now that the contact is being selected, it’s time to display that contact on the home screen.
To get this working, you’ll need to get a reference to the contact that was selected, retrieve the display name, phone number and photo for that contact and display it on the screen.
Start by looking at what’s coming back You’re already getting the contact back to the ImCool Activity in onActivityResult.
You also put a log statement in there to see what the returned Intent contains for its data.
Take a quick look at the log and see what came back.
You should see one line that looks something like this: This string starting.
If  you’re thinking that the string printing out in the logs looks kind of  like some kind of  a local web address, you’re not too far off.
It’s actually a URI, or Uniform Resource Identifier which is a string that locates a specific resource.
The different between the URI here and a web URL is that the URI here is an address for a local resource.
In this case, the URI is a reference to the selected contact.
But I don’t want a reference to the contact, I want the actual contact!
But it does represent a direct lookup to that contact.
Accessing the contact There is a contact data store built into every Android device.
You can query the contact  data store for specific contact information, like determining which contact has an associated phone number for building caller ID functionality, or in our case, just finding more properties for a contact that you already know about.
There is a utility class called ContentResolver that you can use to query the contacts.
Using this Uri and a query to the ContentResolver , you can get to the raw contact! Then using what you learned when you iterated through database results, you’ll iterate through the contact result Cursor it returns.
The ContentResolver processes the query and returns a result cursor from the contact store on the device.
The query returns a Cursor, just like the Cursor returned when you query a database.
Update the code to use a URI The renderContact method is currently hard coded to display the no contact selected state.
But you’re about to start populating the selected contact, so let’s make it clear when there is and when there is not a selected contact.
Then you can start filling in the code when a contact is selected.
If  the Uri is null (meaning no contact is selected) then set the name, phone, and photo view to display the no contact selected state you setup at the beginning of  the chapter.
Also update the onCreate to call renderContact with a null Uri (since no Uri is selected) and from onActivityResult pass in the Uri.
If  that Uri is null, display the no contact selected state with the message to select a contact.
Also update onCreate to pass in a null Uri and onActivityResult to pass in the Uri from the Intent.
Create helper methods for each data field you want to set on the screen.
Pass in a null Uri onCreate since no contact has been selected yet.
Pass the Uri (the data from the intent) on to renderContact.
Then pass in a null URI in onCreate (since there is no contact selected yet)
This method will return the display name for the contact.
This last method will return the photo for the contact.
Stub method for retreiving the display values for a contact.
With that bit of  code reorganization, you now have three contact detail methods to implement and the contact display will be up and running.
The three contact detail access methods you’re going to implement.
This method needs to retrieve the name of  the contact.
The display name is the name that displayed in the list of  contacts that you selected.
Scott selected Sam from his contact list, so this method should return “Sam” to display it on the home screen.
This way Scott will know Sam is the selected contact that the app knows about.
To get this to work, you’ll need to query the contact store and access the appropriate value in the Cursor.
Since Scott selected “Sam” from the contact list, getDisplayName should return Sam from the retrieved contact as positive reinforcement.
Query the contacts Think of  the contact store like a database.
In fact think of  the device having a big database with all of  the content you can access on the phone and the contacts are inside there.
You need a way to query that database though, and that’s done with the ContentResolver.
You can retrieve the ContentResolver from your Activity using the Activity getContentResolver method.
Then you can query the content provider passing in the Uri returned from the Contact selection screen.
The ContentResolver query return a Cusor, just like the cursor returned when you query a database.
The query returns a cursor just like a database query.
Cursor contents Just like the Cursor database queries return, this Cursor is made up of  a number of  rows and columns.
No columns were specified in this query so all the columns came back.
This is resource intensive and you’ll want to fix this.
But for now, let’s get the iteration working and then once you know the columns you need, you can query just for those.
How do you figure out what columns are coming back? There are a few ways you could figure this out- you could write some code to print out the data or use the debugger.
But before you do any of  that, take a look at the documentation for ContactsContract.
This class has a number of  constants for the columns returned from the query, including one for DISPLAY_NAME which is what you’ll need to display in the contact name field.
Put your code in here to query the contacts using the Uri, iterate the cursor, and set the value for the display name on the screen.
Below is the updated renderContact method being passed in a Uri.
If the Uri is not null, write the code to retrieve and set the display name on screen.
To do this, you’ll need to query the ContentResolver using the Uri passed in to renderContact.
Then iterate through the cursor and retrieve the display name using constants.
So retrieve the column index using the constant and retrieve the value.
Also remember to use safe Cursor iteration and to close the Cursor when you’re done.
Below is the updated renderContact method being passed in a Uri.
If the Uri is not null, write the code to retrieve and set the display name on screen.
To do this, you’ll need to query the ContentResolver using the Uri passed in to renderContact.
Then iterate through the cursor and retrieve the display name using constants.
So retrieve the column index using the constant and retrieve the value.
Also remember to use safe Cursor iteration and to close the Cursor when you’re done.
Move to the first row of the cursor (there should only be one)
Get the string value from the cursor, but first get the column index using the display name constant.
Test Drive Run the app now and select a contact.
After selecting a contact and going back to the main screen, the display name is populated with the selected contact.
Display the phone number next You’ve got the name displaying on the contact display on the main screen.
This means you’re successfully selecting a contact, getting the selected contact back and retrieving data values from that contact by querying the contact store.
Now you need to display the phone number and photo to complete the contact display.
The contact name is being set from the selected contact.
This should be super easy, right? Just need to get a few more values from the cursor?
Actually, retrieving the phone and picture are going to take a little more work...
You can have multiple phone numbers (think home, mobile, office, etc), multiple addresses, etc.
To handle this, contacts are actually implemented as separate rows.
One row handles the main information for the contact (like the display name), and then there are multiple detail rows for the contact.
Turn the page to see how access the detail contact rows?
Accessing contact info details The general contact info row has some, but not all, of  the information you need.
This is pretty standard when you’re working with the device contacts.
The general row is about enough to make a list of  contacts but that’s it!
The content for the phone numbers in the contact detail table.
It has a mix of all different kinds of numbers for multiple contacts.
The detail rows are also stored in the contact store and you can access them using another query to the ContentProvider.
All you need to do is pass in the Uri to the query method and you’ll only get back phone numbers.
There are LOTS more columns at the end here ..
Let’s put this all in context and implement the getMobilePhone method.
This method needs to query the contact details for the mobile phone associated with the selected contact.
It will query the contact store using the Uri from ContactsContract.
Can you spot it? (Hint: Look closely at the Uri passed in to getMobilePhone)
Be selective with your contact query If  you used the getMobilePhone method as is in your app, you’ll most likely get a phone number associated with a different contact than the contact selected.
There are additional parameters you can add to the query call that refine the results you’ll get back.
It acts like a SQL WHERE clause in the underlying query to the contacts.
And just like a SQL WHERE clause, you can include ?’s in the select String.
Using another constant from the ContactsContract, your select parameter will look like this.
Another constant from the ContactsContract class that allows you to select a specific contact..
This is going to be the ID for the contact.With this select parameter, you also need to pass in an.
These selection arguments will replace the ?’s in the select string when the query is executed.
This is the ID for the contact you want to select.
The only issue now is that you don’t have a reference to the contact ID in the getMobilePhone method.
This first query retrieves the main contact row, and from that row you can retreive the ID.
The second query retrieves the contact detail rows with the phone numbers of the selected onctact.
It needs first query the contact store to retrieve the ID of  the selected contact based on the selected contact Uri.
Then use that ID and pass it in through the selection arguments in the second query.
Pass in the select statement and selection arguments to select only phone numbers for the selected contact.
Just a little more refining to do With the update of  getMobilePhone to use a select statement using the selected contact ID, you’ll only retrieve phone numbers for the selected contact.
This is good, but not good enough for you, a Head First rockstar!
This current getMobilePhone implementation retrieves all phone numbers for the selected contact.
But for this app, you only want mobile phone numbers! You can’t send a text message to a land line after all, so let’s make sure we retrieve just the mobile numbers.
So the phone numbers are narrowed down to just the.
You’re already selecting phone numbers by passing in a select statement to the query.
Now you need to get a little more specific and add a clause to that select statement that you only want to select mobile phone numbers.
There are also constants for these different types in ContactsContract.
The constant that refers to the mobile number type is ContactsContract.
Now just Sam’s detail rows are coming back, but we want to narrow that down even more to just mobile phone numbers.
Below is the query to retrieve the phone numbers for the selected contact.
Update the code below adding a second clause to the select statement for the phone type to be mobile.
Use AND to join the clauses in the select statement.
Add to this select statement to narrow the results down to only mobile phones.
Below is the query to retrieve the phone numbers for the selected contact.
You should have updated the code below adding a second clause to the select statement for the phone type to be mobile.
You should have used AND to join the clauses in the select statement as well as using the constants from the ContactsContract.
You’ve got two of the three renderContact helper methods working.
Now the display name AND the phone number are being displayed.
Run the app and select the contact again, and you should see the display name and the phone number display for your selected contact.
You’ll need to pass in the ContentResolver and a Uri.
This is slightly different from the other Uri you’ve been using as it’s actually generating a new Uri based on a stored constant plus the ID you’re passing in Check out the online documentation for details.
Use BitmapFactory to decode the stream into a real, live bitmap!
Great work! All three methods are working to retrieve and display the contact info!
Test Drive Run the app and select a contact one last time.
You should see all three fields update- the display name, the phone number AND the photo.
The last feature to build before you can give the app to your users for testing is to send the text message.
The code to send the text message will go in here.
Add the onClick property to the I’m Cool button in main.xml.
Also add the method to the activity that’s called by the onClick attribute.
There is a class called SmsManager with a method that sends a text message.
These are special intents that can be activated like callbacks.
You won’t need to use them for basic text message sending.
If you don’t add the SEND_SMS permission to your app and run it on a device, you’ll get an error about missing permissions.
Let’s make one small change to your Activity to send text messages.
Right now, the contactUri is used to update the display after selection, but it’s not stored anywhere.
For now, store the contactUri in your Activity as an instance variable.
Cache the contactUri that comes back from the contact selection.
Now store the Uri of  the selected contact when it’s passed back from the contact selection in onActivityResult.
This way, you’ll be able to call getMobilePhone to retrieve the selected contact’s phone number to send the text message.
You may not use the same code fragment more than once, and you won’t need to use all the code fragments.
Note: each thing from the pool can only be used once!
You may not use the same code fragment more than once, and you won’t need to use all the code fragments.
Note: each thing from the pool can only be used once!
Now that you have the hang of ContentProviders, here are some other cool things to look into.
Audio Content Using the same concepts you learned searching for contacts, you can load audio too! Check ou.
Audio for more information on loading music, playlists, album covers, and more.
Photo and Video Loading photos and videos from the device works in a similar way too.
Modify Data Content providers aren’t just read only, you can modify content too.
For example, writing or modifying a phone number, adding a new photo, and more.
Write your own! If you have data in your app that you’d like to share with other apps, you can build your own content provider that other apps can query.
If you pas in this Uri/Action commbo, the OS determines the most appropriate Activity to respond to the Intent.
Query general contact information using the full contact Uri returned form selecting a contact.
Query contact details with the help of contact constants in ContactsConstract subclasses.
Refine your queries with select statements to get the data you want.
You also implemented text messaging and tested on a real world device.
Use native behavior by invoking an Intent with Actions and Uris instead of explicit Activity references.
Check the online documentation for Intent to see which Uris have native responders.
Sometimes it’s easier to test on the emulator and sometimes it’s easier to test on hardware.
And make sure not to only test on the emulator since you’re deploying your app to the real world, NOT the emulator!
Contact information is located in an ondevice data store you can query like a database.
Contact information is stored in spearate records for main contact information and contact details.
Query contact (and other OS stored information) information using ContentResolver.
Easily send text messages from your app using SmsManager (and adding the SEND_SMS permission)
First you’ll learn how to use images on your buttons.
Then you’ll learn how to use special resizable images that will really help your apps look.
All you need is a little polish to make it look great!
Sam dropped in while you were finishing up the message sending and asked for a quick look at the app.
After showing it to her, it became clear that function alone is not enough.
Good apps need good graphics You might be a strong engineer and a great graphics designer.
And if  you can design and build your own apps, this is where you’d open up your favorite graphics tools and create some great graphics to make the app look super slick.
But if  you’re like the rest of  us, you’re going to need some help.
Don’t worry though, with the super high quality graphics in even the most basic apps, getting outside graphics help is pretty standard these days!
Let’s see if there is anyone who can help us out with this...
But I need something to use when they don’t have an image set.
If so, and since this is Android supporting different device sizes, could you send me the image in three sizes...
Meet the Head First Graphics Team Turns out there’s a great group of  graphics artists just dying to help you on your latest project! They just need you to send them an email describing what you need.
Here’s a mockup of the app the way we’d like to see it!
Some cool graphics spread around the app to make it.
The Head First Graphics Team just got back to you with a sketch of  how to update the design of  the app.
Let’s take a look at their design and see what it would take to implement it.
Now let’s see what needs to be done to make your app look like this picture.
This design uses custom images for both the Update Contact and I’m Cool buttons.
You’ll need to update the current buttons to use images, and you’ll need to get those image resources (the actual images for the buttons) from the Head First Graphics Team.
You’ll need to get this image from the graphics team and set it on the background.
The issue here is that you don’t really know the actual size of the screen.
Even if  you know the screen grouping, the actual screen might be a a few more or less pixels than you’re expecting.
To solve this, you’ll need to use a special kind of  image that can resize.
Use image buttons instead of plain, boring ones Let’s start implementing the Head First Design Team’s graphical update by adding the images for the buttons.
Android provides a special button View called ImageButton specifically for buttons with images.
To use ImageButton, just declare a View of  type ImageButton and instead of  setting the text, set the android:src attribute to reference an image.
The design you sent over with the added graphics looks fantastic! I’m working on the image buttons now.
Can you cut those out and send me PNG files for them? Thanks!
Before you can add the ImageButtons to your layout, you need the images to use.
Time for another email to the Head First Graphics Team asking for images from their mockup.
The Head First Graphics Team got back to you and sent you two images.
Add them to your project under the res directories in drawable-hdpi.
Make sure to cover ALL of the screen resolutions you’re targeting.
Add the ImageButton With the new button images added to the res directory, update main.xml replacing the regular Buttons with ImageButtons.
Set the android:src attribute to the names of  the images you added from the graphics team.
Also, remove the android:text attributes from both buttons since the images both have styled text embedded in them.
Set the android:src to the names of the images you added (without the .png extension)
Wow, those borders are looking pretty crazy! And when I press them they glow.
Now that you have the images added to your project and the ImageButtons added to your layout, run the app and see how it looks!
The images are displaying, but you’ve got some cleanup to do...
When you press a button, the gray border turns a color so you know it’s being pressed.
The image on an ImageButton doesn’t cover the entire button.
The ImageButton has a default background and the image you set in the android:src attribute is drawn on top of  it.
If  you set the background to null, you’ll just see you’re image.
Now take a look back at the app, and notice that the ImageButton borders are gone.
All you can se now is the image drawable from the android:src attribute.
It turns out I need separate images for the button in pressed and non-pressed states.
Can you send me images for those two buttons in their pressed states? The ones you.
Uggghhhh! Now the ugly border is gone but you can’t tell when the button is pressed.
But fixable! By default, the button indicates it’s being pressed by changing the background to orange.
The indication that the button is pressed is really important for your users, but the big gray box around your great new images looks awful! What to do?
The solution is to have two different images: one for when the button is pressed and one for when it isn’t.
And since you need more images, that can only mean one thing...
Add the (new) images to your project Looks like Head First Graphics Team just got back to you! Let’s plug in the images they sent back.
There is only one attribute - android:src - to set the image on an ImageButton.
But you want to use two different images: one when the button is pressed and another one when the button is in it’s normal state.
You could add a listened to the button and change the image displayed when pressed, but there is a much easier way!
This should make it clear when they are pressed and not pressed.
Let us know if you need anything else, and good luck with the app.
Selectors allow you to define multiple images to use for buttons based on state.
Selecters are implemented as XML files with elements inside the file referring to specific states, and which image to use for that state.
Then you can set the selector as the drawable instead of  a specific image, and the ImageButton will automatically select and update the image according to its state.
When the button is not pressed The selector returns the default button image when the button is NOT pressed.
When the button is pressed The selector returns an alternate button image when the button is NOT pressed.
Where is the selector file? The new empty selector XML file was created by default in the res/drawable directory.
Wait a second! The images are in drawable-hdpi, but the selector file is just in drawable.
Selectors are just pointers to files, and the Android runtime finds the right ones.
By default, Android looks in the drawable directory fro the selector files.
But when it comes to loading an image, the Android runtime tries to load images first from the resource folder specific to the screen size group.
So in this case, the selector XML can live perfectly happy in the drawable folder and be found by the runtime.
But when an image gets loaded, the runtime starts by looking in the drawable-hdpi folder (assuming you’re running on a high resolution device) and loads the image from that folder.
Double click top open it and you’ll see an empty selector file.
You’ll be completing the selector by adding images and states here.
Linking a state to a drawable inside selectors is done by defining <item> elements.
Here is an item element that will render the im_cool_button.
This item is in effect when the button is pressed.
Display the im_cool_ button drawable when the item is in effect.
Add the image pointers The autogenerated selector is empty and you need to add the links from specific states to the images that should be displayed for them.
You’re going to need two image/state combinations: one for when the button is pressed and one when it’s not.
Use the code magnets to add two items to the selector.
This selector will only work on devices that fall in the HDPI category.
This is fine (for now) since we know Sam and Scott both have HDPI Android phones.
With that in mind, you should do careful analysis of your target users and make sure to cover their devices as well.
Here are some tips to cover as many devices as possible.
And remember, you don’t need resources for every single resolution.
You might find that with flexible layouts and decent scalable images, you can get away with really great hdpi and mdpi images and you’re all set.
Don’t do more work then you have to, but do make sure your app looks great on all devices.
Put default drawable images in drawable The other folders contain device group specific images.
But if  an image resource isn’t found for the specific device group (or a new group is introduced) the Android runtime will check here.
Look for new screen groups With the addition of  tablets and larger phones, the number of  screen groups is growing.
Keep an eye out for these new groups and make sure you have the resources you need for these groups.
Add images for each screen group Each screen grouping will try and load its pecific images.
Make images for every group and add them to appropriate folder.
You should have used the code magnets to add two items to the selector.
This item is in effect when the button is NOT pressed, and it displays the im_cool_btn_bkg drawable.
Set the selector as the button’s drawable The selector is a drawable, so you can set it as the background just like using an image.
The last step before testing the selector is to set the android:src attribute on the ImageButton to the selector instead of  pointing directly to an image drawable.
Set the selector as the drawable for the ImageButton src.
Q: These selectors look cool, but what if I want to use a different image when the button is, say, disabled?
A: Pressed isn’t the only state you can use for your selectors.
In addition to pressed, you can also create items referencing focused, selected, checkable, checked, enabled, and window focused states.
But what if I want to combine then? Say I want to use one image when a button is disabled and pressed.
A: No problem! You can combine as many states as you want to in a selector item.
Just add additional attributes to the item you want to configure with multiple states and you’ll be all set.
Now that the Button images are working for the I’m Cool button, let’s add another selector for the Update Contact button.
Now that you have the selector in place, run the app and see how the “I’m Cool!” button looks when pressed and not pressed.
When the button isn’t pressed, it looks just like it did before.
But when the button is pressed, it automatically switches to the pressed image!
Below is the empty selector for the update contact button.
Add two items to that selector for the pressed and unpressed states as well.
When you’re done, update the snippet from main.xml below to use your new selector.
Add items here for the unpressed and pressed button states.
Below is the empty selector for the update contact button.
Add two items to that selector for the pressed and unpressed states as well.
When you’re done, update the snippet from main.xml below to use your new selector.
Set the android:src attribute to the selector as its drawable.
Run the app now and pay close attention to the two buttons.
Press and unpress the buttons a few times and watch their states go back and forth from pressed and unpressed, changing images between the two PNG files as the states change.
And all you had to do was make a selector!
When you click on the “Update Contact” button, the button image changes.
When you click on the “I’m Cool!” button, the button image changes there too.
Now for the background image The buttons are looking great, so it’s time to move on to the background image.
The Head First Graphics Team mocked up the background and sent along the image they used.
The Head First Graphics Team sent you a background image that is 300x300 pixels.
But Android devices can be all kinds of  different sizes! Android can resize the image, but this resizing can make your images look pretty bad with default stretching..
Default image resizing and can push and pull your images in ways that make them look terrible!
Wouldn't it be dreamy if there was a way to make images look great on all different sizes of Android devices.
You can use a technique called 9-patch images to really help deal with these variances between screen sizes.
Then, when the image needs to be resized, it only resizes the portions you’ve specified can be stretched either vertically, horizontally, or both.
Here are extreme stretched versions of  this image as the size of  the background in portrait and landscape mode.
Look how the ‘sky’ section was vertically stretched a lot, but since it’s a part of the image that can stretch it still looks great! The cloud also horizontally stretched a little and still look great.
All and all, the image is a LOT taller, but still looks sharp!
The vertical sky part stretched a little bit, but the clouds stretched a TON horizontally...
Using 9-patch images works really well, but only for images that have a stretchable area.
For this to work, you’ll need a section that can be stretched horizontally, a section that can be stretched vertically, and they have to intersect.
This image has a stretchable horizontal and vertical section AND they intersect.
Anywhere you try and stretch this image will look distorted.
Get a raw PNG image 9 patch images start with plain old PNG images.
The only thing special about these images is that they have to resize well based.
You won’t have to enter the full path to the android home if you add it to your path.
Open your PNG Open the background image by dragging the PNG onto draw9patch.
Since you’re working on the background image, take the background image that the Head First Design Team sent you and drag it onto draw9patch.
Once the image is opened in draw9patch, you’ll see the image preview along with previews of the image at various different sizes.
Previews of the resized images at different sizes and orientations.
Preview of the image along with resizing and zoom controls.
Adjust the path bounds The path bound are what control the different patches of  the 9-patch image.
Draw pixels on the left, top, right and bottom edges to add to the resizing sections.
Draw the lines on the edges to mark the stretchable areas.
On the right you’ll see a previews of the image stretched.
Make sure to select “Show Patches” to get a preview of the stretchable patches.
The 1 pixel black lines on the edges of the image mark the stretchable area.
Add the image to your project and make sure it has the .9.pmg extension.
The 9-patch drawables are not unique, they are just drawables with special extensions.
You can set it as the android:src of  an ImageView or ImageButton, or the android:background for a other Views.
Below is the beginning of the main RelativeLayout for the main screen.
Set the background of the layout to your new 9-patch image using the android:background attribute.
This will set the 9-patch image as the background for the entire screen.
Below is the beginning of the main RelativeLayout for the main screen.
You should have set the background of the layout to your new 9-patch image using the android:background attribute.
This will set the 9-patch image as the background for the entire screen.
Now that the 9-patch image is set as the background.
Wow, that looks TERRIBLE! What is going on with that CRAZY positioning?
Adjust the padding Usually padding isn’t an issue with 9-patch images and you can easily use them as backgrounds for ImageButtons and other Views.
But when you set the background of  a RelativeLayout to a 9-patch image, you need to watch out for padding issues.
Just set the padding to 0dp and you’ll be all set.
This overrides any default padding the Android runtime is trying to use which was causing all of  that crazy positioning.
A: You sure can, and it’s a pretty common thing to do.
You can use a 9-patch image for a button background, with one for pressed and one for not pressed.
Then use Android text rendering instead of using the text embedded in the image and you can use the same pressed and nonpressed images over and over again!
Q: DO I have to make separate 9-patch images for different screen densities?
Like all other image resources, 9-patch images are density dependent.
Since 9-patch images scale though, you can sometimes get away without it.
But it’s always a good idea to include multiple densities.
Q: Do the 9-patch images have to resize the same for each pixel density?
The 9-patch image includes both the image as well as the resizing areas.
So you can resize the images differently for each screen density.
That said, you probably want to keep them pretty similar to keep your app consistent.
Try running the app again, this time with the overridden padding set to 0dp.
That was a crazy drop! Let me send Sam a message and her late her know, I’m cool.
Out in the wild Testing the app is one thing, but the real reason you’re building the app is for Sam and Scott to use it! Let’s give them the app for the day and see how they use it.
Hey, it’s Sam using our new app! I bet he just did a big drop, and let me know he’s OK.
That was some great work you did with the button graphics and 9-patch backgrounds.
Here are some other things to look into if you want to make the app even better!
You could also make a cool 9-patch border for the the contact photo to make it stand out a little more.
Add location to the txt It’s cool to let someone know you’re OK, but even cooler to let them know where you are too! We won’t go into it here, but look into the Android location APIs and add location info to the text message the app is sending.
Save the selected contact You probably noticed that every time you ran the app, you had to select the contact again! That’s because it’s not being saved to the database.
Use what you’re learned about Android SQLite databases to save the contact and automatically reload it on startup.
Use ImageButtons when you want to use images for your buttons.
Use Selectors to add multiple images to a single button based on state.
You don’t need a separate selector for each screen size.
Once you have a good PNG, use draw9patch to mark the resiable sections.
Add 9-patch images to your project just like any other image drawable, in the res directory specific to your screen size.
Make sure you have separate 9-patch images for each screen size group you are supporting.
You can use 9-patch images for all kinds of resizable needs: background of EditTexts and TextViews, layout backgrounds, and more!
Find an image that can stretch horizontally and vertically, and that those.
Add items for each state and reference the image drawable to use for that state.
The selector is a ‘drawable’ so set the drawable source on your ImageButton to the selector.
We’re sad to see you leave, but there’s nothing like taking what you’ve learnt and putting it to use.
You’re just beginning your Android journey and we’ve put you in the.
We’re dying to hear how things go, so drop us a line at the Head First Labs.
