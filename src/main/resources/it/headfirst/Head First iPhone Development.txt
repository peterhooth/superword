The great thing about this book is its simple, step-by-step approach.
It doesn’t try to teach everything—it just launches you right into building iPhone applications in a friendly, conversational way.
Head First iPhone Development continues the growing tradition of  taking complex technical subjects and increasing their accessibility without reducing the depth and scope of  the content.
What sets this book apart is its focus on learning.
Hidden behind the funny pictures and crazy fonts is a serious, intelligent, extremely well-crafted presentation of  OO Analysis and Design.
If  you’re a new software developer, Head First Software Development will get you started off  on the right foot.
Visual learners, kinesthetic learners, everyone can learn from this book.
Visual aids make things easier to remember, and the book is written in a very accessible style—very different from most Java manuals…Head First Java is a valuable book.
I can see the Head First books used in the classroom, whether in high schools or adult ed classes.
Another nice thing about Head First Java, 2nd Edition is that it whets the appetite for more.
With later coverage of  more advanced topics such as Swing and RMI, you just can’t wait to dive into those APIs and code that flawless, 100000-line program on java.net that will bring you fame and venture-capital fortune.
There’s also a great deal of  material, and even some best practices, on networking and threadsmy own weak spot.
In this case, I couldn’t help but crack up a little when the authors use a 1950s telephone operator—yeah, you got it, that lady with a beehive hairdo that manually hooks in patch lines—as an analogy for TCP/IP ports...
Even if  you already know Java, you may pick up a thing or two.
Of  course it’s not the range of  material that makes Head First Java stand out, it’s the style and approach.
This book is about as far removed from a computer science textbook or technical manual as you can get.
The use of  cartoons, quizzes, fridge magnets (yep, fridge magnets …)
And, in place of  the usual kind of reader exercises, you are asked to pretend to be the compiler and compile the code, or perhaps to piece some code together by filling in the blanks or … you get the picture...
The first edition of  this book was one of  our recommended titles for those new to Java and objects.
This new edition doesn’t disappoint and rightfully steps into the shoes of  its predecessor.
Head First Web Design is your ticket to mastering all of  these complex topics, and understanding what’s really going on in the world of  web design...If  you have not been baptized by fire in using something as involved as Dreamweaver, then this book will be a great way to learn good web design.
Is it possible to learn real web design from a book format? Head First Web Design is the key to designing user-friendly sites, from customer requirements to hand-drawn storyboards to online sites that work well.
What sets this apart from other ‘how to build a web site’ books is that it uses the latest research in cognitive science and learning to provide a visual learning experience rich in images and designed for how the brain works and learns best.
I definitely recommend Head First Web Design to all of  my fellow programmers who want to get a grip on the more artistic side of  the business.
Wouldn’t it be dreamy if there was a book to help me learn how to develop iPhone apps that was more fun than.
O’Reilly Media books may be purchased for educational, business, or sales promotional use.
Many of  the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and O’Reilly Media, Inc., was aware of  a trademark claim, the designations have been printed in caps or initial caps.
While every precaution has been taken in the preparation of  this book, the publisher and the authors assume no responsibility for errors or omissions, or for damages resulting from the use of  the information contained herein.
No PCs were harmed in the making of  this book.
To Dan, my best friend and husband, and Vinny and Nick, the best boys a mother could ask for.
This book is dedicated to my family: my parents who made all of this possible, my brothers who keep challenging me, and my wife and sons, who don’t just put up with it—they help make it happen.
Dan’s previous Head First books are Head First Software Development and Head First Algebra, so he’s used to them being a little out of  the ordinary, but this is the first book to involve bounty hunters.
Even scarier was watching Tracey shift to become a night owl and Apple fan-girl to get this book done.
Dan’s degree is in Computer Science with a minor in Mathematics from Virginia Tech and he is one of  the instructors for the O’Reilly iPhone Development Workshop.
Tracey Pilone would first like to thank her co-author and husband for sharing another book and being relentless in his willingness to stay up late to get things right.
She is a freelance technical writer who supports mission planning and RF analysis software for the Navy, and is the author of  Head First Algebra.
Before becoming a writer, she spent several years working as a construction manager on large commercial construction sites around Washington, D.C.
There she was part of  a team responsible for coordinating the design and construction of  office buildings, using engineering and management skills that somehow all came in handy writing Head First books.
Here you are trying to learn something, while here your brain is doing you a favor by making sure the.
Here’s what YOU can do to bend your brain into submission xxvii.
Going mobile1 The iPhone changed everything.It’s a gaming platform, a personal organizer, a full web browser, oh yeah, and a phone.
The iPhone is one of the most exciting devices to come out.
All you need to release your own app are a couple of software.
There’s a lot of  buzz and a lot of  money tied up in the App Store...
OK, actually, they don’t have any real moving parts, but they do have lots of UI.
A typical iPhone app has more going on than just a button, and now it’s time.
Working with some of the more complicated widgets means you’ll need.
A table with a viewMost iPhone apps have more than one view.We’ve written a cool app with one view, but anyone who’s used an iPhone knows that most apps aren’t like that.
I need to know a ton of drink recipes every.
That’s the story of every app! You get some functionality working, decide to add something else, need to do some refactoring, and respond to some feedback from.
Developing an app isn’t always ever a linear process, but there’s a lot to.
Modal views focus the user on the task at hand...
DrinkMixer is great—it uses some cell customization, and works with plist dictionaries to display data.
In this chapter we’ll take a look at editing patterns in iPhone apps and.
Enterprise appsEnterprise apps mean managing more data in different ways.
Companies large and small are a significant market for iPhone apps.
A small handheld device with a custom app can be huge for companies that have staff on.
Most of these apps are going to manage lots of data, and iPhone 3.x has.
Working with that and another new controller, the tab bar.
Things are changingWe have a great app in the works.
But what about when the data has to change? Bob wants some new functionality, and what does that do to.
Next we need to change the search to use the controller...
Proof in the real worldThe iPhone knows where it is and what it sees.
As any iPhone user knows, the iPhone goes way beyond just managing data: it can also take pictures, figure out your location, and put that information together for use in your app.
The top 6 things (we didn’t cover) appendix i, leftovers.
At least, not if you want to be able to carry.
So take a peek and see what you (still) might be missing out on.
Get ready for the App Store appendix ii, preparing your app for distribution.
Intro I can’t believe they put that in an iPhone development book!
So why DID they put that i n an iPhone development book.
Note from marketing: this book is for anyone with a credit card.
Do you want to learn, understand, remember, and apply important iPhone design and development concepts so that you can write your own iPhone apps, and start selling them in the App Store?
Do you prefer stimulating dinner party conversation to dry, dull, academic lectures?
Are you already developing iPhone apps and looking for a reference book on Objective-C?
Are you afraid to try something different? Would you rather have a root canal than mix stripes with plaid? Do you believe that a technical book can’t be serious if there’s a bounty hunter in it?
It definitely helps if you’ve already got some object-oriented chops, too.
Experience with Mac development is helpful, but definitely not required.
Check out Head First Java for an excellent introduction to object-oriented development, and then come back and join us in iPhoneville.
It was built that way, and it helps you stay alive.
So what does your brain do with all the routine, ordinary, normal things you encounter? Everything it can to stop them from interfering with the brain’s real job—recording things that matter.
It doesn’t bother saving the boring things; they never make it past the “this is obviously not important” filter.
How does your brain know what’s important? Suppose you’re out for a day hike and a tiger jumps in front of  you.
This must be important! Don’t forget it! But imagine you’re at home, or in a library.
Or trying to learn some tough technical topic your boss thinks will take a week, ten days at the most.
It’s trying to make sure that this obviously non-important content doesn’t clutter up scarce resources.
Resources that are better spent storing the really big things.
And there’s no simple way to tell your brain, “Hey brain, thank you very much, but no matter how dull this book is, and how little I’m registering on the emotional Richter scale right now, I really do want you to keep this stuff  around.”
In recent studies, student s performed up to 40% be.
Your brain pays attention to things that are out of t.
We think of a “Head First” reade r as a learner.
If  you really want to learn, and you want to learn more quickly and more deeply, pay attention to how you pay attention.
Most of  us did not take courses on metacognition or learning theory when we were growing up.
We were expected to learn, but rarely taught to learn.
But we assume that if  you’re holding this book, you really want to learn about iPhone development.
And you probably don’t want to spend a lot of  time.
And since you’re going to build more apps in the future, you need to remember what you read.
To get the most from this book, or any book or learning experience, take responsibility for your brain.
The trick is to get your brain to see the new material you’re learning as Really Important.
Otherwise, you’re in for a constant battle, with your brain doing its best to keep the new content from sticking.
I wonder how I can trick my brain into remembering.
So just how DO you get your brain to think that iPhone development is a hungry tiger? There’s the slow, tedious way, or the faster, more effective way.
You obviously know that you are able to learn and remember even the dullest of  topics if  you keep pounding the same thing into your brain.
With enough repetition, your brain says, “This doesn’t feel important to him, but he keeps looking at the same thing over and over and over, so I suppose it must be.”
The faster way is to do anything that increases brain activity, especially different types of  brain activity.
The things on the previous page are a big part of  the solution, and they’re all things that have been proven to help your brain work in your favor.
For example, studies show that putting words within the pictures they describe (as opposed to somewhere else in the page, like a caption or in the body text) causes your brain to try to makes sense of  how the words and picture relate, and this causes more neurons to fire.
More neurons firing = more chances for your brain to get that this is something worth paying attention to, and possibly recording.
A conversational style helps because people tend to pay more attention when they perceive that they’re in a conversation, since they’re expected to follow along and hold up their end.
The amazing thing is, your brain doesn’t necessarily care that the “conversation” is between you and a book! On the other hand, if  the writing style is formal and dry, your brain perceives it the same way you experience being lectured to while sitting in a roomful of  passive attendees.
We used pictures, because your brain is tuned for visuals, not text.
As far as your brain’s concerned, a picture really is worth a thousand words.
And when text and pictures work together, we embedded the text in the pictures because your brain works more effectively when the text is within the thing the text refers to, as opposed to in a caption or buried in the text somewhere.
We used redundancy, saying the same thing in different ways and with different media types, and multiple senses, to increase the chance that the content gets coded into more than one area of  your brain.
We used concepts and pictures in unexpected ways because your brain is tuned for novelty, and we used pictures and ideas with at least some emotional content, because your brain is tuned to pay attention to the biochemistry of  emotions.
That which causes you to feel something is more likely to be remembered, even if  that feeling is nothing more than a little humor, surprise, or interest.
We used a personalized, conversational style, because your brain is tuned to pay more attention when it believes you’re in a conversation than if  it thinks you’re passively listening to a presentation.
We included loads of  activities, because your brain is tuned to learn and remember more when you do things than when you read about things.
We used multiple learning styles, because you might prefer step-by-step procedures, while someone else wants to understand the big picture first, and someone else just wants to see an example.
But regardless of  your own learning preference, everyone benefits from seeing the same content represented in multiple ways.
We include content for both sides of  your brain, because the more of  your brain you engage, the more likely you are to learn and remember, and the longer you can stay focused.
Since working one side of  the brain often means giving the other side a chance to rest, you can be more productive at learning for a longer period of  time.
And we included stories and exercises that present more than one point of  view, because your brain is tuned to learn more deeply when it’s forced to make evaluations and judgments.
We included challenges, with exercises, and by asking questions that don’t always have a straight answer, because your brain is tuned to learn and remember when it has to work at something.
Think about it—you can’t get your body in shape just by watching people at the gym.
But we did our best to make sure that when you’re working hard, it’s on the right things.
That you’re not spending one extra dendrite processing a hard-to-understand example, or parsing difficult, jargon-laden, or overly terse text.
In stories, examples, pictures, etc., because, well, because you’re a person.
And your brain pays more attention to people than it does to things.
These tips are a starting point; listen to your brain and figure out what works for you and what doesn’t.
Your brain works best in a nice bath of  fluid.
Dehydration (which can happen before you ever feel thirsty) decreases cognitive function.
Create something! Apply this to your daily work; use what you are learning to make decisions on your projects.
Just do something to get some experience beyond the exercises and activities in this book.
All you need is a pencil and a problem to solve… a problem that might benefit from using the tools and techniques you’re studying for the exam.
Feel something! Your brain needs to know that this matters.
Groaning over a bad joke is still better than feeling nothing at all.
If  you find yourself  starting to skim the surface or forget what you just read, it’s time for a break.
Once you go past a certain point, you won’t learn faster by trying to shove more in, and you might even hurt the process.
If  you’re trying to understand something, or increase your chance of  remembering it later, say it out loud.
Better still, try to explain it out loud to someone else.
You’ll learn more quickly, and you might uncover ideas you hadn’t known were there when you were reading about it.
Part of  the learning (especially the transfer to long-term memory) happens after you put the book down.
Your brain needs time on its own, to do more processing.
If  you put in something new during that processing time, some of  what you just learned will be lost.
They’re not optional sidebars—they’re part of  the core content! Don’t skip them.
We put them in, but if  we did them for you, that would be like having someone else do your workouts for you.
There’s plenty of evidence that physical activity while learning can increase the learning.
The more you understand, the less you have to memorize.
When the book asks you a question, don’t just skip to the answer.
The more deeply you force your brain to think, the better chance you have of learning and remembering.
Here’s what YOU can do to        bend your brain into submission.
Read me This is a learning experience, not a reference book.
We deliberately stripped out everything that might get in the way of  learning whatever it is we’re working on at that point in the book.
And the first time through, you need to begin at the beginning, because the book makes assumptions about what you’ve already seen and learned.
We start off by building an app in the very first chapter.
Believe it or not, even if  you’ve never developed for the iPhone before, you can jump right in and starting building apps.
You’ll also learn your way around the tools used for iPhone development.
We don’t worry about preparing your app to submit to the App Store until the end of book.
In this book, you can get on with the business of  learning how to create iPhone apps without stressing over the packaging and distribution of  your app out of  the gate.
But, we know that’s what everyone who wants to build an iPhone app ultimately wants to do, so we cover that process (and all it’s glorious gotchas) in an Appendix at the end.
We focus on what you can build and test on the simulator.
The simulator lets you try out your code without having to worry about getting it in the app store or on a real device.
There’s some cool iPhone stuff you just can’t test on the simulator, like the accelerometer and compass.
So we don’t cover those kinds of  things in very much detail in this book since we want to make sure you’re creating and testing apps quickly and easily.
The exercises and activities are not add-ons; they’re part of  the core content of  the book.
Some of  them are to help with memory, some are for understanding, and some will help you apply what you’ve learned.
Even crossword puzzles are important—they’ll help get concepts into your brain the way you’ll see them on the PMP exam.
But more importantly, they’re good for giving your brain a chance to think about the words and terms you’ve been learning in a different context.
One distinct difference in a Head First book is that we want you to really get it.
And we want you to finish the book remembering what you’ve learned.
Most reference books don’t have retention and recall as a goal, but this book is about learning, so you’ll see some of  the same concepts come up more than once.
For some of  them, there is no right answer, and for others, part of  the learning experience of  the Brain Power activities is for you to decide if  and when your answers are right.
In some of  the Brain Power exercises, you will find hints to point you in the right direction.
System requirements To develop for the iPhone, you need an Intel-based Mac, period.
We wrote this book using Snow Leopard and Xcode 3.2
If  you are running Leopard with an older version of  Xcode, we tried to point out where there were places that would trip you up.
For some of  the more advanced capabilities, like the accelerometer and the camera, you’ll need an actual iPhone or iPod Touch and to be a registered developer.
In Chapter 1, we point you in the direction to get the SDK and Apple documentation, so don’t worry about that for now.
For this book we had an amazing, elite group of  tech reviewers.
They did a fantastic job, and we’re really grateful for their incredible contribution.
Joe Heck is a software developer, technology manager, author, and instructor who’s been involved with computing for Media Group, Joe is involved in various technologies and development platforms, and assisted the development team for Disney’s iPhone game “Fairies Fly.” He’s the founder of  the Seattle Xcoders developer group, which supports Macintosh and iPhone development in the Seattle area, and the author of  SeattleBus, an iPhone app that provides realtime arrival and departure times of  Seattle public transportation (available at the iPhone App Store)
He also knows a ton about iPhones, and made sure that we were technically solid in every facet of  the book.
His attention to detail means that all of  our nitty gritty answers are complete and correct.
Eric Shepherd got started programming at age nine and never looked back.
He’s been a technical writer, writing developer documentation since 1997, and is currently the developer documentation lead at Mozilla.
In his spare time, he writes software for old Apple II computers—because his day job just isn’t geeky enough—and spends time with his daughter.
His input meant that any typos or bugs we left in the code were caught and fixed.
His thorough review means that no one else has to go through the problems he had in actually making the code work.
Michael Morrison is a writer, developer, and author of  Head First JavaScript, Head First PHP & MySQL, and even a few books that don’t have squiggly arrows, stick figures, and magnets.
Michael spends a lot of  time wearing helmets, be it for skateboarding, hockey, or iPhone debugging.
Since he has iPhone Head First experience, Mike was a great combo to have helping us.
Reviewing in both capacities, he was nice enough to always propose a solution for us when he found a layout problem, which makes those comments easier to take!
All three of  these guys did a tremendous amount of  review at the end in a short period of  time and we really appreciate it! Thanks so much!
Thanks to Courtney Nash, who was there from the beginning and took us through to production, which normally is a long time, but not for us! She pushed us to make sure that every step of  the way the book stayed true to its Head First title, even when it would’ve been WAY easier not to.
And to Brett McLaughlin, who started us off  on this book by responding to an IM that said “What do you think about Head First iPhone?” and got it turned into a book.
He also played the learner (complete with the occasional complaining) for us throughout the book and was a big help in pacing the initial chapters.
And also to Laurie Petrycki, who trusted us to do another Head First book less than a year after the last one.
Finally, to our design editor Mark Reese for his graphics and layout help.
To all of  the Pilones and the Chadwicks, who put up with a lot being pushed until October while we worked on the book and gave us the support we needed to become grown ups who can write this stuff.
To Dan’s brother, Paul, whose relentless “Seriously, Macs are awesome” mantra convinced Dan to get one and find out what all this OS X development stuff  is about.
To Vinny and Nick, who put up with a good bit of  shuffling around the past couple of  months so we could get this done, and are totally going to get some major Mommy and Daddy time now.
To our friends who listened to the whining about getting this thing done and who took the kids for a couple hours here and there so we could get finished and encouraged us when we needed it!
Finally, to Apple, as silly as it sounds, because without the iPhone being such a unique and gamechanging device, there would be no book!
With a subscription, you can read any page and watch any video from our library online.
Access new titles before they are available for print, and get exclusive access to manuscripts in development and post feedback for the authors.
Copy and paste code samples, organize your favorites, download chapters, bookmark key sections, create notes, print out pages, and benefit from tons of  other time-saving features.
To have full digital access to this book and others on similar topics from O’Reilly and other publishers, sign up for free at http://my.safaribooksonline.com.
It’s a gaming platform, a personal organizer, a full web-browser, oh yeah, and a phone.
All you need to release your own app are a couple of software tools, some.
Apple provides the software, and we’ll help you with the.
I just don’t see what all this iPhone fuss is about.
There’s a lot of buzz and a lot of money tied up in the App Store...
Apple’s App Store celebrates 1st birthday Apple launched its acclaimed App Store one year ago and since.
While many apps up for sale are free, many are not, and.
Developers have been leveraging the capabilities of  the iPhone in.
Even users of  the iPod Touch can also download the apps to their devices.
Many people try several new apps a day, and you can install enough apps on your phone to fill several screens....
There are about a billion good reasons to get into the App Store, and now it’s time for you to jump in.
To get there from here, you’ll learn about designing and implementing an iPhone app, but it’s not the same as developing for the desktop, or writing a web application.
It’s important to think an iPhone application through from the beginning.
You need to constantly ask yourself  “What is it the user is trying to do?” Get rid of  everything else, minimize the input they have to provide, and keep it focused.
Check the factors that you need to consider when you’re working on a mobile app, in general.
You need to put real thought into every screen and keep it focused on the specific task the user is doing.
Only one application can run at a time If  it’s your application running, why should you care? Because if  anything else happens, like the phone rings, a text message comes in, the user clicks on a link, etc., your app gets shut down and the user moves on to another application.
You need to be able to gracefully exit at any time and be able to put users back into a reasonable spot when they return.
That’s definitely true, but it doesn’t mean iPhone apps are just small desktop apps.
Some of  the most important issues that you’ll encounter designing an app for the iPhone:
Mobile devices have limited memory and a lot of it is already allocated.
Mobile device users don’t have a lot of time, so apps need to load and work quickly.
Sending texts or accessing the Internet costs money for some mobile users.
The Net is not always available for the mobile user - and it’s typically slow.
Typical mobile devices have different display sizes and resolutions, and you need to plan for that...
Some mobile devices use arrows, some have extra buttons, and others have touch screens.
Check the factors that you need to consider when you’re working on a mobile app, in general.
And while there is a keyboard available, it’s all touch screen!
Anatomy of an iPhone app Before we dive into creating our first app, let’s take a look at what makes up a typical iPhone app.
Games have views too, but typically don’t use the normal GUI components.
Games generally require their own custom interfaces that are created with things like OpenGL or Quartz.
In general, each view has a View Controller behind it that reacts to button presses, table row selection, tilting the phone, etc.
This code is almost always written in Objective-C using Apple’s IDE (integrated development environment), Xcode.
If  you’re new to developing for OS X you might be surprised to find out that applications (iPhone and full desktop apps) are really just directories.
Mike can’t make a decision Mike’s a great guy, but he never knows what he wants to do.
Help him save time waffling about what to do, and give him a straightforward answer.
The way I see it is I already made the decision to buy an iPhone...
Mike has an iPhone, so let’s write him an app that requires a simple button push to tell him what to do when he needs to make a decision.
Make a good first impression When users start up your application, the first thing they see is your view.
It needs to be usable and focused on what your application is supposed to do.
Throughout this book, whenever we start a new application, we’re going to take a little time to sketch up what we want it to look like.
Our first application is pretty straightforward: it is going to be a single view with a button that Mike can press to get a decision.
To keep things simple, we’ll change the label of  the button to show what he should do after he pushes it.
Press the button and the label text will change to tell Mike w.
Now that we know what to build, let’s get into the tools.
This is the iPhone simulator - this lets you run and test your application without using a real phone.
This is the status bar - your app can choose to hide it, but unless you’re writing a game, you should probably leave it.
It all starts with the iPhone SDK It’s time to go get some tools.
You can download the SDK (and other useful Apple development resources) for free with the basic registration, but to distribute a completed app on the App Store or install your app on the iPhone for testing you need to become a paid Standard or Enterprise Developer.
The SDK comes with a simulator for testing directly on your Mac, so free registration is all you’ll need for now.
Code for the iPhone is written in Xcode using Objective-C.
Interface Builder is used for graphically editing GUIs, Instruments helps you assess memory usage and performance for your app, and the Simulator is used for testing.
Download the latest SDK; this book is based on the Download button at the top of  the page.
You will probably want to drag it onto your Dock—we’re going to be using it a lot.
Q: What are the most important things to consider when developing a mobile app?
A: There are two key things to keep in mind when developing a mobile application.
First, the device has limited resources: memory, CPU, storage, Net access speed (if they have access at all), etc.
Mobile apps are generally convenience applications—users want to fire up your application, quickly accomplish their goal, and go back to what they were doing in the real world.
Q: I’ve developed for mobile platforms before, and it was a mess.
Nothing worked the same between different devices, you couldn’t count on the screen size, they didn’t even have the same number of buttons on different devices! Is this any better?
A:YES!  For the most part, developing for iPhone avoids these problems.
Q: There are several different models of the iPhone out there.
Are they all the same? What about the iPod Touch?
A: Not all iPhone and iPod Touch devices are the same.
For example, not all devices have a camera or GPS.
Net access speeds vary by device as well depending on whether.
To make matters more complicated, the iPhone 3GS has a faster processor and better video card than previous iPhone models.
If you take advantage of any features that might not be present on all devices you must make sure your code can handle not having that feature available.
Apple will test for this (for example, trying to use the camera on a first generation iPod Touch) and reject your application if it doesn’t accomodate a device properly.
Q: What language does the iPhone use? A: iPhone apps are generally written in Objective-C, an object-oriented language that is also used for Mac development.
However, you can use C and even C++ on the iPhone.
Since the GUI and Core Framework libraries for the iPhone are written in Objective-C, most developers use Objective-C for their application; however, it’s not uncommon to see support libraries written in C.
Q: Do I have to use an IDE? I’m really a command-line kinda developer.
A: Technically speaking, no, you don’t have to use the Xcode IDE for straight development.
However, the IDE makes iPhone development so much easier that you really should ask yourself if you have a good reason for avoiding it, especially since to deploy onto an actual iPhone or the simulator for testing, it’s mandatory.
This book uses the Xcode IDE as well as other.
Apple development tools like Interface Builder, and we encourage you to at least try them out before you abandon them.
Q: Can I give applications I write out to friends?
First, if you want to put an application on anyone’s actual device (including your own) you’ll need to become a registered Apple iPhone Developer.
Once you’ve done that, you can register a device and install your application on it.
However, that’s not really a great way to get your application out there, and Apple limits how many devices you can register this way.
It’s great for testing your application, but not how you want to go about passing it around.
A better way is to submit your application to the iTunes App Store.
We’ll talk more about distributing apps later in the book.
Q: Can I develop an app for the iPhone then rebuild it for other phones like Windows Mobile, Android, or Blackberries?
When you develop for iPhone, you use Apple’s iPhone frameworks, like Cocoa Touch, as well as Objective-C.
Xcode includes app templates to help you get started When you start Xcode, you’ll get a welcome screen where you can select Create a New Project.
This is the very same Xcode that you’d use to develop for the Mac.
Since we’re working with the iPhone, make sure iPhone OS Application is selected..
Based on your selection, different code and files are populated for you.
As we go through the book, we’ll use different types of  projects and discuss why you’d choose one over another for each app.
For iDecide, we have one screen (or view) that we’re not going to be flipping or anything, so start with the View-based Application and name it iDecide.
If you click on each project type, the description here will help fill you in on some details.
Header files describe the interface for the classes in the project you selected.
Databases, plists, and other types of data are stored in here for your app.
This is the folder where you’ll store the icon for your app and any other images you need.
Xcode will generate at least one view for your template, which is a *.xib file.
The .m files contain the basic implementation files for the app type you selected.
The frameworks that your template type needs are already included.
Frameworks are development libraries - depending on what your application does, you’ll need different frameworks.
For example, there’s a MapKit framework, a Core Data framework, etc.
When Xcode opens with your new View-based project, it will be populated with all of  the files that you see below.
We’ll be using some of  the other tools that came with the SDK (especially Interface Builder and the Simulator), but they are all working with the files that are included here.
The files and frameworks shown were stubbed out based on our selection of  a View-based application.
As we go forward, we’ll use different types of  apps and that will lead to different defaults.
Class files are the Objective C files that your App will use - most code will be written here.
Resources contains all of your Interface Builder (.xib) files, pictures, data, and other stuff that your app will need to run.
The Detail View shows a list of the selected files.
The Editor Pane shows your file with the appropriate editor loaded and allows you to work directly with the code, plist, whatever.
You don’t have to group your files this way, but this is the default from the template.
This grouping works well for us, so we’ll leave it alone.
Here is where you can configure whether to build your app for the simulator or a real device.
As you’ve already seen, Xcode includes the templates to get you started developing an application.
Depending on your application, you may use all of  a template or just parts of  it, but you’ll almost always start with one of  them.
Once you get your basic app template in place, you’ll use Xcode for a lot more:
Maintaining your project resources Xcode will create a new directory for your project and sort the various files into subdirectories.
You don’t have to stick with the default layout, but if  you decide to reorganize, do it from within Xcode.
Xcode also has built-in support for version control tools like Subversion and can be used to checkout and commit your project changes.
Editing your code and resources You’ll use Xcode to edit your application code, and it supports a variety of  languages beyond just Objective-C.
Xcode also has a number of built-in editors for resource files like plists (we’ll talk more about them later on)
For resources Xcode doesn’t handle natively, like UI definition (.xib) files, double-clicking on one of  those files in Xcode will launch the appropriate editor, in this case Interface Builder.
Some file types Xcode can only view, like pictures, or it will merely list, like sound files.
Building and testing your application Xcode comes with all of  the compilers necessary to build your code and generate a working application.
Once your application is compiled, Xcode can install it on the iPhone Simulator or a real device.
Xcode includes a top-notch debugger with both graphical and command-line interfaces to let you debug your application.
You can launch profiling tools like Instruments to check for memory or performance issues.
Prepare your application for sale Once you get your application thoroughly tested and you’re ready to sell it, Xcode manages your provisioning profiles and code signing certificates that let you put your application on real devices or upload it to the iTunes App Store for sale.
Interface Builder When you open any *.xib file in Interface Builder, it will automatically show the Main window, your view, and a library of  UI elements.
Interface Builder allows you to drag and drop any of  the basic library elements into your view, edit them, and work with the connections between the code and these elements.
All of  these elements come from the Cocoa Touch framework, a custom UI framework for the iPhone and the iPod Touch.
It shows the objects and views that are currently created for that particular nib.
File’s Owner and the First Responder exist for every nib, and the others will vary.
The library shows all of the elements you can choose from to drop into your view.
If you scroll around, you’ll see there are a lot of options.
Views for iPhone Apps are called nibs, and have an .xib extension.
Nibs (which have .xib extensions) are XML documents that are loaded by the framework when the app starts up.
We’ll talk a lot more about this in the next chapter, but for now it’s just important to understand that Interface Builder is not creating Objective-C code.
It’s creating an XML description of  the GUI you’re building, and the Cocoa Touch framework uses that to actually create the buttons and whatnot for your application at runtime.
Everything we do in Interface Builder could be done in pure Objective-C code, but as you’ll see, there are some things that are really just easier to lay out with a GUI builder.
I guess it just spits out Objective-C code into my files?
And that view is what the user sees when they run our app.
Add the button to your view To add elements to the view, all you need to do is drag and drop the elements you want onto your view.
For our app, we just need a button with a label on it.
The initial size of  the button will be small, so resize it to be a bit bigger.
Now, save in Interface Builder and return to Xcode and click Build and Run, either from the Build menu or from the button in the main Xcode window.
The iPhone Simulator lets you test your app on your Mac The Simulator is a great tool for testing your apps quickly and for free.
It doesn’t come with all of  the applications that a real phone does, but for the most part it behaves the same way.
When you first start the simulator you see the Springboard, just like on a real iPhone, with iDecide installed (and a default icon that you can change later)
Xcode then opens the app and your code is running.
There are some differences between using the Simulator and your iPhone.
For starters, shaking and rotating your Mac won’t accomplish anything.
To approximate rotation and check landscape and portrait views, there are some commands under the Hardware menu.
Memory, performance, camera, GPS, and other characteristics cannot be reliably tested using the Simulator.
We’ll talk more about these later, but memory usage and performance are tough to test on the simulator simply because your Mac has so many more resources than the iPhone.
Q: Are there other things that don’t work on the Simulator?
A: The Simulator can only work with some gestures, network accessibility and core location are limited, and it doesn’t have an accelerometer or camera.
For more information, reference Apple’s iPhone OS 3.0 Library documentation, via the Help menu in the Simulator.
The Simulator is great for getting started with your application, but at some point you have to move over to a real device.
You really should test on both, which means you’ll need to join one of the paid programs.
Q: What’s with this whole nibs have a xib extension thing?
A: That’s an odd artifact showing the roots of OS X.
Nibs date back to the NeXTStep days, before NeXT was acquired by Apple.
In OS X Leopard, Apple released a new format for nib files based on an XML Schema and changed the extension to xib.
You’ll see more NeXTStep heritage in library class names too—almost everything starts with “NS”, short for NeXTStep.
Q: Why didn’t anything happen when I clicked on the button in the Simulator?
A: It’s temping to expect that button to just work out of the gate, given how much XCode sets up for you.
However, if you think about what we’ve done, there has been some XML created to load a framework and draw a button, but we didn’t tell it to do anything with that button yet...
Interface Builder creates your button, but to make that button actually do something, you’ll need to code what it should do.
Controls trigger events in Objective-C when things happen to them, like the button being pressed or text changing in a text field.
For events like button presses, Interface Builder has to connect the view controls with code in your controller class for action methods, tagged with IBAction (for Interface Builder Action)
We’ll talk more about the Objective-C syntax later, but for now, you’ll need to declare a method in your header (.h) file and the implementation in the .m.
OK, so Interface Builder created XML, but we still need to write code to implement the button press, right?
Here’s where you code up what should actually happen when the button is pressed.
Below is the code for when the button gets tapped.
We’ll need to change the label text to provide Mike’s answer, so we need to be able to get to the label control that the framework will build from our nib.
This is the implementation of the method that gets called when the button is pressed.
We’ll use our reference to the label to change the text.
This code is typical of what you’ll see in a header file.
There’s a declaration of the new IBOutlet and IBAction, and a property for our UILabel.
The IBAction is dealing with what happens when the button is pressed, and the IBOutlet is a reference to the label we’ll use for output text for the button.
We’ll look at both of these in more detail later.
Here, we’re defining the method that is called when the button is pressed.
We use a constant string to change the text in the label.
Remember, decisionText is a reference to the UILabel we created in Interface Builder.
The release call is for memory management Objective-C uses reference counting for memory management (we’ll talk more about this in a bit) and needs to be released to free up the memory.
Try clicking on the button and see if  it works.
Why didn’t the button change? Since the code compiled correctly, it’s not that...
What happened? The Objective-C code is all set to handle it when the button is pressed, but Interface Builder has no idea it needs to connect the button to that code.
We can use Interface Builder to hook up our button to the buttonPressed method we just wrote.
Then, when the .xib file is loaded by the framework, it will connect the button object it creates with our code.
Unless the UI components are hooked up to the code, nothing is going to happen.
We need to connect the button’s “Hey, I just got pressed” event to our buttonPressed action method.
That will get our method called when the user taps on the button.
We then need to get a reference to the UILabel that the framework is going to create for us when the nib is loaded—that’s where the IBOutlet comes in.
Let’s start with the outlet so we can change the UILabel text when the button is pressed.
Hit this button to display the hierarchy view; it’s a little easier to see what’s going on with the nib.
A list of everything in your view, plus its class name.
This will bring up a list of  events and references.
Now when the decisionText UILabel is generated, our decisionText property will be set to a reference to the control, thanks to the IBOutlet.
Ok—I get how we can now change the label, but how does interface builder know that you pressed a button?
If you don’t have a two button mouse, just hit CTRL and then click.
Interface Builder lists which events a component can trigger We need to attach the right component event to the code.
We wrote an action method earlier that we can connect the button to:
The name can be anything, but the method must have one argument of type (id)
Now we need to pick the event that should trigger this method.
If  you right-click on the button in Interface Builder, you’ll see a list of  events it could dispatch.
Elements dispatch events when things happen to them Whenever something happens to an element, for instance, a button gets tapped, the element dispatches one or more events.
What we need to do is tell the button to notify us when that event gets raised.
If  you think about how you click a button on the iPhone, the actual click inside the button isn’t what matters: it’s when you remove your finger (touch up) that the actual tap occurs.
Connecting an event to a method is just like connecting an element to an outlet.
Connect your events to methods Just like with outlets, you drag the connection from the button event to File’s Owner and select the action that should be called.
This will bring up a list of  events and references like it did with the label.
Next click on the circle next to Touch Up Inside and drag it to File’s Owner.
Now when the button gets pressed, our buttonPressed method will be called.
So does it really matter whether I use an IBOutlet or an IBAction since Interface Builder can use both?
Use an IBOutlet when you need a reference to something in the interface (e.g., so you can change the label text)
Use an IBAction when you want a control to tell your code when something happens (like the button gets pressed)
My job is to kick off  a method when something happens—an event.
You just sit there and point to stuff  going on.
Yeah, but when the user does something, I make it happen! I do the saving, I do the actual clicking!
Well, for starters, the “IB” in IBAction stands for Interface Builder!
Anyway, Interface Builder knows when I’m around that some event in a nib can set me off  and keep me informed.
Listen, it’s true that I’m just an instance variable that works with an object in a nib, but that doesn’t mean I’m not important.
Test Drive Now that everything is hooked up, it’s ready to run.
Make sure that you save in Interface Builder and then go back into Xcode and build and run.
You know, there is one thing that you have that I’ve always wanted.
You can be anything! Stick IBOutlet in front of any variable name and you’re good.
I have more complicated syntax, because I need to have the idea of  a sender in there.
Without me, the code couldn’t change anything in the UI.
An IBOutlet variable can point to a specific object in the nib (like a text field or something), and code (yes, probably your code) can use me to change the UI, set a text field’s content, change colors, etc.
I do like the freedom! Glad we could work things out.
You’re on your way to being #1 on the App Store.
Your app is working! All the pieces are fitting together: the *.xib file describes the interface, Interface Builder has connected it to the code, and Objective-C is making it all work together.
You can change what class Interface Builder thinks it will be, but by default a new project is set up so that the main View Controller created by Xcode is the File’s Owner for the main view created by Xcode.
The same thing happened with the TouchUpInside event, except in this case instead of hooking up a component to a reference, it hooked up a component’s event to a method that should be called.
Beware—Interface Builder’s expectation of the class that will load the nib does not mean that other classes can’t try—it just might not work well if that class doesn’t have the necessary properties and methods.
Q: What’s with the “Outlet” stuff? A: Interface Builder has the idea of.
Outlets and Actions, and we’ll talk more about them in a bit.
Basically an Outlet is a reference to something and an Action is a message (method) that gets sent (called) when something happens.
Q: Why does our new text string have an @ in front of it?
A: Cocoa Touch uses a string class named NSString for its text strings.
Since it’s so common, Objective-C has built in support for creating them from constants.
You indicate a string constant should be an NSString by putting an @ symbol in front of it.
Otherwise, it’s just a normal char* like in C or C++
Interface Builder creates nib files (with a .xib extension) that describe the GUI in XML.
Nib files are loaded by the Cocoa Touch framework and are turned into real instances of Cocoa Touch classes at runtime.
In order to connect the components described in a nib to your code, you use IBOutlets and IBActions.
Xcode is where your code and files are maintained for your application.
Xcode is the hub for your project development and offers support for editing your code, building your application, and debugging it once it’s running.
The iPhone Simulator lets you test your application on your Mac without needing a real device.
A typical iPhone plan that is different from most other mobile phones.
Maintaining and editing code and resources, debugging code, and preparing an app for deployment.
Indicates a method that can be called in response to an event.
A typical iPhone plan that is different from most other mobile phones.
Maintaining and editing code and resources, debugging code, and preparing an app for deployment.
Indicates a method that can be called in response to an event.
The term to describe each screen of an iPhone app.
The folder used to organize  the images for the app.
These are used in Xcode to provide classes to be accessed.
This is used on a desktop to test an app.
This is the name of the editor used for Objective-C.
The name of a file used to create a view.
The term to describe each screen of an iPhone app.
The folder used to organize  the images for the app.
These are used in Xcode to provide classes to be accessed.
This is used on a desktop to test an app.
This is the name of the editor used for Objective-C.
The name of a file used to create a view.
Your iPhone Toolbox You’ve got Chapter 1 under your belt and now you’ve added basic IPhone app interactions to your tool box.
Images and other data are referenced together in Xcode so that all of  the files that you need can be easily dealt with.
Views are constructed in Interface Builder A view is made up of  nib (*.xib) files and the GUIs are edited with Interface Builder.
This code is almost always written in Objective-C using Xcode.
OK, actually, they don’t have any real moving parts, but they do have lots of UI controls.
In this chapter, you’ll learn about some of the fundamental design patterns used in.
He has a great girlfriend, Renee, but they’ve been having some problems.
She thinks that he doesn’t talk about his feelings enough.
That would be perfect: I can just tweet about my feelings and then she’ll be happy.
Using some solid design and the basic controls included in the Interface Builder library, you can have Mike posting to Twitter in no time.
First we need to figure out what Mike (really) wants Mike isn’t a complex guy.
He wants an easy interface to talk to Twitter and he really doesn’t want to have to type much.
Here’s what Mike handed you at the end of the night.
App Magnets Now that we know what Mike wants, what do we need to do? Take the magnets below and put them in order of the steps you’ll follow to build his Twitter app.
App Magnets Solution Now that we know what Mike wants, what do we need to do? Take the magnets below and put them in order of the steps you’ll follow to build his Twitter app.
Before you start coding anything, sketch up what you’re thinking.
Some people write backend code first - we’re going to go back and forth depending on our project, but to get started, we’ll do the GUI first this time.
Here we need to manage the data coming from the controls...
A: We’re going to give you a couple to choose from to get started, but in general, it’s important to think about what your app needs to do and focus on those features first.
Q: Are we always going to start with a sketch?
A: Yes! Good software design starts with knowing what you’re building and how.
The app for Mike is going to work with Twitter, and he’s going to be able to make some selections for his feelings and thoughts.
Q: How do we talk to Twitter? A: Don’t worry, we’ll give you some code to help you to work with that.
We’ll give you what you need, but feel free to add more features!
A: For the most part, no—once you learn a few basic patterns, you’ll be able to find your way through most of the SDK.
Some of the controls have a few peculiarities here and there, but for the most part they should start to look familiar.
Based on aesthetics, usability, and standard iPhone app behavior, which one is better for Mike?
Based on aesthetics, usability, and standard iPhone app behavior, which one is better for Mike?
Option #2 has a lot less typing and fewer fields overall.
Since the user doesn’t need to change his username or password often there’s no reason to put it on the main view every time he runs the app.
Option #1 has a lot of typing and settings to remember.
Cancel what? iPhone apps almost never have “Quit” type buttons.
If the user changes his mind, he hits the home button and the app is shut down.
This is the one you’re going to build for Mike.
Instead of having Mike type in what he’s doing and his feelings, we can give him a picker to selec.
Q: Do I really need to care about usability and aesthetics so much?
A: Usability and aesthetics are what made the iPhone a success, and Apple will defend them to the death.
Even more importantly, you don’t get to put anything on the App Store or on anyone else’s iPhone without their approval.
Apple has sold over a billion apps—if yours doesn’t fit with the iPhone look and feel or is hard to use, people will find someone else’s app and never look back.
Q: We got rid of the username, password, and URL fields.
The URL one I understand, but what about the other two?
A: Anytime your app needs configuration information that the user doesn’t need to change frequently, you should keep it out of the main task flow.
Apple even provides a special place for these called a Settings bundle that fits in with the standard iPhone settings.
We’re not going to use that in this chapter (we’ll just hardcode the values) but later we’ll show you how to put stuff in the Settings page.
That’s usually the right place for things like login details.
Q: How am I supposed to know what Apple thinks is good design or aesthetically pleasing?
App design rules—the iPhone HIG The iPhone Human Interface Guide (HIG) is a document that Apple distributes for guidance in developing iPhone Apps for sale on the App Store.
This isn’t just something nice they did to help you out; when you submit an app for approval, you agree that your app will conform to the HIG.
We can’t overstate this: you have to follow the HIG, as Apple’s review process is thorough and they will reject your application if  it doesn’t conform.
Apple also distributes a few other guides and tutorials, including the iPhone Application Programming Guide.
This is another great source of information and explains how you should handle different devices, like the iPhone and the iPod Touch.
Not paying attention to the iPod Touch is another great way to get your app rejected from the App Store.
Application types The HIG details three main types of  applications that are commonly developed for the iPhone.
Each type has a different purpose and therefore offers a different kind of  user experience.
Figuring out what type of  application you’re building before you start working on the GUI helps get you started on the road to good interface design.
Info is hierarchical, and you navigate by drilling down into more levels of detail.
Games are a classic example, but like this simulated level, all immersive apps require a very custom interface that allows the user to interact with the device.
As a result, HIG guidelines aren’t as crucial in this case.
For each one, think about what kind of app it really is and match it to the app types on the right.
News Reader: Gives you a list of the news categories and you can get the details on stories you choose.
Marble Game: A marble rolling game that uses the accelerometer to drive the controls.
Stopwatch Tool: Gives you a stopwatch that starts and stops by touching the screen.
Recipe Manager: A meal listing that allows you to drill down and look at individual recipes.
News Reader: Gives you a list of the news categories and you can get the details on stories you choose.
Marble Game: A marble rolling game that uses the accelerometer to drive the controls.
Stopwatch Tool: Gives you a stopwatch that starts and stops by touching the screen.
Recipe Manager: A meal listing that allows you to drill down and look at individual recipes.
Since we have one screen and no typing, InstaTwit is more of a Utility App.
Since this App has a list-driven, drill-down interface, it’s Productivity.
Using the accelerometer as the control and a big rolling marble...
We want a very focused stopwatch GUI, no real data to work through.
Lots of data to work through here: tables, a drill-down to recipes—definitely productivity.
Before you build the view with your controls, it’s a good idea to take a quick look at the recommendations from Apple.
The picker’s overall size is fixed, although you can hide it or have it be part of the view (like we do in InstaTwit)
If you have units to display, they need to be fixed to the selection bar here.
The rounded rectangle button is pretty straightforward, but keep in mind it should always perform some kind of action.
The new project type is not necessarily the same as your app type.
Start with the view layout Now that we have the autogenerated code, we’re going to start working with the interface.
To do that, we’ll be editing the nib (.xib) file.
We’ll be working with these other project types later in the book.
Using drag and drop, pull over the elements from the Interface Builder library that you need to build the view.
Find each of  the elements (we’ve given them the proper name for you) in the library and drag and drop them into the View window.
Edit the labels and button text for the title, “I’m”, “and feeling”, and “about it”, as well as the title for the button.
Once you save it, your view should look like this...
Once you tweak everything to look just how you want it, we’ll run InstaTwit.
Filling in the picker data requires some code, and we’ll get to that in a minute.
The inspector for the button is slightly differentthe title is further down in the window.
Did you notice the blue guidelines in the simulator? They’re in the view when you’re laying out elements to help you center things and keep them lined up with each other.
The picker isn’t showing up because there isn’t any data yet...
To get the picker to show, it needs to have data to fill it.
Where do you think that the code for the data should go?
The life of a root view In Chapter 1 we touched on how Interface Builder creates XML descriptions of  your view, called a nib, and that the Cocoa Touch framework turns that into a real view in your application.
Now that you’ve built a couple apps, let’s take a closer look at what’s going on under the hood.
When your application is launched by the user, the iPhone provides a quick animation of  your app zooming into the screen (this is actually a PNG file you can include with your app), then calls your main method.
Main is provided by the templates and you almost never need to touch it.
With the View template we used, it’s a nib called MainWindow.xib.
When we constructed the nib, we used the File’s Owner proxy object to stand in for the object that owns the nib contents.
When events occur with components, methods are invoked on our controller instance.
The actions we associated between the controls and the File’s Owner in the nib were translated into connections between the controls and our instance.
The nib file contains serialized instances of objects as we configured them.
They are usually control objects like buttons or labels, but can be anything that can be serialized.
Now let’s put this knowledge to use and add some data for the picker.
Obviously, different people will have differing opinions about what UI looks better.
However, Apple has very specific guidelines about how certain controls should be used and best practices that should be followed.
In general, if you’re using a common iPhone control, make sure you’re using it in a way that’s consistent with existing applications.
Q: How can I run these apps on my iPhone?
A: To get an app you write installed on your iPhone you’ll need to sign up for either the Standard or Enterprise Developer programs at http://developer.apple.com/ iphone/
Everything in this book is designed to work with just the Simulator, so don’t feel like you need to go do that just yet.
We’ll talk more about putting apps on an actual phone later in the book.
A: The icon for an application is just a PNG file in your project.
We’ll add and configure icons later, but for now, just know that you’ll need a .png file in the resources directory for that purpose—we’ll hook you up with some cool icons later.
Everything that you do in Interface Builder can be done in code.
Interface Builder makes it a lot easier to get things started, but sometimes you’ll need that codelevel control of a view to do what you want.
We’ll be switching back and forth depending on the project and view.
Q: I’m still a little fuzzy on this nib thing.
When you assemble a view using Interface Builder, it keeps track of the controls you’re using and the links to other classes.
These controls are serialized into an XML document; when you save it out, this is your nib.
When the nib is restored from disk, objects in the nib are reinstantiated and populated with the values you gave them in Interface Builder.
File’s Owner represents whatever class is asking to have this nib loaded.
So the File’s Owner proxy isn’t actually stored in the nib, but Interface Builder needs that proxy so you can make association with controls you used in your view.
When the nib is restored (and the control objects are instantiated), the nib loading code will make the connections to the real owning object that asked to load the nib.
First, get the data from Mike Mike likes what you have put together for the UI, so now we need a little more information before we fill the picker.
Here’s my list of what I do and how I feel about it so you can fill in the rest.
Can’t wait until it’s done because I’m soooo over talking about it...
This data will be used as part of the picker, but how do you implement that?
Use pickers when you want controlled input In our case, the picker is the perfect element for our app.
No typing at all, but it allows Mike to have some input over what gets selected.
There’s some terminology that you need to know about pickers before we get our data in there.
The number of rows, or items, comes from Mike’s list, so 9 for each component.
Remember the screen size issue when building iPhone apps? The longest word needs to fit in a column or it’s going to be abbreviated.
When in doubt, check out Apple’s API documentation By now you’re already thinking about how to implement that picker.
In Xcode, go to the Help menu and then the Documentation option.
Search for “UIPickerView” and it will pull up all the information on the class that you need to implement for the picker.
Fill the picker rows with Mike’s data The picker needs to know how many rows it needs and how many columns.
And that information is tied to the words that Mike provided.
OK, so we can just set the picker rows with the values Mike gave us like we did with the button label, right?
The picker doesn’t want to be told what to do, it’s going to ask when it wants your input.
You’re going to see this pattern show up with controls that could use a lot of  data like pickers and later, table views.
Most of  the elements in the Cocoa Touch framework have the concept of datasources and delegates.
Q: Why is the delegate providing the content? That really seems like data.
A: That’s something particular to a picker and it has to do with the fact that the picker delegate can change how the data is shown.
In the simplest form, it can just return strings to the picker.
If it wants to get fancy, it can return the entire view (yes, just like the view you built with Interface Builder, but smaller) to use images or special fonts, whatever.
A delegate is responsible for the behavior of  an element.
When someone selects something—or in this case, scrolls the picker to a value—the control tells the delegate what happened and the delegate figures out what to do in response.
Just like with datasources, different controls need different kinds of delegates.
The datasource provides the bridge between the control and the data it needs to display.
The control will ask the datasource for what it needs and the datasource is responsible for providing the information in a format the control expects.
In our case, the datasource provides the number of components (or columns) for the picker and the total number of  rows for the picker.
If you squint a little, even the View-View Controller relationship we’ve been using follows this pattern (minus the datasource)
A datasource works with the databases, plists, images, or general information that your app will need.
A control represents the GUI that your user will interact with.
Generally, it will be assembled with Interface Builder, but it can be built in code, too.
Each approach has benefits and drawbacks, and sometimes you’ll use both on the same project.
Each control has specific needs for its datasource and delegate and we’ll talk about how that’s handled in Objective-C in a minute.
However, it’s important to realize that while the responsibilities are split between the datasource and the delegate in the pattern, they don’t necessarily have to be implemented in different classes.
The control wants a delegate and a datasource—it doesn’t care whether they’re provided by the same object or not: it’s going to ask the datasource for datasource-related things and the delegate for delegate-related things.
Let’s take a closer look at how the UIPicker uses its datasource and delegate to get an idea of  how all of  this fits together.
I don’t usually get to talk to anyone but my datasource and delegate so this is a real treat.
So we’ve worked with controls like buttons and labels, but they just have properties.
Picker: Well, to be clear, I have properties toothere just isn’t too much exciting going on there.
What makes me different is that I could be working with a lot of  data.
I might only have one row or I might have a hundred; it just depends on the application.
A label only has one string in it, so there can be a property that holds that string.
Picker: Exactly! So, instead of  trying to cram all of the data into me directly, it’s cleaner to just let me ask for what I need when I need it.
Head First: But you need to ask for it in a specific way, right?
For example, I need to know how many rows I need to show, so I ask my datasource.
It could be using an array, a database, a plist, whatever—I don’t care.
Head First: That’s really nice—so you could be showing data coming from just about anything, and.
I can draw the wheels and all that, but I don’t know what each application wants to do when someone selects a row, so I just pass the buck to my delegate.
Head First: So whichever one implements the delegate, it codes things so that when you tell it what happened, it performs the right action, like saving some value or setting a clock or whatever....
Now, I have to confess I have one little oddity going on...
I could come up with a lot of  excuses, but...
It’s not all bad, though; your delegate can do some neat things with each row, can’t it?
Picker: Oh yeah! When I ask the delegate for a particular row, it can give me back a full view instead of  just a string.
Sometimes they have icons in them or pictures—really, anything you can cram in a view, I can display.
Well, we’re out of  time, but thanks again for stopping by.
Picker: My pleasure!  Now I’m off  to take my new datasource for a spin...
The Picker Exposed This week’s interview: How to avoid spinning out of control...
Match each picker characteristic to where it belongs—the delegate or the datasource.
You’ll need to go digging in the API to figure out where the three methods go.
Working together, the delegate and the datasource provide what is needed to render the picker.
Match each picker characteristic to where it belongs—the delegate or the data source.
You’ll need to go digging in the API to figure out where the three methods go.
Hang on—there are protocols in both the datasource and the delegate?
Protocols define what messages the datasource and delegates need respond to.
Pickers (and other controls that use delegates and datasources) have specific messages to which their supporting classes need to respond.
When your class can speak a particular protocol, you’re said to conform to it.
Protocols typically have some required methods to implement and others that are optional.
So how do you know what protocols you need to worry about? The documentation for an element will tell you what protocols it needs to talk to.
For example, our UIPickerView needs a datasource that speaks the UIPickerDataSource protocol and a delegate that speaks the UIPickerDelegate protocol.
Click on the protocol name and you’ll see the documentation for which messages are optional and which are required for a protocol.
We’ll talk more about how to implement these in the next chapter; for now, we’ll provide you the code to get started.
Protocols tell you what methods (messages) you need to implement.
Hey - the user just spun me to “row 3”
We’ll need to add some methods to implement the required methods from the protocols, but we’ll get back to that in a second.
We’re going to use the two arrays we declared in the header to store the words that Mike gave us.
First, declare that the controller conforms to both protocols Now that you know what you need to make the picker work, namely a delegate and a datasource, let’s get back into Xcode and create them.
The .h and .m files work together, with the header file (.h) declaring the class’s interface, variable declarations, outlets, and actions, etc.; the implementation file (.m) holds the actual implementation code.
The break here skips commented out default code that we’re not using.
Remove the /* marks that were here and then add the code.
This method gets called on your view controller after the view.
This is where you can do some initialization and setup for the view.
We’ll call them in a bit to fill in the picker.
You need to release all of these objects to clean up the memory, as an iPhone is small (so not much memory)
NSStrings are real Objective-C classes, as opposed to a simple C-style character pointer.
How many rows in each component? They come from different arrays, so we need to treat them seperately.
The datasource protocol has two required methods Let’s focus on the datasource protocol methods first.
Since we know we want two wheels (components) in our view, we can start by putting that method in our implementation file:
Our second method needs to return the number of  rows for each component.
The number of  rows in each component is the just the number of  items in the appropriate array.
Now that we have the methods implemented, let’s wire it up to the picker.
Connect the datasource just like actions and outlets Now that the datasource protocol is implemented, the data is in place and it’s just a matter of  linking it to the picker.
A list of everything in your view, plus it’s class name.
Right-click on the Picker in the view to bring up the picker connections box.
You need to connect the picker’s dataSource to our controller, the File’s Owner.
To do that, click inside the circle next to the dataSource, and drag over the to File’s Owner.
If you don’t save in Interface Builder, it won’t work!
Xcode will run the last saved version, not anything else.
This method has to return an NSString with the title for the given row in the given component.
Again, both of  these values are indexed from 0, so we can use the component value to figure out which array to use, and then use the row value as an index.
Our choice of two methods, one of which needs to be implemented.
This gets called as your app is being shut down and the view is unloaded.
We don’t need it for now, so leave it as it was in the template.
Now back to Interface Builder to wire up the delegate...
Spin those dials - they’re all the things on Mike’s list and they work great!
Right-click on the picker in the Picker again and bring up the connections window.
Click inside the circle next to the delegate, and drag over the to File’s Owner.
Q: What happens if I don’t implement a required method in a protocol?
A: Your project will compile, but you’ll get a warning.
If you try to run your application, it will almost certainly crash with an “unrecognized selector” exception when a component tries to send your class the missing required message.
Q: What if I don’t implement an optional method in a protocol?
But whatever functionality that it would provide isn’t going to be there.
You do need to be a little careful in that sometimes Apple marks a couple of methods.
If you don’t implement at least one of the methods specified in the docs, your app will crash with an error when you try to run it.
Q: Are there limits to the number of protocols a class can realize?
Now, the more you realize, the more code you’re going to need to put in that class, so there’s a point where you really need to split things off into different classes to keep the code manageable.
But technically speaking, you can realize as many as you want.
Q: I’m still a little fuzzy, what’s the difference between the interface we put in a header file and a protocol?
A: An interface in a header file is how Objective-C declares the properties, fields, and messages a class responds to.
It’s like a header file in C++ or the method declarations in a Java file.
However, you have to provide implementation for everything in your class’s interface.
A protocol on the other hand is just a list of messages—there is no implementation.
It’s the class that realizes the protocol that has to provide implementation.
These are equivalent to interfaces in Java and pure virtual methods in C++
The picker needs a delegate and a datasource to work.
Protocols define the messages your class must realize—some of them might be optional.
We got the picker working, but if  you try out the “Tweet it!” button, nothing happens when something’s selected.
We still need to get the button responding to Mike and then get the whole thing to talk to Twitter.
Think about what we need to do to get the button working.
What files will we use? What will the button actually do?
Once Mike has selected what he’s doing and feeling, he’ll hit “Tweet it!” Then we need to get his selections out of  the picker and send them to Twitter.
So we just need to go back to IB and wire up the TouchUpInside event again, right?
Without an action, your button won’t work! We learned about actions in Chapter 1, and without one there won’t be anything in the connections window to wire up in Interface Builder.
The name can be anything, but the method must have one argument of type (id)
Here’s the action we created for the button press in Chapter 1:
Then provide an implementation for that method in our .m file, and write a message to the log so you know it worked before sending to Twitter.
Start with the header and add an IBAction named sendButtonTapped.
Now go back and hook it up with Interface Builder...
Declare your IBAction here so we can use it in the .m file and Interface Builder knows we have an action available.
The IBAction is what allows the code to respond to a user event, remember...
Declare your IBAction in the header file and provide the implementation in the .m file.
You should get the “Tweet button tapped!” message in the console.
So now we need to get the data from that picker, right? Would an IBOutlet.
In Chapter 1, we used an outlet to access and change the text field value on the button.
Now, to gather up the actual message to send to Twitter, we need to extract the values chosen from the picker, then create a string including the label text.
So far the picker has been calling us when it needed information; this time, when Mike hits the “Tweet it” button, we need to get data out of  the picker.
This lets Interface Builder know you have something to connect to.
IBOutlets are actually #defined to nothing; they’re just there for Interface Builder.
Here we declare a field in the class called tweetPicker.
Add the IBOutlet and property to our view controller In addition to declaring the IBOutlet, we’ll declare a property with the same name.
We’ll talk more about properties in the next chapter, but in short, that will get us proper memory management and let the Cocoa Touch framework set our tweetPicker field when our nib loads.
The last thing you need to do with tweetPicker is release our reference to it - another memory thing.
We’ll come back to the memory management in Chapter 3, we promise.
Connect the picker to our outlet You’re probably expecting this by now! Back into Interface Builder to make the connection from the UIPickerView to the IBOutlet in our view controller.
When you click and drag up to File’s Owner, you will be able to connect it to the tweetPicker outlet you just created.
What do you need to do now to get the data out of the picker and into your Twitter message? Think about the “Tweet it!” button press action and how that will need to change...
Use our picker reference to pull the selected values Now all that’s left is to use our reference to the picker to get the actual values Mike selects.
We need to reimplement the sendButtonTapped method to pull the values from the picker.
That method returns a row value, which, just like before, we can use as an index into our arrays.
Pull this log message out and put in one to see what the final Twitter message will be.
To figure out what Mike chose on the picker, we need to ask the picker what row is selected, and get the corresponding string from our arrays.
We’re just going to log this message to the console so we can see the string we’re building, and then we’ll send this to Twitter in just a minute.
Let’s make sure we implemented this correctly first before tweeting to the whole world...
All that’s left is to talk to Twitterwe’ll help you with that.
To post to Twitter, we’re going to use their API.
Rather than go into a Twitter API tutorial, we’ll give you the code you need to tweet the string.
If  you don’t have a Twitter account, just go get one!
After adding that code, you can just save, build and go.
That is great! Now, Renee is happy and feels included and I don’t actually have to talk out loud about my feelings.
This is the document Apple uses to evaluate apps for the App Store.
You see this listed in the view and it controls the view.
We’ve listed a couple of descriptions of a some different apps.
Using the app description, sketch out a rough view and answer the questions about each one.
Generic giant button app There are several of  these currently up for sale on the app store.
This app consists of  pushing a big button and getting some noise out of your iPhone.
What are the main concerns in the HIG about this app type?
Book inventory app This app’s mission is to keep a list of  the books in your library, along with a quick blurb of what it’s about and the author.
What are the main concerns in the HIG about this app type?
You see this listed in the view and it controls the view.
We’ve listed a couple of descriptions of a some different apps.
Using the app description, sketch out a rough view and answer the questions about each one.
Generic giant button app There are several of  these currently up for sale on the app store.
This app consists of  pushing a big button and getting some noise out of your iPhone.
What are the main concerns in the HIG about this app type?
This app’s mission is to keep a list of  the books in your library, along with a quick blurb of what it’s about and the author.
What are the main concerns in the HIG about this app type?
The big thing Apple cares about is that controls “provide an internally consistent experience.” So everything can be custom, it needs to focused and well organized.
The HIG has many more specific rules about this app type, because you’ll be using standard controls.
Another view for details, need to figure out how to get to it...
You’ve got Chapter 2 under your belt and now you’ve.
Protocols define the messages your class must realize—some of them might be optional.
It’s so great that Mike and I are communicating now! But I’ve noticed that Mike’s starting to sound like he’s in a rut, saying the same thing over and over again! Is there something we need to talk about?
Sounds like Mike is going to need some modifications to InstaTwit to keep his relationship on solid ground...
I know these are letters and all, but I have no idea what you’re saying...
Unless you work that out, all your apps will be just default.
InstaTwit was working great, and is so easy to use! But I think Renee is on to me.
I need to be able to add to my tweets or this isn’t going to work much longer.
Mike has been diligently using InstaTwit to communicate his feelings, but his girlfriend is starting to think something weird is going on.
Even for Mike, who is a guy who likes his routines, his tweets are starting to sound suspicious.
We need to make some adjustments to our InstaTwit design.
Take a look at the various UI controls available in Interface Builder, and think about what would be a quick and easy way for Mike to add to his tweets.
Code Magnets Using what you know from adding the picker and the button, match the magnet with the method or file that you’ll need to edit to add the text field.
Make room for custom input It’s nothing fancy, but Mike could add a little personal flavor to his tweets with a text field at the start.
It means he’ll need to do some typing, but in the end his tweets will be more unique.
Design Magnets Solution Using what you know from adding the picker and the button, match the magnet with the method or file that you’ll need to edit to add the text field.
We keep adding code to this .h file, but I still don’t know what a .h file really does! What gives?
It’s where you declare the interface and methods for a class.
All of  the classes we’ve used so far, like UITextField, NSString, and NSArray, have header files you can look through.
Take a minute to look through a couple and start thinking about what is happening in those files.
Sometimes you’ll come across a really tempting method that’s not defined in the Apple Documentation.
Using undocumented APIs will get your app rejected from the iTunes store.
Fill in the blanks and explain what each line does.
Header files describe the interface to your class In Objective-C, classes are defined with interfaces in the header file.
It’s where you declare if  your class inherits from anything, as well as your class’ fields, properties, and methods.
Fill in the blanks and explain what each line does.
This is where we can declare fields of our class.
Next comes the class name, and if it inherits from something then a colon and the super class’s name.
Any protocols you implement go in angle brackets separated by commas.
Protocols are like Java interfaces or pure virtual classes in C++, and a class can realize as many as you want.
The syntax for fields is just like in C++: Basic types like int and float are used as is; pointer types use an asterisk.
Once you’ve closed the field section of your interface, you can declare properties.
IBAction method signatures must take one argument of type id, which is like a void * in C++ or Object reference in Java.
Design Magnets Solution (Continued) Using what you know from adding the picker and the button, match the magnet with the method or file that you’ll need to edit to add the text field.
You can create a new @synthesize line or just add it after a comma on the line that’s already there.
OK, so if we declared a property in the .h file, then adding @synthesize in the .m file must auto-generate some code, right?
Using @property lets the compiler know we have a property, but that’s not enough.
Using the @synthesize keyword in the implementation files, we can have the compiler auto-generate the setter and getter method we talked about earlier.
The compiler will generate a getter, and, if  it’s a readwrite property, a setter and implement it based on the @property attributes declared in the .h file.
When you want the property to be modifiable by people.
The compiler will generate a getter and a setter for you.
Below is a list of  the most commonly used property attributes and definitions.
When you’re dealing with basic types, like ints, floats, etc.
The compiler just creates a setter with a simple myField = value statement.
This is the default, but not usually what you want.
The compiler will retain the value you pass in (we’ll talk more about retaining in a minute) and release the old value when a new one comes in.
You can still change the field value backing the property, but the compiler won’t generate a setter.
When you want to hold onto a copy of some value instead of the value itself; for example, if you want to hold onto an array and don’t want people to be able to change its contents after they set it.
This sends a copy message to the value passed in then retains that.
When you want the property to be modifiable by people.
The compiler will generate a getter and a setter for you.
When you’re dealing with basic types, like ints, floats, etc.
The compiler just creates a setter with a simple myField = value statement.
This is the default, but not usually what you want.
The compiler will retain the value you pass in (we’ll talk more about retaining in a minute) and release the old value when a new one comes in.
You can still change the field value backing the property, but the compiler won’t generate a setter.
When you want to hold onto a copy of some value instead of the value itself; for example, if you want to hold onto an array and don’t want people to be able to change its contents after they set it.
This sends a copy message to the value passed in then retains that.
Q: How does the compiler know what field to use to hold the property value?
A: By default, the compiler assumes the property name is the same as the field name.
Q: What about that nonatomic keyword? A: By default, generated accessors are multithread safe and use mutexes when changing a property value.
However, if your class isn’t being used by multiple threads, that’s a waste.
You can tell the compiler to skip the whole mutex thing by declaring your property as nonatomic.
Below is a list of  the most commonly used property attributes and definitions.
Auto-generated accessors also handle memory management Objective-C on the iPhone doesn’t have a garbage collector, so you have to use reference counting.
That involves keeping up with how many references there are to an object, and only freeing it up when the count drops to zero (it’s no longer being used)
When you use properties, the compiler handles it for us.
The properties we’ve declared so far have all used the retain attribute.
When the compiler generates a setter for that property, it will properly handle memory management for us, like this:
Write the code that Objective-C generates for each property declaration below.
NSStrings are reference counted objects, so while this will technically work, having an assign property for an NSString is probably a bad idea.
Below is the code that the compiler will generate for each property.
I bet that release just lets go of the memory that your properties use up, right?
In addition to retain and release, Objective-C has the concept of  an autorelease pool.
This is basically an array of  objects that the runtime will call release on after it’s finished processing the current event.
To put something in the autorelease pool, you simply send it the autorelease message:
You won’t want to use this all the time because it’s not nearly as efficient and has some performance overhead.
It’s not a bad thing to use, but it’s better to explicitly retain and release when you can.
You must release objects you create with alloc, new, copy, or mutableCopy.
If  you create an object with alloc, new, copy, or mutableCopy, it will have a retain count of  1 and you’re responsible for sending a release when you’re done with the object.
You can also put the object in the autorelease pool if  you want the system to handle sending a release later.
Consider everything else to have a retain count of 1 and in the autorelease pool.
This means that if  you want to hang onto that object outside of  the method that got the object, you’ll need to send it a retain (and a corresponding release later)
To keep your memory straight, you need to remember just two things Memory management can get pretty hairy in larger apps, so Apple has a couple of rules established to keep track of  who’s in charge of  releasing and retaining when.
Memory management is definitely important on iPhone, but that doesn’t mean it’s complicated.
Once you get the hang of  a few key principles, you’ll be able to structure your app so that it doesn’t leak memory and get you kicked out of  the app store.
When you create an object, it starts with a count of  1, and different things you do can raise and lower the count.
When the count reaches 0, the object is released and the memory is made available.
This is some of the memory management code that YOU have already written!
If another object (like this array) needs to hang onto your object, it will retain it....
Determine how many references are left at the end of the chunk of code and if we have to send it a release for each string.
This still has a retain count of 1 because of the alloc, but is now in the autorelease pool, meaning it will be sent a release automatically after the current event loop has completed.
This will have a retain count of 1, but will be in the autorelease pool because we didn’t get it via an alloc, new, copy, or mutableCopy.
Next it goes to 2 because it’s inserted into the “newArray”
Then it goes back to 1 because an array will send a release to all of its items when the array is destroyed.
Note the array wasn’t alloc’ed either, so it will be autoreleased, too.
Then one more retain from the dicionary, also not alloc’ed and will be autoreleased.
So, even though “sixth” has a retain count of 4, we, the developers, only need to send one release to “sixth” and let everything else clean up with the autorelease pool.
Determine how many references are left at the end of the chunk of code and if we have to send it a release for each string.
Design Magnets Solution (Continued) Using what you know from adding the picker and the button, match the magnet with the method or file that you’ll need to edit to add the text field.
We don’t need an action or a datasource for the notes field.
You can create a new @synthesize line or just add it after a comma on the linthat’s already there.
You’ll also need to put a label that says “Notes” in front of  the text field.
You will probably need to move the picker, labels, and button down.
Right-click on File’s Owner and link from the circle next to “notesField” to the UITextField in the view.
Test Drive Now that everything is saved, go back into Xcode and build and run, and launch the simulator.
Click here to write a note to customize the tweet....
Hey, we didn’t even have to do anything to make the keyboard show up for the text field.
I’ve been getting a lot of  attention recently with this whole iPhone thing.
Head First: So you have a pretty strong lineage, right? Why don’t you tell us a little about yourself ?
I’m an Object Oriented language, so I have classes and objects, but I come from strong C roots.
Head First: What do you mean you come from C roots?
Objective-C: Well, nearly all of  my syntax is just like C syntax.
You can easily use other C libraries like SQLite with me.
Most obviously, I am an OO language, so classes, abstract interfaces (which I call protocols), inheritance, etc.
Objective-C: Well, malloc and free work just like they do in C, but I have a really nice memory management model for objects.
Head First: Ah—so you keep track of  who’s using what?
When there aren’t any references left I’ll clean up the object and free up the memory for you.
You know those getter and setter methods you need to write for other OO languages to wrap fields in a class? Not here.
Not only that, you can tell me how you want to handle the memory associated with them.
Oh, and one of  my favorites: I can graft new methods onto classes without a problem.
We’re about out of time, so just one more question.
What’s up with all those “NSs” all over the place, like NSString and NSInteger?
I mentioned my strong lineage earlier; most of  the core classes that people use on iPhone come from CocoaTouch, which is a port of  Cocoa which came from OpenStep, which came from NeXTStep, and that’s where the NS comes from.
The frameworks are written in Objective-C, but they’re frameworks, not really language things.
When you write for iPhone, you’ll be using things like that all of  the time.
For example, instead of  using char*s for strings, you usually use NSStrings or NSMutableStrings.
Head First: This is great information! Thanks again for coming by, and best of  luck with the iPhone!
Q: What happens if I don’t retain an object I’ll need later?
A: Most likely the object’s retain count will hit 0 and it will be cleaned up before you get to use it.
Now here’s the sad part: it might not crash your object on the simulator every time.
The simulator has a lot more memory to work with and behaves differently than a real iPhone or iPod Touch.
Everything might look great until you put it on your phone to test it.
Q: What if I release my object too many times?
When the reference count hits 0, the object will be released and memory will be freed.
Sending that now-freed memory another release message will almost certainly crash your application.
Q: What if my project works on the simulator and dies on the real phone? Could that be a memory problem?
Memory on a real device is much tighter than on the simulator.
We’ll talk more about debugging these and using Instruments to track memory usage and leaks in a later chapter.
Q: How can I check if I’m managing my memory effectively?
A: The iPhone SDK comes with a great memory tool called Instruments that can show you how your memory is being used, peak memory usage, how fast your allocating and deallocating it, and possibly most importantly, if you’re leaking memory.
We’ll talk about it in detail later in the book.
Q: What happens if I set things to nil? A: Well, it depends on what you’re setting to nil.
The variable is now nil, but the memory for the object it used to point to is still allocated and you’ve almost certainly leaked something.
Q: Do I have to retain things I want to set on my properties?
That’s what the “retain” parameter is on the @property declaration.
If you put retain there the property will automatically send values retains and releases when the property is set or cleared.
If you have a property with a retain parameter and it still has a value when your object is released, then whatever that property is set to hasn’t been freed.
You can either send the field an explict release in your dealloc or set the property to nil.
One more quick note: the automatic retain/ release ability of properties only works if you use the “.” notation.
If you explicitly modify the field that backs the property, there’s nothing the property can do about it and can’t retain/release correctly.
Q: Doesn’t Objective-C have garbage collection like Java or .NET?
Apple didn’t provide garbage collection on iPhone OS however, so you need to fallback to reference counting with retain and release.
Q: What about malloc and free?  Can I still use them?
Malloc and free work fine for basic blocks of memory as they do in C, but use alloc to instantiate classes.
Q: What’s with that init call that you always put after the alloc?
A: Objective-C doesn’t have constructors like other Object Oriented languages do.
Instead, by convention, you can provide one or more init methods.
You should always call init on any class you allocate, so you almost always see them together as [[SomeClass alloc] init]
Q: How do I know if something retains my object, like an array or something?
Follow the memory rules that say if you got it from alloc, new, copy, or mutableCopy, you have to send it a release.
Otherwise, retain/ release it if you ant to use it later.
Beyond that, let the other classes handle their own memory management.
Q: Can’t we just append the message to the string?
The textField works great, but how do I get the keyboard to go away?
The keyboard is permanent? Go ahead, play with it and try to get the keyboard to go away.
Return won’t do it, and neither will clicking anywhere else on the screen.
How should the view communicate what has to happen to the user?  What should the user see?
What does the view controller need to do to make these view changes happen?
The user needs to understand what to do to make the keyboard go away, so change the “return” button to say “done”
The view controller needs to receive the “done”message and then make the keyboard go away.
Q: Why didn’t we have to do anything to make the keyboard appear in the first place?
A: When the users indicate they want to interact with a specific control, iPhoneOS gives that control focus and sets it to be the “first responder” to events.
When certain controls become the first responder, they trigger the keyboard to show automatically.
Conventions like using “done” to let the user hide the keyboard are discussed in Apple’s HIG.
There are lots more; “done” is just one of them.
This kind of back and forth between the view and view controller is common and is going to show up all over the place.
Beyond the Text and Placeholder fields, changing some of the other options may hurt your usability and make Apple unhappy, so be careful.
Now, get the keyboard to talk to the view controller...
Next change the label on the return key Changing the name of  the button in the keyboard (so it’s “done” instead of  the “return”) is another option in the inspector.
The big thing that changing the label on the button brings to the table is that it clearly communicates to the user what to do to make they keyboard go away.
Click on the Return Key popup menu and pick Done.
When users click in the text field, iPhone OS gives that control focus and assigns it as “first responder” to that click event.
A component can get focus a number of  ways: the users explicitly tap on the control, the keyboard is set up so that the Return key moves to the next control they should fill out, the application sets some control to explicitly become first responder because of  some event, etc.
What a component does when it becomes the first responder varies by component, however; for a UITextField, it asks iPhoneOS to display the keyboard.
All this chatter between the application and components is fundamental to writing an application, and it all happens through message passing.
When one object wants to communicate with another object, it sends it a message.
Here we’re sending the objectAtIndex message to the activities array.
In Objective-C you send a message to an object and it responds to that message (as opposed to returning a value from a method)
The Objective-C runtime turns those messages into method calls on objects or classes (in the case of  static methods), but get used to thinking about these as messages; you’ll see things like “the receiver of  this message will...” all over Apple’s documentation.
Now, let’s use message passing to get rid of  the keyboard when the user is done with it.
Ask the textField to give up focus In order to get the keyboard to go away, we need to tell the text field that the user is done with it.
We do this by asking the textfield to resign its first responder status.
Sending messages in Objective-C is easy: you list the receiver of  the message, the message to send, and any arguments you need to pass along.
This is the receiver for the message - in our case, the notesField.
In our case we have no arguments, so this is all we need.
See the Apple documentation for details on what messages each component will respond to.
You can pass messages to nil with no obvious problems.
Be careful of uninitialized variables or nil values coming back as other nil values when you debug.
Is that how the View is sending the View Controller information?
Yes! Our View Controller can respond to a number of messages like sendButtonTapped and viewDidLoad.
Now here’s the trick: the textField can send a message when the user taps the Done button on they keyboard.
We just need to tell it that our ViewController is interested in knowing when that happens.
This is a statement like any other—don’t forget the semicolon.
You’ve been handling messages since Chapter 1, but we really haven’t talked about the syntax to make it work.
Method declarations go in your header files and the implementation goes in the .m.
Here are some snippets from our sendButtonTapped implementation from InstaTwit.
Implementation files (.m) start with @implementation, then the name of the class you’re implementing.
The “-” means it’s an instance method (whereas a “+” means a static or class method)
You specify the response type in parenthesis before the message names.
The full message name (with arguments) is called a selector in Obj-C and tends to be long and descriptive.
If there are arguments to your message, follow the message name with a colon, then the type and name of the local variable.
The syntax for declaring a message in a header file is the same as in the implementation file.
Messages in Objective-C use named arguments In Objective-C, message names tend to be long and descriptive.
This really starts to make sense when you see arguments tacked on.
When you send a message with arguments, the message and argument names are all specified.
This method returns the number of  rows for a given component in a picker view.
Q: You keep switching terms back and forth between methods and messages.
In Objective-C, you send messages to objects and they respond.
The Objective-C runtime turns your message into a method call, which returns a value.
So, generally you talk about sending some receiver a message, but if you’re implementing what it does in response, you’re implementing a method.
A: In Objective-C you can have a public name and a local name for arguments.
The public name becomes part of the selector when someone wants to send that message to your object.
The name after the type is the local variable; this is the name of the variable that holds the value.
In Objective-C they don’t have to be the same, so you can use a nice.
If you don’t provide one, people just use a colon and the argument value when sending the message to your object.
Methods can have internal and external names for arguments; the external name is used when sending the message to the receiver.
So when iPhoneOS wants to send this message to our delegate, it creates a call like this:
Use message passing to tell our view controller when the Done button is pressed The text field can tell our ViewController when the Done button was pressed on the keyboard; we just need to tell it what message to send.
You’ll need to declare an action in both the .h and and implement it in the .m file:
Just like we did with the “Tweet it” button, go back into Xcode and add this:
Now that we have an action that will be called when the Done button is pressed, we just need to ask the textField to resign its first responder status and it will hide the keyboard.
If  you right-click on the UITextField you’ll bring up the connections.
The UITextField has a number of events that it can raise, just like the round rectangular  button.
Take a second and check out the list that’s there.
Q: Why did we send the message back to the sender in our action and not to our notesField property?
A: Either one would work fine; they’re both references to the same object.
We used the sender argument because it would work regardless of whether we had a property that was a reference to our UITextField.
Q: You mentioned selectors, but I’m still fuzzy on what they are.
A: Selectors are unique names for methods when Objective-C translates a message into an actual method call.
It’s basically the method name and the names of the arguments separated by colons.
You’ll see them show up again in later chapters when we do more interface connecting in code.
A: “id” is an Objective-C type that can point to any Objective-C object.
Since Objective-C is a dynamically typed language, it’s perfectly ok with sending messages to an object of type “id”
It will figure out at runtime whether or not the object can actually respond to the message.
Q: What happens if an object can’t respond to a message?
This is the reason you should use strongly typed variables whenever possible.
However, there are times when generic typing makes a lot of sense, such as callback methods when the sender could be any number of different objects.
Method declarations go in the header (.h) file after the closing brace of an interface.
Method arguments are usually named, and those names are used when sending a message.
Use a “-” to indicate an instance method; use “+” to indicate a static method.
It works! The keyboard goes away and you can play around with the text field and add some notes now.
If you have your account info in the code, remember every time you tweet it actually will!
Something’s still not right Mike’s ready to try out the custom field and see what happens, but when he puts in his custom message...
The custom note doesn’t do anything! It’s not showing up on Twitter.
You can fix this with no problem now that you’ve gotten the hang of events and message passing...
This string didn’t come from alloc, new, copy, or mutableCopy, so it’ll be autoreleased.
Build the tweet with strings We need to incorporate the note text into our tweet.
In order to do that, we’re going to do a little string manipulation with the core string classes.
You’ve already built a message to send to Twitter, but this time we have more text to include.
Before you refactor the code to send the tweet with the new text in it, let’s take a closer look at what you did in Chapter 2:
Now all you need to update this to include the text from the Notes field.
Take a look at the magnets on the next page and get it working.
Using the information you just learned and the magnets below, fill in the missing code.
Using the information you just learned and the magnets below, fill in the missing code.
We have to handle the case where the user didn’t enter any text.
If the text field is empty, its text property will be nil.
The ? is a ternary operator, just like in Java or C++, where if the expression is true it returns the first value, otherwise, it returns the second.
Test Drive Go ahead and build and run the app with the new text code in it.
It’s so great that we can talk about our feelings...
You’ve got Chapter 3 under your belt and now you’ve added.
The compiler will generate a getter and a setter for you.
You can still change the field value backing the property, but the compiler won’t generate a setter.
The compiler just creates a setter with a simple myField = value statement.
This is the default, but not usually what you want.
The compiler will retain the value you pass in (we’ll talk more about retaining in a minute) and release the old value when a new one comes in.
For example, if you want to hold onto an array and don’t want people to be able to change its contents after they set it.
This sends a copy message to the value passed in then retains that.
Memory Management - You must release objects you create with alloc, new, copy or mutableCopy - Everything else needs to have a retain count of 1 and in the autorelease pool.
I like my coffee with two sugars, cream, a sprinkle of cinnamon, stirred twice, then ...
We’ve written a cool app with one view, but anyone who’s used an iPhone knows that.
Some of the more impressive iPhone apps out there do a great.
I need to know a ton of drink recipes every night.
What views would you need to have for a bartending app?
Sam needs a list of drink names and to be able to look up what’s in them.
He’ll also want to know how much he needs of each ingredient, and any instructions - what’s on the rocks, whether to shake or stir, when to light things on fire, etc.
This bar will have buttons, like the back and forward buttons in a web browser.
We’re not going to use the keyboard for now - it’s a reference app, and Sam just needs to read stuff...
So, how do these views fit together? Before you pick the template for our bartending app, take a minute to look at how you want the user to interact with the drink information.
We’re going to have a scrollable list of  drink names, and when the user taps on a row, we’ll show the detailed drink information using view #2, our detailed view.
Once our user has seen enough, they’re going to want to go back to the drink list.
The navigation template comes with a lot of functionality built in:
Just like the name says, a navigation controller is built in.
It provides back buttons, title bars, and a view history that will keep your user moving through the data without getting lost.
Add sugar to the rim of glass, pour ingredients into shaker...
Pour ingredients into a rocks glass filled with ice.We have hierarchical data to organize.
The navigation template helps us to move through the data, starting with a table view.
The navigation template starts with a table view The navigation template comes with a navigation controller and a root view that the controller displays on startup.
That root view is set up as a table view by default, and that works great for our app.
A table view is typically used for listing items, one of  which then can be selected for more details about that item.
Q: If the navigation template is about handing lots of views, why does it only come with one?
A: Most navigation-based applications start out with a table view and show detailed views from there.
The navigation template doesn’t assume anything beyond the initial table view.
Q: What built in apps on iPhone use the Navigation control?
A: Contacts and Mail, which are both core iPhone apps, use this design.
It’s a good idea to get into those apps on your phone to see how the entire template is implemented.
For a neat twist, take a look at the Messages (SMS) app.
That one uses a navigation controller but frequently starts in the “detail” view, showing the last person you sent or received a message from.
Q: Do I have to use a table view for my root view?
A: No, it’s just the most common, since it provides a natural way to show an overview of a lot of data and have the user drill down for more information.
Table views are very customizable, too, so some apps that might not seem like table views really are, like Notes or the iTunes store, for example.
This is where you’ll find the back buttons, forward buttons, and the title of the view you’re in.
The table view provides an easy way to work with data.
It starts with an empty, scrollable list for the main view of your application.
This is the table view and will hold our drink list.
Add a title to the main view right away, and take a look at what your empty table view will look like.
If you don’t add the title here, you won’t have a back button later.
Setting the title for the main view of the app means that additional views will automatically have back buttons to get to the main view.
Navigation controllers and table views are almost always used together.
When you selected the navigation-based project as your template, Xcode created a different view setup than we’ve used in the past:
In the table view, this nav bar is actually a place-holder provided by Interface builder.
A table is a collection of cells The UITableView provides a lot of  the functionality we need right away, but it still needs to know what data we’re actually trying to show and what to do when the user interacts with that data.
A table view is easy to customize and is set up by the template to talk to the datasource and delegate to see what it needs to show, how many rows, what table cells to use, etc.
The navigation controller, not the table view, provides the navigation bar.
Since we’re in interface builder, this is just a simulated one.
Table views can tell you when your user taps on a cell.
It’ll tell you the section and row that was tapped.
We’re using the default table view cell, but you can create your own and lay them out any way you want.
Look through some of the apps you have on your device.
What are some of the most customized table views you can find? Are they using sections? Are they grouped? How did they layout their cells?
This is where we create table cells and populate them with the drink list information.
This method is called when the table view needs a cell.
The indexPath contains the section and row number for the needed cell.
If there aren’t any available for reuse, we’ll create a new one.
These methods tell the table view how many sections we have and how many rows in each section.
The auto-generated code needs to be modified to tell the table that it will have the same number of  rows as there are drinks in the array.
Modify the implementation file under this line: // Customize the number of rows in the table view.
Implement the code that we talked about on the previous page in Table Cell Up Close so that the table gets populated with the items from the array.
Q: How do cells get into that reusable list to begin with?
When cells scroll off the screen (either the top or the bottom,) the table view will queue up cells that are no longer needed.
When it asks the datasource for a cell for a particular.
When you do more complex table views, you can create custom cell types depending on what.
You use the cell identifier to make sure that when you ask for a reusable cell, the table view gives you back the type you expect.
The identifier can be anything you want—just make sure you have a unique name for each unique cell type you use.
This is the active view with the table cells that are currently visible.
As the user scrolls, some cells slide off the screen.
The cells that are off the view go into a bucket until iPhone needs memory or the table view can reuse them when the user scrolls.When the table view has to.
Wait, memory on the iPhone is a big deal, right? How can we put in all those drinks?
The UITableView does this by reusing cells that scrolled off the screen.
Like everything else on iPhone, the UITableView has to worry about memory.
So, how does it balance concerns about memory with an unknown amount of  data to display? It breaks things up into cells.
Now it tells the table view that we have the same number of rows as the number of items in the drinks array.
Here we customize the text in the cell with the information for the specific drink we need to show.
Save it, build and run, and you’ll see the three drinks in your app in the main view.
Q: You mentioned the table view’s datasource and delegate, but why didn’t I have to declare anything like we did with UIPickerView?
Normally you would, but the navigation-based template we used already set this up.
If we weren’t using a template, you’d have to set these up yourself (we’ll revisit this in Chapter 7)
A: No—both NSMutableArray and NSArray can be initialized with values when you create them.
We’re using an NSMutableArray because we’re going to manipulate the contents of this array later.
Q: What’s the nil at the end of the drink names when we create the drink array?
It uses nil to know it’s reached the end of the arguments.
The last element in the array will be the value before the nil—nil won’t be added to the array.
Q: Tell me again about that @ symbol before our drink names?
A: The @ symbol is shorthand for creating an NSString.
NSArrays store arrays of objects, so we need to convert our text names (char*s) to NSStrings.
We do that by putting an @ in front of the text constant.
Q: When we customized the table view cells, we used the cell.textLabel.
Are there other labels? What’s the difference between cell.textLabel and cell.text?
A: Before iPhone 3.0, there was just one label and set of disclosure indicators in the default cell, and it was all handled by the cell itself.
You just sent the text you wanted on the cell.text property.
Nearly everyone wanted a little more information on the table cells, so in iPhone 3.0, Apple added a few different styles with different label layouts.
Once they did that, they introduced specific properties for the different text areas, like textLabel, detailLabel, etc., and deprecated the old cell.text property.
You shouldn’t use cell.text in your apps—Apple will likely remove it at some point in the future.
We’ll talk more about the other labels later in the chapter.
Q: You mention that we can use section headers and footers—how do you specify those?
There are optional methods you can provide that return the title for section headers and the title for section footers based on the section number.
Q: What’s the difference between a plain table view and a grouped table view?
In a plain table view, like the one we’re using, all the sections touch each other and are separated by the section header and footer if you have them.
In a grouped table view, the table view puts space between the sections and shows the section header in bigger letters.
Take a look at your contact list, then select a contact.
The first view, where all of your contacts are listed together and separated by letters is a plain table view.
The detailed view, where the phone numbers are separated from email addresses, etc, is a grouped table view.
Can’t we just import the list Sam sent us somehow?
We could, but not the way we’re set up now.
Since the drinks are populated with an array that’s hardcoded into the implementation file, we can’t import anything.
What would work well is a standardized way to read and import data; then we would be able to quickly get that drink list loaded.
What can we do? There needs to be a way to speed up the process.
Plists are an easy way to save and load data Plist stands for “property list” and it has been around for quite a while with OS X.
In fact, there are a number of  plists already in use in your application.
This is created by Xcode when you first create your project, and besides the app icons, it stores things like the main nib file to load when the application starts, the application version, and more.
Xcode can create and edit these plists like any other file.
Others are less obvious, but we’ll talk more about them in later chapters.
Before you import Sam’s list, let’s create a sample plist that’s the same format.
We’ll make sure we get that working properly, and then pull in Sam’s list.
Open up the file and change the root type to Array and the item types to strings.
Built-in types can save and load from plists automatically All of  the built-in types we’ve been using, like NSArray and NSString, can be loaded or saved from plists automatically.
We can take advantage of  this and move our drink list out of  our source code.
With the sample list created, we can use it for testing before we get the big list.
Plists are used in Mac development as well as iPhone development, so they’re listed here.
Open up the file and change the root type to Array and the item types to strings.
Ask the app bundle for a path to our DrinkArray plist.
Test Drive After you’ve finished up these two things, go ahead and build and run.
It should look the same, with just the three drinks.
Arrays (and more) have built-in support for plists Changing the array initialization code to use the plist is remarkably easy.
Most Cocoa collection types like NSArray ad NSDictionary have built-in support for serializing to and from a plist.
As long as you’re using built-in types (like other collections, NSStrings, etc.,) you can just ask an array to initialize itself  from a plist.
The only piece missing is telling the array which plist to use.
Once this list works, head over to http://www.headfirstlabs/ iphonedev and download the DrinkArray.plist file.
It has the complete list of the drinks from the Head First Lounge.
Drop this in on top of your test plist, rebuild DrinkMixer, and try it out!
By moving the drinks out of the code and into an external file, you can change the drink list without needing to touch a line of code.
PLists are just one way to save data on the iPhone  - we’ll talk about others later in the book.PLists work great for built-in types.
If you’re going to be using custom types, you probably want to consider another option.
How are we going to get from the list to the detail view? And how are we going to display the details?
Now we just need to get that detail view all set up, right?
The entire list of  drinks is great, but Sam still needs to know what goes in them and how to make them.
That information is going to go in the detail view that we sketched up earlier.
Use a detail view to drill down into data Earlier, we classified DrinkMixer as a productivity app and we chose a navigation controller because we have hierarchical data.
We have a great big list of  drinks loaded, but what Sam needs now is the detailed information for each drink: what are the ingredients, how do you mix them, etc.
Now we’ll use that navigation controller to display a more detailed view of  a drink from the list.
The standard pattern for table views is that you show more information about an item when a user taps on a table cell.
We’ll use that to let the user select a drink then show our detailed view.
The detail view follows the same pattern as our other views:
Detail The detail view shows all the elements that make up a drink - the ingredients and how to mix them.Since the detail view.
When the user taps on a drink, we’ll display the detail view.
It will tell the nav controller to show the detailed view.
UITextField for the drink name It will be populated with “Name:” and the drink info, so we don’t need a label.
A closer look at the detail view We sketched out the detail view earlier—but we need to look more closely at what we’re about to build.
Start building your detail view by creating the files and code you’ll need, then put it together in Interface Builder and wire it up.
Use the library to drag and drop the elements that you need and build the view we sketched out earlier.
Here’s a hint: to reserve the space for the navigation controller, just bring up the Inspector, and under Simulated Interface Elements, Top Bar, select Navigation Controller.
That will make sure that you lay out your view below the navigation bar.
Write the code to handle the declarations and outlets for the new fields.
Just like we did for InstaTwit, use Interface Builder to make the new view work.
To create the new view, you need a new *.xib file, as well as the supporting header and implementation files.
The file type is a Cocoa Touch Class type, and it’s a UIViewController subclass.
Using the inspector, find the checkbox that makes the fields uneditable.
Navigation controllers are a good way to manage multiple views.
Q:We keep drawing the datasource, view, and view controller as separate things, but then we stick them together into the same class.
In general, you’ll have a few defined in a nib, a view controller backing it, and a set of data it needs to work on.
Whether these are combined into one class or not really depends on the complexity of your application.
If you’re not using Interface Builder, you can go completely off the deep end and have your single class create the view programmatically.
Conceptually, however, you still have a view that’s calling into the view controller when things happen.
Likewise, you usually have one or more datasource protocols being realized somewhere that are providing data to your view.
Q: Why do we have to move the *.xib file into the Resources group?
Xcode really doesn’t care; it’s just important that you know how your code is organized and you can find what you’re looking for.
Reusing a structure that others will recognize is a good practice so people can pick up your code quickly and you can understand their code.
Q:What are other ways to save data? A: There are quite a few of them.
We’ll cover the more common ones in this book in different projects.
The one you’re using now, plists, is the simplest, but it does limit what you can save and load.
That doesn’t make it bad; if it works for what you need, it’s a fine solution—it’s just too limited for everything.
There’s a serialization method called NSCoding that works well for custom objects, but can make version migration a challenge.
This used to be the preferred way to go if you have a lot of data or need to search and access it without loading it all into memory.
Core Data is a very powerful framework that provides an OO wrapper on persistence and has nearly all of the benefits of using SQLite.
It’s definitely not trivial to get started, but it’s really powerful.
Q: Why didn’t you use a label for the name field?
A: UITextFields allow you to have placeholder text that appears in the field when it’s empty.
Rather than using up screen space with a Name label, we chose to use the placeholder.
If the meaning of the text shown on the screen is obvious to the user, consider using placeholder text.
Q: So why didn’t we use it for the ingredients and directions?
A: We could have, but since those contain multiple lines of text, we wanted to break them up with labels clearly showing what they were.
Ultimately it’s an aesthetic and usability decision, not a technical one.
Make sure that you have the Cocoa Touch Class line selected under iPhone OS.
The new file dialog box has lots of  options for making new files.
In our case, we need both the nib and the supporting files, so we need to create a new Cocoa Touch Class with .m and .h files, and the .xib file.
Xcode will create all of  your files in one directory.
After this, you should have a working (but still empty) detail view.
Write the code to handle the declarations and outlets for the new fields.
After this, you should have a working (but still empty) detail view.
We need to disable both the UITextField and the two UITextViews to prevent the user from making changes.
Simply click on each field and toggle the Enabled checkbox to off.
Once those changes are made, the keyboard issue goes away, because there won’t be one!
You just put in a lot of work, and it’s a good time to check for errors.
When your users browse through the drink information, they’re going to need to switch between our list and detail views.
Think about how we do that while keeping the user from getting lost.
How can we keep track of  what view to show?2
How does the detail view know what drink to show?3
How do you get the user back to the table view?4
We still need to get that detail view to load when Sam selects a drink.
Think about how we do that and keep the user from getting lost.
How can we keep track of  what view to show?2
How does the detail view know what drink to show?3
How do you get the user back to the table view?4
The user is going to tap on the cell of the drink name.
That’s based on the table cell that the user selects.
The navigation controller can supply a back button that can get us back to the main view.
In the simulator, Xcode will generate a back button with the text that says “DrinkMixer”
A view stack for moving between views As users move back and forth, you can ask the navigation controller to display the appropriate view.
The navigation controller keeps track of  where the users are and gives them buttons to go back.
A navigation bar for buttons and a title The navigation controller interacts with the navigation bar to display buttons that interact with the view being shown, along with a title to help the users know where they are.
A navigation toolbar for view-specific buttons The navigation controller can display a toolbar at the bottom of  the screen that shows custom buttons for its current view.
Since the views get told when they’re shown and hidden, that’s all we need for our app.
Use the navigation controller to switch between views Now that we’ve got the table view populated and the detail view built, it’s time to manage moving between the two views.
The navigationbased template comes preloaded with the functionality we need:
Now we need to get the table view and nav controller working together to display the detail view.
When the delegate method is called, our RootViewController (the delegate) needs to create a.
Navigation controllers maintain a stack of views We’ve been dragging the navigation controller along since the beginning of this project, and now we finally get to put it to use.
The navigation controller maintains a stack of  views and displays the one on top.
It will also automatically provide a back button, as well as the cool slide-in and out animations.
We’re going to talk more about the whole navigation controller stack in the next chapter, but for now, we’re just going to push our new view onto the stack and let the controller take care of  the rest.
We just need to figure out how to get that new view.
Here’s where it gets interesting: our RootViewController is our delegate, so it needs to hand off  control to the view controller for our detail view...
Once the new view is created, we’ll use the navigation controller to push the view onto the screen.
Instantiate a view controller like any other class The only piece left to create is the view controller.
Instantiating a view controller is no different than instantiating any other class, with the exception that you can pass in the nib file it should load its view from:
Let’s put all of  this together by creating the callback into the delegate and creating the new view controller to push onto the stack:
Since we’re going to create the new view controller, we need to include its header.
Here’s the delegate callback - the indexPath tells us which row (drink) was selected.
Try clicking in the text fields - no keyboard because they’re not editable!
Now that both views can talk to each other, go ahead and build and run.
We’ve outgrown our array All that’s left is to get the ingredients and directions in the detail view, and we’ll have a bartender’s brain.
To save you from having to type in the ingredients and directions, we put together a new file with all of  the extra information.
The problem is we can’t just jam that information into an array.
To add the drink details to this version, we need a different data model.
Which options below are possible ways to load the drink data?
Which of these options is the best for DrinkMixer? Why?
Use dictionaries in our plist to hold the drink details.
So, now we can get to the detail view from the drink list, but there aren’t any details in there.
We don’t have that info in our plist, do we?
Our current drink plist is just a single array of  drink names.
That worked great for populating the table view with just drink names, but doesn’t help us at all with drink details.
For this plist, instead of  an array of  strings, we created an array of dictionaries.
Within each dictionary are three keys: name, ingredients, and directions.
Each of  these have string values with the corresponding information.
Since NSDictionary adopts the NSCoding protocol, it can be saved and loaded in plists just like our basic array from before.
Which options below are possible ways to load the drink data?
Use dictionaries in our plist to hold the drink details.
Which of these options is the best for DrinkMixer? Why?
We could use a database to store drink information, but since.
We already have a plist of strings—switching over to a plist of dictionaries won’t be much work and gives us a data structure than can hold the drink info.
This would work too, but has the same hurdle as using a DB.
We’re not parsing any XML right now, so we’d have to define the schema, then add parsing code.
This is basically the worst of all the optio ns.
Since we already have code written that uses plists, we can change our plist to have an array of dictionaries instead of an array of strings without a lot of effort.
This way we don’t have to introduce SQL or XML into our project.
However, we do lose out on the strong typing and data checking that both SQL and XML could give us.
Since this is a smaller project, we’re going to go with dictionaries.
Test Drive Build and run to see the new plist, and watch what happens...
It has a different name, so you’ll need to make a couple of quick modifications.
Open up the new plist in Xcode (again, in the resources directory), and look at what it comes with—all that data is ready to go!
Go into the code and change the references from DrinkArray to DrinksDirections.
What is that? A: NSCoding is a protocol that works with the encoding and decoding of objects.
Working with this protocol means dealing with how an object can be stored on disk or distributed throughout the device.
Q: Where did the back button in the detail view come from? We didn’t do that...
A: It’s automatic functionality that comes with the navigation controller.
When you added a title for the main view, the navigation controller kept track of that name as part of the view stack for navigation, and added a back button with the title in it.
That’s not our problem, though: our code should be warning and compile-error-free.
The good news is that when an app crashes in the Simulator, it doesn’t go away completely (like it would on a real device)
Xcode stops the app right before the OS would normally shut it down.
Debugging—the dark side of iPhone development Something has gone wrong, but honestly, this is a pretty normal part of  the development process.
There are lots of  things that could cause our application to crash, so we need to figure out what the problem is.
Warnings can help find problems without debugging In general, if  your application doesn’t build, Xcode won’t launch it—but that’s not true for warnings.
Xcode will happily compile and run an application with warnings and your only indication will be a little yellow yield sign in the bottom right corner of  Xcode.
Two minutes spent investigating a warning can save hours of  debugging time later.
Sending a message to an object that it doesn’t claim to understand (from a typo or an autocompletion error) will trigger warnings.
Your app will compile, but will likely end up in a runtime exception when that code is executed.
First stop on your debugging adventure: the console We need to figure out why our app crashed, and thankfully, Xcode has a lot of  strong debugging capabilities.
For now we’re just going to look at the information it gave us about the crash, but later in the book we’ll talk about some of  the more advanced debugging features.
Since you ran the program in the simulator, the console should be up.
If  you don’t see the console, we can get it for you!
If  you ran DrinkMixer in a different mode, or can’t find your console, in.
The toolbar contains typical debugging commands, like stopping your application, restarting it, and continuing after hitting a breakpoint.
The console has the information about what happened that caused our application to be shut down.
The console tells us that our app was shut down because of an uncaught exception, and what that exception was.
The console also gives us a stack trace of where our application was, but there’s a mu.
Interact with your application while it’s running The console is a very powerful debugging tool.
This information is printed into the console and can help you diagnose problems quickly.
The console isn’t just read-only, though; it is your window into your running application.
We’ll see log messages displayed in the console, and when your application hits a breakpoint, you’ll be placed at the console prompt.
From there you can use debugging commands like print, continue, where, up, and down to inspect the state of  your application.
And when it’s about to stop running In this case, we’re dealing with a nearly dead application, but the idea is the same.
Since DrinkMixer has crashed, Xcode provides you with the basic information of  what went wrong.
In our case, an “unrecognized selector” was sent to an object.
Remember that a selector is basically a method call—it means that some code is trying to invoke methods on an object and those methods don’t exist.
The console debugger is actually the open source gdb prompt, so nearly all gdb commands work here.
The console prompt lets you interact with your application at the command line.
So far we’ve used Xcode to write code and compile and launch our applications.
Its usefulness doesn’t stop once we hit the “Build and Debug” button.
First, we can set breakpoints in our code to let us keep an eye on what’s going on.
Simply click in the gutter next to the line where you want to set a breakpoint.
Xcode will put a small blue arrow next to the line and when your application gets to that line of  code, it will stop and let you poke around using the console.
This switch indicates whether the breakpoints are on or not.
When the breakpoints are on, you’ll get this cool can of bug spray icon...
Since we know that we’re having a problem near the array, try setting a breakpoint there.
The Xcode debugger shows you the state of your application The debugger shows your code and also adds a stack view and a window to inspect variables and memory.
When you click on a stack frame, Xcode will show you the line of  code associated with that frame and set up the corresponding local variables.
There isn’t anything in the debugger window you couldn’t do with the console, but this provides a nice GUI on top of  it.
If you click on a frame, Xcode will show you the corresponding code.
Test Drive When you run it with the breakpoint at the point where you load the array, everything is OK:
To set a breakpoint, you’ll need to click in the gutter, here.
What the heck is going on? Our application is crashing, and it’s not at the array loading code.
Open up the debugger and click on the topmost frame that contains our code.
It will show you the line that’s causing the problem...
MultipleViewscross Take what you’ve learned about the navigation controller and multiple views to fill in the blanks.
The set of views that the nav controller deals with.
A template that combines a table view and nav controls.
A more versatile way to manage data beyond an array.
To use a new class you need to ___________ it.
The @ symbol is shorthand for creating one of these.
You’ve got Chapter 4 under your belt and now you’ve.
For a complete list of tooltips in the book, go to http://www.
Come with support for editing contents, scrolling, and moving rows.
Can be customized so your cells look like more than one column.
Are good for handling data, but have some limitations - we’ll cover another option, core data, in a couple chapters coming up.
Navigation Controller: Maintains a view stack for moving between views.
Can support custom toolbars at the bottom of the view as needed.
Debugging: Has a built-in console with debugging and logging information.
Gives you errors and warnings as you compile to identify problems.
Has a built-in debugger that allows you to set breakpoints and step through the code to find the bug.
MultipleViewscross Solution Take what you’ve learned about the navigation controller and multiple views to fill in the blanks.
The set of views that the nav controller deals with.
A template that combines a table view and nav controls.
A more versatile way to manage data beyond an array.
To use a new class you need to ___________ it.
The @ symbol is shorthand for creating one of these.
That’s the story of every app! You get some functionality working, decide to add something.
Developing an app isn’t always ever a linear process, but there’s a lot to be learned in that.
This soup would be even better with the perfect cocktail, maybe a Neon Geek...
DrinkMixer has two views: a table view of the list and a detail view about each individual drink.
Sam wanted an app to make his bartending work easier.
You got one up and rolling pretty quick, but hit a snag filling in the details for each drink because of  a plist of  dictionaries.
When we last left DrinkMixer, it was in the middle of being debugged...
The debugger stopped our application and displayed the debugging console.
By setting a breakpoint in our code, what we discovered at the end of  Chapter 4 is that before your app got to the commands to import the file, there was no crash; so far so good.
Let’s walk through loading our plist and make sure that works by typing next twice.
The first “next” looks up the path to the plist, the second one actually loads the data.
It made it past loading the plist, so let’s let it continue running...
Let’s have the application continue running and see where it fails.
Hit the Continue button (or type continue in the console)...
Use the debugger to investigate the crash We can reliably get DrinkMixer to crash, and it doesn’t seem to be our plist loading code.
Xcode has suspended our application right before iPhoneOS shuts it down, so we can use the debugger to see exactly what it was trying to do before it crashed.
Switch back to the debugger and take a look at the stack in the upper left.
This is the call stack that led to the crash.
The buttons along the top of the debugger function just like the buttons in the console.
By default the console prompt isn’t shown in the debugger; the debugger is a GUI on top of it.
Trying to continue now will just keep failing - DrinkMixer has been stopped by iPhoneOS.
Using what you’ve learned so far, figure out what’s going on!
What dictionary is it talking about?  Where is it coming from?
Who’s sending messages to the dictionary? Why did we get an unrecognized selector?
We’re trying to stuff a dictionary into a string Putting a dictionary into the text field of  the label, which wants a string, isn’t going to work.
Our previous array was an array of  strings, so that code worked fine.
Now that we have an array of  dictionaries, we need to figure out how to get the drink name value (a string) out of  it, and then assign that to the text label.
Dictionaries store their values using keys; they’re just a collection of  key-value pairs.
Using what you’ve learned so far, figure out what’s going on!
What dictionary is it talking about?  Where is it coming from?
Who’s sending messages to the dictionary? Why did we get an unrecognized selector?
The dictionaries are coming from the plist! When we load the plist, we now have an array of dictionaries instead of an array of strings.
Messages are being sent to the dictionary when we try to set the cell’s label text.
It’s actually the label sending it a message (see the next stack frame, its code in UILabel)
It’s sending messages as though the cell label text was a string.
But now we’re assigning a dictionary to the label text!
Instead of assigning the array value right to the text label, you’ll need to pull out the name value from the appropriate dictionary.
After this, it should know that you’re using an array of dictionaries, not strings—and the detail view should have a reference to the drink it should display.
Finally, the detail view should populate its fields before it appears on the screen.
Add a reference to a drink dictionary in the detail view.
Don’t forget about the NSDictionary documentation if you want to know more about dictionaries.
Update your code to handle a plist of dictionaries Armed with the knowledge of  how the dictionaries are put together, we can use this information to populate the detail view, too.
If  you give the detail view controller the dictionary of  the selected drink, it can populate the view’s fields before the view is shown to the user.
We need to get that dictionary to the datasource of the detail view.
Go through the code and make sure that you’ve got everything right...
Test Drive Now that we’ve told DrinkMixer to deal with dictionaries, go ahead and build and run the app.
It’s working again! Now that it’s not crashing, it’s time to fill in the details.
The detail view needs data Now that you’ve figured out how to deal with dictionaries, it’s time to fill in the drink details.
But getting the details out of  the array of dictionaries to give to the datasource requires another step.
Remember this? We talked about this being the structure of the app.
Organize your dictionary constants to avoid bugs Since we’re going to need the name, ingredients, and directions keys in the view controller, we should clean up the code to start using real constants.
The view controller needs direct access to the datasource, and the easiest way to get to that data is going to mean some quick code refactoring.
Set the detail view controller’s drink property After you instantiate the detail view controller when a cell is tapped, you need to set the drink property on the new controller to the selected drink.
Add code to the detail view controller to populate the fields Before the detail view appears, the view controller should use the drink dictionary to set the contents of  the name, ingredients, and directions components.
Each dictionary has all the information we need Right now we’re just pulling the name of  each drink into the app using the name key.
In order to populate the ingredients and directions, we need to use the other keys.
We could just type those right into our code, but we’re better developers than that, so we’ll pull them up into constants.
The only thing left is getting the proper dictionary to the detail view controller so it can pull the information it needs.
Here’s all the added code to make the detail view work.
Add a method to the detail view controller to populate the fields3
Add this whole line to grab a dictionary from the array.
Q: We re-create the detail view every time someone taps on a drink.
A: For DrinkMixer it really won’t matter too much; since the view is pretty lightweight, we won’t suffer too much overhead recreating it when a drink is tapped.
However, for best performance you can refactor it to reuse the same detail view controller and just change the drink it should be showing when a row is tapped.
Q: Why did we have to pull out the dictionary key names into a separate file?
A: Having magic string values in your code is generally a bad idea—no matter what programming language or platform you’re using.
By pulling them up into constants using #define, they are checked by the compiler.
Q: I looked at the NSDictionary documentation and there’s a valueForKey: and an objectForKey:
The subtle catch is that NSDictionary usually just turns a call to valueForKey: into a call to objectForKey, and it looks like either one will work.
However, valueForKey actually checks the key you pass it and has different behavior depending on your key.
That’s almost never what you want (unless you’re doing Cocoa binding stuff, of course)
Is that app up on the App Store? Then I can just download it on my phone and start making even more tips!
Looks like there’s a market there! A quick submission to Apple and...
Sam, ready for your app to make his (and your) wallet fatter...
Later in the book, we’ll take you step by step through the process of  preparing.
Seriously, this can and will happen if you don’t follow the HIG.
We have a usability problem We know that the user needs to touch the name of  the drink to see the details about each individual drink, but how is the user supposed to know that? The HIG has a number of recommendations for how to deal with drill-down, hierarchical data.
We’re already on the right track using table views but the HIG has a number of  additional recommendations for helping the user understand how to navigate the app.
It’s time to dive into the HIG and figure out what went wrong.
Here is the root view that users see, the table view.
When the user taps, the view controller hands off control to the detailed view.
The HIG mentions detailed disclosure buttons and disclosure indicators—which should we use? Why?
Table cells have a number of built-in usability items that help users understand how to use your app - even if it’s the first time they’ve run it.
We’re already using the navigation controller’s back button to help the user know how to get back to where they came from...
So, what exactly is the disclosure indicator element, and where does it go? Let’s look a little deeper in the HIG:
In the HIG, Chapter 8, the “Configuring a Table View” section, you can pretty quickly find out why you’re in violation over those disclosure indicators:
DrinkMixer uses really basic cells, but you can easily customize your cells for a different app, besides just adding disclosure indicators.
Even though the table only supports one column, you can make it look like more by adding a thumbnail, for example.
You can also adjust the font sizes to open up some room for each table cell if  you need to.
Most really polished apps use some kind of  table cell customizing, so keep that in mind while you’re looking through the API.
For now, we just need to add the disclosure icon to our cells to indicate there’s more information available if a user taps on them.
The HIG mentions detailed disclosure buttons and disclosure indicators—which should we use? Why?
It’s time to dive into the HIG and figure out what went wrong.
Adding a disclosure indicator is simply a matter of  telling the cell what type of  accessory icon it should use.
Take a look at the UITableViewCell documentation for some of the other options.
There’s just one quick line of code to set the cell’s accessory type when we configure the cell:
Test Drive One little line of code fixed all of your App Store approval issues.
After resubmitting to the App Store, DrinkMixer is up on iTunes!
This app is great! I’m going to use it every night.
I’m going to switch to iDrink it’s more expensive, but it lets me add new drinks and customize my list.”“I don’t like any of the drinks on the.
Think about how you originally designed DrinkMixer and the feedback, and figure out what you’ll do next.
Given the structure of  DrinkMixer, how would you refactor the code to fix the problem?2
Is there an easy way to fix the code? A hard way?3
Think about how you originally designed DrinkMixer and the feedback, and figure out what you’ll do next.
The easiest way to fix the problem is to update the app so users can add more drinks to the list.
We could add a new view that lets users enter their drink information.
It could look like the detail view, but allow them to type in the information they want.
We’d have to be able to save that new information and update the table to show the new drink.
There are lots of hard ways and probably a few good “easy” ways.
In general, the easiest way for us to add this functionality is to reuse as much of what we’ve already done as possible.
We can definitely take advantage of our navigation controller, and let’s see if we can’t do something useful with our DetailDrinkView too...
How would you go about implementing a view where users can add drinks to DrinkMixer?
Think about how you originally designed DrinkMixer and the feedback, and figure out what you’ll do next.
Given the structure of  DrinkMixer, how would you refactor the code to fix the problem?2
Is there an easy way to fix the code? A hard way?3
Some kind of button in the navigation controller to kick off a new view.
Add a new toolbar with some buttons below the nav controller.
You’d have room for an add button and others, when you need them.
Here is the table view for DrinkMixer with two possible designs.
Based on aesthetics, usability, and standard iPhone App behavior, which one is better for showing the users where they should add a drink?
Because by putting the icon in the nav controller, you don’t take up more space.
Option #2 makes the interface a bit more cluttered, and requires more code.
This type of interface is good when you have several new views to add, not just one.
There’s also built-in support for that button in the nav controller already.
The toolbar will cover up part of the table view, too.
Based on aesthetics, usability, and standard iPhone App behavior, which one is better for showing the users where they should add a drink?
Users will be able to tap the + button to add a drink.
Using Xcode, add the button to the Nav controller and the associated IBActions and IBOutlets.
Scroll through the library and drag a Bar Button Item to the Main Window (this will add it to the list after the table view)
It won’t show up on the navigation controller in Interface Builder—we’ll need to add code so it shows up at runtime.
Finally, pull up the inspector for the Bar Button Item and change the Identifier to Add.
It won’t show up because the navigation controller in Interface Builder is SIMULATED, not real.
Use navigation controller buttons for editing So far we’ve used the navigation controller to move between views.
But if  you’ve spent much time with other iPhone apps, you know it’s capable of  much more.
Since a UITableView is almost always embedded in a navigation controller, table editing is usually done through buttons on the controller itself.
Let’s start out by adding a + button to the navigation controller that will let the users add a drink when they tap it.
Using Xcode, add the button to the nav controller and the associated IBActions and IBOutlets.
Scroll through the library and drag a Bar Button Item to the Main Window (it will get added to the list)
Finally, pull up the inspector for the Bar Button Item and change the Identifier to Add.
The button shows up in the view, but now what?
The button works! Now you get an affirmative message in the console...
What do we need for the user to be able to enter a new drink? Exactly what fields do you need and how will you lay them out? How will the view controller work?
The button should create a new view Our new button works: the action gets called, but really doesn’t do anything useful yet.
We need to give our user a place to enter the new drink information and we can do that with a new view.
Just like with the detailed view, we can let the navigation controller handle the transition.
These are the directions, mix, pour over ice, then layer the rest.
Touching the disclosure indicator moves you into the filled-out information about that particular drink.
The add drink view needs to contain exactly the same fields as the detail view—it just needs to be editable.
When you click on these text fields, the keyboard will pop up and let you enter new information.
So instead of  creating a whole new nib, let’s take advantage of  the fact that the UI (the nib) is separate from our behavior (the UIView subclass in the .m file), and reuse the detail view.
Up until now we’ve had a one-to-one pairing between our nibs and our view controllers.
That’s definitely the norm, but our view controllers are really just normal Objective-C classes.
We can use object-oriented extension mechanisms like inheritance to add the behavior we want.
We need to support different behavior than the detail view controller, though.
Really, a new view controller but not a new nib? I thought they always go together.
Remember that a nib is just the XML representation of  a view.
Using nibs is a lot easier than trying to lay out your view using code.
And since the nib is just graphical information, you need to put the actual code somewhere.
The view controller defines the behavior for the view From the user’s perspective we’ll have three views: the table view, the detailed view, and the new drink view.
But, since we’re reusing the .xib to create the “new” view, all we need is a new view controller class that supports adding a drink.
That means there isn’t any Interface Builder work to do at all!
These are the directions, mix, pour over ice, then layer the rest.
Separating the UI from behavior helps you reuse your view.
Reusing both the the nib file and the detail view controller is also an option...
Remember, we don’t just use Interface Builder to lay out the interface; we use it to wire up the components to the class that will load the nib.
When you pass the nib to the view controller, it will deserialize the nib and begin making connections to the outlet names stored in the nib file.
This means if  we want to pass that nib into another, new view controller, we need to make sure we have the same outlets with the same names, the same actions, etc.
Reusing our nib gets us what we need for this app, but it’s not for every app out there...
Because of the way DrinkMixer is built, we can just subclass our detailed view to get what we need.
That works great for this app, but be careful doing this in more complex apps, because your code.
Often, it’s better to just bite the bullet and build a new view...
Q: I still don’t get it about the new view controller without a new nib.
A: There’s nothing in that nib that you couldn’t create in normal Objective-C by hand.
As you’ve likely discovered with Interface Builder, nibs are generally a lot easier to work with than trying to lay out your view using code, so when you create a new view, you typically create a nib to go with it.
But really, you could build an entire application without a single nib.
In our case, we’re going to do something somewhere in the middle: we’re going to create a new view but reuse the UI information from another view.
Q: So why the “Watch it” warning about reusing the nib? Is this a good idea or not?
For DrinkMixer, we can reuse our DetailDrinkView and its nib since we want the layouts to look the same and the DetailDrinkView doesn’t really do anything specific.
However, in a more complex application, you might run into problems where you’re constantly fighting between the two view controllers or you have to expose so much information to the subclass that your code becomes unmaintainable.
This isn’t a problem unique to iPhone development; you always have to be careful when you start subclassing things.
For our app, subclassing works fine, and you’ll see it in some of Apple’s example applications, too (which is part of the reason we included it here)
But it’s equally likely that in some other application you’ll want views to be similar, but not quite exactly the same.
In those cases, create a new view controller and nib.
This new view will get all of  the fields, behavior (which we’ll change), and the nib we need.
A: We could do that, but the problem is we’re not just dealing with GUI layout.
We have text fields and labels in there that need to get populated.
We’d have to reimplement that in our new view controller if we didn’t subclass.
Q: Is this some kind of contrived Head First example or should I really be paying attention?
This pattern shows up pretty often and a lot of Apple’s example applications use it.
It’s very common, particularly in table-driven applications, to have one view that just displays the data and another to edit it when the user puts the table in editing mode (we’ll talk about that more later)
Sometimes you should use totally different views; sometimes you can reuse one you have.
If you don’t put an access specifier there, Objective-C defaults to protected for fields.
Joe: That makes sense—we used the navigation controller to drill down into the data just by pushing a detailed view on the stack...
Frank: Adding a new drink to our list is a little different, though.
Frank: Well, adding a new drink is really a sub-task.
Frank: The users are stepping out of  the usual browsing drinks workflow to create a new drink.
Frank: Right, so for times like this, it’s important to communicate to the users that they have to complete the task.
Which of these views better communicates what the user needs to do? Is one more ambiguous than the other?
Modal views focus the user on the task at hand...
When users navigate through your app, they are used to seeing views pushed and popped as they move through the data.
However, some tasks are different than the normal drilldown navigation and we really need to call the users attention to what’s going on.
These are normal views from the developer perspective, but feel different to the user in a few ways:
They have to either save the added drink, or discard (cancel) it, before they can return to the main DrinkMixer app.
The modal view is going to cover up the navigation control...
Modal views have to be dismissed - either by saving the changes or cancelling out of the view.
Any view can present a modal view Up until now we’ve presented new views using our navigation controller.
Things are a little different for modal views: any UIViewController can show a modal view, then hide it when necessary.
Since our RootViewController is the view controller that needs to show the modal view, we can just send this message to ourselves, using self, like this:
Be careful about your memory management—don’t leak references to the controllers.
If you say NO to animated, then the view just appears.
By saying YES, we get the smooth slide in from the bottom.This is the view controller.
The RootViewController will retain a reference to the new view controller when we present it.
Don’t forget to release the reference to the view controller!
Test Drive Now that the add view is fully implemented, build and run the project.
Make sure you try out all of the functionality: scrolling, drilling down to details, and finally adding a drink.
Touch in the title to bring up the keyboard and make sure it works.
If your keyboard isn’t working, your fields might still not be editable.
Back in Chapter 4, we had you make the fields uneditable in Interface Builder.
If your keyboard isn’t appearing, try going back into Interface.
That’s great, but after I type in the drink, nothing happens! I can’t get the view to go away, and I can’t add the drink.
The add drink detail view needs to go away one of  two ways: either the user cancels out or saves the drink.
How should we lay out the save and cancel buttons?
Our view doesn’t have a navigation bar To be consistent with the rest of  DrinkMixer, we really should put the save and cancel buttons at the top of  the view in a navigation bar.
The problem is, we don’t have one in our modal version of  the detail view.
We could add one by hand, but remember we’re sharing the detail drink view nib, which gets its navigation bar from the navigation controller.
Since we’re showing the add drink view as a modal view, we cover up the navigation bar.
Instead of  trying to solve this from within the detail drink view nib, we can embed our add drink view in a navigation controller of  its own, like this:
The detail view is pushed on top of the table view, preserving the nav controller.
This will add a nav controller to wrap the add drink detail view.
Instead of presenting our addDrinkVC, we present the addNavCon view controller.
It will retain the controller, since it needs to display it.
It works! The modal view has a nav controller and your buttons have a home.
Notice our “autorelease” here - normally we alloc a class, assign it to where it needs to go, then release our reference to it.
By autoreleasing when we create it we ask Objective-C to handle releasing it for us later.
Not quite as efficient as explicitly handling it ourselves, but a little cleaner-looking in the code.
Just like when we made an add b utton, we’re.
Create the save and cancel buttons Since both the save and cancel buttons need to dismiss the modal view, let’s start by wiring them up to do that.
We’ve covered how to do that in Interface Builder, so we’ll write them in code this time.
Since we’re using the navigation bar, we get built-in support for left and righthand buttons.
We just need to create those buttons and assign them to our leftBarButtonItem and rightBarButtonItem to have them placed where we want them.
Start this at the bottom of the file, just before the dealloc.
Write the save and cancel actions When the user clicks either Save or Cancel, we need to exit the modal view by asking the view controller that presented the view to dismiss it.
However, to make things easier, we can send the modal view the dismiss message, and it will automatically forward the message to its parent view controller.
Since we are in the modal view, this dismiss message will be delegated up to our parent view controller, which will actually make the view go away.
Test Drive The modal view can be dismissed now, and the keyboard works too!
Just like that, the buttons are in the detail view.
This chapter, you’ve learned how to add a view and pass it through the navigation stack to pop the view, plus you reused the nib you already created and wired it up for a.
Q: Why don’t we need an outlet for the save/cancel button? And what about Interface Builder?
A: The navigation controller API has support for both left and right buttons; you just need to initialize them with the buttons you want to use (save and cancel buttons, for instance)
So can I add some new drinks yet? I just learned how to make this cool new one from another bartender and want to put it in my app.
You can create  ________________ bars in the IB or in code.
You’ve got Chapter 5 under your belt and now you’ve.
Debugging If you know where your problem is likely to be, set the breakpoint there.
You can use the debugger to step through the problem area.
If you have no idea where to start, you can step through the entire app!
Approvals can take weeks, so try and get it right the first time.
Once your app is up for sale, the reviews stay with it, even with updates.
Views Are pushed onto the stack via the table view or buttons.
Modal views force the user to interact with them before they can be dismissed.
You can create  ________________ bars in IB or in the code.
If these records were on an iPhone and I could edit them life would be grand!
Displaying data is nice, but adding and editing information is what makes an app really hum.
DrinkMixer is great—it uses some cell customization, and works with plist dictionaries to display data.
In this chapter we’ll take a look at editing patterns in iPhone apps and how to.
Sam was clicking around, ready to add his new drink.
We have a problem with our view, since we can’t get to some of the fields.
Sam went to try DrinkMixer with the new add view, and ran into problems right away.
You can’t see the directions at all, and part of the ingredients information is covered up.
When Sam taps on a control, it gets focus (becomes the first responder) and asks iPhoneOS to show the keyboard.
How did we deal with the keyboard last time? Will that work this time? What do you want the view to do when the keyboard appears?
When Sam taps in the Drink name field, the keyboard appears like it’s supposed to—that’s good.
We had a similar problem in InstTwit where the user couldn’t get to the controls under the keyboard.
In DrinkMixer it would be fine for the name field, but what about the directions and the ingredients fields? As soon as they keyboard comes up, they’re covered.The user has a smaller screen to work with once the keyboard shows up - we need to set up the view to scroll things in when the user needs them.
How did we deal with the keyboard last time? Will that work this time? What do you want the view to do when the keyboard appears?
The scroll view draws and manages a scroll bar, panning and zooming, and what part of  the content view is displayed.
It does all of  this by knowing how big the area it needs to show is (called the contentSize) and how much space it has to show it in (the frame)
All a scroll view needs to care about are the subviews it has to manage.
It doesn’t matter if  it’s one huge UIImageView that shows a big image you can pan around, or if  it’s lots of  text fields, buttons, and labels.
To get a scrollable view, we need to move our components into a UIScrollView instead of  a UIView.
The scroll view clips the content view so that only a portion is visible to the user.
UIScrollView has built-in support for zooming and panning around the content view—you just need to tell it how big the content is.
The components shown to the user are considered the content view; the scroll view acts like a window into that view.
The content doesn’t have to be just buttons and text fields; UIScrollViews work well with images too.
The scroll view will be the size of the entire view (minus the nav control)
Remember when we said sometimes Interface Builder makes things (a lot) easier? This is one of  those times...
All of these components need to be children of the scroll view.
You mean we have to pull all those components off and then lay out the view again? Isn’t there an easier way?
We need to wrap our content in a scroll view We want the user to be able to scroll through our controls when the keyboard covers some of  them up.
In order to do that, we need to add a UIScrollView to our view and then tell it about the controls (the content view) we want it to handle.
Interface Builder will create a UIScrollView just big enough to hold all of our components.
Since we want the whole view to scroll, grab the corners of the new UIScrollView and drag them out to the corners of the screen, right up to the edge of the navigation bar (we don’t want that to scroll)
Now you have the same listing of widgets as before, but they are under a scroll view.
Apparently we aren’t the only people to realize after we’ve built a view that it needs to be scrollable.
Interface Builder has built-in support for taking an existing view and wrapping it in a UIScrollView.
How will this new scroll view know how much content needs to be scrolled?
The scroll view is the same size as the screen Interface Builder created the UIScrollView, but there are a few finishing touches we must do manually to make this work the way we want.
We need to tell the UIScrollView how big its content area is so it knows what it will need to scroll.
You’ll need to add an outlet and property for the UIScrollView, then wire it up in Interface Builder so we can get to it.
So how do we figure out how big the contentSize should be? When the UIScrollView is the same size as our screen, we don’t have anything outside of  the visible area that it needs to worry about.
Since the scroll view is the same size as our UIView that it’s sitting in, we can grab the size from there, like this:
Once you resize it, the UIScrollView and its contentSize are the same size.
We just need to tell that to the scroll view.
You’ll need the field declaration and IBOutlet property, then you will synthesize it in the .m and release it in dealloc.
Wire up the new property to the UIScrollView in Interface Builder by adding a new Referencing Outlet to the UIScrollView connected to your scrollView property.
Remember, we’re telling the scrollView that its content is the same size as the view it’s sitting in.
Add a field and a property for the new scrollView.
You’ll need the field declaration, an IBOutlet property, synthesize it in the .m and release it in dealloc.
Why isn’t it working yet? Think about all the things that you have going into this view—the scroll view, the main view, and the keyboard...
Wire up the new property to the UIScrollView in Interface Builder.2
The keyboard changes the visible area The problem is the keyboard changes the visible area but the scroll view has no idea that just happened.
The scroll view still thinks it has the whole screen to display its content, and from its perspective, that’s plenty of  room.
We need to tell the scroll view that the visible area is smaller now that the keyboard is there.
Just because iPhone knows that the keyboard is there, it doesn’t know how your app wants.
In DrinkMixer the content view is the same size as our scroll view’s initial size, which is the whole screen...
Wouldn't it be dreamy if iPhone could just tell the app when the keyboard appears? But I know it's just a fantasy…
Just like component events being passed around our application, there are system-level events, called Notifications, that are being passed by the iPhone OS.
The secret to knowing what’s going on with the keyboard is tapping into these events.
Sam taps in the Drink name field and the field becomes the first responder.
Objects are registered by providing a selector (method) to call if  the event is triggered.
Then unregister when you’re done Just like memory management, we need to clean up our registrations from the notification center when we don’t need them any longer.
We’ll register for events in viewWillAppear: and unregister in viewWillDisappear:
Unregistering for an event is easy—just ask the notification center to removeObserver for the object you registered.
You can get a reference to the default one by calling:
Since we will only register for keyboard events when our window is visible, we don’t care who sends the event.
Make sure you unregister from the same notification center you registered with.
Don’t forget the colon here, because you’re going to get details about the notification as an argument.
Head First: Um, this is embarrassing but I’m not entirely sure I have the right Notification Center here...
Notification Center: Well, unless you need something weird, it’s probably me.
Head First: Wow—so you know about every app that starts and stops?
I’m the default center; all the system events go through me.
Now, not everybody is interested in what’s going on, but if  they want to know, I’m the guy to see.
Head First: So when someone wants to know what’s going on, they tell you what they’re interested in, right?
If  somebody wants to know about somethin’ in the system, they register with me.
They tell me the notification they want me to watch for, who I should tell when it happens, and, if  they’re really picky, who should have sent it.
Head First: So then you tell them when that notification happens?
Notification Center: Right—they tell me what message to send them when I see the notification they were interested in.
I package up the notification information into a nice object for them and then call their method.
Doesn’t take me long at all; the sender almost always waits for me to finish telling everyone what happened before it does anything else.
Notification Center: Well, the sender could use a notification queue to have me send out the notifications later, when the sender isn’t busy, but that’s not typically how it’s done.
Head First: Hmm, this sounds a lot like message passing.
The sender wants to tell somebody that something happened, you call a method on that somebody...
Notification Center: It’s similar to message passing, but there are some differences.
First, the senders don’t need to know who to tell.
They just tell me that something happened and I’ll figure out if  anyone cares.
Second, there might be lots of  people interested in what’s going on.
In normal message passing the senders would have to tell each one individually.
With notifications they just tell me once and I’ll make sure everyone knows.
Finally, the receiver of  the notification doesn’t need to care who’s sending the message.
If  some object wants to know that the application is shutting down, it doesn’t care who’s responsible for saying the app’s quitting, the object just trusts me to make sure they’ll know when it happens.
Anybody can ask me to post a notification and if  anyone’s registered to get it, I’ll let them know.
Head First: How do they know which notifications to send?
Different frameworks have their own messages they pass around, you’ll have to check with the framework to see what they’ll send out.
If you’re going to be posting your own notifications, you almost certainly don’t want to go blasting out someone else’s notifications; you should come up with your own.
They’re just strings—and a dictionary if  you want to include some extra infonothing fancy.
Fill in the blanks and get a plan for the next step!
We’ll adjust the size of  the when the keyboard appears and disappears.
Now you have a plan for what to do next.
Q: I can’t find the list of notifications that are sent by the iPhone OS.
A: There isn’t a central list of all the notifications that could be sent.
For example, the UIDevice class offers a set of notifications to tell you about when the battery is being charged or what’s happening with the.
Apple’s documentation is usually pretty clear about what notifications are available and what they mean.
The keyboard notifications are described in the UIWindow class documentation.
Q: Why would I want to create my own notifications?
Remember, notifications let you decouple the sender from the receiver.
For example, let’s say you had a view that let you add or remove items from your application and your app has several different ways to view those things.
Notifications could give you a nice way to announce to all of the other views that something has changed without your add/ remove view needing to have a reference to each of them.
We’ll adjust the size of  the when the keyboard appears and disappears.
Go ahead and make the changes to your code to register for the keyboard events.
We’ll implement the code to handle the scroll view shortly.
For now, just have them print out an NSLog when they are called.
Both methods should take an NSNotification*, as they’ll be called by the notification center and will be given notification information.
A stub for this method is included with the template, but it’s commented out by default.
Go ahead and uncomment it and add the code to unregister for events.
We’ll talk more about this in a minute, but you’re going to need a flag to keep track of  whether the keyboard is already visible.
These are both new methods for the keyboard notifications in the implementation file.
If you don’t give it a notification to unregister from, it will remove you from anything you’ve registered for.
We need to keep track of whether the keyboard is showing or not.
Go ahead and make the changes to your code to register for the keyboard events.
We’ll implement the code to handle the scroll view shortly.
Keyboard events tell you the keyboard state and size The whole point of  knowing when the keyboard appears or disappears is to tell the scroll view that the visible area has changed size.
We need to know how big the keyboard is so.
The notification object contains the name of the notification and the object it pertains to (or nil if there’s no related object)
Getting the notification is easy, but we get told every time the keyboard is shown, even if it’s already there.
That’s why we need the BOOL to keep track of whether or not the keyboard is currently displayed.
If the keyboard isn’t visible when we get the notification, then we need to tell our scroll view its visible size.
If the keyboard is hidden, we set the scroll view back to full size.
Keyboard Code Magnets Part I Below are the code magnets you’ll need to implement the keyboardDidShow method.
Use the comments in the code on the right to help you figure out what goes where.
Resize the scroll view to make room for the keyboard.
Keyboard Code Magnets Part II Below are the code magnets you’ll need to implement the keyboardDidHide method.
Use the comments in the code on the right to help you figure out what goes where.
Reset the height of the scroll view to its original value.
Resize the scroll view to make room for the keyboard.
We will get this notification whenever the user switches text fields, even if the keyboard is already showing.
So we keep track of it and bail if it’s a repeat.
NSNotification contains a dictionary with the event details; we pull that out here.
Finally, update the scroll view with the new size and mark that the keyboard is visible.
Keyboard Code Magnets Solution Below are the code magnets to work with the keyboard...
Reset the height of the scroll view to its original value.
Once you get into the detail view, you should be able to scroll the view to the right field, and the messages in the console help you keep track of what’s going on.
Q: Manipulating that scroll view size is kind of tricky—how would I have figured that out without magnets?
A: A great reference for the code samples and information for programming apps in general is the iPhone Application Programming Guide that is available on the Apple developer website.
That has sample code for common problems like handling the keyboard events, using the GPS, etc.
Q: Tell me again why we need to keep track of whether the keyboard is already visible? Isn’t iPhone doing that?
You need to keep track of whether you already knew it was visible so you don’t resize the scroll view to the wrong size.
Q: The scroll view works, but depending on what the users pick, they still have to scroll to the widget?
The iPhone Application Programming Guide has good sample code for that.
Q: Do we really need to use the keyboard size stuff in the notification? Isn’t it always the same?
A: It’s not always the same! If your application is landscape.
If your app is portrait, then it’s taller than it is wide.
Apple also makes it clear that they may change the size of the keyboard if necessary and you should never assume you know how big it is.
Everything scrolls OK, and I can put a drink in, but as soon as I get back to the list, it’s gone!
Sam’s drink is missing! As soon as he leaves the drink detail view.
We need to figure out how to keep it around longer...
Answer the following and think about what it means for our app.
What happens to new drinks when the user hits save?
Answer the following and think about what the answers mean for our app.
What happens to new drinks when the user hits save? We dismiss the view and the drink information.
We need to add some code to the save method that actually stores.
Since we already store our drinks in dictionaries, we can.
We can create a new dictionary by allocing it, but we’re going to need to get a reference to the array from somewhere.
What’s going to take a little more work is adding it to the drink array.
We could have the RootViewController pass the new drink in after we’ve created it...
Give the AddDrinkController a reference to the master drink array.
You’re going to need to add a field to the class, a property, and then synthesize it and release the reference in dealloc.
Finally, you need to make sure that the RootViewController passes on a reference to the drink array when it’s setting up the AddDrinkController.
You need to update the save: method to get the drink details from the controls and store them in a new dictionary.
After that, add the dictionary to the master drink array using addObject:
We need the constant key names so we can populate the new dictionary.
Since we want to add keys and objects, we need to create a mutable dictionary.
What problems could you run into later if you created an immutable version?
Since we alloc’ed it, we need to release our reference.
The Case of  the Missing Reservations Nicole has been a Maitre d’ at Chez Platypus since it opened nearly 10 years ago.
This upscale restaurant has a number of distinguished customers who like their dining experience to be just perfect.
The VIP guest list hasn’t changed in years and Nicole knows everyone’s face.
She sends them right to their favorite table when they show up and makes sure everything is just right.
Restaurant management dug up the dusty VIP list and added the scientist’s name at the bottom, along with all the detailed instructions for making sure everything was “just so” when he arrived.
They trusted that Nicole would would take good care of  him and didn’t give it another thought.
Last night, their new investor arrived a few minutes before some of the other VIP guests.
She continued to move the regular VIPs to their seats and, for all she knew, their new investor did not even exist.
Test Drive That was a lot of code! Run the app and make sure everything is working.
Here’s a drink to add to the list (it’s the new house drink in the Head First Lounge)
Add the whiskey, then the cream soda to a shot glass and drink.
Test Drive To properly test the app now, click the add button and enter the data for the new drink in the detail view.
We implemented the save method, created a new drink, added it to the array...
Before we move on, let’s use the debugger and do a quick sanity check.
After looking at the initial values, go ahead and continue the application and add a new drink.
Now we’re going to use the debugger to help us figure out what’s going on.
What did you find? The array initially has 40 dictionaries in it; after adding our new drink, it.
We’ve added it to the drink array, has one more.
If we use that console command we can step through them and see that it’s right.
We have 41 objects in the drink array now! That’s our new drink, so we’re adding it to the drink array correctly.
Nicole hasn’t needed to look at the VIP list in years.
She was so concerned that their important customers feel welcome that she didn’t want to have to do something as crass as go back and read a list every time someone arrived.
She made a point of memorizing that list so when they came to the restaurant she could recognize and seat them immediately.
As far as Nicole knew, there were 10 VIPs on that list and she knew them all.
The problem was that the list was changed and no one told her.
All it would have taken was a simple “heads up” to Nicole that there was a change to the list and the restaurant’s newest investor wouldn’t have disappeared...
The table view doesn’t know its data has changed The table view does a number of  things to improve performance as much as possible.
As a result, if  you just change values in the datasource without telling it, it won’t know that something has changed.
In our case, we added a new value to the array used by our datasource but didn’t let the table view know about it.
You need to ask the table view to reload its data Since we’re modifying the underlying data used by the datasource, the easiest way to refresh the table is to ask it to reload its data.
This tells the tableview to reconstruct everything—how many sections it thinks it has, the headers and footers of  those sections, its data rows, etc.
Ask the table view to reload its data right before the RootViewController appears.
The controller modified the drink array used by the datasource...
Add the whiskey, then the cream soda to a shot glass and drink.
Test Drive To properly test the app now, click the add button and enter the data for the new drink in the detail view.
Uhh—that drink is at the end of the list, not in with the Rs.
Q: Telling the table to reload all its data seems pretty drastic.
A: It’s the simplest way to refresh the table data, but not necessarily the most efficient.
If you’re modifying the table while it’s visible, you can call beginUpdates and endUpdates to tell it you’re about to make a number of changes and it will animate those changes for you and let you avoid a reloadData call.
There are also versions that only reload the specified rows or for a given section.
Which you use depends on your application, how much you know about what changed in your data, and how big your dataset is.
Q: We didn’t add any code to the cancel button.
This will clean up any memory associated with the controller and throw away any data the user entered in the fields.
As long as we don’t manipulate the drink array, we’ve properly canceled any action the user started.
Q: Why can’t I see the drink information in the debugger when I expand the drinks array and dictionaries?
The debugger knows the class is a dictionary, but that’s about all it can tell us, since all of the keys and values are dynamic.
You can get to them through the debugging console, but that’s not as convenient as seeing real attributes on classes when you debug something.
Q: Did we really need to use the debugger back there? Couldn’t I have just printed out how many items were in the array using NSLog?
A: Sure, but then you wouldn’t have been able to practice debugging again...
Why is the drink showing up at the bottom of the table? What do we need to do?
We can sort our array using NSSortDescriptor In order to get the table view properly sorted, we need to sort our data array.
You tell descriptors what to compare by specifying a property, how to compare them with an optional selector, and then which order to display the information in.
In our case, we’re looking for alphabetical sorting by the name of  the drink.
Add this in the save method after you add the data to the array but before the view gets popped off the stack.
The array is out of order, too Our table view gets its information directly from our drink array.
We want the NSSortDescriptor to sort based on drink names.
If we didn’t provide a selector, it does a case-sensitive comparison, but we want a case-insensitive one.T.
Let’s add another drink; this one should end up in the right place.
Great, that new drink is there, but what about the Red-Headed Schoolgirl from before? Don’t we need to deal with saving more permanently?
We’re positive we’re updating the array with our new drink, but obviously that new array doesn’t survive quitting and restarting our app.
What do we need to do?  When should it happen?
Jim: OK, so we should save the array after each new drink is added, right? That will make sure we always have the right data.
Frank: But that means you could be saving out every time you add a drink.
Jim: Oh, I see, that means we’ll have to go through reading in the array and saving it back out multiple times.
Joe: Well then, when are we supposed to do it?
Frank: When we exit! The app will keep the data present until it closes, then it’s lost without some kind of  save.
Jim: How do we do that? How can we tell when the user exits?
Joe: But the app delegate doesn’t know anything about our drink list or where to save it...
Q: Do I need to register to receive it? A: Yup—just like any other notification.
Q: What if the user hits the home button or the phone rings or...?
Q: What happens if my app crashes? A: Then you’re not going to get the notification.
You need to balance how critical it is to make sure no data is lost with the performance impact of saving more frequently.
In our case, we’re just going to save on exit.
Use your skills at working with the API and what Jim, Frank, and Joe were discussing to figure out what to implement to save the array.
Add the code to save out the new plist of dictionaries.
We’re going to give you a little code snippet to use.
The code used to save the plist will work fine on the simulator, but fail miserably on a real device.
The problem is with file permissions and where apps are allowed to store data.
We’ll talk a lot more about this in Chapter 7, but for now, go ahead with this version.
Use your skills at working with the API and what Jim, Frank, and Joe were discussing to figure out what to implement to save the array.
This is the code that’s going to give us problems on a real device.
We’ll run into this again (and fix it) in the next chapter—bear with us for now....
The stop and “Build and Run” in Xcode are NOT the same as the home key and relaunching the app in the simulator!
When you stop the app using Xcode’s stop button, you are killing the app right then and there.
No termination notifications are sent, no saving is done—it’s just stopped.
Likewise, when you click Build and Debug, Xcode will reinstall the application on.
To test our load and save code, make sure you restart the app by tapping the icon in the simulator.
Author’s note: we thought about showing the same screenshot twice, but figured that still wouldn’t prove that it saves after hitting the home key and coming back in.
Pour the liqueur and vodka over ice and then fill with pineapple juice and garnish with a grape.
Make sure when you run DrinkMixer the second time you tap on the icon in the simulator; don’t hit Build and Debug again!
Can I just put any object in there and have it save to a plist?
Arrays load and save using a Cocoa technique called NSCoding.
Any objects you want to load an save must conform to the NSCoding protocol, which includes initWithCoder and encodeWithCoder methodbasically, load and save.
You’d need to conform to the NSCoding protocol and provide those methods to be serializable in and out of an array.
However, NSDictionaries do conform to NSCoding (as do the strings inside of them), and that’s why we can load and save so easily.
Q: What is the deal with giving us code that won’t work on the device? What happens?
A: Well, to find out what happens, we encourage you to run it on a real device.
Then think about why it isn’t working the way you’d expect.
We’ll talk a lot more about this in the next chapter.
To give you a hint, it has to with where we’re trying to save the data.
This is also a real world example of something working just fine in the simulator only to behave differently on a real device.
Q: Instead of registering for that quit notification, couldn’t we have just updated the AppDelegate to get the drink array from the RootViewController and save it in the delegate?
It’s more of a style and design question than anything else.
You could argue we’d be breaking encapsulation if we exposed what needs to be loaded and saved for each view up to the AppDelegate.
Since we only need to save a single array, it’s not a big deal either way, but if you have a number of views that need to save information or complex persistence code, it can often be cleaner to leave it with the class that needs to know about it rather than lumping it all into the AppDelegate.
Q: Why did we register and unregister in the viewDidLoad and viewDidUnload methods instead of the *Appear methods?
A: The problem is when and how often those methods are called.
That starts out OK—we’ll get that call before the table view shows up and we can register.
If we unregister there we won’t get the termination notification if the user decides to quit while looking at the details for a drink.
For example, say the user adds a new drink, goes back to the RootViewController then taps on his drink to make sure he entered it correctly.
We show the detailed view, he’s happy, then he quits the app.
Our RootViewController has unregistered for the termination notification and the drink is lost.
Instead, we use the load and unload methods, which are called when the view is loaded from the nib or unloaded.
Since that view is in use throughout the application, those won’t be called except at startup and shutdown.
Q: What’s the deal with hitting “Build and Run” versus tapping on the icon to start DrinkMixer the second time?
We’ll talk more about it in the next chapter, but the problem is when you hit.
This means it’s replacing the modified drink plist with the one that we ship with the application and you lose your drink.
That’s great! Now I can add the extra drinks I need.
But there are a couple of other things that I need to really make this app work for me.
Delete drinks that aren’t used to keep the list small and easy to use.
Edit the ingredients for drinks that were already in the list.
How can we implement these things? Where in the app do we need to handle this stuff?
Table views have built-in support for editing and deleting Good news! The table view comes complete with almost everything we need for deleting data.
This is behavior that acts a bit like implementing a save or cancel button, and a lot of  it comes preloaded.
Editing mode adds an edit button to the navigation control in the main view, and when it’s pressed, indicators appear to the left of  the table cell that can be selected and deleted like this:
This button will read “edit”, and then when pushed it will display the delete icon and change th.
The edit button in the view tells the user how to.
The delegate will handle which mode the table is in and handle deleting drinks.
The drinks array will be modified as needed after the drinks are deleted.
Using the view below, write what each part of the editing view does.
Using the view below, write what each part of the editing view does.
The Done button turns off editing mode and puts the table back to normal.
The delete icons let the user delete a row from the table.
The + button is unchanged: it lets us add a new drink.
When tapping on a row in edit mode, we should be able to edit a drink instead of just displaying it.
The Xcode template comes with a good bit of the code we’ll need, and at this point you’re pretty familiar with the RootViewController and the table view.
We’ll give you some hints on what to implement next, but let you take it from here.
We need an edit button in the upper left of  the navigation bar.
Once the table view is in editing mode, we’ll get a call when the user tries to delete a row either by swiping across the row or tapping the delete indicator.
Most of this method is stubbed out for us too, but you’ll need to add code to update the datasource with the change.
Remember, we’ve been mapping rows to indexes in our array.
Lastly, you don’t need to call reloadData after this change because we ask the tableView to explicitly remove the row.
You’ll need to tell the app that it must edit a drink instead of  creating a new one, then have it populate the controls with the existing information, and finally update the drink on save.
Check that “Allow Selection While Editing” is checked for the Drinks table view.
We need an edit button in the upper left of  the navigation bar.
Once the table view is in editing mode, we’ll get a call when the user tries to delete a row either by swiping across the row or tapping the delete indicator.
Most of  this method is stubbed out for us too, but you’ll need to add code to update the datasource with the change.
Remember, we’ve been mapping rows to indexes in our array.
Lastly, you don’t need to call reloadData after this change because we ask the tableView to explicitly remove the row.
Uncomment the following line to display an Edit button in the navigation bar for this view controller.
All we need to do is add it to the nav bar.
The Xcode template comes with a good bit of the code we’ll need, and at this point you’re pretty familiar with the RootViewController and the table view.
We’ll give you some hints on what to implement next, but let you take it from here.
First we need to check to see if we’re in editing mode.
Check that “Allow Selection While Editing” is checked for the Drinks table view.
Initially the keyboard is hidden, so reset our variable keyboardVisible = NO;
You’ll need to tell it that it must edit a drink instead of  creating a new one, then have it populate the controls with the existing information, and finally update the drink on save.
If we have a drink set, that means we’re supposed to edit that drink rather than create a new one.
We’ll need to populate our fields with the current drink information.
The Xcode template comes with a good bit of the code we’ll need, and at this point you’re pretty familiar with the RootViewController and the table view.
We’ll give you some hints on what to implement next, but let you take it from here.
Then sort it since the name might have changed with an existing // drink or it’s a completely new one.
If there’s a drink set, then we need to update it.
We can either update the existing object or replace it.
Since we need to resort the whole array anyway (in case the drink name changed), we just remove the old one and re-add it.
Make the editing changes to your app and give it a shot.
You should be able to remove drinks and fine-tune them all you want.
Remember to restart your app by tapping on the icon, though; otherwise, you’ll lose your changes.
Q: I like the automatic editing support in the table view, but how do I do those cool “Add New Address” rows that the iPhone has when you edit a contact?
Basically, when you’re in editing mode you tell the table view you have one more row than you actually have in your data.
If it is, return a cell that says “Add New Address” or whatever.
Q: We haven’t talked about moving rows around, but I’ve seen tables do that.
A: No, the table view part is really easy; it’s the datasource part that can be tricky.
The users will see a row handle on the side of the cells when they’re in editing mode.
When they move a row, you’ll get a call to your new method that provides the IndexPath the row started at and the IndexPath for the new position.
It’s your job to update your datasource to make sure they stay that way.
There are even finer-grained controls in the delegate if you’re interested, such as preventing the users from moving a cell to a certain section.
Q: What if I don’t want the users to be able to delete a row? Can I still support editing for some of the rows?
Q: When we edit a drink, we replace the object in the array.
What if we had some other view that had a reference to the original?
The short answer is you’re going to have a problem, no matter how you handle it.
If some other view has a reference to the object we removed, that’s not tragic since the retain count should still be at least 1; the object won’t get dealloced when we remove it.
However, the other views obviously won’t see any of the changes the user made since we’re putting them in a new dictionary.
Even if they had the old dictionary, they wouldn’t have any way of knowing the values changed.
One option is you could change our code to leave the original object in the array and modify it in place, then make sure that any other view you have refreshes itself on viewWillAppear.
Another option is you could send out a custom notification that the drink array changed or that a particular drink was modified.
Q: Aren’t we supposed to be concerned about efficiency? Isn’t removing the drink and reading it inefficient?
A: It’s not the most efficient way since it requires finding the object in the array and removing it before reinserting it, but for the sake of code clarity we decided it was simpler to show.
We’d have to re-sort the array regardless of which approach we took, however, since the name of the drink (and its place alphabetically) could change with the edit.
Q: We added the edit button on the left-hand side of the detail view, but what about a back button? Isn’t that where they usually go?
When you get into having an add button, an edit button, and a back button, you run into a real estate problem.
The way we solved it was fine, but you’ll need to make sure that your app flows the way you need it to when your navigation controller starts to get crowded.
For a complete list of tooltips in the book, go to.
Scroll View Acts like a lens to show only the part of the view you need and scrolls the rest off the screen.
Notifications Are system-level events that you can monitor and use in your app.
Different frameworks use different notifications, or you can create your own.
Table View EditingThere’s built-in support for editing a table view.The edit button comes with lots of functionality, including methods to delete rows from the table view.
Here’s what I ‘ve found: we just can’t be competitive anymore without an iPhone app!
Companies large and small are a significant market for iPhone apps.
Working with that and another new controller, the tab bar controller, we’re going.
With my business, I’m out of the office a lot.
I got a new iPhone to take with me, and now I need an app help me keep track of fugitives.
Bounty hunting is not a desk job; Bob needs lots of  information to pick up fugitives.
His iPhone is ideal to take along on the job and bring all of his case files with him.
He has to keep track of  everyone he’s looking for, along with people he’s captured.
He also needs a display of  the detailed information about each fugitive, like what they’re wanted for, where they were last seen, and how much their bounty is.
He wants to be able to quickly display a list of just the captured fugitives.
You have Bob’s requirements—take them and sketch up what you think we’ll need for this app.
The quickest way to switch between different lists is with a tab bar controller.
He keeps track of  everyone he’s looking for or has captured.
Joe wants to be able to quickly display a list of  just the captured fugitives.
For each list, we’ll use a table view, like we did with DrinkMixer.
We’ll keep track of the fugitive data sorted by name.
With the tab bar controller, the user can click on the tab at the bottom of the screen to jump between views.
The detail view for each fugitive will be available by clicking on any name.
This area is for notes and details about the fugitive.
Bob wants a display of  the detailed information about each fugitive.
All of  the views are created up front and easily accessed by clicking the tab, with each tab being tied to a specific view.
Tab bars are better suited to tasks or data that are related, but not necessarily hierarchical.
The UITabBarController keeps track of  all of  the views and swaps between them based on user input.
Standard iPhone apps that have tab bar controllers include the phone app, and the iPod.
For managing the data we’re going to use new iPhone 3.x technology, Core Data.
Choose a template to start iBountyHunter This time around, we have a lot going on in our app.
A navigation controller, a tab bar, and Core Data, too.
Core Data is an optional add-on to many of the templates, including the basic window-based app.
We’re going to start with the window-based app and add the tab bar and the navigation controller with interface builder and a little bit of  code.
Wait, I thought we were using a tab bar controller.
There’s a template for it right there—why aren’t we using that one?
If  you look back at the views you sketched, we’re also going to have some navigation controller capabilities and table views.
We’d have to do quite a bit of  extra work to get those working in the tab bar template.
With all of  that going on, it’s easier to start from a windows-based app (a basic template) and add to it, rather than working with a template that doesn’t quite fit our needs.
Jim: OK, what do we do now? All we have is an empty view.
Joe: Well, we need to add two table views, the tab bar navigation controller to switch between those views, and the detail view.
Frank: So do we need a bunch of  new nib files to handle all these views and controls?
I like to think of  it as a blank slate.
Let’s see, we can start with the tab bar and tab bar controller...
Frank: Right, that will switch between the two table views for Fugitive and Captured.
Those views will each need nav controllers as well, to get in and out of  the detailed view.
Joe: So do we need separate nibs for the tab bar and those two views? It seems like maybe we could have all those controls in just one nib, for the tab bar and the two views, since they’re basically the same.
Jim: Yeah, but we’d still need view controllers, headers, and .m files for each of  those views.
Joe: Yup, they’re the views that need the tables in them.
We’d also need a detail view with it’s own nib and view controller, with the .h and .m files, right?
We can use Interface Builder to create the tab bar and navigation controllers.
Joe: What do we do about the rest of  the stuff ? Add new files in Xcode?
Frank: That’ll work—like before, we just need to specify that the nib files are created at the same time, and we should be good to go.
Jim: I think that all makes sense—it’s a lot to keep track of.
Joe: Well, we’re combining like three different things now, so it’s definitely going to get more complicated! Maybe it would help to diagram how this will all fit together?
Each of our views will have a view controller that’s responsible for fetching the appropriate data for that view.
The tab bar controller gives us all of the functionality we need right out of the box, so we don’t need to subclass it.
We’ll use a navigation controller to transition to and from the detail view.
Create a detail vie w with a nib, and a.
So we only need two nibs, one to handle the controls for the tab bar switching between Fugitive and Captured views, and another to handle the detail view.
We need to put the table view components somewhere, and we can either create new nibs for each view and have the tab controller load them...
Jim: ...or we can just include it all in one nib.
Since we don’t plan to reuse those table views anywhere else and they’re not too complicated, we can keep everything a bit simpler with just one nib.
Jim: And we need view controllers for the two table views, along with the detail view.
They’ll handle gettting the right data, depending on which view the user is in.
Frank: Plus a navigation controller for the table views to transition to and from the detail view.
Q: Why are we using a tab bar controller and a table view?
A: Our Fugitive data is hierarchical and lends itself well to a table view.
The problem is, we have two table views: the fugitive list and the captured list.
To support two toplevel lists, we chose a tab bar.
Q: Couldn’t you have done something similar with a toggle switch, like a UISegmentControl?
The two lists are really different lists, not just different ways of sorting or organizing the same data.
Q:OK, I’m still a bit confused about the business with using just one nib for the tab controller and the two table views.
A: Well, there is a lot going on in this app, and we could have done this a different way.
We could create two more nibs, each with a nav controller and a table view in it.
Then we’d tell the tab bar controller to load the first one as the Fugitive List and the second one as the Captured List.
Rather than do that, we just put all those controls for the list in the same nib as the tab bar.
Remember, the nib is just the UI controls, not the behavior.
Q: Seriously, though—this is a better approach than just using the Tab Bar template and adjusting it based on what we need?
However, if we look at using the TabBar template, it comes with two branches, with one broken out into a nib to show that you can do it and the other right in the same nib (to show you could do that too)
So we’d have to change one, or continue splitting the approach, which can get ugly pretty quick.
We’d also have to change a ton of the default configurations, half of which are in another nib, and half of which are embedded.
In the end, this approach was less complicated and built on the methods you’ve already learned thus far.
These will be the view controllers for the Fugitive List and the Captured List.
Create your two new classes for the Fugitive and Captured views in Xcode, and then add your tab bar controller in Interface Builder.
In Interface Builder, open the MainWindow.xib to get started, and drop the tab bar controller in the view.
Create two new classes, each with .m, and .h files.
Create your two new classes for the Fugitive and Captured view controllers in Xcode, and then add your tab bar controller in Interface Builder.
Here’s what your file listing should look like once you’re done.
The window template doesn’t give us a whole lot out of  the box.
We’re going to use Interface Builder to assemble our views and view controllers the way we want them.
The tab bar controller comes with a tab bar and two built-in view controllers, but we’re going to change those shortly...
It’s the window that our app delegate will display when it starts.
Drag the tab bar controller from the Library into your main window listing.
Build the fugitive list view We’re going to focus on the Fugitive List first, but the same steps will apply to the Captured List when we get to it.
We don’t want the default; we want it to use our Fugitive List view controller.
Delete those two view controllers and replace them with navigation controllers.
Since we want all of  the functionality that comes with a nav controller, delete those the view controllers and drag two new nav controllers in their place from the Library.
Nothing’s changed in the view—the main window listing just reflects what you’ve updated.
Updated nav controller title is changed with the badge item.
Drag a table view from the Library over as a child for that view controller.
Create a detail vie w with a nib, and a.
That’s going to mean some code and IB work; we’ll come back to it in a minute.
Just do the same thing we did earlier with the Fugitives view.
Next up: the captured view You’ve just gone through and created the classes for your two table views, and dropped in a tab controller to switch between the two.
Use the to-do list from Jim, Frank, and Joe to figure out what’s left.
It’s up to you to create the captured view, and then connect the views up with the tab bar controller...
You should end up with a list that looks like this.
Follow the same steps from earlier for creating the Fugitive view.
To do this, we need to go back to the AppDelegate.
Right now, there isn’t an outlet to connect the tab bar controller to anything, so it won’t work.
You should be pretty familiar with how to do this by now.
Q: We have a lot jammed in our main window nib.
If you’re still having trouble with the idea, it might help to open the MainWindow.xib file in Interface Builder and view it in tree mode.
Q: Can I add icons to the tab bar tabs?
The easiest way is to pick a standard icon using Interface Builder.
To do that, click on the question mark icon on the tab you want to change, then change the Identifier in the Inspector.
If you want to use a custom image, set the Identifier to custom, then select your image in the Image field (you’ll need to add it to your project, just like we did with the application icon earlier)
There are a couple of peculiarities with Tab Bar icons, though: they should be 30x30 and the alpha values in the icon are used to actually create the image.
Q: How many views can I have in a tabbar?
If you add more views than can fit across the tab bar at the bottom, the UITabBarController will automatically add a “More” item and show.
By default, the UITabBarController also includes an Edit button that lets the user edit which tabs are on the bottom bar.
Q: Is there anyway of knowing when a user switches tabs?
A: Yes, there’s a UITabBarDelegate protocol you can conform to and set as the tab bar delegate.
You’ll be notified when the users are customizing the bottom bar and when they change tabs.
Q: Why did we add a reference to the tab bar controller in the App Delegate?
A: We’ve added the tab bar controller to the nib, but there’s a little more tweaking we’re going to have to do to get everything displaying properly.
Go ahead and give it a Test Drive to see what’s going on...
Ugh! Nothing! Why isn’t the tab bar controller (or anything else) being displayed?
You’ve just done a lot of work on your app—new view controllers, new nav controllers, table views—all from scratch.
Look at what we did earlier in Interface Builder and see if you can figure out where we went wrong...
The template we started with is an empty window, but the listing isn’t.
Since it will be responsible for working with the two views, that’s where we’ll start.
The tab bar controller comes with a tab bar and two built-in view controllers, but they’re not going to last.
The problem is that the tab bar is a top-level element in the nib.
The AppDelegate has the UIWindow as its window, so the delegate will display that window.
We need to embed the tab bar controller into the UIWindow.
We need to make the tab bar a subview of the UIWindow.
Look at what we did earlier in Interface Builder and see if you can figure out where we went wrong...
The template we started with is an empty window, but the listing isn’t.
Since it will be responsible for working with the two views, that’s where we’ll start.
The tab bar controller comes with a tab bar and two built-in view controllers, but we’re going to change those shortly.
A view’s contents are actually subviews All of  the UI components we’ve used are subclasses of  UIView.
By dropping them into a view we’ve made them subviews of  some bigger, container view.
We need to do the same thing with our tab bar; however, the problem is that we can’t get to the UIWindow’s view in Interface Builder.
Anything you do in Interface Builder can also be done in code.
There are a few more connections we need to put together in Interface Builder to wrap it up.
The table views also need to be connected to both view controllers, as well as outlets from the App Delegate to both the fugitive controller and the captured controller.
For both table views, the delegates and datasources need to be connected to their parent view controller.
Build and run and you can see both tab views working with tables.
Remember that icon we installed earlier? Go ahead and hit the home key to check it out.
Right now it’s pretty old school—just a typed list from the court.
Now that the app is up and running, you need to fill in the blanks.
The list is pretty simple right now, so we can make the data into any form we want and then import it.
Frank: I was thinking—I’m not sure a plist is such a good idea this time.
Jim: Why not? We used it for DrinkMixer, and it worked fine.
Frank: Well, this list could get pretty big—remember, the list of fugitives is going to be ongoing: the ones that Bob is trying to catch and those that he already has.
Joe: Oh, that’s right—and the plist loaded the entire thing every time.
Jim: What about that Core Data thing, that’s supposed to handle large amounts of  data, right?
Jim: Why use that and not just a database? Doesn’t iPhone have SQLite support?
Frank: It does, but I’m not a SQL expert, and Core Data can support all kinds of  data, including SQL, but you don’t have to talk to it directly.
Frank: We are, but we’ll use Core Data to access it.
Frank: Core Data handles all of  the dirty work for us, we just need to tell it what data we want to load and save...
What are some other limitations with how we stored data in plists and dictionaries with DrinkMixer?
Core Data lets you focus on your app Loading and saving data, particularly lots of  data, is a major part of  most applications.
We’ve already spent a lot of  time working with plists and moving objects in and out of  arrays.
But wait, there’s more! Core Data makes loading and saving your data a snap, but it doesn’t stop there.
It’s a mature framework that Apple brought over from Mac OS X to the iPhone in version 3.0 and gives you:
The ability to load and save your objects Core Data automatically loads and saves your objects based on Entity descriptions.
It can even handle relationships between objects, migrating between versions of  your data, required and optional fields, and field validation.
Different ways to store your data Core Data hides how your data is actually stored from your application.
You could read and write to a SQLite database or a custom binary file by simply telling Core Data how you want it to save your stuff.
Memory management with undo and redo Core Data can be extremely efficient about managing objects in memory and tracking changes to objects.
You can use it for undo and redo, paging through huge databases of  information, and more.
But before we do any of that, we need to tell Core Data about our objects...
Core Data needs to know what to load We need Core Data to load and save the fugitive information and we need to populate our detailed view.
If  you think back to DrinkMixer, we used dictionaries to hold our drink information and accessed them with keys, like this:
The problem with dictionaries and plists was that we had to store all of  our data using basic types and get to this data with dictionary keys.
We could have easily had a bug if  we put the wrong type in the Dictionary or used the wrong key and caused lots of  problems later.
What we really want is to use normal Objective-C classes and objects where we can declare properties for the fields, use real data types, etc.
We want to use strongly typed data, have properties to get to that data, and use the usual Object Oriented goodness of validating the data.
Core Data works with entities and properties to give us the OO benefits we want.
Not only can Core Data give us the OO-based view of  our data that we want, it can even define our data graphically.
There’s one snag thoughout of  the box, Core Data supports a specific set of  data types, so we need to define our entity using the types it offers...
Dictionaries worked for DrinkMixer, but don’t provide any kind of type safety or encapsulation of our data.
These are the types we’d use if we were writing this class in Objective -C.
Match each field we need to implement for the data view to it’s Core Data type.
Match each field we need to implement for the data view to it’s Core Data type.
We used a fixed-point decimal for Bounty because it’s a dollar value and we don’t want rounding errors.
Core Data looks at that Managed Object Model at runtime to figure out how to load and save data from its persistence store (e.g., a database)
The Xcode template we used comes with an empty Managed Object Model to get us started.
The Managed Object Model describes the objects we’re going to ask for or try to save.
It also contains all of the information Core Data needs to read and write this data from storage.
By default, our object model is empty; we’ll need to define the Fugitive entity.
The template is set up so that Core Data will try to load all of the Managed Object Models defined in your application at startup.
Technically you can create a Managed Object Model in code or by hand, but the Xcode tools.
Since our Fugitive doesn’t have any relationships to other classes, we just need to add properties.
To add the Fugitive entity, click the “plus” button here, and change the name to “Fugitive”
Once the entity exists, you can add attributes to the data model, using a plus button again.
Use these fields to edit the name and type of  the property.
You should use your normal property naming convention when naming these.
This diagram is automatically generated to give you a visual representation of the data being managed.
The property editor lets you enter contraints for your properties too, min, max, whether it’s required, etc.
If we had multiple entities you’d see the others here too, along with their relationships.
Finish building the Fugitive entity in the Managed Object Model based on the Fugitive information we want to store.
Make sure you name your properties the same as we have in the  Fugitive diagram shown below.
Make sure you use the same property names as we did.
Finish building the Fugitive entity in the Managed Object Model based on the Fugitive information we want to store.
Make sure you name your properties the same as we used in the  Fugitive diagram.
Make sure that the “optional” box is unchecked for all of the properties.
When you’re writing your own apps, there are lots of ways to set up your data model, but since we’re going to give you a database for iBountyHunter, your model must match ours exactly!
Check that you used the same types for your properties as we did.
Your Fugitive entity should have four properties and no relationships.
Q: Why did you use an NSDecimalNumber for the bounty?  Why not a float or a double?
A: We’re going to store a currency value in the bounty field, so we want precision with the decimal part of the figure.
Our choice of NSDecimalNumber for the bounty has nothing to do with Core Data and everything to do with what we’re trying to store.
Q: What are the transient and indexed checkboxes for in Xcode when you create properties?
A: The transient checkbox indicates that Core Data doesn’t need to load or save that property.
Transient properties are typically used to hold values that you only want to calculate once for performance or convenience reasons, but can be calculated based on the other data you save in the Entity.
If you use transient properties, you typically implement a method named awakeFromFetch: that is called right after Core Data loads your Entity.
In that method you can calculate the values of your transient properties and set them.
The indexed checkbox tells Core Data it should try and create an index on that property.
Indexes take up space and can slow down inserting new data into the store, so only use them when they can actually improve search performance.
Q: I’ve seen constants declared with k’s in front of them.
Q: What if I need to use a type that Core Data doesn’t support?
A: The easiest way is obviously to try and make your data work with one of the built-in types.
If that doesn’t work, you create custom types and implement methods to help Core Data load and save those values.
Finally, you could stick your data into a binary type (binary data or BLOB) and write some code to encode and decode it at runtime.
Q: What other types of persistance does Core Data support?
A: Core Data supports three types of persistence stores on the iPhone: Binary files, SQLite DBs, and in-memory.
SQLite store is the most useful and what we’re using for iBountyHunter.
Binary files are nice because they’re atomic, meaning either everything is successfully stored at once or nothing is.
The problem with them is that in order to be atomic, the iPhone has to read and write the whole file whenever something changes.
The in-memory persistence store is a type of store that isn’t actually ever saved on disk, but lets you use all of the searching, sorting, and undo-redo capabilities that Core Data offers with data you keep in-memory.
Q: What SQL datatypes/table structures does Core Data use when it writes to a SQLite database?
A: The short answer is you don’t need to know.
Even though it’s writing to a SQLite database the format, types, and structures are not part of the public API and could potentially be changed by Apple.
You’re supposed to treat the SQLite database as a blackbox and only access it through Core Data.
Q: So this is a nice GUI and all, but I don’t see what this gets us over dictionaries yet.
A: We had to tell Core Data what kind of information we’re working with.
Now that we’ve done that, we can start putting it to work.
Core Data is about managing objects So far we’ve talked about how to describe our objects to Core Data, but not how we’re actually going to do anything with them.
In order to do that, we need to a take a quick look inside Core Data.
This class keeps track of all of the Entities (Managed Objects) our application has in memory.
When you need Core Data to load an object, you ask the Managed Object Context for it...
There are different kinds of Persistent Object Stores for ea.
All of these components know how to handle our data because of the Managed Object Model.
The Xcode template we used set up the Core Data stack for us, but we still need to figure out how to talk to the Managed Object Context.
Given what you know about Core Data so far, how would you go about asking the framework to load and save data for you?
Write custom save and load code to update the data.
Use Core Data to generate classes to do the work for you.
So, if we want to load or save anything using Core Data, we need to talk to the Managed Object Context...
Exactly! The question is how do we get data in and out of  it...?
Core Data is a persistence framework that offers loading, saving, versioning and undo-redo.
Core Data can be built on top of SQLite databases, binary files, or temporary memory.
The Managed Object Context is our entry point to our data.
The Persistent Object Store is part of the Core Data stack that handles reading and writing our data.
Use Core Data to generate classes to do the work for you.
Write custom save and load code to update the data.
The Xcode template we used set up the Core Data stack for us, but we still need to figure out how to talk to the Managed Object Context.
Given what you know about Core Data so far, how would you go about asking the framework to load and save data for you?
Whip up a Fugitive class without writing a line Xcode can create a Fugitive class from our Managed Object Model that we can use like any other class.
And generate the .h and .m Click Finish and you should have a Fugitive.h and a Fugitive.m added to your project.
Go ahead and drag these up to the Classes group.
Now when you create a Cocoa Touch Class you should have an option to create a Managed Object Class.
Make sure you select “Cocoa Touch Class” under iPhone OS.
Our generated Fugitive class matches our Managed Object Model Xcode created two new files from our Fugitive entity: a Fugitive.h header file and a Fugitive.m implementation file.
Open up both files and let’s take a look at what was created.
The new Fugitive class inherits from NSManagedObject - it is a Managed Object.
The class has the properties we’d expect, but no fields in the class?!?!
NSManagedObject handles storage and memory for generated properties The generated Fugitive class has properties for name, description, etc., but no fields in the class.
The Core Data framework (and NSManagedObject in particular) are responsible for handling the memory associated with those properties.
You can override this if  you want, but in most cases this does exactly what you need.
The Fugitive.m class is nearly empty, and instead of  synthesizing the properties, they’re declared with a new directive, @dynamic.
NSManagedObject also implements the properties The new @dynamic directive tells the compiler not to worry about the getter and setter methods necessary for the properties.
They need to come from somewhere, though, or else code is going to crash at runtime when someone tries to access those properties.
Because NSManagedObject handles the memory for the fields backing the properties, it also provides runtime implementations for the getter and setter methods.
By having NSManagedObject implement those methods, you get a number of  other neat benefits:
The implementation of the Fugitive class is almost completely empty!
The NSManagedObject knows when properties are changed, can validate new data, and can notify other classes when changes happen.
NSManagedObject can be lazy about fetching property information until someone asks for it.
For example, it does this with relationships to other objects.
NSManagedObject can keep track of  changes to properties and provide undo-redo support.
You get all of this without writing a line of code!
Now it’s just a matter of asking Core Data to load a Fugitive...
Ask the Managed Object Context to fetch data using your NSFetchRequest All that’s left is to ask the Managed Object Context to actually execute your NSFetchRequest.
That means we’ll need a reference to a Managed Object Context.
Fortunately, the template set up one for us in the App Delegate.
Use an NSFetchRequest to describe your search In order to tell the Managed Object Context what we’re looking for, we need to create an NSFetchRequest.
An NSFetchRequest describes the search we want Core Data to execute for us.
You can provide a predicate that describes conditions the entities must meet.
Now, where do we put all of this code? And where are we going to store the results? What about actually displaying the fetched data?
All that’s left is to ask our Managed Object Context to go ahead and execute our fetch request.
We’ll ask it to give us back the results in an array and clean up our references.
Now, where do we put all of this code? And where are we going to store the results? What about actually displaying the fetched data?
As for storing the results, we’ll get back an array, but we release it right away.
We need to keep a reference to that array in our view controller.
Take what we learned on the previous couple of  pages and get the fetch working.
You’ll need to get the Managed Object Context from the delegate, create the fetch, then execute it.
Remember to update the code to actually hang onto the results by assigning them to the array we just created.
Don’t forget to synthesize the property and clean up memory.
Table Cell Magnets Use the code snippets below to customize the table cells for the fugitive list.
It’s a lot of code to implement, but when you’re done, Core Data will be fetching the data you need for the fugitive list.
Table Cell Magnets Solution Use the code snippets below to customize the table cells for the fugitive list.
Describes the search you want to execute on your data.
Includes type of  information you want back, any conditions the data must meet, and how the results should be sorted.
Subclasses of  this represent data you want to load and save through Core Data.
Provides the support for monitoring changes, lazy loading, and data validation.
Responsible for keeping track of  managed objects active in the application.
Describes entities in your application, including type information, data constraints, and relationships between the entities.
Captures how data should be sorted in a generic way.
You specify the field the data should be sorted by and how it should be sorted.
Describes the search you want to execute on your data.
Includes type of  information you want back, any conditions the data must meet, and how the results should be sorted.
Subclasses of  this represent data you want to load and save through Core Data.
Provides the support for monitoring changes, lazy loading, and data validation.
Responsible for keeping track of  managed objects active in the application.
Describes entities in your application including type information, data constraints, and relationships between the entities.
Captures how data should be sorted in a generic way.
You specify the field the data should be sorted by and how it should be sorted.
Turns out I can do that instead of getting that paper list from the court...
How do we tell Core Data to load from this file?
Add the database as a resource We have all of  this code already in place to load data—it came with the Core Data template.
But how do we get from there to actually loading the database?
Back to the Core Data stack Remember the Core Data stack we talked about earlier? We’ve gotten everything in place with the Managed Object Context, and now we’re interested in where the data is actually coming from.
Just like with the Managed Object Context, the template set up the rest of  the stack for us.
The template set up the stack for us and we only have one Persistent Object Store so we can leave the Coordinator as is.
The Persistent Object Store is the one responsible for actually reading and writing the raw data.
Let’s take a look at the template code in the App Delegate...
Now that the database is in place, and the Persistent Object Store can be used as-is, go ahead and run the app.
The template sets things up for a SQLite DB The Core Data template set up the Persistent Store Coordinator to use a SQLite database named after our project.
The template code adds a Persistent Object Store to the coordinator configured with the NSSQLiteStoreType.
The template sets things up to use a DB named the same as your project.
Our problem is with how Core Data looks for the database.
This worked great and our data loaded without a problem.
But remember how we talked about how this would only work in the simulator? It’s time to sort that out.
As part of  iPhone security, applications are installed on the device read-only.
You can get to any resources bundled with your application, but you can’t modify them.
The Core Data template assumes you’re going to want to read and write to your database, so it doesn’t even bother checking the application bundle.
This code will only work in the simulator!!The code used to save the plist will work fine on the simulator but fail miserably on a real device.
We need to take a closer look at how those directories are set up...
The iPhone’s application structure defines where you can read and write For security and stability reasons, the iPhone OS locks down the filesystem pretty tight.
When an application is installed, the iPhone OS creates a directory under /User/Applications on the device using a unique identifier.
The application is installed into that directory, and a standard directory structure is created for the app.
The app itself is stored in a directory nam ed.
The Documents and Library directories are read-write for the application and also backed up by iTunes when the user syncs their device.
The tmp directory is read-write too, but it isn’t backed up during a sync.
Use the Documents directory to store user data Since most Core Data applications want to read and write data, the template sets up our Core Data stack to read and write from the Documents directory.
Copy the database to the correct place When the application first starts, we need to check to see if  there’s a copy of  the database in our Documents directory.
If  there is, we don’t want to mess with it.
Do this! Now that the app knows how to copy the database, you need to uninstall the old version of your app to delete the empty database that Core Data created earlier.
When you build and run again, our new code will copy the correct DB into place.
Here we grab the master DB from our application bundle; this is the read-only copy.
Now that the app knows where to find the database, it should load.
Q: Why didn’t we have to do all of this directory stuff with the plist in DrinkMixer?
A: We only ran DrinkMixer in the simulator, and the simulator doesn’t enforce the directory permissions like the real device does.
We’d basically have the same problem with DrinkMixer on a device.
The reason this was so obvious with iBountyHunter is that Core Data is configured to look in the correct place for a writeable database, namely the application’s Documents directory.
Q: How do I get paths to the other application directories?
You should never assume you know what the directory structure is or how to navigate it; always look up the specific directory you want.
Q: So what happens to the data when someone uninstalls my application?
A: When an application is removed from a device, the entire application directory is removed, so data, caches, preferences, etc., are all deleted.
Q: The whole Predicate thing with NSFetchRequest seems pretty important.
Q: So is there always just one Managed Object Context in an application?
A: No, there can be multiple if you want them.
For most apps, one is sufficient, but if you want to separate a set of edits or migrate data from one data source to another you can create and configure as many Managed Object Contexts as you need.
For example, you could have a customer information coming from one database but product information coming from another.
You can configure two separate persistent object stores and let the persistent store coordinator sort out which one is used based on the database attached.
Q: How about object models?  Can we have more than one of those?
Q: Do I always have to get my NSManagedObjects from the Managed Object Context? What if I want to create a new one?
A: No, new ones have to be added to the context—however, you can’t just alloc and init them.
That will return a new Fugitive instance and after that you can use it like normal.
We have the database loading with detailed information, but the user can’t see it yet.
Now, we just needto build out the detail view to display that information as well.
Create a detail vie w with a nib, and a.
Building the detail view isn’t anything new for you—so get to it! Here is what you’re working with from our earlier sketch for the detail view.
The detail view for each fugitive will be available by clicking on any name.
This area is for notes and details about the fugitive.
Lay out the nib using Interface Builder to have the fields we need.
Then update the new view controller to have outlets for the fields we’ll need to set and a reference to the Fugitive it’s displaying.
All of the fields should be read only since we don’t want users tweaking the bounties.
When you create the new class files, you’ll have the .m, .h, and .xib files.
Go through and check the code, outlets, declarations, and dealloc.
Here’s the final listing of the components of the detail view.
Make sure that all of the added elements are children of the main view.
Use the inspector to change the default values of each of these elements to “Fugitive Name”, “Fugitive ID”, etc.
To get the simulated navigation bar, in the Inspector set the top bar, simulated interface element to “Navigation Bar”
We’re going to add some spit and polish to this view.
It’s fine the way it is, but here’s some iPhone coolness to add.
Add a rounded rectangular button, right on top of the UITextView.
With the button still selected, use the inspector to uncheck the enabled box (under content)
Now, just populate the detail view from the Fugitive List.
You know how to do this from what we did earlier with DrinkMixer.
The other files need to know that the detail view exists.
In that same implementation file, the table view needs some selection code.
It’ll be similar to the code that we used in DrinkMixer.
The detail view code needs to populate the existing fields with the data from the fields that were set up with the Fugitive.h and Fugitive.m classes and the Core Data code.
These are just a couple of examples but should give you all the hints you’ll need.
Go back into IB and link your table view to its delegate.
The other files need to know that the detail view exists.
In that same implementation file, the table view needs some selection code.
It’ll be similar to the code that we used in DrinkMixer.
Here we tell the detail view controller which fugitive it should display.
Adding the stringValue on the end of these two declarations handles the fact that they were not strings, but NSNumber and NSDecimalNumbers.
We’re going to be accessing fields in the Fugitive class.
In IB, the table view under the Fugitive List View Controller needs to have its delegate linked to that View Controller.
Test Drive After populating the detail view, you can see the information about each fugitive.
The labels have been replaced with values from the database.
The back button is working thanks to the nav control.
It works great! Having all that information with me makes it much easier to catch outlaws.
Great! After a couple of  weeks, Bob is back with a new request...
That really worked! I’ve caught a ton of people already! How can I keep track of who I’ve caught?
CoreDatacross There’s a lot of terminology with Core Data; let’s make sure you remember it!
You’ve got Chapter 7 under your belt and now you’ve.
Core Data Provides a stack that manages the data so you don’t have to.
The Data Model Works with entities that have properties called attributes.
Core Data is a persistence framework that offers loading, saving, versioning and undo-redo.
Core Data can be built on top of SQLite databases, binary files, or temporary memory.
The Managed Object Context is our entry point to our data.
The Managed Object Context is part of the Core Data stack that handles reading and writing our data.
How about this one? I just can’t seem to decide which outfit to wear...
But what about when the data has to change? Bob wants some new.
To get paid, I need to be able to show who was captured when...
Bob has to keep track of  his work so he can be paid.
That means that we need somewhere to store the day and time of  a capture and then use that to build the captured view...
Remember that captured view we built in the last chapter?
How are we going to update iBountyHunter to handle the new information?
We need to figure out how to update iBountyHunter to handle this new data.
Look at each piece of our application and write what, if anything, needs to change.
We need to figure out how to update iBountyHunter to handle this new data.
Look at each piece of our application and write what, if anything, needs to change.
Add information about the changes to the data for display in the app.
Since nearly everything depends on the new data we need to add, let’s get that in our object model first; then we can update the rest.
Everything stems from our object model From what we figured out in the exercise, the Fugitive entity needs a few more fields: the date and time, and something to indicate whether or not the fugitive has been captured.
The database is built from the data model, so we can just update the data model to add the information we need.
The Core Data date type includes both a date and time, so we only need two more properties on our Fugitive entity:
Since all fugitives will be either captured or not, it needs to exist for all of them.
Since this field will only exist for the captured fugitives, it’s optional.
Use the data model editor to update the model with the two new fields.
After you update the model, you’ll need to delete the two old fugitive class files and generate new ones with the new fields included.
Use the data model editor to update the model with the two new fields.
After you update the model, you’ll need to delete the two old fugitive class files and generate new ones with the new fields included.
Use the tools that Xcode comes with to quickly make those changes.
Once you’ve made the changes, go ahead and run iBountyHunter.
The new fields have been added as dynamic properties, just like the earlier ones.
The data hasn’t been updated If  you take a close look at the console report of  the crash, you can figure out what’s wrong...
It’s complaining that our data model isn’t compatible with the one that created the database.
The data model is different than what was used to actually write the data.
Core Data caught a mismatch between our DB and our model We created this problem when we added new fields to the Fugitive entity.
Our initial fugitive database was created with the old model, and Core Data has no idea where to get those new fields from.
Rather than risk data corruption, it aborted our application with an error.
That’s good, but we still need to figure out how to fix it.
Data migration is a common problem Realizing you need to add new data or changing the way you store old data is a pretty common problem in application development.
Core Data works hard to make sure it doesn’t corrupt or lose any data, so we’re going to have to tell it what to do with our new Fugitive entity.
Right now, we have the old data and the new data model.
The Persistent Object Store fails to load the data, saying it can’t load what’s in that database into the new entity.
Then GO BACK and CHECK that it’s working again!  It will save lots of time and trouble later.
Our two models need different versions It’s easy enough to change the data model by hand, but Core Data needs to be able to work with both the old and new data.
We need to give Core Data access to both, but tell them they’re different versions of  the same model.
Even more importantly, we need to tell Core Data which one we consider our current version.
We need to migrate the old data into the new model We made the changes to the data model, but we need everything up and down the Core Data stack to be able to deal with those changes.
In order to do that, we need to migrate the data.
To migrate anything, you need to go from somewhere to somewhere.
Core Data needs to have both of  these data models to make data migration work for the entire stack.
We need a new approach to changing the data model, besides just changing the old one.
Let’s undo what we did earlier so we can load the data from the database again.
This is what we started with, and the Persistent Object Store is expecting this data model.
The Persistent Object Store needs to know that this is what we consider our current version.
Xcode makes it easy to version the data model Fortunately, it’s pretty easy to create a new version of  your data model using Xcode:
Select iBountyHunter 2.xcdatamodel and re-edit the data model to add back in the captdate and captured fields as we did before.
Now the old version is preserved and the changes are where they belong.
Normally, you’d also need to delete and regenerate the Fugitive class, but since we made the same changes to.
I guess we need to write a bunch of  migration code or something.
Jim: I assume we’re going to have to tell Core Data how to get from the old version of  the data to the new one, right?
Frank: Well, actually, I think we can do it automatically.
Frank: Core Data has a feature that allows you to tell the app about both models and it can migrate the data for you.
Frank: Runtime, when the Persistent Object Store sees that the data is in the old format.
That means that we’ll just need some code to tell iBountyHunter to actually do the migration.
Joe: OK, so it looks like some of  that code is auto-generated, and some of  it needs to be added.
Jim: This is great; so we can just change whatever we want?
Frank: There are certain data changes that Core Data can handle automatically, like adding new attributes.
More complex changes to the data need to be handled manually.
Joe: Yeah, it says here that we can do automatic migration if we’re adding attributes, or changing the optional status of  an attribute.
Frank: Renaming gets tricky—sometimes you can and sometimes you can’t.
Joe: So, how can we migrate the data we have?
Core Data can “lightly” migrate data Lightweight data migration is a powerful Core Data tool that allows you to cleanly update your underlying data to match a new data model without needing a mapping model.
It only works with basic data changes: adding new attributes, changing a required attribute to an optional one, or making an optional attribute required with a default value.
It can also handle limited renaming of  attributes, but that gets trickier.
Automatic data migration happens at runtime, which means that your app needs to know that it’s going to happen so that the data can be migrated.
After adding the code to the app delegate, Build and Debug...
Remember, by default Core Data will load all of the object models in your app bundle.
That means it will see both the old version and the current version of our model.
All we need to do to enable lightweight migration is turn it on.
If you run into issues here, try Build->Clean first, then Build and Debug.
Strangely, Xcode doesn’t always properly recompile the first time you version your model, but cleaning should fix it.
It’s my job to read and write your actual data.
Head First: Right, you’re the guy who translates into a bunch of  different formats.
When you use Core Data, you don’t really need to know if  your data is going into a simple file or a sophisticated database.
You just ask me to read and write a bunch of  data and I handle it.
See, it’s my job to make sure your data is loaded and saved exactly right.
Head First: I get that, but still, small changes are OK, right?
Store: Sure—I just need to make sure you really want me to do them.
You need to tell me what data I’m looking at and then tell me how you want me to return it to you.
Tell me it’s OK to infer the differences and do the mapping and I’ll take care of the rest.
Head First: So do you actually migrate the data or just translate it when you load it?
Simple stores like the binary file ones just create a new file with the migrated data.
But if  I’m using a SQLite DB, I can usually do the migration right in place.
Don’t need to load the data and the whole migration is nearly instant.
Head First: Nice! I thought lightweight migration was kind of  a noob’s migration.
Store: Oh no, if  you can let me do the migration through lightweight migration, that’s definitely the way to go.
Now if  you need to do something more complicated, like splitting an old attribute into two new ones or change the type of  something, you’ll need to help me out.
Basically, you need to give me one more model, a mapping model.
That tells me how to move your data from the old format to the new format.
Store: Actually, most of  the time I can handle that too, as long as you tell me what the old name was.
If you look at the details of  an attribute in your object model, you can give me the old name of  an attribute.
If  it’s there, and I have to do a migration, I can handle renaming too.
Head First: Wow, you’re not nearly as boring as I thought...
Q: How may versions of a data model can I have?
Once you start adding versions, you’ll need to keep track of your current version so that Managed Object Model knows what you want when you ask for an entity.
By keeping all of the old versions around, Core Data can migrate from any prior version to the current one.
Q: When is renaming something OK for a lightweight migration? When isn’t it?
A: You can rename variables as long as you don’t change the type.
If you rename them, click on the little wrench on the attribute properties in Xcode and specify the renaming identifier to be the old attribute.
Q: Can I use migration to get data I have in some other format into Core Data?
If you have legacy data you want moved into Core Data, you’ll need to do that yourself.
Typically, you just read the legacy data with your own code, create a new NSManagedObject to hold it, populate the new object, and save it using Core Data.
There are a couple other approaches you can look at if you have large amounts of data to migrate or streaming data (for example, from a network feed)
Q: Does it make a difference if I use lightweight migration or migrate data myself?
It won’t work for all cases, but, if it can be done, Core Data can optimize the migration if you’re using a SQLite store.
Migration time can be really, really small when done through lightweight migration.
Q: What do I do if I can’t use lightweight migration?
Q: Xcode lets me enter a hash modifier in the Versioning Settings for an attribute.
A: Core Data computes a hash for entities using attribute information so it can determine if the model has changed since the data store was created.
However, it’s possible that you need to change the way your data is stored without actually changing the data model.
For example, let’s say you always stored your time values in seconds, but then decided you needed to store milliseconds instead.
You can continue to store the value as an integer but use the version hash modifier to let Core Data know that you want two models to be considered different versions and apply your migration code at runtime.
Lightweight automatic migration needs both versions of the data model before it will work.
Automatic migration can change a SQLite database without loading the data.
You can use lightweight migration to add variables, make a required variable optional, make an optional one required with default, and to do some renaming.
Add information about the changes to the data for display in the app.
What kind of changes do we need to make to the UI to add the capture information?
I want all of this captured info on the detail view.
I was thinking I could just type in Y or N when I capture a guy? Then fill in the date and time below.
As an experienced iPhone developer, you can probably come up with some better UI designs.
Can Bob’s view actually work with the app as it’s currently written?  (Circle one)1
To properly implement this view, you need to know what data is editable.
What data can the user edit and what is the best way to handle that input?
Now that you’ve thought through the design implications, what should the detail view look like?
Can Bob’s view actually work as is with the app as written?  (Circle one)1
To properly implement this view, you need to know what data is editable.
What data can the user edit and what is the best way to handle input?
We already have a “back” button where Bob wants to put a cancel button.
Asking the user to input the “Y” or “N” and type the date and time is not a great UI.
The only data that will need to change is the captured field and the captured date and time.
Save We might need this later - we’ll have to see....
That will mean NO typing required to input the data.
Make the additions you need to the detail view to include the additional fields.
Go ahead and add the visual elements you need: the three labels, and the segmented control.
You’ll need to add a simulated tab bar to make sure that everything will fit.
Now that all of  those interface elements exist, give them the back end in Xcode, but don’t worry about linking them just yet...
Here are the additions to the view, and the code to support them.
This is the label that will hold the captured date and time, but it’s empty unless the switch is toggled to yes.
The segmented control needs to be configured (it says first/second by default)
Toggle this selection to get to the other half of the control.
Make sure “Segment 0 - Yes” is selected and both segments are enabled.
Test Drive Build and debug to make sure the interface is working.
Q: Why didn’t we use the switch instead of the segmented control?
A: Because there’s no Apple-sanctioned way to change the text of the switch.
By default, the options are On and Off, which won’t work for us.
Q: Why didn’t we use a check box for the captured field?
A: It turns out that the check box isn’t a standard control.
It’s certainly surprising, since you see them so often in iPhone apps.
They can be done, however, by creating a custom button with three images (an empty box, a selected box, and a checked box), and switching between them.
All the view elements look good! Now we just need to implement their behaviors...
Toggle Code Magnets Now that we have the controls laid out the way we want them, we need to actually give them some behavior.
Use the magnets below to implement the method that will handle the segmented control switching.
Then everything will be ready for linking to the segmented control in Interface Builder.
Toggle Code Magnets Solution Now that we have the controls laid out the way we want them, we need to actually give them some behavior.
Use the magnets below to implement the method that will handle the segmented control switching.
Then everything will be ready for linking to the segmented control in Interface Builder.
This will only be called if the value actually changed, so if the selected index is now 0, the fugitive wasn’t captured prior to this call.
This will return an NSDate set to the current date and time.
Core Data stores booleans as NSNumbers, so we need to convert our boolean YES/NO values to NSNumbers to update the fugitive.
If the fugitive isn’t captured, clear the old capture date if there was one.
Test Drive Now that all of that work is done, you should have a functioning detail view.
The view looks great and the segmented control is set to No, just like it should be.
If you toggle the segmented control, the date and time are filled in.
It’s working! Spend some time moving around in and out of the table view, mark a fugitive as captured, and then come back into that same fugitive.
Go ahead, quit the app and check again, we dare you.
The data is still there if I go back to the table view—it’s even still there if I completely exit the app and come back in the simulator.
Core Data handles saving, too! Checking that Core Data box when you created the app did more for you than you realized—it enabled saving as well.
The Managed Object Context saves new or changed items We’ve used the managed object context to load our Fugitives, but it is also responsible for coordinating saving your data, too.
Remember how NSManagedObject can keep track of  changes to entities? The Managed Object Context can take advantage of  this information to tell if  you if  there are any changes in the objects it’s managing.
Similarly, if  you create a new instance of  an NSManagedObject, you need to tell it which Managed Object Context it belongs to and that Managed Object Context knows it has new entities to keep track of.
The Core Data template takes advantage of  this during application exit to see if  the Managed Object Context has any new or changed data.
If it does, the application simply asks the context to save them.
Q: You said if I create new instances of NSManagedObjects I need to tell them which Managed Object Context they belong to.
The Managed Object Context is provided right from the start.
Q: What’s the “&error” that’s being passed to the save call?
A: Most Core Data load/save operations point to an NSError in case something goes wrong.
The “&” in Objective-C behaves just like it does in C or C++ and returns the.
We declare a pointer to an NSError then pass the address of that pointer into the save method in case something happens.
If the save call fails, Core Data will populate that error argument with more detailed information.
Q: Speaking of errors, what should I do if this comes back with an error?
Depending on when you detect the problem, you can warn the user and try to recover; other times there’s not too much you can do.
The Core Data template set it up this way for convenience, but you should save whenever it’s appropriate in your application.
In fact, if you’re using a SQLite database backend for your data, saves are significantly faster than when we were working with plists in DrinkMixer.
You should consider saving additions or changes to the data as soon as possible after they are made to try and avoid any kind of data loss.
Q: You said Core Data could do data validation; where does that fit into all of this?
A: At a minimum, Core Data will validate objects before they’re stored in the.
So, it’s possible that you could get a validation error when you try to save your changes if you have invalid data in one of your managed objects.
To avoid such late notice, you should validate your NSManagedObjects as close to the time of change as possible.
You can call these methods at any time to verify that the NSManagedObject is valid against constraints you put in the data model.
If it’s not, you can notify the user and ask them to correct the problem.
When a Managed Object Context is told to rollback it will discard any newly inserted objects, any deletions, and any unsaved changes to existing objects.
A quick demo with Bob After seeing the detailed view and all the captured stuff, Bob’s thrilled, but has one quick comment:
This is definitely way easier than what I came up with.
After all that, we forgot to populate the captured list!
OK, I know how to populate the table cells and stuff—but how can I only pick captured guys?
We already have capture information in our Fugitive data; we just need to use it to get the captured list.
We need a way to tell Core Data we only want Fugitives where the captured flag is true.
Where is a natural place to put this kind of filtering?
Use predicates for filtering data In database languages all over the world, predicates are used to scope a search to only find data that matches certain criteria.
Remember the NSFetchRequest we talked about in Chapter 7? We’ve used the Entity Information and Sort Descriptor but haven’t needed the predicate support...
An NSFetchRequest describes the search we want Core Data to execute for us.
Entity Information tells Core Data the type of the data we’re searching for (and want back)
If it doesn’t match, it doesn’t get returned with the results.
We used the Sort Decriptor to order the data alphabetically in the results.
NSFetchRequest concepts are nearly identical to SQL The three major concepts in an NSFetchRequest are nearly identical to the expressions in standard SQL:
All we need to do is provide the predicate information to our NSFetchRequest and Core Data handles the rest.
Time to populate the captured view! There’s some work to get the captured view updated to where the fugitive view is, and then a tweak to display what we need.
Build and run the old version of  the app and toggle a handful of  the fugitives to captured before making any changes.
Where we left off  in Chapter 7, we hadn’t yet done the work to populate the captured list.
Since we’re just going to be filtering the data that’s in the fugitive list, the easiest way is to start with the entire list and then add the filtering code.
Update your NSFetchRequest to use an NSPredicate so it only finds captured fugitives.
We need to set a predicate on our NSFetchRequest NSPredicate is a deceptively simple class that lets us express logical constraints on our NSFetchRequest.
You use entity and attribute names along with comparison operators to express your constraint information.
You can create a basic NSPredicate with a string format syntax similar to NSString, like this:
For iBountyHunter, a simple attribute condition is all we need to get Bob’s view working.
You can handle this one - any 5 that you want!
You should recognize the code from Chapter 7 to get the captured view working, and then the predicate code to get the filtered data.
Get the captured view to match the fugitive view (continued).2
Go ahead and fire it up—the captured view should be ready to go!
It works! These are the four fugitives we marked as captured.
What problems would we introduce if we moved the fetching code to viewDidLoad? What else could we do to improve performance?
Hang on—you said we should be careful with memory and performance and blah blah...
Now we have two arrays of fugitives and we reload them every time the view appears.
If  we move the code there, we’re going to end up with two new problems.
The problem is that viewWillAppear gets called every time the view is shown, which means we’re reloading all of  the fugitives and all of  the captured fugitives every time, regardless of  whether anything’s changed.
We could move the code to viewDidLoad, but that only gets called when the views are loaded from their nibs.
First, if  we mark a fugitive as captured, the Captured List won’t reflect that since it only loads its data once.
What we need is a better way to manage our fetched data.
High performance UITableView support UITableView needs to know how many sections there are, how many rows there are in each section, etc.
Built-in monitoring for data changes We’ve already talked about how the Managed Object Context knows when data is modified.
Delete the reference to the items array here and release the new view controller.
Next we need to change the search to use the controller...
We want the controller to tell us when data changes we need to conform to its delegate protocol.
Now instead of asking the Managed Object Model to perform the fetch, we ask the controller.
Now you need to update the tableview delegate and datasource methods to use the controller instead of the view.
Use those to figure out how many sections there are and how many rows in each section.
In fact, it can do it a lot more efficiently.
For the number of sections we can just return the count of the sections in the controller.
Nothing fancy here - just get the Fugitive at the given indexPath.
One more lookup for the indexPath to get the Fugitive, and we’re all set.
Test Drive Go ahead and run iBountyHunter to make sure the changes didn’t break anything.
Do some quick testing—if you mark a fugitive as captured, does he switch lists? What if you exit and come back into the app using the home key?
Test Drive Now that you’re using the controller instead of just a predicate, the behavior of the app should be the same.
But people are showing up in the captured list even when they’re not marked as captured!
Why aren’t fugitives properly changing lists when you change their captured status?
We need to refresh the data The fugitives aren’t properly changing lists when you change their status because we’re not refreshing the data every time the captured list view is displayed.
The table view will completely reload the data when it detects a change.
The view controller has built-in support for monitoring the data for changes through a delegate.
We had set ourselves up as that delegate but never implemented the code to handle data changing.
Test Drive Do the same thing you did last time, build and run, and then change the status of one of the fugitives to pull him dynamically out of the captured list.
This is awesome! The advantage I’m going to have over the competition is great, and having all that information with me means that I’ll be making way fewer trips back to the police station.
Q: Where can I find the full syntax for NSPredicate?
A: NSPredicate has a pretty complex syntax available for expressing constraints on your data.
There’s a simple summary available in the NSPredicate class documentation but Apple has an entire document available to help you write advanced predicates.
Q: It seems like it would be pretty easy to make a mistake typing predicate syntax into code like that.
A: Yes, and Xcode can offer a lot of help here.
Instead of embedding your predicates in code, you can build them graphically using Xcode’s data modeller, just like we did with the Managed Object Model.
To build a predicate graphically, select an entity in Xcode, then click on the plus as though you were adding an attribute.
Select “Add Fetch Request” to create a new fetch request and click Edit Predicate to bring up the graphical editor.
Then just use that fetch request instead of one created in code.
You can also use Xcode’s builder to assemble a predicate, then just cut and paste that into your code if you’d prefer to keep them there.
Q: Reloading the whole table when data changes seem pretty inefficient.
There are a number of delegate methods you can implement to get finer-grained information about what’s happening with the Managed Object Context.
With that information, you can find out if you just need to update a specific table view cell, insert a cell, or remove a cell.
We took the easier route and just asked the table view to reload completely.
Q: What’s with that cache value we gave to the results controller?
A: The results controller will use that file name to cache information like the number of items, number of sections, etc.
It will keep an eye on the data store and regenerate the cache if something changes.
You can also forcibly ask it to remove a cache, but in general you shouldn’t need to.
How do I get it to split things into multiple sections?
You can get really sophisticated and create a transient property if you want to group them by something you’re not actually storing in the database and calculate the value using a custom getter added to your object model.
NSFetchRequest can take an NSPredicate to filter data based on logical conditions.
You can express NSPredicate conditions in code or using Xcode’s predicate builder.
Be careful about what you put in viewWillAppear, as it will be called every time your view is shown.
DataMigrationcross We have some new data lingo to try out, so flex those verbal skills...
DataMigrationcross Solution We have some new data lingo to try out, so flex those verbal skills...
You’ve got Chapter 8 under your belt and now you’ve.
Data Migration Core data can use lightweight migration to automatically make database changes.
Versioning is used to keep track of the data migrations.
Lightweight migration can be used to add attributes or changing optional status.
Does data migration, sometimes without actually needing to load the data.
Uses mapping models if the changes are too much for lightweight migration.
The iPhone knows where it is and what it sees.
As any iPhone user knows, the iPhone goes way beyond just managing data: it can also.
The beauty about incorporating these features is that just by tapping into the tools.
For Bob, payment requires proof! Bob is working hard on getting as many fugitives off  the street as he can, but to get paid he has to document his captures.
I need a picture of the arrest when it happens, and since my.
Bob wants a picture of  his catch and he’s going to need it to be pretty big—so let’s go ahead and put it on its own view.
Those pictures will be great for advertising, not to mention that it will speed up payment!
Here’s what we came up with for the photo view.
Flip over for the detail view! It’s  about time we used some real animation in our app.
Since we’ll only want the photo after drilling down through to the detail view (what Bob will use to find his fugitive), it makes sense to stick it on the back of  the detail view.
This is a really common interface for the utility apps on the iPhone.
Typically, there will be two views, one with an info button on it, and another that is revealed by flipping over when the info button is clicked.
Our app isn’t a utility app, but we can steal the idea to give a nice baseball-card look to our fugitive detail view.
The flipping is just another transition that comes with UIKit.
We’re going to want a modal view for that last view.
If we shrink up the space for the description, we can move the capture info up and leave room for the new button.
Author’s note: These are hints for the next exercise, so pay attention!
The detail view needs a new info button, and an action to trigger the new flip view.
The info button is just a regular button with the Info Dark type.
Use a custom animation to show the new view when the info button is pressed.
You already know how to present a modal view, but this time we want to do it with a custom animation.
Take a look at the UIViewController documentation if  you’re stuck on how to use it.
That’s going to mean a view with a UIImageView and a Done button.
Don’t forget the action to tie in with the button and dismiss the view.
Don’t forget to connect the button and the IBAction in Interface Builder!
Don’t worry about an IBOutlet for the UIImageView yet,; we’ll get to that in a second.
This one is a whole bunch of functionality that you added without much help! Here’s what we came up with:
Use a custom animation to show the new view when the info button is pressed.
Instantiate the view controller and open up the flip view nib.
The info button is just a UIButton configured in the inspector as an “info dark” type.
Make sure you have the simluated tab bar in here too, so it doesn’t get hidden!
When the done button is pressed, we want the view to go away.
Declare the View Controller and the action for the button.
Wire this up to File’s Owner, at the top of the dialog.
This one is a whole bunch of functionality that you added without much help! Here’s what we came up with:
Test Drive Run the app and see the cool animation working!
This is the image view - it’s empty, but not for long...
The and the need to be again so this will work.
The has to know about the image and where to display it.
Now the views and animations are all working properly, what about the image itself? Think about the data model when you fill in the blanks below.
The and the need to be again so this will work.
The has to know about the image and where to display it.
Now the views and animations are all working properly, what about the image itself? Think about the data model when you fill in the blanks below.
Do this! You’ve migrated the database before, and you’re going to need to do it again.
Just so it’s handled and out of the way, get into Xcode and do another database migration.
Add the new field to the new data model and generate the new Fugitive class.
For the image, we’ll need a new attribute called “image” that is a binary data type.
Then delete the old Fugitive.h and Fugitive.m files and generate new ones via the New menu option.
Check out Chapter 7 if you’re still fuzzy on how to do this.
Why? Because our real mission here is to pick an image.
The iPhone implements image selection through a picker that allows you to get your image from different places, like the camera or the photo library.
UIImage The view for the image picker is already written and will automatically be used when you present the controller.
If it received an image, our view controller needs to update its fugitive with the image that will be persisted the next time save is called.
The delegate gets an image the same way regardless of whether it came from the Photo Library or was just taken with the camera.
Here is some code you’ll need to tie the image picker together.
When the view appears, we’re going to allocate the image in the database to the view if there is one.
This allows the users to edit the photo they are choosing.
Time to get some images! Using the code for the image picker that we gave you, as well as some of your Objective-C skills, and let’s get the images going.
Import the Fugitive header file and declare a property for the fugitive.
Using Interface Builder, you’ll need to create a button that covers the entire UIImageView and is then set behind it.
Store the image when it’s selected and update the UIImageView.
You need to set the image information on the fugitive when the picker gives us an image, then make sure the UIImageView is updated when the view is shown.
You’ll need an outlet for the UIImageView; then link it in Interface Builder.
Import the Fugitive header file and declare a property for the fugitive.
Here’s all of the pieces put together to implement the button...
Store the image when it’s selected and update the UIImageView.
We’ll need an outlet so we can update the UIImageView with the selected image.
Then we present the picker and wait to see what happens...
Since Core Data wants to store binary data, we need to get the raw image information out of the UIImage.
You need to remember to release the picker controller once you’ve gotten the image.
Logging the method here will let us see that it gets called in the debugger.
This is a little tough to make out, but the button is behind the UIImageView.
Change the default text to “Tap here to add a photo”; since it’s behind the picture, you’ll only see it if there’s no image.
Here’s all of the pieces put together to implement the button...
Build and run to see your new picture view in action.
The simulator is reacting to the fact that you are asking for the camera and it doesn’t have one.
But more than the simulator not having the camera, the iPod touch doesn’t either.
The iPhone isn’t the only device using apps One of  the things that Apple requires when you release an app is that it can work on all devices that can run apps, which for now includes the iPod Touch and the iPhone.
Part of  the approval process for apps is that they are checked for compatibility with the iPod Touch.
All this means that you need to be aware of  when your app may be straying into areas where an iPhone behaves differently than the iPod Touch.
Author’s note: We don’t have insider information or anything; we’re just assuming that as time goes on this list will grow.
Pool Puzzle Your job is to take items from the pool and.
You may not use the same item more than once, and you won’t need to use all the items listed.
Your goal is to make a complete list of the functionality for the iPhone and iPod Touch.
Note: each thing from the pool can only be used once!
Pool Puzzle Solution Your job is to take functionality from the pool.
You may not use the same item more than once, and you won’t need to use all the items listed.
Your goal is to make a complete list of the functionality for iPhone and iPod Touch.
Note: each thing from the pool can only be used once!
You may have noticed some random stuff on this list—who would’ve thought about the speaker?
Apple is always coming out with new devices and updating.
There’s a method for checking With all of  these little things that can be different between devices, pretty much every time you go to use something from the device, you need to check and see if  it’s there.
Since we’re getting the info from a source, we need to check and see if the source you want is there.
So what happens when the user taps the “Take a photo” button? You check for the camera, then what? What’s the user flow?
In our case, we have another option: the photo library.
If  there’s no camera, we can get an image from there instead.
Prompt the user with action sheets Action sheets slide up from the bottom of  the page and give the user options to proceed.
It’s similar to a modal view because the user has to address the action sheet before they can move on to anything else.
Action sheets are really straightforward to use: they take strings for their buttons and have built-in animations for appearing and disappearing.
Our code for the action sheet has some standard stuff  included:
What happens with each of these buttons? Go to the camera, take a picture, and then come back and put your new image into the Fugitive.
Go to the photo library, pick an image, and then come back and stuff that image into the Fugitive.
We’ll use action sheets to let the user pick the image source We know that our options are to use the camera, use the photo library, or cancel, so we’ll need to implement the behavior for each option.
First, allocate the action sheet, and pass it a title.
All action sheets need a cancel button, so you can dismiss it, just like modal views.
Implement the action sheet! There’s a lot here to think about since we’re changing the flow of the app a bit.
If  not, the app should just go straight into the photo library.
Think about the options for case 1 and the default, and make sure you release the picker and present the view.
The action sheet should be ready to go and your app has a good user flow now...
Test Drive Fire up iBountyHunter and drill down through a fugitive to the point of taking a picture.
The action sheet pops up, and once you select choose the existing photo...
It might be time to register with Apple’s Developer Program.
If you do, you can install the app on your actual iPhone and test it yourself.
Check out the appendix at the end of the book to help you walk through the provisioning process to make it work.
Q: Doesn’t iPhone 3GS support video now? How do I get to that?
By default, it uses still images, which is what we want for iBountyHunter.
Q: What about the whole augmented reality thing with the camera? Can I do something like that?
There are still limitations on what you can actually do in the camera view, but you can overlay it with your own information if you want.
A: The picker controller has built-in support for cropping and zooming images.
The allowEditing flag controls whether or not the users get a chance to move and resize their image before it’s sent to the delegate.
If you enable it, and the user tweaks the image, you’ll be given editing information in the callback.
Q: Do we really have to worry about the iPod Touch?
When you submit your application to Apple for inclusion in the iTunes App Store, you specify the devices your application works with.
If you say it works, Apple will test it on both types of devices.
They also run tests where your application cannot get network access to ensure you handle that properly as well.
Apple is going to test your application in a variety of scenarios.
Q: Is there any way to test the camera in the simulator?
What we’ve done is about as close as you can get, which is to implement.
You’ve learned a lot so far, and lots of the functionality that you’re moving into has outgrown the simulator.
A: In order to install an app on your device or to submit an app to the App Store, you need to be a registered iPhone developer with Apple.
Even if you want to just install an app for your own personal use, you’ll need to be registered.
Look at the appendix for more detailed directions of how installing an app on your phone actually works.
Bob needs the where, in addition to the when You’ve given Bob a way to record the proof  he captured someone with a photo, and an easy way to note when it happened, but what about the where?
Cool—I love the pictures—but I need location info about the grab, too.
There are rules about where Bob can nab criminals, so he needs to keep track of  where the capture occurred.
The easiest way for Bob to keep track of these things is by recording the latitude and longitude of  the capture.
How are two new fields going to affect the app? Use this space to show where, and on what view, the latitude and longitude info will end up.
What needs to happen to the data model and the data itself?
Here’s what we came up with for the new view and the data changes:
The database needs to be updated: we’re going to be getting a latitude and longitude value in degrees.
To hold them in the database, they’ll need to be broken up into two new attributes for the Fugitive class: latitude and longitude.
What needs to happen to the data model and the data itself?
Get into it and get the app ready for the capture coordinates:
Implement the new fields in the view for the location label and the latitude and longitude fields.
Migrate the database again and produce the new Fugitive class with the latitude and longitude fields.
We called them capturedlat and capturedlon and made them type “Double”
Get into it and get the app ready for the capture coordinates:
Implement the new fields in the view for the location label and the latitude and longitude fields.
The values will be added here when the fugitive is captured.
Migrate the database again and produce the new Fugitive class with the latitude and longitude fields.
The new fields, capturedLat and catpuredLon, are both of type “Double”
You may remember back in that pool puzzle we said something about the iPod Touch being able to handle limited location.
The iPhone (and iPod Touch) have more than one way to get at where you are in the world.
Core Location can find you in a few ways GPS is the first thought most people come up with, but the first generation iPhone didn’t have GPS, and neither does the iPod Touch.
There area actually three ways available for the iPhone to determine your location: GPS, cell tower triangulation, and Wi-Fi Positioning Service.
Core Location actually decides which method to use based on what’s available to the device and what kind of  accuracy you’re after.
That means none of  that checking for source stuff; the iPhone OS will handle it.
To use Core Location, you simply need to create a location manager and ask it to start sending updates.
It can provide position, altitude, and orientation, depending upon the device’s capabilities.
In order for it to send you this info, you need to provide it with a delegate as well as your required accuracy.
The CLLocationManager will notify you when positions are available or if  there’s an error.
You’ll want to make sure you’re also properly handing when you don’t get a position from the location manager.
Even if  the device supports it, the users get asked before you collect location information, and can say “No” to having their position recorded (either intentionally or by accident)
Allocate the CLLocation Manager You’ll need to pass in the accuracy.
Once the locationManager has the position, it will start sending it back to the delegate for you to use.
I guess we’re going to need a new header file for those Core Location constants?
To keep the size of  your app small, Apple breaks apart functionality into libraries.
As you start adding new functionality, like Core Location, you’ll need to start adding frameworks.
Since the Core Location framework isn’t included by default, we need to go add it.
Add a new framework So far we’ve been spoiled and have used default frameworks, or they’ve been imported with the template.
Now that we’re branching out, it’s time to add the Core Location framework to the app.
We’re working through the delegate, so tha t needs to be there.
Declare the CLLocationManager so we ca n use it and.
Making frequent calls from your app to find locations will quickly drain batteries, since it turns on the GPS/cellular/ Wi-Fi receiver.
Bob needs the location and date and time to mark a capture.
What method will be used to kick off  Core Location in the detail view?1
What happens when the location is returned to the view controller?2
What happens if  Core Location can’t get anything or the user disables it?3
Bob needs the location and date and time to mark a capture.
What method will be used to kick off Core Location in the detail view?
What happens when the location is returned to the view controller?2
Put the code to initialize Core Location in the viewWillAppear for the detail view.
We’ll know the location manager can get the current position.
If the user marks the fugitive as captured, we need to get the current position from the location manager and update the fugitive.
We don’t need the continually updating locations, so we’ll ask the location manager for its last.
Since Bob needs the location info when he marks a fugitive as captured, we’ll need to disable the captured switch if we can’t get anything.
We’ll shut it down when we leave the detail view.
All we do is tell Core Location the accuracy we want and it deals with the rest.
So, the iPod Touch can get just the best data it can, and we’ll get that.
Do this! Implement all this code and then take it for a spin...
What happens if  Core Location can’t get anything or the user disables it?3
Since the segmented controller really doesn’t have a nice disabled look, you might want to consider using a UIAlertView to warn the user that they can’t mark anyone as captured.
Q: We start and stop Core Location in viewWillAppear and viewWillDisappear.
A: It’s normal to start and stop Core Location as you need it.
It uses a fair amount of power while it’s running, so it’s best to shut it down if you don’t need it.
This gets a little tricky because Core Location can require some time to get its initial position information.
To try and make that a little smoother for the user, we enable it as soon as the view appears to give it a head start before the user needs the location.
Q: Is there any way to speed up that initial position? A: Core Location will try to cache previous position information so it can give you something as quickly as possible.
Because of this, if you’re really concerned about accuracy, you should check the timestamp sent along with the position information to make sure the position is recent enough for your needs.
Q: Does location accuracy impact things like startup time or battery usage?
The more accurate a position you ask for, the more battery Core Location will consume and it will potentially take longer to figure out.
Use whatever accuracy you need for your application, but be aware of the implications of high resolution information.
Q: Is there a way to just wait for Core Location to have a position rather than having it call back to the delegate like that?
Core Location, like a lot of other frameworks in iPhone OS, calls back asynchronously as data is available.
You need to make sure you keep your users informed of what’s going on in the application and what they can and can’t do at the moment.
For example, we disable the Captured button if there’s no position information available.
Other options display a wait indicator (like a spinning gear) or display position status with a disabled indicator like an icon, button, or label.
Test Drive Implementing Core Location really wasn’t that hard, but making it work in the user flow required a bit more work.
Now that it’s all done, you should be up and running...
To operate the app here, Bob will navigate into the detail view, which will kick off the Core Location manager.
Once a position is returned, the captured button is enabled and the fields are populated.
That’s great for my forms and everything, but I’m more of a visual person...
What’s the point of  all the network connectivity and fancy graphics if we just show a text field? With just a little bit of  code and the iPhone OS Map Kit, we’ve got something a lot more appealing in the works.
Map Kit is new with iPhone 3.0 With the latest major iPhone update, Apple opened up the API for the maps that are used on the iPhone.
The data for the maps comes from Google maps, including satellite imagery.
There’s lots of  customization that you can do with the maps, such as how wide an area they show, what view they start with, and pins and annotations.
MKMapView is a control that pulls map information from Google Maps.
You can configure it for the normal road display, satellite imagery, or a hybrid, like you see here.
Map Kit comes with built-in support for pushpins at specified locations, called annotations.
Depending on the information you want to show on the map, you can create your own Views for annotations and show anything you want, like pictures, formatted text, etc.
Since Map Kit pulls imagery information from Google, you’ll need to have a network connection for it to be useful.
That’s not a problem for the simulator (assuming your Mac is online) but it could be an issue for the iPod Touch.
Map Kit handles this gracefully, but it’s something to be aware of.
A little custom setup for the map Like Core Location, it’s not a lot of  work to get basic Map Kit support going in iBountyHunter.
Here we’ll pass in the value of the lat and lon where the fugitive was captured.
These values allow us to configure the size of the default map shown.
We pull all of this information together to initialize the map.
There are a few map types; hybrid is both satellite and road information.
Implement the map to show the area where the fugitive was captured.
Add the framework just like we did with Core Location.
While you’re at it, make sure that you do the #import in the detail view to include the Map Kit header.
Rather than adding a whole new view, go ahead and add the map to the CapturedPhotoView with the image.
Resize the image and the button then drag an MKMapView to the bottom half  of the view.
Now that you have all the support stuff  in place, go ahead and add the outlets and the actual Map Kit code we gave you to make the map work.
Make sure you wire up the outlet in Interface Builder.
Q: What’s the difference between Core Location and Map Kit? A: Map Kit is about displaying a map, position-sensitive information, and, user interface.
Core Location is about getting you information about where you are.
You can drag and drop a map onto your view in Interface Builder; you pass it some values and it just works.
Core Location, on the other hand, returns values to the delegate and you need to decide what to do with them.
We’re going to take that information from Core Location and give it to Map Kit to show us a map of the capture location, for example.
Q: Where do all these frameworks come from? What if I want one that’s not on the list?
A: The frameworks are included as part of the SDK.
The actual path to the frameworks varies by version and what platform you’re developing for.
In general, you should be able to add frameworks using the “Add Existing Framework” and not need to worry about a specific location, but if a framework isn’t listed or you’re adding a custom one, you can point Xcode to the actual path.
Implement the map to show the area where the fugitive was captured.
Test Drive Go ahead and build and run the app.
You’ll need to make sure that you mark a fugitive as captured, and that the lat/lon field fills in, then flip over the view to look at the map.
To try out the zooming on the map you’d use the “pinching” motion on a real device.
Test Drive To try out the zooming on the map, the “pinching” motion in real life, in the simulator, hold down option and then click.
Excellent! Now all we need is a pin to show where the capture happened.
You can click in the map and move it around.
Since you’re in the simulator, the location will be Cupertino, CA, no matter where you are.
Annotations require a little more work Annotations are the little flags that come up when you see a point of  interest, represented by a pin.
The catch? Incorporating annotations means conforming to the Map Kit annotation protocol.
Map Kit uses an annotation protocol so that you can use your existing classes and provide them directly to Map Kit.
The downside is that means we need to add code to our Fugitive class.
For an application that you expect to have to do more data migration, you should implement a separate class conforming to the protocol that has a reference to its Fugitive (composition) rather than adding code to the Fugitive class directly.
The protocol requires us to have a coordinate property, a title, and a subtitle.
Instead of synthesizing that coordinate property, we’ll implement it ourselves and just return the fugitive’s position, name, etc.
That’s it! Everything should be working now.You may not have noticed as you’ve been working through all this code, but this app is huge and awesome!
This invokes the camera, which you can see on your phone, not the simulator.
Your app must be able to work on the ____________ , too.
One last time to flex the right side of your brain...
Your app must be able to work on the ____________ , too.
You’ve got Chapter 9 under your belt and now you’ve.
For a complete list of tooltips in the book, go to http://www.headfirstlabs.
Is not on all devices and you need to handle that.
Allows you to select and edit an image for use in your app directly from your library.
We’re sad to see you leave, but there’s nothing like taking what you’ve just learned and putting it to use.
You’re just beginning your iPhone journey, and we’ve put the.
Check out the Appendix after this to find out how to get your brilliant.
So take a peek and see what you (still) might be missing out on.
Depending on your application, you should consider supporting multiple languages and cultures.
Location or culture-specific icons and images such as flags or text.
Once you’ve identified the culture or language-specific parts of  your application, the next step is to localize them.
The iPhone OS has strong support for localizing resources and separates the localizable resources from the rest of  the application so you can easily use a localization team or outsource the effort all together.
Up until now our resources have been included in our application in the .app directory.
Once you start localizing resources, Xcode creates an lproj directory for each localization (locale) you add and moves the locale specific resources there.
For example, if  you provide both English and French translations of  your nibs, then you will have an en.lproj (or English.lproj) and fr.lproj directories in your application.
Localizing nibs Xcode and Interface Builder have built-in support for localizing nibs.
Before you start translating anything, you need to ask Xcode to create the locale-specific directories.
Next click on “Make File Localizable.” Xcode will turn your nib entry in the project list into a group with each localization listed beneath it.
The next dialog you’ll see allows you to add additional localizations.
Select the General tab and click “Add Localization.” In the dialog that appears, you should enter the country code of  the localization you wish to add.
Click on the “Make File Localizable” to ask Xcode to create the locale-based directory structure that organizes your resources.
This is the “Get Info” dialog for a nib, but use this approach to localize any generic resource like icons or images.
The Add Localization button asks you for the new localization name.
Use two or three character country codes found in Apple’s documentation.
Do not use the values in the drop down list.
Now all you need to do to localize the nib is to double-click on the language you want to localize and translate any text.
Remember that depending on the language, you may need to adjust layout as well.
For large projects, there is a command-line tool you can use called ibtool that you can use to extract all string values from a nib into an external file, then merge translations back into the nib later.
This allows for bulk extraction and translation, but you need to be particularly careful about layout issues as you’re not visually inspecting each nib.
Once a nib has been translated, you can have Interface Builder mark it as locked to prevent any accidental changes to the text or layout that could impact your translations.
See Apple’s documentation on bundles and nib localization for more information.
Localizing string resources In addition to nib text, text in your application that you intend on showing the user needs to be localized as well.
For example, the Action Sheet used in iBountyHunter offers the user the option to take a photo, choose an existing one, or cancel.
That button text is generated programmatically and needs to be translated appropriately.
For this type of  text, called string resources, the iPhone OS uses strings files.
You’ll generally have one of  these files for each language you support.
Each file contains a description of  what the string is trying to communicate, the default language version of  the string, and the translated version.
Title for the important alert view */ “This is important!” = “This is important!”;
Are you sure?” = “This will empty your bank account.
You’ll want to run this for each translation you support.
You’ll need to add that strings file to your Xcode project like any other resource, but once it’s there, the iPhone OS will look in the appropriate strings file at runtime based on the language the users select for their device.
The iPhone OS provides robust localization capabilities, including currency, time, and date presentation support; we’ve just scratched the surface.
If you’ve installed your app before doing translations, it’s likely that the iPhone OS.
Generating your strings file You could create your strings file by hand, but a much simpler way is to have Xcode generate it for you.
Xcode does this by looking for the localization macros that load the translated text.
To support localized strings, you should use one of  the NSLocalizedString macros, like this:
The second argument is the comment to be shown with the string in the strings file.
UIWebView The iPhone OS comes with a powerful control called UIWebView that uses Web Kit to handle web content.
You can use this control to load external URLs like a normal browser or to load local content for displaying documentation written in HTML.
Despite how powerful it is, it’s one of  the simplest controls to use.
To create a UIWebView, simply drop one onto your view in Interface Builder and set up an outlet for it in the view controller.
To load a URL, you simply send it the loadRequest: message with the URL you want it to load, like this:
We want the whole page shown initially, so we enable scalesPageToFit.
UIWebView properties Once you’ve loaded a URL, you can then use the loading property to find out if  UIWebView is currently trying to load a URL.
To control how the page is shown, you have a few options.
However, you can enable the scalesPageToFit property to have it scale the URL’s content to fit the screen.
If  this property is enabled, users can use the usual pinch gesture to zoom and pan around the contents.
It will set its canGoBack and canGoForward properties based on whether there are pages in its forward or back history.
Typically you use those to enable or disable forward and back buttons if  you want navigation support.
UIWebView knows what the history looks like, so you can simply send it the goBack: or goFoward: mesages and it will handle the rest.
Loading generated content You can also use UIWebView to load locally generated content (such as displaying HTML help files or reports) by asking it to load an HTML string, like this:
The UIWebView supports a delegate, too If  you want to know more about what’s going on with the UIWebView, you can conform to the UIWebViewDelegate protocol and set the delegate on your web view.
The delegate protocol lets you get notified when loading starts and stops as well as gives you an opportunity to inspect links before they are followed.
You can return NO if  the web view shouldn’t follow the URL.
Device orientation and view rotation On the surface, the iPhone OS makes handling screen rotation simple.
The iPhone and iPod Touch each contain an accelerometer that lets the device detect orientation.
When you build an application using UIKit, the iPhone OS asks the active view controller if  it can handle rotating.
By default this is the only orientation view controllers support.
If  your view can handle the given orientation, it simply returns YES.
You can use this method to disable buttons or timers or anything else that could cause a problem while the view is changing.
The I-beam shapes on the edges indicate how the control is anchored to the view.
The lines inside the box indicate which directions the control is allow to resize.
A dashed line indicates the control cannot change sizes in that direction.
A solid line means UIKit can resize the control if the view changes shape.
This window animates what would happen to the control as the view changes shape.
Interface Builder lets you rotate the view you’re working on and see the autosizing at design time.
When the simulator rotates, the view controller is told; the iPhone OS animates the transition, then the autosizing kicks in, and the button spans the whole phone.
Handling rotation with two different views Depending on your application, your view may be sufficiently complex that autosizing just doesn’t get you what you want for the rotated view.
Alternatively, some applications present a totally different perspective to the user in landscape mode than in portrait mode.
The built-in Stocks application shows two different views depending on the orientation of the device - it’s more than just autosizing controls.
To support multiple views, you’ll need to either define multiple UIViews in your nib or create separate nibs.
Then, when your view controller is notified of  the rotation, you can change your self.view to the appropriate view depending on the target orientation.
You can only have one object for any given IBOutlet!
If you have similar controls (but in different positions or altered styles) in your views, you’ll need separate.
View animations If  you’ve spent any time with an iPhone or iPod Touch you know that smooth transitions and graceful animations define the user experience.
In the applications we’ve built so far, we’ve only touched on a few basic animations (like the flip animation used in iBountyHunter)
However, everything from adding and removing table rows to sliding controls around the screen can be animated.
Animating table view updates If  you’re going to add or remove multiple rows in a table view, you can ask it to provide a smooth animation (as well as a more efficient handling of  updating the table view itself) by sending it the beginUpdates message before you start manipulating the data, then an endUpdates when you’re finished, like this:
The tableView will immediately ask the datasource and delegate for cell information for those new rows and, if you specify the animation information, they’ll smoothly slide in to the table.The beginUpdates and endUpdates tell the tableView that you’
Animating view and control changes Similar to table views, UIViews have built-in support for smoothly animating changes to several of their properties.
You simply need to tell the view that you want it to animate a change by sending it the beginAnimations message, describe the end point of  the change, then ask it to start the transition by sending it the commitAnimations message.
UIView property Description frame The physical rectangle that describes the view - the view’s origin.
Accelerometer One of  the most versatile pieces of  hardware in the iPhone and iPod Touch is the accelerometer.
The accelerometer allows the device to detect acceleration and the pull of gravity along three axes.
With just a few lines of  code, you can tell whether the device is rightside up, upside down, laying flat on a table, etc.
You can even detect how quickly the device is changing direction.
All you need is the UIAccelerometer Getting orientation information from your device is straightforward.
To receive acceleration information you simply need to tell the accelerometer about the delegate and how frequently to send acceleration information, like this:
Each UIAcceleration object contains acceleration information along the x, y, and z axes and a timestamp that the data was collected.
In a simple example, you can update labels with the acceleration information, like this:
You’ll get no information back, regardless of  how much you shake your Mac.
You’ll need to install the application on a real device to get actual accelerometer information back.
If the device is held still, the pull of gravity is defined as 1.0 along some axis.
The Z axis runs through the display of the phone, with positive Z pointing out of the front of the display.
Place the device face up on the table and your Z axis value will be -1
If  you’re building a typical view-based application, UIKit hides a lot of  the need for the accelerometer by letting you know about orientation changes and automatically providing undo/redo when the user shakes the phone.
The accelerometer is most useful for custom-drawn applications like games (steering or balance) and utility applications (levels)
Multitouch You probably noticed that we only used one of  the possible events that can be triggered for a button in our apps, the touch up inside event.
The iPhone is capable of  detecting up to five finger touches at a time and can interpret how each of  those fingers are interacting with the screen with several different types of  events.
In addition to touches, the iPhone can detect swipes and gestures that can be configured as well.
By defining the length and direction of  a swipe, you can create lots of  different ways to interact with your application.
Pinching is a custom gesture that Apple uses in many of  its default applications, most notably Safari, to zoom in and out of  a view.
It is just registering for a two-finger touch and keeping track of  the change in the distance between them: if  it increases, zoom out, if  it decreases, zoom in.
Using these events means that you can create custom interfaces, not just touching buttons, for your user.
Working with multitouch means that your view needs to be configured to be a multitouch view, and then you need code to work with each different type of event that you’re interested in leveraging.
Working with these events requires working with the responder chain (see the UIResponder class reference) and the UIEvents class reference.
It’s outside of  the scope of  our book to get into those applications—which can use multitouch interactions, Quartz and OpenGL graphics, and peer to peer networking—but here we’ll give you a quick pass at the technologies that you can use and where to find more information about them.
These are all of the button events than can be triggered.
Quartz and OpenGL Quartz and OpenGL are the two ways to create graphics on the iPhone and they are both big enough to be books on their own, but here’s a small sample of  what you’d be dealing with.
Quartz Quartz is the simpler of  the two, allowing you to draw in two dimensions directly into the view.
The drawing code uses the Core Graphics Framework and renders directly into the view.
It follows a painter’s model, which means that the order of  commands is important.
The first thing drawn will be covered up with a subsequent drawing in the same location.
Quartz can handle shading, color, and interfacing with other image and video types.
The Quartz 2D Programming Guide in the developer documentation has a lot of information to help get you started.
OpenGL OpenGL can work in two or three-dimensional graphics and is significantly more complex, but that means that you have more flexibility to work with.
It is a well-established, cross platform library that has been implemented for mobile devices with OpenGL ES, and is used through the OpenGL ES Framework.
You can use it to draw lines, polygons, and objects, and animate them as well.
A good place to get started is with the OpenGL ES Programming Guide for iPhone OS in the developer documentation.
Game Kit New with the iPhone OS 3, the GameKit framework allows you to use both peer to peer networking and voice over bluetooth to facilitate interaction with other devices within game play.
This functionality does not exist for the first generation iPhone, iPod Touch, or the simulator alone.
After that connection is established, you can transmit data or voice between devices.
A good place to get started is with the GameKit Programming Guide to leverage this new functionality in your app.
It’s time to take this thing out for a spin, don’t you think?
And the only way to do that is to register with Apple as.
Even then, it’s not just a matter of clicking a button in Xcode to get an app.
Apple has rules We’ve talked about the HIG, and how stringent Apple can be through the approval process—they’re protecting their platform.
Part of  that is keeping track of  what goes on your own iPhone, even when it’s stuff  you’ve written yourself.
Here we’re going to give you an overview of  how you can get an app onto your device, and then, in turn, ready for submission.
We can’t get into the nitty gritty of  the full process—for that you need to be a member of  the iPhone Development Program and pay the $99 fee.
Start at the Apple Developer Portal The Developer Portal, where you first downloaded the SDK, is also your hub for managing all the parts of  electronic signatures that you’ll need to get an app up and running on your iPhone.
First get your Development Certificate Getting through the process to go from having your app in Xcode to installing it on an iPhone or iPod Touch for testing means that you need a Development Certificate and a Provisioning Profile.
This certificate is signed by you and Apple to register you as a developer.
It creates a public and a private key, and the private key is stored on the keychain app on your Mac.
Xcode will use it to sign the apps you build to install on a device.
The iPhone Development Guide in the Xcode documentation has some more good information that you can look at before you join the Development Program.
The Provisioning Profile pulls it all together Now that you have a Development Certificate in place, to complete the process you need a Provisioning Profile.
That electronic document ties the app (through an iPhone application ID), the developer, and the certificate together for installation onto the device.
To start, you need to enter your Device ID into the Developer’s Portal to request a Provisioning Profile.
Apple will issue a Provisioning Profile that you’ll need to download to the Organizer in Xcode.
In Xcode, you’ll use the Organizer to keep all of your devices and profiles straight.
In the Organizer, you’ll attach the Profile to your device.
Finally, when you compile your app in Xcode, you’ll be able to select your iPhone as the location for the build, rather than the simulator.
If you have your iPhone plugged in, you’ll get a similar display.
Here you’ll be able to get to your Provisioning Profiles.
In here, you’ll be able to configure your device for development.
The Organizer will make sure that you have a valid software version for development, and if not, help you choose one that works.
This quick overview gives you an idea of  how the process works, but you need to get into the Developer Program to learn all the details.
Our goal here was just to help you see the big picture of  the process.
First, when you’re developing as part of a team, the team admin has to be involved in many of  these steps.
Second, you need to go through this process to install anything on your device, regardless of  whether you plan to release it to the world or not.
And finally, what about the app store? Once you’ve joined the Developer Program, and the application has been tested, then you can submit it for approval.
This Identifier is required for a Provisioning Profile and is unique to each device.
It has a lot of good information to get you through the process.
See DrinkMixer app example; iBountyHunter app; iDecide app example; InstaTwit app example.
See DrinkMixer app example; iBountyHunter app example; iDecide app example; InstaTwit app example.
There’s a lot of buzz and a lot of money tied up inthe App Store...
Mobile applications aren’t just ported desktop apps iPhone apps are not small desktop apps.
Anatomy of an iPhone app First we have one or more views...
Mike can’t make a decision Make a good first impression It all starts with the iPhone SDK Xcode includes app templates to help you get started Xcode is the hub of your iPhone project...
Interface Builder Add the button to your view The iPhone Simulator lets you test your app on your Mac What happened? Unless the UI components are hooked up to the code, nothing is going to happen.
Use Interface Builder to connect UI controls to code Interface Builder lists which events a component can trigger Elements dispatch events when things happen to them Connect your events to methods iPhonecross iPhonecross Solution Your iPhone Toolbox.
The life of a root view First, get the data from Mike Use pickers when you want controlled input When in doubt, check out Apple’s API documentation.
Fill the picker rows with Mike’s data Pickers get their data from a datasource...
There’s a pattern for that Controls have their own specific datasources and delegates.
Protocols tell you what methods (messages) you need to implement First, declare that the controller conforms to both protocols Next, add Mike’s activities and feelings to the implementation file.
The datasource protocol has two required methods Connect the datasource just like actions and outlets There’s just one method for the delegate protocol The button needs to be connected to an event Without an action, your button won’t work! Add the IBOutlet and property to our view controller Connect the picker to our outlet Use our picker reference to pull the selected values iPhonecross iPhonecross Solution Your iPhone Toolbox.
Make room for custom input Header files describe the interface to your class Auto-generated accessors also handle memory management Objective-C can automatically release references, too.
To keep your memory straight, you need to remember just two things But when Mike’s finished typing...
Customize your UITextField Next change the label on the return key.
Ask the textField to give up focus Messages in Objective-C use named arguments Use message passing to tell our viewcontroller when the Done button is pressed Something’s still not right Build the tweet with strings Objective-Ccross Your Objective-C Toolbox Objective-Ccross Solution.
So, how do these views fit together? The navigation template pulls multiple views together The navigation template starts with a table view A table is a collection of cells Each drink gets its own cell...
Instantiate a view controller like any other class Dictionaries store informationas key-value pairs Debugging—the dark side of iPhone development Warnings can help find problems without debugging.
First stop on your debugging adventure: the console Interact with your application while it’s running And when it’s about to stop running.
Xcode supports you after your app breaks, too The Xcode debugger shows you the state of your application What the heck is going on? MultipleViewscross Your iPhone Toolbox MultipleViewscross Solution.
Use the debugger to investigate the crash We’re trying to stuff a dictionary into a string Update your code to handle a plist of dictionaries The detail view needs data Each dictionary has all the information we need We have a usability problem Use a disclosure indicator if your cell leads to more information Sales were going strong...
Use navigation controller buttons for editing The button should create a new view We need a view...
You can subclass and extend views like any other class Use Xcode to create a view controller without a nib Modal views focus the user on the task at hand...
Any view can present a modal view Our view doesn’t have a navigation bar Create the save and cancel buttons Write the save and cancel actions iPhoneDevcross Your iPhone Toolbox iPhoneDevcross Solution.
Keyboard events tell you the keyboard state and size The table view doesn’t know its data has changed You need to ask the table view to reload its data The array is out of order, too We can sort our array using NSSortDescriptor.
Build the fugitive list view Next up: the captured view After a quick meeting with Bob...
Core Data lets you focus on your app But wait, there’s more!
Core Data needs to know what to load We need to define our types...
Core Data describes entities with a Managed Object Model Build your Fugitive entity Whip up a Fugitive class without writing a line Our generated Fugitive class matches our Managed Object Model NSManagedObject handles storage and memory for generated properties NSManagedObject also implements the properties.
Use an NSFetchRequest to describe your search Ask the Managed Object Context to fetch data using your NSFetchRequest.
Add the database as a resource Back to the Core Data stack.
The template sets things up for a SQLite DB iPhone Apps are read-only.
The iPhone’s application structure defines where you can read and write Use the Documents directory to store user data.
Bob needs documentation Everything stems from our object model The data hasn’t been updated Core Data caught a mismatch between our DB and our model.
Data migration is a common problem We need to migrate the old data into the new model Our two models need different versions.
Xcode makes it easy to version the data model Core Data can “lightly” migrate data Bob has some design input The Managed Object Context saves new or changed items A quick demo with Bob Use predicates for filtering data NSFetchRequest concepts are nearly identical to SQL.
For Bob, payment requires proof! Flip over for the detail view! The way to the camera...
The iPhone isn’t the only device using apps There’s a method for checking Prompt the user with action sheets We’ll use action sheets to let the user pick the image source.
Bob needs the where, in addition to the when Core Location can find you in a few ways Core Location relies on the LocationManager Add a new framework Then update the header file.
Device orientation and view rotation The view controller tells the iPhone OS what orientations it supports Handling view rotations Handling rotation with two different views.
View animations Animating table view updates Animating view and control changes.
Accelerometer All you need is the UIAccelerometer Understanding the device acceleration.
The Provisioning Profile pulls it all together Keep track in the Organizer A few final tips...
