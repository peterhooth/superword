Head First Python is a great introduction to not just the Python language, but Python as it’s used in the real world.
Where other books start with theory and progress to examples, Head First Python jumps right in with code and explains the theory as you read along.
This is a much more effective learning environment, because it engages the reader to do from the very beginning.
It was fun without being flippant and informative without being condescending.
The breadth of  examples and explanation covered the majority of  what you’ll use in your job every day.
Kathy and Bert’s Head First Java transforms the printed page into the closest thing to a GUI you’ve ever seen.
Just the right tone for the geeked-out, casual-cool guru coder in all of  us.
There are books you buy, books you keep, books you keep on your desk, and thanks to O’Reilly and the Head First crew, there is the penultimate category, Head First books.
They’re the ones that are dog-eared, mangled, and carried everywhere.
Head First SQL is at the top of  my stack.
Usually when reading through a book or article on design patterns, I’d have to occasionally stick myself in the eye with something just to make sure I was paying attention.
Odd as it may sound, this book makes learning about design patterns fun.
Wouldn’t it be dreamy if there were a Python book that didn’t.
O’Reilly Media books may be purchased for educational, business, or sales promotional use.
Many of  the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and O’Reilly Media, Inc., was aware of  a trademark claim, the designations have been printed in caps or initial caps.
While every precaution has been taken in the preparation of  this book, the publisher and the author assume no responsibility for errors or omissions, or for damages resulting from the use of  the information contained herein.
No athletes were pushed too hard in the making of  this book.
I dedicate this book to all those generous people in the Python community who have helped to make this great little language the first-rate programming technology it is.
And to those that made learning Python and its technologies just complex enough that people need a book like this to learn it.
Paul Barry recently worked out that he has been programming for close to a quarter century, a fact that came as a bit of  a shock.
In that time, Paul has programmed in lots of  different programming languages, lived and worked in two countries on two continents, got married, had three kids (well…his wife Deirdre actually had them, but Paul was there), completed a B.Sc.
When Paul first saw Head First HTML with CSS & XHTML, he loved it so much he knew immediately that the Head First approach would be a great way to teach programming.
He was only too delighted then, together with David Griffiths, to create Head First Programming in an attempt to prove his hunch correct.
Paul’s day job is working as a lecturer at The Institute of Technology, Carlow, in Ireland.
As part of  the Department of  Computing and Networking, Paul gets to spend his day exploring, learning, and teaching programming technologies to his students, including Python.
Paul recently completed a post-graduate certificate in Learning and Teaching and was more than a bit relieved to discover that most of  what he does conforms to current thirdlevel best practice.
Here you are trying to learn something, while here your brain is doing you a favor by making sure the learning doesn’t stick.
Reusable code is great, but a shareable module is better.
By sharing your code as a Python module, you open up your code to the entire Python.
Along the way, you’ll pick up a few new tricks relating to Python’s functions, too.
It’s simply not enough to process your list data in your code.
You need to be able to get your data into your programs with ease, too.
It is truly great to be able to process your file-based data.
But what happens to your data when you’re done? Of course, it’s best to save your.
Data comes in all shapes and sizes, formats and encodings.
To work effectively with your data, you often have to manipulate and transform it into a.
It’s important to match your data structure choice to your data.
And that choice can make a big difference to the complexity of your code.
And when Python’s built-in data structures don’t quite cut it, the Python class.
Sooner or later, you’ll want to share your app with lots of people.
Pop your code on PyPI, send out lots of emails, put.
Luckily, you don’t have to do any of this: just create a webapp instead.
Putting your data on the Web opens up all types of possibilities.
Not only can anyone from anywhere interact with your webapp, but they are increasingly.
And it’s not just humans interacting with your webapp that.
The Web and your phone are not just great ways to display data.
They are also great tools to for accepting input from your users.
The Web is a great place to host your app…until things get real.
Sooner or later, you’ll hit the jackpot and your webapp will be wildly successful.
Will you be ready? Will your web server handle the load?
How will you know? What will it cost? Who will pay? Can your data model scale to.
It’s great when you can apply Python to a specific domain area.
Whether it’s web development, database management, or mobile apps, Python helps.
Problems that are in themselves so unique you have to look at them in a different, highly.
Creating bespoke software solutions to these type of problems is an area.
In this, your final chapter, you’ll stretch your Python skills to the.
But learning about Python is an activity that never stops.
There’s just not enough room in this book to show you.
Do you prefer actually doing things and applying the stuff you learn over listening to someone in a lecture rattle on for hours on end?
Do you wish you had the know-how to program Python, add it to your list of tools, and make it do new things?
Are you looking for a reference book to Python, one that covers all the details in excruciating detail?
Do you already know how to program in another programming language?
Do you already know most of what you need to know to program with Python?
Would you rather have your toenails pulled out by 15 screaming monkeys than learn something new? Do you believe a Python book should cover everything and if it bores the reader to tears in the process then so much the better?
It was built that way, and it helps you stay alive.
So what does your brain do with all the routine, ordinary, normal things you encounter? Everything it can to stop them from interfering with the brain’s real job—recording things that matter.
It doesn’t bother saving the boring things; they never make it past the “this is obviously not important” filter.
How does your brain know what’s important? Suppose you’re out for a day hike and a tiger jumps in front of  you, what happens inside your head and body?
Or trying to learn some tough technical topic your boss thinks will take a week, ten days at the most.
It’s trying to make sure that this obviously non-important content doesn’t clutter up scarce resources.
Resources that are better spent storing the really big things.
Like how you should never have posted those “party” photos on your Facebook page.
And there’s no simple way to tell your brain, “Hey brain, thank you very much, but no matter how dull this book is, and how little I’m registering on the emotional Richter scale right now, I really do want you to keep this stuff  around.”
We think of a “Head First” r eader as a learner.
So what does it take to le arn something? First, yo.
Your brain will lea rn much more quickly if it.
If  you really want to learn, and you want to learn more quickly and more deeply, pay attention to how you pay attention.
Most of  us did not take courses on metacognition or learning theory when we were growing up.
We were expected to learn, but rarely taught to learn.
But we assume that if  you’re holding this book, you really want to learn how to design user-friendly websites.
And you probably don’t want to spend a lot of  time.
If  you want to use what you read in this book, you need to remember what you read.
To get the most from this book, or any book or learning experience, take responsibility for your brain.
The trick is to get your brain to see the new material you’re learning as Really Important.
Otherwise, you’re in for a constant battle, with your brain doing its best to keep the new content from sticking.
So just how DO you get your brain to treat programming like it was a hungry tiger?
There’s the slow, tedious way, or the faster, more effective way.
You obviously know that you are able to learn and remember even the dullest of  topics if  you keep pounding the same thing into your brain.
With enough repetition, your brain says, “This doesn’t feel important to him, but he keeps looking at the same thing over and over and over, so I suppose it must be.”
The faster way is to do anything that increases brain activity, especially different types of  brain activity.
The things on the previous page are a big part of  the solution, and they’re all things that have been proven to help your brain work in your favor.
For example, studies show that putting words within the pictures they describe (as opposed to somewhere else in the page, like a caption or in the body text) causes your brain to try to makes sense of  how the words and picture relate, and this causes more neurons to fire.
More neurons firing = more chances for your brain to get that this is something worth paying attention to, and possibly recording.
A conversational style helps because people tend to pay more attention when they perceive that they’re in a conversation, since they’re expected to follow along and hold up their end.
The amazing thing is, your brain doesn’t necessarily care that the “conversation” is between you and a book! On the other hand, if  the writing style is formal and dry, your brain perceives it the same way you experience being lectured to while sitting in a roomful of  passive attendees.
Here’s what WE did: We used pictures, because your brain is tuned for visuals, not text.
As far as your brain’s concerned, a picture really is worth a thousand words.
And when text and pictures work together, we embedded the text in the pictures because your brain works more effectively when the text is within the thing the text refers to, as opposed to in a caption or buried in the text somewhere.
We used redundancy, saying the same thing in different ways and with different media types, and multiple senses, to increase the chance that the content gets coded into more than one area of  your brain.
We used concepts and pictures in unexpected ways because your brain is tuned for novelty, and we used pictures and ideas with at least some emotional content, because your brain is tuned to pay attention to the biochemistry of  emotions.
That which causes you to feel something is more likely to be remembered, even if  that feeling is nothing more than a little humor, surprise, or interest.
We used a personalized, conversational style, because your brain is tuned to pay more attention when it believes you’re in a conversation than if  it thinks you’re passively listening to a presentation.
We included more than 80 activities, because your brain is tuned to learn and remember more when you do things than when you read about things.
We used multiple learning styles, because you might prefer step-by-step procedures, while someone else wants to understand the big picture first, and someone else just wants to see an example.
But regardless of  your own learning preference, everyone benefits from seeing the same content represented in multiple ways.
We include content for both sides of  your brain, because the more of  your brain you engage, the more likely you are to learn and remember, and the longer you can stay focused.
Since working one side of  the brain often means giving the other side a chance to rest, you can be more productive at learning for a longer period of  time.
And we included stories and exercises that present more than one point of  view, because your brain is tuned to learn more deeply when it’s forced to make evaluations and judgments.
We included challenges, with exercises, and by asking questions that don’t always have a straight answer, because your brain is tuned to learn and remember when it has to work at something.
Think about it—you can’t get your body in shape just by watching people at the gym.
But we did our best to make sure that when you’re working hard, it’s on the right things.
That you’re not spending one extra dendrite processing a hard-to-understand example, or parsing difficult, jargon-laden, or overly terse text.
In stories, examples, pictures, etc., because, well, because you’re a person.
And your brain pays more attention to people than it does to things.
These tips are a starting point; listen to your brain and figure out what works for you and what doesn’t.
Your brain works best in a nice bath of  fluid.
Dehydration (which can happen before you ever feel thirsty) decreases cognitive function.
Write a lot of code! There’s only one way to learn to program: writing a lot of  code.
And that’s what you’re going to do throughout this book.
Coding is a skill, and the only way to get good at it is to practice.
We’re going to give you a lot of  practice: every chapter has exercises that pose a problem for you to solve.
Don’t just skip over them—a lot of  the learning happens when you solve the exercises.
But try to solve the problem before you look at the solution.
And definitely get it working before you move on to the next part of  the book.
Groaning over a bad joke is still better than feeling nothing at all.
If  you find yourself  starting to skim the surface or forget what you just read, it’s time for a break.
Once you go past a certain point, you won’t learn faster by trying to shove more in, and you might even hurt the process.
If you’re trying to understand something, or increase your chance of  remembering it later, say it out loud.
Better still, try to explain it out loud to someone else.
You’ll learn more quickly, and you might uncover ideas you hadn’t known were there when you were reading about it.
Part of  the learning (especially the transfer to long-term memory) happens after you put the book down.
Your brain needs time on its own, to do more processing.
If  you put in something new during that processing time, some of  what you just learned will be lost.
They’re not optional sidebars, they’re part of  the core content! Don’t skip them.
Here’s what YOU can do to bend your brain into submission.
We put them in, but if  we did them for you, that would be like having someone else do your workouts for you.
There’s plenty of  evidence that physical activity while learning can increase the learning.
When the book asks you a question, don’t just skip to the answer.
The more deeply you force your brain to think, the better chance you have of  learning and remembering.
The more you understand, the less you have to memorize.
Read Me This is a learning experience, not a reference book.
We deliberately stripped out everything that might get in the way of  learning whatever it is we’re working on at that point in the book.
And the first time through, you need to begin at the beginning, because the book makes assumptions about what you’ve already seen and learned.
This book is designed to get you up to speed with Python as quickly as possible.
So you won’t find long lists of  technical material, no tables of  Python’s operators, not its operator precedence rules.
We don’t cover everything, but we’ve worked really hard to cover the essential material as well as we can, so that you can get Python into your brain quickly and have it stay there.
The only assumption we make is that you already know how to program in some other programming language.
We get you doing useful stuff  in Chapter 1 and build from there.
There’s no hanging around, because we want you to be productive with Python right away.
The exercises and activities are not add-ons; they’re part of  the core content of  the book.
Some of  them are to help with memory, some are for understanding, and some will help you apply what you’ve learned.
One distinct difference in a Head First book is that we want you to really get it.
And we want you to finish the book remembering what you’ve learned.
Most reference books don’t have retention and recall as a goal, but this book is about learning, so you’ll see some of  the same concepts come up more than once.
Our readers tell us that it’s frustrating to wade through 200 lines of  an example looking for the two lines they need to understand.
Most examples in this book are shown within the smallest possible context, so that the part you’re trying to learn is clear and simple.
Don’t expect all of  the examples to be robust, or even complete—they are written specifically for learning, and aren’t always fully functional.
We’ve placed a lot of  the code examples on the Web so you can copy and paste them as needed.
For some of  them, there is no right answer, and for others, part of  the learning experience of  the Brain Power activities is for you to decide if  and when your answers are right.
In some of  the Brain Power exercises, you will find hints to point you in the right direction.
He began programming at age 12, when he saw a documentary on the work of  Seymour Papert.
At age 15, he wrote an implementation of  Papert’s computer language LOGO.
After studying Pure Mathematics at University, he began writing code for computers and magazine articles for humans.
He’s worked as an agile coach, a developer, and a garage attendant, but not in that order.
He can write code in over 10 languages and prose in just one, and when not writing, coding, or coaching, he spends much of  his spare time traveling with his lovely wife—and fellow Head First authorDawn.
Having spent more than OOP, he is now teaching full time at the University of  Advancing Technology in Tempe, AZ.
In his spare time, Phil is a raving NFL fanatic.
He has been a developer, system administrator, quality assurance engineer, and tech support analyst.
They all have their rewards and challenges, but his most challenging and rewarding job has been husband and father.
When not editing books, Brian likes to run marathons in his spare time.
This turns out to be the perfect training for working on another book with me (our second together)
O’Reilly and Head First are lucky to have someone of  Brian’s caliber working to make this and other books the best they can be.
Karen Shaner provided administrative support and very capably coordinated the techical review process, responding quickly to my many queries and requests for help.
There’s also the back-room gang to thank—the O’Reilly Production Team—who guided this book through its final stages and turned my InDesign files into the beautiful thing you’re holding in your hands right now (or maybe you’re on an iPad, Android tablet, or reading on your PC—that’s cool, too)
And thanks to the other Head First authors who, via Twitter, offered cheers, suggestions, and encouragement throughout the entire writing process.
You might not think 140 characters make a big difference, but they really do.
I am also grateful to Bert Bates who, together with Kathy Sierra, created this series of  books with their wonderful Head First Java.
At the start of  this book, Bert took the time to set the tone with a marathon 90-minute phone call, which stretched my thinking on what I wanted to do to the limit and pushed me to write a better book.
Now, some nine months after the phone call, I’m pretty sure I’ve recovered from the mind-bending Bert put me through.
My thanks again to Nigel Whyte, Head of  Department, Computing and Networking at The Institute of  Technology, Carlow, for supporting my involvement in yet another book (especially so soon after the last one)
Their positive reaction to Python and the approach I take with my classes helped inform the structure and eventual content of  this book.
My family, Deirdre, Joseph, Aaron, and Aideen had to, once more, bear the grunts and groans, huffs and puffs, and more than a few roars on more than one occasion (although, to be honest, not as often they did with Head First Programming)
After the last book, I promised I wouldn’t start another one “for a while.” It turned out “a while” was no more than a few weeks, and I’ll be forever grateful that they didn’t gang up and throw me out of  the house for breaking my promise.
Without their support, and especially the ongoing love and support of  my wife, Deirdre, this book would not have seen the light of  day.
My technical review team did an excellent job of  keeping me straight and making sure what I covered was spot on.
They confirmed when my material was working, challenged me when it wasn’t and not only pointed out when stuff was wrong, but provided suggestions on how to fix it.
This is especially true of  David Griffiths, my co-conspirator on Head First Programming, whose technical review comments went above and beyond the call of  duty.
David’s name might not be on the cover of  this book, but a lot of  his ideas and suggestions grace its pages, and I was thrilled and will forever remain grateful that he approached his role as tech reviewer on Head First Python with such gusto.
With a subscription, you can read any page and watch any video from our library online.
Access new titles before they are available for print, and get exclusive access to manuscripts in development and post feedback for the authors.
Copy and paste code samples, organize your favorites, download chapters, bookmark key sections, create notes, print out pages, and benefit from tons of  other time-saving features.
To have full digital access to this book and others on similar topics from O’Reilly and other publishers, sign up for free at http://my.safaribooksonline.com/?portal=oreilly.
And then there’s the other stuff Python provides that makes.
But, before getting to that, there’s another important question that.
Rather than tell you, this book’s goal is to show you the greatness that is Python.
Before diving head first into Python, let’s get a bit of  housekeeping out of the way.
To work with and execute the Python code in this book, you need a copy of the Python 3 interpreter on your computer.
Like a lot of  things to do with Python, it’s not difficult to install the interpreter.
Install Python 3 Before you write and run Python code, you need to make sure the Python interpreter is on your computer.
In this book, you’ll start out with Release 3 of Python, the very latest (and best) version of  the language.
A release of  Python might already be on your computer.
Open up a command-line prompt and, if  you are using Mac OS X or Linux, type:
Without the UPPERCASE “v”, you are taken into the Python interpreter.
Use the quit() command to exit the interpreter and return to your OS prompt.
If  Python 3 is missing from your computer, download a copy for your favorite OS from the www.python.org website.
When you install Python 3, you also get IDLE, Python’s simple—yet surprisingly useful— integrated development environment.
Use IDLE to help learn Python IDLE lets you write code in its full-featured code editor as well as experiment with code at the Python Shell.
You’ll use the code editor later in this book but, when learning Python, IDLE’s shell really rocks, because it lets you try out new Python code as you go.
When you first start IDLE, you are presented with the “triple chevron” prompt (>>>) at which you enter code.
The shell takes your code statement and immediately executes it for you, displaying any results produced on screen.
The print() BIF displays messages to standard output (usually the screen)
By default, built-in functions are purple, strings are green, and language keywords (like if) are orange.
If  you hate these color choices, don’t worry; you can easily change them by adjusting IDLE’s preferences.
When you start with Python, this can be hard to get used to, but IDLE keeps you straight by automatically indenting as needed.
Work effectively with IDLE IDLE has lots of  features, but you need to know about only a few of  them to get going.
Type “pr” and then TAB at the >>> prompt to see IDLE’s list of command completion suggestions.
Recall code statements Press Alt-P to recall the previous code statement entered into IDLE or press Alt-N to move to the next code statement (assuming there is one)
Both key combinations can be used to cycle rapidly through all of  the code you’ve entered into IDLE, re-executing any code statements as needed.
Edit recalled code Once you recall your code statement, you can edit it and move around the statement using the arrow keys.
It’s possible to edit any statement that you’ve previously entered, even code statements that span multiple lines.
Adjust IDLE’s preferences IDLE’s preferences dialog lets you adjust its default behavior to your tastes.
You can control font and tab behavior, the colors used to syntax highlight, the behavior of  certain keycombinations, and IDLE’s start-up settings.
So, if  shocking pink strings is really your thing, IDLE gives you the power to change how your code looks on screen.
It might look a little different on yours, but not by much.
Unless you’re on a Mac, in which case it’s Ctrl-P and Ctrl-N.
Deal with complex data Any program of  any worth that you create has to work with data.
Other times, the data you have to work with is complex in its structure and meaning, forcing you to work hard to make sense of  it all, let alone write code to process it.
To tame complexity, you can often arrange your data as a list: there’s the list of  customers, your friend’s list, the shopping list, and your to-do list (to name a few)
Arranging data in lists is so common that Python makes it easy for you to create and process lists in code.
Let’s look at some complex data before learning how to create and process list data with Python.
I’ve been making lists of movie data for years and would love to be able to process it on my laptop...
On first glance, this collection of  data does indeed look quite complex.
However, the data appears to conform to some sort of  structure: there’s a line for a list of  basic movie facts, then another line for the lead actor(s), followed by a third line listing the movie’s supporting actors.
Create simple Python lists Let’s start with the following simple list of  movie titles and work up from there:
Here’s the same list written in a way that Python understands:
To turn the human-friendly list into a Python-friendly one, follow this fourstep process:
It’s perfectly OK to put your list creation code all on one line, assuming, of course, that you have room:
Convert each of  the names into strings by surrounding the data with quotes.1
Separate each of  the list items from the next with a comma.2
Surround the list of  items with opening and closing square brackets.3
Assign the list to an identifier (movies in the preceding code) using the assignment operator (=)
Hang on a second! Aren’t you forgetting something? Don’t you need to declare type information for your list?
Many other programming languages insist that every identifier used in code has type information declared for it.
Not so with Python: identifiers are simply names that refer to a data object of  some type.
The type of  the data items is not important to the list.
It’s OK to state that your movies list is a “collection of strings,” but Python doesn’t need to be told this.
All Python needs to know is that you need a list, you’ve given it a name, and the list has some data items in it.
Lists are like arrays When you create a list in Python, the interpreter creates an array-like data structure in memory to hold your data, with your data items stacked from the bottom up.
Each data item in the list has a numeric OFFSET associated with it.
Access list data using the square bracket notation As with arrays, you can access the data item in a list slot using the standard square bracket offset notation:
Use the “print()” BIF to display a data item on screen.
Let’s use IDLE to learn a bit about how lists work.
Lists in Python might look like arrays, but they are much more than that: they are full-blown Python collection objects.
This means that lists come with ready-to-use functionality in the form of list methods.
Open up IDLE and follow along with the code entered at the >>> prompt.
You should see exactly the same output as shown here.
Start by defining a list of names, which you then display on screen using the print() BIF.
Then, use the len() BIF to work out how many data items are in the list, before accessing and displaying the value of the second data item:
With your list created, you can use list methods to add a single data item to the end of your list (using the append() method), remove data from the end of your list (with the pop() method), and add a collection of data items to the end of your list (thanks to the extend() method):
Finally, find and remove a specific data item from your list (with the remove() method) and then add a data item before a specific slot location (using the insert() method):
It’s OK to invoke a BIF on the results of another BIF.
After all that, we end up with the cast of Monty Python’s Flying Circus!
Add more data to your list With your list of  movie names created, now you need to add more of  the movie buff ’s complex data to it.
I think I’ll use the appropriate list methods to add the extra data I need.
With something this small, I’m gonna simply re-create my list from scratch.
Which works best for you depends on what you are trying to do.
Let’s recall what the movie buff ’s data looks like:
The next piece of  data you need to add to your list is a number (which represents the year the movie was released), and it must be inserted after each movie name.
What?!? There’s no way you can mix data of different types in lists, is there? Surely this is madness?
It’s perfectly OK to mix strings with numbers within the same Python list.
In fact, you can mix more than just strings and numbers; you can store data of  any type in a single list, if  you like.
Recall that a Python list is a high-level collection, designed from the get-go to store a collection of  “related things.” What type those things have is of  little interest to the list, because the list exists merely to provide the mechanism to store data in list form.
So, if  you really need to store data of  mixed type in a list, Python won’t stop you.
Let’s take a bit of time to try to work out which strategy to use when adding data to your list in this case.
Work out the Python code required to insert the numeric year data into the preceding list, changing the list so that it ends up looking like this:
Now write the Python code required to re-create the list with the data you need all in one go:
In this case, which of these two methods do you think is best? (Circle your choice)
Let’s take a bit of time to try and work out which strategy to use when adding data to your list in this case.
You were to work out the Python code required to insert the numeric year data into the preceding list:
You were also to write the Python code required to recreate the list with the data you need all in one go:
Then append the last year to the end of the list.
Did you get the math right? After the first insertion, the list grows, so you have to take that into consideration when working out where to do the second insert.
Work with your list data You often need to iterate over your list and perform some action on each item as you go along.
Of  course, it is always possible to do something like this, which works but does not scale:
Define a list and populate its items with the names of two movies.
This code works as expected, making the data from the list appear on screen.
However, if  the code is later amended to add another favorite movie to the list, the list-processing code stops working as expected, because the list-processing code does not mention the third item.
Big deal: all you need to do is add another print() statement, right?
Yes, adding one extra print() statement works for one extra movie, but what if  you need to add another hundred favorite movies? The scale of  the problem defeats you, because adding all those extra print() statements becomes such a chore that you would rather find an excuse not to have to do.
It’s time to iterate Processing every list item is such a common requirement that Python makes it especially convenient, with the built-in for loop.
Consider this code, which is a rewrite of  the previous code to use a for loop:
Define a list and populate it just as you did before.
Using a for loop scales and works with any size list.
For loops work with lists of any size Python’s for loop exists to process lists and other iterations in Python.
Lists are the most common iterated data structure in Python, and when you need to iterate a list, it’s best to use for:
The keyword “for” indicates the start of the loop and comes before the target identifier.
The keyword “in” separates the target identifier from your list.
A colon “:” follows your list name and indicates the start of your list-processing code.
The list-processing code is referred to by Python programmers as the suite.
The target identifier is like any other name in your code.
As your list is iterated over, the target identifier is assigned each of  the data values in your list, in turn.
This means that each time the loop code executes, the target identifier refers to a different data value.
The loop keeps iterating until it exhausts all of  your list’s data, no matter how big or small your list is.
An alternative to using for is to code the iteration with a while loop.
Consider these two snippets of  Python code, which perform the same action:
When you use “while”, you have to worry about “state information,” which requires you to employ a counting identifier.
When you use “for”, the Python interpreter worries about the “state information” for you.
Q: So…when iterating over a list, I should always use for instead of while?
A: Yes, unless you have a really good reason to use (or need the extra control of) a while loop.
The for loop takes care of working from the start of your list and continuing to the end.
It’s next to impossible to get stung by an off-by-one error when you use for.
Q: So, lists aren’t really like arrays then, because they do so much more?
A: Well…they are in that you can access individual data items in your list with the standard square bracket notation, but—as you’ve seen—Python’s lists can do so much more.
At Head First Labs, we like to think of lists as “arrays on steroids.”
Q: And they work this way only in Python 3, right?
Q: Seeing as Python’s lists shrink and grow as needed, they must not support bounds-checking, right?
A: Well, lists are dynamic, in that they shrink and grow, but they are not magic, in that they cannot access a data item that does not exist.
If you try to access a nonexistent data item, Python responds with an IndexError, which means “out of bounds.”
Q: What’s with all the strange references to Monty Python?
A: Ah, you spotted that, eh? It turns out that the creator of Python, Guido van Rossum, was reading the scripts of the Monty Python TV shows while designing his new programming language.
When Guido needed a name for his new language, he chose “Python” as a bit of a joke (or so the legend goes)
Q: Do I need to know Monty Python in order to understand the examples?
A: No, but as they say in the official Python documentation: “it helps if you do.” But don’t worry: you’ll survive, even if you’ve never heard of Monty Python.
Q: I notice that some of your strings are surrounded with double quotes and others with single quotes.
The only rule is that if you start a string with one of the quotes, then you have to end it with the same quote; you can’t mix’n’match.
As you may have seen, IDLE uses single quotes when displaying strings within the shell.
Q: What if I need to embed a double quote in a string?
Q: Can I use any characters to name my identifiers?
A: Yes, Python is the “sensitive type,” in that Python code is case sensitive.
This means that msg and MSG are two different names, so be careful.
Python (and IDLE) will help with the problems that can occur as a result of this.
For instance, you can use an identifier in your code only if it has been given a value; unassigned identifiers cause a runtime error.
This means that if you type mgs when you meant msg, you’ll find out pretty quickly when Python complains about your code having a NameError.
Store lists within lists As you’ve seen, lists can hold data of  mixed type.
But it gets even better than that: lists can hold collections of  anything, including other lists.
Simply embed the inner list within the enclosing list as needed.
Looking closely at the movie buff ’s data, it is possible to determine a structure which looks much like a list of  lists:
There’s only one lead actor listed here, but there could be more.
In Python, you can turn this real list of  data into code with little or no effort.
All you need to remember is that every list is a collection of  items separated from each other with commas and surrounded with square brackets.
And, of course, any list item can itself  be another list:
This looks a little weird…until you remember that there are three opening square brackets, so there must also be three closing ones.
So, a list within a list is possible, as is a list within a list within a list (as this example code demonstrates)
In fact, it’s possible to nest lists within lists to most any level with Python.
And you can manipulate every list with its own list methods and access it with the square bracket notation:
But what happens when you try to process a list that contains another list (or lists) using the for loop from earlier in this chapter?
Begin by creating the list of the movie data for “The Holy Grail” in memory, display it on screen, and then process the list with your for loop:
The list within a list within a list has been created in memory.
The “for” loop prints each item of the outer loop ONLY.
The inner list within the inner list is printed “as-is.”
I think the trouble is that you haven’t told it what to do with any inner lists that it finds, so it just prints everything, right?
At the moment, the code within the loop simply prints each list item, and when it finds a list at a slot, it simply displays the entire list on screen.
After all, the inner list is just another list item as far as the outer enclosing list is concerned.
What’s we need here is some mechanism to spot that an item in a list is in fact another list and take the appropriate action.
Check a list for a list Each time you process an item in your list, you need to check to see if  the item is another list.
If  the item is a list, you need to process the nested list before processing the next item in your outer list.
Deciding what to do when in Python follows the familiar if...
The keyword “if” indicates the start of the decision code.
This code executes if the condition does NOT hold (i.e., it’s FALSE)
No surprises here, as the if statement in Python works pretty much as expected.
But what condition do you need to check? You need a way to determine if  the item currently being processed is a list.
Luckily, Python ships with a BIF that can help here: isinstance()
What’s cool about the isinstance() BIF is that it lets you check if  a specific identifier holds data of  a specific type:
Let’s use the IDLE shell to learn a little about how isinstance() works:
Create a short list and assign it to an identifier.
Your task is to rewrite this code using an if statement and the isinstance() BIF to process a list that displays another list.
Q: Over 70! How am I to remember that many, let alone find out what they all are?
Q: How? A: At the Python or IDLE shell, type dir(__builtins__) to see a list of the built-in stuff that comes with Python (that’s two leading and trailing underscore characters, by the way)
To find out what any BIF does—like input(), for example—type help(input) at the shell for a description of the BIFs function.
Q: Why so many BIFs? A: Why not? Because Python comes with lots of built-in functionality, it can mean less code for you to write.
This Python philosophy is known as “batteries included”: there’s enough included with Python to let you do most things well, without having to rely on code from third parties to get going.
As well as lots of BIFs, you’ll find that Python’s standard library is rich and packed with features waiting to be exploited by you.
Your task was to rewrite this code using an if statement and the isinstance() BIF to process a list that displays another list.
You need to check if the current item is a list.
If it is a list, use another “for” loop to process the nested list.
If the current item of the enclosing list isn’t a list, display it on screen.
Let’s use IDLE to see if this code makes a difference to the output displayed on screen:
This is a little better, but not by much…there’s another nested list here that’s not being processed properly.
Complex data is hard to process The movie buff ’s data is complex.
Let’s take another look at a subset of  the data and your Python code that processes it.
An inner, nested list Another inner (inner) , nested list.
Can you spot the problem with your Python code as it is currently written? What do you think needs to happen to your code to allow it to process the movie buff’s data correctly?
Handle many levels of nested lists The data and your code are not in sync.
The movie buff ’s data is a list that contains a nested list that itself  contains a nested list.
The trouble is that your code knows only how to process a list nested inside an enclosing list.
The solution, of  course, is to add more code to handle the additionally nested list.
By looking at the existing code, it’s easy to spot the code you need to repeat:
The repeated code replaces the “print()” statement and introduces another target identifier called “deeper_item”
Note: in this code, each “if” needs an associated “else”
I just love that...in fact, I love it so much I’ve decided to add another list to my data.
I want to include the other movies each supporting actor has starred in.
If I add the data, can you change your code to print this.
The data has to be embedded as another nested list within the already deeply nested list of  supporting actors.
That’s possible to do, even though it makes your head hurt just to think about a list of  lists of  lists of  lists! Amending your code is just a matter of  adding another for loop and an if statement.
Let’s use IDLE once more to test this latest iteration of your code:
It works! This time, you see all of your list data on screen.
I think I’d rather have a root canal than change that code again.
Your data is getting more complex (that mind-bending list of  lists of  lists of  lists) and, as a consequence, your code is getting overly complex, too (that brain-exploding for loop inside a for loop inside a for loop)
Wouldn’t it be dreamy if there were an efficient way to process lists, preferably using a technique that resulted in less code, not more? But I know it’s just a fantasy...
Don’t repeat code; create a function Take a look at the code that you’ve created so far, which (in an effort to save you from having your brain explode) has already been amended to process yet another nested list.
It’s also a mess to look at, even though it works with the movie buff ’s amended data.
All that nesting of  for loops is hard to read, and it’s even harder to ensure that the else suites are associated with the correct if statement.
There has to be a better way…but what to do?
When code repeats in this way, most programmers look for a way to take the general pattern of  the code and turn it into a reusable function.
Creating a reusable function lets you invoke the function as needed, as opposed to cutting and pasting existing code.
Create a function in Python A function in Python is a named suite of  code, which can also take an optional list of  arguments if  required.
You define a Python function using the def statement, providing a name for your function and specifying either an empty or populated argument list within parentheses.
A colon (:) follows the closing parenthesis and indicates the start of your functions code suite.
What does your function need to do? Your function needs to take a list and process each item in the list.
If  it finds a nested list within the first list, the function needs to repeat.
It can do this by invoking itself on the nested list.
In other words, the function needs to recurthat is, invoke itself from within the funtion code suite.
It takes one argument: a list to display on screen.
Grab your pencil and complete the code below to provide the required functionality:
You were to call the function that you’ll create print_lol()
It takes one argument: a list to display on screen.
You were to grab your pencil and complete the code to provide the required functionality:
If the item being processed is itself a list, invoke the function.
If the item being processed ISN’T a list, display the item on screen.
Let’s use IDLE one final time to test your new function.
It works, too! The recusrive function produces EXACTLY the same results as the earlier code.
Unlike the earlier code that needs to be amended to support additional nested lists (should the movie buff  require them), the recursive function does not need to change to process any depth of  nested lists properly.
Ah, yes, that’s terrific! I can now relax, knowing that your code can process my movie data.
What a great start! By taking advantage of  functions and recursion, you’ve solved the code complexity problems that had crept into your earlier list-processing code.
By creating print_lol(), you’ve produced a reusable chunk of  code that can be put to use in many places in your (and others) programs.
You’re well on your way to putting Python to work!
Your Python Toolbox You’ve got Chapter 1 under your belt and you’ve added some key Python goodies to your toolbox.
Run Python 3 from the command line or from within IDLE.
The identifiers have no “type,” but the data objects that they refer to do.
A list is a collection of data, separated by commas and surrounded by square brackets.
Lists can be used with BIFs, but also support a bunch of list methods.
Lists can hold any data, and the data can be of mixed type.
All of the memory used by your data is managed by Python for you.
The for loop lets you iterate a list and is often more convenient to use that an equivalent while loop.
The IDLE shell lets you experiment with your code as you write it.
Remember: when working with the shell, use Alt-P for Previous and use Alt-N for Next (but use Ctrl if you’re on a Mac)
I’d love to share...but how am I supposed to function without a module?
Reusable code is great, but a shareable module is better.
By sharing your code as a Python module, you open up your code to the entire Python.
Along the way, you’ll pick up a few new tricks relating to Python’s functions, too.
It’s too good not to share You’ve been showing your function to other programmers, and they like what they see.
You should make your function shareable, so that everyone can use it.
Yes, a function this good should be shared with the world.
Python provides a set of  technologies that make this easy for you, which includes modules and the distribution utilities:
The distribution utilities let you share your modules with the world.
Let’s turn your function into a module, then use the distribution utilities to share your module with the wider Python programming community.
Turn your function into a module A module is simply a text file that contains Python code.
The main requirement is that the name of  the file needs to end in .py: the Python extension.
To turn your function into a module, save your code into an appropriately named file:
Q: What’s the best Python editor? A: The answer to that question really depends on who you ask.
However, you can, of course, use any text editor to create and save your function’s code in a text file.
Something as simple as NotePad on Windows works fine for this, as does a full-featured editor such as TextMate on Mac OS X.
And there’s also full-fledged IDEs such as Eclipse on Linux, as well as the classic vi and emacs editors.
And, as you already know, Python comes with IDLE, which also includes a built-in code editor.
It might not be as capable as those other “real” editors, but IDLE is installed with Python and is essentially guaranteed to be available.
For lots of jobs, IDLE’s edit window is all the editor you’ll ever need when working with your Python code.
Check out WingIDE for one that specifically targets Python developers.
Modules are everywhere As might be expected, you’ll find Python modules in lots of  places.
I’m preloaded with lots of modules in the Python Standard Library...
If the Standard Library doesn’t do it for you, why not try the Web? I hear PyPI is where third-party Python modules hang out.
The Python Package Index (or PyPI for short) provides a centralized repository for third-party Python modules on the Internet.
When you are ready, you’ll use PyPI to publish your module and make your code available for use by others.
And your module is ready, but for one important addition.
If you are already familiar with Perl’s CPAN repository, you can think of PyPI as the Python equivalent.
Comment your code It’s always a good idea to include comments with your code.
As your plan to share your module with the world, well-written comments help to document your work.
In Python, a common commenting technique is to use a triple quote for multiple-line comments.
When you use a triple quote without assigning it to a variable, everything between the triple quotes is considered a comment:
Hello! I’m a big string who just happens to be a Python comment, too.
Here is your module code (which is saved in the file nester.py)
In the spaces provided, use your pencil to compose two comments: the first to describe the module and the second to describe the function.
Here is your module code (which is saved in the file nester.py)
In the spaces provided, you were asked to use your pencil to compose two comments: the first to describe the module and the second to describe the function.
There are no changes to the actual code here; you’re just adding some comments.
Q: How do I know where the Python modules are on my computer?
Type import sys; sys.path (all on one line) into the IDLE prompt to see the list of locations that your Python interpreter searches for modules.
I can use “;” to put more than one line of code on the same line in my Python programs?
Better to give each Python statement its own line; it makes your code much easier for you (and others) to read.
Q: Does it matter where I put my nester.py module?
Just be sure to put it somewhere where you can find it later.
In a while, you’ll install your module into your local copy of Python, so that the interpreter can find it without you having to remember when you actually put it.
Q: So comments are like a funnylooking string surrounded by quotes?
When a triple-quoted string is not assigned to a variable, it’s treated like a comment.
The comments in your code are surrounded by three double quotes, but you could have used single quotes, too.
Q: Is there any other way to add a comment to Python code?
A lot of Python programmers use the “#” symbol to quickly switch on and off a single line of code when testing new functionality.
Now that you’ve added your comments and created a module, let’s test that your code is still working properly.
Rather than typing your function’s code into IDLE’s prompt, bring the nester.py file into IDLE’s edit window, and then press F5 to run the module’s code:
Nothing appears to happen, other than the Python shell “restarting” and an empty prompt appearing:
What’s happened is that the Python interpreter has reset and the code in your module has executed.
The code defines the function but, other than that, does little else.
The interpreter is patiently waiting for you to do something with your newly defined function, so let’s create a list of lists and invoke the function on it:
The data in the list of lists is displayed on screen.
Prepare your distribution In order to share your newly created module, you need to prepare a distribution.
This is the Python name given to the collection of  files that together allow you to build, package, and distribute your module.
Once a distribution exists, you can install your module into your local copy of  Python, as well as upload your module to PyPI to share with the world.
Follow along with the process described on these two pages to create a distribution for your module.
Follow along with each of the steps described on these pages.
By the time you reach the end, your module will have transformed into a Python distribution.
With the folder created, copy your nester.py module file into the folder.
Build your distribution You now have a folder with two files in it: your module’s code in nester.py and metadata about your module in setup.py.
A collection of status messages appears on screen, confirming the creation of your distribution.
Another bunch of status messages appear on screen, confirming the installation of your distribution.
The distribution utilities include all of  the smarts required to build a distribution.
Open a terminal window within your nester folder and type a single command: python3 setup.py sdist.
Staying in the terminal, type this command: sudo python3 setup.py install.
A quick review of your distribution Thanks to Python’s distribution utilities, your module has been transformed into a distribution and installed into your local copy of  Python.
You started with a single function, which you entered into a file called nester.py, creating a module.
You then created a folder called nester to house your module.
The addition of  a file called setup.py to your folder allowed you to build and install your distribution, which has resulted in a number of  additional files and two new folders appearing within your nester folder.
These files and folders are all created for you by the distribution utilities.
A list of files in your distribution is in this file.
A “compiled” version of your code is in this file.Your metadata is in this file.
Import a module to use it Now that your module is built, packaged as a distribution, and installed, let’s see what’s involved in using it.
To use a module, simply import it into your programs or import it into the IDLE shell:
Note: you don’t need to include the “.py” extension when naming your module.
The import statement tells Python to include the nester.py module in your program.
From that point on, you can use the module’s functions as if they were entered directly into your program, right? Well…that’s what you might expect.
Write a small program that imports your newly created module, defines a small list called “cast,” and then uses the function provided by your module to display the contents of the list on screen.
Open your program in IDLE’s edit window, and then press F5 to execute your code.
You were to write a small program that imports your newly created module, defines a small list called “cast,” and then uses the function provided by your module to display the contents of the list on screen.
Open your program in IDLE’s edit window, and then press F5 to execute your code.
With your program in the IDLE edit window, pressing F5 (or choosing Run Module from the Run menu) does indeed cause problems:
Your program does not appear to have executed and an error message is reported:
Python’s modules implement namespaces All code in Python is associated with a namespace.
Code in your main Python program (and within IDLE’s shell) is associated with a namespace called __main__
When you put your code into its own module, Python automatically creates a namespace with the same name as your module.
So, the code in your module is associated with a namespace called nester.
I guess namespaces are like family names? If someone is looking for Chris, we need to know if it’s Chris Murray or Chris Larkin, right? The family name helps to qualify what we mean, as do namespace names in Python.
When you want to refer to some function from a module namespace other than the one you are currently in, you need to qualify the invocation of  the function with the module’s namespace name.
The format for namespace qualification is: the module’s name, followed by a period, and then the function name.
The function is then invoked as normal, with “cast” provided as the list to process.
A period separates the module namespace name from the function name.
That’s a double underscore in front of the word “main” and after it.
Staying at the IDLE shell, import your module, create the list, and then try to invoke the function without a qualifying name.
As expected, your code has caused a NameError, because you didn’t qualify the name.
When you qualify the name of the function with the namespace, things improve dramatically:
This time, things work as expected…the data items in the list are displayed on screen.
When you use a plain import statement, such as import nester, the Python interpreter is instructed to allow you to access nester’s functions using namespace qualification.
If you already have a function called print_lol defined in your current namespace, the specific import statement overwrites your function with the imported one, which might not be the behavior you want.
Register with the PyPI website In order to upload your distribution to PyPI, you need to register with the PyPI website.
Begin by surfing over to the PyPI website at http://pypi.python.org/ and requesting a PyPI ID:
Don’t try to use “hfpython,” because that Username is already taken.
Don’t forget to click the “I agree” checkbox before clicking on the Register button.
If  all of  your registration details are in order, a confirmation message is sent to the email address submitted on the registration form.
The email message contains a link you can click to confirm your PyPI registration:
Click the confirmation link to complete your PyPI registration.You are now registered with PyPI.
Upload your code to PyPI You’re ready to rock! The code in your function has been placed in a module, used to create a distribution and installed into your local copy of  Python.
To upload your distribution to PyPI, complete these two steps: command-line registration with PyPI and command-line uploading.
It might seem strange to have to register with PyPI again, seeing as you just did this with their website.
However, the command-line uploading tool needs to be made aware of  your PyPI Username and Password, and that’s what this registration does.
With your registration details entered and saved, you are now ready to upload your distribution to PyPI.
Confirm that you want to use your just-created PyPI credentials.
Use your PyPI settings and save them for future use.
Welcome to the PyPI community Congratulations! You are now a full-fledged, card-carrying member of  the PyPI community.
Your distribution has joined the over 10,000 other uploads on PyPI.
Feel free to surf  on over to the PyPI website to confirm the upload.
Programmers from all over the globe are now able to download, unpack, and install your module into their local copy of  Python, which is pretty cool when you think about it.
Sit back, put your feet up, and wait for the plaudits to begin…
You’ve now written and published your code… how cool is that?
Most programmers mix and match based on their own personal preference and taste (although there are plenty of programmers willing to argue that their preferred way is the “one true way”)
Note that the from module import function form pollutes your current namespace: names already defined in your current namespace are overwritten by the imported names.
Q: And when I press F5 in IDLE’s edit window, it’s as if the module’s code is imported with an import statement, right?
The code in your edit window is compiled and executed by Python, and any names in the edit window are imported into the namespace being used by IDLE’s shell.
This is handy, because it makes it easy to test functionality with IDLE.
But bear in mind that outside of IDLE, you still need to import your module before you can use its functionality.
Q: Is it really necessary for me to install my modules into my local copy of Python? Can’t I just put them in any old folder and import them from there?
Just bear in mind that Python looks for modules in a very specific list of places (recall the import sys; sys.path trick from earlier in this chapter)
If you put your modules in a folder not listed in Python’s path list, chances are the interpreter won’t find them, resulting in ImportErrors.
Using the distribution utilities to build and install your module into your local copy of Python avoids these types of errors.
Q: I noticed the distribution utiliites created a file called nester.pyc.
When the interpreter executes your module code for the first time, it reads in the code and translates it into an internal bytecode format which is ultimately executed.
This idea is very similar to the way the Java JVM works: your Java code is turned into a class file as.
The Python interpreter is smart enough to skip the translation phase the next time your module is used, because it can determine when you’ve made changes to the original module code file.
If your module code hasn’t changed, no translation occurs and the “compiled” code is executed.
If your code has changed, the translation occurs (creating a new pyc file) as needed.
The upshot of all this is that when Python sees a pyc file, it tries to use it because doing so makes everything go much faster.
So I can just provide my users with the pyc file?
A: No, don’t do that, because the use of the pyc file (if found) is primarily a runtime optimization performed by the interpreter.
Q: So, can I delete the pyc file if I don’t need it?
Just be aware that you lose any potential runtime optimization.
With success comes responsibility Lots of  programmers from many different locations are using your module.
And some of  these programmers are looking for more features.
We really love your code, but is there any chance this thing could print the data to screen and indent each nested list whenever one is found?
Requests for change are inevitable You need to keep your current users happy by maintaining the existing functionality, while at the same time providing enhanced functionality to those users that require it.
Any changes to the way your function works are likely to annoy this guy.
Life’s full of choices When it comes to deciding what to do here, there’s no shortage of  suggestions.
Simply create another function called “print_lol2”, right? You could then import the function you want using the specific form of the import statement.
When you want to use the new, improved version of  the function, use this import statement: from nester import print_lol2
But that suggestion is twice the work...which might be OK.
Not only are you introducing an almost identical function to your module, which might create a potential maintenance nightmare, but you’re also making things much more difficult for the users of  your module, who must decide ahead of  time which version of  the function they need.
Adding a second function makes your module’s application programming interface (API) more complex than it needs to be.
Control behavior with an extra argument If  you add an extra argment to your function, you can handle indentation within your current code without too much trouble.
Of course, it’s clear to me now: adding another argument to your function gives you options.
Take your function to the next level At the moment, your function has a single argument: the_list.
If  you add a second argument called level, you can use it to control indentation.
A positive value for level indicates the number of  tab-stops to include when displaying a line of  data on screen.
It’s clear you are looking at some sort of  looping mechanism here, right? You already know how to iterate over a variably sized list, but how do you iterate a fixed number of  times in Python?
Before your write new code, think BIF When you come across a need that you think is generic, ask yourself  if  there’s a built-in function (BIF) that can help.
After all, iterating a fixed number of times is something you’ll need to do all the time.
Use your pencil to draw a line matching each BIF to the correct description.
Once you have all your lines drawn, circle the BIF you think you need to use in the next version of  your function.
You were to use your pencil to draw a line matching each BIF to the correct description.
Once you had all your lines drawn, you were to circle the BIF you think you need to use in the next version of  your function.
This is the "nester.py" module and it provides one function called print_lol()
Now that you know a bit about the range() BIF, amend your function to use range() to indent any nested lists a specific number of tab-stops.
Hint: To display a TAB character on screen using the print() BIF yet avoid taking a new-line (which is print()’s default behavior), use this Python code: print("\t", end='')
Add code here to take the required number of tab-stops.
Q:Don’t I need to import the BIFs in order to use them in my program?
For all intents and purposes, the BIFs are specifically imported into every Python program as well as IDLE.
Q: So the BIFs must belong to the __main__ namespace, right?
Q: I get how range() works, but surely I could just as easily use a while loop to do the same thing?
A: Yes, you can, but it’s not as elegant as using range()
Seriously, though, the while equivalent not only requires you to write more code, but it also makes it your responsibility to worry about loop state, whereas range() worries about this for you.
As a general rule, Python programmers look for ways to reduce the amount of code they need to write and worry about, which leads to better code robustness, fewer errors, and a good night’s sleep.
Q: So BIFs are actually good for me? A: BIFs exist to make your programming experience as straightforward as possible by providing a collection of functions that provide common solutions to common problems.
Since they are included with Python, you are pretty much assured that they have been tested to destruction and do “exactly what it says on the tin.” You can depend on the BIFs.
Using them gives your program a leg up and makes you look good.
This is the "nester.py" module and it provides one function called print_lol()
Now that you know a bit about the range() BIF, you were to amend your function to use range() to indent any nested lists a specific number of tab-stops.
Hint: To display a TAB character on screen using the print() BIF yet avoid taking a new-line (which is print()’s default behavior), use this Python code: print("\t", end='')
Use the value of “level” to control how many tab-stops are used.
It’s time to test the new version of your function.
Load your module file into IDLE, press F5 to import the function into IDLE’s namespace, and then invoke the function on your movies list with a second argument:
Invoke your function, being sure to provide a second argument.
Your code has a TypeError, which caused it to crash.
Python tries its best to run your code Unlike compiled languages (such as C, Java, C#, and others), Python doesn’t completely check the validity of  your code until it runs.
This allows Python to do some rather cool things that just aren’t possible in those other languages, such as dynamically defining functions at runtime.
The cost to you, however, is that you need to be very careful when writing your code, because something that typically would be caught and flagged as an “error” by a traditional, statically typed, compiled language often goes unnoticed in Python.
You are planning to do that, right? Please don’t disappoint me, or I’ll give.
Take another look at the error on the opposite page.
Why do you think Python is giving you this particular error? What do you think is wrong?
Trace your code When you’re trying to work out what went wrong with a program that looks like it should be OK, a useful technique is to trace what happens as each line of  code executes.
At only three lines long (remember: the creation of  the list is one line of  code), it doesn’t look like it should cause any trouble:
With the data assigned to the function’s arguments, the function’s code starts to execute on each data item contained within the passed-in list:
If the data item is a list, recursively invoke the function…hang on a second, that doesn’t look right!?
Work out what’s wrong There’s your problem: the recursive invocation of  your function is using the old function signature that required only one argument.
The fix is easy: provide the correct number of  arguments when calling the new version of  your function.
Surely the nested list needs to be printed after a specific number of tab-stops? At the moment, your code sets “level” to 0 but never changes the value, so “level” never has any impact on your.
The whole point of  having level as an argument is to allow you to control the nested output.
Simply increment the value of level by 1 ea ch.
Update PyPI with your new code Go ahead and edit your nester.py module (in the nester folder) to invoke your function properly.
Now that you have a new version of  your module, it’s a good idea to update the distribution that you uploaded to PyPI.
With your code amended, there’s also a small change needed to your distribution’s setup.py program.
You’ve changed your API, so adjust the value associated with version in setup.py.
Just as you did when you created and uploaded your distribution, invoke the setup.py program within your distribution folder to perform the upload:
Change the value associated with “version” to indicate to PyPI that this is indeed a new version.
Mark: Take a look at this, guys…the nester module has been updated on PyPI.
Mark: It still works with nested lists of  lists, but now you can see the nested structure on screen, which I think is pretty cool.
Bob: Eh…OK…but how do I upgrade my existing local copy?
Mark: Just follow the same steps as when you downloaded and installed nester from PyPI the first time.
Bob: So I download the package file, unpack it, and ask setup.py to install it into my Python for me?
Laura: And what about my existing version of  nester; what happens to that “old” version?
When you use setup.py to install the latest version it becomes the current version and effectively replaces the previous module, which was the 1.0.0 release.
Bob: And PyPI knows to give you the latest version of  the module, too, right?
Mark: Yes, when you surf  the PyPI website and search for nester, you are always provided with the latest version of  the module.
Laura: Well, I use this module all the time and I’ve been waiting for this feature.
Mark: I’ve already upgraded mine, and it works a treat.
Bob: Yeah, I use it a lot, too, so I guess I’ll keep my system up to date and install the latest version.
It’s probably not a good idea to rely on out-of-date software, right?
Laura: Catch you later, guys, I’ve got work to do.
I’m off  to PyPI to grab the latest nester and install it into my local copy of  Python.
I’ll give it a quick test to confirm all is OK.
You’ve changed your API Your new version of  nester is indeed better, but not for all your users.
I installed the latest version of “nester” from PyPI, and now all of my code that uses your function is not working.
In your rush to release the lates and greatest version of  your module, you forgot about some of  your existing users.
Recall that not all of  your users want the new nested printing feature.
However, by adding the second argument to print_lol(), you’ve changed your function’s signature, which means your module has a different API.
Anyone using the old API is going to have problems.
The ideal solution would be to provide both APIs, one which switches on the new feature and another that doesn’t.
Use optional arguments To turn a required argument to a function into an optional argument, provide the argument with a default value.
When no argument value is provided, the default value is used.
When an argument value is provided, it is used instead of the default.
The key point is, of  course, that the default value for the argument effectively makes the argument optional.
To provide a default value for any function argument, specify the default value after the argument name:
The addition of a default value has turned “level” into an OPTIONAL argument.
With the default value for the argument defined, you can now invoke the function in a number of  different ways:
Invoke the function with one argument and use the default value for the second.Invoke the function with both arguments, but provide an alternative starting value for the second argument.
Your function now supports different signatures, but the functonality remains as it was.
Amend your code to give the level argument a default value of 0 and then load your code into the IDLE editor.
Press F5 to load the code into the shell and then follow along to confirm that the latest version of your function works as expected.
Start be defining a short list of lists and use the function to display the the list on screen:
Now try to do the same thing without specifiying the second argument.
Now specify a value for the second argument and note the change in the function’s behavior:
One final example provides what looks like a silly value for the second argument.
The standard behavior works as expected, with nested lists indented.
Specify an alternative value for the second argument and the indenting starts from that level.
Using a negative value effectively switches OFF the indenting, as the.
Let’s take a moment to create and upload a new distibution for PyPI.
As before, let’s amend the version setting in the setup.py program:
Once again, be sure to change the value associated with “version” in “setup.py”
And with the code changes applied, upload this new version of  your distribution to PyPI:
Success! The messages from setup.py confirm that the your latest version of  nester is up on PyPI.
How might some of your users still have a problem with this version of your code?
Your API is still not right Although the API lets your users invoke the function in its original form, the nesting is switched on by default.
This behavior is not required by everyone and some people aren’t at all happy.
I can’t believe it! My programs were back to running fine, but now everything is indented.
Of  course, if  you have some functionality that really ought to be optional (that is, not the default), you should adjust your code to make it so.
One solution is to add a third argument which is set to True when the indenting is required and False otherwise.
If  you ensure that this argument is False by default, the original functonality becomes the default behavior and users of  your code have to request the new indenting feature explicitly.
Amend your module one last time to add a third argument to your function.
Call your argument indent and set it initially to the value False—that is, do not switch on indentation by default.
In the body of your function, use the value of indent to control your indentation code.
Note: to save a bit of space, the comments from the module are not shown here.
Of course, you need to make the necessary adjustments to your comments to keep them in sync with your code.
With your new code additions in place, provide the edit you would recommend making to the setup.py program prior to uploading this latest version of your module to PyPI:
Provide the command you would use to upload your new distribution to PyPI:
Add a line of code to control when indenting occurs.
You were to amend your module one last time to add a third argument to your function.
You were to call your argument indent and set it initially to the value False—that is, do not switch on indentation by default.
In the body of your function, you were to use the value of indent to control your indentation code.
With your new code additions in place, you were to provide the edit you would recommend making to the setup.py program prior to uploading this latest version of your module to PyPI:
You were to provide the command you would use to upload your new distribution to PyPI:
It’s a new version of your module, so be sure to change the value associated with “version” in your “setup.py” file.
A final test of the functonality should convince you that your module is now working exactly the way you and your users want it to.
Next, turn on indentation by providing True as the second argument:
And, finally, control where indentation begins by providing a third argument value:
Go ahead and edit your setup.py file; then upload your distribution to PyPI.
The original, default functionality is restored (that should please Bob)
By providing a second argument, it’s possible to switch on indented output (keeping Laura happy)
Your module’s reputation is restored Congratulations! Word of  your new and improved module is spreading fast.
Great work! I love that I can switch indentation on and off.
My programs are back to working the way I want them to, so I’m a happy guy.
Your Python skills are starting to build You’ve created a useful module, made it shareable, and uploaded it to the PyPI website.
Programmers all over the world are downloading and using your code in their projects.
Your Python Toolbox You’ve got Chapter 2 under your belt and you’ve added some key Python goodies to your toolbox.
A module is a text file that contains Python code.
The distribution utilities let you turn your module into a shareable package.
The setup.py program provides metadata about your module and is used to build, install, and upload your packaged distribution.
Import your module into other programs using the import statement.
Each module in Python provides its own namespace, and the namespace name is used to qualify the module’s functions when invoking them using the module.
Specifically import a function from a module into the current namespace using the from module import function form of the import statement.
Use # to comment-out a line of code or to add a short, one-line comment to your program.
The built-in functions (BIFs) have their own namespace called __builtins__, which is automatically included in every Python program.
The range() BIF can be used with for to iterate a fixed number of times.
Including end=’’ as a argument to the print() BIF switches off its automatic inclusion of a new-line on output.
Arguments to your functions are optional if you provide them with a default value.
Use a “triple-quoted string” to include a multiple-line comment in your code.
A “namespace” is a place in Python’s memory where names exist.
Press F5 to “run” the code in the IDLE edit window.
When you press F5 to “load” a module’s code into the IDLE shell, the module’s names are specifically imported into IDLE’s namespace.
Within your code, you need to use the import statement explicitly.
It’s simply not enough to process your list data in your code.
You need to be able to get your data into your programs with ease, too.
I’m ready for your data...just give it to me, baby!
So far, you’ve learned how to process data as well as display it on screen.
But what’s involved in getting data into your programs? Specifically, what’s involved in reading data from a file?
It’s all lines of text The basic input mechanism in Python is line based: when read into your program from a text file, data arrives one line at a time.
When combined with a for statement, reading files is straightforward.
Create a folder called HeadFirstPython and a subfolder called chapter3
With the folders ready, download sketch.txt from the Head First Python support website and save it to the chapter3 folder.
When you use the open() BIF to access your data in a file, an iterator is created to feed the lines of  data from your file to your code one line at a time.
Let’s use IDLE to get a feel for Python’s file-input mechanisms.
Start a new IDLE sesson and import the os module to change the current working directory to the folder that contains your just-downloaded data file:
This code should look familiar: it’s a standard iteration using the file’s data as input.
Now, open your data file and read the first two lines from the file, displaying them on screen:
Let’s “rewind” the file back to the start, then use a for statement to process every line in the file:
Open a named file and assign the file to a file object called “data”
Use the “readline()” method to grab a line from the file, then use the “print()” BIF to display it on screen.
Use the “seek()” method to return to the start of the file.
And yes, you can use “tell()” with Python’s files, too.
Every line of the data is displayed on screen (although for space reasons, it is abridged here)
Since you are now done with the file, be sure to close it.
Take a closer look at the data Look closely at the data.
The split() method returns a list of  strings, which are assigned to a list of target identifiers.
With this format in mind, you can process each line to extract parts of  the line as required.
Let’s confirm that you can still process your file while splitting each line.
Man said:  Is this the right room for an argument?
Other Man said:  Oh I'm sorry, is this a five minute argument, or the full half hour?
Man said:  Ah! (taking out his wallet and paying) Just the five minutes.
It’s a ValueError, so that must mean there’s something wrong with the data in your file, right?
Know your data Your code worked fine for a while, then crashed with a runtime error.
The problem occurred right after the line of  data that had the Man saying, “You most certainly did not!”
Let’s look at the data file and see what comes after this successfully processed line:
Other Man: Oh I'm sorry, is this a five minute argument, or the full half hour?
Man: Ah! (taking out his wallet and paying) Just the five minutes.
Other Man: Now let's get one thing quite clear: I most definitely told you!
The next line of  data has two colons, not one.
This is enough extra data to upset the split() method due to the fact that, as your code currently stands, split()expects to break the line into two parts, assigning each to role and line_spoken, respectively.
When an extra colon appears in the data, the split() method breaks the line into three parts.
Your code hasn’t told split() what to do with the third part, so the Python interpreter raises a ValueError, complains that you have “too many values,” and terminates.
What approach might you take to solve this dataprocessing problem?
To help diagnose this problem, let’s put your code into its own file called sketch.py.
You can copy and paste your code from the IDLE shell into a new IDLE edit window.
Know your methods and ask for help It might be useful to see if  the split() method includes any functionality that might help here.
You can ask the IDLE shell to tell you more about the split() method by using the help() BIF.
Return a list of the words in S, using sep as the.
The optional argument to split() controls how many breaks occur within your line of  data.
By default, the data is broken into as many parts as is possible.
But you need only two parts: the name of  the character and the line he spoke.
If  you set this optional argument to 1, your line of  data is only ever broken into two pieces, effectively negating the effect of  any extra colon on any line.
Man said:  Is this the right room for an argument?
Other Man said:  Now let's get one thing quite clear: I most definitely told you!
With the edit applied and saved, press F5 (or select Run Module from IDLE’s Run menu) to try out this version of your code:
The displayed output is abridged to allow the important stuff to fit on this page.
Know your data (better) Your code has raised another ValueError, but this time, instead of complaining that there are “too many values,” the Python interpreter is complaining that it doesn’t have enough data to work with: “need more than 1 value to unpack.” Hopefully, another quick look at the data will clear up the mystery of  the missing data.
Other Man: Now let's get one thing quite clear: I most definitely told you!
What’s this?!? Some of the data doesn’t conform to the expected format…which can’t be good.
The case of the missing colon Some of  the lines of  data contain no colon, which causes a problem when the split() method goes looking for it.
The lack of  a colon prevents split() from doing its job, causes the runtime error, which then results in the complaint that the interpreter needs “more than 1 value.”
It looks like you still have problems with the data in your file.
When you have to deal with a bunch of exceptional situations, the best approach is to add extra logic.
If there’s more stuff to worry about, you need more code.
Or you could decide to let the errors occur, then simply handle each error if and when it happens.
Jill’s suggested approach certainly works: add the extra logic required to work out whether it’s worth invoking split() on the line of  data.
All you need to do is work out how to check the line of  data.
Joe’s approach works, too: let the error occur, spot that it has happened, and then recover from the runtime error…somehow.
Add extra logic Let’s try each approach, then decide which works best here.
In addition to the split() method, every Python string has the find() method, too.
You can ask find() to try and locate a substring in another string, and if  it can’t be found, the find() method returns the value -1
If the method locates the substring, find() returns the index position of  the substring in the string.
Assign a string to the each_line variable that does not contain a colon, and then use the find() method to try and locate a colon:
Press Alt-P twice to recall the line of code that assigns the string to the variable, but this time edit the string to include a colon, then use the find() method to try to locate the colon:
The string does NOT contain a colon, so “find()” returns -1 for NOT FOUND.
The string DOES contain a colon, so “find()” returns a positive index value.
And you thought this approach wouldn’t work? Based on this IDLE session, I think this could do the trick.
Adjust your code to use the extra logic technique demonstrated on the previous page to deal with lines that don’t contain a colon character.
Can you think of any potential problems with this technique? Grab your pencil and write down any issues you might have with this approach in the space provided below:
You were to adjust your code to use the extra logic technique to deal with lines that don’t contain a colon character:
You were to think of any potential problems with this technique, grabbing your pencil to write down any issues you might have with this approach.
There might be a problem with this code if the format of the data file changes, which will require changes to the condition.
The condition used by the if statement is somewhat hard to read and understand.
This code is a little “fragile”…it will break if another exceptional situation arises.
It takes a few seconds to get your head around this condition, but it does work.
Note the use of the “not” keyword, which negates the value of the condition.
Test Drive Amend your code within IDLE’s edit window, and press F5 to see if it works.
If  the format of  the file changes, your code will need to change, too, and more code generally means more complexity.
Adding extra logic to handle exceptional situations works, but it might cost you in the long run.
Maybe it’s time for a different approach? One that doesn’t require extra logic, eh?
Handle exceptions Have you noticed that when something goes wrong with your code, the Python interpreter displays a traceback followed by an error message?
The traceback is Python’s way of  telling you that something unexpected has occurred during runtime.
Of  course, if  you decide to ignore an exception when it occurs, your program crashes and burns.
But here’s the skinny: Python let’s you catch exceptions as they occur, which gives you with a chance to possibly recover from the error and,  critically, not crash.
By controlling the runtime behavior of  your program, you can ensure (as much as possible) that your Python programs are robust in the face of  most runtime errors.
Try first, then recover Rather than adding extra code and logic to guard against bad things happening, Python’s exception handling mechanism lets the error occur, spots that it has happened, and then gives you an opportunity to recover.
During the normal flow of  control, Python tries your code and, if  nothing goes wrong, your code continues as normal.
During the exceptional flow of  control, Python tries your code only to have something go wrong, your recovery code executes, and then your code continues as normal.
The try/except mechanism Python includes the try statement, which exists to provide you with a way to systematically handle exceptions and errors at runtime.
The general form of the try statement looks like this:
Hang on, here! Are you actually letting errors occur on purpose? ARE YOU MAD?!?
If  you try to code for every possible error, you’ll be at it for a long time, because all that extra logic takes a while to work out.
Paradoxically, when you worry less about covering every possible error condition, your coding task actually gets easier.
Identify the code to protect In order to plug into the Python exception handling mechanism, take a moment to identify the code that you need to protect.
Study your program and circle the line or lines of code that you think you need to protect.
When the split() method executes, it passes back a list, but the target identifiers are enclosed in regular brackets, not square brackets, so how is this a list?
It turns out that there are two types of list in Python: those that can change (enclosed in square brackets) and those that cannot be changed once they have been created (enclosed in regular brackets)
The latter is an immutable list, more commonly referred to as a tuple.
Think of tuples as the same as a list, except for one thing: once created, the data they hold cannot be changed under any circumstances.
Another way to think about tuples is to consider them to be a constant list.
You were to study your program and circle the line or lines of code that you think you need to protect.
Then, in the space provided, you were to state why.
These four lines of code all need to be protected.
If the call to “split()” fails, you don’t want the three “print()” statements executing, so it’s best to protect all four lines of the “if” suite, not just the line of code that calls “split()”
I get that the code can be protected from an error.
But what do I do when an error actually occurs?
It’s probably best to ignore it, right? I wonder how...
Take a pass on the error With this data (and this program), it is best if  you ignore lines that don’t conform to the expected format.
If  the call to the split() method causes an exception, let’s simply pass on reporting it as an error.
Now, no matter what happens when the split() method is invoked, the try statement catches any and all exceptions and handles them by ignoring the error with pass.
Make the required changes to your code in the IDLE edit window.
With your code in the IDLE edit window, press F5 to run it.
Man said:  Is this the right room for an argument?
This code works, and there are no runtime errors, either.
Tonight’s talk: Approaching runtime errors with extra code and exception handlers.
By making sure runtime errors never happen, I keep my code safe from tracebacks.
You’re more than happy for your code to explode in your face…then you decide it’s probably a good idea to put out the fire?!?
They never happen with me, because I don’t let them.
If  you’re smart enough—and, believe me, I am—you can think up all the possible runtime problems and code around them.
Of  course all my code is needed! How else can you code around all the runtime errors that are going to happen?
I’ll be sure to remind you of  that the next time you’re debugging a complex piece of  code at 4 o’clock in the morning.
I concentrate on getting my work done first and foremost.
Sounds like a whole heap of  extra work to me.
You don’t know, do you? You’ve no idea what will happen when an unknown or unexpected runtime error occurs, do you?
What about other errors? It is true that both approaches work, but let’s consider what happens when other errors surface.
How does you code react when the data file is deleted?
I guess that’ll produce another exception, but what happens in my code is anyone’s guess.
Handling missing files Frank’s posed an interesting question and, sure enough, the problem caused by the removal of the data file makes life more complex for Jill and Joe.
When the data file is missing, both versions of the program crash with an IOError.
Rename the data file, then run both versions of  your program again to confirm that they do indeed raise an IOError and generate a traceback.
Add more error-checking code… If  you’re a fan of  the “let’s not let errors happen” school of  thinking, your first reaction will be to add extra code to check to see if  the data file exists before you try to open it, right?
Python’ s os module has some facilities that can help determine whether a data file exists, so we need to import it from the Standard Library, then add the required check to the code:
A quick test of the code confirms that this new problem is dealt with properly.
With this new version of your code in IDLE’s edit window, press F5 to confirm all is OK.
Or add another level of exception handling If  you are a fan of  the “handle exceptions as they occur” school of  thinking, you’ll simply wrap your code within another try statement.
As with the other program, all of this code remains unchanged.
Another quick test is required, this time with the version of your program that uses exception handling.
As expected, this version of the program handles the missing file, too.
So, which approach is best? Well…it depends on who you ask! Here are both versions of  your code:
This version uses extra logic to handle File I/O errors.
This version uses another “try” statement to handle File I/O errors.
Let’s ask a simple question about these two versions of  your program: What do each of  these programs do?
In box 1, write down what you think the program on the left does.
In box 2, write down what you think the program on the right does.
Complexity is rarely a good thing Do you see what’s happening here?
As the list of  errors that you have to worry about grows, the complexity of the “add extra code and logic” solution increases to the point where it starts to obscure the actual purpose of  the program.
This is not the case with the exceptions handling solution, in which it’s obvious what the main purpose of  the program is.
By using Python’s exception-handling mechanism, you get to concentrate on what your code needs to do, as opposed to worrying about what can go wrong and writing extra code to avoid runtime errors.
Prudent use of  the try statement leads to code that is easier to read, easier to write, and—perhaps most important—easier to fix when something goes wrong.
The code on the right starts by importing the “os” library, and then it uses “path.exists” to make sure the data file exists, before it attempts to open the data file.
Each line from the file is then processed, but only after it has determined that the line conforms to the required format by checking first for a single “:” character in the line.
If the “:” is found, the line is processed; otherwise, it’s ignored.
And you get a friendly message at the end  if the file is not found.
The code on the right opens a data file, processes each line in that file, extracts the data of interest and displays it on screen.
You were to grab your pencil, then in box 1, write down what you thought the program on the left does.
In box 2, write down what you thought the program on the right does.
You’re done…except for one small thing Your exception-handling code is good.
In fact, your code might be too good in that it is too general.
At the moment, no matter what error occurs at runtime, it is handled by your code because it’s ignored or a error message is displayed.
But you really need to worry only about IOErrors and ValueErrors, because those are the types of  exceptions that occurred earlier when your were developing your program.
Although it is great to be able to handle all runtime errors, it’s probably unwise to be too generic…you will want to know if  something other than an IOError or ValueError occurs as a result of  your code executing at runtime.
If  something else does happen, your code might be handling it in an inappropriate way.
As your code is currently written, it is too generic.
Any runtime error that occurs is handled by one of  the except suites.
This is unlikely to be what you want, because this code has the potential to silently ignore runtime errors.
You need to somehow use except in a less generic way.
Be specific with your exceptions If  your exception-handling code is designed to deal with a specific type of error, be sure to specify the error type on the except line.
In doing so, you’ll take your exception handling code from generic to specific.
Of  course, if  an different type of  runtime error occurs, it is no longer handled by your code, but at least now you’ll get to hear about it.
When you are specific about the runtime errors your code handles, your programs no longer silently ignore some runtime errors.
Using “try/except” lets you concentrate on what your code needs to do...
Your Python Toolbox You’ve got Chapter 3 under your belt and you’ve added some key Python techiques to your toolbox.
Use the open() BIF to open a disk file, creating an iterator that reads data from the file one line at a time.
The readline() method reads a single line from an opened file.
The seek() method can be used to “rewind” a file to the beginning.
The split() method can break a string into a list of parts.
An unchangeable, constant list in Python is called a tuple.
Once list data is assigned to a tuple, it cannot be changed.
A ValueError occurs when your data does not conform to an expected format.
An IOError occurs when your data cannot be accessed properly (e.g., perhaps your data file has been moved or renamed)
The help() BIF provides access to Python’s documentation within the IDLE shell.
The find() method locates a specific substring within another string.
The try/except statement provides an exception-handling mechanism, allowing you to protect lines of code that might result in a runtime error.
The pass statement is Python’s empty or null statement; it does nothing.
The Python 3 documentation set should open in your favorite web browser.
I’m in a bit of a pickle...my data is not as persistent as it could be.
It is truly great to be able to process your file-based data.
But what happens to your data when you’re done? Of course, it’s best to save your.
Programs produce data It’s a rare program that reads data from a disk file, processes the data, and then throws away the processed data.
Typically, programs save the data they process, display their output on screen, or transfer data over a network.
You have lots of choices about which type of disk file to use.
Before you learn what’s involved in writing data to disk, let’s process the data from the previous chapter to work out who said what to whom.
Code Magnets Add the code magnets at the bottom of this page to your existing code to satisfy the following requirements:
Add a line of code to remove unwanted whitespace from the line_spoken variable.
Provide the conditions and code to add line_spoken to the correct list based on the value of role.
Print each of the lists (man and other) to the screen.
Code Magnets Solution Your were to add the code magnets to your existing code to satisfy the following requirements:
Add a line of code to remove unwanted whitespace from the line_spoken variable.
Provide the conditions and code to add line_spoken to the correct list based on the value of role.
Print each of the lists (man and other) to the screen.
Update one of the lists based on who said what.
Test Drive Load your code into IDLE’s edit window and take it for a spin by pressing F5
Be sure to save your program into the same folder that contains sketch.txt.
And here’s what appears on screen: the contents of the two lists.
Surely Python’s open() BIF can open files for writing as well as reading, eh?
When you need to save data to a file, the open() BIF is all you need.
Open your file in write mode When you use the open() BIF to work with a disk file, you can specify an access mode to use.
By default, open() uses mode r for reading, so you don’t need to specify it.
By default, the print() BIF uses standard output (usually the screen) when displaying data.
To write data to a file instead, use the file argument to specify the data file object to use:
What gets written to the file The name of the data file object to write to.
When you’re done, be sure to close the file to ensure all of  your data is written to disk.
When you use access mode w, Python opens your named file for writing.
If the file already exists, it is cleared of its contents, or clobbered.
To append to a file, use access mode a, and to open a file for writing and reading (without clobbering), use w+
If you try to open a file for writing that does not already exist, it is first created for you, and then opened for writing.
At the bottom of your program, two calls to the print() BIF display your processed data on screen.
Let’s amend this code to save the data to two disk files instead.
Be sure to both open and close your data files, as well as protect your code against an IOError using try/except.
Specify the files to write to when you invoke “print()”.Be sure to close your.
At the bottom of your program, two calls to the print() BIF display your processed data on screen.
You were to amend this code to save the data to two disk files instead.
You were to make sure to both open and close your data files, as well as protect your code against an IOError using try/except.
Did you remember to open your files in WRITE mode?
Open your two files, and assign each to file objects.
Use the “print()” BIF to save the named lists to named disk files.
Test Drive Perform the edits to your code to replace your two print() calls with your new file I/O code.
Then, run your program to confirm that the data files are created:
When you run your code, this is all you see, what looks like an “empty” IDLE shell.
Before your program runs, there are no data files in your folder, just your code.
After your program runs, two new files are CREATED in your folder.
You’ve created two data files, each holding the data from each of  your lists.
Go ahead and open these files in your favorite editor to confirm that they contain the data you expect.
Consider the following carefully: what happens to your data files if the second call to print() in your code causes an IOError?
Files are left open after an exception! When all you ever do is read data from files, getting an IOError is annoying, but rarely dangerous, because your data is still in your file, even though you might be having trouble getting at it.
It’s a different story when writing data to files: if  you need to handle an IOError before a file is closed, your written data might become corrupted and there’s no way of  telling until after it has happened.
Your exception-handling code is doing its job, but you now have a situation where your data could potentially be corrupted, which can’t be good.
What’s needed here is something that lets you run some code regardless of whether an IOError has occured.
In the context of  your code, you’ll want to make sure the files are closed no matter what.
Extend try with finally When you have a situation where code must always run no matter what errors occur, add that code to your try statement’s finally suite:
If  no runtime errors occur, any code in the finally suite executes.
Equally, if  an IOError occurs, the except suite executes and then the finally suite runs.
No matter what, the code in the finally suite always runs.
By moving your file closing code into your finally suite, you are reducing the possibility of  data corruption errors.
This is a big improvement, because you’re now ensuring that files are closed properly (even when write errors occur)
How do you find out the specifics of the error?
Surely invoking the strip() method on line_spoken changed the string it refers to?
Strings in Python are immutable, which means that once a string is created, it cannot be changed.
Q: But you did change the line_spoken string by removing any unwanted whitespace, right?
What actually happens is that invoking the strip() method on the line_spoken string creates a new string with leading and trailing whitespace removed.
The new string is then assigned to line_spoken, replacing the data that was referred to before.
In effect, it is as if you changed line_ spoken, when you’ve actually completely replaced the data it refers to.
Q: So what happens to the replaced data? A: Python’s built-in memory management technology reclaims the RAM it was using and makes it available to your program.
That is, unless some other Python data object is also referring to the string.
A: It is conceivable that another data object is referring to the string referred to by line_spoken.
For example, let’s assume you have some code that contains two variables that refer to the same string, namely “Flying Circus.” You then decide that one of the variables needs to be in all UPPERCASE, so you invoke the upper() method on it.
The Python interperter takes a copy of the string, converts it to uppercase, and returns it to you.
You can then assign the uppercase data back to the variable that used to refer to the original data.
Q: And the original data cannot change, because there’s another variable referring to it?
That’s why strings are immutable, because you never know what other variables are referring to any particular string.
Q: But surely Python can work out how many variables are referring to any one particular string?
A: It does, but only for the purposes of garbage collection.
If you have a line of code like print('Flying Circus'), the string is not referred to by a variable (so any variable reference counting that’s going on isn’t going to count it) but is still a valid string object (which might be referred to by a variable) and it cannot have its data changed under any circumstances.
Q: So Python variables don’t actually contain the data assigned to them?
Python variables contain a reference to a data object.The data object contains the data and, because you can conceivably have a string object used in many different places throughout your code, it is safest to make all strings immutable so that no nasty side effects occur.
Q: Isn’t it a huge pain not being able to adjust strings “in place”?
Once you get used to how strings work, it becomes less of an issue.
In practice, you’ll find that this issue rarely trips you up.
Q: Other than learning which is which, how will I know when something is immutable?
If you try to change an immutable value, Python raises a TypeError exception.
Knowing the type of error is not enough When a file I/O error occurs, your code displays a generic “File Error” message.
Maybe the problem is that you can’t open the file?
It could be that the file can be opened but not written to?
Yeah, or it could be a permission error, or maybe your disk is full?
It turns out that the Python interpreter knows…and it will give up the details if  only you’d ask.
When an error occurs at runtime, Python raises an exception of  the specific type (such as IOError, ValueError, and so on)
Additionally, Python creates an exception object that is passed as an argument to your except suite.
Let’s see what happens when you try to open a file that doesn’t exist, such as a disk file called missing.txt.
As the file doesn’t exist, the data file object wasn’t created, which subsequently makes it impossible to call the close() method on it, so you end up with a NameError.
A quick fix is to add a small test to the finally suite to see if the data name exists before you try to call close()
The locals() BIF returns a collection of names defined in the current scope.
Let’s exploit this BIF to only invoke close() when it is safe to do so:
Here you’re searching the collection returned by the locals() BIF for the string data.
If you find it, you can assume the file was opened successfully and safely call the close() method.
If some other error occurs (perhaps something awful happens when your code calls the print() BIF), your exception-handling code catches the error, displays your “File error” message and, finally, closes any opened file.
But you still are none the wiser as to what actually caused the error.
This is just the bit of code that needs to change.
When an exception is raised and handled by your except suite, the Python interpreter passes an exception object into the suite.
A small change makes this exception object available to your code as an identifier:
It turns out exception objects and strings are not compatible types, so trying to concatenate one with the other leads to problems.
You can convert (or cast) one to the other using the str() BIF:
File error: [Errno 2] No such file or directory: 'missing.txt'
Use the “str()” BIF to force the exception object to behave like a string.
And you now get a specific error message that tells you exactly what went wrong.
Of course, all this extra logic is starting to obscure the real meaning of your code.
Wouldn’t it be dreamy if there were a way to take advantage of these mechanisms without the code bloat? I guess it’s just a fantasy...
But when you try to run your code with this change made, another exception is raised:
Now, with this final change, your code is behaving exactly as expected:
Use with to work with files Because the use of  the try/except/finally pattern is so common when it comes to working with files, Python includes a statement that abstracts away some of  the details.
The with statement, when used with files, can dramatically reduce the amount of  code you have to write, because it negates the need to include a finally suite to handle the closing of  a potentially opened data file.
The use of “with” negates the need for the “finally” suite.
When you use with, you no longer have to worry about closing any opened files, as the Python interpreter automatically takes care of  this for you.
The with code on the the right is identical in function to that on the left.
At Head First Labs, we know which approach we prefer.
The with statement takes advantage of a Python technology called the context management protocol.
Grab your pencil and rewrite this try/except/finally code to use with instead.
You were to grab your pencil and rewrite this try/except/finally code to use with instead.
Using two “with” statements to rewrite the code without the “finally” suite.
Or combine the two “open()” calls into one “with” statement.
Test Drive Add your with code to your program, and let’s confirm that it continues to function as expected.
Delete the two data files you created with the previous version of your program and then load your newest code into IDLE and give it a spin.
If you check your folder, your two data files should’ve reappeared.
Let’s take a closer look at the data file’s contents by opening them in your favorite text editor (or use IDLE)
You’ve saved the lists in two files containing what the Man said and what the Other man said.
Your code is smart enough to handle any exceptions that Python or your operating system might throw at it.
Default formats are unsuitable for files Although your data is now stored in a file, it’s not really in a useful format.
Let’s experiment in the IDLE shell to see what impact this can have.
Use a with statement to open your data file and display a single line from it:
Yikes! It would appear your list is converted to a large string by print() when it is saved.
Your experimental code reads a single line of  data from the file and gets all of  the data as one large chunk of  text…so much for your code saving your list data.
Note: no need to close your file, because “with” does that for you.
By default, print() displays your data in a format that mimics how your list data is actually stored by the Python interpreter.
The resulting output is not really meant to be processed further… its primary purpose is to show you, the Python programmer, what your list data “looks like” in memory.
I guess I could write some custom parsing code to process the “internal format” used by “print()”
It might be worth looking at using something other than a plain.
Writing the required code is doable, but it is a lot of  code just to read back in your saved data.
Of  course, if  the data is in a more easily parseable format, the task would likely be easier, so maybe the second option is worth considering, too?
Can you think of a function you created from earlier in this book that might help here?
This functionality sounds perfect! Here’s your code from the nester.py module (last seen at the end of  Chapter 2):
Amending this code to print to a disk file instead of  the screen (known as standard output) should be relatively straightforward.
You can then save your data in a more usable format.
Standard Output The default place where your code writes its data when the “print()” BIF is used.
In Python, standard output is referred to as “sys.stdout” and is importable from the Standard Library’s “sys” module.
Let’s add a fourth argument to your print_lol() function to identify a place to write your data to.
Be sure to give your argument a default value of sys.stdout, so that it continues to write to the screen if no file object is specified when the function is invoked.
Fill in the blanks with the details of your new argument.
Note: to save on space, the comments have been removed from this cod, but be sure to update your comments in your nester.py module after you’ve amended your code.
What needs to happen to the code in your with statement now that your amended print_lol() function is available to you?
List the name of the module(s) that you now need to import into your program in order to support your amendments to print_lol()
You were to add a fourth argument to your print_lol() function to identify a place to write your data to, being sure to give your argument a default value of sys.stdout so that it continues to write to the screen if no file object is specified when the function is invoked.
You were to fill in the blanks with the details of your new argument.
What needs to happen to the code in your with statement now that your amended print_lol() function is available to you?
List the name of the module(s) that you now need to import into your program in order to support your amendments to print_lol()
The code needs to be adjusted so that instead of using the “print()” BIF, the code needs to invoke “print_lol()” instead.
Adjust the two calls to “print()” to use the new argument.
Add the fourth argument and give it a default value.
Test Drive Before taking your code for a test drive, you need to do the following:
Make the necessary changes to nester and install the amended module into your Python environment (see Chapter 2 for a refresher on this)
Amend your program so that it imports nester and uses print_lol() instead of print() within your with statement.
When you are ready, take your latest program for a test drive and let’s see what happens:
Let’s check the contents of the files to see what they look like now.
By amending your nester module, you’ve provided a facility to save your list data in a legible format.
But does this make it any easier to read the data back in?
This problem is not unlike the problem from the beginning of  the chapter, in that you’ve got lines of text in a disk file that you need to process, only now you have two files instead of  one.
You know how to write the code to process your new files, but writing custom code like this is specific to the format that you’ve created for this problem.
This is brittle: if  the data format changes, your custom code will have to change, too.
Custom Code: Hi, I’m great! And when I’m not great, there’s always something I can do to fix things.
I’m your “go-to guy.” Just ask; absolutely anything’s possible when it’s a custom job.
Head First: Even when it leads to problems down the road?
Custom Code: Problems?!? But I’ve already told you: nothing’s too much trouble for me.
Head First: Even when a readymade solution might be a better fit?
Custom Code: Readymade? You mean (I hate to say it): off  the shelf?
Custom Code: What?!? That’s where I excel: creating beautifully crafted custom solutions for folks with complex computing problems.
Head First: But if  something’s been done before, why reinvent the wheel?
Custom Code: But everything I do is custommade; that’s why people come to me…
Head First: Yes, but if  you take advantage of  other coders’ work, you can build your own stuff  in half the time with less code.
Head First: More like collaboration, sharing, participation, and working together.
Custom Code: [shocked] You want me to give my code…away?
All I’m saying is that it is not always a good idea to create everything from scratch with custom code when a good enough solution to the problem might already exist.
Custom Code: I guess so…although it won’t be as perfect a fit as that chair.
Head First: But I will be able to sit on it!
Custom Code: [laughs] You should talk to my buddy Pickle…he’s forever going on about stuff  like this.
And to make matters worse, he lives in a library.
Custom Code: Just remember: you know where to find me if  you need any custom work done.
Pickle your data Python ships with a standard library called pickle, which can save and load almost any Python data object, including lists.
Once you pickle your data to a file, it is persistent and ready to be read into another program at some later date/time:
Your data as it appears in Python’s memory The pickle engine.
You can, for example, store your pickled data on disk, put it in a database, or transfer it over a network to another computer.
When you are ready, reversing this process unpickles your persistent pickled data and recreates your data in its original form within Python’s memory:
Your data is recreated in Python’s memory, exactly as before.The same pickle engine.
Save with dump and restore with load Using pickle is straightforward: import the required module, then use dump() to save your data and, some time later, load() to restore it.
The only requirement when working with pickled files is that they have to be opened in binary access mode:
What if something goes wrong? If  something goes wrong when pickling or unpickling your data, the pickle module raises an exception of  type PickleError.
The “b” tells Python to open your data files in BINARY mode.
Once your data is back in your program, yo u can.
Grab your pencil and strike out the code you no longer need, and then replace it with code that uses the facilities of pickle instead.
Add any additional code that you think you might need, too.
You were to grab your pencil and strike out the code you no longer need, and then replace it with code that uses the facilities pickle instead.
You were also to add any additional code that you think you might need.
Q: When you invoked print_lol() earlier, you provided only two arguments, even though the function signature requires you to provide four.
A: When you invoke a Python function in your code, you have options, especially when the function provides default values for some arguments.
If you use positional arguments, the position of the argument in your function invocation dictates what data is assigned to which argument.
When the function has arguments that also provide default values, you do not need to always worry about positional arguments being assigned values.
Can you explain? A: Consider print(), which has this signature: print(value, sep=' ', end='\n', file=sys.stdout)
By default, this BIF displays to standard output (the screen), because it has an argument called file with a default value of sys.stdout.
However, when you want to send data to something other than the screen, you do not need to (nor want to have to) include values for the second and third positional arguments.
They have default values anyway, so you need to provide values for them only if the defaults are not what you want.
In Python, not only do the BIFs work this way, but your custom functions support this mechamism, too.
Test Drive Let’s see what happens now that your code has been amended to use the standard pickle module instead of your custom nester module.
Load your amended code into IDLE and press F5 to run it.
So, once again, let’s check the contents of the files to see what they look like now:
Once again, you get no visual clue that something has happened.
It appears to have worked…but these files look like gobbledygook! What gives?
To do so efficiently, Python’s pickle module uses a custom binary format (known as its protocol)
As you can see, viewing this format in your editor looks decidedly weird.
And, of course, there’s nothing to stop you from using pickle with nester.
After all, each module is designed to serve different purposes.
Let’s demonstrate with a handful of lines of code within IDLE’s shell.
Next up: create a new identifier to hold the data that you plan to unpickle.Create an empty list called new_man:
Yes, almost too exciting for words, isn’t it? With your list created.
As you are working with external data files, it’s best if you enclose your code with try/except:
However, at this point, your data has been unpickled and assigned to the new_man list.
And to finish off, let’s display the first line spoken as well as the last:
Not all the data is shown here, but trust us: it’s all there.
Generic file I/O with pickle is the way to go!
Now, no matter what data you create and process in your Python programs, you have a simple, tested, triedand-true mechanism for saving and restoring your data.
Python takes care of  your file I/O details, so you can concentrate on what your code actually does or needs to do.
As you’ve seen, being able to work with, save, and restore data in lists is a breeze, thanks to Python.
But what other data structures does Python support out of  the box?
Your Python Toolbox You’ve got Chapter 4 under your belt and you’ve added some key Python techiques to your toolbox.
The file argument to the print() BIF controls where data is sent/saved.
The finally suite is always executed no matter what exceptions occur within a try/except statement.
An exception object is passed into the except suite and can be assigned to an identifier using the as keyword.
The str() BIF can be used to access the stringed representation of any data object that supports the conversion.
The locals() BIF returns a collection of variables within the current scope.
The “+” operator concatenates two strings when used with strings but adds two numbers together when used with numbers.
The with statement automatically arranges to close all opened files, even when exceptions occur.
The standard library’s pickle module lets you easily and efficiently save and restore Python data objects to disk.
Life could be so much easier if only she’d let me help her extract, sort, and comprehend her data...
Data comes in all shapes and sizes, formats and encodings.
To work effectively with your data, you often have to manipulate and transform it into a.
So, flip the page, and let’s not keep the coach waiting…
I’m too busy on the track to waste time fiddling with my computer.
The coach is an old friend, and you’d love to help.
His crack squad of  U10 athletes has been training hard.
With each 600m run they do, Coach Kelly has recorded their time in a text file on his computer.
There are four files in all, one each for James, Sarah, Julie, and Mikey.
Initially, the coach needs a quick way to know the top three fastest times for each athlete.
Before proceeding with this chapter, take a few moments to download the four data files from the Head First Python support website.
Let’s begin by reading the data from each of the files into its own list.
Write a short program to process each file, creating a list for each athlete’s data, and display the lists on screen.
Hint: Try splitting the data on the commas, and don’t forget to strip any unwanted whitespace.
Let’s begin by reading the data from each of the files into its own list.
You were to write a short program to process each file, creating a list for each athlete’s data.
Open each of the data files in turn, read the line of data from the file, and create a list from the line of data.
Can you explain what’s going on? A: That’s called method chaining.
The first method, strip(), is applied to the line in data, which removes any unwanted whitespace from the string.
Then, the results of the stripping are processed by the second method, split(','), creating a list.
The resulting list is then applied to the target identifier in the previous code.
In this way, the methods are chained together to produce the required result.
It helps if you read method chains from left to right.
Test Drive Load your code into IDLE and run it to confirm that it’s all OK for now:
Coach Kelly’s data is now represented by four lists in Python’s memory.
Other than the use of  method chaining, there’s nothing much new here, because you’ve pretty much mastered reading data from files and using it to populate lists.
There’s nothing to show the coach yet, so no point in disturbing him until his data is arranged in ascending order, which requires you to sort it.
Sort in one of two ways When it comes to sorting your data using Python, you have two options.
In-place sorting takes your data, arranges it in the order you specify, and then replaces your original data with the sorted version.
Copied sorting takes your data, arranges it in the order you specify, and then returns a sorted copy of  your original data.
Your original data’s ordering is maintained and only the copy is sorted.
Let’s see what happens to your data when each of Python’s sorting options is used.
Start by creating an unordered list at the IDLE shell:
Perform an in-place sort using the sort() method that is built in as standard to every Python list:
Reset data to its original unordered state, and then perform a copied sort using the sorted() BIF:
Create a list of unordered data and assign to a variable.
Either sorting option works with the coach’s data, but let’s use a copied sort for now to arrange to sort the data on output.
In the space below, provide four amended print() statements to replace those at the bottom of your program.
Either sorting option works with the coach’s data, but let’s use a copied sort for now to arrange to sort the data on output.
You were to provide four amended print() statements to replace those at the bottom of your program.
Q: What happens to the unsorted data when I use sort()? A: For all intents and purposes, it disappears.
Python takes a copy, sorts it, and then replaces your original data with the sorted version.
Q: And there’s no way to get the original data back? A: No.
If the ordering of the original data is important to you, use the sorted() BIF to transform your data into a sorted copy.
Simply call “sorted()” on the data BEFORE you display it on screen.
You’ve already seen method chaining, and now it’s time to say “hello” to function chaining.
Function chaining allows you to apply a series of functions to your data.
Each function takes your data, performs some operation on it, and then passes the transformed data on to the next function.
Unlike method chains, which read from left to right, function chains read from right to left ( just to keep things interesting)
Test Drive Let’s see if this improves your output in any way.
Make the necessary amendments to your code and run it.
Hey, it looks like your data values are not uniform.
Is the problem with all those periods, dashes, and colons?
But look at THIS! The data is not at all sorted…which is, like, weird.
The minute and seconds separators are confusing Python’s sorting technology.
When recording his athletes’ times in each of  their files, Coach Kelly sometimes used a different character to separate minutes from seconds.
The trouble with time Well…there’s never enough of  it, is there?
Let’s look closely at the coach’s data to see what the problem is.
Recall that data read from a file comes into your program as text, so Sarah’s data looks like this once you turn it into a list of  “times”:
And when you sort Sarah’s data, it ends up in this order (which isn’t quite what you were expecting):
Python sorts the strings, and when it comes to strings, a dash comes before a period, which itself  comes before a colon.
As all the strings start with 2, the next character in each string acts like a grouping mechanism, with the dashed times grouped and sorted, then the period times, and finally the colon times.
Nonuniformity in the coach’s data is causing the sort to fail.
I don’t get what the problem is...they’re all times to me.
Code Magnets Let’s create a function called sanitize(),  which takes as input a string from each of the athlete’s lists.
The function then processes the string to replace any dashes or colons found with a period and returns the sanitized string.
Note: if the string already contains a period, there’s no need to sanitize it.
Rearrange the code magnets at the bottom of the page to provide the required functionality.
Return the sanitized time string to the caller of this function.
Code Magnets Solution You were to create a function called sanitize(), which takes as input a string from each of the athlete’s lists.
The function then processes the string to replace any dashes or colons found with a period and returns the sanitized string.
Note: if the string already contains a period, there’s no need to sanitize it.
You were to rearrange the code magnets at the bottom of the previous page to provide the required functionality.
Use the “in” operator to check if the string contains a dash or a colon.
Do nothing if the string does NOT need to be sanitized.
Split the string to extract the minutes and seconds parts.
Of  course, on its own, the sanitize() function is not enough.
You need to iterate over each of  your lists of  data and use your new function to convert each of  the athlete’s times into the correct format.
Let’s write the code to convert your existing data into a sanitized version of itself.
Iterate over each athlete’s list data and append each sanitized string from each list to the appropriate new list.
Conclude your program by printing a sorted copy of each new list to the screen.
The code that reads the data from the data files remains unchanged (and has been compressed to fit on this page)
Let’s write the code to convert your existing data into a sanitized version of itself.
You were to create four new lists to hold the sanitized data.
You were then to iterate over each athlete’s data and append each sanitized string from each list to an appropriate new list.
You were to conclude your program by printing a sorted copy of each new list to the screen.
The four “print()” statements now display the new lists, which are sorted, too.
Take each of the data items in the original lists, sanitize them, and then append the sanitized data to the appropriate new list.
Test Drive Combine your sanitize() function with your amended code from the previous page, and then press F5 in IDLE to confirm the sorting is now working as expected.
It’s taken a bit of  work, but now the data from each of  the four files is both sorted and uniformly formatted.
By preprocessing your data before you sort it, you’ve helped ensure Python’s sorting technology performs correctly.
By default, both the sort() method and the sorted() BIF order your data in ascending order.
To order your data in descending order, pass the reverse=True argument to either sort() or sorted() and Python will take care of things for you.
The ordering works, because all the times are now comparable.
Hang on a sec! Something doesn’t feel quite right...look at all that duplicated code, as well as all those duplicated lists.
This duplication is bad, right? Is this really the best you can do?
As things stand, your code creates four lists to hold the data as read from the data files.
Then your code creates another four lists to hold the sanitized data.
There has to be a better way to write code like this.
Transforming lists is such a common requirement that Python provides a tool to make the transformation as painless as possible.
This tool goes by the rather unwieldly name of  list comprehension.
And list comprehensions are designed to reduce the amount of  code you need to write when transforming one list into another.
Comprehending lists Consider what you need to do when you transform one list into another.
Here’s the same functionality as a list comprehension, which involves creating a new list by specifying the transformation that is to be applied to each of  the data items within an existing list.
What’s interesting is that the transformation has been reduced to a single line of  code.
Additionally, there’s no need to specify the use of  the append() method as this action is implied within the list comprehension.
You get to pick the target identifier to use (just like with regular iterations)
Open up your IDLE shell and follow along with these one-liner transformations.
Start by transforming a list of minutes into a list of seconds:
Given a list of strings in mixed and lowercase, it’s a breeze to transform the strings to UPPERCASE:
Let’s use your sanitize() function to transform some list data into correctly formatted times:
It’s also possible to assign the results of the list transformation back onto the original target identifier.
This example transforms a list of strings into floating point numbers, and then replaces the original list data:
And, of course, the transformation can be a function chain, if that’s what you need:
Now that you know about list comprehensions, let’s write four of them to process the coach’s four lists of timing values.
Transform each of your lists into sorted, sanitized version of themselves.
Grab your pencil and in the space provided, scribble the list comprehensions you plan to use.
Q: So…let me get this straight: list comprehensions are good and list iterations are bad, right? A: No, that’s not the best way to look at it.
If you have to perform a transformation on every item in a list, using a list comprehension is the way to go, especially when the transformation is easily specified on one line (or as a function chain)
List iterations can do everything that list comprehensions can, they just take more code, but iterations do provide more flexibility should you need it.
Python’s list comprehension is an example of the language’s support for functional programming concepts.
There’s plenty of debate about the best way to develop program code: either procedurally, using functional programming techniques, or using object orientation.
At Head First Labs, we try not to get involved in this debate, other than to rejoice in the fact that Python supports, in one way or another, all three of these programming practices.
Now that you know about list comprehensions, you were to write four of them to process the coach’s four lists of timing values.
You were to transform each of your lists into sorted, sanitized version of themselves.
You were to grab your pencil and in the space provided, scribble the list comprehensions you plan to use.
The list comprehension performs the transformation, and the new list is then ordered by the “sorted()” BIF.
Be careful about where you use the sorted() BIF when defining your list comprehensions.
Recall that the transformation works on one list item at a time, not the entire list.
In this example, the sorted() BIF expects to sort a list, not an individual data item.
The beauty of list comprehensions The use of  list comprehensions with the coach’s athlete data has resulted in a lot less code for you to maintain.
Additionally, as you get used to list comprehension syntax and usage, you’ll find that their use is natural and matches the way your brain thinks about your data and the transformations that you might want to apply.
Let’s confirm that your new code is working as expected.
Test Drive Replace your list iteration code from earlier with your four new (beautiful) list comprehensions.
Run your program to confirm that the results have not changed.
Your new list comprehensions produce EXACTLY the same output as your earlier list iterations.
You’ve written a program that reads Coach Kelly’s data from his data files, stores his raw data in lists, sanitizes the data to a uniform format, and then sorts and displays the coach’s data on screen.
It’s probably safe to let the coach take a look at your output now.
In your haste to sanitize and sort your data, you forgot to worry about what you were actually supposed to be doing: producing the three fastest times for each athlete.
And, of  course, there’s no place for any duplicated times in your output.
Accessing the first three data items from any list is easy.
Either specify each list item individually using the standard notation or use a list slice:
Iterate to remove duplicates Processing a list to remove duplicates is one area where a list comprehension can’t help you, because duplicate removal is not a transformation; it’s more of a filter.
And a duplicate removal filter needs to examine the list being created as it is being created, which is not possible with a list comprehension.
To meet this new requirement, you’ll need to revert to regular list iteration code.
Assume that the fourth from last line of code from your current program is changed to this:
That is, instead of printing the sanitized and sorted data for James to the screen, this line of code replaces James’s unordered and nonuniform data with the sorted, sanitized copy.
Your next task is to write some code to remove any duplicates from the james list produced by the preceding line of code.
Start by creating a new list called unique_james, and then populate it with the unique data items found in james.
Additionally, provide code to display only the top three fastest times for James.
Hint: you might want to consider using the not in operator.
Assume that the fourth from last line of code from your current program is changed to this:
That is, instead of printing the sanitized and sorted data for James to the screen, this line of code replaces James’s unordered and non-uniform data with the sorted, sanitized copy.
Your next task was to write some code to remove any duplicates from the james list produced by the preceding line of code.
You were to start by creating a new list called unique_james and then populate it with the unique data items found in james.
Additionally, you were to provide code to only display the top three fastest times for James.
Create the empty list to hold the unique data items.
Slice the first three data items from the list and display them on screen.
Repeat the code on this page for the rest of  the coach’s lists: julie, mikey & sarah.
Add all of  your new code to your existing program.
Test Drive Take all of the recent amendments and apply them to your program.
Run this latest code within IDLE when you are ready.
You are now displaying only the top three times for each athlete, and the duplicates have been successfully removed.
The list iteration code is what you need in this instance.
There’s a little bit of duplication in your code, but it’s not too bad, is it?
The irony is hard to avoid, isn’t it? The code that removes duplicates from your lists is itself duplicated.
Sometimes such a situation is unavoidable, and sometimes creating a small function to factor out the duplicated code can help.
Wouldn't it be dreamy if there were a way to quickly and easily remove duplicates from an existing list? But I know it's just a fantasy...
Remove duplicates with sets In addition to lists, Python also comes with the set data structure, which behaves like the sets you learned all about in math class.
The overriding characteristics of  sets in Python are that the data items in a set are unordered and duplicates are not allowed.
If  you try to add a data item to a set that already contains the data item, Python simply ignores it.
Create an empty set using the set() BIF, which is an example of  a factory function:
Factory Function: A factory function is used to make new data items of a particular type.
In the real world, factories make things, hence the name.
Create a new, empty set, and assign it to a variable.
It is also possible to create and populate a set in one step.
You can provide a list of  data values between curly braces or specify an existing list as an argument to the set() BIF, which is the factory function:
Any duplicates in the supplied list of data values are ignored.
Can you spell “d-a-t-a  l-o-s-s”? Getting rid of  data automatically sounds kinda dangerous to me.
Have you ever considered that I like my duplicate values.
And, anyway, I can always rely on the kindness of  others to help me out with any duplicates that I don’t need.
I’m resisting the urge to say, “No, you can’t.” Instead, let me ask you: what about handling duplicates? When I see them, I throw them away automatically.
You’re just being smug in an effort to hide from the fact that you can’t get rid of duplicates on your own.
I think you meant to say, “the kindness of  set()”, didn’t you?
The Head First Code Review Team has taken your code and annotated it in the only way they know how: they’ve scribbled all over it.
Some of their comments are confirmations of what you might already know.
Like all code reviews, these comments are an attempt to improve the quality of your code.
What happens if one of these files is missing?!? Where’s your exception handling.
The slice is applied to the list produced by “sorted()”, right?
There’s a lot going on here, but we find it’s not too hard to understand if you.
Let’s take a few moments to implement the review team’s suggestion to turn those four with statements into a function.
In the space provided, create a function to abstract the required functionality, and then provide one example of how you would call your new function in your code:
You were to take a few moments to implement the review team’s suggestion to turn those four with statements into a function.
In the space provided, your were to create a function to abstract the required functionality, then provide one example of how you would call your new function in your code:
Perform the split/strip trick on the data prior to returning it to the calling code.
Tell your user about the error (if it occurs) and return “None” to indicate failure.
Test Drive It’s time for one last run of your program to confirm that your use of sets produces the same results as your list-iteration code.
Take your code for a spin in IDLE and see what happens.
You’ve processed the coach’s data perfectly, while taking advantage of  the sorted() BIF, sets, and list comprehensions.
As you can imagine, you can apply these techniques to many different situations.
You’re well on your way to becoming a Python data-munging master!
Thanks! I’m looking forward to seeing you on the track soon...
Your Python Toolbox You’ve got Chapter 5 under your belt and you’ve added some more Python techiques to your toolbox.
The sorted() BIF sorts most any data structure by providing copied sorting.
Pass reverse=True to either sort() or sorted() to arrange your data in descending order.
To access more than one data item from a list, use a slice.
A “slice” - access more than one item from a list.
A “set” - a collection of unordered data items that contains no duplicates.
The object of my desire [sigh] is in a class of her own.
It’s important to match your data structure choice to your data.
And that choice can make a big difference to the complexity of your code.
And when Python’s built-in data structures don’t quite cut it, the Python class.
I love what you’ve done, but I can’t tell which line of data belongs to which athlete, so I’ve added some information to my data files to make it easy for you to figure it out.
The output from your last program in Chapter 5 was exactly what the coach was looking for, but for the fact that no one can tell which athlete belongs to which data.
Coach Kelly thinks he has the solution: he’s added identification data to each of  his data files:
Sarah’s full name Sarah’s date of birth S arah’s timing data.
If  you use the split() BIF to extract Sarah’s data into a list, the first data item is Sarah’s name, the second is her date of  birth, and the rest is Sarah’s timing data.
Let’s exploit this format and see how well things work.
Grab the updated files from the Head First Python website.
Code Magnets Let’s look at the code to implement the strategy outlined at the bottom of the previous page.
Rearrange the code magnets at the bottom of this page to implement the list processing required to extract and process Sarah’s three fastest times from Coach Kelly’s raw data.
Hint: the pop() method removes and returns a data item from the specified list location.
Code Magnets Solution Let’s look at the code to implement the strategy outlined earlier.
You were to rearrange the code magnets at the bottom of the previous page to implement the list processing required to extract and process Sarah’s three fastest times from Coach Kelly’s raw data.
Use the function to turn Sarah’s data file into a list, and then assign it to the “sarah” variable.
The “pop(0)” call returns and removes data from the front of a list..
Two calls to “pop(0)” remove the first two data values and assigns them to the named variables.
A custom message within the call to “print()” is used to display the results you’re after.
Test Drive Let’s run this code in IDLE and see what happens.
This program works as expected, and is fine…except that you have to name and create Sarah’s three variables in such as way that it’s possible to identify which name, date of  birth, and timing data relate to Sarah.
And if  you add code to process the data for James, Julie, and Mikey, you’ll be up to 12 variables that need juggling.
Although the data is related in “real life,” within your code things are disjointed, because the three related pieces of  data representing Sarah are stored in three separate variables.
Use a dictionary to associate data Lists are great, but they are not always the best data structure for every situation.
Sarah’s full name Sarah’s date of birth Sarah’s timing data.
There’s a definite structure here: the athlete’s name, the date of  birth, and then the list of  times.
Let’s continue to use a list for the timing data, because that still makes sense.
But let’s make the timing data part of  another data structure, which associates all the data for an athlete with a single variable.
We’ll use a Python dictionary, which associates data values with keys:
Dictionary A built-in data structure (included with Python) that allows you to associate data with keys, as.
This lets your in-memory data closely match the structure of your actual data.
The “keys” The associated data, also known as the “values”
Tonight’s talk: To use a list or not to use a list?
I hear you’re great, but not always the best option for complex data.
But when you do, you lose any structure associated with the data you are processing.
You guess so? When it comes to modeling your data in code, it’s best not to guess.
Look, the rule is simple: if  your data has structure, use a dictionary, not a list.
Knowing when to use a list and when to use a dictionary is what separates the good programmers from the great ones, right?
What?!? Haven’t you heard? You can put anything into a list, anything at all.
That sounds like a slogan from one of  those awful self-help conferences.
Unless, of  course, you are a list, and you miss being used for every piece of  data in a program…
The Python dictionary is known by different names in other programming languages.
If you hear other programmers talking about a “mapping,” a “hash,” or an “associative array,” they are talking about a “dictionary.”
Follow along with this IDLE session on your computer, ensuring that you get the same results as shown.
Start by creating two empty dictionaries, one using curly braces and the other using a factory function:
Add some data to both of these dictionaries by associating values with keys.
Note the actual structure of the data is presenting itself here, as each dictionary has a Name and a list of Occupations.
Note also that the palin dictionary is being created at the same time:
With your data associated with keys (which are strings, in this case), it is possible to access an individual data item using a notation similar to that used with lists:
Use square brackets to index into the dictionary to access data items, but instead of numbers, index with keys.
Use numbers to access a list item stored at a particular dictionary key.
As with lists, a Python dictionary can grow dynamically to store additional key/value pairings.
Unlike lists, a Python dictionary does not maintain insertion order, which can result in some unexpected behavior.
The key point is that the dictionary maintains the associations, not the ordering:
The ordering maintained by Python is different from how the data was inserted.
It’s time to apply what you now know about Python’s dictionary to your code.
Strike out the code that you no longer need and replace it with new code that uses a dictionary to hold and process Sarah’s data.
It’s time to apply what you now know about Python’s dictionary to your code.
You were to strike out the code that you no longer needed and replace it with new code that uses a dictionary to hold and process Sarah’s data.
Populate the dictionary with the data by associating the data from the file with the dictionary keys..
Test Drive Let’s confirm that this new version of your code works exactly as before by testing your code within the IDLE environment.
Which, again, works as expected…the difference being that you can now more easily determine and control which identification data associates with which timing data, because they are stored in a single dictionary.
Although, to be honest, it does take more code, which is a bit of  a bummer.
Sometimes the extra code is worth it, and sometimes it isn’t.
Let’s review your code to see if we can improve anything.
The Head First Code Review Team has been at it again: they’ve scribbled all over your code.
Like all code reviews, these comments are an attempt to improve the quality of your code.
You might want to consider moving this code into the get_coach_data() function, too, because doing so would rather nicely abstract away these processing details.
But whether you do or not is up to you.
It’s great to see you taking some of our suggestions on board.
Let’s take the time to apply them to your code.
There are four suggestions that you need to adjust your code to support:
Move the dictionary creation code into the get_coach_data() function, returning a dictionary as opposed to a list.
Move the code that determines the top three times for each athlete into the get_coach_data() function.
Adjust the invocations within the main code to the new version of the get_coach_data() function to support it’s new mode of operation.
Grab your pencil and write your new get_coach_data() function in the space provided below.
Provide the four calls that you’d make to process the data for each of the athletes and provide four amended print() statements:
You were to take the time to apply the code review comments to your code.
There were four suggestions that you needed to adjust your code to support:
Move the dictionary creation code into the get_coach_data() function, returning a dictionary as opposed to a list.
Move the code that determines the top three times for each athlete into the get_coach_data() function.
Adjust the invocations within the main code to the new version of the get_coach_data() function to support its new mode of operation.
You were to grab your pencil and write your new get_coach_data() function in the space provided below, as well as provide the four calls that you’d make to process the data for each of the athletes and provide four amended print() statements:
Create a temporary list to hold the data BEFORE creating the dictionary all in one go.
The dictionary creation code is now part of the function.
The code that determines the top three scores is part of the function, too.
Call the function for an athlete and adjust the “print()” statement as needed.
We are showing only these two lines of code for one athlete (because repeating it for the other three is a trivial exercise)
All of the data processing is moved into the function.
Test Drive Let’s confirm that all of  the re-factoring suggestions from the Head First Code Review Team are working as expected.
Load your code into IDLE and take it for a spin.
To process additional athletes, all you need is two lines of  code: the first invokes the get_coach_data() function and the second invokes print()
And if  you require additional functionality, it’s no big deal to write more functions to provide the required functionality, is it?
It does indeed make sense to try and associate the functions with the data they are meant to work on, doesn’t it? After all, the functions are only going to make sense when related to the data—that is, the functions will be specific to the data, not general purpose.
Because this is the case, it’s a great idea to try and bundle the code with its data.
But how? Is there an easy way to associate custom code, in the form of  functions, with your custom data?
Bundle your code and its data in a class Like the majority of  other modern programming languages, Python lets you create and define an object-oriented class that can be used to associate code with the data that it operates on.
By associating your code with the data it works on, you reduce complexity as your code base grows.
However, it’s a fact of  life that your programs will have functionality added over time, which will result in additional complexity.
Using classes to manage this complexity is a very good thing.
Using classes lets you keep your code and your data together in one place, and as your code base grows, this really can make quite a difference.
Define a class Python follows the standard object-oriented programming model of providing a means for you to define the code and the data it works on as a class.
Once this definition is in place, you can use it to create (or instantiate) data objects, which inherit their characteristics from your class.
Within the object-oriented world, your code is often referred to as the class’s methods, and your data is often referred to as its attributes.
Here are your instantiated objects, which are packaged to contain your code and its associated data.
Each object is created from the class and shares a similar set of characteristics.
The methods (your code) are the same in each instance, but each object’s attributes (your data) differ because they were created from your raw data.
Use class to define classes Python uses class to create objects.
Every defined class has a special method called __init__(), which allows you to control how objects are initialized.
Methods within your class are defined in much the same way as functions, that is, using def.
That’s a double underscore before and after the word “init”
Creating object instances With the class in place, it’s easy to create object instances.
Simply assign a call to the class name to each of  your variables.
In this way, the class (together with the __init__() method) provides a mechanism that lets you create a custom factory function that you can use to create as many object instances as you require:
Unlike in C++-inspired languages, Python has no notion of  defining a constructor called “new.” Python does object contruction for you, and then lets you customize your object’s initial state using the __init__() method.
The brackets tell Python to create a new “Athlete” object, which is then assigned to a variable.
All of these variables are unique and are “of type” Athlete.
The importance of self To confirm: when you define a class you are, in effect, defining a custom factory function that you can then use in your code to create instances:
When Python processes this line of  code, it turns the factory function call into the following call, which identifies the class, the method (which is automatically set to __init__()), and the object instance being operated on:
Now take another look at how the __init__() method was defined in the class:
Check out what Python turns your object creation invocation into.
Without it, the Python interpreter can’t work out which object instance to apply the method invocation to.
Note that the class code is designed to be shared among all of  the object instances: the methods are shared, the attributes are not.
The self argument helps identify which object instance’s data to work on.
Every method’s first argument is self In fact, not only does the __init__() method require self as its first argument, but so does every other method defined within your class.
Python arranges for the first argument of  every method to be the invoking (or calling) object instance.
Let’s extend the sample class to store a value in a object attribute called thing with the value set during initialization.
Another method, called how_big(), returns the length of  thing due to the use of the len() BIF:
The “init” code now assigns a supplied value to a class attribute called “self.thing”
Note the use of “self” to identify the calling object instance.
When you invoke a class method on an object instance, Python arranges for the first argument to be the invoking object instance, which is always assigned to each method’s self argument.
This fact alone explains why self is so important and also why self needs to be the first argument to every object method you write:
Let’s use IDLE to create some object instances from a new class that you’ll define.
With the class defined, create two unique object instances which derive their characteristcs from the Athlete class:
Even though sarah and james are both athletes and were created by the Athlete class’s factory function, they are stored at different memory addreses:
Now that sarah and james exist as object instances, you can use the familiar dot notation to access the attributes associated with each:
Three attributes are initialized and assign ed to three class.
Create two unique athletes (with “james” using the default argument values)
These are the memory addresses on our co mputer, which will.
The “james” object instance has no value for “dob”, so nothing appears on screen.
Here’s your code (except for the santize() function, which doesn’t need to change)
With your pencil, write code to define the Athlete class.
Be sure to adjust the get_coach_data() function to return an Athlete object as opposed to a dictionary, and don’t forget to amend your print() statements, too.
What needs to change here to ensure this function returns an Athlete object as opposed to a dictionary?
Here’s your code (except for the santize() function, which doesn’t need to change)
With your pencil, you were to write code to define the Athlete class.
You were to be sure to adjust the get_coach_data() function to return an Athlete object as opposed to a dictionary, and you weren’t to forget to amend print(), too.
There’s nothing new here as this code is taken straight from the most recent IDLE session.
Remove the dictionary creation code and replace it with Athlete object creation code instead.
Invoke the “top3()” method and convert its results to a string prior to its display on screen.
Test Drive With these changes applied to your program, let’s ensure you continue to get the same results as earlier.
The code to the “sanitize()” function is not shown here, but it is still part of this program.
And to make objects do more, I just add more methods, right?
Simply add methods to encapsulate the new functionality you need within your class.
There’s no limit to how many methods a class can have, so feel free to knock yourself  out!
Q: I’m not sure I see why the top3() method is coded to return a three-item list, as opposed to a string? Surely a string would make the print() statement in the main program easier to write?
By returning a list (albeit a small one), the top3() method lets the calling code decide what happens next, as opposed to forcing the caller to work with a string.
Granted, the current program needs to treat the list like a string, but not all programs will want or need to.
Q: Why does the class even need the top3() method? Why not store the top three times as an attribute within the class and create it as part of the object’s creation?
A: Again, better not to, because doing so is less flexible.
If you compute and store the top three times at object creation, you make it harder to extend the list of timing data associated with the object.
For instance, if you add more timing data after the object is created, you’ll need to arrange to recompute the top three (because the new times might be fast) and update the attribute.
However, when you compute the top three times “on the fly” using a call to the top3() method, you always ensure you’re using the most up-to-date data.
But, with a little extra work, I could do it during object creation, right?
By preserving the original data in each object’s attributes, you are supporting the extension of the class to support additional requirements in the future (whatever they might be)
If you process the data as part of the object initialization code, the assumptions you make about how programmers will use your class might just come back to bite you.
Q: But what if I’m the only programmer that’ll ever use a custom class that I write?
A: Trust us: you’ll thank yourself for coding your class to be as flexible as possible when you come to use it for some other purpose in a future project.
When you are creating a class, you have no idea how it will be used by other programmers in their projects.
And, if you think about, you have no idea how you might use it in the future, too.
But tell me: how do I go about adding more times to my existing Athlete objects?
With your Athlete class created, it’s a breeze to extend it to do more work for you: simply add more methods.
So, if you want to add a single new timing value to your times attribute, define a method called add_time() to do it for you.
Q: What?!? Why do you say that? There’s nothing wrong with my suggestion, is there?
However, the problem with writing code like that is that it exposes (and exploits) that fact that the timing data is stored in a list within the Athlete class.
If you later change your class implementation to use (for instance) a string instead of a list, you may well break all of the existing code that uses your class and that exploits the fact that the timing data is a list.
It is worth noting that one of the reasons for using object orientation is to hide away the details of a class’s implementation from the users of that class.
Exposing the internals of your class’s implementation and expecting programmers to exploit it breaks this fundamental ideal in a very big way.
The first, called add_time(), appends a single additional timing value to an athlete’s timing data.
The second, add_times(), extends an athlete’s timing data with one or more timing values supplied as a list.
Here’s your current class: add the code to implement these two new methods.
Don’t put down the pencil just yet! Provide a few lines of code to test your new functionality:
While still holding on firmly to your pencil, you were to provide a few lines of code to test your new functionality:
The first, called add_time(), appends a single additional timing value to an athlete’s timing data.
The second, add_times(), extends an athlete’s timing data with one of more timing values supplied as a list.
Here’s your current class: you were to add the code to implement these two new methods.
Take the supplied argument and append it to the existing list of timing values.
Take the list of supplied arguments and extend the existing list of timing values with them.
This will display a list with only one value in it: 1.31
Test Drive After running your existing program, try out your test code in the IDLE shell to confirm that everything is working as expected.
Display the top three times (there’s only one, so that’s all you see)
Display the top three times (which, now, makes a little more sense)
You’ve packaged your code with your data and created a custom class from which you can create objects that share behaviors.
And when extra functionality is required, add more methods to implement the required functionality.
By encapsulating your athlete code and data within a custom class, you’ve created a much more maintainable piece of  software.
You will thank yourself  for doing this when, in six months, you need to amend your code.
Amend your code with the updated version of  your Athlete class before proceeding with this Test Drive.
Emmm...maybe I’m missing something, but isn’t your Athlete class wasteful? I mean, you’ve extended it with functionality that’s already in lists, which feels a little like reinventing the wheel to me...
Your Athlete class does indeed behave like a list most of  the time, and you’ve added methods to expose some list functionality to the users of  your class.
In fact, your Athlete class only differs from Python’s list due to the inclusion of  the name and dob object attributes.
Wouldn't it be dreamy if there were a way to extend a built-in class with custom attributes? But I know it's just a fantasy…
Inherit from Python’s built-in list Python’s class lets you create a custom class from scratch, just like you did with your Athlete class.
However, class also lets you create a class by inheriting from any other existing class, including Python’s built-in data structure classes that provide you with list, set, and dict.
What’s really nice is that when you inherit from an existing class (such as list), you are given all of  the existing functionality for free.
As your existing class is really nothing more than a list with added attributes, perhaps a better design is to kill off  your Athlete class and replace it with a class that inherits from the built-in list class? It’s certainly worth considering, isn’t it?
But, according to my files, you’re in line to inherit a mountain of functionality from the built-in list class.
Programmers like me because they get to control everything in their code…and you know programmers: they love to code.
Design! Phooey! Real programmers eat, sleep, dream, snore, and exhale code.
All that design talk is for people who can’t code!
When you build everything from the ground up, you’re in control, as it’s all your code.
Of  course, especially when there are custom requirements to be taken into consideration.
In that case, a brand-spanking new custom class is the only way to go.
I guess so, although I’m still a fan of  custom code…
But sometimes writing everything from scratch is not the best design decision.
Is it really? So, you’re saying it’s much better to do everything from scratch and repeat the work of others, because your way is the best way.
And you’re happy to reinvent the wheel, even though someone else solved that problem eons ago?
Not if  you can extend someone else’s class to handle your custom requirements.
That way, you get the best of  both worlds: inheritied functionality (so you’re not reinventing the wheel) together with the custom bits.
But it’s not about us: it’s to do with making the life of  the programmer easier, even the ones that live to code, right?
Let’s see what’s involved in inheriting from Python’s built-in list class.
Working in IDLE’s shell, start by creating a custom list derived from the built-in list class that also has an attribute called name:
With your NamedList class defined, use it to create an object instance, check the object’s type (using the type() BIF), and see what it provides (using the dir() BIF):
Use some of the functionality supplied by the list class to add to the data stored in johnny:
Because johnny is a list, it’s quite OK to do list-type things to it:
Provide the name of the class that this new class derives from.
Initialize the derived from class, and then assign the argument to the attribute.
Add data to the “NamedList” using the methods provided by the list built in.
Access the list data, as well as the attribute data.
Here is the code for the now defunct Athlete class.
In the space provided below, rewrite this class to inherit from the built-in list class.
Provide a few lines of code to exercise your new class, too:
Here is the code for the now defunct Athlete class.
In the space provided below, you were to rewrite this class to inherit from the built-in list class.
You were to call your new class AthleteList, as well as provide a few lines of code to exercise your new class:
The data itself is the timing data, so the “times” attribute is gone.
Nothing new here…this code is very similar to the “NamedList” init code.
This code does a good job of exercising your new class.
Now that you’re inheriting from the built-in list, you can use its methods to get your work on.
In your code, replace your Athlete class code with your new AthleteList class code, and don’t forget to change get_coach_data() to return an AthleteList object instance as opposed to an Athlete object instance.
Q: Sorry…but not three minutes ago you were telling me not to expose the inner workings of my class to its users, because that was fundamentally a bad idea.
In this particular case, it’s OK to expose the fact that the class is built on top of list.
This is due to the fact that the class is deliberately called AthleteList to distinguish it from the more generic Athlete class.
When programmers see the word “list” in a class name, they are likely to expect the class to work like a list and then some.
Q: And I can inherit from any of the built-in types? A: Yes.
Q: What about inheriting from more than one class…does Python support multiple interitance?
Refer to a good Python reference text for all the gory details.
Q: Can I inherit from my own custom classes? A: Of course, that’s the whole idea.
You create a generic class that can then be “subclassed” to provide more specific, targeted functionality.
Q: Can I put my class in a module file? A: Yes, that’s a really good idea, because it lets you share your class with many of your own programs and with other programmers.
For instance, if you save your AthleteList class to a file called athletelist.py, you can import the into your code using this line of code:
And, of course, if you create a really useful class, pop it into its own module and upload it to PyPI for the whole world to share.
Test Drive One last run of your program should confirm that it’s working to specification now.
Your entire program now produces the output the coach wants.
That looks great! I can’t wait to show this to my young athletes and see their reaction...
By basing your class on built-in functionality, you’ve leveraged the power of Python’s data structures while providing the custom solution your application needs.
You’ve engineered a much more maintainable solution to Coach Kelly’s data processing needs.
Your Python Toolbox You’ve got Chapter 6 under your belt and you’ve added some key Python techiques to your toolbox.
To access the value associated with the key Name in a dictionary called person, use the familiar square bracket notation: person['Name']
Like list and set, a Python’s dictionary dynamically grows as new data is added to the data structure.
Class methods (your code) are defined in much the same way as functions, that is, with the def keyword.
Class attributes (your data) are just like variables that exist within object instances.
The __init__() method can be defined within a class to initialize object instances.
Every method defined in a class must provide self as its first argument.
Every attribute in a class must be prefixed with self.
Classes can be built from scratch or can inherit from Python’s built-in classes or from other custom classes.
Classes can be put into a Python module and uploaded to PyPI.
Sooner or later, you’ll want to share your app with lots of  people.
Pop your code on PyPI, send out lots of emails, put.
Luckily, you don’t have to do any of this: just create a webapp instead.
The coach showed us your program running on his laptop...any chance me and my friends could also get access to our list of times? I’d love to show them to my dad...
The new requests come flooding in right after Coach Kelly starts showing off  your latest program.
It appears that everyone wants access to the coach’s data!
The thing is: what’s the “best way” to do this?
You’ll want to be able to share your functionality with lots of people...
If  you develop your program as a Web-based application (or webapp, for short), your program is:
I just type the web address into my browser’s location bar and press Enter...Step 1: Your user enters.
No matter what you do on the Web, it’s all about requests and responses.
A web request is sent from a web browser to a web server as the result of  some user interaction.
On the web server, a web response (or reply) is formulated and sent back to the web browser.
Step 3: The web server receives the web request and has to decide what.
Deciding what to do next One of  two things happen at this point.
If  the web request is for static content—such as an HTML file, image, or anything else stored on the web server’s hard disk—the web server locates the resource and returns it to the web browser as a web response.
If  the request is for dynamic content—that is, content that must be generated—the web server runs a program to produce the web response.
Obviously, if  all the server has to do is locate static content and sent it back to the browser, the substeps aren’t too taxing, because it’s all just file I/O.
However, when dynamic content must be generated, the substeps involve the web server locating the program to execute, executing the located program, and then capturing the output from the program as the web response…which is then sent back to the waiting web browser.
This dynamic content generation process has been standardized since the early days of  the Web and is known as the Common Gateway Interface (CGI)
Programs that conform to the standard are often referred to as CGI scripts.
What does your webapp need to do? Let’s take a moment to consider what you want your webapp to look like and how it should behave on your user’s web browser.
You can then use this information to help you specify what your webapp needs to do.
I guess I need a nice, friendly home page to kick things off, eh?
Yeah...and I want to be able to get at my times easily...
There’s nothing like grabbing your pencil and a few blank paper napkins to quickly sketch a simple web design.
You probably need three web pages: a “welcome” page, a “select an athlete” page, and a “display times” page.
Go ahead and draw out a rough design on the napkins on this page, and don’t forget to draw any linkages between the pages (where it makes sense)
There’s nothing like grabbing your pencil and a few blank paper napkins to quickly sketch a simple web design.
You probably need three web pages: a “welcome” page, a “select an athlete” page, and a “display times” page.
You were to draw out a rough design on the napkins.
You were to draw any linkages between the pages (where it made sense)
For now, all that you’ ll find here is my.
Select an athlete from this list to work with:  Sarah James Julie Mikey.
The home page displays a friendly graphic and a link to start the web app.
Click on the home page’s link to go to a page that displays a list of all the coach’s athletes.
Click on an athlete’s radio button and then the “Select” button to see the data.
The third web page displays the selected athlete’s data and provides links back to the other two pages.
Design your webapp with MVC Now that you have an idea of  the pages your webapp needs to provide, your next question should be: what’s the best way to build this thing?
The Model The code to store (and sometimes process) your webapp’s data.
The View The code to format and display your webapp’s user interface(s)
The Controller The code to glue your webapp together and provide its business logic.
By following the MVC pattern, you build your webapp in such as way as to enable your webapp to grow as new requirements dictate.
You also open up the possibility of  splitting the workload among a number of  people, one for each component.
Let’s build each of the MVC components for your webapp.
Model your data Your web server needs to store a single copy of  your data, which in this case is Coach Kelly’s timing values (which start out in his text files)
When your webapp starts, the data in the text files needs to be converted to AthleteList object instances, stored within a dictionary (indexed by athlete name), and then saved as a pickle file.
Let’s put this functionality in a new function called put_to_store()
While your webapp runs, the data in the pickle needs to be available to your webapp as a dictionary.
Let’s put this functionality in another new function called get_from_store()
The single pickle with all of the data stored in a dictionary.
The single pickle with all of the coach’s data stored in a dictionary.
Here is the outline for a new module called athletemodel.py, which provides the functionality described on the previous page.
Not shown here as it has not changed since the last chapter.
You need code in here to populate the dictionary with the data from the files.
And don’t forget to save the dictionary to a pickle (and check for file I/O errors)
This function is called with a list of filenames as its sole argument.
Get the dictionary from the file, so that it can be returned to the caller.
Here is the outline for a new module called athletemodel.py, which provides the functionality described on the previous page.
You were not to forget to protect any file I/O calls.
Not shown here as it has not changed since the last chapter.
Take each file, turn it into an AthleteList object instance, and add the athlete’s data to the dictionary.
Each athlete’s name is used as the “key” in the dictionary.
And don’t forget a try/except to protect your file I/O code.
Let’s test your code to ensure that it is working to specification.
Type your code into an IDLE edit window and save your code into a folder that also includes the coach’s text files.
Create a list of files to work with, and then call the put_to_store() function to take the data in the list of files and turn them into a dictionary stored in a pickle:
At this point, the athletes.pickle file should appear in the same folder as your code and text files.
Recall that this file is a binary file, so trying to view it in IDLE or in your editor is not going to make much sense.
Use the existing data in the data dictionary to display each athlete’s name and date of birth:
Use the get_from_store() function to load the pickled data into another dictionary, then confirm that the results are as expected by repeating the code to display each athlete’s name and date of birth:
By accessing the “name” and “dob” attributes, you can get at the rest of the AthleteList data.
The data in the returned dictionary is as expected, exactly the same as that produced by put_to_store()
View your interface With your model code written and working, it’s time to look at your view code, which creates your webapp’s user interface (UI)
If you are new to HTML, it is worth taking some time to become familiar with this critical web development technology.
There’s lots of  material on the Web and more than a few good books out there.
They’ve sent over some code that they swear will make your life easier.
It’s a small library of  HTML-generating helper functions called yate.
The code was produced quickly and was originally designed to be “throw away,” so the team has provided it as is.
Hey, we hear you are getting into web development? We have a small.
Let’s get to know the yate code before proceeding with the rest of this chapter.
For each chunk of code presented, provide a written description of what you think it does in the spaces provided:
This function takes a single (optional) string as its argument and uses it to create a CGI “Content-type:” line, with “text/html” as the default.
Let’s get to know the yate code before proceeding with the rest of this chapter.
For each chunk of code presented, you were to provide a written description of what you think it does:
Import the “Template” class from the standard library’s “string” module.
This function takes a single (optional) string as its argument and uses it to create a CGI “Content-type:” line, with “text/html” as the default.
This function takes a single string as its argument and uses at the title for the start of a HTML page.
Similar to the “include_header” function, this one uses its single string as its argument to create the end of a HTML page.
Based on how they are used, it looks like the argument needs to be a dictionary.
Open the template file (which is HTML), read it in, and substitute in the provided “title”
Open the template file (which is HTML), read it in, and substitute in the provided dictionary of HTML links in “the_links”
Turn the dictionary of links into a string, which is then substituted into the template.
This looks a little weird, but it’s an HTML hack for forcing spaces into a string.
This function returns the HTML for the start of a form and lets the caller specify the URL to send the form’s data to, as well as the method to use.
This function returns the HTML markup, which terminates the form while allowing the caller to customize the text of the form’s “submit” button.
Given a radio-button name and value, create a HTML radio button (which is typically included within a HTML form)
Given a list of items, this function turns the list into a HTML unnumbered list.
A simple “for” loop does all the work, adding a LI to the UL element with each iteration.
Enclose a paragraph of text (a string) in HTML paragraph tags.
Go ahead and grab them from the Head First Python support website, and put them into a folder of your choice.
Q: Why do I need yate at all? Why not include the HTML that I need right in the code and generate it with print() as needed?
A: You could, but it’s not as flexible as the approach shown here.
And (speaking from bitter experience) using a collection of print() statements to generate HTML works, but it turns your code into an unholy mess.
Q: And you did this because you are using MVC? A: Partly, yes.
The reason the MVC pattern is being followed is to ensure that the model code is separate from the view code, which are both separate from the controller code.
No matter the size of the project, following MVC can make your life easier.
Q: But surely MVC is overkill for something this small? A: We don’t think so, because you can bet that your webapp will grow, and when you need to add more features, the MVC “separation of duties” really shines.
With the code downloaded and tucked away in an easy-tofind folder, load the module into IDLE and press F5 to take it for a spin.
The CGI standard states that every web response must start with a header line that indictes the type of the data included in the request, which start_response() lets you control:
The default CGI response header, plus variations on a theme.
The include_header() function generates the start of a web page and let’s you customizee its title:
This all looks a little bit messy, but don’t worry; it’s meant.
The include_footer() function produces HTML that terminates a web page, providing links (if provided as a dictionary)
An empty dictionary switches off the inclusion of the linking HTML:
The argument allows you to specify the name of the program on the server to send the form’s data to.
Which one is your favorite? Select from the list of radio buttons.
The header() function lets you quickly format HTML headings at a selected level (with 2 as the default):
Again, not too easy on your eye, but fine as far as your web browser is concerned.
Last, but not least, the para() function encloses a chunk of text within HTML paragraph tags:
Control your code Your model code is ready, and you have a good idea of  how the yate module can help you with your view code.
It’s time to glue it all together with some controller code.
First things first: you need to arrange your wedapp’s directory structure to help keep things organized.
To be honest, anything goes here, although by giving it a little thought, you can enhance your ability to extend your webapp over time.
Let’s keep the coach’s data files in a separate folder by putting all of the TXT files in here.
The templates that came with the “yate.py” download can go in here.
Any code that you write for your webapp needs to reside in a specially named folder called “cgi-bin”
If your webapp has any images files (JPGs, GIFs, PNGs, and so on), pop them into their own folder to help keep things organized.
Head on over to the Head First Python support website, download webapp.zip, and unpack it to your hard disk.
Typically, CGI scripts are placed inside a special folder called cgi-bin, so that the web server knows where to find them.
On some operating systems (most notably UNIX-styled systems), CGI scripts must be set to executable before the web server can execute them when responding to a web request.
So...to run my webapp, I need a web server with CGI enabled.
Whether your running Apache, IIS, nginx, Lighttpd, or any of  the others, they all support running CGI scripts written in Python.
There’s no way the coach is going to agree to download, unpack, install, configure, and manage one of  these industry heavyweights.
As luck would have it, Python comes with its very own web server, included in the http.server library module.
Check the contents of  the webapp.zip download: it comes with a CGIenabled web server called simplehttpd.py.
Here are the five lines of code needed to build a web server in Python.Import the HTTP server and CGI modules.
I’m all fired up and ready to go! I live to serve-up HTML and run CGIs...
Display the list of athletes Let’s create a program called generate_list.py which, when executed by the web server, dynamically generates a HTML web page that looks something like this:
Select an athlete from this list to work with: Sarah James Julie Mikey.
It wouldn’t hurt to add a title to this web page, would it?
When your user selects an athlete by clicking on her radio button and clicking Select, a new web request is sent to the web server.
This new web request contains data about which radio button was pressed, as well as the name of  a CGI script to send the form’s data to.
Recall that all of  your CGI scripts need to reside in the cgi-bin folder on your web server.
With this in mind, let’s make sure your generate_list.py CGI script sends its data to another program called:
Pool Puzzle Your job is to take the code from the pool and.
You may not use the same line of code more than once.
Your goal is to make a CGI script that will generate a HTML page that matches the hand-drawn design from the previous page.
Note: each thing from the pool can be used once!
The “glob” module lets you query your operating system for a list of file names.
Use your “put_to_store()” function to create a dictionary of athletes from the list of data files.
Let’s add a link to the bottom of the generated HTML page that takes your user home.
Pool Puzzle Solution Your job was to take the code from the pool.
You were not to use the same line of code more than once.
Your goal was to make a CGI script that generates a HTML page that matches the hand-drawn design.
Start generating the form, providing the name of the serverside program to link to.
Test Drive To test drive your CGI script, you need to have a web server up and running.
The code to simplehttpd.py is included as part of the webapp.zip download.
After you unpack the ZIP file, open a terminal window in the webapp folder and start your web server:
What you need to do next depends on the operating system you’re running your web server on.
If you are running on Windows, stop reading right now and proceed to the Test Drive.
However, if you are running a Unixbased system (such as Linux, Mac OS X, or BSD) you need to.
Set the executable bit for your CGI using the chmod +x command.
Add the following line of code to the very top of your program:
Test Drive, continued With your web server running, let’s load up Coach Kelly’s home page and get things going.
It’s called “index.html” and it is included in the “webapp.zip” download.
The “timing data” hyperlink is waiting for you to click it.
Sure enough, clicking on the home page’s link runs the generate_list.py program on the web server, which displays Coach Kelly’s athletes as a list of radio buttons.
You can click the Home hyperlink to return to the coach’s home page, or select an athlete from the list (by clicking on their radio-button), before pressing the Select button to continue.
The web server is in fact telling you that it can’t locate the resource that your web browser requested, so it’s telling you that you made a mistake:
Which isn’t really that surprising seeing as you have yet to write that code! So…things aren’t as bad as they first appear.
What’s needed is the code to the other CGI script.
If you create the required CGI script, you’ll be back on track.
Tonight’s talk: To be CGI or not to be CGI, that is the question.
Listen: you’re really not all that different than me; you just work on a web server, whereas I can work anywhere.
Special?!? But you only work on the Web, nowhere else.
Nonsense! The truth is that you work only on the Web and break pretty quickly when used elsewhere.
Like [sniggers] generating text in the form of HTML? That’s really taxing…
Oh, get over yourself ! You’re a regular program, just like me.
I can generate HTML, too, I just choose not to.
Because all the cool stuff  works on the Web these days and I’m designed, optimized, tailored, and engineered for the Web.
Because the Web’s a cool place, it follows that I must be cool, too.
I have a friendly web server to take care of  that for me.
My input comes from the web server and my output goes to the web server.
This arrangement allows me to concentrate on the important stuff.
Smirk all you want; HTML makes the World Wide Web go around and I’m a master at generating it dynamically, on demand, and as needed.
Without me, the Web would be a pretty static place.
And if  you did generate HTML, you’d want it displayed somewhere…like in a browser?
And to do that you’d need to rely on the services of a friendly web server, right?
Based on your hand-drawn sketch from earlier, your need to generate a new HTML page that contains the top three times for the selected athlete:
This looks like a HTML heading for the page, right?
This might be best rendered as an unordered HTML list.
Two hyperlinks: one jumps to the home page, whereas the other returns to the previous selection page.
But how do you know which athlete is selected? When you click on a radio-button and then press the Select button, a new web request is sent to the server.
The web server arranges to send the form’s data to your CGI script as its input.
Within your code, you can access the form data using Python’s cgi module, which is part of  the standard library:
Grab all of the form data and put it in a dictionary.
Access a named piece of data from the form’s data.
It’s probably a good idea to add a title to this page.
It’s not too different from the generate_list.py code, so you should be able to reuse a lot of your existing code.Write the code to your new CGI.
It’s not too different from the generate_list.py code, so you should be able to reuse a lot of your existing code.
Turn the top three list into an unordered HTML list.
Test Drive Your web server should still be running from earlier.
In your web browser, return to the coach’s home page, then select the hyperlink to display the list of athletes, select Sarah, and then press the button.
Your CGI has suffered from a TypeError exception, but other than looking at the web server’s logging screen, it’s not clear on the web browser screen that anything has gone wrong.
What do you think is the problem here? Take a moment to study the error message before flipping the page.
Enable CGI tracking to help with errors The CGI standard dictates that any output generated by a server-side program (your CGI script) should be captured by the web server and sent to the waiting web browser.
When your CGI script raises an exception, Python arranges for the error message to display on STDERR (standard error)
The CGI mechanism is programmed to ignore this output because all it wants is the CGI script’s standard output.
This behavior is fine when the webapp is deployed, but not when it’s being developed.
Wouldn’t it be useful to see the details of  the exception in the browser window, as opposed to constantly having to jump to the web server’s logging screen?
Well…guess what? Python’s standard library comes with a CGI tracking module (called cgitb) that, when enabled, arranges for detailed error messages to appear in your web browser.
These messages can help you work out where your CGI has gone wrong.
When you’ve fixed the error and your CGI is working well, simply switch off  CGI tracking:
When your CGI fails, it’s a case of—POOF!—gone for good.
Add these two lines near the start of your CGI scripts to enable Python’s CGI tracking technology.
Press the Back button on your web browser and press the Select button again.
Notice that the CGI tracking module tries to identify exactly where the problem with your code lies.
A small change can make all the difference The CGI tracking output indicates an error with the use of  the top3() method from the AthleteList code.
A quick review of  the code to the AthleteList class uncovers the source of  the error: the top3() method has been redesignated as a class property.
Treat the top3() method as if  it was another class attribute, and call it like this:
It’s a small change, but it’s an important one When a change is made to the way a class is used, you need to be careful to consider what impact the change has on existing programs, both yours and those written by others.
At the moment, you are the only one using the AthleteList class, so it’s not a big deal to fix this.
But imagine if  thousands of  programmers were using and relying on your code…
This decorator allows you to access the data returned by “top3()” as if it were a class attribute.
Test Drive Make the small edit to your code to remove the brackets from the call to the top3() method, press your web browser’s Back button, and press the Select button one last time.
Whoo hoo! This time the selected athlete’s data is displayed on screen.
Q: What happens if the coach recruits new athletes? A: All Coach Kelly needs do is create a new text file similar to the others, and your webapp handles the rest by dynamically including the new athlete the next time your webapp runs, which occurs when someone clicks on the home page’s “timing data” hyperlink.
Q: Shouldn’t the server’s data be in a database as opposed to a pickle? Surely that would be better, right?
A: In this case, it’s probably overkill to use a database, but it might be worth considering sometime in the future.
Now that you’ve solved that problem, be sure to switch off CGI tracking.
This is great! Now I can share my data with the kids, and they can access their times without bugging me...
Hey, this is super cool and the coach is right...
By moving your program to the Web, you’ve made it a no-brainer for Coach Kelly to share his data with not only his athletes, but with anyone else that needs to access his data.
By conforming to the MVC pattern and using CGI, you’ve built a webapp in such a way that it’s easy to extend as new requirements are identified.
Your Python Toolbox You’ve got Chapter 7 under your belt and you’ve added some key Python techiques to your toolbox.
The standard library string module includes a class called Template, which supports simple string substitutions.
The standard library http.server module can be used to build a simple web server in Python.
The standard library cgi module provides support for writing CGI scripts.
The standard library glob module is great for working with lists of filenames.
Set the executable bit with the chmod +x command on Linux and Mac OS X.
The standard library cgitb module, when enabled, lets you see CGI coding errors within your browser.
Use cgitb.enable() to switch on CGI tracking in your CGI code.
This had better be a smartphone running Honeycomb or Mr.
Putting your data on the Web opens up all types of  possibilities.
Not only can anyone from anywhere interact with your webapp, but they are increasingly.
And it’s not just humans interacting with your webapp that.
The world is getting smaller Coach Kelly is continuing to use his webapp every day, but he’s having a problem with his new smartphone.
I can access my timing data over WiFi on my phone, but it’s so small it’s all but impossible to read, let alone click on links or buttons.
Can you take a look at it for me? Gotta dash.
Who knew that your users would try to interact with your webapp using something other than a desktop computer or laptop?
Coach Kelly is on Android The coach has a lovely new smartphone that’s running Google’s Android operating system.
Sure enough, when you check it out, the webapp is way too small and not much use on the coach’s three-inch screen:
And don’t go telling me to do all that twofingered zoom and doubletapping thing.
Obviously, the coach needs to access his data and run his webapp on his phone…but what’s the best way to do this if  not through the phone’s browser?
Open your web browser on your desktop computer (or phone) and enter “Python for Android” into your favorite search engine.
Make a note in the space below of the most promising site from your search results:
Run Python on the coach’s smartphone A quick search of  the Web uncovers a pleasent surprise: Python runs on Android.
A project called Scripting Layer for Android (SL4A) provides technology to let you run Python on any Android device.
Python 3, this book’s preference, is the best version of Python yet, but it achieves its greatness at the cost of  a lack of  backward compatibility.
You were to open your web browser on your desktop computer (or phone) and enter “Python for Android” into your favorite search engine.
You were then to make a note in the space below of the most promising site from your search results:
I’m quite happy to run Python 3 all day long...
Set up your development environment Understandably, the coach won’t let your have his phone to work on until you have something that works.
Thankfully, Google provides a cross-platform Android emulator that lets you develop for the phone as needed, even though you don’t own any hardware.
Visit this website and download the SDK for your computer and operating system:
Follow along with these instructions to ensure you have your Android development environment correctly set up on your computer.
Despite what this website might look like it’s telling you, you do not need to install Eclipse to run the Android emulator.
However, you do need to have a Java Runtime Environment installed.
If  you are unsure about this, don’t worry: the Android emulator will advise your best course of  action if  it spots that Java is missing.
Note: This is how the Android SDK download page looks at the time of this writing.
No worries: just download the latest version of the SDK.
Configure the SDK and emulator You need to do two things to configure the SDK and emulator: add an Android Platform and create an Android Virtual Device (known as an AVD)
Create a new Android Virtual Device (AVD) With the 2.2 platform downloaded and installed, create a new Android Virtual Device.
This might take a minute or two, depending on the speed of your network connection.
Set the size of the virtual SDcard: 512 is more than enough.
This is the only version of the SDK that you need.
Install and configure Android Scripting With the emulator ready, use the AVD Manager to start your 2.2 device.
Click on the emulator’s browser (the little globe), surf  to this web address:
On the emulator, tap on the “boxed” bar code to start the SL4A download.
The version available to you might be different, but don’t worry: download the latest release.
Just be sure to enable “Unknown sources” to allow for non-Market application downloads.
Add Python to your SL4A installation Return to the emulator’s web browser, double-tap on the screen to zoom in, and select the Downloads tab.
Again, the version you see might be different than this.
When you are ready, tap Open -> Install to complete the installation.
This downloads, extracts, and installs the Python support files for Android, which can take a few minutes to complete.
When it does, Python 2.6.2 and Python for Android are installed on your emulator and ready for action.
Test Python on Android Return to your emulator’s main screen and find an app called SL4A added to your list of  app icons.
Tap this app to display the list of  Python scripts preinstalled with Python for Android.
Take your Android emulator for a spin Here’s a four-line Python script that you can create to test your installation.
Import the “android” library and create a new app object instance.
To transfer your script to the emulator, you need to copy it to the emulator’s virtual SD card.
Another program within the tools folder called adb helps with this:
Issue this command at your terminal window to transfer your script to the emulator.
Your script should now appear on the list of  scripts available to SL4A.
Be sure to set the SL4A rotation mode to automatic.
Test Drive Let’s confirm that your Android setup is working.
With the SL4A app open, simply tap on your script’s name to run it, and then click the run wheel from the menu.
Your Android emulator with SL4A is working, and it’s running your Python code.
Define your app’s requirements Let’s think a little bit about what your Android app needs to do.
Frank: Well…first off, the view code no longer has to generate HTML, so that makes things interesting.
Jill: In fact, you need the web server only to supply your data on request, not all that generated HTML.
Just send the pickle with all the data from the server to the Android phone.
You’ll certainly be able to send the pickle to the phone, but the phone’s Python won’t be able to work with the data in the pickle.
Joe: Hey, good idea: just send the data as one big string and parse it on the phone.
Jill: No, that’s a potential disaster, because you never know in what format that stringed data will arrive.
You need an data interchange format, something like XML or JSON.
I think they use it in lots of  different places on the Web, especially with AJAX.
In fact, you don’t even need to worry about understanding JSON at all; you just need to know how to use it.
And, guess what? JSON comes standard with Python JSON on the web server and on the phone.
Frank & Joe: Bonus! That’s the type of  technology we like!
Always willing to play my part in whatever way I can.
JSON: Oh, I’m just one of  the most widely used data interchange formats on the Web.
When you need to transfer data over the Internet, you can rely on me.
The “JS” in JSON stands for “JavaScript” and the “ON” stands for “Object Notation.” See?
JSON: The first two letters are the key ones: I’m a JavaScript standard, which means you’ll find me everywhere JavaScript is…which means I’m in every major web browser on the planet.
JSON: That’s where the other two letters come into play.
Because I was initially designed to allow JavaScript data objects to be transferred from one JavaScript program to another, I’ve been extended to allow objects to be transferred regardless of  what programming language is used to create the data.
By using the JSON library provided by your favorite programming language, you can create data that is interchangeable.
If  you can read a JSON data stream, you can recreate data as you see fit.
Python, use JSON to convert it to JSON’s object notation, and then send the converted data to another computer running a program written in C#?
There’s plenty of  reasons to use different programming languages for different reasons.
Head First: You know something…I think it might well have been! [laughs]
JSON: Yes! And that’s exactly my point: when you need a language-neutral data interchange format that is easy to work with, it’s hard to pass me by.
Head First: But how can you be “language neutral” when you have JavaScript in your name?
It’s what they called me when the only language I supported was JavaScript, and it kinda stuck.
Head First: So they should really call you something else, then?
I spent all that time learning to use pickles and now you’re abandoning them in favor of this “JSON” thing.
The JSON technology is a better fit here for a number of  reasons.
First of  all, it’s a text-based format, so it fits better with the way the Web works.
And third, because JSON is language-neutral, you open up the possibility of  other web tools written in other programming languages interacting with your server.
The JSON API is not that much different to the one used by pickle:
Transform the Python list-of-lists into a JSON list of lists.
Transform the JSON list of lists back into one that Python understands.
The new data is exactly the same as the original list of lists.
Add a new function to the athletemodel module that, when called, returns the list of athlete names as a string.
You were to add a new function to the athletemodel module that, when called, returns the list of athlete names as a string.
So...rather than running a CGI script to create a HTML web page, you want me to deliver just the data, right? That’s OK.
Not a problem—just be sure to tell me which script to run...
Whether you need a web page or just your data, you can count on me to get the job done.
Don’t forget this “magic” first line if you’re running on Linux or Mac OS X.
Get the data from the model.Start with the appropriate “Content-type”: line.
The behavior you see when testing your JSONgenerating CGI script will differ depending on the web browser you are using.
For instance, Firefox might attempt to download the generated data as opposed to display it on screen.
When you’re ready, grab your favorite web browser and take your new CGI for a spin.
Hey! It looks like the coach has added two new athletes.
The web server’s logging information confirms that the CGI executed.
Now all you have to do is arrange for the Android emulator to request the data within a Python script and display the list of  names on the smartphone’s screen.
Recall the code from earlier, which demonstrated a minimal Android SL4A app:
Import the “android” library and create a new app object instance.
Six calls to the Android API let you create a list of  selectable items in a dialog, together with positive and negative buttons, which are used to indicate the selection your user made.
Note how each of  the calls to the Android “dialog” API results in something appearing on screen.
Android Code Magnets Here is the code to a program that queries your web server for the list of names as a JSON array and then displays the list on the smartphone.
The only trouble is, the second half of the program is a bunch of mixed-up code magnets at the bottom of the screen.
Your job is to rearrange the magnets to complete the program.
Do the usual imports…these ones pull in web client functionality.
Change this to the web address that’s running your web server.
The name of the CGI script to run on the web server This function takes both a web address (url) and some optional data (post_data) and sends a web request to your web server.
Android Code Magnets Solution Here is the code to a program that queries your web server for the list of names as a JSON array and then displays the list on the smartphone.
The only trouble is, the second half of the program is a bunch of mixed-up code magnets at the bottom of the screen.
Your job was to rearrange the magnets to complete the program.
This is a little function for displaying short messages on the phone.
Send the web request to your server, then turn the JSON response into a sorted list.
Create a two-buttoned dialog from the list of athlete names.
Wait for the user to tap a button, then assign the result to “resp”
Test Drive Recall that (for now)  your Android Python scripts run within the emulator, not within IDLE.
So use the tools/adb program to copy your program to the emulator.
When the code is copied over, start SL4A on your emulator, and then tap your script’s name.
This is looking really good! Your app has communicated with your web server, requested and received the list of  athlete names, and displayed the list on your emulator.
Run your app again in the Python terminal by tapping on the little terminal icon to the left of  the “run wheel” within SL4A.
If  your code raises an error, you’ll see any messages on the emulator’s screen, which should give you a good idea of  what went wrong.
In your code, you can check the value of  resp, which is a dictionary, and the which key is set to either positive or negative.
So…if  the positive button is tapped, you can index into the list of  athlete names to see which athlete was selected from the displayed list.
You can use this behavior in the next version of your code.
Provide the code (which includes a call to  thensend_to_ server() function) to implement this functionality:
Additionally, write the code required to display the list of times returned from the server within an Android dialog.
Hints: Use the dialogSetItems() method from the Android API to add a list of items to a dialog.
Also, remember that the data arriving over the Internet will be formatted using JSON.
You were to provide the code (which includes a call to the send_to_server() function) to implement this functionality:
Additionally, you were to write the code required to display the list of times returned from the server within an Android dialog:2
Send the request to the web server, together with the athlete name.
When your user taps the “positive” button…work out the index value chosen.
The index value is in the first element of the list of results returned from the dialog.Look up the.
Send a new web request to the server to fetch the athlete’s data.
The user needs to see only the data this time, so you need to use “dialogSetItems()”
Process the data sent with the request and extract the athlete’s name.
Start a web response, with JSON as the data type.
Include the indicated athlete’s data in the web response, formatted by JSON.The complete Android app, so far.
You’ve made quite a few changes to your program at this stage.
Before you test it on the Android emulator, take a moment to look at your code in its entirety:
The rest of your code is on the following page.
Test Drive Let’s give the latest version of your app a go.
Copy the app to your emulator, and put the new CGI script in your cgi-bin folder on your web server (remember to set the executable bit, if needed)
What happens when you run your latest app using the emulator’s Python shell as opposed to the “run wheel”?
Yikes! Your code has a TypeError, which is crashing your app when you try to display the selected athlete’s timing data.
You are dumped into the Python shell with a rather nasty error message.
After reading the error message, click “Yes” to return to the SL4A script listing.
Look at the CGI code...it gets the data from the model and sends it to the web browser...
Let’s add a debugging line of  code to your CGI script to try and determine what’s going on.
Recall that the CGI mechanism captures any output your script sends to standard output by default, so let’s use code like this to send your debugging messgage to the web server’s console, which is displaying on standard error:
Redirect the output from “print()” to “stderr”, rather than the default, which is “stdout”
Run your app again and, of  course, it’s still crashes with a TypeError.
However, if  you check your web server’s console screen, you’ll see that the data being sent as the JSON web response is clearly visible.
This is a list of athlete timing values…but where’s the name and DOB values?
This means that the standard library’s JSON library can work with Python’s built-in types, but not with your AthleteList objects.
The solution to this problem is straightforward: add a method to your AthleteList class to convert your data into a dictionary, and send that back to the app.
Be sure to decorate your new method with @property, so that it appears to be a new attribute to users of your class.
If you think about things, your to_dict() method doesn’t change the state of your object’s data in any way: it merely exists to return the object’s attribute data as a dictionary.
Users of your class (that is, other programmers) don’t need to know that when they access the to_dict attribute they are in fact running a method.
All they see is a unified interface: attributes access your class’s data, while methods manipulate it.
Be sure to decorate your new method with @property, so that it appears to be a new attribute to users of your class.
As well as updating your AthleteList class code, be sure to change cgi-bin/ generate-data.py to return a dictionary, rather than the object instance, when servicing its web request.
While you’re making changes, adjust the coachapp.py app code to include the athlete’s name and DOB values in the second dialog’s title.
Here’s the code that your app uses in response to an athlete selection.
Your app displays the selected athlete’s top three times on screen.
Run your app on a real phone Now that your app is running successfully on your emulator, it’s time to try it on a real phone.
There are many options when it comes to copying your code to a real device:
Unfortunately, which technique to use (and which work) depends very much on your phone.
At Head First Labs, we’ve had the greatest and most consistent success with the last option: use a file transfer tool over WiFi.
Step 1: Prepare your computer To transfer files securely between your Android phone and your computer, enable SSH file transfers by running an SSH server on your computer.
How you do this depends on the operating system you are running:
Step 2: Install AndFTP on your Android phone Use the Android Market on your phone to find and install the AndFTP app.
This excellent tool lets you transfer files to and from your Android phone over FTP, SFTP, and FTPS.
To use it with the SSH server running on your computer, you’ll want to select SFTP as the file transfer protocol within the app, because AndFTP defaults to using the FTP protocol.
The Android emulator does not currently support Google’s Android Market, which you’ll need access to use when following along with the instructions on these pages.
With the connection set up, tap AndFTP’s Connect button to establish a connection to your SSH server, entering your Username and Password when prompted.
With the connection to the server established, navigate to the server folder containing the file(s) you want to transfer to the phone, mark the files for download, and tap the Download button.
When the download completes, click Disconnect to terminate the connection between the phone and your computer.
If  you transferred a Python program, it should now be added to the list of  scripts within SL4A.
Configure AndFTP With AndFTP running on your phone, configure it to connect to your computer (Hostname) using SFTP as the transfer protocol (Type)
Change this entry to be the web name or address of your SSH server.
Welcome to the future! You’ve delivered a solution that automates interaction with your website while providing a modern interface on an Android phone.
Your app allows your users to access web data directly on their mobile device.
All that’s left to do is write some code to satisfy Coach Kelly’s latest request, and you’ll get to that in the next chapter.
Your Python Toolbox You’ve got Chapter 8 under your belt and you’ve added some key Python techiques to your toolbox.
The json library module lets you convert Python’s built-in types to the textbased JSON data interchange format.
Use json.dumps() to create a stringed version of a Python type.
Use json.loads() to create a Python type from a JSON string.
Data sent using JSON needs to have its Content-Type: set to application/json.
The Web and your phone are not just great ways to display data.
They are also great tools to for accepting input from your users.
We love what you did for Coach Kelly, but it would be great if we could add times for an athlete no matter where we are.
The National Underage Athletics Committee (NUAC) took one look at your Android app and realized it’s just what they need…almost.
There are many ways to improve your webapp, but for now, let’s concentrate on the committee’s most pressing need: adding a new time value to an existing athlete’s data set.
Adding new data to text files isn’t going to work: there are just too many coaches around the country adding data.
The committee wants something that’s user friendly from any web browser or Android phone.
On the Web, your user interacts with your web form and enters data.
When she presses the submit button, the web browser gathers up all of  the form’s data and sends it to the web server as part of  the web request.
On your Android phone, you can use the dialogGetInput() method to get input from the user, then mimic the behavior of  the web form’s submit button in code.
In fact, you’ve done this already: check out this line of  code from your coachapp.py app, which sends the selected athlete name to your web server:
Here’s where the data is included with the web request.
Create an HTML form template Let’s extend yate.py to support the creation of  a HTML form.
Take a look a this simple form, together with the HTML markup used to produce it.
The name of the CGI script to send the form’s data to.
Click the “Send” button to submit the form’s data to your web server.
When your user clicks on the Send button, any data in the input area is sent to the web server as part of  the web request.
On your web server, you can access the CGI data using the facilities provided by the standard library’s cgi module:
Get the data sent from the form as part of the web request.
The cgi module converts the data associated with the web request into a dictionary-like object that you can then query to extract what you need.
Let’s turn the HTML form from the previous page into a template within the yate.py module.
With the template ready, write the code for two functions you intend to add to yate.py.
The name of the CGI script and a list of <INPUT> tag names are required arguments.
The HTTP method and text to the “Submit” button have sensible default values.
Substitute the arguments and generated <INPUT> tags into the template to create the form.
You were to turn the HTML form into a template within the yate.py module.
With the template ready, you were to write the code for two functions to add to yate.py.
The CGI script’s name and associated HTTP method are parameterized.
The list of <INPUT> tags and the submit button’s text is also parameterized.
This “continuation” character lets you split a long line of code over multiple lines.
Set the executable bit (if required on your OS) using chmod + x test_form.py , and then  use your browser to confirm that your HTML form-generating code is working.
Enter the URL for the CGI script into your web browser’s location bar.
Use your browser’s “View Source” menu option to confirm that the generated form is exactly what you need.
You’ve extended yate.py to support the creation of  a simple data entry form.
Now all you need to do is to decide what happens once the data arrives on your server.
The data is delivered to your CGI script In addition to running your webapp, the web server also arranges to deliver any submitted form data to your waiting CGI script.
Python’s cgi library converts the data into a dictionary and, as you already know, provides you with convenient access to the submitted data:
Additional information about the web request is also available to you via the web server’s environment.
Typically, you won’t need to access or use this data directly.
However, occasionally, it can be useful to report on some of  it.
Here is some code that takes advantage of  Python’s built-in support for querying your CGI script’s environment using the os library, assuming the environment values have been set by a friendly web server.
Note that the data in the enviroment is available to your code as a dictionary.
Let’s exploit both code snippets on this page to log the data sent from a form to your web server’s console.
When you are convinced that the data is arriving at your web server intact, you can extend your code to store the received data in your model.
All of your form’s data has been added to the “form” dictionary.
Be sure to include the “os” library in your list of imports.
Query three environment variables and assign their values to variables.
The CGI needs to query the environment, arranging to display the logged data on one line.
The code exists, but most of it is all over the floor.
Don’t forget this line if you are running on Max OS X or Linux.
There’s not much of a response for now…so just send back plain text to the waiting web browser.
The CGI needs to query the environment, arranging to display the logged data on one line.
The code exists, but most of it is all over the floor.
You were to rearrange the magnets to produce a working program.
Ensure that this “print()” function does NOT take a newline.
As you enter data in the form and press the Send button, watch what happens on the web server’s console.
The data entered into the form is delivered to your CGI script on the your server.
Your next challenge is to provide the same user input experience on an Android phone.
The web server’s logging screen displays the data that arrived, as well as the name associated with it.
Ask for input on your Android phone When you ask for user input on Android, the dialog that your user sees looks something like this example, which asks your user to confirm or change the web address and port for your server.
A space for data entry, when tapped, bring ups the “soft” keyboard.
A single Android call creates this interface for you using the dialogGetInput() method:
Pressing the Ok button sets resp to the data entered into the input area.
Pressing the Cancel button sets resp to None, which is Python’s internal null-value.
The result of your user’s interaction with the dialog is assigned to “resp”
Let’s create a small Android app that interacts with your user twice.
The first dialog asks the user to confirm the web address and port to use for the web server.
Assuming your user taps the OK button on your dialog, a second dialog pops up to request the timing value to send to the server.
As with the first dialog, tapping the OK button continues execution by sending the newly acquired timing value to the web server.
Tapping Cancel at any time causes your app to exit.
There’s nothing new here…you’ve seen all of this code before.
You were to create a small Android app that interacts with your user twice.
The first dialog asks the user to confirm the web address and port to use for the web server.
Assuming your user taps the OK button on your dialog, a second dialog pops up to request the timing value to send to the server.
As with the first dialog, tapping the OK button continues execution by sending the newly acquired timing value to the web server.
Tapping Cancel at any time causes your app to exit.
Your job was to complete the program by writing the code you think you need under this code and call your program get2inputsapp.py.
The first dialog asks your user to confirm the web address and port to use.
Test Drive Let’s copy get2inputsapp.py to the emulator using the adb tool:
Your new app starts, and you can edit the web server address and port.
When you click on the input area, Android’s “soft” keyboard pops up.
The web server’s log confirms the data was sent from your emulator.
Regardless of  where your data originates—on the Web or a phone—your app can send it to your web server.
If  you update the appropriate athlete’s text file, the data in the pickle will be stale until put_to_store() runs again.
If another process calls the get_from_store() function in the meantime, the update to the pickle might not have been applied and will appear to be missing for anyone reading your data.
Oh, look, how lovely: I have a new timing value to add to the system.
Of course...I could write to the text file and then immediately call.
Yes, that’s one possible solution, but it’s a poor one.
These types of  situations are known as race conditions and are hard to debug when they occur.
It’s best to keep them from ever happening if  you can.
The basic problem here is that you have one update with one piece of  data that results in two file interactions.
You need a better data storage mechanism Your initial text files and pickle design is fine when only one user is accessing the data.
However, now that more than one person can access the data at any time, and from anywhere, your design is in need of  improvement.
Q: Surely you should have thought about this problem long ago and designed this “properly” from the start?
A: That’s certainly one way to look at things, and hindsight is always a wonderful thing! However, programs have a tendency to start out small, then grow to provide more features, which can introduce complexity.
Recall that the coach’s app started life as a simple “standalone” text-based program, which was then moved to the Web to support multiple users.
Part of the app was then redeveloped for use on an Android phone.
And yes, if we’d known all of this ahead of time, we might have been designed it differently.
Q: So I’m facing a rewrite of large chunks of my code? A: Let’s see.
You did build your program using the MVC pattern, and you are using Python, so those two facts should take the sting out of any potential rewrite, assuming a rewrite is what’s required here.
Wouldn't it be dreamy if I could put my data in only one place and support all my app’s requirements? But I know it's just a fantasy...
Use a database management system You need to move away from your text file and pickle combination and use a real database management system.
If you want rocksolid without the corporate bloat, it has to be PostgreSQL.
All of  these fine technologies will work, but they are overkill for your app’s data requirements.
And besides some of  these are way beyond the NUAC’s budget, let alone their ability to set up, run, and maintain such a system.
What you need is something that’s effectively hidden from the NUAC yet lets you take advantage of  what a database management system has to offer.
To use SQLite, simply import the sqlite3 library and use Python’s standardized database API to program it.There’s really nothing to it: no database setup, no config, and no ongoing maintenance.
With your data stored in SQLite, rewrite your webapp’s model code to use SQL to access, manipulate, and query your data.
You can plan to move to one of  the bigger database systems if  and when your application needs dictate such a move.
The material in this chapter assumes you are comfortable with SQL database technology.
If you are new to SQL (or just need a quick refresher), take a look at Head First SQL, which comes highly recommended.
Exploit Python’s database API The Python Database API provides a standard mechanism for programming a wide variery of  database management systems, including SQLite.
The process you follow in your code is the same regardless of  which back-end database you’re using.
Connect Establish a connection to your chosen database back end.
Create Create a cursor to communicate through the connecton to your data.
Commit Tell your connection to apply all of  your SQL manipulations to your data and make them permanent.
Rollback Tell your connection to abort your SQL manipulations, returning your data to the state it was in before your interactions started.
The database API as Python code Here’s how to implement an interaction with a database using the sqlite3 module:
Depending on what happens during the Interact phase of  the process, you either make any changes to your data permanent (commit) or decide to abort your changes (rollback)
It is also possible to interact with you SQLite data from within IDLE’s shell.
Whichever option you choose, you are interacting with your database using Python.
It’s great that you can use a database to hold your data.
But what schema should you use? Should you use one table, or do you need more? What data items go where? How will you design your database?
This disk file is used to hold the database and its tables.
A little database design goes a long way Let’s consider how the NUAC’s data is currently stored within your pickle.
Each athlete’s data is an AthleteList object instance, which is associated with the athlete’s name in a dictionary.
The pickled dictionary has any number of AthleteLists within it.
With this arrangement, it is pretty obvious which name, date of  birth, and list of  times is associated with which individual athlete.
But how do you model these relationships within a SQL-compliant database system like SQLite?
You need to define your schema and create some tables.
Define your database schema Here is a suggested SQL schema for the NUAC’s data.
The first table, called athletes, contains rows of  data with a unique ID value, the athlete’s name, and a date-of-birth.
The second table, called timing_data, contains rows of  data with an athlete’s unique ID and the actual time value.
This is a new attribute that should make it easy to guarantee uniqueness.
Note how this schema “links” the two tables using a foreign key.
There can be one and only one row of  data for each athlete in the athletes table.
For each athlete, the value of  id is guaranteed to be unique, which ensures that two (or more) athletes with the same name are kept separate within the system, because that have different ID values.
What does the data look like? If  the two tables were created and then populated with the data from the NUAC’s text files, the data in the tables might look something like this.
This is what the data in the “athletes” table might look like, with one row of data for each athlete.
This is what the data in the “timing_data” table might look like, with multiple rows of data for each athlete and one row for each timing value.
If  you create these two tables then arrange for your data to be inserted into them, the NUAC’s data would be in a format that should make it easier to work with.
Looking at the tables, it is easy to see how to add a new timing value for an athlete.
Simply add another row of  data to the timing_data table.
Need to add an athlete? Add a row of  data to the athletes table.
Want to know the fastest time? Extract the smallest value from the timing_data table’s value column?
SQLite Magnets Let’s create a small Python program that creates the coachdata.
Rearrange the magnets at the bottom of the page to complete it.
SQLite Magnets Solution Your job was to create a small Python program that creates the coachdata.sqlite database with the empty athletes and timing_data tables.
The code you needed was almost ready, and you were to rearrange the magnets at the bottom of the page to complete it.
The commit isn’t always required with most other database systems, but it is with SQLite.
Transfer the data from your pickle to SQLite As well as writing the code to create the tables that you need, you also need to arrange to transfer the data from your existing model (your text files and pickle combination) to your new database model.
You can add data to an existing table with the SQL INSERT statement.
Assuming you have data in variables called name and dob, use code like this to add a new row of  data to the athletes table:
The data in these variables is substituted in place of the “?” placeholders.
You don’t need to worry about supplying a value for.
Get the athlete’s name and DOB from the pickled data.
Use the INSERT statement to add a new row to the “athletes” table.
What ID is assigned to which athlete? You need to query the data in your database table to work out which ID value is automatically assigned to an athlete.
Here’s a small snippet of code to show you how to use it with Python, assuming the name and dob variables have values:
Again, the placeholders indicate where the data values are substituted into the query.
If  the query succeeds and returns data, it gets added to your cursor.
You can call a number of  methods on your cursor to access the results:
Each of these cursor methods return a list of rows.
Names alone are not enough anymore...if you want to uniquely identify your athletes, I need to know their IDs.
Insert your timing data You’re on a roll, so let’s keep coding for now and produce the code to take an athlete’s timing values out of  the pickle and add them to your database.
Specifically, you’ll want to arrange to add a new row of  data to the timing_data table for each time value that is associated with each athlete in your pickle.
Those friendly coders over at the Head First Code Review Team have just announced they’ve added a clean_data attribute to your AthleteList class.
When you access clean_data, you get back a list of  timing values that are sanitized, sorted, and free from duplicates.The Head First Code Review Team has excellent timing; that attribute should come in handy with your current coding efforts.
Grab your pencil and write the lines of code needed to query the athletes table for an athlete’s name and DOB, assigning the result to a variable called the_current_id.
Write another query to extract the athlete’s times from the pickle and add them to the timing_data table.
Again, it’s OK to assume in your code that the “name” and “dob” variables exist and have values assigned to them.
You were to grab your pencil and write the lines of code needed to query the  athletes table for an athlete’s name and DOB, assigning the result to a variable called the_current_id.
You were then to write another query to extract the athlete’s times from the pickle and add them to the timing_data table.
It often makes sense to split your execute statement over multiple lines.
Add the ID and the time  value to the “timing_data” table.
Take each of the “clean” times and use it, together with the ID, within the SQL “INSERT” statement.
Rename your program initDBtables.py, now that both the athletes and timing_data tables are populated with data by a single program.
Rather than running these programs within IDLE, let’s use the Python command-line tool instead.
Hello? Something happened there, didn’t it? I ran the programs but nothing appeared on screen...how do I know if anything worked?
SQLite data management tools When it comes to checking if  your manipulations of  the data in your database worked, you have a number of  options:
Write more code to check that the database is in the state that you expect it.
Which can certainly work, but is error-prone, tedious, and way too much work.
Simply type sqlite3 within a terminal window to enter the SQLite.
The tool is a little basic (and cryptic), but it works.
There are lots of  these; just Google “sqlite database browser” for more choices than you have time to review.
Our favorite is the SQLite Manager, which installs into the Firefox web browser as an extension.
Great, all of the athletes are in the “athletes” table.
But how do you integrate your new database into your webapp?
We just have to rewrite the code in athletemodel.py to use the database, while keeping the API the same.
Frank: What do you mean by keeping the API the same?
It returns an AthleteList dictionary, so we need to make sure that when we update get_from_store() to use our database that it continues to return a dictionary, just as it’s always done.
Frank: Ah, now I get it: we can query the database, grab all the data, turn it into a big dictionary containing all of  our AthleteList objects and then return that to the caller, right?
Joe: Yes, exactly! And the best of  it is that the calling code doesn’t need to change at all.
Jim: You are bending over backward to maintain compatibility with an API that exists only because of  the way your data model was initially designed.
Now that you’ve reimplemented how your data is stored in your model, you need to consider if  you need to change your API, too.
If  we can simplify the API by redesigning it to better fit with our database, then we should.
So...we just need to change our model code to use SQLite...but.
Let’s spend some time amending your model code to use your SQLite database as opposed to your pickle.
Take a pencil and strike out the lines of code you no longer need.
Let’s spend some time amending your model code to use your SQLite database as opposed to your pickle.
You were to take a pencil and strike out the lines of code you no longer need.
None of this code is needed anymore, because SQLite provides the data model for you.
You still need the list of names Throwing away all of  your “old” model code makes sense, but you still need to generate a list of  names from the model.
Your decision to use SQLite is about to pay off: all you need is a simple SQL SELECT statement.
I guess in this case it actually makes perfect sense to maintain the API for this call.
Get an athlete’s details based on ID In addition to the list of  names, you need to be able to extract an athlete’s details from the athletes table based on ID.
A new function gets the data associated with a specific ID.
Note the use of the placeholder to indicate where the “athlete_id” argument is inserted into the SQL SELECT query.
Get the “name” and “DOB” values from the athletes table.
It still follows the API used with working with data stored in SQLite.
With the model code converted, you can revisit your CGI scripts to use your new model API.
But how does the web browser or the phone know which ID to use when all it has to work with are the athletes’ names?
That’s a good point: which ID do you use? Your current CGIs all operate on the athlete name, not the ID.
In order to ensure each athlete is unique, you designed your database schema to include a unique ID that allows for your system to properly identify two (or more) athletes with the same name, but at the moment, your model code doesn’t provide the ID value to either your web browser or your phone.
One solution to this problem is to ensure that the athlete names are displayed to the user within the view, while the IDs are used internally by your system to unique identify a specific athlete.
Rather than amending this code, you were to create a new function, called get_namesID_from_ store(), based on this code but including the ID values as well as the athlete names in its response.
You were to write your new function in the space provided.
Arrange to include the value of “id” in the SQL “SELECT” query.
There’s no need to process “results” in any way…assign everything returned from the query to “response”
Part 1: With your model code ready, let’s revisit each of your CGI scripts to change them to support your new model.
At the moment, all of your code assumes  that a list of athlete names or an AthleteList is returned from your model.
Grab your pencil and amend each CGI to work with athlete IDs where necessary.
This “Sharpen” is continued on the next page, but no peeking! Don’t flip over until you’ve amended the code on this page.
Part 2: You’re not done with that pencil just yet! In addition to amending the code to the CGIs that support your web browser’s UI, you also need to change the CGIs that provide your webapp data to your Android app.
Part 1: With your model code ready, you were to revisit each of your CGI scripts to change them to support your new model.
At the moment, all of your code assumes that a list of athlete names or an AthleteList is returned from your model.
You were to grab your pencil and amend each CGI to work with athlete IDs where necessary.
The rest of this “Sharpen Solution” is on the next page.
The “athletes” are now a list of lists, so amend the code to get at the data you need.
It looks like you might need a slightly different “radio_ button()” function?!?
Get the athlete’s data from the model, which returns a dictionary.
Use the returned data as needed, accessing each of the dictionary key/values to get at the athlete’s data.
Part 2: You weren’t done with that pencil just yet! In addition to amending the code to the CGIs that support your web browser’s UI, you also needed to change the CGIs that provide your webapp data to your Android app.
The tiniest of changes need to be made to these CGIs, because your Android app is only interested in your webapp’s data, NOT all of that generated HTML.
Add this code to “yate.py” to support the creation of radio buttons that provide a value for the button that differs from the button text.
A third argument lets you specify an ID to go with the radio button.
Test Drive Before you run your amended webapp, be sure to move you SQLite database into the top-level directory of your webapp (that is, into the same folder your index.html file)
That way, your model code can find it, so move it into your webapp’s root folder now.
Display the list of athlete names as radio buttons.And there’s Sally’s timing.
You need to amend your Android app, too Unlike your HTML-based webapp, where all of  your code resides and is executed on your web server, your Android app runs on your phone and it is programmed to work with a list of  names, not a list of  names and athlete IDs.
This is weird…instead of the names, your app is displaying a list of lists!
And if you tap “Select”, your app crashes with a “ValueError”
Just like with the CGI scripts, you need to amend you Android app to work with the data that’s now arriving from your web server—that is, a list of  lists as opposed to a list.
Here is your current coachapp.py code, which you need to amend to support the way your webapp’s model now works.
Grab a pencil and make the necessary changes to this code.
There is no change to this code from the previous chapter.
There is no change to this code from the previous chapter.
Here is your current coachapp.py code, which you need to amend to support the way your webapp’s model now works.
You were to grab a pencil and make the necessary changes to this code.
There is no change to this code from the previous chapter.
There is no change to this code from the previous chapter.
Extract the athlete names ONLY from the list of lists.
A small adjustment to next line is needed to access the “top3” attribute.
Android Pool Puzzle Your job is to take the code from the pool and place it into.
Your goal is to write the code to have your app provide the user with a mechanism to add a timing value to the server for the currently selected athlete.
Hint: the code from get2inputsapp.py (from earlier in this chapter) should come in handy here.
Provide a new timing value ' + athlete['Name'] + ': '
Add another button to the existing dialog in the current version of your app.
If some input is supplied, send it to the web server together with the athlete’s ID.
Define the dialog’s titles and specify the CGI to send the data to.
Android Pool Puzzle Solution Your job was to take the code from the pool and place it.
Your goal was to write the code to have your app provide the user with a mechanism to add a timing value to the server for the currently selected athlete.
Hint: the code from get2inputsapp.py (from earlier in this chapter) should come in handy here.
Test Drive Use the tools/adb command to copy your latest app to the emulator, and give your app a go.
Great: your data is sent from your Android app to your web server.
At this point, it’s a trivial exercise, because a single SQL INSERT statement will do the heavy lifting.
Get the data sent to your web browser from your Android app.
With this version of  your CGI script running on your web server, any new times entered by anyone on an Android phone are added to the data in the database.
The NUAC no longer has to worry about adding data to text files, because the files are effectively obsoleted by the use of  SQLite.
You’ve produced a robust solution that is more manageable, scalable, programmable, and extendable.
And it’s all thanks to the power of  Python, it’s database API and the inclusion of  sqlite3 in the standard library.
All that’s left to do is sit back, relax and bask in the glory of your latest programming creation…
The NUAC is over the moon! Of  course, your use of  SQLite gives you more than just easy insertions of  data.
With the NUAC’s data in tables, it’s easy to answer some of  the questions that have been on their mind.
With our data in a database, it’s a breeze to.
And if we need to know who had the fastest time, that’s easy, too.
This is just great! I can get instant answers to my many questions in the blink of an eye.
To answer these and other queries on the data in the NUAC’s database, you’ll have to bone up on your SQL.
Then it’s up to you to take it from there.
As your data management needs increase, you can consider alternative heavy-duty data management technologies as needed.
Your Python Toolbox You’ve got Chapter 9 under your belt and you’ve added some key Python tools to your evey expanding Python toolbox.
The fieldStorage() method from the standard library’s cgi module lets you access data sent to your web server from within your CGI script.
The standard os library includes the environ dictionary providing convenient access to your program’s environment settings.
The SQLite database system is included within Python as the sqlite3 standard library.
The connect() method establishes a connection to your database file.
The cursor() method lets you communicate with your database via an existing connection.
The execute() method lets you send an SQL query to your database via an existing cursor.
The rollback() method cancels any pending changes to your data.
The close() method closes an existing connection to your database.
The “?” placeholder lets you parameterize SQL statements within your Python code.
It all started with the internal combustion engine, then it was the electric engine, and now there’s App Engine.
The Web is a great place to host your app…until things get real.
Sooner or later, you’ll hit the jackpot and your webapp will be wildly successful.
Will you be ready? Will your web server handle the load? How.
There are whale sightings everywhere The Head First Whale Watching Group (HFWWG) coordinates the live cetacean sightings for the entire country.
To date, they’ve provided a PDF form on their website that members of  the public can download, fill in, and mail to the HFWWG central office.
The form contains the essential data needed to record the sighting:
After a busy sightings weekend, the central office is swamped with completed forms for thousands of  sightings…which is a data-entry nightmare as all those forms can take an age to process manually.
There’s nothing worse than being stuck in front of  your computer entering data when all you want to do is be out on the water looking for humpbacks…
We need to somehow automate the recording of our sightings...
Suggesting to the HFWWG that they invest in an expensive web hosting solution isn’t going to make you any friends.
It’s way too expensive to buy the capacity they’ll need for the busy weekends and a total waste of  capacity when sightings are infrequent.
Suggesting that they invest in a large, state-of-the-art web server that can be hosted in the central office is also a nonstarter: there’s no one to look after a setup like that, and the broadband link required to handle the anticipated traffic would blow the their budget right out of  the water.
Ideally, a solution that works on the Web would be great.
Build your webapp with Google App Engine Google App Engine (GAE) is a set of  technologies that lets you host your webapp on Google’s cloud computing infrastructure.
When things are busy, GAE increases the resources available to your webapp, and when things are quiet, GAE reduces the resources until such time as extra activity warrants increasing them again.
On top of  this, GAE provides access to Google’s BigTable technology: a set of database technologies that make storing your webapp’s data a breeze.
Google also backs up your webapp’s data on a regular basis, replicates your webapp over multiple, geographically dispersed web servers, and keeps App Engine running smoothly 24/7
And the best part? GAE can be programmed with Python.
And the even better part? You can start running your webapp on GAE for free.
Google provides this webapp hosting service at no charge and will continue to do so until your webapp processes five million page views per month.
Once it exceeds this threshold, you’ll need to pay Google for the extra capacity used.
If  you never reach the limit, your use of  GAE is not charged.
Download and install App Engine When your webapp is ready for deployment, you’ll upload it to the Google cloud and run it from there.
However, during development, you can run a test version of  your webapp locally on your computer.
All you need is a copy of the GAE SDK, which is available from here:
Windows, Mac OS X, and Linux are all supported, and installation is straightforward.
If  this command gives an error, pop on over to the Python website and grab the 2.5 release for your operating system.
After installation, Windows and Mac OS X users will find a nice, graphical front end added to their system.
On Linux, a new folder called “google_appengine” is created after a successful install.
It’s important to remember to always code to the restrictions placed on you.You might think that it sucks that GAE runs on Python 2.5, but you shouldn’t.
Think of it as just another restriction placed on the code you write—that is, it must target Release 2.5 of Python.
In fact, you will be hard pressed to spot the difference.
To build a GAE-compatible webapp, you need three things: a folder to hold your webapp’s files, some code to execute, and a configuration file.
Within the folder, create a small CGI you can use to test GAE.
The configuration file must be called app.yaml and it, too, must be in your webapp’s folder.
This file tells the Google cloud a little bit about your webapp’s runtime environment.
It doesn’t get much easier than this…a plain-text message is displayed within your browser whenever this CGI runs.
The “application” line identifies your webapp and is the same name as your folder.
The “version” line identifies the current version of your webapp (and usually starts at 1)
The “api_version” indicates the release of GAE you are targeting.
Go ahead and create the folder called mygaetest and the two files shown here.
Think of the “handlers” section of the configuration file as a top-level webapp routing mechanism.
This entry tells GAE to route all requests to your webapp to your “sayhello.py” program.
Test Drive The GAE SDK includes a test web server, so let’s use it to take your test GAE webapp for a spin.
This tool makes it easy to start, stop, and monitor your webapp.
On Linux, you’ll need to invoke a command to kick things off.
If you are using the GAE Launcher, choose File -> Add Existing Application from the menu system to browse and select your webapp’s folder.
Also: be sure to edit the Launcher’s Preferences to select Python 2.5 as your preferred Python Path.
There is no graphical front end for Linux, so start your GAE webapp from the command line.
And there it is… the message from your test webapp!
This is actually more work than plain old CGI...and you’re claiming this is better?!?
For now, this is more work than you’re used to, but remember that this is just a quick test to make sure your GAE test environment is up and running (and it is)
When you start to work with some of GAE’s web development features, you’ll initially see that there’s a lot more going on behind the scenes than meets the eye.
Like your webapp from the previous chapter, the model component of  a GAE-enabled webapp uses a back-end data storage facility that’s known as the datastore.
This is based on Google’s BigTable technology, which provides a “NoSQL” API to your data, as well as a SQL-like API using Google’s Query Language (GQL)
GAE’s views use templates, but unlike the simple string templates from the previous chapter, GAE uses the templating system from the Django Project, which is one of  Python’s leading web framework technologies.
And, of  course, any controller code is written in Python and can use the CGI or WSGI standards.
So...like any other webapp that I build, with App Engine I define a model for my data, create some templates for my view, and then control it all with code, right?
Google has worked hard to ensure that the move to App Engine is as painless as possible.
If  you understand MVC (as you now do), you are well on your way to creating with GAE.
It’s just a matter of  working out how GAE implements each of  the MVC components.
Model your data with App Engine App Engine refers to data items stored within its datastore as properties, which are defined within your model code.
Think of  properties as a way to define the name and types of  data within your database schema: each property is like the column type associated piece of  data stored in a row, which App Engine refers to as an entity.
When you think “row,” I think “entity.” And when your think “column,” I think “property.” Get it?
As with traditional SQL-based databases, your GAE datastore properties are of  a specific, predeclared type.
Pool Puzzle Your job is to take the properties from the.
Your goal is to assign the correct property type to each of the attributes within your Sighting class.
Create a class called “Sighting” that inherits from the GAE “db.Model” class.
Pool Puzzle Solution Your job was to take the properties from.
Your goal was to assign the correct property type to each of the attributes within your Sighting class.
Everything is a “StringProperty”, except the “date” and “time” fields.
What good is a model without a view? GAE not only lets you define the schema for your data, but it also creates the entities in the datastore.
The first time you go to put your data in the datastore, GAE springs to life and makes room for your data.
There’s no extra work required by you, other than defining your model in code.
It’s useful to think of  GAE as executing something similar to a SQL CREATE command on the fly and as needed.
But how do you get data into the GAE datastore?
The short answer is that you put it there, but you first need to get some data from your webapp’s user…and to do that, you need a view.
App Engine templates in an instant Recall that the templating technology built into GAE is based on technology from the Django Project.
Django’s templating system is more sophisticated than the simple string-based templates used in the previous chapter.
Like your templates, Django’s templates can substitute data into HTML, but they can also execute conditional and looping code.
Use templates in App Engine To use a template, import the template module from google.
This is similar to the mechanism your yate.py module uses to parameterize the data displayed within your HTML pages.
And I can use a bunch of calls like this to create the view that I need for the HTWWG sightings form, right?
Just like the other webapps that you’ve built, you can create your view in much the same way using Python code.
It’s a bummer that you can’t use your yate.py module, but Django’s templates provide most of  the functionality you need here.
Q: Should I create one big template for my entire web page? A: You could, if you want.
However, if you build up your view from snippets of HTML in templates, you open up the possibility of reusing those HTML snippets in lots of places.
For instance, to maintain a consistent look and feel, you can use the same header and footer template on all of your web pages, assuming of course that your header and footer aren’t already embedded in an entire web page (which can’t be reused)
Let’s write the rest of the code needed to create a view that displays a data entry form for your HFWWG webapp.
In addition to your web page header code (which already exists and is provided for you), you need to write code that starts a new form, displays the form fields, terminates the form with a submit button, and then finishes off the web page.
Make use of the templates you’ve been given and (here’s the rub) do it all in no more than four additional lines of code.
Now that you have attempted to write the code required in no more than four lines of code, what problem(s) have you encountered.
In the space below, note down any issue(s) you are having.
Extend the contents of “html” with the rest of the HTML you need.
You were to write the rest of the code needed to create a view that displays a data entry form for your HFWWG webapp.
In addition to your webpage header code (which already exists and is provided for you), you were to write code with starts a new form, displays the form fields, terminates the form which a submit button, then finishes off the webpage.
You were to make use of the templates you’ve been given and (here’s the rub) you had to do it all in no more than four more lines of code.
Having attempted to write the code required in no more than four lines of code, you were to make a note of any issue(s) you encountered.
We need to generate the FORM fields in here…but how?!?
This is IMPOSSIBLE to do in just four lines of code, because there’s no way to generate the FORM fields that I need.
If you don’t need the second one, be sure to pass an empty dictionary.
Django’s form validation framework Templates aren’t the only things that App Engine “borrows” from Django.
It also uses its form-generating technology known as the Form Validation Framework.
Given a data model, GAE can use the framework to generate the HTML needed to display the form’s fields within a HTML table.
Here’s an example GAE model that records a person’s essential birth details:
This model is used with Django’s framework to generate the HTML markup needed to render the data-entry form.
Import the forms library in addition to your GAE data model.
There is some code missing from here…but don’t worry: you’ll get to it in just.
For now, just concentrate on un derstanding the links between the.
Check your form The framework generates the HTML you need and produces the following output within your browser.
Use the View Source menu option within your web browser to inspect the HTML markup generated.
It’s not the prettiest web page ever made, but it works.
By setting “auto_id” to “False” in your code, the form generator uses your model property names to identify your form’s fields.
It’s time to tie things all together with your controller code.
Controlling your App Engine webapp Like your other webapps, it makes sense to arrange your webapp controller code within a specific folder structure.
Your top-level folder needs to be named to match the “application” line in your webapp’s “app.yaml” file.
If you have static content, put it in here (at the moment, this folder is empty)
Put all of your webapp’s controller code and configuration files in here.
As you’ve seen, any CGI can run on GAE, but to get the most out of  Google’s technology, you need to code to the WSGI standard.
Here’s some boilerplate code that every WSGI-compatible GAE webapp starts with:
This class responds to a web request from your web browser.This method runs when a G.
All you need to do is move that file into your webapp’s top-level folder.
Copy your templates folder in there, too.Your webapp’s controller code, in a file called hfwwg.py, also needs to exist in your top-level folder.
The only problem is that some of the code’s all over the floor.
All of the imports have survived…so there’s no need to rearrange them.
There’s only one small change from the boilerplate code in that “IndexPage” is not being linked to.
You were to move that file into your webapp’s top-level folder, as well as copy your templates folder in there, too.Your webapp’s controller code, in a file called hfwwg.py, also needs to exist in your top-level folder.
The only problem is that some of the code’s all over the floor.
Did you guess this correctly? You need to send a.
Test Drive It’s been a long time coming, but you are now ready to test the first version of your sightings form.
If you haven’t done so already, create an app.yaml file, too.
Set the application line to hfwwg and the script line to hfwwg.py.
One final step is to use the Add Existing Application menu option within the GAE Launcher to select your top-level folder as the location of your webapp.
And here’s your generated HTML form in all its glory.
Let’s get a quick opinion from the folks over at the HFWWG.
I know what you’re thinking: “With a shirt like *that*, how can this guy possibly know anything about style?”...
Not to worry, you know all about code reuse, right? So, let’s reuse someone else’s cascading style sheets (CSS) to help with the “look” of  your generated HTML form.
But who can you “borrow” from and not lose sleep feeling guilty over it?
As luck would have it, the authors of  Head First HTML with CSS & XHTML created a bunch of  stylesheets for their web pages and have made them available to you.
Grab a slightly amended copy of  some of  their great stylesheets from this book’s support website.
When you unzip the archive, a folder called static appears: pop this entire folder into your webapp’s top-level folder.
Improve the look of your form To integrate the stylesheets into your webapp, add two link tags to your header.html template within your templates folder.
Your CSS files are static and are in your static folder.
All you need to do is tell GAE about them to enable optimization.
Do this by adding the following lines to the handers section of  your app.yaml file:
Add these two lines to the top of your “header.html” template.
Test Drive With your stylesheets in place and your app.yaml file amended, ask your browser to reload your form.
Restrict input by providing options At the moment, your form accepts anything in the Fin, Whale, Blow, and Wave input areas.
The paper form restricts the data that can be provided for each of  these values.
Anything you can do to cut down on input errors is a good thing.
As the youngest member of the group, I was “volunteered” to work on data clean-up duties...
Providing a list of choices restricts what users can input.
Instead of  using HTML’s INPUT tag for all of  your form fields, you can use the SELECT/OPTION tag pairing to restrict what’s accepted as valid data for any of  the fields on your form.
The good news is that the form validation framework can generate the HTML markup you need for you.
All you have to provide is the list of  data items to use as an argument called choices when defining your property in your model code.
You can also indicate when multiple lines of  input are acceptable using the multiline argument to a property.
Apply these changes to your model code in the hfwwgDB.py file.
Define your lists of values near the top of your code.
This naming convention helps identify these lists as containing constant values.
Test Drive With these changes applied to your model code, refresh your web browser once more.
Your form is not only looking good, but it’s more functional, too.
Each of the “type” fields now have drop-down selection menus associated with them.
Your form now looks great! Go ahead and enter some test data, and then press the Submit Sighting button.
Meet the “blank screen of death” Submitting your form’s data to the GAE web server produces a blank screen.
To work out what happened (or what didn’t happen), you need to look at the logging information for your GAE webapp.
If  you are running GAE on Linux, your logging messages are displayed on screen.
If  you are on Windows or Mac OS X, click the Logs button within the Launcher to open up the Log Console for your webapp.
Your request resulted in a 405 status code from the web server.
According to the official HTTP RFC standards document, 405 stands for:
The method specified in the Request-Line is not allowed for the resource identified by the Request-URI.
Process the POST within your webapp What the 405 status code actually tells you is that posted data arrived at your webapp intact, but that your webapp does not have any way of  processing it.
Take a quick look back at your code: the only method currently defined is called get()
This method is invoked whenever a GET web request arrives at your webapp and, as you know, it displays your sightings form.
In order to process posted data, you need to define another method.
Specifically, you need to add a new method called post() to your SightingInputPage class.
App Engine handles requests as well as responses Your get() method produces your HTML form and returns a web response to the waiting web browser using the self.response object and by invoking the  out.write() method on it.
In additon to helping you with your web responses, GAE also helps you process your web requests using the self.request object.
Here are a few lines of  code that displays all of  the data posted to your web server:
Listen, bud, I’ll happily process your web requests all day long...just as long as you give me the methods I need!
The “arguments()” method returns a list of the field names used on your form.
But what do you do with the data once you have it?
Put your data in the datastore Your data is sent to your webapp by GAE and you can use the self.
Assume that an HTML form has sent data to your webapp.
The data is destined to be stored in the GAE datastore.
Get each of the form’s data values and assign them to your new object’s attributes.Put (save) your data to the GAE datastore.
There’s nothing to it: create a new object from your data model, get the data from your HTML form, assign it to the object’s attributes, and then use the put() method to save your data in the datastore.
Based on what you know about how to put your HTML form’s data into the GAE datastore, create the code for the post() method that your webapp now needs.
Some of the code has been done for you already.
Based on what you know about how to put your HTML form’s data into the GAE datastore, you were to create the code for the post() method that your webapp now needs.
Some of the code has been done for you already.
For each of the data values received from the HTML form, assign them to the attributes of the newly created object.
Test Drive Add your post() code to your webapp (within the hfwwg.py file)  and press the Back button on your web browser.
Click the Submit Sighting button once more and see what happens this time.
Here’s your form with the data waiting to be submitted.
But when you click the button, something bad has happened…your webapp has crashed.
It looks like you might have a problem with the.
Don’t break the “robustness principle” The Robustness Principle states: “Be conservative in what you send; be liberal in what you accept.” In other words, don’t be too picky when requesting data of a certain type from your users, but when providing data, give ’em exactly what they need.
If  you make it too hard for your users to enter data into your system, things will likely things break.
For instance, within your model code, consider how date and time are defined:
The trouble is, when it comes to dates and times, there are lots of  ways to specify values.
I say, old boy, tea is at noon on the first of each month.
Get the low-down on the hoedown: quarter after six on 6/17/2011
Accept almost any date and time If  you are going to insist on asking your users to provide a properly formatted date and time, you’ll need to do one of  two things:
Specify in detail the format in which you expect the data.
Convert the entered data into a format with which you can work.
For example, if  you are too picky in requesting a date in a particular format, you’ll slow down your user and might end up picking a date format that is foreign to them, resulting in confusion.
If  you try to convert any date or time entered into a common format that the datastore understands, you’ll be biting off  more than you can chew.
There is a third option If  your application doesn’t require exact dates and times, don’t require them of your user.
With your sightings webapp, the date and time can be free-format fields that accept any value (in any format)
What’s important is the recording of  the sighting, not the exact date/time it occurred.
Of course, other webapps might not be as fast and loose with dates and times.
When that’s the case, you’ll need to revert one of the options discussed earlier on this page and do the best you can.
It’s a small change, but it’ll make all the difference.
Click Back in your web brwoser and submit your sightings data once more.OK, folks…
By relaxing the restrictions you placed on the types of  data you’ll accept, your webapp now appears to be working fine.
Go ahead and enter a few sightings by clicking on the link on your thank-you page and entering more data.
With a few sightings entered, let’s use App Engine’s included developer console to confirm that the sightings are in the datastore.
To access the console, enter http://localhost:8081/_ah/admin into your web browser’s location bar and click on the List Entities button to see your data.
In addition to viewing your existing data in the datastore, you can use the console to enter new test data.
There’s all the data your entered, which is in a slightly different order than what you might expect.
App Engine stores your properties in alphabetical order, by name.
App Engine has assigned a “Key” and an “ID ” to.
Before you deploy it to Google’s cloud infrastructure, let’s run it by the folk at HFWWG to see if  they are happy for their webapp to “go live.”
Man, that’s looking good! There’s just one thing we forgot to tell you...
You’ll have to create an new entity to hold your registered user login information, and you’ll also need another form to ask users to provide their registration data (which you’ll need to store in the datastore)
With that in place, you’ll need yet another form to ask your users to log in, and then you’ll have to come up with a mechanism to restrict only registered and logged-in users to view your webapp’s pages, assuming you can come up with something robust that will work…?
Or…as this is GAE, you could just switch on authorization.
Sometimes, the tiniest change can make all the difference… The engineers at Google designed App Engine to deploy on Google’s cloud infrastructure.
As such, they decided to allow webapps running on GAE to access the Google Accounts system.
By switching on authorization, you can require users of  your webapp to log into their Google account before they see your webapp’s pages.
If  a user tries to access your webapp and he isn’t not logged in, GAE redirects to the Google Accounts login and registration page.
Then, after a successful login, GAE returns the user to your waiting webapp.
To switch on authorization, make one small change to your app.yaml file:
Now, when you try to access your webapp, you are asked to log in before proceeding.
This is how the login screen looks within the GAE test environment running on your computer.
Capture your user’s Google ID, too Now that your webapp requires your users to log in, let’s arrange to capture the user login information as part of  the sighting.
Start by adding the following property to your entity’s list of  attributes in your hfwwgDB.py file.
Let’s ensure that Django’s form validation framework excludes this new attribute when generating your HTML form.
Within your hfwwg.py file, change your SightingForm class to look like this:
Staying within your hfwwg.py file, add another import statement near the top of  your program:
In your post() method, right before you put your new sighting to the datastore, add this line of  code:
Every time a user adds a sighting to the datastore, GAE ensures that the user’s Google Account ID is saved, too.
This extra identification information allows the HFWWG to track exactly who reported which sighting, and should (hopefully) cut down on the amount of  spam your webapp might attract.
Make sure Django doesn’t include the new attribute in your generated form.
When you put your data to the datastore, this code includes the Google ID of the currently logged-in user.
All that’s left to do is to deploy your webapp to Google’s cloud.
Deploy your webapp to Google’s cloud With your webapp developed and tested locally, you are now ready to deploy to the Google cloud.
To register your webapp on the Google cloud, click the Dashboard button on the GAE Launcher.
The “Dashboard” button opens your web browser and takes you to the GAE “My Applications” page (after you sign in with your Google ID)
Enter your webapp’s name in the box, then click on the “Check Availability” button.
Assuming all went according to plan and GAE confirmed that your application has been created, all that’s left to do is to deploy.
Return to the GAE Launcher and click on the Deploy button.
The console displays a bunch of  status message while the deployment progresses.
If  all is well, you’ll be told that “appcfg.py has finished with exit code 0”
Your GAE webapp is now ready to run on Google’s cloud.
Test Drive, on Google Let’s take your webapp for a spin on Google’s cloud.
Open your web browser and surf to a web address that starts with your webapp’s name and ends in .appspot.com.
When you first attempt to go to their webapp, App Engine redirects you to the Google login page.
Provide your Google ID and password, or sign up for a new Google account (if you don’t have one already)
The sighting form served from the Google cloud is EXACTLY the same as the form served by your test server.
Return to the http://appengine.google.com site to log into the console.
The UI is a little different than the test console, but you can use the Datastore Viewer to confirm that your data has been stored correctly.
Click on this link to see your data as stored in the Google cloud.
I’m all packed up and ready for a weekend of whale watching.
I finally have time to relax, now that I have no more marathon data-entry sessions.
You’ve built a great data-entry webapp and deployed it on Google’s cloud.
No matter how busy things get, whether there’s a handful of  sightings per day or tens of  thousands, your webapp can handle the load, thanks to Google’s App Engine.
And, best of  all, the cash-strapped HFWWG doesn’t pay a penny until their sightings activity reaches the level of  millions of  sightings per month!
Did you even notice that you wrote all of your code using Python 2.5?
Your Python Toolbox You’ve got Chapter 10 under your belt and you’ve added more great Python technology to your everexpanding Python toolbox.
Use the GAE Launcher to start, stop, monitor, test, upload, and deploy your webapps.
App Engine’s templating technology is based on the one use in the Django Project.
Use the self.response object to construct a GAE web response.
Use the self.request object to access form data within a GAE webapp.
When responding to a GET request, implement the required functionality in a get() method.
When responding to a POST request, implement the required functionality in a post() method.
Store data in the App Engine datastore using the put() method.
Once I build up a head of steam, it’s not all that hard to keep on running, and running, and running...
It’s great when you can apply Python to a specific domain area.
Whether it’s web development, database management, or mobile apps, Python helps you.
Creating bespoke software solutions to these type of problems is an area where Python.
In this, your final chapter, you’ll stretch your Python skills to the limit and solve.
What’s a good time goal for the next race? The Head First Marathon Club has spent years collecting and collating data on their distance runners.
Over time, this data has helped the club produce a large spreadsheet of  pace data that helps their runners predict their performance over various distances.
The spreadsheet is huge and runs to 50 columns of  tightly packed data.
Let’s take a look at the club’s data, as well as the way the runners and their coach use it.
The runner selects a distance, say 15K, and we time her over the length of her run.
My coach looks up the closest match for my time along the 15K row.
This benchmark allows me to look up or down the column to select a target time for any other distance, such as a marathon, for example.
So…what’s the problem? At the moment, we print our data onto.
But when it rains or gets really windy, our pages are either soaked.
Not to mention: forgetting the sheets, keeping the sheets up to date, and having to flip back and forth through the sheets looking for a closest match.
Of  course, word of  your newly acquired Python programming skills is getting around, especially among the running crowd.
Ideally, the Marathon Club needs an Android app that can be loaded onto a bunch of  phones and carried in each coach’s pocket.
The app needs to automate the lookup and distance predictions.
Are you up to the challenge? Do you think you can help?
Start with the data For now, let’s not worry about creating the Android app; you’ll get to that soon enough.
Instead, let’s solve the central  data wrangling problem and then, when you have a working solution, we’ll worry about porting your solution to Android.
We’ll begin by getting the data into a format you can easily process with Python.
Most spreadsheet programs can export data to the widely used CSV format.
The club has done this for you and created a file called PaceData.csv, which includes the data for each of  the rows from the original the spreadsheet.
Here’s a sample of  the raw data from the start of  the CSV:
The first line of data is the column headin gs from the spreadsheet.
Because the have no affect on the timing data, we’ll just treat them as headings.
The first value on each of the rest of the lines is the timed distance or row label.
The rest of each line is a list of recorded.
You somehow have to model the data from the CSV file in your Python program.
Can you think of a data structure that might help here? Justify your selection.
Grab a copy of PaceData.csv from this book’s support website.
You somehow have to model the data from the CSV file in your Python program.
You were to think of a data structure that might help here? You were also to justify your selection.
The list of headings can be stored in a LIST.
The list of times from each row can also be stored in a LIST, but they also need to be associated with the headings in the very first row of data, so maybe a DICTIONARY is what’s needed here?
Take another look at the data The first row of  data in the CSV file is the column headings, with the very first value on the line, the V02 string, being redundant (it won’t ever be used in this version of  the app)
The rest of  the first line’s data are headings associated with the time values in each of  the columns.
Let’s look at the data in the CSV file again, which has been reformatted to help highlight the associations.
The times on each row are associated with their row label, but ALSO with a column heading.
The row labels are unique to each row of times.
Marathon Magnets Here’s some code that reads the raw data from from the CSV data file.
The column headings from the first line are loaded into a list called column_headings.
The rest of the data (all the rows of times) are loaded into a dictionary called row_data, with each row of data keyed with the row label string from the start of each line.
Of course, as luck would have it, someone was cleaning the fridge door, and they’ve left a bunch of magnets on the floor.
See if you can arrange the magnets into their correct order.
With the data loaded, this code lets you check if it’s all OK.
Marathon Magnets Solution Here’s some code that reads the raw data from from the CSV data file.
The column headings from the first line are loaded into a list called column_headings.
The rest of the data (all the rows of times) are loaded into a dictionary called row_data, with each row of data keyed with the row label string from the start of each line.
Of course, as luck would have it, someone was cleaning the fridge door, and they’ve left a bunch of magnets on the floor.
You were to see if you could arrange the magnets into their correct order.
You need to be sure to create an empty dictionary for the row times.
Create the column headings from the first line of data.
It’s the same deal here: take the line, strip it, and then split on comma.Extract the.
Use the row label together with the rest of the line’s data to update the dictionary.
Test Drive Load your code into IDLE and, with the CSV in the same folder as your code, run it to see what you get on screen.
The output confirms that each row of data has 50 data items.
That’s a great start: you’ve managed to read the data from the CSV and put the headings into a list and the data into a dictionary.
Did you forget to associate each time on each row with its heading? At the moment, the list and the dictionary are disconnected...
What we need is some way to connect each of  the times in each row with the heading that tops their column of  data.
When it comes to linking (or associating) two data items with each other, the Python dictionary is the data strucutre of choice, isn’t it?
Store each time as a dictionary Rather than simply storing each time in the row_data dictionary as a number, let’s store the data as as a dictionary, with the key set to the time and the value set to the column heading.
That way, you can quickly and easily determine for any time which column it is associated with, right?
Here’s a portion of  what the data structure looks like in Python’s memory once this association exists:
Instead of a single time value, each row item is now an inner dictionary that associates the time with its column heading.
All you need to do is work out how to populate the inner dictionary with the row data and the associated columns headings…and you’ll have all the data you need.
The trick in creating the data structure is to realize that each row, including the column headings, are of  a fixed size: 50 items.
Knowing this, it’s not much work to create the dictionary you need:
With the dictionary populated, assign it to its label in “row_data”
Go ahead and add the extra dictionary populating code to your program.
Let’s remove all of those print() statements from the end of your program, because you’ll use the IDLE shell to test your code.
Run the code by pressing F5 or by selecting the Run Module option from the Run menu.
Use the dir() BIF to confirm that your program code executed and that a collection of variables have been created in Python’s namespace:
Let’s then use the column heading to find the predicted time for a 20k run:
Dissect the prediction code Let’s take a moment to review what just happened at the bottom of  the IDLE Session from the last page.
Look up the ‘15k’ row data, then look up t he.
And this is another dictionary key, which indexes into the dictionary at “row_data[‘15k’]”
A conditional list comprehension is put to good use here.
Recall that the list comprehension syntax is a shorthand notation for a for loop.
The loop searches through the data in the list of  keys associated with the dictionary stored at row_data['20k']
If  the value associated with the key (in k) is the same as column_heading, the value of  k is added to the comprehensions results, which are then assigned to a new list call predicton.
There’s really an awful lot going on in that comprehension.
You are interested only in data that satisfies this conditional.
Sweet mother of all things Python! What’s going on here? I think my brain is going to explode...
Recall that you can always rewrite a list comprehension using an equivalent for loop…
Rewrite each of the list comprehensions on this page to use a for loop.
You were to rewrite each of the list comprehensions to use a for loop.
With each iteration, append the key (which is a time value) onto the “times” list.
With each iteration, append the value (which is a column heading) onto the “times” list.
With each iteration, check to see if the column heading (the value part of the dictionary) equals “79.3” and if it does, append the time to the list.
Get input from your user Now that you have your data within a Python data structure, it’s time to ask your user what it is they are looking for.
Specifically, you need to know three things: the distance run, the time recorded, and the distance a prediction is required for.
When you get to move your app onto Android, you can use a nice graphical dialog to ask your user for input, but for now, let’s quickly create a textbased user interface, which will allow you to develop and test the rest of  the functionality required from your application.
Use input() for input Python has the input() BIF that can help here, which is used to display a prompt on screen, and then accept keyboard input, returning what was entered as a string to your code.
Using the input() BIF is best demonstrated with some examples:
The input() BIF returns a string, which has been stripped of any trailing newline character, which would typically be included at the end of any input string.
It is important to note that any input is returned as a string, regardless of what type of data you think you might be entering:
The entered data is assigned to “res” and it’s a STRING.
The entered data is assigned to “age” and it’s a string, even though you might want to treat it like it’s a number.
Convert the input to the type you need BEFORE using the data.
Here’s your code from earlier with three calls to input() added to interact with your user.
When your program runs, your user enters some data, and look what happens:
There’s nothing to this, as user-interaction with “input()” doesn’t get much easier than this..
If not, we look for the closest match and work from there...
If it’s not in the dictionary, it can’t be found.
The data in the row_data dictionary originally comes from the spreadsheet and is read into your program from the CSV file.
If  the data value entered into the recorded_time variable is in the dictionary, things are going to be fine, because there’s a match.
However, if  the data entered into the recorded_time variable doesn’t match anything in the dictionary, you’ll get a KeyError.
Search for the closest match All you need to do is search the row of  data for the closest match, right? And guess what? The Head First Code Review Team think they have some functions that might help here.
There’s nothing better than sharing our code with our fellow Python programmers.
This code is in a file called “find_it.py” and you can download a copy from this book’s support website.
Here’s an example of a nested function, which is allowed in Python.
Given two values, this function returns the difference between them.
This may not be the most efficient search code ever written, but it works.
Let’s test the find_it.py module to try and determine if it meets the requirements of your application.
Load the module into IDLE and then press F5 or choose Run Module from the Run menu:
Given a value to look for and some target data, the “find_closest” function seems to be doing the trick.
Let’s try it with some of data that more closely resembles your CSV data:
TypeError: unsupported operand type(s) for -: 'str' and 'str' Yikes! Something’s seriously broken here.
What do you think has gone wrong here? Why does the find_closest() function crash when asked to work with data from your CSV file?
The trouble is with time The data in your CSV file is a representation of  timing values.
Rather than actual numbers, the values in the CSV are strings.
This is great for you, because you understand what the representation means.
Python, on the other hand, sees the data only as strings.
When you send your data to the find_closest() function, Python attempts to treat your strings as numbers and chaos ensues.
What might work would be to convert the time-strings into numbers.
When I have to work with times, I always convert my time strings to seconds first...
Grab a copy of this code from this book’s support website.
Given a “time string”, convert it to a value in seconds.
Sure enough, their rather strangely name tm2secs2tm.py module looks like it might help.
This function ensures that all times are formatted in “HH:MM:SS” format.
This helps keep things simple when doing conversions to seconds.
The function returns the closest time found as a string:
Unlike in the previous chapter, it is possible to do what you need to do here in only four lines of code.
The function returns the closest time found as a string:
The function takes two arguments, a time string and a list of time strings.
Convert the time string you are looking for into its equivalent value in seconds.
Return the closest match to the calling code, after converting it back to a time string.
Let’s try out your code at the IDLE shell to see if your time “problems” have been resolved:
Test Drive With all this code available to you, it’s an easy exercise to put it all together in your program and produce a complete solution to the Marathon Club’s prediction problem.
Search for a predicted time at the desired distance and display it on screen.
After all that, you’re getting the same error as before.
Try out your program with the same data input from earlier.
Take another look at the results from the previous IDLE Session.
When your code takes one of  these returned values and tries to index into your dictionary, there’s no match found, because your dictionary’s keys do not confirm to the HH:MM:SS format.
The solution to this problem is to ensure that every time you use a time-string in your code, make sure it’s in HH:MM:SS format:
Use the function to ensure the times used internally by your code are formatted in “HH:MM:SS” format.
Hopefully, now that all of the time strings within the system conform to HH:MM:SS format, your code will behave itself.
This is the previous test, which crashed with a “KeyError”
This time around, your program behaves itself and works fine.
You’ve solved your application’s central problem: your program reads in the spreadsheet data from the CSV file, turns it into a dictionary of  dictionaries, and lets you interact with your user to acquire the recorded time at a particular distance before predicting a time for another distance.
Not counting the code provided by the Head First Code Review Team, you’ve written fewer than 40 lines of  code to solve this problem.
All that’s left to do is to port your program to the club’s Android’s phones.
And porting to Android won’t take too long, will it?
Now it’s time to port your text-based Python program to Android.
Most of  your code doesn’t need to change, only the parts that interact with your user.
Obviously, you’ll want to make things as easy to use as possible for users of your latest Android app, providing an interface not unlike this one.
Your Android app is a bunch of dialogs Your Android app interacts with your users through a series of  dialogs.
Other than the single dialog that requests data from your user, the other three share certain similarities.
You can take advantage of  these shared features by creating a utility function which abstracts the dialog creation details:
You were to assume the existence of a list called distances, which contains the row distance labels.
This last one’s a little trickier, because you have to build up the dialog title from some variables (that you’ll need to have created first)
This function is taken “as-is” from earlier in this book.
Get your Android app code ready To use your dialog creating code, import the necessary libraries, define some constants, create an Android object, and reuse some code from earlier in this book:
Android Pool Puzzle Your job is to take the code from the pool and place.
You can assume that the row_data dictionary exists and has been populated.
Your goal is to arrange the code so that it implements the UI interactions you need.
Android Pool Puzzle Solution Your job was to take the code from the pool and.
Ask your user to pick a distance from the list of labels.
Ask your user to pick a distance from the list of labels to predict to.Look up the prediction.
Display the predicted time at the selected distance to your user.
Put your app together… You now have all the code you need to create your app:
NOTE: the location of the data file on the SDCARD is specific to Android.
Create your Android app object and include your helper functions.
Display your UI to your user and process the resulting interaction.
Test Drive It’s time to test your Android app on the Android Emulator before loading a working application onto a “real” phone.
Start your Android emulator and begin by transferring your code and the files it needs onto the emulator’s SDCARD.
And there it is… waiting for you to test it.
Copy your code and its support files to the emulator with these commands.
Your app’s a wrap! All that’s left to do is transfer your working Android app to the Marathon Club’s phones…and that’s easy when you use AndFTP.
When you show off your latest work, the club’s members can’t believe their eyes.
This is fantastic! Now I can work with my coach and the other club members to hit my target times at my chosen distances.
And there’s no stopping you! You’ve put your Python skills and techniques to great use here.
Whether you’re building an app for the smallest handheld device or the biggest web server, your Python skills help you get the job done.
Your Python Toolbox You’ve got Chapter 11 under your belt and you’ve demonstrated a mastery of your Python toolbox.
The input() BIF lets you prompt and receive input from your users.
Build complex data structures by combining Python’s built-in lists, sets, and dictionaries.
The time module, which is part of the standard library, has a number of functions that make converting between time formats possible.
A “conditional” list comprehension is one that includes a trailing “if” statement, allowing you to control which items are added to the new list as the comprehension runs.
List comprehensions can be rewritten as an equivalent “for” loop.
It’s been a blast having you with us here on Lake Python.
I don’t know about you, but I think it could do with more spam...
But learning about Python is an activity that never stops.
There’s just not enough room in this book to show you.
Using a “professional” IDE Throughout this book, you’ve used Python’s IDLE, which is great to use when first learning about Python and, although it’s a little quirky, can handle most programming tasks.
It even comes with a built-in debugger (check out the Debug menu), which is surprisingly well equipped.
Chances are, however, sooner or later, you’ll probably need a more full-featured integrated development environment.
One such tool worth looking into is the WingWare Python IDE.
This professional-level development tool is specifically geared toward the Python programmer, is written by and maintained by Python programmers, and is itself written in Python.
WingWare Python IDE comes in various licencing flavor: it’s free if  you’re a student or working on an open source project, but you’ll need to pay for it if  you are working within a for-profit development environment.
And, of  course,there are all those programmer editors which are often all you’ll ever need.
There’s more than a few Python programmers using emacs and vi (or its more common variant, vim)
Your author is a huge fan of  vim, but also spends large portions of  his day using IDLE and the Python shell.
A function which attempts to read from and write to the global variable called “name”
See what “name” is set to after the function runs.
When it comes to scope, Python is quite happy to let you access and read the value of  a global variable within a function, but you cannot change it.
When Python sees the assignment, it looks for a local variable called name, doesn’t find it, and throws a hissy fit and an UnboundLocalError exception.
To access and change a global variable, you must explicitly declare that’s your intention, as follows:
Testing Writing code is one thing, but testing it is quite another.
The combination of the Python shell and IDLE is great for testing and experimenting with small snippets of  code, but for anything substantial, a testing framework is a must.
Python comes with two testing frameworks out of  the box.
The first is familiar to programmers coming from another modern language, because it’s based on the popular xUnit testing framework.
Python’s unittest module (which is part of  the standard library) lets you create test code, test data, and a test suite for your modules.
These exist in separate files from you code and allow you to exercise your code in various ways.
If  you already use a similar framework with your current language, rest assured that Python’s implementation is essentially the same.
The other testing framework, called doctest, is also part of  the standard library.
This framework allows you to take the output from a Python shell or IDLE session and use it as a test.
All you need to do is copy the content from the shell and add it to your modules documentation strings.
If  you add code like this to the end of  your modules, they’ll be ready for “doctesting”:
If  you then run your module at your operating systems comand line, your tests run.
If  all you want to do is import your module’s code and not run your tests, the previous if statement supports doing just that.
For more on unittest and doctest, search the online Python documentation on the Web or via IDLE’s Help menu.
If your code is imported as a module, this code does NOT run.
If you run your module from the command line, your tests run.
What do you mean: you can’t hear me...I guess I should’ve tested this first, eh?
Advanced language features With a book like this, we knew we’d never get to cover the entire Python language unless we tripled the page count.
And let’s face it, no one would thank us for that!
There’s a lot more to Python, and as your confidence grows, you can take the time to check out these advanced language features:
Anonymous functions: the lambda expression lets you create small, oneline, non-named functions that can be incredibly useful once you understand what’s going on.
Generators: like iterators, generators let you process sequences of  data.
Unlike iterators, generators, through the use of  the yield expression, let you minimize the amount of  RAM your program consumes while providing iterator-like functionality on large datasets.
Custom exceptions: create your own exception object based on those provided as standard by Python.
Function decorators: adjust the behavior of  a preexisting function by hooking into its start-up and teardown mechanisms.
Most (but not all) of  these language features are primarily of  interest to the Python programmer building tools or language extensions for use by other Python programmers.
You might never need to use some of  these language features in your code, but they are all worth knowing about.
Take the time to understand when and where to use them.
See #10 of  this appendix for a list of  my favorite Python books (other than this one), which are all great starting points for learning more about these language features.
I know I look complex, but I really am quite useful.
Regular expressions When it comes to working with textual data, Python is a bit of  a natural.
The built-in string type comes with so many methods that most of  the standard string operations such as finding and splitting are covered.
However, what if  you need to extract a specific part of  a string or what if  you need to search and replace within a string based on a specific specification? It is possible to use the built-in string methods to implement solutions to these types of  problems, but—more times than most people would probably like to admit to—using a regular expression works better.
Consider this example, which requires you to extract the area code from the phone_number string and which uses the built-in string methods:
Jeff Friedl’s regular expression “bible”, which is well worth a look if you want to learn more.
This code works fine, but it breaks when presented with the following value for phone_number:
When you use a regular expression, you can specify exactly what it is you are looking for and improve the robustness of  your code:
This specification is much more likely to find the area code and won’t break as quickly as the other version of this program.
More on web frameworks When it comes to building web applications, CGI works, but it’s a little old-fashioned.
As you saw in Chapter 10, Google’s App Engine technology supports CGI, but also WSGI and a number of  web framework technologies.
If  you aren’t deploying to the cloud and prefer to roll your own, you have plenty of  choices.
My advice: try a few on for size and see which one works best for you.
Search for the following terms in your favorite search engine: Django, Zope, TurboGears, Web2py, and Pylons.
The “old timers”…but don’t let maturity fool you: these are cracking web frameworks.
The “new kids on the block”: leaner, meaner and stuffed full of features.
Object relational mappers and NoSQL Working with SQL-based databases in Python is well supported, with the inclusion of  SQLite in the standard library a huge boon.
Of  course, the assumption is you are familiar with SQL and happy to use SQL to work with your data.
But what if  you aren’t? What if  you detest SQL?
An object relational mapper (ORM) is a software technology that lets you use an underlying SQL-based database without having to know anything about SQL.
Rather than the procedural interface based on the Python database API, ORMs provide an object-oriented interface to your data, exposing it via method calls and attribute lookups as opposed to columns and rows.
Many programmers find ORMs a much more natural mechanism for working with stored datasets and the Python community creates and supports a number of  them.
One of  the most interesting is SQL Alchemy, which is popular and included in a number of  the web framework technologies discussed in #6
If  you find yourself  becoming increasingly frustrated by SQL, check out an ORM.
Of  course, you have already experienced a similar technology: Google App Engine’s datastore API is very similar in style to those APIs provided by the major Python ORMs.
In addition to database technologies that let you avoid working with the underlying SQL-based database, a new breed of  technologies have emerged that let you drop your SQL database in its entirety.
Known collectively as NoSQL, these data tools provide an alternative non-SQL API to your data and do not use an SQL-based database management system at all.
CouchDB and MongoDB are the two most closely associated with robust Python implementations.
If  you like working with your data in a Python dictionary and wished your database technology let you store your data in much the same way, then you need to take a look at NoSQL: it’s a perfect fit.
Programming GUIs In this book, you’ve created text-based interfaces, web-based interfaces and interfaces that ran on Android devices.
But what if  you want to create a desktop application that runs on your or your user’s desktop computer? Are you out of  luck, or can Python help here, too?
Well…as luck would have it, Python comes preinstalled with a GUI-building toolkit called tkinter (shorthand for Tk Interface)
It’s possible to create a usable and useful graphical user interface (GUI) with tkinter and deploy it on Mac OS X, Windows, and Linux.
With the latest version of  Tk, your developed app takes on the characteristics of  the underlying operating system, so when you run on Windows, your app looks like a Windows desktop app, when it run on Linux, it looks like a Linux desktop app, and so on.
You write your Python and tkinter code once, then run it anywhere and it just works.
There are lots of  great resources for learning to program with tkinter, with one of  the best being the last few chapters of  Head First Programming, but since plugging that book would be totally shameless, I won’t mention it again.
Other GUI-building technologies do exist, with the PyGTK, PyKDE, wxPython, and PyQT toolkits coming up in conversation more than most.
Search the Web for any of  the project names to learn more.
Stuff to avoid When it comes to stuff  to avoid when using Python, there’s a very short list.
There are three types of bugs: your bugs, my bugs...
Threads do indeed exist in Python but should be avoided where possible.
This has nothing to do with the quality of  Python’s threading library and everything to do with Python’s implementation, especially the implementation known as CPython (which is more than likely the one you’re running now)
Python is implemented using a technology known as the Global Interpreter Lock (GIL), which enforces a restriction that Python can only ever run on a single interpreter process, even in the presence of  multiple processors.
What all this means to you is that your beautifully designed and implemented program that uses threads will never run faster on multiple processors even if  they exist, because it can’t use them.
Your threaded application will run serially and, in many cases, run considerably slower than if  you had developed the same functionality without resorting to threads.
Main message: don’t use threads with Python until the GIL restriction is removed…if  it ever is.
Other books There are lots of  great books that cover Python in general, as well as specifically within a particular problem domain.
Here is a collection of  my favorite Python books, which we have no hestitation in recommending to you.
If you are a sysadmin, then this is the Python book for you.
See GAE input data, sending to CGI scripts  300–303 input forms for.
