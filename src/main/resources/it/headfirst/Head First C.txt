Head First C could quite possibly turn out to be the best C book of  all time.
I could easily see this become the standard C textbook for every college C course.
Most books on programming follow a fairly predictable course through keywords, control-flow constructs, syntax, operators, data types, subroutines, etc.
These can serve as a useful reference, as well as a fairly academic introduction to the language.
This book, on the other hand, takes a totally different approach.
It teaches you how to be a real C programmer.
Head First C is an accessible, light-hearted introduction to C programming, in the classic Head First style.
Kathy and Bert’s Head First Java transforms the printed page into the closest thing to a GUI you’ve ever seen.
Beyond the engaging style that drags you forward from know-nothing into exalted Java warrior status, Head First Java covers a huge amount of  practical matters that other texts leave as the dreaded ‘exercise for the reader…’  It’s clever, wry, hip, and practical—there aren’t a lot of  textbooks that can make that claim and live up to it while also teaching you about object serialization and network launch protocols.
Just the right tone for the geeked-out, casual-cool guru coder in all of  us.
There are books you buy, books you keep, books you keep on your desk, and thanks to O’Reilly and the Head First crew, there is the penultimate category, Head First books.
They’re the ones that are dog-eared, mangled, and carried everywhere.
Head First SQL is at the top of  my stack.
Usually when reading through a book or article on design patterns, I’d have to occasionally stick myself in the eye with something just to make sure I was paying attention.
Odd as it may sound, this book makes learning about design patterns fun.
Wouldn’t it be dreamy if there were a book on C that was easier to understand than the space shuttle flight manual? I guess it’s just a.
O’Reilly Media books may be purchased for educational, business, or sales promotional use.
Many of  the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and O’Reilly Media, Inc., was aware of  a trademark claim, the designations have been printed in caps or initial caps.
While every precaution has been taken in the preparation of  this book, the publisher and the authors assume no responsibility for errors or omissions, or for damages resulting from the use of  the information contained herein.
No kittens were harmed in the making of  this book.
David Griffiths began programming at age 12, when he saw a documentary on the work of  Seymour Papert.
At age 15, he wrote an implementation of Papert’s computer language LOGO.
After studying pure mathematics at university, he began writing code for computers and magazine articles for humans.
He’s worked as an agile coach, a developer, and a garage attendant, but not in that order.
He can write code in over 10 languages and prose in just one, and when not writing, coding, or coaching, he spends much of  his spare time traveling with his lovely wife—and coauthor—Dawn.
Dawn Griffiths started life as a mathematician at a top UK university, where she was awarded a first-class honors degree in mathematics.
She went on to pursue a career in software development and has over 15 years experience working in the IT industry.
Before joining forces with David on Head First C, Dawn wrote two other Head First books (Head First Statistics and Head First 2D Geometry) and has also worked on a host of  other books in the series.
When Dawn’s not working on Head First books, you’ll find her honing her Tai Chi skills, running, making bobbin lace, or cooking.
She also enjoys traveling and spending time with her husband, David.
Here you are trying to learn something, while here your brain is, doing you a favor by making sure the learning doesn’t stick.
Want to get inside the computer’s head? Need to write high-performance code for a new game? Program an Arduino? Or.
So dive in and grab your compiler, and you’ll soon.
If  you really want to kick butt with C, you need to understand how C handles memory.
The C language gives you a lot more control over how your program uses the.
In this chapter, you’ll strip back the covers and see exactly what.
You’ve seen how strings in C are actually char arrays but what does C allow you to do.
In this chapter, you’ll see how to create an array of strings, and then take a.
Small tools written in C perform specialized small tasks, such as reading and.
If  you create a big program, you don’t want a big source file.
Can you imagine how difficult and time-consuming a single source file for an enterpriselevel program would be to maintain? In this chapter, you’ll learn how C allows you to.
Along the way, you’ll learn a bit more about data type subtleties.
Ever wished your plants could tell you when they need watering? Well, with an Arduino, they can! In this lab, you’ll build an Arduino-powered plant monitor, all coded in C.
Most things in life are more complex than a simple number.
So far, you’ve looked at the basic data types of the C language, but what if you.
In this chapter, you’ll learn how to combine the basic data types into.
To model complex data requirements, you often need to link structs together.
You’ll also see how to make your data structures cope with flexible amounts of data by.
So far, you’ve focused on the basics, but what if you need even more power and.
Now it’s time to use that power for your own code.
What’s more, you’ll learn how to share code at runtime with dynamic libraries.
And by the end of the chapter, you’ll be able to.
Is it a bird? Is it a plane? No, it's a relocatable object file with metadata.
Imagine if your computer could keep an eye on your house while you’re out, and tell you who’s been prowling around.
In this lab, you’ll build a C-powered intruder detector using the cleverness of OpenCV.
You’ve already seen that you can build complex applications by connecting small.
It runs separate processes for each of the three newsfeeds.
What if you want to control the process once it’s running? What if you want to send it.
We’ll show you how to multiply the power of your code by letting it.
Programs on different machines need to talk to each other.
You’ve learned how to use I/O to communicate with files and how processes on the.
A client and server have a structured conversation called a protocol.
Programs often need to do several things at the same time.
But be careful! Threads are powerful tools, but you don’t.
In this chapter, you’ll learn how to put up traffic.
The traffic signals prevent the two threads from accessing the same shared variable at the same time.
In this lab, you’re going to pay tribute to one of the most popular and long-lived video games of them all.
There are just a few more things we think you need to know.
Ever wished all those great C facts were in one place? This is a roundup of all the C topics and principles we’ve covered in the book.
Do you prefer actually doing things and applying the stuff you learn over listening to someone in a lecture rattle on for hours on end?
Do you want to master C, create the next big thing in software, make a small fortune, and retire to your own private island?
Are you looking for a quick introduction or reference book to C?
Do you already know how to program in another programming language?
Would you rather have your toenails pulled out by 15 screaming monkeys than learn something new? Do you believe a C book should cover everything and if it bores the reader to tears in the process, then so much the better?
It was built that way, and it helps you stay alive.
So what does your brain do with all the routine, ordinary, normal things you encounter? Everything it can to stop them from interfering with the brain’s real job—recording things that matter.
It doesn’t bother saving the boring things; they never make it past the “this is obviously not important” filter.
How does your brain know what’s important? Suppose you’re out for a day hike and a tiger jumps in front of  you—what happens inside your head and body?
Or trying to learn some tough technical topic your boss thinks will take a week, ten days at the most.
It’s trying to make sure that this obviously unimportant content doesn’t clutter up scarce resources.
Resources that are better spent storing the really big things.
Like how you should never have posted those party photos on your Facebook page.
And there’s no simple way to tell your brain, “Hey brain, thank you very much, but no matter how dull this book is, and how little I’m registering on the emotional Richter scale right now, I really do want you to keep this stuff  around.”
We think of a “Head First” r eader as a learner.
So what does it take to le arn something? First, yo.
Your brain will lea rn much more quickly if it.
If  you really want to learn, and you want to learn more quickly and more deeply, pay attention to how you pay attention.
Most of  us did not take courses on metacognition or learning theory when we were growing up.
We were expected to learn, but rarely taught to learn.
But we assume that if  you’re holding this book, you really want to learn how to program in C.
And you probably don’t want to spend a lot of  time.
If  you want to use what you read in this book, you need to remember what you read.
To get the most from this book, or any book or learning experience, take responsibility for your brain.
The trick is to get your brain to see the new material you’re learning as Really Important.
Otherwise, you’re in for a constant battle, with your brain doing its best to keep the new content from sticking.
So just how DO you get your brain to treat programming like it was a hungry tiger?
There’s the slow, tedious way, or the faster, more effective way.
You obviously know that you are able to learn and remember even the dullest of  topics if  you keep pounding the same thing into your brain.
With enough repetition, your brain says, “This doesn’t feel important to him, but he keeps looking at the same thing over and over and over, so I suppose it must be.”
The faster way is to do anything that increases brain activity, especially different types of  brain activity.
The things on the previous page are a big part of  the solution, and they’re all things that have been proven to help your brain work in your favor.
For example, studies show that putting words within the pictures they describe (as opposed to somewhere else in the page, like a caption or in the body text) causes your brain to try to makes sense of  how the words and picture relate, and this causes more neurons to fire.
More neurons firing = more chances for your brain to get that this is something worth paying attention to, and possibly recording.
A conversational style helps because people tend to pay more attention when they perceive that they’re in a conversation, since they’re expected to follow along and hold up their end.
The amazing thing is, your brain doesn’t necessarily care that the “conversation” is between you and a book! On the other hand, if  the writing style is formal and dry, your brain perceives it the same way you experience being lectured to while sitting in a roomful of  passive attendees.
Here’s what WE did: We used pictures, because your brain is tuned for visuals, not text.
As far as your brain’s concerned, a picture really is worth a thousand words.
And when text and pictures work together, we embedded the text in the pictures because your brain works more effectively when the text is within the thing it refers to, as opposed to in a caption or buried in the body text somewhere.
We used redundancy, saying the same thing in different ways and with different media types, and multiple senses, to increase the chance that the content gets coded into more than one area of  your brain.
We used concepts and pictures in unexpected ways because your brain is tuned for novelty, and we used pictures and ideas with at least some emotional content, because your brain is tuned to pay attention to the biochemistry of  emotions.
That which causes you to feel something is more likely to be remembered, even if  that feeling is nothing more than a little humor, surprise, or interest.
We used a personalized, conversational style, because your brain is tuned to pay more attention when it believes you’re in a conversation than if  it thinks you’re passively listening to a presentation.
We included more than 80 activities, because your brain is tuned to learn and remember more when you do things than when you read about things.
We used multiple learning styles, because you might prefer step-by-step procedures, while someone else wants to understand the big picture first, and someone else just wants to see an example.
But regardless of  your own learning preference, everyone benefits from seeing the same content represented in multiple ways.
We include content for both sides of  your brain, because the more of  your brain you engage, the more likely you are to learn and remember, and the longer you can stay focused.
Since working one side of  the brain often means giving the other side a chance to rest, you can be more productive at learning for a longer period of  time.
And we included stories and exercises that present more than one point of  view, because your brain is tuned to learn more deeply when it’s forced to make evaluations and judgments.
We included challenges, with exercises, and by asking questions that don’t always have a straight answer, because your brain is tuned to learn and remember when it has to work at something.
Think about it—you can’t get your body in shape just by watching people at the gym.
But we did our best to make sure that when you’re working hard, it’s on the right things.
That you’re not spending one extra dendrite processing a hard-to-understand example, or parsing difficult, jargon-laden, or overly terse text.
In stories, examples, pictures, etc., because, well, you’re a person.
And your brain pays more attention to people than it does to things.
These tips are a starting point; listen to your brain and figure out what works for you and what doesn’t.
Your brain works best in a nice bath of  fluid.
Dehydration (which can happen before you ever feel thirsty) decreases cognitive function.
There’s only one way to learn to program in C: write a lot of  code.
And that’s what you’re going to do throughout this book.
Coding is a skill, and the only way to get good at it is to practice.
We’re going to give you a lot of  practice: every chapter has exercises that pose a problem for you to solve.
Don’t just skip over them—a lot of  the learning happens when you solve the exercises.
But try to solve the problem before you look at the solution.
And definitely get it working before you move on to the next part of  the book.
Groaning over a bad joke is still better than feeling nothing at all.
If  you find yourself  starting to skim the surface or forget what you just read, it’s time for a break.
Once you go past a certain point, you won’t learn faster by trying to shove more in, and you might even hurt the process.
If you’re trying to understand something, or increase your chance of  remembering it later, say it out loud.
Better still, try to explain it out loud to someone else.
You’ll learn more quickly, and you might uncover ideas you hadn’t known were there when you were reading about it.
Part of  the learning (especially the transfer to long-term memory) happens after you put the book down.
Your brain needs time on its own, to do more processing.
If  you put in something new during that processing time, some of  what you just learned will be lost.
They’re not optional sidebars, they’re part of  the core content! Don’t skip them.
Here’s what YOU can do to bend your brain into submission.
We put them in, but if  we did them for you, that would be like having someone else do your workouts for you.
There’s plenty of  evidence that physical activity while learning can increase the learning.
When the book asks you a question, don’t just skip to the answer.
The more deeply you force your brain to think, the better chance you have of  learning and remembering.
The more you understand, the less you have to memorize.
We deliberately stripped out everything that might get in the way of  learning whatever it is we’re working on at that point in the book.
And the first time through, you need to begin at the beginning, because the book makes assumptions about what you’ve already seen and learned.
We assume you’re new to C, but not to programming.
Not a lot, but we’ll assume you’ve already seen things like loops and variables in some other language, like JavaScript.
You need to install a C compiler on your computer.
Throughout the book, we’ll be using the Gnu Compiler Collection (gcc) because it’s free and, well, we think it’s just a pretty darned good compiler.
You’ll need to make sure you have gcc installed on your machine.
The good news is, if  you have a Linux computer, then you should already have gcc.
If  you’re using a Mac, you’ll need to install the Xcode/Developer tools.
You can either download these from the Apple App Store or by downloading them from Apple.
If  you’re on a Windows machine, you have a couple options.
Cygwin (http://www.cygwin.com) gives you a complete simulation of  a UNIX environment, including gcc.
But if  you want to create programs that will work on Windows plain-and-simple, then you might want to install the Minimalist GNU for Windows (MingW) from http://www.mingw.org.
All the code in this book is intended to run across all these operating systems, and we’ve tried hard not to write anything that will only work on one type of  computer.
Occasionally, there will be some differences, but we’ll make sure to point those out to you.
We begin by teaching some basic C concepts, and then we start putting C to work for you right away.
That way, by the time you make it all the way to Chapter 2, you are creating programs that actually do something real, useful, and—gulp!—fun.
The rest of  the book then builds on your C skills, turning you from C newbie to coding ninja master in no time.
The exercises and activities are not add-ons; they’re part of  the core content of  the book.
Some of  them are to help with memory, some are for understanding, and some will help you apply what you’ve learned.
One distinct difference in a Head First book is that we want you to really get it.
And we want you to finish the book remembering what you’ve learned.
Most reference books don’t have retention and recall as a goal, but this book is about learning, so you’ll see some of  the same concepts come up more than once.
Our readers tell us that it’s frustrating to wade through 200 lines of  an example looking for the two lines they need to understand.
Most examples in this book are shown within the smallest possible context, so that the part you’re trying to learn is clear and simple.
Don’t expect all of  the examples to be robust, or even complete—they are written specifically for learning, and aren’t always fully functional.
For some of  them, there is no right answer, and for others, part of  the learning experience of  the Brain Power activities is for you to decide if  and when your answers are right.
In some of  the Brain Power exercises, you will find hints to point you in the right direction.
Outside of  work, Dave likes to play guitar and piano and spend time with his wife and three kids.
Vince Milner has been developing in C (and many other languages) on a wide variety of  platforms for over 20 years.
When not studying for his master’s degree in mathematics, he can be found being beaten at board games by six-year-olds and failing to move house.
Many thanks to Brian Sawyer for asking us to write this book in the first place.
Brian believed in us every step of  the way, gave us the freedom to try out new ideas, and didn’t panic too much when deadlines loomed.
A big thank you goes to the following people who helped us out along the way: Karen Shaner for her expert image-hunting skills and for generally keeping the wheels oiled; Laurie Petrycki for keeping us well fed and well motivated while in Boston; Brian Jepson for introducing us to the wonderful world of  the Arduino; and the early release team for making early versions of  the book available for download.
Finally, thanks go to Rachel Monaghan and the production team for expertly steering the book through the production process and for working so hard behind the scenes.
We’ve made a lot of  friends on our Head First journey.
David: My thanks to Andy Parker, Joe Broughton, Carl Jacques, and Simon Jones and the many other friends who have heard so little from me whilst I was busy scribbling away.
Dawn: Work on this book would have been a lot harder without my amazing support network of  family and friends.
Our technical review team did a truly excellent job of  keeping us straight and making sure what we covered was spot on.
We’re also incredibly grateful to all the people who gave us feedback on early releases of  the book.
We think the book’s much, much better as a result.
Finally, our thanks to Kathy Sierra and Bert Bates for creating this extraordinary series of  books.
Technology professionals, software developers, web designers, and business and creative professionals use Safari Books Online as their primary resource for research, problem solving, learning, and certification training.
Safari Books Online offers a range of  product mixes and pricing programs for organizations, government agencies, and individuals.
For more information about Safari Books Online, please visit us online.
Don’t you just love the deep blue C? Come on in—the water’s lovely!
Want to get inside the computer’s head? Need to write high-performance code for a new game? Program an Arduino? Or use.
So dive in and grab your compiler, and you’ll soon get started in no time.
It’s lower-level than most other languages; that means it creates code that’s a lot closer to what machines really understand.
The compiler checks for errors, and once it’s happy, it compiles the source code.
Output The compiler creates a new file called an executable.
You convert your C code into machine code with the aid of  a compiler.
In Windows, this will be called rocks.exe instead of rocks.
There are three C standards that you may stumble across.
The differences between the different versions aren’t huge, and we’ll point them out along the way.
Try to guess what each of these code fragments does.
Don’t worry if you don’t understand all of this yet.
Everything is explained in greater detail later in the book.
Is the count more than 10? If so, display a message on the command prompt.
This displays a string on the command prompt or terminal.
This is the end of the code that should be repeated.
This will insert this string of characters here in place of the %s.
This means “store everything the user types into the ex array.”
Is it ‘C’? If so, display the word “Clubs.” Then skip past the other checks.
Is it ‘D’? If so, display the word “Diamonds.” Then skip past the other checks.
Is it ‘H’? If so, display the word “Hearts.” Then skip past the other checks.
Otherwise… Display the word “Spades.” This is the end of the tests.
A switch statement checks a single variable for different values.
But what does a complete C program look like? To create a full program, you need to enter your code into a C source file.
Let’s have a look at a typical C source file.
This is just a convention, but you should follow it.
Program to calculate the number of cards in the shoe.
So let’s look at the main() function in a little more detail.
The comment describes the purpose of  the code in the file, and might include some license or copyright information.
There’s no absolute need to include a comment here—or anywhere else in the file—but it’s good practice and what most C programmers will expect to find.
You will need to tell the compiler what external code to use by including header files for the relevant libraries.
The header you will see more than any other is stdio.h.
The stdio library contains code that allows you to read and write data from and to the terminal.
The last thing you find in a source file are the functions.
The most important function you will find in any C program is called the main() function.
The main() function is the starting point for all of  the code in your program.
The computer will start running your program from the main() function.
The name is important: if  you don’t have a function called main(), your program won’t be able to start.
So what does this mean? Well, when the computer runs your program, it will need to have some way of deciding if  the program ran successfully or not.
It does this by checking the return value of  the main() function.
If  you tell your main() function to return 0, this means that the program was successful.
If  you tell it to return any other value, this means that there was a problem.
That’s followed by the function parameters if  there are any.
It replaces format characters with the values of variables, like this:
You can include as many parameters as you like when you call the printf() function, but make sure you have a matching % format character for each one.
First parameterThe first parameter will be inserted here as a string.
Second parameterThe second parameter will be inserted here as an integer.
Because the function is called “main,” the program will start here.
The body of the function is always surrounded by braces.
Code Magnets The College Blackjack Team was working on some code on the dorm fridge, but someone mixed up the magnets! Can you reassemble the code from the magnets?
Code Magnets Solution The College Blackjack Team was working on some code on the dorm fridge, but someone mixed up the magnets! You were to reassemble the code from the magnets.
A: If your compiler supports the C99 standard, then you can begin a comment with //
The compiler treats the rest of that line as a comment.
Q: How do I know which standard my compiler supports?
But how do you run the program? C is a compiled language.
That means the computer will not interpret the code directly.
Instead, you will need to convert—or compile—the human-readable source code into machine-readable machine code.
To compile the code, you need a program called a compiler.
One of  the most popular C compilers is the GNU Compiler Collection or gcc.
Here’s how you can compile and run the program using gcc.
Save the code from the Code Magnets exercise on the opposite page in a file called cards.c.
Compile with gcc cards.c -o cards at a command prompt or terminal.
Run by typing cards on Windows, or ./cards on Mac and Linux machines.
You can compile and run your code on most machines using this trick:
You should put “zork” instead of “./zork” on a Windows machine.
This command will run the new program only if it compiles successfully.
If there’s a problem with the compile, it will skip running the program and simply display the errors on the screen.
You should create the cards.c file and compile it now.
We’ll be working on it more and more as the chapter progresses.
Test Drive Let’s see if  the program compiles and runs.
Open up a command prompt or terminal on your machine and try it out.
The program works! Congratulations! You have compiled and run a C program.
The gcc compiler took the human-readable source code from cards.c and converted it into computer-readable machine code in the cards program.
If  you are using a Mac or Linux machine, the compiler will have created the machine code in a file called cards.
But on Windows, all programs need to have a .exe extension, so the file will be called cards.exe.
Q: Why do I have to prefix the program with ./ when I run it on Linux and the Mac? A: On Unix-style operating systems, programs are run only if you specify the directory where they live or if their directory is listed in the PATH environment variable.
This line compiles the code and creates the cards program.
Remember: you can combine the compile and run steps together (turn back a page to see how)
An array of characters???? Why? Can’t we use a string or something???
The C language doesn’t support strings out of the box.
If  you’ve programmed in other languages, you’ve probably met an array before.
An array is just a list of things given a single name.
So card_name is just a variable name you use to refer to the list of  characters entered at the command prompt.
To see how this works, let’s take a deeper dive into the computer’s memory and see how C handles text…
But there are a number of C extension libraries that do give you strings.
Don’t fall off the end of the string But what happens when C wants to read the contents of  the string? Say it wants to print it out.
Now, in a lot of  languages, the computer keeps pretty close track of  the size of  an array, but C is more low-level than most languages and can’t always work out exactly how long an array is.
If  C is going to display a string on the screen, it needs to know when it gets to the end of the character array.
The sentinel character is an additional character at the end of  the string that has the value \0
Whenever the computer needs to read the contents of  the string, it goes through the elements of  the character array one at a time, until it reaches \0
That’s why in our code we had to define the card_name variable like this:
The card_name string is only ever going to record one or two characters, but because strings end in a sentinel character we have to allow for an extra character in the array.
A: The index is an offset: it’s a measure of how far the character is from the first character.
Q: Why? A: The computer will store the characters in consecutive bytes of memory.
It can use the index to calculate the location of the character.
Q: Why does it need a sentinel character? Doesn’t it know how long the string is?
Sometimes the compiler can work out the length of an array by analyzing the code, but usually C relies on you to keep track of your arrays.
Q: Does it matter if I use single quotes or double quotes?
Single quotes are used for individual characters, but double quotes are always used for strings.
They are called string literals, and they are easier to type.
Q: Are there any differences between string literals and character arrays?
Q: What does that mean? A: It means that you can’t change the individual characters once they are created.
Q: What will happen if I try? A: It depends on the compiler, but gcc will usually display a bus error.
Q: A bus error? What the heck’s a bus error?
A: C will store string literals in memory in a different way.
A bus error just means that your program can’t update that piece of memory.
In C, the equals sign (=) is used for assignment.
But a double equals sign (==) is used for testing equality.
If you want to increase or decrease a variable, then you can save space with the += and -= assignments.
Finally, if you want to increase or decrease a variable by 1, use ++ and --
Two types of command So far, every command you’ve seen has fallen into one of  the following two categories.
Do something Most of  the commands in C are statements.
Simple statements are actions; they do things and they tell us things.
You’ve met statements that define variables, read input from the keyboard, or display data to the screen.
These commands form a block statement because they are surrounded by braces.
Do something only if something is true Control statements such as if check a condition before running the code:
Do you need braces? Block statements allow you to treat a whole set of statements as if they were a single statement.
So what if you want to run several statements in an if? If you wrap a list of statements in braces, C will treat them as though they were just one statement:
Could this check if a card value is in a particular range? That might be handy…
Card counting? In C? Card counting is a way to increase your chances of  winning at blackjack.
By keeping a running count as the cards are dealt, a player can work out the best time to place large bets and the best time to place small bets.
Even though it’s a powerful technique, it’s really quite simple.
You need a set of operations that will allow you to combine conditions together.
We’ve got to check for a few values here…or do we?
There’s more to booleans than equals… So far, you’ve looked at if statements that check if  a single condition is true, but what if  you want to check several conditions? Or check if  a single condition is not true?
Both of these conditions need to be true for this piece of code to run.
The and operator is efficient: if  the first condition is false, then the computer won’t bother evaluating the second condition.
It knows that if  the first condition is false, then the whole condition must be false.
If  the first condition is true, the computer won’t bother evaluating the second condition.
It knows that if  the first condition is true, the whole condition must be true.
To C, the number 0 is the value for false.
But what’s the value for true? Anything that is not equal to 0 is treated as true.
So there is nothing wrong in writing C code like this:
You are going to modify the program so that it can be used for card counting.
It will need to display a different message if the card is a 10, Jack, Queen, or King.
The ANSI C standard has no value for true and false.
A: Because they do more than simply evaluate logical conditions.
They perform bitwise operations on the individual bits of a number.
You were to modify the program so that it can be used for card counting.
It needed to display a different message if the card is a 10, Jack, Queen, or King.
Did you spot that you just needed a single condition for this?
Test Drive Let’s see what happens when you compile and run the program now:
By combining multiple conditions with a boolean operator, you check for a range of  values rather than a single value.
You now have the basic structure in place for a card counter.
We run it a few times to check that the different value ranges work.
The count went up! Raise the bet! Raise the bet!
Head First: May I begin by thanking you, gcc, for finding time in your very busy schedule to speak to us.
Head First: gcc, you can speak many languages, is that true?
I can get by in Pascal, Fortran, PL/I, and so forth.
Head First: And on the hardware side, you can produce machine code for many, many platforms?
Generally, when a hardware engineer creates a new type of  processor, one of  the first things she wants to do is get some form of  me running on it.
I have a frontend, a part of  me that understands some type of  source code.
My frontend can convert that language into an intermediate code.
All of  my language frontends produce the same sort of  code.
Head First:  You say there are two sides to your personality?
Add to that my knowledge of  the particular executable file formats for just about every operating system you’ve ever heard of…
Head First: And yet, you are often described as a mere translator.
Do you think that’s fair? Surely that’s not all you are.
But I also look for subtler things, such as the redefinition of  variables.
Or I can warn the programmer if  he chooses to name variables after existing functions and so on.
Head First: So you check code quality as well, then?
If  I discover a section of  code inside a loop that could work equally well outside a loop, I can very quietly move it.
For extra bonus points, say what you think the output of each compiled.
For extra bonus points, say what you think the output of each compiled.
The program displays “Small card.” But it doesn’t work properly because the else is attached to the wrong if.
The program displays nothing and is not really working properly because the else is matched to the wrong if.
The code won’t compile because the braces are not matched.
Now, you can just use a sequence of  if statements, and that will probably be just fine.
But C gives you an alternative way of  writing this kind of  logic.
I wonder if there’s a more efficient way of saying that in C.
Pulling the ol’ switcheroo Sometimes when you’re writing conditional logic, you need to check the value of  the same variable over and over again.
To prevent you from having to write lots and lots of  if statements, the C language gives you another option: the switch statement.
The switch statement is kind of  like an if statement, except it can test for multiple values of  a single variable:
When the computer hits a switch statement, it checks the value it was given, and then looks for a matching case.
When it finds one, it runs all of  the code that follows it until it reaches a break statement.
The computer keeps going until it is told to break out of  the switch statement.
For any other value of train, set the winnings back to ZERO.
Most C programs have a break at the end of each case section to make the code easier to.
Let’s look at that section of your cards program again:
Do you think you can rewrite this code using a switch statement? Write your answer below:
You were to rewrite the code using a switch statement.
Q: Why would I use a switch statement instead of an if?
A: If you are performing multiple checks on the same variable, you might want to use a switch statement.
Q: What are the advantages of using a switch statement?
It is clear that an entire block of code is processing a single variable.
That’s not so obvious if you just have a sequence of if statements.
Secondly, you can use fallthrough logic to reuse sections of code for different cases.
Q: Does the switch statement have to check a variable? Can’t it check a value?
The switch statement will simply check that two values are equal.
A: No, you can’t use a switch statement to check a string of characters or any kind of array.
The computer will start to run the code at the first matching case statement.
It will continue to run until it reaches a break or gets to the end of the switch statement.
Check that you’ve included breaks in the right places; otherwise, your switches will be buggy.
Sometimes once is not enough… You’ve learned a lot about the C language, but there are still some important things to learn.
You’ve seen how to write programs for many different situations, but there is one fundamental thing that we haven’t really looked at yet.
What if  you want your program to do something again and again and again?
Using while loops in C Loops are a special type of  control statement.
A control statement decides if a section of  code will be run, but a loop statement decides how many times a piece of  code will be run.
The most basic kind of  loop in C is the while loop.
A while loop runs code over and over and over as long as some condition remains true.
When it gets to the end of the body, the computer checks if the loop condition is still true.
If you have only one line in the body, you don’t need the braces.The body is between.
There’s another form of the while loop that checks the loop condition after the loop body is run.
Here is that same piece of  code written with a for loop:
Not only do they make the code slightly shorter, but they’re also easier for other C programmers to read, because all of  the code that controls the loop—the stuff  that controls the value of  the counter variable—is now contained in the for statement and is taken out of  the loop body.
This is the text condition checked before the loop runs each time.
This is the code that will run after each loop.
Because there’s only one line in the loop body, you could actually have skipped these braces.
Every for loop needs to have something in the body.
Loops like this have code that prepares variables for the loop, some sort of  condition that is checked each time the loop runs, and finally some sort of  code at the end of  the loop that updates a counter or something similar.
You can use the while loop anytime you need to repeat a piece of  code, but a lot of  the time your loops will have the same kind of  structure:
You use break to break out… You can create loops that check a condition at the beginning or end of  the loop body.
But what if  you want to escape from the loop from somewhere in the middle? You could always restructure your code, but sometimes it’s just simpler skip out of  the loop immediately using the break statement:
A break statement will break you straight out of  the current loop, skipping whatever follows it in the loop body.
But you might want to avoid using too many, because they can also make the code a little harder to read.
The break statement is used to break out of loops and also.
Make sure that you know what you’re breaking out of when you break.
The cause? A developer working on the C code used in the exchanges tried to use a break to break out of an if statement.
Instead, the program skipped an entire section of code and introduced a bug that interrupted 70 million phone calls over nine hours.
Before you try out your new loop mojo, let’s go on a detour and take a quick look at functions.
So far, you’ve had to create one function in every program you’ve written, the main() function:
Pretty much all functions in C follow the same format.
For example, this is a program with a custom function that gets called by main():
The larger() function is slightly different from main() because it takes arguments or parameters.
An argument is just a local variable that gets its value from the code that calls the function.
The larger() function takes two arguments—a and b—and then it returns the value of  whichever one is larger.
The main() function has an int return type, so you should include a return statement when you get to the end.
But if you leave the return statement out, the code will still compile—though you may get a warning from the compiler.
A C99 compiler will insert a return statement for you if you forget.
Most functions in C have a return value, but sometimes you might want to create a function that has nothing useful to return.
Normally, functions always have to contain a return statement, but not if  you give your function the return type void:
As soon as you tell the C compiler that you don’t care about returning a value from the function, you don’t need to have a return statement in your function.
Almost everything in C has a return value, and not just function calls.
So why does that matter? Because it means you can do cool tricks, like chaining assignments together:
In fact, you can shorten the code slightly by removing the parentheses:
You’ll often see chained assignments in code that needs to set several variables to the same value.
Q: If I create a void function, does that mean it can’t contain a return statement?
A: You can still include a return statement, but the compiler will most likely generate a warning.
Also, there’s no point to including a return statement in a void function.
Q: Really? Why not? A: Because if you try to read the value of your void function, the compiler will refuse to compile your code.
The void return type means the function won’t return anything.
There’s no need for a return statement because it’s a void function.
Your challenge is to match the candidate block of code (on the left) with the output that you’d see if the block were inserted.
Not all of the lines of output will be used, and some of the lines of output might be used more than once.
Draw lines connecting the candidate blocks of code with their matching command-line output.
Now that you know how to create while loops, modify the program to keep a running count of the card game.
Display the count after each card and end the program if the player types X.
You should also skip the rest of the loop body and try again.
Your challenge was to match the candidate block of code (on the left) with the output that you’d see if the block were inserted.
You were to draw lines connecting the candidate blocks of code with their matching command-line output.
Now that you know how to create while loops, you were to modify the program to keep a running count of the card game.
Display the count after each card and end the program if the player types X.
You need to check if the first character was an X.
We need a continue to go back and check the loop condition again.
Test Drive Now that the card-counting program is finished, it’s time to take it for a spin.
The card counting program works! You’ve completed your first C program.
By using the power of  C statements, loops, and conditions, you’ve created a fully functioning card counter.
By betting big when the count was high, I made a fortune!
We now check if it looks like a correct card value.
Disclaimer: Using a computer for card counting is illegal in many states, and those casino guys can get kinda gnarly.
Q: Why do I need to compile C? Other languages like JavaScript aren’t compiled, are they?
Even though there are languages that aren’t compiled, some of those—like JavaScript and Python—often use some sort of hidden compilation to improve their speed.
C++ was originally designed as an extension of C, but now it’s a little more than that.
C++ and Objective-C were both created to use object orientation with C.
Q: What’s object orientation? Will we learn it in this book?
A: Object orientation is a technique to deal with complexity.
A: C has a very compact syntax and it’s influenced many other languages.
A: The Gnu Compiler Collection can be used to compile many languages, though C is probably still the language with which it’s used most frequently.
If the condition on a loop is the value 1, then the loop will run forever.
Q: Is it a good idea to create a loop that runs forever?
An infinite loop (a loop that runs forever) is often used in programs like network servers that perform one thing repeatedly until they are stopped.
But most coders design loops so that they will stop sometime.
A while loop runs code as long as its condition is true.
A do-while loop is similar, but runs the code at least once.
The for loop is a more compact way of writing certain kinds of loops.
You can exit a loop at any time with break.
You can skip to the loop condition at any time with continue.
Assignments have values so you can chain them together (x = y = 0)
You can use the && operator on the command line to run your program only if it compiles.
Your C Toolbox You’ve got Chapter 1 under your belt, and now you’ve.
Your source files should have a name ending in .c.
If  you really want to kick butt with C, you need to understand how C handles memory.
The C language gives you a lot more control over how your program uses the computer’s.
In this chapter, you’ll strip back the covers and see exactly what happens when.
You’ll learn how arrays work, how to avoid some nasty.
So what’s a pointer? A pointer is just the address of  a piece of  data in memory.
Pointers are used in C for a couple of  reasons.
Instead of passing around a whole copy of the data, you can just pass a pointer.
You might want two pieces of code to work on the same piece of data rather than a separate copy.
Pointers help you do both these things: avoid copies and share data.
But if  pointers are just addresses, why do some people find them confusing? Because they’re a form of  indirection.
If  you’re not careful, you can quickly get lost chasing pointers through memory.
The trick to learning how to use C pointers is to go slowly.
Take frequent breaks, drink plenty of  water, and if  you really get stuck, take a nice long bath.
I’ve got the answer you need; it’s right here in the Encyclopedia Britannica.
You were supposed to sign the birthday card we left in the lunch room.
Digging into memory To understand what pointers are, you’ll need to dig into the memory of  the computer.
Every time you declare a variable, the computer creates space for it somewhere in memory.
If  you declare a variable inside a function like main(), the computer will store it in a section of  memory called the stack.
If a variable is declared outside any function, it will be stored in the globals section of  memory.
The computer might allocate, say, memory location 4,100,000 in the stack for the x variable.
If  you want to find out the memory address of  the variable, you can use the & operator:
The address of  the variable tells you where to find the variable in memory.
That’s why an address is also called a pointer, because it points to the variable in memory.
A variable declared inside a function is usually stored in the stack.
A variable declared outside a function is stored in globals.
Set sail with pointers Imagine you’re writing a game in which players have to navigate their way around the…
The game will need to keep control of  lots of  things, like scores and lives and the current location of  the players.
You won’t want to write the game as one large piece of  code; instead, you’ll create lots of  smaller functions that will each do something useful in the game:
What does any of  this have to do with pointers? Let’s begin coding without worrying about pointers at all.
A major part of  the game is going to be navigating your ship around the Bermuda Rectangle, so let’s dive deeper into what the code will need to do in one of  the navigation functions.
Set sail sou’east, Cap’n The game will track the location of  players using latitudes and longitudes.
The latitude is how far north or south the player is, and the longitude is her position east or west.
If  a player wants to travel southeast, that means her latitude will go down, and her longitude will go up:
So you could write a go_south_east() function that takes arguments for the latitude and longitude, which it will then increase and decrease:
But if  you compile and run the program, this happens:
But if  that’s how C calls functions, how can you ever write a function that updates a variable?
When the computer calls the go_south_east() function, it copies the value of  the longitude variable to the lon argument.
This is just an assignment from the longitude variable to the lon variable.
When you call a function, you don’t send the variable as an argument, just its value.
When the go_south_east() function changes the value of  lon, the function is just changing its local copy.
This is a new variable containing a copy of the longitude value.
Q: I printed the location of the variable on my machine and it wasn’t 4,100,000
The memory location your program uses for the variables will be different from machine to machine.
Q: Why are local variables stored in the stack and globals stored somewhere else?
You will only ever get one copy of a global variable, but if you write a function that calls itself, you might get very many instances of the same local variable.
Q: What are the other areas of the memory used for?
A: You’ll see what the other areas are for as you go through the rest of the book.
All the function needs to do is read and update the contents of  memory location 4,100,000
Because the go_south_east() function is updating the original latitude variable, the computer will be able to print out the updated location when it returns to the main() function.
Pointers make it easier to share memory This is one of  the main reasons for using pointers—to let functions share memory.
The data created by one function can be modified by another function, so long as it knows where to find it in memory.
Instead of passing the value of the variable, pass its location.
Using memory pointers There are three things you need to know in order to use pointers to read and write data.
You’ve already seen that you can find where a variable is stored in memory using the & operator:
But once you’ve got the address of  a variable, you may want to store it somewhere.
A pointer variable is just a variable that stores a memory address.
When you declare a pointer variable, you need to say what kind of  data is stored at the address it will point to:
When you have a memory address, you will want to read the data that’s stored there.
The & operator takes a piece of  data and tells you where it’s stored.
The * operator takes an address and tells you what’s stored there.
Because pointers are sometimes called references, the * operator is said to dereference a pointer.
If  you have a pointer variable and you want to change the data at the address where the variable’s pointing, you can just use the * operator again.
But this time you need to use it on the left side of an assignment:
OK, now that you know how to read and write the contents of a memory location, it’s time for you to fix the go_south_east() function.
The %p format will print out the location in hex (base 16) format.
This is a pointer variable for an address that stores an int.
This will read the contents at the memory address given by address_of_x.
This will be set to 4: the value originally stored in the x variable.
Compass Magnets Now you need to fix the go_south_east() function so that it uses pointers to update the correct data.
Think carefully about what type of data you want to pass to the function, and what operators you’ll need to use to update the location of the ship.
What kinds of arguments will store memory addresses for ints?
Compass Magnets Solution You needed to fix the go_south_east() function so that it uses pointers to update the correct data.
You were to think carefully about what type of data you want to pass to the function, and what operators you’ll need to use to update the location of the ship.
The arguments will store pointers so they need to be int *
You need to find the address of the latitude and longitude variables with &
Test Drive Now if  you compile and run the new version of  the function, you get this:
Because the function takes pointer arguments, it’s able to update the original latitude and longitude variables.
That means that you now know how to create functions that not only return values, but can also update any memory locations that are passed to them.
The * operator can read the contents of a memory address.
The * operator can also set the contents of a memory address.
Q: Are pointers actual address locations? Or are they some other kind of reference?
Q: What does that mean? A: Each process is given a simplified version of memory to make it look like a single long sequence of bytes.
Q: And memory’s not like that? A: It’s more complicated in reality.
But the details are hidden from the process so that the operating system can move the process around in memory, or unload it and reload it somewhere else.
Q: Is memory not just a long list of bytes?
A: The computer will probably structure its physical memory in a more complex way.
The machine will typically group memory addresses into separate banks of memory chips.
Q: Do I need to understand this? A: For most programs, you don’t need to worry about the details of how the machine arranges its memory.
Q: Why do I have to print out pointers using the %p format string?
On most modern machines, you can use %li—although the compiler may give you a warning if you do.
Q: Why does the %p format display the memory address in hex format?
A: It’s the way engineers typically refer to memory addresses.
Q: If reading the contents of a memory location is called dereferencing, does that mean that pointers should be called references?
A: Sometimes coders will call pointers references, because they refer to a memory location.
However, C++ programmers usually reserve the word reference for a slightly different concept in C++
How do you pass a string to a function? You know how to pass simple values as arguments to functions, but what if  you want to send something more complex to a function, like a string? If  you remember from the last chapter, strings in C are actually arrays of characters.
That means if  you want to pass a string to a function, you can do it like this:
The msg argument is defined like an array, but because you won’t know how long the string will be, the msg argument doesn’t include a length.
That seems straightforward, but there’s something a little strange going on…
Honey, who shrank the string? C has an operator called sizeof that can tell you how many bytes of space something takes in memory.
You can either call it with a data type or with a piece of  data:
But a strange thing happens if  you look at the length of  the string you’ve passed in the function:
What’s happened? Why does it think the string we passed in is shorter?
And on some machines, this might even say 4! What gives?
Why do you think sizeof(msg) is shorter than the length of the whole string? What is msg? Why would it return different sizes on different machines?
Array variables are like pointers… When you create an array, the array variable can be used as a pointer to the start of  the array in memory.
When C sees a line of code in a function like this:
The computer will set aside space on the stack for each of  the characters in the string, plus the \0 end character.
But it will also associate the address of  the first character with the quote variable.
Every time the quote variable is used in the code, the computer will substitute it with the address of  the first character in the string.
In fact, the array variable is just like a pointer:
Even though it looked like you were passing a string to the fortune_cookie() function, you were actually just passing a pointer to it:
And that’s why the sizeof operator returned a weird result.
It was just returning the size of  a pointer to a string.
You can use “quote” as a pointer variable, even though it's an array.
If you write a test program to display the address, you will see something like this.
The quote variable will represent the address of the first character in the string.
Hmmm…looks like they intend to pass an array to this function.
That means the function will receive the value of the array variable, which will be an address, so msg will be a pointer to a char.
I can print the message because I know it starts at location msg.
That’s a pointer variable, so the answer is 8 bytes because that’s how much memory it takes for me to store a pointer.
So quote’s an array and I’ve got to pass the quote variable to fortune_cookie()
I’ll set the msg argument to the address where the quote array starts in memory.
The array variable points to the first element in the array.
If you declare an array argument to a function, it will be treated as a pointer.
The sizeof operator returns the space taken by a piece of data.
You can also call sizeof for a data type, such as sizeof(int)
Q: Is sizeof a function? A: No, it’s an operator.
Q: What’s the difference? A: An operator is compiled to a sequence of instructions by the compiler.
But if the code calls a function, it has to jump to a separate piece of code.
Q: So is sizeof calculated when the program is compiled?
The compiler can determine the size of the storage at compile time.
Q: If I create a pointer variable, does the pointer variable live in memory?
A pointer variable is just a variable storing a number.
Q: So can I find the address of a pointer variable? A: Yes—using the & operator.
Q: Can I convert a pointer to an ordinary number? A: On most systems, yes.
So if p is a pointer and you want to store it in a long variable a, you can type a = (long)p.
Tonight’s lucky lady is going to pick one of these fine contestants.
Look at the code below, and write your answer here.
But array variables aren’t quite pointers Even though you can use an array variable as a pointer, there are still a few differences.
To see the differences, think about this piece of  code.
But if  you call sizeof on an array variable, C is smart enough to understand that what you want to know is how big the array is in memory.
The address of the array...is the address of the array.
A pointer variable is just a variable that stores a memory address.
But what about an array variable? If  you use the & operator on an array variable, the result equals the array variable itself.
But if  someone writes &t, that means “What is the address of  the t variable?”
But what if you create an array? The computer will allocate space to store the array, but it won’t allocate any memory to store the array variable.
The compiler simply plugs in the address of  the start of  the array.
But because array variables don’t have allocated storage, it means you can’t point them at anything else.
Pointer decay Because array variables are slightly different from pointer variables, you need to be careful when you assign arrays to pointers.
If you assign an array to a pointer variable, then the pointer variable will only contain the address of the array.
The pointer doesn’t know anything about the size of the array, so a little information has been lost.
Every time you pass an array to a function, you’ll decay to a pointer, so it’s unavoidable.
But you need to keep track of where arrays decay in your code because it can cause very subtle bugs.
The Case of  the Lethal List The mansion had all the things he’d dreamed of: landscaped grounds, chandeliers, its own bathroom.
The 94-year-old owner, Amory Mumford III, had been found dead in the garden, apparently of  a heart attack.
Natural causes? The doc thought it was an overdose of heart medication.
Something stank here, and it wasn’t just the dead guy in the gazebo.
They say I wrote this code, but I don’t even think it’ll compile.
She slipped her manicured fingers into her purse and handed him a copy of  the program the police had found lying by the millionaire’s bed.
A dose of  size 3 wouldn’t have killed the old guy.
But maybe there was more to this code than met the eye…
Why arrays really start at 0 An array variable can be used as a pointer to the first element in an array.
That means you can read the first element of  the array either by using the brackets notation or using the * operator like this:
But because an address is just a number, that means you can do pointer arithmetic and actually add values to a pointer value and find the next address.
In general, the two expressions drinks[i] and *(drinks + i) are equivalent.
The index is just the number that’s added to the pointer to find the location of the element.
Use the power of pointer arithmetic to mend a broken heart.
This function will skip the first six characters of the text message.
What expression do you need here to print from the seventh character?
The function needs to print this message from the ‘c’ character on.
You were to use the power of pointer arithmetic to mend a broken heart.
This function skips the first six characters of the text message.
Why pointers have types If  pointers are just addresses, then why do pointer variables have types? Why can’t you just store all pointers in some sort of  general pointer variable?
If  you add 1 to a char pointer, the pointer will point to the very next memory address.
But that’s just because a char occupies 1 byte of  memory.
If  you run this code, the two memory address will be more than one byte apart.
So pointer types exist so that the compiler knows how much to adjust the pointer arithmetic.
Pointer variables have different types for each type of data.
Last time we left our hero interviewing Bubbles Mumford, whose husband had been given an overdose as a result of suspicious code.
Was Bubbles the coding culprit or just a patsy? To find out, read on…
Bubbles, you know a lot more about C than you let on.
I knew something was wrong when I saw the expression 3[doses]
You knew you could use an array variable like doses as a pointer.
It issued a dose of  1,000 to the old guy.
Pointer variables have types so they can adjust pointer arithmetic.
Q: Do I really need to understand pointer arithmetic? A: Some coders avoid using pointer arithmetic because it’s easy to get it wrong.
But it can be used to process arrays of data efficiently.
But be careful that you don’t go back before the start of the allocated space in the array.
Q: When does C adjust the pointer arithmetic calculations? A: It happens when the compiler is generating the executable.
It looks at the type of the variable and then multiplies the pluses and minuses by the size of the underlying variable.
Q: Does C use the sizeof operator when it is adjusting pointer arithmetic?
The sizeof operator is also resolved at compile time, and both sizeof and the pointer arithmetic operations will use the same sizes for different data types.
Using pointers for data entry You already know how to get the user to enter a string from the keyboard.
How does scanf() work? It accepts a char pointer, and in this case you’re passing it an array variable.
By now, you might have an idea why it takes a pointer.
It’s because the scanf() function is going to update the contents of  the array.
Functions that need to update a variable don’t want the value of  the variable itself—they want its address.
Entering numbers with scanf() So how do you enter data into a numeric field? You do it by passing a pointer to a number variable.
Use the & operator to get the address of the int.
Because you pass the address of  a number variable into the function, scanf() can update the contents of  the variable.
And to help you out, you can pass a format string that contains the same kind of  format codes that you pass to the printf() function.
You can even use scanf() to enter more than one piece of  information at a time:
This reads a first name, then a space, then the second name.
The first and last names are stored in separate arrays.
Be careful with scanf() There’s a little…problem with the scanf() function.
So far, all of  the code you’ve written has very carefully put a limit on the number of  characters that scanf() will read into a function:
Why is that? After all, scanf() uses the same kind of  format strings as printf(), but when we print a string with printf(), you just use %s.
Well, if  you just use %s in scanf(), there can be a problem if  someone gets a little type-happy:
The reason is because scanf() writes data way beyond the end of  the space allocated to the food array.
The extra data then gets written into memory that has not been properly allocated by the computer.
Now, you might get lucky and the data will simply be stored and not cause any problems.
But it’s very likely that buffer overflows will cause bugs.
It might be called a segmentation fault or an abort trap, but whatever the error message that appears, the result will be a crash.
From the “-” on, this code is in illegal space.
Just like the scanf() function, it takes a char pointer, but unlike the scanf() function, the fgets() function must be given a maximum length:
OK, what else do you need to know about fgets()?
Using sizeof with fgets() The code above sets the maximum length using the sizeof operator.
Remember: sizeof returns the amount of  space occupied by a variable.
In the code above, food is an array variable, so sizeof returns the size of  the array.
If  food was just a simple pointer variable, the sizeof operator would have just returned the size of  a pointer.
If  you know that you are passing an array variable to fgets() function, then using sizeof is fine.
If  you’re just passing a simple pointer, you should just enter the size you want:
If food was a simple pointer, you’d give an explicit length, rather than using sizeof.
The fgets() function actually comes from an older function called gets()
Even though fgets() is seen as a safer-to-use function than scanf(), the truth is that the older gets() function is far more dangerous than either of them.
The reason? The gets() function has no limits at all:
But all you really need to know is that you really shouldn’t use it.
Next, it takes a maximum size of the string (‘/0’ included)
Roll up! Roll up! It’s time for the title fight we’ve all been waiting for.
In the red corner: nimble light, flexible but oh-so-slightly dangerous.
And in the blue corner, he’s simple, he’s safe, he’s the function you’d want to introduce to your mom: it’s fgets()!
Yes! scanf() will not only allow you to enter more than one field, but it also allows you to enter structured data including the ability to specify what characters appear between fields.
When scanf() reads a string with the %s, it stops as soon as it hits a space.
So if  you want to enter more than one word, you either have to call it more than once, or use some fancy regular expression trick.
Do you limit the number of characters that a user can enter?
Can you be used to enter more than one field?
Clearly, if you need to enter structured data with several fields, you’ll want to use scanf()
If you’re entering a single unstructured string, then fgets() is probably the way to go.
Anyone for three-card monte? In the back room of  the Head First Lounge, there’s a game of  three-card monte going on.
Someone shuffles three cards around, and you have to watch carefully and decide where you think the Queen card went.
Of  course, being the Head First Lounge, they’re not using real cards; they’re using code.
The code is designed to shuffle the letters in the three-letter string “JQK.” Remember: in C, a string is just an array of characters.
The program switches the characters around and then displays what the string looks like.
The players place their bets on where they think the “Q” letter will be, and then the code is compiled and run.
When the code is compiled and run on the Lounge’s notebook computer, this happens:
What’s more, if  the guys try the same code on different machines and operating systems, they get a whole bunch of different errors:
Read through these possible answers and select only the one you think is correct.
What’s Your Hunch? It was time to use your intuition.
You were to read through these possible answers and select only the one you think is correct.
String literals can never be updated A variable that points to a string literal can’t be used to change the contents of  the string:
But if  you create an array from a string literal, then you can modify it:
When the computer loads the program into memory, it puts all of  the constant values—like the string literal “JQK”—into the constant memory block.
The stack is the section of  memory that the computer uses for local variables: variables inside functions.
The cards variable is set to the address of “JQK.” The cards variable will contain the address of  the string literal “JQK.” String literals are usually stored in read-only memory to prevent anyone from changing them.
When the program tries to change the contents of  the string pointed to by the cards variable, it can’t; the string is read-only.
So the problem is that string literals like “JQK” are held in read only memory.
But if that’s the problem, how do you fix it?
To understand why this line of  code causes a memory error, we need to dig into the memory of  the computer and see exactly what the computer will do.
If you’re going to change a string, make a copy.
But in the old code, cards was just a pointer.
If  you declare an array called cards and then set it to a string literal, the cards array will be a completely new copy.
It’s a brand-new array that contains a fresh copy of  the string literal.
To see how this works in practice, you’ll need to look at what happens in memory.
The truth is that if  you want to change the contents of  a string, you’ll need to work on a copy.
If  you create a copy of  the string in an area of  memory that’s not read-only, there won’t be a problem if  you try to change the letters it contains.
But how do you make a copy? Well, just create the string as a new array.
If you see a declaration like this, what does it really mean?
If it’s a normal variable declaration, then it means that cards is an array, and you have to set it to a value immediately:
But if cards is being declared as a function argument, it means that cards is a pointer:
There’s no array size given, so you have to set it to something immediately.
As before, when the computer loads the program into memory, it stores the constant values—like the string “JQK”—into read-only memory.
We’re declaring an array, so the program will create one large enough to store the “JQK” string—four characters’ worth.
But as well as allocating the space, the program will also copy the contents of  the string literal “JQK” into the stack memory.
So the difference is that the original code used a pointer to point to a read-only string literal.
But if  you initialize an array with a string literal, you then have a copy of  the letters, and you can change them as much as you like.
We’ve already seen what happens with the broken code, but what about our new code? Let’s take a look.
Test Drive See what happens if  you construct a new array in the code.
The code works! Your cards variable now points to a string in an unprotected section of  memory, so we are free to modify its contents.
One way to avoid this problem in the future is to never write code that sets a simple char pointer to a string literal value like:
There’s nothing wrong with setting a pointer to a string literal—the problems only happen when you try to modify a string literal.
Instead, if you want to set a pointer to a literal, always make sure you use the const keyword:
That way, if the compiler sees some code that tries to modify the string, it will give you a compile error:
You’ve gotta help me…you gotta clear his name! Jimmy was innocent, I tells you.
Jimmy Blomstein worked tables at the local Starbuzz and spent his weekends cycling and working on his taxidermy collection.
He hoped one day to save up enough for an elephant.
The Masked Raider had met Jimmy in the morning for coffee and they’d both been alive:
Then, that afternoon, the Masked Raider had gone off  to pull a heist, like a hundred heists he’d pulled before.
But this time, he hadn’t reckoned on the crowd of  G-Men enjoying their weekly three-card monte session in the back room of  the Head First Lounge.
A rattle of  gunfire, a scream, and moments later the villain was lying on the sidewalk, creating a public health hazard:
Problem is, when Toots here goes to check in with her boyfriend at the coffee shop, she’s told he’s served his last orange mocha frappuccino:
So what gives? How come a single magic bullet killed Jimmy and the Masked Raider? What do you think happened?
How come a single magic bullet killed Jimmy and the Masked Raider?
Jimmy, the mild-mannered barista, was mysteriously gunned down at the same time as arch-fiend the Masked Raider:
It took the detective a while to get to the bottom of  the mystery.
While he was waiting, he took a long refreshing sip from a Head First Brain Booster Fruit Beverage.
He sat back in his seat and looked across the desk at her blue, blue eyes.
She was like a rabbit caught in the headlights of  an oncoming truck, and he knew that he was at the wheel.
She took a sharp intake of  breath and raised her hand to her mouth.
Note from Marketing: ditch the product placement for the Brain Booster drink; the deal fell through.
Q: Why didn’t the compiler just tell me I couldn’t change the string?
A: Because we declared the cards as a simple char *, the compiler didn’t know that the variable would always be pointing at a string literal.
Some versions of gcc on Cygwin actually allow you to modify a string literal without complaining.
Q: What does const actually mean? Does it make the string readonly?
The const modifier means that the compiler will complain if you try to modify an array with that particular variable.
Q: Do the different memory segments always appear in the same order in memory?
A: They will always appear in the same order for a given operating system.
For example, Windows doesn’t place the code in the lowest memory addresses.
Q: I still don’t understand why an array variable isn’t stored in memory.
A: When the program is compiled, all the references to array variables are replaced with the addresses of the array.
So the truth is that the array variable won’t exist in the final executable.
That’s OK because the array variable will never be needed to point anywhere else.
Q: If I set a new array to a string literal, will the program really copy the contents each time?
The final machine code will either copy the bytes of the string literal to the array, or else the program will simply set the values of each character every time it reaches the declaration.
A: A declaration is a piece of code that declares that something (a variable, a function) exists.
A definition is a piece of code that says what something is.
If you declare a variable and set it to a value (e.g., int x = 4;), then the code is both a declaration and a definition.
A: scanf() means “scan formatted” because it’s used to scan formatted input.
If you see a * in a variable declaration, it means the variable will be a pointer.
If you want to modify a string, you need to make a copy in a new array.
You can declare a char pointer as const char * to prevent the code from using it to modify a string.
Stack This is the section of  memory used for local variable storage.
Every time you call a function, all of  the function’s local variables get created on the stack.
It’s called the stack because it’s like a stack of  plates: variables get added to the stack when you enter a function, and get taken off  the stack when you leave.
It starts at the top of  memory and grows downward.
Heap This is a section of  memory we haven’t really used yet.
The heap is for dynamic memory: pieces of  data that get created when the program is running and then hang around a long time.
You’ll see later in the book how you’ll use the heap.
Globals A global variable is a variable that lives outside all of  the functions and is visible to all of  them.
Globals get created when the program first runs, and you can update them freely.
Constants Constants are also created when the program first runs, but they are stored in read-only memory.
Constants are things like string literals that you will need when the program is running, but you’ll never want them to change.
A lot of  operating systems place the code right down in the lowest memory addresses.
This is the part of  the memory where the actual assembled code gets loaded.
Your C Toolbox You’ve got Chapter 2 under your belt, and now you’ve.
A char pointer variable x is declared as char *x.
You’ve seen how strings in C are actually char arrays but what does C allow you to do.
In this chapter, you’ll see how to create an array of strings, and then take a close.
I thought it called you short and said your butt was bigger.
Desperately seeking Susan There are so many tracks on the retro jukebox that people can’t find the music they are looking for.
To help the customers, the guys in the Head First Lounge want you to write another program.
Gah! Wayne Newton… again! We need a search program to help people find tracks on the jukebox.
The list is likely to get longer, so there’s just the first few tracks for now.
You’ll need to write a C program that will ask the user which track she is looking for, and then get it to search through all of  the tracks and display any that match.
How do you think you can record that information in C?
The guys say that there will be lots more tracks in the future, but they’ll never be more than 79 characters long.
Create an array of arrays There are several track names that you need to record.
You can record several things at once in an array.
That means you need to create an array of  arrays, like this:
That means that you’ll be able to find an individual track name like this:
But you can also read the individual characters of  each of  the strings if  you want to:
So now that you know how to record the data in C, what do you need to do with it?
This first set of brackets is for the array of all strings.
The compiler can tell that you have five strings, so you don’t need a number between these brackets.
The second set of brackets is used for each individual string.
Each string is an array, so this is an array of arrays.
The array of  arrays looks something like this in memory:
Find strings containing the search text The guys have helpfully given you a spec.
You also know how to read the value of  an individual track name, so it shouldn’t be too difficult to loop through each of  them.
You even know how to ask the user for a piece of  text to search for.
But how do you look to see if  the track name contains a given piece of  text?
Using string.h The C Standard Library is a bunch of  useful code that you get for free when you install a C compiler.
The library code does useful stuff  like opening files, or doing math, or managing memory.
Now, chances are, you won’t want to use the whole of  the Standard Library at once, so the library is broken up into several sections, and each one has a header file.
The header file lists all of  the functions that live in a particular section of  the library.
So far, you have only really used the stdio.h header file.
But the Standard Library also contains code to process strings.
String processing is required by a lot of  the programs, and the string code in the Standard Library is tested, stable, and fast.
There are plenty of other exciting things in string.h for you to play with; this is just for starters.
You’ll use both stdio.h and string.h in your jukebox program.
You include the string code into your program using the string.h header file.
You add it at the top of  your program, just like you include stdio.h.
See if  you can match up each string.h function with the description of what it does.
Which of the functions above should you use for the jukebox program? Write your answer below.
You were to write which of the above functions you should use for the jukebox program.
You were to match up each string.h function with the description of what it does.
Using the strstr() function So how exactly does the strstr() function work? Let’s look at an example.
Let’s say you’re looking for the string “fun” inside a larger string, “dysfunctional.” You’d call it like this:
The strstr() function will search for the second string in the first string.
If  it finds the string, it will return the address of  the located string in memory.
In the example here, the function would find that the fun substring begins at memory location 4,000,003
Can you think why that is? Well, if  you remember, C treats zero as false.
That means you can use strstr() to check for the existence of  one string inside another, like this:
Let’s see how we can use strstr() in the jukebox program.
Pool Puzzle The guys in the Lounge had already started to write.
Do you think you can select the correct pieces of code to complete the search function? It’s been a while since the pool was cleaned, so.
Note: the guys have slipped in a couple of new pieces of code they found in a book somewhere.
Note: each thing from the pool can be used only once!
Presumably, when you get around to writing the main() function, it will call this.
This is the “for loop.” We’ll look at this in more detail in a while, but for now you just need to know that it will run this piece of code five times.
If the track name matches our search, you'll display it here.
Your job is to play like you’re the compiler and say which of the following main() functions is the one you need for the.
You were to select the correct pieces of code to complete the search function.
Note: the guys have slipped in a couple of new pieces of code they found in a book somewhere.
Your job was to play like you’re the compiler and say which of the following main() functions is the one you.
This version isn’t using the full length of the array.
The coder has subtracted one from the length, like you would with scanf()
This version is using scanf() and would allow the user to enter 81 characters into the array.
It’s time for a code review Let’s bring the code together and review what you’ve got so far:
It’s important that you assemble the code in this order.
The headers are included at the top so that the compiler will have all the correct functions before it compiles your code.
Then you define the tracks before you write the functions.
This is called putting the tracks array in global scope.
A global variable is one that lives outside any particular function.
Global variables like tracks are available to all of  the functions in the program.
Finally, you have the functions: find_track() first, followed by main()
The find_track() function needs to come first, before you call it from main()
You still need to stdio.h for the printf() and scanf() functions.
You will also need the string.h header, so you can search.
You’ll need to declare it here before you call it from main()
And this is your main() function, which is the starting point of the program.
Now you call your new find_track() function and display the matching tracks.
It’s time to fire up the terminal and see if  the code works.
And the great news is, the program works! Even though this program is a little longer than any code you’ve written so far, it’s actually doing a lot more.
It creates an array of strings and then uses the string library to search through all of them to find the music track that the user was looking for.
The cats in the bar are groovin’ on down to a whole heap of Sinatra goodness! Geek Bits.
For more information about the functions available in string.h, see http://tinyurl.com/82acwue.
If you are using a Mac or a Linux machine, you can find out more about each of the string.h functions like strstr() by typing:
A: You could have defined it that way, but the compiler can tell there are five items in the list, so you can skip the [5] and just put []
Q: But in that case, why couldn’t we just say tracks[][]?
A: The track names are all different lengths, so you need to tell the compiler to allocate enough space for even the largest.
Q: Does that mean each string in the tracks array is 80 characters, then?
A: The program will allocate 80 characters for each string, even though each of them is much smaller.
Q: What happens if I forget to include a header file like string.h?
A: For some header files, the compiler will give you a warning and then include them anyway.
For other header files, the compiler will simply give a compiler error.
Q: Why did we put the tracks array definition outside of the functions?
Global variables can be used by all functions in the program.
Q: Now that we’ve created two functions, how does the computer know which one to run first?
A: The program will always run the main() function first.
Q: Why do I have to put the find_track() function before main()?
A: C needs to know what parameters a function takes and what its return type is before it can be called.
Q: What would happen if I put the functions in a different order?
A: In that case, you’d just get a few warnings.
The first set of brackets is used to access the outer array.
The second set of brackets is used to access the details of each of the inner arrays.
The string.h header file gives you access to a set of string manipulation functions in the C Standard Library.
You can create several functions in a C program, but the computer will always run main() first.
Code Magnets The guys are working on a new piece of code for a game.
They’ve created a function that will display a string backward on the screen.
Unfortunately, some of the fridge magnets have moved out of place.
Do you think you can help them to reassemble the code?
Code Magnets Solution The guys are working on a new piece of code for a game.
They’ve created a function that will display a string backward on the screen.
Unfortunately, some of the fridge magnets have moved out of place.
An array of  pointers is actually what it sounds like: a list of  memory addresses stored in an array.
It’s very useful if  you want to quickly create a list of  string literals:
There will be one pointer pointing at each string literal.
You can access the array of  pointers just like you accessed the array of  arrays.
C-Cross Now that the guys have the print_reverse() function working, they’ve used it to create a crossword.
The answers are displayed by the output lines in the code.
C-Cross Solution Now that the guys have the print_reverse() function working, they’ve used it to create a crossword.
The answers are displayed by the output lines in the code.
Your C Toolbox You’ve got Chapter 2.5 under your belt, and now you’ve.
It’s all about picking the right tool for the right job…
Small tools written in C perform specialized small tasks, such as reading and writing.
If you want to perform more complex tasks, you can even link.
But how are these small tools built? In this chapter, you’ll look.
Small tools can solve big problems A small tool is a C program that does one task and does it well.
It might display the contents of  a file on the screen or list the processes running on the computer.
Or it might display the first 10 lines of  a file or send it to the printer.
Most operating systems come with a whole set of  small tools that you can run from the command prompt or the terminal.
Sometimes, when you have a big problem to solve, you can break it down into a series of  small problems, and then write small tools for each of  them.
Someone’s written me a map web application, and I’d love to publish my route data with it.
Trouble is, the format of the data coming from my GPS is wrong.
If one small part of your program needs to convert data from one format to another, that’s the perfect kind of task for a small tool.
A small tool does one task and does it well.
The data’s the same, but the format’s a little different.
Hey, who hasn’t taken a code printout on a long ride only to find that it soon becomes… unreadable? Sure, we all have.
But with a little thought, you should be able to piece together the original version of some code.
This program can read comma-separated data from the command line and then display it in JSON format.
See if you can figure out what the missing code is.
We’re using scanf() to enter more than one piece of data.
This is just a way of saying, “Give me every character up to the end of the line.”
The scanf() function returns the number of values it was able to read.
What will these values be? Remember: scanf() always uses pointers.
Hey, who hasn’t taken a code printout on a long ride only to find that it soon becomes… unreadable? Sure, we all have.
But with a little thought, you should have been able to piece together the original version of some code.
This program can read comma-separated data from the command line and then display it in JSON format.
You were to figure out what the missing code is.
We need to begin with “started” set to 0, which means false.
Did you remember the “&”s on the number variables? scanf() needs pointers.
Once the loop has started, you can set “started” to 1, which is true.
You’ll display a comma only if you’ve already displayed a previous line.
You don’t need & here because printf() is using the values, not the addresses of the numbers.
So what happens when you compile and run this code? What will it do?
The program lets you enter GPS data at the keyboard and then it displays the JSON-formatted data on the screen.
Problem is, the input and the output are all mixed up together.
If  you are writing a small tool, you don’t want to type in the data; you want to get large amounts of  data by reading a file.
Also, how is the JSON data going to be used? Surely it can’t be much use on the screen?
So is the program running OK? Is it doing the right thing? Do you need to change the code?
We need it in a file so we can use it with the mapping application.
This is the data you type in.This is the data that’s printed out.
In the end, you need to press Ctrl-D just to stop the program.
Here’s how the program should work Take the GPS from the bike and download the data.
It creates a file called gpsdata.csv with one line of  data for every location.
This is the GPS unit used to track the location of the bike.
The web page that contains the map application reads the output.json file.
The mapping application reads the data from output.json and displays it on a map inside a web page.
But you’re not using files… The problem is, instead of  reading and writing files, your program is currently reading data from the keyboard and writing it to the display.
The user won’t want to type in all of  the data if  it’s already stored in a file somewhere.
And if  the data in JSON format is just displayed on the screen, there’s no way the map within the web page will be able to read it.
But how do you do that? If  you want to use files instead of  the keyboard and the display, what code will you have to change? Will you have to change any code at all?
Is there a way of making our program use files without changing code? Without even recompiling it?
Tools that read data line by line, process it, and write it out again are called filters.
If you have a Unix machine, or you’ve installed Cygwin on Windows, you already have a few filter tools installed.
You’ll see later how to combine filters together to form filter chains.
The data is then sent to the display, not to a file.
You can use redirection You’re using scanf() and printf() to read from the keyboard and write to the display.
But the truth is, they don’t talk directly to the keyboard and display.
The Standard Input and Standard Output are created by the operating system when the program runs.
The operating system controls how data gets into and out of the Standard Input and Output.
If  you run a program from the command prompt or terminal, the operating system will send all of  the keystrokes from the keyboard into the Standard Input.
If the operating system reads any data from the Standard Output, by default it will send that data to the display.
The scanf() and printf() functions don’t know, or care, where the data comes from or goes to.
After all, why not just have your program talk directly to the keyboard and screen? Wouldn’t that be simpler?
Well, there’s a very good reason why operating systems communicate with programs using the Standard Input and the Standard Output:
You can redirect the Standard Input and Standard Output so that they read and write data somewhere else, such as to and from files.
This is the file containing the data from the GPS device.
The < operator tells the operating system that the Standard Input of  the program should be connected to the gpsdata.csv file instead of  the keyboard.
So you can send the program data from a file.
This is telling the operating system to send the data from the file into the Standard Input of the program.
Now you just see the JSON data coming from the program.
You don’t have to type in the GPS data, so you don’t see it mixed up with the output.
Instead of  entering data at the keyboard, you can use the < operator to read the data from a file.
Because you’ve redirected the Standard Output, you don’t see any data appearing on the screen at all.
But the program has now created a file called output.json.
The output.json file is the one you needed to create for the mapping application.
The output of the program will now be written to output.json.
There’s no output on the display at all; it’s all gone to the output.json file.
Test Drive Now it’s time to see if  the new data file you’ve created can be used to plot the location data on a map.
You’ll take a copy of  the web page containing the mapping program and put it into the same folder as the output.json file.
Then you need to open the web page in a browser:
The map inside the web page is able to read the data from the output file.
Great! Now I can publish my journeys on the Web!
But there’s a problem with some of the data… Your program seems to be able to read GPS data and format it correctly for the mapping application.
So what happened here? The problem is that there was some bad data in the GPS data file:
But the geo2json program doesn’t do any checking of  the data it reads; it just reformats the numbers and sends them to the output.
The decimal point is in the wrong place in this number.
You need to add some code to the geo2json program that will check for bad latitude and longitude values.
If a latitude or longitude falls outside the expected numeric, just display an error message and exit the program with an error status of 2:
You needed to add some code to the geo2json program to check for bad latitude and longitude values.
If a latitude or longitude falls outside the expected numeric, just display an error message and exit the program with an error status of 2:
These lines check that the latitude and longitude are in the correct range.
Test Drive OK, so you now have the code in place to check that the latitude and longitude are in range.
But will it be enough to make our program cope with bad data? Let’s see.
Compile the code and then run the bad data through the program:
You added the error-checking code, but when you run the program, nothing appears to be different.
But now no points appear on the map at all.
What do you think happened? Is the code doing what you asked it to? Why weren’t there any error messages? Why did the mapping program think that the entire output.json file was corrupt?
Code DeConstruction The mapping program is complaining about the output.json file, so let’s open it up and see what’s inside:
Once you open the file, you can see exactly what happened.
The program saw that there was a problem with some of  the data, and it exited right away.
It didn’t process any more data and it did output an error message.
Problem is, because you were redirecting the Standard Output into the output.json, that meant you were also redirecting the error message.
So the program ended silently, and you never saw what the problem was.
Now, you could have checked the exit status of  the program, but you really want to be able to see the error messages.
But how can you still display error messages if you are redirecting the output?
Oh, the error message was also redirected to the output file.
But how can you check that error status after the program has finished? Well, it depends on what operating system you’re using.
If you’re running on a Mac, Linux, some other kind of Unix machine, or if you’re using Cygwin on a Windows machine, you can display the error status like this:
If you’re using the Command Prompt in Windows, then it’s a little different:
Both commands do the same thing: they display the number returned by the program when it finished.
Wouldn’t it be dreamy if there were a special output for errors so that I didn’t have to mix my errors in with Standard Output? But I know it’s just a fantasy…
Introducing the Standard Error The Standard Output is the default way of  outputting data from a program.
But what if  something exceptional happens, like an error? You’ll probably want to deal with things like error messages a little differently from the usual output.
The Standard Error is a second output that was created for sending error messages.
Human beings generally have two ears and one mouth, but processes are wired a little differently.
Every process has one ear (the Standard Input) and two mouths (the Standard Output and the Standard Error)
By default, the Standard Error is sent to the display Remember how when a new process is created, the operating system points the Standard Input at the keyboard and the Standard Output at the screen? Well, the operating system creates the Standard Error at the same time and, like the Standard Output, the Standard Error is sent to the display by default.
That means that if  someone redirects the Standard Input and Standard Output so they use files, the Standard Error will continue to send data to the display.
And that’s really cool, because it means that even if  the Standard Output is redirected somewhere else, by default, any messages sent down the Standard Error will still be visible on the screen.
So you can fix the problem of  our hidden error messages by simply displaying them on the Standard Error.
What you didn’t know is that the printf() function is just a version of  a more general function called fprintf():
The fprintf() function allows you to choose where you want to send text to.
You can tell fprintf() to send text to stdout (the Standard Output) or stderr (the Standard Error)
Is there a stdin? A: Yes, and as you probably guessed, it refers to the Standard Input.
Q: Can I read from it? A: Yes, by using fscanf(), which is just like scanf(), but you can specify the data stream.
Let’s update the code to use fprintf() With just a couple of  small changes, you can get our error messages printing on the Standard Error.
That means that the code should now work in exactly the same way, except the error messages should appear on the Standard Error instead of  the Standard Output.
Test Drive If  you recompile the program and then run the corrupted GPS data through it again, this happens.
This time, even though you are redirecting the Standard Output into the output.json file, the error message is still visible on the screen.
The Standard Error was created with exactly this in mind: to separate the error messages from the usual output.
But remember: stderr and stdout are both just output streams.
And there’s nothing to prevent you from using them for anything.
You can redirect the Standard Output to a file by using > on the command line.
The Standard Input reads data from the keyboard by default.
You can redirect the Standard Input to read a file by using < on the command line.
Top Secret We have reason to believe that the following program has been used in the transmission of secret messages:
We have intercepted a file called secret.txt and a scrap of paper with instructions:
Top Secret — solved We have reason to believe that the following program has been used in the transmission of secret messages:
We have intercepted a file called secret.txt and a scrap of paper with instructions:
Head First: Operating System, we’re so pleased you’ve found time for us today.
Head First: Now you’ve agreed to appear under conditions of  anonymity, is that right?
Head First: Does it matter what kind of  O/S you are?
O/S: A lot of  people get pretty heated over which operating system to use.
But for simple C programs, we all behave pretty much the same way.
O/S: Yeah, if  you’re writing C, then the basics are the same everywhere.
Like I always say, we’re all the same with the lights out.
Now, you are in charge of  loading programs into memory?
You can’t just throw a program into memory and let it struggle, you know? There’s a whole bunch of  setup.
I need to allocate memory for the programs and connect them to their standard data streams so they can use things like displays and keyboards.
Head First: Like you just did for the geo2json program?
O/S: No, I mean he’s a real tool: a simple, text-based program.
O/S: Ain’t that life? It depends on the operating system.
Unix-style systems use a lot of  tools to get the work done.
Head First: Creating small tools that work together is almost a philosophy, isn’t it?
Sometimes when you’ve got a big problem to solve, it can be easier to break it down into a set of  simpler tasks.
Then use the operating system—that’s me—to connect the tools together.
If  you have a set of small programs, they are easier to test.
The other thing is that once you’ve built a tool, you can use it in other projects.
They work on the command line usually, so they don’t have a lot of what you might call Eye Appeal.
As long as you have a set of  solid tools to do the important work, you can always connect them to a nice interface, whether it’s a desktop application or a website.
Head First: Oh, well, thank you, O/S; it’s been a pleas…zzzzzz…
Small tools are flexible One of  the great things about small tools is their flexibility.
If  you write a program that does one thing really well, chances are you will be able to use it in lots of  contexts.
If  you create a program that can search for text inside a file, say, then chances are you going to find that program useful in more than one place.
To see how flexible our tool is, let’s use it for a completely different problem.
Instead of  just displaying data on a map, let’s try to use it for something a little more complex.
Say you want to read in a whole set of  GPS data like before, but instead of  just displaying everything, let’s just display the information that falls inside the Bermuda Rectangle.
That means you will display only data that matches these conditions:
You don’t really want to modify the geo2json tool, because you want it to do just one task.
If  you make the program do something more complex, you’ll cause problems for your users who expect the tool to keep working in exactly the same way.
Our geo2json tool displays all of  the data it’s given.
So what should we do? Should we modify geo2json so that it exports data and also checks the data?
So if you don’t want to change the geo2json tool, what should you do?
They deal with text data rather than obscure binary formats.
You’ll feed all of our data into the bermuda tool.
This data includes events inside and outside the Bermuda Rectangle.
The tool will only pass on data that falls inside the Bermuda Rectangle.
So you will only pass Bermuda Rectangle data to geo2json.
You will produce a map containing only Bermuda Rectangle data.
By splitting the problem down into two tasks, you will be able to leave your geo2json untouched.
That will mean that its current users will still be able to use it.
If  you want to skip over the data that falls outside the Bermuda Rectangle, you should build a separate tool that does just that.
So, you’ll have two tools: a new bermuda tool that filters out data that is outside the Bermuda Rectangle, and then your original geo2json tool that will convert the remaining data for the map.
Connect your input and output with a pipe You’ve already seen how to use redirection to connect the Standard Input and the Standard Output of  a program file.
But now you’ll connect the Standard Output of  the bermuda tool to the Standard Input of  the geo2json, like this:
A pipe can be used to connect the Standard Output of one process to the Standard Input of another process.
That way, whenever the bermuda tool sees a piece of  data inside the Bermuda Rectangle, it will send the data to its Standard Output.
The pipe will send that data from the Standard Output of  the bermuda tool to Standard Input of  the geo2json tool.
The operating system will handle the details of  exactly how the pipe will do this.
All you have to do to get things running is issue a command like this:
The output of bermuda will become the input of geo2json.
This is the pipe.The operating system will run both programs at the same time.
The | symbol is a pipe that connects the Standard Output of one process to the Standard Input of another process.
The bermuda tool The bermuda tool will work in a very similar way to the geo2json tool: it will read through a set of  GPS data, line by line, and then send data to the Standard Output.
First, it won’t send every piece of  data to the Standard Output, just the lines that are inside the Bermuda Rectangle.
The second difference is that the bermuda tool will always output data in the same CSV format used to store GPS data.
This is what the pseudocode for the tool looks like:
Pool Puzzle Your goal is to complete the code for.
Take code snippets from the pool and place them into the blank lines below.
You won’t need to use all the snippets of code in the pool.
Note: each thing from the pool can be used only once!
Pool Puzzle Solution Your goal was to complete the code for.
Note: each thing from the pool can be used only once!
Test Drive Now that you’ve completed the bermuda tool, it’s time to use it with the geo2json tool and see if  you can map any weird occurrences inside the Bermuda Rectangle.
Once you’ve compiled both of  the tools, you can fire up a console and then run the two programs together like this:
By connecting the two programs together with a pipe, you can treat these two separate programs as if  they were a single program, so you can redirect the Standard Input and Standard Output like you did before.
Remember: if you are running on Windows, you don’t need the “./”
When you connect the two programs together, you can treat them as a single program.
The bermuda tool filters out the events we want to ignore.
The geo2json tool will convert the events to JSON format.
Q: Why is it important that small tools use the Standard Input and Standard Output?
A: Because it makes it easier to connect tools together with pipes.
Q: Why does that matter? A: Small tools usually don’t solve an entire problem on their own, just a small technical problem, like converting data from one format to another.
But if you can combine them together, then you can solve large problems.
Q: What is a pipe, actually? A: The exact details depend on the operating system.
Pipes might be made from sections of memory or temporary files.
The important thing is that they accept data in one end, and send the data out of the other in sequence.
Q: So if two programs are piped together, does the first program have to finish running before the second program can start?
Both of the programs will run at the same time; as output is produced by the first program, it can be consumed by the second program.
Q: Why do small tools use text? A: It’s the most open format.
If a small tool uses text, it means that any other programmer can easily read and understand the output just by using a text editor.
A: Yes, just add more | between each program name.
A: The < will send a file’s contents to the first process in the pipeline.
The > will capture the Standard Output from the last process in the pipeline.
Q: Are the parentheses really necessary when I run the bermuda program with geo2json?
The parentheses will make sure the data file is read by the Standard Input of the bermuda program.
If you want to perform a different task, consider writing a separate small tool.
You can connect the Standard Output of one process to the Standard Input of another process using a pipe.
But what if you want to output to more than one file? We’ve looked at how to read data from one file and write to another file using redirection, but what if  the program needs to do something a little more complex, like send data to more than one file?
Imagine you need to create another tool that will read a set of  data from a file, and then split it into other files.
So what’s the problem? You can’t write to files, right? Trouble is, with redirection you can write to only two files at most, one from the Standard Output and one from the Standard Error.
Roll your own data streams When a program runs, the operating system gives it three file data streams: the Standard Input, the Standard Output, and the Standard Error.
But sometimes you need to create other data streams on the fly.
The good news is that the operating system doesn’t limit you to the ones you are dealt when the program starts.
Each data stream is represented by a pointer to a file, and you can create a new data stream using the fopen() function:
This will create a data stream to read from a file.
This will create a data stream to write to a file.
The fopen() function takes two parameters: a filename and a mode.
The mode can be w to write to a file, r to read from a file, or a to append data to the end of  a file.
Once you’ve created a data stream, you can print to it using fprintf(), just like before.
But what if  you need to read from a file? Well, there’s also an fscanf() function to help you do that too:
The mode is: “w” = write, “r” = read, or “a” = append.
Finally, when you’re finished with a data stream, you need to close it.
The truth is that all data streams are automatically closed when the program ends, but it’s still a good idea to always close the data stream yourself:
This is the code for a program to read all of the data from a GPS file and then write the data into one of three other files.
The mode is: “w” = write, “r” = read, or “a” = append.
The key thing is there’s a limited number of them, so make sure you close them when you’re done using them.
This is the code for a program to read all of the data from a GPS file and then write the data into one of three other files.
The program runs, but… If  you compile and run the program with:
That’s great, but what if  a user wanted to split up the data differently? What if he wanted to search for different words or write to different files? Could he do that without needing to recompile the program each time?
There’s more to main() The thing is, any program you write will need to give the user the ability to change the way it works.
If  it’s a GUI program, you will probably need to give it preferences.
And if  it’s a command-line program, like our categorize tool, it will need to give the user the ability to pass it command-line arguments:
Like any array in C, you need some way of  knowing how long the array is.
The argc value is a count of  the number of  elements in the array.
Command-line arguments really give your program a lot more flexibility, and it’s worth thinking about which things you want your users to tweak at runtime.
It will make your program a lot more valuable to them.
OK, let’s see how you can add a little flexibility to the categorize program.
The first argument contains the name of the program as it was run by the user.
That means that the first proper command-line argument is argv[1]
But how do you read command-line arguments from within the program? So far, every time you’ve created a main() function, you’ve written it without any arguments.
But the truth is, there are actually two forms of  the main() function we can use.
All of the mermaid data will be stored in this file.
The main() function can read the command-line arguments as an array of  strings.
Actually, of  course, because C doesn’t really have strings built-in, it reads them as an array of  character pointers to strings.
The first argument is actually the name of the program being run.
Code Magnets This is a modified version of the categorize program that can read the keywords to search for and the files to use from the command line.
See if you can fit the correct magnets into the correct slots.
Code Magnets Solution This is a modified version of the categorize program that can read the keywords to search for and the files to use from the command line.
You were to fit the correct magnets into the correct slots.
Test Drive OK, let’s try out the new version of  the code.
Now you’ll need to run the categorize program with a few commandline arguments saying what text to look for and what filenames to use:
If you run elvises.txt through geo2json, you can display it on a map.
Although at Head First Labs we never make mistakes (cough), it’s important in real-world programs to check for problems when you open a file for reading or writing.
That means if you want to check for errors, you should change code like:
Anchovy and pineapple, thick crust! Make it snappy; we need it for immediate delivery.
Chances are, any program you write is going to need options.
If  you create a chat program, it’s going to need preferences.
If  you write a game, the user will want to change the shape of  the blood spots.
And if you’re writing a command-line tool, you are probably going to need to add command-line options.
Command-line options are the little switches you often see with command-line tools:
Display the end of the file, but wait for new data to be added to the end of the file.
Let the library do the work for you Many programs use command-line options, so there’s a special library function you can use to make dealing with them a little easier.
It’s called getopt(), and each time you call it, it returns the next option it finds on the command line.
Imagine you have a program that can take a set of  different options:
This program needs one option that will take a value (-e = engines) and another that is simply on or off (-a = awesomeness)
You can handle these options by calling getopt() in a loop like this:
Inside the loop, you have a switch statement to handle each of the valid options.
The string ae: tells the getopt() function that a and e are valid options.
The e is followed by a colon to tell getopt() that the -e needs to be followed by an extra argument.
When the loop finishes, you tweak the argv and argc variables to skip past all of  the options and get to the main command-line arguments.
The “:” means that the e option needs an argument.
After processing the arguments, the 0th argument will no longer be the program name.
The unistd.h header is not actually part of the standard C library.
Instead, it gives your programs access to some of the POSIX libraries.
Pizza Pieces Looks like someone’s been taking a bite out of the pizza code.
See if you can replace the pizza slices and rebuild the order_pizza program.
Pizza Pieces Solution Looks like someone’s been taking a bite out of the pizza code.
You were to replace the pizza slices and rebuild the order_pizza program.
The ‘d’ is followed by a colon because it takes an argument.
We’ll point the delivery variable to the argument supplied with the ‘d’ option.
Remember: in C, setting something to 1 is equivalent to setting it to true.
Test Drive Now you can try out the pizza-order program:
It works! Well, you’ve learned a lot in this chapter.
You learned how to talk to files using redirection and your own custom data streams.
Finally, you learned how to deal with command-line arguments and options.
A lot of  C programmers spend their time creating small tools, and most of  the small tools you see in operating systems like Linux are written in C.
If  you’re careful in how you design them, and if  you make sure that you design tools that do one thing and do that one thing well, you’re well on course to becoming a kick-ass C coder.
You’re not using any options the first couple of times you call it.
Finally, try skipping the argument for “d”: it creates an error.
Q: Can I combine options like -td now instead of -d now -t?
The getopt() function will handle all of that for you.
A: Because of the way we read the options, it won’t matter if you type in -d now -t or -t -d now or -td now.
Q: So if the program sees a value on the command line beginning with “-”, it will treat it as an option?
A: If it reads it before it gets to the main command-line arguments, it will, yes.
A: In order to avoid ambiguity, you can split your main arguments from the options using --
There are two versions of the main() function—one with command-line arguments, and one without.
Command-line arguments are passed to main() as an argument count and an array of pointers to the argument strings.
You define valid options by passing a string to getopt() like ae:
A “:” (colon) following an option in the string means that the option takes an additional argument.
After you have read all of the options, you should skip past them using the optind variable.
You can change where the Standard Input, Output, and Error are connected to using redirection.
Your C Toolbox You’ve got Chapter 3 under your belt, and now you’ve.
The mode can be “w” to write, “r” to read, or “a” to append.
The getopt() function makes it easier to read commandline options.
If  you create a big program, you don’t want a big source file.
Can you imagine how difficult and time-consuming a single source file for an enterpriselevel program would be to maintain? In this chapter, you’ll learn how C allows you to break.
Along the way, you’ll learn a bit more about data type subtleties and get to.
You can see a few of these data types listed on the opposite page.
See if you can figure out which data type was used in each example.
The distance from the launch pad to the star Proxima Centauri (light years)
The numbers of stars in the universe that we won’t be visiting.
You can see a few of these data types listed on the opposite page.
You were to figure out which data type was used in each example.
The distance from the launch pad to the star Proxima Centauri (light years)
The numbers of stars in the universe that we won’t be visiting.
On some machines, the long data type ta kes up twice the memory of  an int, and it.
Don’t put something big into something small When you’re passing around values, you need to be careful that the type of  the value matches the type of  the variable you are going to store it in.
So you need to be careful that you don’t try to store a value that’s too large for the amount of  space allocated to a variable.
Now there’s no problem storing a short value inside an int or a long variable.
There is plenty of  space in memory, and your code will work correctly:
The problems start to happen if  you go the other way around—if, say, you try to store an int value into a short.
Sometimes, the compiler will be able to spot that you’re trying to store a really big value into a small variable, and then give you a warning.
But a lot of  the time the compiler won’t be smart enough for that, and it will compile the code without complaining.
In that case, when you try to run the code, the computer won’t be able to store a number 100,000 into a short variable.
So why did putting a large number into a short go negative? Numbers are stored in binary.
But when the computer tried to store that value into a short, it only allowed the value a couple of bytes of storage.
The program stored just the righthand side of the number:
Signed values in binary beginning with a 1 in highest bit are treated as negative numbers.
And this shortened value is equal to this in decimal:
The contents of a long may be too large to fit in a short or an int.
The contents of a short will always fit in an int or a long.
Because it doesn’t need to worry about recording negative numbers, unsigned numbers can store larger numbers since there’s now one more bit to work with.
So an unsigned int stores numbers from 0 to a maximum value that is about twice as large as the maximum number that can be stored inside an int.
There’s also a signed keyword, but you almost never see it, because all data types are signed by default.
So a long int is a longer version of an int, which means it can store a larger range of numbers.
You can put some other keywords before data types to change the way that the numbers are interpreted:
Use casting to put floats into whole numbers What do you think this piece of  code will display?
What do you do if  you want to perform calculations on whole numbers and you want to get floating-point results? You could store the whole numbers into float variables first, but that’s a little wordy.
Instead, you can use a cast to convert the numbers on the fly:
The (float) will cast an integer value into a float value.
The calculation will then work just as if  you were using floating-point values the entire time.
In fact, if  the compiler sees you are adding, subtracting, multiplying, or dividing a floating-point value with a whole number, it will automatically cast the numbers for you.
That means you can cut down the number of  explicit casts in your code:
There’s a new program helping the waiters bus tables at the Head First Diner.
The code automatically totals a bill and adds sales tax to each item.
See if you can figure out what needs to go in each of the blanks.
Note: there are several data types that could be used for this program, but which would you use for the kind of figures you’d expect?
There’s a new program helping the waiters bus tables at the Head First Diner.
The code automatically totals a bill and adds sales tax to each item.
You were to figure out what needs to go in each of the blanks.
Note: there are several data types that could be used for this program, but which would you use for the kind of figures you’d expect?
You need a small floating-point number to total the cash.
There won’t be many items on an order, so we’ll choose a short.
By adding .0, you make the calculation work as a float.
If you left it as 100, it would have returned a whole number.
But how do you find out how big an int is, or how many bytes a double takes up? Fortunately, the C Standard Library has a couple of  headers with the details.
This program will tell you about the sizes of  ints and floats:
When you compile and run this code, you will see something like this:
The values you see on your particular machine will probably be different.
What if  you want to know the details for chars or doubles? Or longs? No problem.
This contains the values for the integer ty pes like int and char.
Q: Why are data types different on different operating systems? Wouldn’t it be less confusing to make them all the same?
A: C uses different data types on different operating systems and processors because that allows it to make the most out of the hardware.
Q: In what way? A: When C was first created, most machines were 8-bit.
Because C doesn’t specify the exact size of its data types, it’s been able to adapt over time.
And as newer machines are created, C will be able to make the most of them as well.
A: Technically, the bit size of a computer can refer to several things, such as the size of its CPU instructions or the amount of data the CPU can read from memory.
The bit size is really the favored size of numbers that the computer can deal with.
Q: So what does that have to do with the size of ints and doubles?
Q: I understand how whole numbers like ints work, but how are floats and doubles stored? How does the computer represent a number with a decimal point?
Most computers used a standard published by the IEEE (http://tinyurl.com/6defkv6)
Q: Do I really need to understand how floating-point numbers work?
The vast majority of developers use floats and doubles without worrying about the details.
Some people were never really cut out to be programmers.
It seems that some aspiring actors are filling in their time between roles and making a little extra cash by cutting code, and they’ve decided to spend some time freshening up the code in the billtotalling program.
By the time they rejiggered the code, the actors were much happier about the way everything looked…but there’s just a tiny problem.
Let’s see what’s happened to the code This is what the actors did to the code.
You can see they really just did a couple of  things.
Hey - I was up for a movie with Val Kilmer */
And what about the tip? Voice lessons ain't free */
The code has had some comments added, and they also changed the order of  the functions.
The code should be good to go, right? Well, everything was great, right up until the point that they compiled the code…
Test Drive If  you open up the console and try to compile the program, this happens:
What does error: conflicting types for 'add_with_tax' mean? What is a previous implicit declaration? And why does it think the line that prints out the current total is now an int? Didn’t we design that to be floating point?
The compiler will ignore the changes made to the comments, so that shouldn’t make any difference.
That means the problem must be caused by changing the order of  the functions.
But if  the order is the problem, why doesn’t the compiler just return a message saying something like:
Seriously, why doesn’t the compiler give us a little help here?
To understand exactly what’s happening here, you need to get inside the head of  the compiler for a while and look at things from its point of  view.
You’ll see that what’s happening is that the compiler is actually trying to be a little too helpful.
Compilers don’t like surprises So what happens when the compiler sees this line of  code?
The compiler sees a call to a function it doesn’t recognize.
Rather than complain about it, the compiler figures that it will find out more about the function later in the source file.
The compiler simply remembers to look out for the function later on in the file.
The compiler needs to know what data type the function will return.
Of  course, the compiler can’t know what the function will return just yet, so it makes an assumption.
Hey, here’s a call to a function I’ve never heard of.
But I’ll keep a note of it for now and find out more later.
When it reaches the code for the actual function, it returns a “conflicting types for ‘add_with_tax’” error.
This is because the compiler thinks it has two functions with the same name.
The other is the one that  the compiler assumed would return an int.
The computer makes an assumption that the function returns an int, when in reality it returns a float.
If you were designing the C language, how would you fix the problem?
Hello? I really don’t care how the C language solves the.
You could just put the functions back in the correct order and define the function before you call it in main()
Changing the order of  the functions means that you can avoid the compiler ever making any dangerous assumptions about the return types of  unknown functions.
But if  you force yourself  to always define functions in a specific order, there are a couple of  consequences.
Fixing function order is a pain Say you’ve added a cool new function to your code that everyone thinks is fantastic:
Most coders want to spend their time improving what their code can do.
It would be better if  you didn’t have to shuffle the order of  the code just to keep the compiler happy.
In some situations, there is no correct order OK, so this situation is kind of  rare, but occasionally you might write some code that is mutually recursive:
If  you have two functions that call each other, then one of  them will always be called in the file before it’s defined.
For both of  those reasons, it’s really useful to be able to define functions in whatever order is easiest at the time.
Split the declaration from the definition Remember how the compiler made a note to itself  about the function it was expecting to find later in the file? You can avoid the compiler making assumptions by explicitly telling it what functions it should expect.
When you tell the compiler about a function, it’s called a function declaration:
The declaration tells the compiler what return value to expect.
The declaration is just a function signature: a record of  what the function will be called, what kind of  parameters it will accept, and what type of  data it will return.
Once you’ve declared a function, the compiler won’t need to make any assumptions, so it won’t matter if  you define the function after you call it.
So if  you have a whole bunch of  functions in your code and you don’t want to worry about their order in the file, you can put a list of function declarations at the start of  your C program code:
But even better than that, C allows you to take that whole set of declarations out of  your code and put them in a header file.
You’ve already used header files to include code from the C Standard Library:
Let’s go see how you can create your own header files.
Creating your first header file To create a header, you just need to do two things:
If  you are writing a program called totaller, then create a file called totaller.h and write your declarations inside it:
At the top of  your program, you should add an extra include line:
When you write the name of  the header file, make sure you surround it with double quotes rather than angle brackets.
Why the difference? When the compiler sees an include line with angle brackets, it assumes it will find the header file somewhere off  in the directories where the library code lives.
But your header file is in the same directory as your .c file.
By wrapping the header filename in quotes, you are telling the compiler to look for a local file.
When the compiler reads the #include in the code, it will read the contents of  the header file, just as if  it had been typed into the code.
Separating the declarations into a separate header file keeps your main code a little shorter, and it has another big advantage that you’ll find out about in a few pages.
For now, let’s see if  the header file fixed the mess.
Local header files can also include directory names, but you will normally put them in the same directory as the C file.
Test Drive Now when you compile the code, this happens:
The compiler reads the function declarations from the header file, which means it doesn’t have to make any guesses about the return type of  the function.
Just to check that everything is OK, you can run the generated program to see if  it works the same as before.
Press Ctrl-D here to stop the program from asking for more prices.
Your job is to play like you’re the compiler and say what.
Your job was to play like you’re the compiler and say what.
The program will still work because it will guess the function returns an int.
The program will compile without warnings, but it won’t work because there will be a rounding problem.
The program won’t compile, because you’re calling a float function without declaring it first.
Q: So I don’t need to have declarations for int functions?
You talk about the compiler preprocessing? Why does the compiler do that?
A: Strictly speaking, the compiler just does the compilation step: it converts the C source code into assembly code.
But in a looser sense, all of the stages that convert the C source code into the final executable are normally called compilation, and the gcc tool allows you to control those stages.
Q: What is the preprocessor? A: Preprocessing is the first stage in converting the raw C source code into a working executable.
Preprocessing creates a modified version of the source just before the proper compilation begins.
In your code, the preprocessing step read the contents of the header file into the main file.
A: No, compilers normally just use pipes for sending the stuff through the phases of the compiler to make things more efficient.
Q: Why do some headers have quotes and others have angle brackets?
A: Strictly speaking, it depends on the way your compiler works.
Usually quotes mean to simply look for a file using a relative path.
So if you just include the name of a file, without including a directory name, the compiler will look in the current directory.
If angle brackets are used, it will search for the file along a path of directories.
Q: What directories will the compiler search when it is looking for header files?
A: The gcc compiler knows where the standard headers are stored.
Q: So that’s how it works for standard headers like stdio.h?
Q: Can I create my own libraries? A: Yes; you’ll learn how to do that later in the book.
If the compiler finds a call to a function it hasn’t heard of, it will assume the function returns an int.
So if you try to call a function before you define it, there can be problems.
Function declarations tell the compiler what your functions will look like before you define them.
If function declarations appear at the top of your source code, the compiler won’t get confused about return types.
You can tell the compiler to read the contents of a header file using #include.
The compiler will treat included code the same as code that is typed into the source file.
Here is the entire set of reserved words (in no useful order)
Every C program you ever see will break into just these words and a few symbols.
If you use these for names, the compiler will be very, very upset.
If you have common features… Chances are, when you begin to write several programs in C, you will find that there are some functions and features that you will want to reuse from other programs.
For example, look at the specs of  the two programs on the right.
It’s not very secure, but it’s very easy to do.
And the same code that can encrypt text can also be used to decrypt it.
Imagine you have a set of functions that you want to share between programs.
If you had created the C programming language, how would you allow code to be shared?
Read the contents of a file and create an encrypted version using XOR encryption.
So you could just copy the code from one program to the other, right? That’s not so bad if  there’s just a small amount of  code to copy, but what if  there’s a really large amount of  code? Or what if the way the encrypt() function works needs to change in the future? If  there are two copies of  the encrypt() function, you will have to change it in more than one place.
For your code to scale properly, you really need to find some way to reuse common pieces of  code—some way of  taking a set of  functions and making them available in a bunch of  different programs.
Loop through the array and update each character with an encrypted version.
Doing math with a character? You can because char is a numeric data type.
You can split the code into separate files If  you have a set of  code that you want to share among several files, it makes a lot of  sense to put that shared code into a separate .c file.
If  the compiler can somehow include the shared code when it’s compiling the program, you can use the same code in multiple applications at once.
So if  you ever need to change the shared code, you only have to do it in one place.
If  you want to use a separate .c file for the shared code, that gives us a problem.
So far, you have only created programs from single .c source files.
But now you want some way to give the compiler a set of  source code files and say, “Go make a program from those.” How do you do that? What syntax do you use with the gcc compiler? And more importantly, what does it mean for a compiler to create a single executable program from several files? How would it work? How would it stitch them together?
To understand how the C compiler can create a single program from multiple files, let’s take a look at how compilation works…
The compiler will compile the shared code into each program.
You need to find a way of telling the compiler to create the program from multiple source files.
Compilation behind the scenes To understand how a compiler can compile several source files into a single program, you’ll need to pull back the curtain and see how compilation really works.
The first thing the compiler needs to do is fix the source.
It needs to add in any extra header files it’s been told about using the #include directive.
It might also need to expand or skip over some sections of  the program.
Once it’s done, the source code will be ready for the actual compilation.
First, I’ll just add some extra ingredients into the source.
You’ll see how to use them later in the book.
The C programming language probably seems pretty low level, but the truth is it’s not low level enough for the computer to understand.
The computer only really understands very low-level machine code instructions, and the first step to generate machine code is to convert the C source code into assembly language symbols like this:
Looks pretty obscure? Assembly language describes the individual instructions the central processor will have to follow when running the program.
The C compiler has a whole set of  recipes for each of  the different parts of  the C language.
These recipes will tell the compiler how to convert an if statement or a function call into a sequence of  assembly language instructions.
But even assembly isn’t low level enough for the computer.
So for this “if” statement I need to begin by adding onto the stack…
The compiler will need to assemble the symbol codes into machine or object code.
This is the actual binary code that will be executed by the circuits inside the CPU.
If  you give the computer several files to compile for a program, the compiler will generate a piece of  object code for each source file.
But in order for these separate object files to form a single executable program, one more thing has to occur…
Once you have all of  the separate pieces of  object code, you need to fit them together like jigsaw pieces to form the executable program.
The compiler will connect the code in one piece of  object code that calls a function in another piece of  object code.
Linking will also make sure that the program is able to call library code properly.
Finally, the program will be written out into the executable program file using a format that is supported by the operating system.
The file format is important, because it will allow the operating system to load the program into memory and make it run.
So how do you actually tell gcc that we want to make one executable program from several separate source files?
Finally, I need to put everything together for the final result…
The shared code needs its own header file If  you are going to share the encrypt.c code between programs, you need some way to tell those programs about the encrypt code.
Include encrypt.h in your program You’re not using a header file here to be able to reorder the functions.
You’re using it to tell other programs about the encrypt() function:
You’ll include encrypt.h so that the program has the declaration.
Having encrypt.h inside the main program will mean the compiler will know enough about the encrypt() function to compile the code.
At the linking stage, the compiler will be able to connect the call to encrypt(msg) in message_hider.c to the actual encrypt() function in encrypt.h.
Finally, to compile everything together you just need to pass the source files to gcc:
But what if you want to share variables? Source code files normally contain their own separate variables to prevent a variable in one file affecting a variable in another file with the same name.
But if you genuinely want to share variables, you should declare them in your header file and prefix them with the keyword extern:
Test Drive Let’s see what happens when you compile the message_hider program:
You need to compile the code with both source files.
When you run the program, you can enter text and see the encrypted version.
You can even pass it the contents of the encrypt.h file to encrypt it.
The message_hider program is using the encrypt() function from encrypt.c.
Now that you have the encrypt() function in a separate file, you can use it in any program you like.
If  you ever change the encrypt() function to be something a little more secure, you will need to amend only the encrypt.c file.
You can share code by putting it into a separate C file.
You need to put the function declarations in a separate .h header file.
Include the header file in every C file that needs to use the shared code.
List all of the C files needed in the compiler command.
Remember, you can call the same function to decrypt text.
Man! Every time I make a simple change in one file, it takes an age to recompile! And I’m working on a schedule…
It’s not rocket science…or is it? Breaking your program out into separate source files not only means that you can share code between different programs, but it also means you can start to create really large programs.
Why? Well, because you can start to break your program down into smaller self-contained pieces of code.
Rather than being forced to have one huge source file, you can have lots of  simpler files that are easier to understand, maintain, and test.
So on the plus side, you can start to create really large programs.
The downside? The downside is…you can start to create really large programs.
They can modify your source, link hundreds of  files together without blowing your memory, and even optimize the code you wrote, along the way.
And even though they do all that, they still manage to run quickly.
But if  you create programs that use more than a few files, the time it takes to compile the code starts to become important.
Let’s say it takes a minute to compile a large project.
That might not sound like a lot of time, but it’s more than long enough to break your train of  thought.
If you try out a change in a single line of  code, you want to see the result of  that change as quickly as possible.
If  you have to wait a full minute to see the result of  every change, that will really start to slow you down.
If you change even one line in one file, it can take the compiler a long time to recompile all the source files.
Even a simple change might mean running a large, slow compile to see the result.
Given what you know about the compilation process, how could you speed up the time to recompile the program?
Don’t recompile every file If  you’ve just made a change to one or two of  your source code files, it’s a waste to recompile every source file for your program.
Think what happens when you issue a command like this:
What will the compiler do? It will run the preprocessor, compiler, and assembler for each source code file.
And if  the source code hasn’t changed, the object code that’s generated for that file won’t change either.
So if  the compiler is generating the object code for every file, every time, what do you need to do?
If  you change a single file, you will have to recreate the object code file from it, but you won’t need to create the object code for any other file.
Then you can pass all the object code files to the linker and create a new version of  the program.
So how do you tell gcc to save the object code in a file? And how do you then get the compiler to link the object files together?
Save copies of the compiled code If  you tell the compiler to save the object code it generates into a file, it shouldn’t need to recreate it unless the source code changes.
If  a file does change, you can recreate the object code for that one file and then pass the whole set of  object files to the compiler so they can be linked.
If this source file changes, it’s the only one you need to recompile.
The compiler will update the object code that’s stored in a file.
You will still need to run the linker, but most of the files will still be the same.
First, compile the source into object files You want object code for each of  the source files, and you can do that by typing this command:
The *.c will match every C file in the current directory, and the -c will tell the compiler that you want to create an object file for each source file, but you don’t want to link them together into a full executable program.
Then, link them together Now that you have a set of  object files, you can link them together with a simple compile command.
But instead of giving the compiler the names of  the C source files, you tell it the names of  the object files:
This will match all the object files in the directory.
The compiler is smart enough to recognize the files as object files, rather than source files, so it will skip most of the compilation steps and just link them together into an executable program called launch.
OK, so now you have a compiled program, just like before.
But you also have a set of  object files that are ready to be linked together if  you need them again.
So if  you change just one of  the files, you’ll only need to recompile that single file and then relink the program:
Even though you have to type two commands, you’re saving a lot of  time:
Here is some of the code that’s used to control the engine management system on the craft.
Which files do you think need to be recreated to make the ems executable up to date? Circle the files you think need to be updated.
And in the galley, they need to check that their code’s up to date as well.
Here is some of the code that’s used to control the engine management system on the craft.
You were to circle the files you think need to be recreated to make the ems executable up to date.
And in the galley, they need to check that their code’s up to date as well.
The galley executable needs to be relinked, because it’s older than the microwave.o file.
It’s true: partial compiles are faster, but you have to think more carefully to make sure you recompile everything you need.
If  you are working on just one source file, things will be pretty simple.
But if  you’ve changed a few files, it’s pretty easy to forget to recompile some of  them.
That means the newly compiled program won’t pick up all the changes you made.
Now, of  course, when you come to ship the final program, you can always make sure you can do a full recompile of  every file, but you don’t want to do that while you’re still developing the code.
Even though it’s a fairly mechanical process to look for files that need to be compiled, if  you do it manually, it will be pretty easy to miss some changes.
Is there something we can use to automate the process?
I thought the whole point of saving time was so I didn’t have to get distracted.
Now the compile is faster, but I have to think a lot harder about how to compile my code.
Wouldn’t it be dreamy if there were a tool that could automatically recompile just the source that’s changed? But I know it’s just a fantasy…
Automate your builds with the make tool You can compile your applications really quickly in gcc, as long as you keep track of  which files have changed.
That’s a tricky thing to do, but it’s also pretty straightforward to automate.
Imagine you have a file that is generated from some other file.
Let’s say it’s an object file that is compiled from a source file:
If the thruster.c file is newer, you need to recompile.
If the thruster.o file is newer, you don’t need to recompile.
How do you tell if  the thruster.o file needs to be recompiled? You just look at the timestamps of  the two files.
If  the thruster.o file is older than the thruster.c file, then the thruster.o file needs to be recreated.
And if  you have a simple rule for something, then don’t think about it—automate it…
The make tool will check the timestamps of  the source files and the generated files, and then it will only recompile the files if  things have gotten out of  date.
But before you can do all these things, you need to tell make about your source code.
It needs to know the details of  which files depend on which files.
And it also needs to be told exactly how you want to build the code.
What does make need to know? Every file that make compiles is called a target.
A target is any file that is generated from some other files.
So a target might be a zip archive that is generated from the set of  files that need to be compressed.
For every target, make needs to be told two things:
A rule tells make all it needs to know to create the target file.
Which files the target is going to be generated from.
The set of  instructions it needs to run to generate the file.
How make works Let’s say you want to compile thruster.c into some object code in thruster.o.
The thruster.o file is called the target, because it’s the file you want to generate.
And what will the recipe be? That’s the compile command to convert thruster.c into thruster.o.
Make sense? If  you tell the make tool about the dependencies and the recipe, you can leave it to make to decide when it needs to recompile thruster.o.
Once you build the thruster.o file, you’re going to use it to create the launch program.
That means the launch file can also be set up as a target, because it’s a file you want to generate.
The dependency files for launch are all of  the .o object files.
Once make has been given the details of  all of  the dependencies and rules, all you have to do is tell it to create the launch file.
But how do you tell make about the dependencies and recipes? Let’s find out.
So I’ve got to compile the launch program? Hmm… First I’ll need to recompile thruster.o, because it’s out of date; then I just need to relink launch.
The make tool may have a different name on Windows.
Because make came from the Unix world, there are different flavors of it available in Windows.
MinGW includes a version of make called mingw32-make and Microsoft produce their own version called NMAKE.
Tell make about your code with a makefile All of  the details about the targets, dependencies, and recipes need to be stored in a file called either makefile or Makefile.
To see how it works, imagine you have a pair of source files that together create the launch program:
The launch program is made by linking the launch.o and thruster.o files.
Those files are compiled from their matching C and header files, but the launch.o file also depends on the thruster.h file because it contains code that will need to call a function in the thruster code.
This is how you’d describe that build in a makefile:
All of the recipe lines MUST begin with a tab character.
If you just try to indent the recipe lines with spaces, the build won’t work.
A target is a file that is going to be generated.
The launch program is made from the launch.o and thruster.o files.
Test Drive Save your make rules into a text file called Makefile in the same directory; then, open up a console and type the following:
File  Edit   Window  Help   MakeItSoYou are telling make to create the launch file.
Finally, make links the object files to create the launch program.
You can see that make was able to work out the sequence of commands required to create the launch program.
But what happens if  you make a change to the thruster.c file and then run make again?
Instead, it just compiles thruster.o and then relinks the program.
Q: Is make just like ant? A: It’s probably better to say that build tools like ant and rake are like make.
Q: This seems like a lot of work just to compile source code.
For small projects, make might not appear to save you that much time, but once you have more than a handful of files, compiling and linking code together can become very painful.
Q: If I write a makefile for a Windows machine, will it work on a Mac? Or a Linux machine?
A: Because makefiles calls commands in the underlying operating system, sometimes makefiles don’t work on different operating systems.
Q: Can I use make for things other than compiling code? A: Yes.
But it can also be used as a command-line installer, or a source control tool.
In fact, you can use make for almost any task that you can perform on the command line.
It’s easy to indent recipes with spaces instead of tabs.
So why does make insist on using tabs? This is a quote from make’s creator, Stuart Feldman:
And then a few weeks later I had a user population of about a dozen, most of them friends, and I didn’t want to screw up my embedded base.
But if you find that even it is not automatic enough, take a look at a tool called autoconf:
An increasing number of them are available on the GNU website.
Make Magnets Hey, baby, if you don’t groove to the latest tunes, then you’ll love the program the guys in the Head First Lounge just wrote! oggswing is a program that reads an Ogg Vorbis music file and creates a swing version.
Sweet! See if you can complete the makefile that compiles oggswing and then uses it to convert a .ogg file:
Make Magnets Solution Hey, baby, if you don’t groove to the latest tunes, then you’ll love the program the guys in the Head First Lounge just wrote! oggswing is a program that reads an Ogg Vorbis music file and creates a swing version.
Sweet! You were to complete the makefile that compiles oggswing and then uses it to convert a .ogg file:
The make tool can do far, far more than we have space to discuss here.
To find out more about make and what it can do for you, visit the GNU Make Manual at:
Liftoff! If  you have a very slow build, make will really speed things up.
Most developers are so used to building their code with make that they even use it for small programs.
If  you have a large amount of  code, make will always take care to build just the code you need at just the time you need it.
It can take a long time to compile a large number of files.
You can speed up compilation time by storing object code in *.o files.
The gcc can compile programs from object files as well as source files.
The make tool can be used to automate your builds.
Be careful formatting your makefile: don’t forget to indent lines with tabs instead of spaces.
Your C Toolbox You’ve got Chapter 4 under your belt, and now you’ve.
Save object code into files to speed up your builds.
This lab gives you a spec that describes a program for you to build, using the knowledge you’ve gained over the last few chapters.
This project is bigger than the ones you’ve seen so far.
So read the whole thing before you get started, and give yourself a little time.
There are no new C concepts in here, so you can move on in the book and come back to the lab later.
We’ve filled in a few design details for you, and we’ve made sure you’ve got all the pieces you need to write the code.
It’s up to you to finish the job, but we won’t give you the code for the answer.
The spec: make your houseplant talk Ever wished your plants could tell you when they need watering? Well, with an Arduino they can! In this lab, you’ll create an Arduino-powered plant monitor, all coded in C.
The physical device The plant monitor has a moisture sensor that measures how wet your plant’s soil is.
If  the plant needs watering, an LED lights up until the plant’s been watered, and the string “Feed me!” is repeatedly sent to your computer.
When the plant has been watered, the LED switches off  and the string “Thank you, Seymour!” is sent once to your computer.
The moisture sensor detects whether or not the plant needs watering.
The Arduino The brains of  the plant monitor is an Arduino.
You can connect it to sensors that pick up information about the world around it, and actuators that respond.
All of  this is controlled by code you write in C.
The Arduino board has 14 digital IO pins, which can be inputs or outputs.
These tend to be used for reading on or off values, or switching actuators on or off.
The board also has six analog input pins, which take voltage readings from a sensor.
The board can take power from your computer’s USB port.
The IDE allows you to verify and compile your code, and then upload it to the Arduino itself  via your USB port.
The IDE also has a built-in serial monitor so that you can see what data the Arduino is sending back (if  any)
The IDE lets you upload code to the Arduino board…
Build the physical device You start by building the physical device.
While this bit’s optional, we really recommend that you give it a go.
Build the moisture sensor Take a long piece of  jumper wire and attach it to the head of  one of  the galvanized nails.
You can either wrap the wire around the nail or solder it in place.
Once you’ve done that, attach another long piece of  jumper wire to the second galvanized nail.
The moisture sensor works by checking the conductivity between the two nails.
If  the conductivity is high, the moisture content must be high.
You will see that it has one longer (positive) lead and one shorter (negative) lead.
Put the long positive lead of the LED into the slot labeled 13, and the shorter negative lead into the slot labeled GND.
Insert the short LED lead into the slot labeled GND.
Fix the end of the wire to the head of the nail.
Connect the moisture sensor Connect the moisture sensor as shown below:
Take one of  the galvanized nails, and connect the wire attached to it to slot B10.4
Take the other galvanized nail, and connect the wire attached to it to slot B5.6
The moisture sensor is connected to analog input pin 0, which means we can read analog data from the sensor via this pin.
Here’s what your code should do Your Arduino C code should do the following.
Read from the moisture sensor The moisture sensor is connected to an analog input pin.
You will need to read analog values from this pin.
Here at the lab, we’ve found that our plants generally need watering when the value goes below 800, but your plant’s requirements may be different—say, if  it’s a cactus.
Write to the LED The LED is connected to a digital pin.
When the plant doesn’t need any more water, write to the digital pin the LED is connected to, and get it to switch off  the LED.
When the plant needs watering, write to the digital pin and get it to switch on the LED.
Even better, get it to flash when the conditions are borderline.
Write to the serial port When the plant needs watering, repeatedly write the string “Feed me!” to the computer serial port.
When the plant has enough water, write the string “Thank you, Seymour!” to the serial port once.
Assume that the Arduino is plugged in to the computer USB socket.
Here’s what your C code should look like An Arduino C program has a specific structure.
This function loops over and over, and allows you to respond to input from your sensors.
It only stops running when the board is switched off*/
The easiest way of  writing the Arduino C code is with the Arduino IDE.
The IDE allows you to verify and compile your code, and then upload your completed program to the Arduino board, where you’ll be able to see it running.
The Arduino IDE comes with a library of  Arduino functions and includes lots of  handy code examples.
Turn the page to see a list of  the functions you’ll find most useful when creating Arduino.
You can add extra functions and declarations if you like, but without these two functions the code won’t work.
Tells the Arduino whether the digital pin is an input or output.
Tells the Arduino to start sending and receiving serial data at speed bits per second.
The finished product You’ll know your Arduino project is complete when you put the moisture sensor in your plant’s soil, connect the Arduino to your computer, and start getting status updates about your plant.
Most things in life are more complex than a simple number.
So far, you’ve looked at the basic data types of the C language, but what if you want to.
And if you’re after a simple yes or no, bitfields.
Sometimes you need to hand around a lot of data.
Now that’s not really so bad, is it? But even though you’re just passing four pieces of  data, the code’s starting to look a little messy:
So how do you get around this problem? What can you do to avoid passing around lots and lots of  data if  you’re really only using it to describe a single thing?
You are passing the same four pieces of data twice.
You’ve seen that C can handle a lot of  different types of  data: small numbers and large numbers, floating-point numbers, characters, and text.
But quite often, when you are recording data about something in the real world, you’ll find that you need to use more than one piece of  data.
Here you have two functions that both need the same set of  data, because they are both dealing with the same real-world thing:
Both of these functions take the same set of parameters.
Joe: Sure, it’s four pieces of  data now, but what if  we change the system to record another piece of  data for the fish?
Jill: Yes, it’s just one piece of  data, but we’ll have to add that to every function that needs data about a fish.
Joe: Yeah, for a big system, that might be hundreds of  functions.
And all because we add one more piece of  data.
Joe: Easy, we just group the data into a single thing.
Arrays normally store a list of data of  the same type.
Joe: But come on, there must be some way of  doing this in C.
Frank: OK, we want something that lets us refer to a whole set of  data of  different types all at once, as if  it were a single piece of data.
Jill: I don’t think we’ve seen anything like that yet, have we?
What you need is something that will let you record several pieces of data into one large piece of  data.
This will create a new custom data type that is made up of  a collection of  other pieces of  data.
In fact, it’s a little bit like an array, except:
But once you’ve defined what your new struct looks like, how do you create pieces of  data that use it? Well, it’s quite similar to creating a new array.
You just need to make sure the individual pieces of  data are in the order that they are defined in the struct:
If  you have a set of  data that you need to bundle together into a single thing, then you can use a struct.
A struct will let you take all of  those different pieces of  data into the code and wrap them up into one large new data type, like this:
A: const char * is used for strings that you don’t want to change.
The struct here just stores a pointer to a string.
That means it’s just recording an address, and the string lives somewhere else in memory.
Q: But you can store the whole string in there if you want?
A: Yes, if you define a char array in the string, like char name[20];
Just give them the fish Now, instead of  having to pass around a whole collection of individual pieces of  data to the functions, you can just pass your new custom piece of  data:
Looks a lot simpler, doesn’t it? Not only does it mean the functions now only need a single piece of  data, but the code that calls them is easier to read:
So that’s how you can define your custom data type, but how do you use it? How will our functions be able to read the individual pieces of  data stored inside the struct?
For example, let’s say you want to add an extra field to fish:
All the catalog() and label() functions have been told is they they’re going to be handed a fish.
They don’t know (and don’t care) that the fish now contains more data, so long as it has all the fields they need.
That means that structs don’t just make your code easier to read, they also make it better able to cope with change.
Wrapping parameters in a struct makes your code more stable.
Read a struct’s fields with the “.” operator Because a struct’s a little like an array, you might think you can read its fields like an array:
OK, now that you know a few things about using structs, let’s see if you can go back and update that code…
Even though a struct stores fields like an array, the only way to access them is by name.
If  you’ve used another language, like JavaScript or Ruby, this will look familiar:
You get an error if you try to read a struct field like it’s an array.
Pool Puzzle Your job is to write a new version of the catalog()
Take fragments of code from the pool and place them in the blank lines below.
You may not use the same fragment more than once, and you won’t need to use all the fragments.
Note: each thing from the pool can be used only once!
Pool Puzzle Solution Your job was to write a new version of the catalog()
You were to take fragments of code from the pool and place them in the blank lines below.
Test Drive You’ve rewritten the catalog() function, so it’s pretty easy to rewrite the label() function as well.
Once you’ve done that, you can compile the program and check that it still works:
The code works the same as it did before, but now you have really simple lines of  code that call the two functions:
Not only is the code more readable, but if  you ever decide to record some extra data in the struct, you won’t have to change anything in the functions that use it.
Q: So is a struct just an array? A:No, but like an array, it groups a number of pieces of data together.
Q:An array variable is just a pointer to the array.
A:No, a struct variable is a name for the struct itself.
Q:Are structs like classes in other languages? A:They’re similar, but it’s not so easy to add methods to structs.
When you define a struct, you’re not telling the computer to create anything in memory.
You’re just giving it a template for how you want a new type of  data to look.
But when you define a new variable, the computer will need to create some space in memory for an instance of  the struct.
That space in memory will need to be big enough to contain all of the fields within the struct:
So what do you think happens when you assign a struct to another variable? Well, the computer will create a brand-new copy of  the struct.
That means it will need to allocate another piece of  memory of  the same size, and then copy over each of  the fields.
Remember: when you’re assigning struct variables, you are telling the computer to copy data.
The assignment copies the pointers to strings, not the strings themselves.
When you assign one struct to another, the contents of the struct will be copied.
But if, as here, that includes pointers, the assignment will just copy the pointer values.
That means the name and species fields of gnasher and snappy both point to the same strings.
Can you put one struct inside another? Remember that when you define a struct, you’re actually creating a new data type.
But if  a struct creates a data type from existing data types, that means you can also create structs from other structs.
To see how this works, let’s look at an example.
This code tells the computer one struct will contain another struct.
You can then create variables using the same arraylike code as before, but now you can include the data for one struct inside another:
Once you’ve combined structs together, you can access the fields using a chain of  “.” operators:
Our new field is called “care,” but it will contain fields defined by the “preferences” struct.
Why would you want to do this? So you can cope with complexity.
By combining structs together, you can create larger and larger data structures.
You might have to begin with just ints and shorts, but with structs, you can describe hugely complex things, like network streams or video images.
The guys at the Head First Aquarium are starting to record lots of data about each of their fish guests.
This is the data that will be recorded for one of the fish:
Question 0: How would you write this data in C?
Question 1: Complete the code of the label() function so it produces output like this:
The guys at the Head First Aquarium are starting to record lots of data about each of their fish guests.
This is the data that will be recorded for one of the fish:
Question 0: How would you write this data in C?
Question 1: Complete the code of the label() function so it produces output like this:
I have to use the struct keyword when I define.
You can give your struct a proper name using typedef.
When you create variables for built-in data types, you can use simple short names like int or double, but so far, every time you’ve created a variable containing a struct you’ve had to include the struct keyword.
But C allows you to create an alias for any struct that you create.
If  you add the word typedef before the struct keyword, and a type name after the closing brace, you can call the new type whatever you like:
Let’s see what your code will look like if  you start to add typedefs to it…
If you use typedef to create an alias for a struct, you will need to decide what your alias will be.
That means there are two names to think about: the name of the struct (struct cell_phone) and the name of the type (phone)
The compiler is quite happy for you to skip the struct name, like this:
Now, when the compiler sees “phone,” it will treat it like “struct cell_phone.”
It’s time for the scuba diver to make his daily round of the tanks, and he needs a new label on his suit.
Trouble is, it looks like some of the code has gone missing.
It’s time for the scuba diver to make his daily round of the tanks, and he needs a new label on his suit.
Trouble is, it looks like some of the code has gone missing.
The coder decided to give the struct the name “scuba” here.
Q: Do struct fields get placed next to each other in memory?
Q: Why’s that? A: The computer likes data to fit inside word boundaries.
Q: So it would leave a gap and start the short in the next 32-bit word?
Q: Does that mean each field takes up a whole word?
The computer leaves gaps only to prevent fields from splitting across word boundaries.
If it can fit several fields into a single word, it will.
Q: Why does the computer care so much about word boundaries?
If a field was split across more than one word, the CPU would have to read several locations and somehow stitch the value together.
Q: In languages like Java, if I assign an object to a variable, it doesn’t copy the object, it just copies a reference.
If you want to copy a reference to a piece of data, you should assign a pointer.
A struct is a data type made from a sequence of other data types.
If you use typedef with a struct, then you can skip giving the struct a name.
How do you update a struct? A struct is really just a bundle of  variables, grouped together and treated like a single piece of  data.
You’ve already seen how to create a struct object, and how to access its values using dot notation.
But how do you change the value of  a struct that already exists? Well, you can change the fields just like any other variable:
That means if  you look at this piece of  code, you should be able to work out what it does, right?
Test Drive This is what happens when you compile and run the code.
And that’s exactly what the code did…at least, for a while.
Inside the happy_birthday() function, the age field was updated, and you know that it worked because the printf() function displayed the new increased age value.
Even though the age was updated by the function, when the code returned to the main() function, the age seemed to reset itself.
But you’ve already been given enough information to tell you exactly what happened.
The code is cloning the turtle Let’s take a closer look at the code that called the happy_birthday() function:
This is the turtle that we are passing to the function.
That means that when you call a function, the values you pass into it are assigned to the parameters.
So in this code, it’s almost as if  you had written something like this:
But remember: when you assign structs in C, the values are copied.
When you call the function, the parameter t will contain a copy of  the myrtle struct.
It’s as if  the function has a clone of  the original turtle.
So the code inside the function does update the age of  the turtle, but it’s a different turtle.
What happens when the function returns? The t parameter disappears, and the rest of  the code in main() uses the myrtle struct.
But the value of  myrtle was never changed by the code.
So what do you do if you want pass a struct to a function that needs to update it?
When you assign a struct, its values get copied to the new struct.
Why did you do that? Because if  you tell the scanf() function where the variable lives in memory, then the function will be able to update the data stored at that place in memory, which means it can update the variable.
If  you want a function to update a struct variable, you can’t just pass the struct as a parameter because that will simply send a copy of  the data to the function.
This means “Someone is going to give me a pointer to a struct.”
This means you will pass the address of the myrtle variable to the function.
See if you can figure out what expression needs to fit into each of the gaps in this new version of the happy_birthday() function.
You were to figure out what expression needs to fit into each of the gaps in this new version of the happy_birthday() function.
It means “the contents of  the memory location given by t.age.” But t.age isn’t a memory location.
I am the contents of the memory location given by t.age.
I am the age of the turtle pointed to by t.
If t is a pointer to a turtle struct, then this expression is wrong.
If t is a pointer to a turtle struct, then this is the age of the turtle.
Test Drive Let’s check if  you got around the bug:
By passing a pointer to the struct, you allowed the function to update the original data rather than taking a local copy.
But the stuff about parentheses and * notation doesn’t make the code all that readable.
I wonder if there’s something that would help with that.
Yes, there is another struct pointer notation that is more readable.
Because you need to be careful to use parentheses in the right way when you’re dealing with pointers, the inventors of  the C language came up with a simpler and easier-to-read piece of syntax.
So, t->age means, “The age field in the struct that t points to,” That means you can also write the function like this:
Safe Cracker Shhh…it’s late at night in the bank vault.
Can you spin the correct combination to crack the safe? Study these pieces of code and then see if you can find the correct combination that will allow you to get to the gold.
Be careful! There’s a swag type and a swag field.
What combination will get you to the string “GOLD!”? Select one symbol or word from each column to assemble the expression.
Q: Why are values copied to parameter variables? A: The computer will pass values to a function by assigning values to the function’s parameters.
Safe Cracker Solution Shhh…it’s late at night in the bank vault.
You were to spin the correct combination to crack the safe.
You needed to study these pieces of code and then find the correct combination that would allow you to get to the gold.
What combination will get you to the string “GOLD!”? You were to select one symbol or word from each column to assemble the expression.
So you can display the gold in the safe with:
When you call a function, the values are copied to the parameter variables.
You can create pointers to structs, just like any other type.
The -> notation cuts down on parentheses and makes the code more readable.
Sometimes the same type of thing needs different types of data.
So if  you want to record, say, a quantity of  something, and that quantity might be a count, a weight, or a volume, how would you do that? Well, you could create several fields with a struct, like this:
But there are a few reasons why this is not a good idea:
It would be really useful if  you could specify something called quantity in a data type and then decide for each particular piece of  data whether you are going to record a count, a weight, or a volume against it.
In C, you can do just that by using a union.
But there are pieces of  data that don’t have a single data type:
A union will use the space for just one of  the fields in its definition.
So, if  you have a union called quantity, with fields called count, weight, and volume, the computer will give the union enough space for its largest field, and then leave it up to you which value you will store in there.
Whether you set the count, weight, or volume field, the data will go into the same space in memory:
A union looks like a struct, but it uses the union keyword.
Each of these fields will be stored in the same space.
Every time you create an instance of  a struct, the computer will lay out the fields in memory, one after the other:
How do you use a union? When you declare a union variable, there are a few ways of  setting its value.
To give the union a value for its first field, just wrap the value in braces:
Designated initializers set other values A designated initializer sets a union field value by name, like this:
Set the value with dot notation The third way of  setting a union value is by creating the variable on one line, and setting a field value on another line:
Remember: whichever way you set the union’s value, there will only ever be one piece of  data stored.
The union just gives you a way of  creating a variable that supports several different data types.
Designated initializers allow you to set struct and union fields by name and are part of the C99 C standard.
They are supported by most modern compilers, but be careful if you are using some variant of the C language.
For example, Objective C supports designated initializers, but C++ does not.
Q: Why is a union always set to the size of the largest field?
A: The computer needs to make sure that a union is always the same size.
The only way it can do that is by making sure it is large enough to contain any of the fields.
Q:Why does the C89 notation only set the first field? Why not set it to the first float if I pass it a float value?
Those designated initializers look like they could be useful for structs as well.
Yes, designated initializers can be used to set the initial values of fields in structs as well.
They can be very useful if  you have a struct that contains a large number of  fields and you initially just want to set a few of  them.
It’s also a good way of  making your code more readable:
This will set the gears and the height fields, but won’t set the color field.
This will print “This order contains 4.20 lbs of apples.”
It’s .amount because that’s the name of the struct quantity variable.
That means you can use its values anywhere you would use another data type like an int or a struct.
And you can access the values in the struct/union combination using the dot or -> notation you used before:
Mixed-Up Mixers It’s Margarita Night at the Head First Lounge, but after one too many samples, it looks like the guys have mixed up their recipes.
See if you can find the matching code fragments for the different margarita mixes.
And finally, here are the different mixes and the drink recipes they produce.
Which of the margaritas need to be added to these pieces of code to generate the correct recipes?
Your job is to play like you’re the compiler and say which one.
Mixed-Up Mixers Solution It’s Margarita Night at the Head First Lounge, but after one too many samples, it looks like the guys have mixed up their recipes.
You were to find the matching code fragments for the different margarita mixes.
And finally, here are the different mixes and the drink recipes they produce.
Which of the margaritas need to be added to these pieces of code to generate the correct recipes?
Your job is to play like you’re the compiler and say which one.
That’s a really good point: you can store lots of possible values in a union, but you have no way of  knowing what type it was once it’s stored.
The compiler won’t be able to keep track of  the fields that are set and read in a union, so there’s nothing to stop us setting one field and reading another.
Is that a problem? Sometimes it can be a BIG PROBLEM.
You need some way, then, of  keeping track of  the values we’ve stored in a union.
One trick that some C coders use is to create an enum.
By mistake, the programmer has set the weight, not the count.
An enum variable stores a symbol Sometimes you don’t want to store a number or a piece of  text.
Instead, you want to store something from a list of symbols.
If  you want to record a day of  the week, you only want to store MONDAY, TUESDAY, WEDNESDAY, etc.
You don’t need to store the text, because there are only ever going to be seven different values to choose from.
You could have given the type a proper name with typedef.
Any variable that is defined with a type of  enum colors can then only be set to one of  the keywords in the list.
So you might define an enum colors variable like this:
Under the covers, the computer will just assign numbers to each of  the symbols in your list, and the enum will just store a number.
But you don’t need to worry about what the numbers are; your C code can just refer to the symbols.
That’ll make your code easier to read, and it will prevent storing values like REB or PUSE:
The computer will spot that this is not a legal value, so it won’t compile.
Nope; I’m not compiling that; it’s not on my list.
So that’s how enums work, but how do they help you keep track of unions? Let’s look at an example…
Code Magnets Because you can create new data types with enums, you can store them inside structs and unions.
In this program, an enum is being used to track the kinds of quantities being stored.
Do you think you can work out where the missing pieces of code go?
Code Magnets Solution Because you can create new data types with enums, you can store them inside structs and unions.
In this program, an enum is being used to track the kinds of quantities being stored.
Were you able to work out where the missing pieces of code go?
I don’t care if  you gave me a float or not.
But store just one thing with different possible types? Dude’s your man.
Can’t you see I’m on the phone here? Listen, you just tell him that if  he wants to store a float and an int, he needs to come see me.
Sometimes you want control at the bit level Let’s say you need a struct that will contain a lot of  yes/no values.
You could create the struct with a series of  shorts or ints:
The problem? The short fields will take up a lot more space than the single bit that you need for true/false values.
It would be much better if  you could create a struct that could hold a sequence of  single bits for the values.
Unfortunately, C doesn’t support binary literals, but it does support hexadecimal literals.
But how do you convert back and forth between hexadecimal and binary? And is it any easier than.
All you need to learn are the binary patterns for the numbers 0–15, and you will soon be able to convert binary to hex and back again in your head within seconds.
Bitfields store a custom number of bits A bitfield lets you specify how many bits an individual field will store.
This means the field will only use 1 bit of storage.
By using bitfields, you can make sure each field takes up only one bit.
If  you have a sequence of  bitfields, the computer can squash them together to save space.
So if  you have eight single-bit bitfields, the computer can store them in a single byte.
Let’s see how how good you are at using bitfields.
Bitfields can save space if they are collected together in a struct.
But if the compiler finds a single bitfield on its own, it might still have to pad it out to the size of a word.
Bitfields can be used to store a sequence of true/false values, but they’re also useful for other short-range values, like months of the year.
If you want to store a month number in a struct, you know it will have a value of, say, 0–11
Back at the Head First Aquarium, they’re creating a customer satisfaction survey.
Let’s see if you can use bitfields to create a matching struct.
How many days a week would you visit if you could?
Back at the Head First Aquarium, they’re creating a customer satisfaction survey.
You were to use bitfields to create a matching struct.
How many days a week would you visit if you could?
A: Because they take up a lot of space, and it’s usually more efficient to write hex values.
They’re important if you need to read low-level binary information.
Q: Such as? A: If you’re reading or writing some sort of custom binary file.
A union allows you to store different data types in the same memory location.
The compiler will let you store one field in a union and read a completely different field.
Bitfields allow you to store a field with a custom number of bits.
Your C Toolbox You’ve got Chapter 5 under your belt, and now you’ve.
Designated initializers let you set struct and union fields by name.
Bitfields give you control over the exact bits stored in a struct.
To model complex data requirements, you often need to link structs together.
You’ll also see how to make your data structures cope with flexible amounts of data by.
Do you need flexible storage? You’ve looked at the different kinds of  data that you can store in C, and you’ve also seen how you can store multiple pieces of  data in an array.
But sometimes you need to be a little more flexible.
Imagine you’re running a travel company that arranges flying tours through the islands.
Each tour contains a sequence of  short flights from one island to the next.
For each of  those islands, you will need to record a few pieces of  information, such as the name of  the island and the hours that its airport is open.
You could create a struct to represent a single island:
Now if  a tour passes through a sequence of  islands, that means you’ll need to record a list of  islands, and you can do that with an array of  islands:
Arrays are fixed length, which means they’re not very flexible.
You can use one if  you know exactly how long a tour will be.
But what if  you need to change the tour? What if  you want to add an extra destination to the middle of  the tour?
To store a flexible amount of data, you need something more extensible than an array.
Linked lists are like chains of data A linked list is an example of  an abstract data structure.
It’s called an abstract data structure because a linked list is general:  it can be used to store a lot of  different kinds of  data.
To understand how a linked list works, think back to our tour company.
A linked list stores a piece of  data, and a link to another piece of  data.
In a linked list, as long as you know where the list starts, you can travel along the list of links, from one of piece of data to the next, until you reach the end of the list.
Using a pencil, change the list so that the tour includes a trip to Skull Island between Craggy Island and Isla Nublar.
You are storing a piece of data for each island.
This is a link to the next piece of data.
In a linked list, as long as you know where the list starts, you can travel along the list of links, from one of piece of data to the next, until you reach the end of the list.
Using a pencil, you were to change the list so that the tour includes a trip to Skull Island between Craggy Island and Isla Nublar.
Linked lists allow inserts With just a few changes, you were able to add an extra step to the tour.
That’s another advantage linked lists have over arrays: inserting data is very quick.
If  you wanted to insert a value into the middle of  an array, you would have to shuffle all the pieces of  data that follow it along by one:
So linked lists allow you to store a variable amount of data, and they make it simple to add more data.
But how do you create a linked list in C?
If you wanted to insert an extra value after Craggy Island, you’d have to move the other values along one space.
And because an array is fixed length, you’d lose Shutter Island.
You needed to remove the flight from Craggy to Isla Nublar.
You needed to create a new flight from Craggy to Skull.
Create a recursive structure Each one of  the structs in the list will need to connect to the one next to it.
A struct that contains a link to another struct of  the same type is called a recursive structure.
If you use the typedef command, you can normally skip giving the struct a proper.
But in a recursive structure, you need to include a pointer to the same type.
You need to record all of the usual details for the island…
Recursive structures contain pointers to other structures of  the same type.
So if  you have a flight schedule for the list of  islands that you’re going to visit, you can use a recursive structure for each island.
How do you store a link from one struct to the next? With a pointer.
That way, the island data will contain the address of  the next island that we’re going to visit.
So, whenever our code is at one island, it will always be able to hop over to the next island.
You store a pointer to the next island in the struct.
Create islands in C… Once you have defined an island data type, you can create the first set of  islands like this:
This code will create island structs for each of the islands.
You have to be careful to set the next field in each island to the address of  the next island.
So now you’ve created a complete island tour in C, but what if  you want to insert an excursion to Skull Island between Isla Nublar and Shutter Island?
Code Magnets Oh, no, the code for the display() function was on the fridge door, but someone’s mixed up the magnets.
Inserting values into the list You can insert islands just like you did earlier, by changing the values of  the pointers between islands:
In just two lines of  code, you’ve inserted a new value into the list.
If  you were using an array, you’d write a lot more code to shuffle items along the array.
OK, you’ve seen how to create and use linked lists.
Code Magnets Solution Oh, no, the code for the display() function was on the fridge door, but someone’s mixed up the magnets.
You don’t need any extra code at the start of the loop.
You need to keep looping until the current island has no next value.
At the end of each loop, skip to the next island.
Q: Other languages, like Java, have linked lists built in.
A: C doesn’t really come with any data structures built in.
Q: What if I want to use the 700th item in a really long list? Do I have to start at the first item and then read all the way through?
I thought a linked list was better than an array.
A: You shouldn’t think of data structures as being better or worse.
They are either appropriate or inappropriate for what you want to use them for.
Q: So if I want a data structure that lets me insert things quickly, I need a linked list, but if I want direct access I might use an array?
Q: You’ve shown a struct that contains a pointer to another struct.
Can a struct contain a whole recursive struct inside itself?
Q: Why not? A: C needs to know the exact amount of space a struct will occupy in memory.
If it allowed full recursive copies of the same struct, then one piece of data would be a different size than another.
Test Drive Let’s use the display() function on the linked list of  islands and compile the code together into a program called tour.
The code creates a linked list of  islands, and you can insert items with very little work.
OK, so now that you know the basics of  how to work with recursive structs and lists, you can move on to the main program.
You need to read the tour data from a file that looks like this:
The folks at the airline are still creating the file, so you won’t know how long it is until runtime.
Each line in the file is the name of  an island.
It should be pretty straightforward to turn this file into a linked list.
The code on this page declares a new variable, skull, right in the middle of the code.
In ANSI C, you need to declare all your local variables at the top of a function.
Hmmm… So far, we’ve used a separate variable for each item in the list.
But if we don’t know how long the file is, how do we know how many variables we need? I wonder if there’s some way to generate new storage when we need it.
All of  the programs you’ve written so far have used static storage.
Every time you wanted to store something, you’ve added a variable to the code.
Remember: the stack is the area of  memory set aside for storing local variables.
So when you created the first four islands, you did it like this:
This piece of  code will always create exactly four islands.
If  you wanted the code to store more than four islands, you would need another local variable.
That’s fine if  you know how much data you need to store at compile time, but quite often, programs don’t know how much storage they need until runtime.
If  you’re writing a web browser, for instance, you won’t know how much data you’ll need to store a web page until, well, you read the web page.
So C programs need some way to tell the operating system that they need a little extra storage, at the moment that they need it.
Wouldn’t it be dreamy if there were a way to allocate as much space as I needed with code at runtime? But I know that’s just a fantasy…
Use the heap for dynamic storage Most of  the memory you’ve been using so far has been in the stack.
The stack is the area of  memory that’s used for local variables.
Each piece of  data is stored in a variable, and each variable disappears as soon as you leave its function.
The trouble is, it’s harder to get more storage on the stack at runtime, and that’s where the heap comes in.
The heap is the place where a program stores data that will need to be available longer term.
It won’t automatically get cleared away, so that means it’s the perfect place to store data structures like our linked list.
You can think of  heap storage as being a bit like reserving a locker in a locker room.
First, get your memory with malloc() Imagine your program suddenly finds it has a large amount of  data that it needs to store at runtime.
This is a bit like asking for a large storage locker for the data, and in C you do that with a function called malloc()
You tell the malloc() function exactly how much memory you need, and it asks the operating system to set that much memory aside in the heap.
The malloc() function then returns a pointer to the new heap space, a bit like getting a key to the locker.
It allows you access to the memory, and it can also be used to keep track of  the storage locker that’s been allocated.
The malloc() function will give you a pointer to the space in the heap.
Give the memory back when you’re done The good news about heap memory is that you can keep hold of  it for a really long time.
The bad news is…you can keep hold of  it for a really long time.
When you were just using the stack, you didn’t need to worry about returning memory; it all happened automatically.
Every time you leave a function, the local storage is freed from the stack.
Once you’ve asked for space on the heap, it will never be available for anything else until you tell the C Standard Library that you’re finished with it.
There’s only so much heap memory available, so if  your code keeps asking for more and more heap space, your program will quickly start to develop memory leaks.
A memory leak happens when a program asks for more and more memory without releasing the memory it no longer needs.
Memory leaks are among the most common bugs in C programs, and they can be really hard to track down.
The heap has only a fixed amount of storage available, so be sure you use it wisely.
Free memory by calling the free() function The malloc() function allocates space and gives you a pointer to it.
You’ll need to use this pointer to access the data and then, when you’re finished with the storage, you need to release the memory using the free() function.
It’s a bit like handing your locker key back to the attendant so that the locker can be reused.
Every time some part of  your code requests heap storage with the malloc() function, there should be some other part of  your code that hands the storage back with the free() function.
When your program stops running, all of  its heap storage will be released automatically, but it’s always good practice to explicitly call free() on every piece of  dynamic memory you’ve created.
Ask for memory with malloc()… The function that asks for memory is called malloc() for memory allocation.
Most of  the time, you probably don’t know exactly how much memory you need in bytes, so malloc() is almost always used with an operator called sizeof, like this:
You need to include the stdlib.h header file to pick up the malloc() and free() functions.
This means, “Give me enough space to store an island struct.”
It might be a struct, or it could be some base data type, like int or double.
The malloc() function sets aside a chunk of  memory for you, then returns a pointer containing the start address.
But what kind of  pointer will that be? malloc() actually returns a general-purpose pointer, with type void*
This means, “Create enough space for an island, and store the address in variable p.”
But once you’ve finished, you need to release the memory using the free() function.
As long as the library is told where the chunk of  memory starts, it will be able to check its records to see how much memory to free up.
So if  you wanted to free the memory you allocated above, you’d do it like this:
OK, now that we know more about dynamic memory, we can start to write some code.
Remember: if you allocated memory with malloc() in one part of your program, you should always release it later with the free() function.
Do you think there might be any problems with it? Once you’ve thought about it good and hard, turn the page to see it in action.
The actors have spotted that most of  the island airports have the same opening and closing times, so they’ve set the opens and closes fields to default values.
The function returns a pointer to the newly created struct.
It’s using the malloc() function to create space on the heap.
The sizeof operator works out how many bytes are needed.
The name of the island is passed as a char pointer.
This will create a new island struct on the heap.
The aspiring actors are currently between jobs, so they’ve found some free time in their busy schedules to help you out with the coding.
They’ve created a utility function to create a new island struct with a name that you pass to it.
A create() function using dynamic allocation has been written, and the coding team says it is ready for air trials.
Take off  from landing strip rocky due to earth tremors.
Ask the user for the name of an isla nd.
The flight log produced by the test program appears to have a bug.
When the details of  today’s flight are logged, the trip to the first island has been mysteriously renamed.
What happened to the name of  the first island? Is there a bug in the create() function? Does the way it was called give any clues?
Ask the user to enter the name of the second island.
What happened to Atlantis???? The first island now has the same name as the second island!!!
When the code records the name of  the island, it doesn’t take a copy of the whole name string; it just records the address where the name string lives in memory.
Is that important? Where did the name string live? We can find out by looking at the code that was calling the function:
The program asks the user for the name of  each island, but both times it uses the name local char array to store the name.
That means that the two islands share the same name string.
As soon as the local name variable gets updated with the name of  the second island, the name of  the first island changes as well.
In C, you often need to make copies of  strings.
You could do that by calling the malloc() function to create a little space on the heap and then manually copying each character from the string you are copying to the space on the heap.
But guess what? Other developers got there ahead of  you.
They created a function in the string.h header called strdup()
Let’s say that you have a pointer to a character array that you want to copy:
The strdup() function can reproduce a complete copy of  the string somewhere on the heap:
The strdup() function works out how long the string is, and then calls the malloc() function to allocate the correct number of characters on the heap.
It then copies each of the characters to the new space on the heap.2
That means that strdup() always creates space on the heap.
It can’t create space on the stack because that’s for local variables, and local variables get cleared away too often.
But because strdup() puts new strings on the heap, that means you must always remember to release their storage with the free() function.
Let’s fix the code using the strdup() function You can fix up the original create() function using the strdup() function, like this:
You can see that we only need to put the strdup() function on the name field.
It’s because we are setting the opens and closes fields to string literals.
Remember way back when you saw where things were stored in memory? String literals are stored in a read-only area of  memory set aside for constant values.
Because you always set the opens and closes fields to constant values, you don’t need to take a defensive copy of  them, because they’ll never change.
But you had to take a defensive copy of  the name array, because something might come and update it later.
So does it fix the code? To see if  the change to the create() function fixed the code, let’s run your original code again:
Each time the user enters the name of  an island, the create() function is storing it in a brand-new string.
OK, now that you have a function to create island data, let’s use it to create a linked list from a file.
Q: If the island struct had a name array rather than a character pointer, would I need to use strdup() here?
Each island struct would store its own copy, so you wouldn’t need to make your own copy.
Q: So why would I want to use char pointers rather than char arrays in my data structures?
A: char pointers won’t limit the amount of space you need to set aside for strings.
If you use char arrays, you will need to decide in advance exactly how long your strings might need to be.
Pool Puzzle Catastrophe! The code to create an island tour has.
Your goal is to reconstruct the program so that it can read a list of names from Standard Input and then connect them together to form a linked list.
Note: each thing from the pool can be used only once!
Your goal was to reconstruct the program so that it can read a list of names from Standard Input and then connect them together to form a linked list.
Note: each thing from the pool can be used only once!
We’ll keep looping until we don’t get any more strings.
At the end of each loop, set i to the next island we created.
The first time through, start is set to NULL, so set it to the first island.
Don’t forget: i is a pointer, so we’ll use -> notation.
Don’t forget that if you ever allocate space with the malloc() function, you need to release the space with the free() function.
The program you’ve written so far creates a linked list of islands in heap memory using malloc(), but now it’s time to write some code to release that space once you’re done with it.
Here’s a start on a function called release() that will release all of the memory used by a linked list, if you pass it a pointer to the first island:
When you release the memory, what will you need to free? Just the island, or something more? In what sequence should you free them?
Don’t forget that if you ever allocate space with the malloc() function, you need to release the space with the free() function.
The program you’ve written so far creates a linked list of islands in heap memory using malloc(), but now it’s time to write some code to release that space once you’re done with it.
Here’s a start on a function called release() that will release all of the memory used by a linked list, if you pass it a pointer to the first island:
When you release the memory, what will you need to free? Just the island, or something more? In what sequence should you free them?
First, you need to free the name string that you created with strdup()
If you’d freed the island first, you might not have been able to reach the name to free it.
Free the memory when you’re done Now that you have a function to free the linked list, you’ll need to call it when you’ve finished with it.
Your program only needs to display the contents of  the list, so once you’ve done that, you can release it:
Test Drive So, if  you compile the code and then run the file through it, what happens?
Remember: you had no way of  knowing how long that file was going to be.
In this case, because you are just printing out the file, you could have simply printed it out without storing it all in memory.
But because you do have it in memory, you’re free to manipulate it.
You could add in extra steps in the tour, or remove them.
Dynamic memory allocation lets you create the memory you need at RUNTIME.
And the way you access dynamic heap memory is with malloc() and free()
Just need to free up the storage from those local variables.
You really should consider getting somebody in to take care of  this place.
How do you know? I mean, how do you know it hasn’t just forgotten about it?
Hmmm? Are you sure? Wasn’t it written by the same woman who wrote that dreadful Whack-abunny game? Memory leaks everywhere.
Hey, it’s not my responsibility to clear up the memory.
I’ll leave it there until he tells me to clean it up.
If  a program wants to make a mess, it’s not my responsibility.
Don’t worry; I don’t think the program needs it anymore.
Fussing? I don’t fuss! You might want to use a napkin…
Q: Why is the heap called the heap? A: Because the computer doesn’t automatically organize it.
Q: What’s garbage collection? A: Some languages track when you allocate data on a heap and then, when you’re no longer using the data, they free the data from the heap.
A: C is quite an old language; when it was invented, most languages didn’t do automatic garbage collection.
Q: I understand why I needed to copy the name of the island in the example.
Why didn’t I need to copy the opens and closes values?
A: The opens and closes values are set to string literals.
String literals can’t be updated, so it doesn’t matter if several data items refer to the same string.
A: It will depend on how the C Standard Library is implemented, but most of the time, yes.
Q: Do I need to free all my data before the program ends?
A: You don’t have to; the operating system will clear away all of the memory when the program exits.
But it’s good practice to always explicitly free anything you’ve created.
Dynamic data structures allow you to store a variable number of data items.
A linked list is a data structure that allows you to easily insert items.
Dynamic data structures are normally defined in C with recursive structs.
A recursive struct contains one or more pointers to a similar struct.
The stack is used for local variables and is managed by the computer.
The sizeof operator will tell you how much space a struct needs.
Data will stay on the heap until you release it with free()
You’ve seen how to create a linked list in C.
But linked lists aren’t the only data structures you might need to build.
See if  you can match up the data structure with the description of  how it can be used.
I can be used to store a sequence of items, and I make it easy to insert new items.
Each item I store can connect to up to two other items.
I can be used to associate two different types of data.
For example, you could use to me to associate people’s names to their phone numbers.
Each item I store connects to up to two other items.
You’ve seen how to create a linked list in C.
But linked lists aren’t the only data structures you might need to build.
You were to match up the data structure with the description of  how it can be used.
I can be used to store a sequence of items, and I make it easy to insert new items.
Each item I store can connect to up to two other items.
I can be used to associate two different types of data.
For example, you could use to me to associate people’s names to their phone numbers.
Each item I store connects to up to two other items.
Associated array or map It connects key information to value information.
It’s like a normal linked list, but it has connections going both ways.
Data structures are useful, but be careful! You need to be careful when you create these data structures using C.
If  you don’t keep proper track of  the data you are storing, there’s a risk that you’ll leave old dead data on the heap.
Over time, this will start to eat away at the memory on your machine, and it might cause your program to crash with memory errors.
That means it’s really important that you learn to track down and fix memory leaks in your code…
Our Cambridge, MA, office advised t hat there is a suspected leak.
An informant who has furnished re liable information in the past.
You are hereby given access to the e xpert system source code.
This software can be used to record and identify persons of  interest.
You are not required to read this code in detail now, but please keep a copy in your records so that you may refer to it during the ongoing investigation.
An overview of the SPIES system The SPIES program is an expert system that learns how to identify individuals using distinguishing features.
The more people you enter into the system, the more the software learns and the smarter it gets.
The program builds a tree of suspects The program records data using a binary tree.
A binary tree allows each piece of  data to connect to two other pieces of  data like this:
This is what the data looks like when the program starts.
The first item (or node) in the tree stores a question: “Does the suspect have a mustache?” That’s linked to two other nodes: one if  the answer’s yes, and another if  the answer’s no.
The yes and no nodes store the name of  a suspect.
The program will use this tree to ask the user a series of  questions to identify a suspect.
If  the program can’t find the suspect, it will ask the user for the name of  the new suspect and some detail that can be used to identify him or her.
It will store this information in the tree, which will gradually grow as it learns more things.
The program will store new information in the tree like this.
The suspect names always appear at the ends of the tree.
Test Drive This is what happens if  an agent compiles the SPIES program and then takes it on a test run:
The first time through, the program fails to identify the suspect Hayden Fantucci.
But once the suspect’s details are entered, the program learns enough to identify Mr.
So what’s the problem? Someone was using the system for a few hours in the lab and noticed that even though the program appeared to be working correctly, it was using almost twice the amount of  memory it needed.
Somewhere deep in the source code, something is allocating memory on the heap and never freeing it.
Now, you could just sit and read through all of  the code and hope that you see what’s causing the problem.
But memory leaks can be awfully difficult to track down.
So maybe you should pay a trip to the software lab…
Prepare your code: add debug info You don’t need to do anything to your code before you run it through valgrind.
But to really get the most out of  valgrind, you need to make sure your executable contains debug information.
Debug information is extra data that gets packed into your executable when it’s compiled—things like the line number in the source file that a particular piece of  code was compiled from.
If  the debug info is present, valgrind will be able to give you a lot more details about the source of  your memory leak.
To add debug info into your executable, you need to recompile the source with the -g switch:
It can take an achingly long time to track down bugs in large, complex programs like SPIES.
So C hackers have written tools that can help you on your way.
One tool used on the Linux operating system is called valgrind.
It works by creating its own fake version of  malloc()
When your program wants to allocate some heap memory, valgrind will intercept your calls to malloc() and free() and run its own versions of  those functions.
The valgrind version of  malloc() will take note of  which piece of code is calling it and which piece of  memory it allocated.
When your program ends, valgrind will report back on any data that was left on the heap and tell you where in your code the data was created.
The -g switch tells the compiler to record the line numbers against the code it compiles.
Just the facts: interrogate your code To see how valgrind works, let’s fire it up on a Linux box and use it to interrogate the SPIES program a couple times.
The first time, use the program to identify one of  the built-in suspects: Vinny the Spoon.
You’ll start valgrind on the command line with the --leak-check=full option and then pass it the program you want to run:
Does suspect have a mustache? (y/n): y Vinny the Spoon? (y/n): y SUSPECT IDENTIFIED Run again? (y/n): n ==1754== All heap blocks were freed -- no leaks are possible.
You can find out if valgrind is available on your operating system and how to install it at http://valgrind.org.
Use valgrind repeatedly to gather more evidence When the SPIES program exited, there was nothing left on the heap.
But what if  you run it a second time and teach the program about a new suspect called Hayden Fantucci?
This time, valgrind found a memory leak It looks like there were 19 bytes of  information left on the heap at the end of  the program.
Look at the evidence OK, now that you’ve run valgrind, you’ve collected quite a few pieces of  evidence.
It’s time to analyze that evidence and see if  you can draw any conclusions.
The memory leak only happened when you entered a new suspect name.
Why is that significant? Because that means the leak can’t be in the code that ran the first time.
Looking back at the source code, that means the problem lies in this section of  the code:
If  you look at the source code, what piece of  data is likely to take up 19 bytes of  space?
How many pieces of data were left on the heap?
What was the piece of data left on the heap?
You were to consider the evidence carefully and answer these questions.
How many pieces of data were left on the heap?
What was the piece of data left on the heap?
The create() functions themselves don’t cause leaks because they didn’t on the first pass, so it must be this strdup() line:
If current->question is already pointing to something on the heap, free that before allocating a new question:
The fix on trial Now that you’ve added the fix to the code, it’s time to run the code through valgrind again.
The leak is fixed You ran exactly the same test data through the program, and this time the program cleared everything away from the heap.
How did you do? Did you crack the case? Don’t worry if  you didn’t manage to find and fix the leak this time.
Memory leaks are some of  the hardest bugs to find in C programs.
The truth is that many of  the C programs available probably have some memory bugs buried deep inside them, but that’s why tools like valgrind are important.
Q: valgrind said the leaked memory was created on line 46, but the leak was fixed on a completely different line.
Leaks don’t happen when data is created; they happen when the program loses all references to the data.
Q: How does valgrind intercept calls to malloc() and free()?
A: The malloc() and free() functions are contained in the C Standard Library.
But valgrind contains a library with its own versions of malloc() and free()
When you run a program with valgrind, your program will be using valgrind’s functions, rather than the ones in the C Standard Library.
Q: Why doesn’t the compiler always include debug information when it compiles code?
A: Because debug information will make your executable larger, and it may also make your program slightly slower.
A: Valgrind is the name of the entrance to Valhalla.
When a program stops running, valgrind prints details of what’s left on the heap.
If you compile your code with debug information, valgrind can give you more information.
If you run your program several times, you can narrow the search for the leak.
Your C Toolbox You’ve got Chapter 6 under your belt, and now you’ve.
For a complete list of tooltips in the book, see Appendix ii.
Recursive structs contain one or more links to similar data.
A memory leak is allocated memory you can no longer access.
My go_on_date() is awesome now that I’ve discovered variadic functions.
So far, you’ve focused on the basics, but what if you need even more power and.
And finally, you’ll discover how to make your code super stretchy.
Right… You’ve used a lot of  C functions in the book so far, but the truth is that there are still some ways to make your C functions a lot more powerful.
If  you know how to use them correctly, C functions can make your code do more things but without writing a lot more code.
To see how this works, let’s look at an example.
Imagine you have an array of  strings that you want to filter down, displaying some strings and not displaying others:
I want someone into sports, but definitely not into Bieber…
Let’s write some code that uses string functions to filter this array down.
Code Magnets Complete the find() function so it can track down all the sports fans in the list who don’t also share a passion for Bieber.
Beware: you might not need all the fragments to complete the function.
Code Magnets Solution You were to complete the find() function so it can track down all the sports fans in the list who don’t also share a passion for Bieber.
Test Drive Now, if  you take the function and the data, and wrap everything up in a program called find.c, you can compile and run it like this:
And sure enough, the find() function loops through the array and finds the matching strings.
Now that you have the basic code, it would be easy to create clones of  the function that could perform different kinds of  searches.
If you clone the function, you’ll have a lot of duplicated code.
At the moment, the find() function runs through each element of  the array and applies a simple test to each string to look for matches.
Now, you could pass some strings into the function so that it could search for different substrings.
The trouble is, that wouldn’t allow find() to check for three strings, like “arts,” “theater,” or “dining.” And what if  you needed something wildly different?
Pass code to a function What you need is some way of  passing the code for the test to the find() function.
If  you had some way of wrapping up a piece of  code and handing that code to the function, it would be like passing the find() function a testing machine that it could apply to each piece of  data.
This means the bulk of  the find() function would stay exactly the same.
It would still contain the code to check each element in an array and display the same kind of  output.
But the test it applies against each element in the array would be done by the code that you pass to it.
This testing machine looks for people who like arts, theater, or dining.
This testing machine looks for people who like sports or working out.
You need to tell find() the name of a function Imagine you take our original search condition and rewrite it as a function:
I want someone into sports, but definitely not into Bieber…
Now, if  you had some way of  passing the name of  the function to find() as a parameter, you’d have a way of  injecting the test:
Here, you’d need some way of calling the function whose name was given by the match parameter.
If  you could find a way of  passing a function name to find(), there would be no limit to the kinds of  tests that you could make in the future.
As long as you can write a function that will return true or false to a string, you can reuse the same find() function.
But how do you say that a parameter stores the name of a function? And if you have a function name, how do you use it to call the function?
Every function name is a pointer to the function… You probably guessed that pointers would come into this somewhere, right? Think about what the name of a function really is.
It’s a way of  referring to the piece of  code.
And that’s just what a pointer is: a way of referring to something in memory.
That’s why, in C, function names are also pointer variables.
So, if  you give find() a parameter that has a function pointer type, you should be able to use the parameter to call the function it points to.
Let’s look at the C syntax you’ll need to work with function pointers.
When you call the function, you are using the function pointer.
If  you have a data type like int, you just need to add an asterisk to the end of  the data type name, and you declare a pointer with int *
Unfortunately, C doesn’t have a function data type, so you can’t declare a function pointer with anything like function *
Why doesn’t C have a function data type? C doesn’t have a function data type because there’s not just one type of  function.
When you create a function, you can vary a lot of  things, such as the return type or the list of  parameters it takes.
That combination of  things is what defines the type of  the function.
These functions are different types because they have different return types and parameters.
So, for function pointers, you’ll need to use slightly more complex notation…
How to create function pointers Say you want to create a pointer variable that can store the address of  each of  the functions on the previous page.
Unfortunately, it has to be, because you need to tell C the return type and the parameter types the function will take.
But once you’ve declared a function pointer variable, you can use it like any other variable.
You can assign values to it, you can add it to arrays, and you can also pass it to functions…
Take a look at those other types of searches that people have asked for.
See if you can create a function for each type of search.
This will call the match() function that was passed in.
You were to take a look at those other types of searches that people have asked for and create a function for each type of search.
Test Drive Let’s take those functions out on the road and see how they perform.
You’ll need to create a program to call find() with each function in turn:
Each call to the find() function is performing a very different search.
That’s why function pointers are one of  the most powerful features in C: they allow you to mix functions together.
Function pointers let you build programs with a lot more power and a lot less code.
Q: If function pointers are just pointers, why don’t you need to prefix them with a * when you call the function?
In the program, instead of writing match(ADS[i]), you could have written (*match)(ADS[i])
Q: And could I have used & to get the address of a method?
Q: Then why didn’t I? A: Because it makes the code easier to read.
When you’re out in the reeds, identifying those function pointers can be pretty tricky.
But this simple, easy-to-carry guide will fit in the ammo pocket of any C user.
Get it sorted with the C Standard Library Lots of  programs need to sort data.
And if  the data’s something simple like a set of  numbers, then sorting is pretty easy.
But it’s not so easy with other types of  data.
How would you put them in order? By height? By intelligence? By hotness?
When the people who wrote the C Standard Library wanted to create a sort function, they had a problem:
How could a sort function sort any type of data at all?
Use function pointers to set the order You probably guessed the solution: the C Standard Library has a sort function that accepts a pointer to a comparator function, which will be used to decide if  one piece of  data is the same as, less than, or greater than another piece of  data.
This is the size of each element in the array.
This is a pointer to a function that compares two items in the array.
The qsort() function compares pairs of  values over and over again, and if  they are in the wrong order, the computer will switch them.
It will tell qsort() which order a pair of  elements should be in.
To see how this works in practice, let’s look at an example.
If the first value is less than the second value, it should return a negative number.
If the first value is greater than the second value, it should return a positive number.
If the two values are equal, it should return zero.
Let’s say you have an array of  integers and you want to sort them in increasing order.
If  you look at the signature of  the comparator function that qsort() needs, it takes two void pointers given by void*
Remember void* when we used malloc()? A void pointer can store the address of  any kind of  data, but you always need to cast it to something more specific before you can use it.
The qsort() function works by comparing pairs of  elements in the array and then placing them in the correct order.
It compares the values by calling the comparator function that you give it.
A void pointer void* can store a pointer to anything.
Values are always passed to the function as pointers, so the first thing you need to do is get the integer values from the pointers:
You need to cast the void pointer to an integer pointer.
Then you need to return a positive, negative, or zero value, depending on whether a is greater than, less than, or equal to b.
For integers, that’s pretty easy to do—you just subtract one number from the other:
And this is how you ask qsort() to sort the array:
See if you can write a comparator function for each one.
To get you started, the first one is already completed.
You were to look at these different sort descriptions and write a comparator function for each one.
If you subtract the numbers the other way around, you’ll reverse the order of the final sort.
A string is a pointer to a char, so the pointers you’re given are pointers to pointers.
We need to use the * operator to find the actual strings.
Don’t worry if  this exercise caused you a few problems.
It involved pointers, function pointers, and even a little math.
If you found it tough, take a break, drink a little water, and then try it again in an hour or two.
Test Drive Some of  the comparator functions were really pretty gnarly, so it’s worth seeing how they run in action.
This is the kind of  code you need to call the functions.
This will print out the array once it’s been sorted.
Remember: an array of names is just an array of char pointers, so the size of each item is sizeof(char*)
If  you compile and run this code, this is what you get:
Q: I don’t understand the comparator function for the array of strings.
A: Each item in a string array is a char pointer (char*)
When qsort() calls the comparator function, it sends pointers to two elements in the arrays.
Q: Does qsort() create a sorted version of an array?
A: It doesn’t make a copy, it actually modifies the original array.
Q: Why does my head hurt? A: Don’t worry about it.
If you don’t find them a little confusing, it probably means you aren’t thinking hard enough about them.
The sorting functions can be incredibly useful, but the comparator functions they need can be tricky to write.
But the more practice you get, the easier they become.
Automating the Dear John letters Imagine you’re writing a mail-merge program to send out different types of  messages to different people.
One way of creating the data for each response is with a struct like this:
These are the three types of messages that will be sent to people.
You’ll record a response type with each piece of response data.
The enum gives you the names for each of  the three types of response you’ll be sending out, and that response type can be recorded against each response.
Then you’ll be able to use your new response data type by calling one of  these three functions for each type of  response:
So, now that you know what the data looks like, and you have the functions to generate the responses, let’s see how complex the code is to generate a set of  responses from an array of  data.
Pool Puzzle Take code fragments from the pool and place.
Your goal is to piece together the main() function so that it can generate a set of letters for the array of response data.
You may not use the same code fragment more than once.
Note: each thing from the pool can be used only once!
Pool Puzzle Solution Take code fragments from the pool and place.
Your goal was to piece together the main() function so that it can generate a set of letters for the array of response data.
Note: each thing from the pool can be used only once!
Looping through the array Testing the type field each time.
Test Drive When you run the program, sure enough, it generates the correct response for each person:
Dear Matt, Good news: your last date has asked us to arrange another meeting.
Dear William, Congratulations! Your last date has contacted us with a proposal of marriage.
Well, it’s good that it worked, but there is quite a lot of  code in there just to call a function for each piece of  response data.
Every time you need call a function that matches a response type, it will look like this:
And what will happen if  you add a fourth response type? You’ll have to change every section of  your program that looks like this.
Soon, you will have a lot of  code to maintain, and it might go wrong.
Fortunately, there is a trick that you can use in C, and it involves arrays…
They told me a coder forgot a set of break statements, and that meant I ended up with this guy…
Create an array of function pointers The trick is to create an array of  function pointers that match the different response types.
Before seeing how that works, let’s look at how to create an array of  function pointers.
If  you had an array variable that could store a whole bunch of  function names, you could use it like this:
You have to tell the compiler exactly what the functions will look like that you’re going to store in the array: what their return types will be and what parameters they’ll accept.
That means you have to use this much more complex syntax:
But how does an array help? Look at that array.
It contains a set of  function names that are in exactly the same order as the types in the enum:
And that’s really neat, because it means you can get a pointer to one of  your sets of  functions using a response_type:
Let’s see if you can use the function array to replace your old main() function.
Each function in the array will be a void function.
And it’s not just a function pointer; it’s a whole array of them.
Now you’re done naming the variable, and it’s time to say what parameters each function will take.
But take your time with it, and you should be fine.
You already have all the information you need to complete the code.
In this new version of the main() function, the whole switch/case statement used before has been removed and needs to be replaced with a single line of code.
This line of code will find the correct function name from the replies array and then use it to call the function.
In this new version of the main() function, the whole switch/case statement used before was removed, and you needed to replace it.
This line of code will find the correct function name from the replies array and then use it to call the function.
This whole thing is a function like “dump” or “marriage.”
You’re calling the function and passing it the response data r[i]
Test Drive Now, when you run the new version of  the program, you get exactly the same output as before:
Dear Matt, Good news: your last date has asked us to arrange another meeting.
Dear William, Congratulations! Your last date has contacted us with a proposal of marriage.
The difference? Now, instead of  an entire switch statement, you just have this:
If  you have to call the response functions at several places in the program, you won’t have to copy a lot of  code.
And if  you decide to add a new type and a new function, you can just add it to the array:
Arrays of  function pointers can make your code much easier to manage.
They are designed to make your code scalable by making it shorter and easier to extend.
Even though they are quite difficult to understand at first, function pointer arrays can really crank up your C programming skills.
Q: Why is the function pointer array syntax so complex?
A: Because when you declare a function pointer, you need to say what the return and parameter types are.
Q: This looks a little like the sort of object-oriented code in other languages.
Object-oriented languages associate a set of functions (called methods) with pieces of data.
In the same way, you can use function pointers to associate functions with pieces of data.
Q: Hey, so does that mean that C is object oriented? Wow, that’s awesome.
The name of each function is actually a function pointer.
If you have a function shoot(), then shoot and &shoot are both pointers to that function.
The C Standard Library has a sorting function called qsort()
The comparator function will be passed pointers to two items in the array being sorted.
If you have an array of data, you can associate functions with each data item using function pointer arrays.
Make your functions streeeeeetchy Sometimes, you want to write C functions that are really powerful, like your find() function that could search using function pointers.
But other times, you just want to write functions that are easy to use.
The printf() function has one really cool feature that you’ve used: it can take a variable number of  arguments:
So how can YOU do that? And you’ve got just the problem that needs it.
Down in the Head First Lounge, they’re finding it a little difficult to keep track of  the drink totals.
One of  the guys has tried to make life easier by creating an enum with the list of  cocktails available and a function that returns the prices for each one:
And that’s pretty cool, if  the Head First Lounge crew just wants the price of a drink.
But what they want to do is get the price of  a total drinks order:
They want a function called total() that will accept a count of the drinks and then a list of  drink names.
A function that takes a variable number of  parameters is called a variadic function.
The C Standard Library contains a set of  macros that can help you create your own variadic functions.
To see how they work, you’ll create a function that can print out series of  ints:
You can think of macros as a special type of function that can modify your source code.
Number of ints to print The ints that need to be printed.
This is a normal, ordinary argument that will always be passed.
Let’s break it down and take a look at it, step by step.
In the case of  our function, that’ll be the args parameter.
Then read off the variable arguments, one at a time.
After you’ve finished reading all of  the arguments, you need to tell C that you’re finished.
All the code to handle variadic functions is in stdarg.h, so you need to make sure you include it.
In C, an ellipsis after the argument of  a function means there are more arguments to come.
A va_list will be used to store the extra arguments that are passed to your function.
A macro is used to rewrite your code before it’s compiled.
A: No, they are designed to look like ordinary functions, but they actually are replaced by the preprocessor with other code.
Q: And the preprocessor is? A: The preprocessor runs just before the compilation step.
Among other things, the preprocessor includes the headers into the code.
Q: Can I have a function with just variable arguments, and no fixed arguments at all?
You need to have at least one fixed argument in order to pass its name to va_start.
Q: What happens if I try to read more arguments from va_arg than have been passed in?
Q: What if I try to read an int argument as a double, or something?
The guys in the Head First Lounge want to create a function that can return the total cost of a round of drinks, like this:
Using the price() from a few pages back, complete the code for total():
The guys in the Head First Lounge want to create a function that can return the total cost of a round of drinks, like this:
Using the price() from a few pages back, you were to complete the code for total():
Don’t worry if your code doesn’t look exactly like this.
Test Drive If  you create a little test code to call the function, you can compile it and see what happens:
Your code works! Now you know how to use variable arguments to make your code simpler and more intuitive to use.
Functions that accept a variable number of arguments are called variadic functions.
To create variadic functions, you need to include the stdarg.h header file.
Be careful that you don’t try to read more parameters than you’ve been given.
You will always need to know the data type of every parameter you read.
Your C Toolbox You’ve got Chapter 7 under your belt, and now you’ve.
Function pointers let you pass functions around as if they were data.
The name of every function is a pointer to the function.
Each sort function needs a pointer to a comparator function.
Arrays of function pointers can help run different functions for different types of data.
Functions with a variable number of arguments are called “variadic.”
The toe bone’s statically linked to the foot bone, and the foot bone’s statically linked to the ankle bone…
Now it’s time to use that power for your own code.
And by the end of the chapter, you’ll be able to write code that you.
Code you can take to the bank Do you remember the encrypt() function you wrote a while back that encrypted the contents of  a string? It was in a separate source code file that could be used by several programs:
Encrypting data and checking if  data has been modified are both important for security.
Separately, the two functions are useful, but together they could form the basis of  a security library.
This function returns a number based on the contents of a string.
A security library? Hey, that’s just what I’m looking for! The security at our bank is, well…kinda sloppy.
The guy at the bank has written a test program to see how the two functions work.
He put all of the source into the same directory on his machine and then began to compile it.
He compiled the two security files into object files, and then wrote a test program:
Using a pencil, highlight which command or code made the compile fail.
Angle brackets are for standard headers If  you use angle brackets in an #include statement, the compiler won’t look for the headers in the current directory; instead, it will search for them in the standard header directories.
To get the program to compile with the local header files, you need to switch the angle brackets for simple quotes (" "):
File  Edit   Window  Help   <> stdio.h is stored in one of the standard header directories.
Calling the encrypt() function a second time returns the original string.
But what if you want to share code? Sometimes you want to write code that will be available to lots of  programs, in different folders, all over your computer.
Yeah, I gotta get security added to all these different programs.
I don’t want a separate copy of the security code for each one…
There are two sets of  files that you want to share between programs: the .h header files and the .o object files.
So, if you include headers using angle brackets, where does the compiler go searching for the header files? You’ll need to check the documentation that came with your compiler, but typically on a Unix-style system like the Mac or a Linux machine, the compiler will look for the files under these directories:
And if you’re using the MinGW version of the gcc compiler, it will normally look here:
Sharing .h header files There are a few ways of  sharing header files between different C projects:
If  you want to store your header files somewhere else, such as /my_header_files, you can add the directory name to your include statement:
The final option is to tell the compiler where it can find your header files.
You can do this with the -I option on gcc:
The -I option tells the gcc compiler that there’s another place where it can find header files.
It will still search in all the standard places, but first it will check the directory names in the -I option.
This tells the compiler to look in /my_header_files as well as the standard directories.
Share .o object files by using the full pathname / Root directory.
Now you can always put your .o object files into some sort of shared directory.
Once you’ve done that, you can then just add the full path to the object files when you’re compiling the program that uses them:
Using the full pathname to the object files means you don’t need a separate copy for each C project.
If  you compile your code with the full pathname to the object files you want to use, then all your C programs can share the same encrypt.o and checksum.o files.
Yes, if you create an archive of object files, you can tell the compiler about a whole set of object files all at once.
An archive is just a bunch of  object files wrapped up into a single file.
By creating a single archive file of  all of  your security code, you can make it a lot easier to share the code between projects.
An archive contains .o files Ever used a .zip or a .tar file? Then you know how easy it is to create a file that contains other files.
That’s exactly what a .a archive file is: a file containing other files.
Open up a terminal or a command prompt and change into one of  the library directories.
These are the directories like /usr/lib or C:\MinGW\lib that contain the library code.
In a library directory, you’ll find a whole bunch of  .a archives.
And there’s a command called nm that you can use to look inside them:
The nm command lists the names that are stored inside the archive.
The libl.a archive shown here contains two object files: libmain.o and libyywrap.o.
What these two object files are used for doesn’t really matter; the point is that you can take a whole set of object files and turn them into a single archive file that you can use with gcc.
Before you see how to compile programs using .a, let’s see how to store our encrypt.o and checksum.o files in an archive.
You might not have a libl.a on your machine, but you can try the command on any other .a file.
Create an archive with the ar command… The archive command (ar) will store a set of  object files in an archive file:
The r means the .a file will be updated if it already exists.
The c means that the archive will be created without any feedback.
The s tells ar to create an index at the start of the .a file.
This is the name of the .a file to create.
These are the files that will be stored in the archive.
The names begin with lib because they are static libraries.
If you don’t name them this way, your compiler will.
Which library directory should you store it in? It’s up to you, but you have a couple of  choices:
You can put your .a file in a standard directory like /usr/local/lib.
Some coders like to install archives into a standard directory once they are sure it’s working.
On Linux, on Mac, and in Cygwin, the /usr/local/lib directory is a good choice because that’s the directory set aside for your own local custom libraries.
If  you are still developing your code, or if  you don’t feel comfortable installing your code in a system directory, you can always create your own library directory.
On most machines, you need to be an administrator to put files in /usr/local/lib.
Finally, compile your other programs The whole point of  creating a library archive was so you could use it with other programs.
If  you’ve installed your archive in a standard directory, you can compile your code using the -l switch:
If you’re using several archives, you can set several -l options.
Remember to list your source files before your -l libraries.
Do you need a -I option? It depends on where you put your headers.
So if  your archive is called libawesome.a, you can compile your program with the -lawesome switch.
But what if  you put your archive somewhere else, like /my_lib? In that case, you will need to use the -L option to say which directories to search:
The contents of the library directories can be very different from one machine to another.
Why is that? It’s because different operating systems have different services available.
There’ll be libraries for connecting to the network, or creating GUI applications.
Try running the nm command on a few of the .a files.
A lot of the names listed in each module will match compiled functions that you can use:
The nm command will tell you the name of each .o object file and then list the names that are available within the object file.
If you see a T next to a name, that means it’s the name of a function within the object file.
So, I need to look for libhfsecurity.a starting in the /my_lib directory.
Make Magnets The security guy is having trouble compiling one of the bank programs against the new security library.
He has his source code as well as the encrypt and checksum source code in the same directory.
For now, he wants to create the libhfsecurity.a archive in the same directory and then use it to compile his own program.
Make Magnets Solution The security guy is having trouble compiling one of the bank programs against the new security library.
He has his source code, as well as the encrypt and checksum source code in the same directory.
For now, he wants to create the libhfsecurity.a archive in the same directory and then use it to compile his own program.
The compiler will need to be told where the header files are with a -I statement.
This creates the object file from the encrypt.c source file.
You can’t build the libhfsecurity.a archive until we’ve created encrypt.o and checksum.o.
You need the -L., because the archive is in the current directory.
The program’s source code needs to be listed before the library code.
Q: How do I know what the standard library directories are on my machine?
A: You need to check the documentation for your compiler.
On most Unix-style machines, the library directories include /usr/lib and /usr/local/lib.
Q: When I try to put a library archive into my /usr/lib directory, it won’t let me.
Many operating systems will prevent you from writing files to the standard directories in case you accidentally break one of the existing libraries.
Q: Is the ar format the same on all systems?
And the object code the archive contains will be completely different for different operating systems.
Q: If I’ve created a library archive, can I see what’s inside it?
Q: Are the object files in the archive linked together like an executable?
The object files are stored in the archive as distinct files.
Q: Can I put any kind of file in a library archive?
The ar command will check the file type before including it.
Q: Can I extract a single object file from an archive?
To extract the encrypt.o file from libhfsecurity.a, use ar -x libhfsecurity.a encrypt.o.
Q: Why is it called “static” linking? A: Because it can’t change once it’s been done.
When two files are linked together statically, it’s like mixing coffee with milk: you can’t separate them afterward.
Q: Should I use the HF security library to secure the data at my bank?
If you need to link to an archive called libfred.a, use -lfred.
The -L flag should appear after the source files in the gcc command.
Head First: Linker, thank you so much for making time for us today.
Head First: I’d like to begin by asking if  you ever feel overlooked by developers.
Perhaps they don’t understand exactly what it is you do?
A lot of  people don’t talk to me directly with the ld command.
Head First: That’s a lot of  options on my screen.
Linker: The compiler works out what needs to be done to join some files together and then calls me.
Head First: I hate to sound foolish, but what exactly is it you do?
I stitch pieces of  compiled code together, a bit like a telephone operator.
Linker: The old telephone operators would patch calls from one location to another so the two parties could talk.
Linker: An object file might need to call a function that’s stored in some other file.
I link together the point in one file where the function call is made to the point in another file where the function lives.
That’s the plan, anyway, but the guys need a little help.
Let’s look into the code in a little more detail.
Calculating calories The team is still working on the software, but they’ve got one of  the key modules ready.
The hfcal library will generate the main data for the LCD display.
If  the code is told the user’s weight, the virtual distance she’s traveled on the machine, and then a special coefficient, it will generate the basic LCD details on the Standard Output:
The hfcal.h header file just contains a declaration of the display_calories() function.
The team hasn’t yet written the main code for each piece of equipment.
When they do, there will be separate programs for the ellipticals, treadmills, and exercise bikes.
Until then, they’ve created a test program that will call the hfcal.c code with some example data:
This is what the display looks like for the test program.
Now that you’ve seen the source code for the test program and the hfcal library, it’s time to build the code.
The hfcal.h header is going to be stored in ./includes:
Next, you need to create an object file called elliptical.o from the elliptical.c test program:
Now, you need to create an archive library from hfcal.o and store it in ./libs:
Finally, create the elliptical executable using elliptical.o and the hfcal archive:
Now that you’ve seen the source code for the test program and the hfcal library, it’s time to build the code.
The hfcal.h header is going to be stored in ./includes:
Next, you need to create an object file called elliptical.o from the elliptical.c test program:
Now, you need to create an archive library from hfcal.o and store it in ./libs:
Finally, create the elliptical executable using elliptical.o and the hfcal archive:
The hfcal.c program needs to know where the header file is.
Again, you need to tell the compiler that the headers are in ./includes.
Now that you’ve built the elliptical program, you can run it on the console:
But things are a bit more complex… Turns out, there’s a problem.
The Head First Gyms are expanding everywhere, in different countries that use different languages and different measures.
For example, in England, the machines need to report information in kilograms and kilometers:
In the US, measurements need to be in pounds and miles.
But in England, measurements need to be in kgs and kms.
If  you think about it, you get the same kinds of  problems when you write any software.
Different machines might require different device driver code, or they might need to talk to different databases or different graphical user interfaces.
You probably won’t be able to build a version of  your code that will work on every machine, so what should you do?
If  an engineer upgrades the sensors used on a machine, she might need to upgrade the code that talks to them.
If  the displays ever change, the engineers might need to change the code that generates the output.
Programs are made out of lots of pieces… You’ve already seen that you can build programs using different pieces of  object code.
You’ve created .o files and .a archives, and you’ve linked them together into single executables.
Once you’ve created a single executable file from those separate pieces of  object code, you really have no way of changing any of  the ingredients without rebuilding the whole program.
The program is just a large chunk of  object code.
There’s no way to separate the display code from the sensor code; it’s all lost in the mix.
Wouldn’t it be dreamy if there were a way to run a program using switchable pieces of object code? But I guess that’s just a fantasy…
Dynamic linking happens at runtime The reason you can’t change the different pieces of  object code in an executable file is because, well, they are all contained in a single file.
They were statically linked together when the program was compiled.
But if  your program wasn’t just a single file—if  your program was made up of  lots of  separate files that only joined together when the program was run—you would avoid the problem.
Each of these pieces of code lives in a separate file.
The trick, then, is to find a way of  storing pieces of  object code in separate files and then dynamically linking them together only when the program runs.
You need to join these files together each time the program runs.
Can you link .a at runtime? So you need to have separate files containing separate pieces of  object code.
But you’ve already got separate files containing object code: the .o object files and the .a archive files.
Does that mean you just need to tell the computer not to link the .o files until you run the program?
Simple object files and archives don’t have quite enough information in them to be linked together at runtime.
There are other things our dynamic library files will need, like the names of  the other files they need to link to.
Dynamic libraries are object files on steroids So, dynamic libraries are similar to those .o object files you’ve been creating for a while, but they’re not quite the same.
Like an archive file, a dynamic library can be built from several .o object files, but unlike an archive, the object files are properly linked together in a dynamic library to form a single piece of  object code.
A dynamic library contains extra information that the operating system will need to link the library to other things.
At the heart of a dynamic library is a single piece of object code.
The library is built from one or more .o files.
So how do you create your own dynamic libraries? Let’s see.
Is it a bird? Is it a plane? No, it’s a relocatable object file with metadata.
First, create an object file If  you’re going to convert the hfcal.c code into a dynamic library, then you need to begin by compiling it into a .o object file, like this:
Did you spot the difference? You’re creating the hfcal.o exactly the same as before except you’re adding an extra flag: -fPIC.
Now, the truth is that on most systems you don’t need to specify this option.
Imagine you had a dynamic library that expected to find the value of some piece of global data 500 bytes away from where the library is loaded.
Bad things would happen if the operating system decided to load the library somewhere else in memory.
If you compile your code on Windows, you might find that gcc will give you a warning that the -fPIC option is not needed.
You can either remove the -fPIC flag, or ignore the warning.
What you call your dynamic library depends on your platform Dynamic libraries are available on most operating systems, and they all work in pretty much the same way.
On Windows, dynamic libraries are usually called dynamic link libraries and they have the extension .dll.
On Linux and Unix, they’re shared object files (.so), and on the Mac, they’re just called dynamic libraries (.dylib)
But even though the files have different extensions, you can create them in very similar ways:
The -shared option tells gcc that you want to convert a .o object file into a dynamic library.
When the compiler creates the dynamic library, it will store the name of  the library inside the file.
So, if  you create a library called libhfcal.so on a Linux machine, the libhfcal.so file will remember that its library name is hfcal.
Why is that important? It means that if  you compile a library with one name, you can’t just rename the file afterward.
If  you need to rename a library, recompile it with the new name.
On some older Mac systems, the -shared flag is not available.
But don’t worry, on those machines, if you just replace it with -dynamiclib, everything will work exactly the same way.
Compiling the elliptical program Once you’ve created the dynamic library, you can use it just like a static library.
Even though these are the same commands you would use if  hfcal were a static archive, the compile will work differently.
Because the library’s dynamic, the compiler won’t include the library code into the executable file.
Instead, it will insert some placeholder code that will track down the library and link to it at runtime.
Library names in MinGW and Cygwin Both MinGW and Cygwin let you use several name formats for dynamic libraries.
Test Drive You’ve created the dynamic library in the /libs directory and built the elliptical test program.
Because hfcal isn’t in one of  the standard library directories, you’ll need to make sure the computer can find the library when you run the program.
File  Edit   Window  Help   I’mLinux On Linux, you need to set the LD_LIBRARY_PATH variable so the program can find the library.
There’s no need to do this if the library is somewhere standard, like /usr/lib.
On a Mac On the Mac, you can just run the program.
On Linux, and most versions of  Unix, the compiler just records the filename of  the libhfcal.so library, without including the path name.
That means if  the library is stored outside the standard library directories (like /usr/lib), the program won’t have any way of  finding the hfcal library.
To get around this, Linux checks additional directories that are stored in the LD_LIBRARY_PATH variable.
On Windows Now let’s take a look at how to run code that’s been compiled using the Cygwin and MinGW versions of  the gcc compiler.
And just like Linux, Windows executables store the name of  the hfcal library without the name of  the directory where it’s stored.
But Windows doesn’t use a LD_LIBRARY_PATH variable to hunt the library down.
Instead, Windows programs look for the library in the current directory, and if  they don’t find it there, the programs search for it using the directories stored in the PATH variable.
Using MinGW And if  you’ve compiled the program using the MinGW compiler, you can run it from the command prompt like this:
Does this seem a little complex? It is, which is why most programs that use dynamic libraries store them in one of  the standard directories.
That means on Linux and the Mac, they are normally in directories like /usr/lib or /usr/local/lib; and in Windows, developers normally keep .DLLs stored in the same directory as the executable.
Using Cygwin If  you’re compiled the program using Cygwin, you can run the program from the bash shell like this:
The guys at the Head First Gym are about to ship a treadmill over to England.
The embedded server is running Linux, and it already has the US code installed.
The tech guys like to install libraries using these directories because it’s a little more standard.
The machine is all configured for use in the US, but things need to change.
There are lots of other files in here as well.
The system needs to be updated for use in the gym it is being shipped to in England.
That means the treadmill’s display code needs to be switched from miles and pounds to kilometers and kilograms.
The software that’s already installed on the machine needs to use this new version of the code.
Because the applications connect to this code as a dynamic library, all you need to do is compile it into the /usr/local/lib directory.
Assuming that you are already in the same directory as the hfcal_UK.c file and that you have write permissions on all the directories, what commands would you need to type to compile this new version of the library?
The guys at the Head First Gym are about to ship a treadmill over to England.
The embedded server is running Linux, and it already has the US code installed.
The tech guys like to install libraries using these directories because it’s a little more standard.
The machine is all configured for use in the US, but things need to change.
There are lots of other files in here as well.
The system needs to be updated for use in the gym it is being shipped to in England.
That means the treadmill’s display code needs to be switched from miles and pounds to kilometers and kilograms.
Because the applications connect to this code as a dynamic library, all you need to do is compile it into the /usr/local/lib directory.
Assuming that you are already in the same directory as the hfcal_UK.c file and that you have write permissions on all the directories, what commands would you need to type to compile this new version of the library?
You need to compile the source code to an object file.
Then you need to convert the object file to a shared object.
You don’t need to set a -I option, because the header file is in a standard directory.
Did you spot that the library and headers had been installed in standard directories? That meant you didn’t have to use a -I flag when you were compiling the code, and you didn’t have to set the LD_LIBRARY_PATH variable when you were running the code.
Test Drive Now that you’ve updated the library on the English treadmill, let’s try it against an American machine.
This is one of  the unaltered US treadmills using the original version of  libhfcal.so library:
The treadmill application starts when the machine boots up, so after using the machine for a while the display shows this:
When the runner has been on the treadmill for a similar distance, the display looks like this:
This version is linked the UK version of the hfcal library.
Even though the treadmill program was never recompiled, it was able to pick up the code from the new library dynamically.
Dynamic libraries make it easier to change code at runtime.
You can update an application without needing to recompile it.
If  you have several programs that share the same piece of  code, you can update them all at the same time.
Now that you know how to create dynamic libraries, you’ve become a much more powerful C developer.
The English machine has the same treadmill program installed, but on this machine you recompiled the libhfcal.so library from the source code in the hfcal_UK.c file.
Tonight’s talk: Two renowned proponents of modular software discuss the pros and cons of static and dynamic linking.
Well, I think we can both agree that creating code in smaller modules is a good idea.
I think programs should be made of  lots of  small files that link together only when the program is run.
What about the Linux kernel, hmmm? That large enough? And I believe that’s…
Static linking might not be as loose and informal, but you know what? Static programs are simple to use.
Dynamic libraries are created from one or more object files.
On some machines, you need to compile them with the -fPIC option.
Life is simpler if your dynamic libraries are stored in standard directories.
Otherwise, you might need to set PATH and LD_LIBRARY_PATH variables.
Q: Why are dynamic libraries so different on different operating systems?
A: Operating systems like to optimize the way they load dynamic libraries, so they’ve each evolved different requirements for dynamic libraries.
Q: I tried to change the name of my library by renaming the file, but the compiler couldn’t find it anymore.
A: When the compiler creates a dynamic library, it stores the name of the library inside the file.
If you rename the file, it will then have the wrong name inside the file and will get confused.
If you want to change its name, you should recompile the library.
Q: Why does Cygwin support so many different naming conventions for dynamic library files?
A: Cygwin makes it easy to compile Unix software on a Windows machine.
Because Cygwin creates a Unix-style environment, it borrows a lot of Unix conventions.
So it prefers to give libraries .a extensions, even if they’re dynamic DLLs.
But because they depend on the Cygwin system, you’ll need to do a little work before non-Cygwin code can use them.
Q: Why does the MinGW compiler support the same dynamic library name format as Cygwin?
A: Because the two projects are closely associated and share a lot of code.
The big difference is that MinGW programs can run on machines that don’t have Cygwin installed.
Q: Why doesn’t Linux just store library pathnames in executables? That way, you wouldn’t need to set LD_LIBRARY_PATH.
By not storing the pathname, it gives you a lot more control over which version of a library a program can use—which is great when you’re developing new libraries.
Static linking means you get a small, fast executable file that is easier to move from machine to machine.
Dynamic linking means that you can configure the program at runtime more.
Q: If different programs use the same dynamic library, does it get loaded more than once? Or is it shared in memory?
Some operating systems will load separate copies for each process.
Q: Are dynamic libraries the best way of configuring an application?
But if you’re going to connect to some external device, you’d normally need separate dynamic libraries to act as drivers.
Your C Toolbox You’ve got Chapter 8 under your belt, and now you’ve.
The ar command creates a library archive of object files.
L<name> adds a directory to the list of standard library directories.
This lab gives you a spec that describes a program for you to investigate and build, using the knowledge you’ve gained over the last few chapters.
This project is bigger than the ones you’ve seen so far.
So read the whole thing before you get started, and give yourself a little time.
And don’t worry if you get stuck; there are no new C concepts in here, so you can move on in the book and come back to the lab later.
It’s up to you to finish the job, but we won’t give you the code for the answer.
The spec: turn your computer into an intruder detector Imagine if  your computer could keep an eye on your house while you’re out and tell you who’s been prowling around.
Well, using its default webcam and the cleverness of  OpenCV, it can!
The intruder detector Your computer will constantly survey its surroundings using its webcam.
When it detects movement, it will write the current webcam image to a file.
And if  you store this file on a network drive or use a file synchronization service such as Dropbox, you’ll have instant evidence of  any intruders.
Aha, an intruder making off with the coffee supplies! I must record this…
It allows you to take input from your computer camera, process it, and analyze real-time image data and make decisions based on what your computer sees.
What’s more, you can do all of  this using C code.
The install guide is here, and includes links to the latest stable releases:
Once you’ve installed OpenCV, you should see a folder on your computer labeled samples.
There are also links to tutorials on the OpenCV wiki.
You’ll need to investigate OpenCV in order to complete this lab.
If  you want to get deep into OpenCV, we recommend the book Learning OpenCV by Gary Bradski and Adrian Kaehler (O’Reilly)
What your code should do Your C code should do the following.
Take input from your computer camera You need to work with real-time data that comes in from your computer camera, so the first thing you need to do is capture that data.
This pointer is your hotline to the webcam device, and you’ll use it to grab images.
Remember to check for errors in case your computer can’t find a camera.
Grab an image from the webcam You can read the latest image from the webcam using the cvQueryFrame() function.
The cvQueryFrame() function returns a pointer to the latest image, so your code will probably start with something a little like this:
If  you decide that there’s a thief  in the image, you can save the image to a file with:
If you read an image, you’ll need to process it here.
The name of the image file The image you read.
Detect an intruder Now you come to the really clever part of  the code.
How do you decide if  there’s an intruder in the frame?
One way is to check for movement in the image.
An optical flow compares two images and tells you how much movement there’s been at each pixel.
From that, you’ll need to write some code that measures the amount of  movement between the two frames.
If  the movement’s above a threshold level, you’ll know that something large is moving in front of  the webcam.
Make a clean getaway When you start the program, you don’t want the camera to record you walking away, so you might want to add a delay to give you time to leave the room.
Optional: show the current webcam output During our tests here at the lab, we found it useful to check on the current images the program is seeing.
To do this, we opened a window and displayed the current webcam output.
Maybe if I move reeeaaaally slooooowly, it won’t spot me…
To display the current image in the window, use this:
The finished product You’ll know your OpenCV project is complete when your computer is able to automatically take pictures of  people trying to sneak up on it.
Why stop there? We’re sure you have all kinds of exciting ideas for what you could do with OpenCV.
Drop us a line at Head First Labs and let us know how OpenCV is working out for you.
It’s time to become a C ninja… The final part of  the book covers advanced topics.
As you’re going to be digging into some of  the more advanced functions in C, you’ll need to make sure that you have all of  these features available on your computer.
If  you’re using Linux or Mac, you’ll be fine, but if  you’re using Windows, you need to have Cygwin installed.
Once you’re ready, turn the page and enter the gate…
Since you taught me how to make system calls, I haven’t looked back.
You’ve already seen that you can build complex applications by connecting small tools.
But what if you want to use other programs from inside.
That will give your programs access to email, the Web, and any other.
By the end of the chapter, you’ll have the power to go beyond C.
System calls are your hotline to the OS C programs rely on the operating system for pretty much everything.
They make system calls if  they want to talk to the hardware.
System calls are just functions that live inside the operating system’s kernel.
Most of  the code in the C Standard Library depends on them.
Whenever you call printf() to display something on the command line, somewhere at the back of  things, a system call will be made to the operating system to send the string of  text to the screen.
I want to display this on the command line, then play.
The system() function is an easy way of  running other programs from your code—particularly if  you’re creating a quick prototype and you’d sooner call external programs rather than write lots and lots of  C code.
This will print out the contents of the D: drive.
Code Magnets This is a program that writes timestamped text to the end of a logfile.
It would have been perfectly possible to write this entire program in C, but the programmer has used a call to system() as a quick way of dealing with the file handling.
See if you can complete the code that creates the operating system command string that displays the text comment, followed by the timestamp.
This function returns a string containing the current date and time.
Code Magnets Solution This is a program that writes timestamped text to the end of a logfile.
It would have been perfectly possible to write this entire program in C, but the programmer has used a call to system() as a quick way of dealing with the file handling.
You were to complete the code that creates the operating system command string that displays the text comment, followed by the timestamp.
It needs to store the text in the comment array.
The data will come from the Standard Input: the keyboard.
The formatted string will be stored in the cmd array.
Test Drive Let’s compile the program and then watch it in action:
Q: Does the system() function get compiled into my program?
The system() function—like all system callsdoesn’t live in your program.
Q: So, when I make a system call, I’m making a call to some external piece of code, like a library?
On some operating systems, the code for a system call lives inside the kernel of the operating system.
On other operating systems, it might simply be stored in some dynamic library.
Now, when you look in the same directory as the program, there’s a new file that’s been created called reports.log:
It read a comment from the command line and called the echo command to add the comment to the end of  the file.
Even though you could have written the whole program in C, by using system(), you simplified the program and got it working with very little work.
It’s quick and easy to use, but it’s also kinda sloppy.
Before getting into the problems with system(), let’s see what it takes to break the program.
The code worked by stitching together a string containing a command, like this:
By injecting some command-line code into the text, you can make the program run whatever code you like:
The user can use the program to run any command she likes on the computer.
Is this a big problem? If  a user can run guard_log, she can just as easily run some other program.
But what if  your code has been called from a web server? Or if  it’s processing data from a file?
Security’s not the only problem This example injects a piece of  code to list the contents of  the root directory, but it could have deleted files or launched a virus.
What if the comments contain apostrophes? That might break the quotes in the command.
What if the PATH variable causes the system() function to call the wrong program?
What if the program we’re calling needs to have a specific set of environment variables set up first?
The system() function is easy to use, but most of  the time, you’re going to need something more structured—some way of  calling a specific program, with a set of  command-line arguments and maybe even some environment variables.
What’s the kernel? On most machines, system calls are functions that live inside the kernel of the operating system.
But what is the kernel? You never actually see the kernel on the screen, but it’s always there, controlling your computer.
The kernel is the most important program on your computer, and it’s in charge of three things:
Processes No program can run on the system without the kernel loading it into memory.
The kernel creates processes and makes sure they get the resources they need.
The kernel also watches for processes that become too greedy or crash.
Memory Your machine has a limited supply of memory, so the kernel has to carefully ration the amount of memory each process can take.
The kernel can increase the virtual memory size by quietly loading and unloading sections of memory to disk.
Hardware The kernel uses device drivers to talk to the equipment that’s plugged into the computer.
Your program can use the keyboard and the screen and the graphics processor without knowing too much about them, because the kernel talks to them on your behalf.
System calls are the functions that your program uses to talk to the kernel.
The exec() functions give you more control When you call the system() function, the operating system has to interpret the command string and decide which programs to run and how to run them.
And that’s where the problem is: the operating system needs to interpret the string, and you’ve already seen how easy it is to get that wrong.
So, the solution is to remove the ambiguity and tell the operating system precisely which program you want to run.
If  you type taskmgr on Windows or ps -ef on most other machines, you’ll see the processes running on your system.
The operating system tracks each process with a number called the process identifier (PID)
The exec() functions replace the current process by running some other program.
You can say which commandline arguments or environment variables to use, and when the new program starts it will have exactly the same PID as the old one.
It’s like a relay race, where your program hands over its process to the new program.
There are many exec() functions Over time, programmers have created several different versions of  exec()
Each version has a slightly different name and its own set of  parameters.
Even though there are lots of  versions, there are really just two groups of  exec() functions: the list functions and the array functions.
The list functions: execl(), execlp(), execle() The list functions accept command-line arguments as a list of parameters, like this:
This might be the full pathname of  the program—execl()/ execle()—or just a command name to search for—execlp()but the first parameter tells the exec() function what program it will run.
You need to list one by one the command-line arguments you want to use.
Remember: the first command-line argument is always the name of  the program.
That means the first two parameters passed to a list version of  exec() should always be the same string.
This tells the function that there are no more arguments.
If  you call an exec() function whose name ends with ...e(), you can also pass an array of  environment variables.
If you pass two arguments “I like” and “turtles,” MinGW programs might send three arguments: “I,” “like,” and.
The second parameter should be the same as the first.
These are the arguments.execLP = a LIST of arguments + search on the PATH.
The only difference between these two functions is that execvp will search for the program using the PATH variable.
How to remember the exec() functions You can figure out which exec() function you need by constructing the name.
Each exec() function can be followed by one or two characters that must be l, v, p, or e.
The characters tell you which feature you want to use.
The l and v characters always come before p and e, and the p and e characters are optional.
If  you already have your command-line arguments stored in an array, you might find these two versions easier to use:
These are the values you see when you type set or env on the command line, and they usually tell the process useful information, such as the location of  the home directory or where to find the commands.
You can see getenv() being used in the diner_info program on the right.
If  you want to run a program using command-line arguments and environment variables, you can do it like this:
The execle() function will set the command-line arguments and environment variables and then replace the current process with diner_info.
But what if there’s a problem? If  there’s a problem calling the program, the existing process will keep running.
That’s useful, because it means that if  you can’t start that second process, you’ll be able to recover from the error and give the user more information on what went wrong.
And luckily, the C Standard Library provides some built-in code to help you with that.
If you’re passing an environment on Cygwin, be sure to.
On Cygwin, the PATH variable is needed when programs are loaded.
So, if you’re passing environment variables on Cygwin, be sure to include PATH=/usr/bin.
You can create a set of environment variables as an array of string pointers.
Most system calls go wrong in the same way Because system calls depend on something outside your program, they might go wrong in some way that you can’t control.
To deal with this problem, most system calls go wrong in the same way.
It’s really easy to see when an exec() call goes wrong.
If  an exec() call is successful, the current program stops running.
So, if  the program runs anything after the call to exec(), there must have been a problem:
If execle() worked, this line of code would never run.
But just telling if a system call worked is not enough.
You normally want to know why a system call failed.
That’s why most system calls follow the golden rules of  failure.
The errno variable is a global variable that’s defined in errno.h, along with a whole bunch of  standard error values, like:
Now you could check the value of  errno against each of these values, or you could look up a standard piece of  error text using a function in string.h called strerror():
So, if  the system can’t find the program you are running and it sets the errno variable to ENOENT, the above code will display this message:
EMULLET=81   Bad haircut This value is not available on all systems.
Different machines have different commands to tell you about their network configuration.
On Linux and Mac machines, there’s the /sbin/ifconfig program, and on Windows there’s a command called ipconfig that’s stored somewhere on the command path.
This program tries to run the /sbin/ifconfig program and, if that fails, it will try the ipconfig command.
This will need to run the ipconfig command and check if it fails.
Different machines have different commands to tell you about their network configuration.
On Linux and Mac machines, there’s the /sbin/ifconfig program, and on Windows there’s a command called ipconfig that’s stored somewhere on the command path.
This program tries to run the /sbin/ifconfig program and, if that fails, it will try the ipconfig command.
Use execl() because you have the path to the program file.
If execl() returns -1, it failed, so we should probably look for ipconfig.
Checking for the value -1 in case the command failed.
Q: Isn’t system() just easier to use than exec()? A: Yes.
But because the operating system needs to interpret the string you pass to system(), it can be a bit buggy.
Q: Why are there so many exec() functions? A: Over time, people wanted to create processes in different ways.
The different versions of exec() were created for more flexibility.
Q: Do I always have to check the return value of a system call? Doesn’t it make the program really long?
A: If you make system calls and don’t check for errors, your code will be shorter.
It is better to think about errors when you first write code.
It will make it much easier to catch bugs later on.
Q: If I call an exec() function, can I do anything afterward?
If the exec() function is successful, it will change the process so that it runs the new program instead of your program.
That means the program containing the exec() call will stop as soon as it runs the exec() function.
System calls are functions that live in the operating system.
When you make a system call, you are calling code outside your program.
The exec() system calls let you run programs with more control.
System calls usually, but not always, return –1 if there’s a problem.
They will also set the errno variable to an error number.
The guys over at Starbuzz have come up with a new order-generation program that they call coffee:
Can you match up these code fragments to the output they produce?
Candidates: Possible output: Match each candidate with one of the possible outputs.
The guys over at Starbuzz have come up with a new order-generation program that they call coffee:
Can you match up these code fragments to the output they produce?
Read the news with RSS RSS feeds are a common way for websites to publish their latest news stories.
Each RSS feed is just an XML file containing a summary of  stories and links.
Of  course, it’s possible to write a C program that will read RSS files straight off  the Web, but it involves a few programming ideas that you haven’t seen yet.
But that’s not a problem if  you can find another program that will handle the RSS processing for you.
Once you have Python and rssgossip.py, you can search for stories like this:
Also, if you don’t have Python installed, you can get it here: http://www.python.org/
Why not write a program that can search a lot of RSS feeds all at once! Can you do that?
You need to create an environment variable containing the address of an RSS feed.
The editor wants a program on his machine that can search a lot of RSS feeds all at the same time.
You could do that if you ran the rssgossip.py several times for different RSS feeds.
Fortunately, the out-of-work actors have made a start on the program for you.
Trouble is, they’re having problems creating the call to exec() the rssgossip.py script.
Think carefully about what you need to do to run the script, and then complete the newshound code.
To save space, this listing doesn’t show the #include lines.
These are RSS feeds the editor wants (you might want to choose your own)
You need to insert the other parameters to the function here.
The editor wants a program on his machine that can search a lot of RSS feeds all at the same time.
You could do that if you ran the rssgossip.py several times for different RSS feeds.
Fortunately, the out-of-work actors have made a start on the program for you.
Trouble is, they’re having problems creating the call to exec() the rssgossip.py script.
You were to think carefully about what you need to do to run the script, and then complete the newshound code.
You’re using a LIST of args and an ENVIRONMENT, so it’s execLE.
But what will the program do when you run it?
Test Drive When you compile and run the program, it looks like it works:
The newshound program has the rssgossip.py script using data from the array of  RSS feeds.
Worked!? Worked?!? It didn’t work! What about the announcement of the surprise concert? That was on every other news site! I coulda sent my photographers down there.
As it is, I was beaten to the story by everyone else in town!
Although the newshound program managed to run the rssgossip.py script, it looks like it didn’t manage to run the script for all of  the feeds.
In fact, the only news it displayed came from the first feed on the list.
That meant the other news stories matching the search terms were missed.
Look at the code of the newshound program again and think about how it works.
Why do you think it failed to run the rssgossip.py script for any of the other newsfeeds?
The brand-new copy will be running the same program, on the same line number.
It will have exactly the same variables that contain exactly the same values.
The only difference is that the copy process will have a different process identifier from the original.
The original process is called the parent process, and the newly created copy is called the child process.
But how can cloning the current process fix the problems with exec()? Let’s see.
The exec() functions replace the current function by running a new program.
But what happens to the original program? It terminates, and it terminates immediately.
That’s why the program only ran the rssgossip.py script for the first newsfeed.
After it had called execle() the first time, the newshound program terminated.
Once the newshound program hands over the process to the rssgossip.py program, newshound quits.
But if  you want to start another process and keep your original process running, how do you do it?
Unlike Linux and the Mac, Windows doesn’t support fork() natively.
To use fork() on a Windows machine, you should first install Cygwin.
Running a child process with fork() + exec() The trick is to only call an exec() function on a child process.
That way, your original parent process will be able to continue running.
Begin by making a copy of  your current process by calling the fork() system call.
The processes need some way of  telling which of  them is the parent process and which is the child, so the fork() function returns 0 to the child process, and it will return a nonzero value to the parent process.
If you’re the child process, call exec() At this point, you have two identical processes running, both of  them using identical code.
But the child process (the one that received a 0 from the fork() call) now needs to replace itself  by calling exec():
Now you have two separate processes: the child process is running the rssgossip.py script, and the original parent process is free to continue doing something else.
The code needs to run the rssgossip.py script in a separate process for each of the RSS feeds.
The code is reduced, so you only have to worry about the main loop.
Be careful to check for errors, and don’t get the parent and child processes mixed!
The parent process will receive the process identifier of the child process.
But what is pid_t? Different operating systems use different kinds of integers to store process IDs: some might use shorts and some might use ints.
So pid_t is always set to the type that the operating system uses.
Code Magnets Solution It’s time to update the newshound program.
The code needs to run the rssgossip.py script in a separate process for each of the RSS feeds.
The code is reduced, so you only had to worry about the main loop.
Be careful to check for errors, and don’t get the parent and child processes mixed!
If fork() returned -1, there was a problem cloning the process.
If fork() returned a 0, the code is running in the child process.
If you get here, you’re the child process, so we should exec() the script.
Test Drive Now, if  you compile and run the code, this happens:
Hey! That’s great! I’ll send my photographers down to the premiere.
By fork-ing a copy of  itself  and then exec-ing the Python script in a separate process, the newshound program is able to run a separate process for each of  the RSS feeds.
And the great thing is that these processes will all run at the same time.
It runs separate processes for each of the three newsfeeds.
That’s a lot faster than reading the newsfeeds one at a time.
By learning how to create and run separate processes with fork() and exec(), not only can you make the most of  your existing software, but you can also improve the performance of  your code.
But system() gives you less control over exactly how the program runs.
Q: Isn’t fork-ing processes really inefficient? I mean, it copies an entire process, and then a moment later we replace the child process by doing an exec()?
A: Operating systems use lots of tricks to make fork-ing processes really quick.
For example, the operating system cheats and avoids making an actual copy of the parent process’s data.
Instead, the child and parent processes share the same data.
Q: But what if one of the processes changes some data in memory? Won’t that screw things up?
A: It would, but the operating system will catch that a piece of memory is going to change, and then it will make a separate copy of that piece of memory for the child process.
A: Yes; it’s called “copy-on-write.” Q: Is a pid_t just an int? A: It depends on the platform.
The only thing you know is that it will be some integer type.
Q: I stored the result of a fork() call in an int, and it worked just fine.
A: It’s best to always use pid_t to store process IDs.
If you don’t, you might cause problems with other system calls or if your code is compiled on another machine.
A: Windows manages processes very differently from other operating systems, and the kinds of tricks fork() needs to do in order to work efficiently are very hard to do on Windows.
This may be why there isn’t a version of fork() built in.
Q: But Cygwin lets me do fork()s on Windows, right?
The gurus who work on Cygwin did a lot of work to make Windows processes look like processes that are used on Unix, Linux, and the Mac.
But because they still need to rely on Windows to create the underlying processes, fork() on Cygwin can be a little slower than fork() on other platforms.
Q: So, if I’m just interested in writing code to work on Windows, is there something else I should use instead?
There’s a function called CreateProcess() that’s like an enhanced version of system()
To find out more, go to http://msdn.microsoft.com and search for “CreateProcess.”
Q: Won’t the output of the various feeds get mixed up?
A: The operating system will make sure that each string is printed completely.
Failed system calls set the errno variable to the error number.
Your C Toolbox You’ve got Chapter 9 under your belt, and now you’ve.
What if you want to control the process once it’s running? What if you want to send it.
We’ll show you how to multiply the power of your code by letting it talk.
Redirecting input and output When you run programs from the command line, you can redirect the Standard Output to a file using the > operator:
The Standard Output is one of  the three default data streams.
A data stream is exactly what it sounds like: a stream of  data that goes into, or comes out of, a process.
There are data streams for the Standard Input, Output, and Error, and there are also data streams for other things, like files or network connections.
When you redirect the output of  a process, you change where the data is sent.
So, instead of  the Standard Output sending data to the screen, you can make it send the data to a file.
Redirection is really useful on the command line, but is there a way of  making a process redirect itself?
The descriptor table has one column for each of  the file descriptor numbers.
Even though these are called file descriptors, they might not be connected to an actual file on the hard disk.
Against every file descriptor, the table records the associated data stream.
That data stream might be a connection to the keyboard or screen, a file pointer, or a connection to the network.
The first three slots in the table are always the same.
The other slots in the table are either empty or connected to data streams that the process has opened.
For example, every time your code opens a file for reading or writing, another slot is filled in the descriptor table.
When the process is created, the Standard Input is connected to the keyboard, and the Standard Output and Error are connected to the screen.
And they will stay connected that way until something redirects them somewhere else.
Every process will contain the program it’s running, as well as space for stack and heap data.
But it will also need somewhere to record where data streams like the Standard Output are connected.
Each data stream is represented by a file descriptor, which, under the surface, is just a number.
The process keeps everything straight by storing the file descriptors and their data streams in a descriptor table.
A file descriptor is a number that represents a data stream.
Redirection just replaces data streams The Standard Input, Output, and Error are always fixed in the same places in the descriptor table.
That means if  you want to redirect the Standard Output, you just need to switch the data stream against descriptor 1 in the table.
All of  the functions, like printf(), that send data to the Standard Output will first look in the descriptor table to see where descriptor 1 is pointing.
They will then write data out to the correct data stream.
But processes can do their own redirection by rewiring the descriptor table.
Now you can see why the Standard Error is redirected with 2>
The 2 refers to the number of the Standard Error in the descriptor table.
On most operating systems, you can use 1> as an alternative way of redirecting the Standard Output, and on Unix-based systems you can even redirect the Standard Error to the same place as the Standard Output like this:
Let’s say you open a file with something like this:
The operating system will open the guitar.mp3 file and return a pointer to it, but it will also skim through the descriptor table until it finds an empty slot and register the new file there.
But once you’ve got a file pointer, how do you find it in the descriptor table? The answer is by calling the fileno() function.
As long as you pass fileno() the pointer to an open file, it should always return the descriptor number.
There’s still just one guitar.mp3 file, and there’s still just one data stream connected to it.
Now that you know how to find and change things in the descriptor table, you should be able to redirect the Standard Output of a process to point to a file.
Does your error code worry you? Do you find that you’re writing duplicate error-handling code.
Duplicated code can be the cause of unwarranted coding stress.
Is there some way of removing the duplicated code block? Why, yes, th ere is! By creating a.
What’s that, you say? How do you handle that troublesome return stat ement? After all, you.
There’s no need! The exit() system call is the fastest way to stop your p rogram in its tracks.
First, remove all of your error code into a separat e function called.
Now you can replace that troublesome error-checking code with somet hing much simpler:
Warning: offer limited to one exit() call per program execution.
To ensure you have the exit system call available, you need to include stdlib.h.
This is a program that saves the output of the rssgossip.py script into a file called stories.txt.
It’s similar to the newshound program, except it searches through a single RSS feed only.
Using what you’ve learned about the descriptor table, see if you can find the missing line of code that will redirect the Standard Output of the child process to the stories.txt file.
The #includes and the error() function have been removed to save space.
If we can’t write to stories.txt, then f will be zero.
We’ll report errors using the error() function we wrote earlier.
This is a program that saves the output of the rssgossip.py script into a file called stories.txt.
It’s similar to the newshound program, except it searches through a single RSS feed only.
Using what you’ve learned about the descriptor table, you were to find the missing line of code that will redirect the Standard Output of the child process to the stories.txt file.
This code changes the child process because the pid is zero.
Did you get the right answer? The program will change the descriptor table in the child script to look like this:
That means that when the rssgossip.py script sends data to the Standard Output, it should appear in the stories.txt file.
Test Drive This is what happens when the program is compiled and run:
If you’re on a Windows machine, you’ll need to be running Cygwin.
What happened? When the program opened the stories.txt file with fopen(), the operating system registered the file f in the descriptor table.
I think there might be a problem with the program.
See, I just tried the same thing, but on my machine the file was empty.
Assuming you’re searching for stories that exist on the feed, why was stories.txt empty after the program finished?
But once that child process gets created, it’s independent of  its parent.
You could run the newshound2 program and still have an empty stories.txt, just because the rssgossip.py isn’t finished yet.
That means the operating system has to give you some way of  waiting for the child process to complete.
The waitpid() function The waitpid() function won’t return until the child process dies.
That means you can add a little code to your program so that it won’t exit until the rssgossip.py script has stopped running:
This new code goes at the end of the newshound2 program.
This variable is used to store information about the process.
If  you set the options to 0, the function waits until the process finishes.
What’s the status? When the waitpid() function has finished waiting, it stores a value in pid_status that tells you how the process did.
To find the exit status of  the child process, you’ll have to pass the pid_status value through a macro called WEXITSTATUS():
The macro tells you the value of  just those 8 bits.
The stories.txt file now contains the stories as soon as newshound2 is run.
Adding a waitpid() to the program was easy to do and it made the program more reliable.
Before, you couldn’t be sure that the subprocess had finished writing, and that meant there was no way you could use the newshound2 program as a proper tool.
You couldn’t use it in scripts and you couldn’t create a GUI frontend for it.
Redirecting input and output, and making processes wait for each other, are all simple forms of  interprocess communication.
When processes are able to cooperateby sharing data or by waiting for each other—they become much more powerful.
You can redirect input and output by changing the descriptor table.
Q: Does exit() end the program faster than just returning from main()?
But if you call exit(), you don’t need to structure your code to get back to the main() function.
As soon as you call exit(), your program is dead.
Q: Should I check for –1 when I call exit(), in case it doesn’t work?
Q: Is the number I pass to exit() the exit status?
Q: So, if I open a new file, it is automatically added to the descriptor table?
Q: Is there a rule about which slot it gets?
A: New files are always added to the available slot with the lowest number.
So, if slot number 4 is the first available one, that’s the one your new file will use.
A: Because it allows you to rewire the way a program works.
Q: Is there a way of sending data to the screen without using the Standard Output?
For example, on Unix-based machines, if you open /dev/tty, it will send data directly to the terminal.
Q: Can I use waitpid() to wait for any process? Or just the processes I started?
A: You can use waitpid() to wait for any process.
Q: Such as? A: For example, WIFSIGNALED (pid_status) will be false if a process ended naturally, or true if something killed it off.
Q: How can an integer variable like pid_status contain several pieces of information?
It’s easier to read and it will work on whatever the native int size is on the platform.
A: Because it is a macro rather than a function.
The compiler replaces macro statements with small pieces of code at runtime.
Stay in touch with your child You’ve seen how to run a separate process using exec() and fork(), and you know how to redirect the output of  a child process into a file.
But what if  you want to listen to a child process directly? Is that possible? Rather than waiting for a child process to send all of  its data into a file and then reading the file afterward, is there some way to start a process running and read the data it generates in real time?
Reading story links from rssgossip As an example, there’s an option on the rssgossip.py script that allows you to display the URLs for any stories that it finds:
Now, you could run the script and save its output to a file, but that would be slow.
It would be much better if  the parent and child process could talk to each other while the child process is still running.
Since I created you, you never write, you never phone…
Connect your processes with pipes grep filters the output of the script.
Pipes are used on the command line to connect the output of one process with the input of  another process.
In the example here, you’re running the rssgossip.py script manually and then passing its output through a command called grep.
Piped commands are parents and children Whenever you pipe commands together on the command line, you are actually connecting them together as parent and child processes.
So, in the above example, the grep command is the parent of  the rssgossip.py script.
Pipes are used a lot on the command line to allow users to connect processes together.
But what if  you’re just using C code? How do you connect a pipe to your child process so that you can read its output as soon as it’s generated?
You’ve already used something that makes live connections between processes: pipes.
The parent process forks the rssgossip.py script in a child process.
The parent connects the output of the child with the input of the parent using a pipe.
I want a program that opens stories in my browser as soon as they’re found.
Let’s say you want to run the rssgossip.py script and then open the stories it finds in a web browser.
Your program will run in the parent process and rssgossip.py will run in the child.
You need to create a pipe that connects the output of rssgossip.py to the input of  your program.
Remember how we said that every time you open a data stream to something like a file, it gets added to the descriptor table? Well, that’s exactly what the pipe() functions does: it creates two connected streams and adds them to the table.
Whatever is written into one stream can be read from the other.
Once you’ve got the descriptors, you’ll need to use them in the parent and child processes.
When pipe() creates the two lines in the descriptor table, it will store their file descriptors in a two-element array:
You pass the name of the array to the pipe() function.
This will close the read end of the pipe.The child won’t read from the pipe.
That means that everything the child sends to the Standard Output will be written to the pipe.
Everything that the child writes to the pipe will be read through the Standard Input of  the parent process.
The child then connects the write end to the Standard Output.
The parent connects the read end to the Standard Output.
Opening a web page in a browser Your program will need to open up a web page using the machine’s browser.
That’s kind of  hard to do, because different operating systems have different ways of  talking to programs like web browsers.
Fortunately, the out-of-work actors have hacked together some code that will open web pages on most systems.
It looks like they were in a rush to go do something else, so they’ve put together something pretty simple using system():
The code runs three separate commands to open a URL: that’s one command each for the Mac, Windows, and Linux.
Two of  the commands will always fail, but as long as the third command works, that’ll be fine.
Think you can write better code than the out-of-work actors? Then why not rewrite the code to use fork() and exec() for your favorite operating system?
It looks like most of the program is already written.
All you need to do is complete the code that connects the parent and child processes to a pipe.
Remember, in this program the child is going to talk to the parent, so make sure that pipe’s connected the right way!
You might want to replace this with another RSS newsfeed.
Are you parent or child? What code goes in these lines?
What needs to go here? What will you read from?If the line starts with a tab…
It looks like most of the program is already written.
You were to complete the code that connects the parent and child processes to a pipe.
Need to check that return code, in case we can’t create the pipe.
You’re reading from the Standard Input, because that’s connected to the pipe.
This will set the Standard Output to the write end of the pipe.
The child won’t read from the pipe, so we’ll close the read end.
This will redirect the Standard Input to the read end of the pipe.
This will close the write end of the pipe, because the parent won’t write to it.
Test Drive When you compile and run the code, this happens:
The program opens all the news stories it can find in the browser.
The news_opener program ran the rssgossip.py in a separate process and told it to display URLs for each story it found.
All of  the output of  the screen was redirected through a pipe that was connected to the news_opener parent process.
That meant the news_opener process could search for any URLs and then open them in the browser.
Now, you have the ability to not only run processes and control their environments, but you also have a way of capturing their output.
That opens up a huge amount of functionality to you.
Your C code can now use and control any program that you can use from the command line.
Now that you know how to control rssgossip.py, why not try controlling some of these programs? You can get all of them for Unix-style machines or any Windows machine using Cygwin:
If you call them from C code, you can write programs that can talk to the Web.
If they’re on your machine, it means your C programs can send mail too.
Why not create a C program that outputs SVG charts in text format, and then use the convert command to create PNG images from them?
Q: Is a pipe a file? A: It’s up to the operating system how it creates pipes, but pipes created with the pipe() function are not normally files.
Q: Why would anyone want a pipe that uses a file?
That means they are useful if two processes need to talk to each other and they are not parent and child processes.
As long as both processes know the name of the pipe, they can talk with it.
Q: If most pipes are not files, what are they?
Data is written at one point and read at another.
Q: What happens if I try to read from a pipe and there’s nothing in there?
Q: How does the parent know when the child is finished?
A: When the child process dies, the pipe is closed and the fgets() command receives an end-of-file, which means the fgets() function returns 0, and the loop ends.
There is no reason why you can’t connect your pipes the other way around, so that the parent sends data to the child process.
Q: Can you have a pipe that works in both directions at once? That way, my parent and child processes could have a two-way conversation.
But you can create two pipes: one from the parent to the child, and one from the child to the parent.
The descriptors are for the read and write ends of the pipe.
You can redirect Standard Input and Output to the pipe.
The parent and child processes use different ends of the pipe.
The death of a process You’ve seen how processes are created, how their environments are configured, and even how processes talk to each other.
But what about how processes die? For example, if  your program is reading data from the keyboard and the user hits Ctrl-C, the program stops running.
How does that happen? You can tell from the output that the program never got as far as running the second printf(), so the Ctrl-C didn’t just stop the fgets() command.
Did the operating system just unload the program? Did the fgets() function call exit()? What happened?
The O/S controls your program with signals The magic all happens in the operating system.
When you call the fgets() function, the operating system reads the data from the keyboard, and when it sees the user hit Ctrl-C, sends an interrupt signal to the program.
A signal is just a short message: a single integer value.
When the signal arrives, the process has to stop whatever it’s doing and go deal with the signal.
The process looks at a table of signal mappings that link each signal with a function called the signal handler.
The default signal handler for the interrupt signal just calls the exit() function.
So, why doesn’t the operating system just kill the program? Because the signal table lets you run your own code when your process receives a signal.
The process runs its default interrupt handler and calls exit()
Catching signals and running your own code Sometimes you’ll want to run your own code if  someone interrupts your program.
For example, if  your process has files or network connections open, it might want to close things down and tidy up before exiting.
But how do you tell the computer to run your code when it sends you a signal? You can do it with sigactions.
A sigaction is a function wrapper A sigaction is a struct that contains a pointer to a function.
So, if  you have a function called diediedie() that you want the operating system to call if  someone sends an interrupt signal to your process, you’ll need to wrap the diediedie() function up as a sigaction.
The function wrapped by a sigaction is called the handler, because it will be used to deal with (or handle) a signal that’s sent to it.
If  you want to create a handler, it will need to be written in a certain way.
All handlers take signal arguments Signals are just integer values, and if  you create a custom handler function, it will need to accept an int argument, like this:
Because the handler is passed the number of  the signal, you can reuse the same handler for several signals.
Or, you can have a separate handler for each signal.
How you choose to program it is up to you.
Handlers are intended to be short, fast pieces of  code.
They should do just enough to deal with the signal that’s been received.
Be careful when writing to Standard Output and Error in handler functions.
Even though the example code you’ll use will display text on the Standard Output, be careful about doing that in more complex programs.
Signals can arrive because something bad has happened to the program.
That might mean that Standard Output isn’t available, so be careful.
This is the name of the function you want the computer to call.
The mask is a way of filtering the signals that the sigaction will handle.
You’ll usually want to use an empty mask, like here.
The function that the sigaction wraps is called a handler.
The integer value of  the signal you want to handle.
Usually, you’ll pass one of  the standard signal symbols, like SIGINT or SIGQUIT.
This is the address of  the new sigaction you want to register.
If  you pass a pointer to another sigaction, it will be filled with details of  the current handler that you’re about to replace.
If  you don’t care about the existing signal handler, you can set this to NULL.
You’ll find out more about the standard signals in a while.
The sigaction() function will return –1 if  it fails and will also set the errno function.
To keep the code short, some of  the code you’ll see in this book will skip checking for errors, but you should always check for errors in your own code.
This is a function that will make it a little easier to register functions as signal handlers:
This function will allow you to set a signal handler by calling catch_signal() with a signal number and a function name:
Set the action’s handler to the handler function that was passed in.Use an empty mask.
Return the value of sigaction(), so you can check for errors.
Rewriting the code to use a signal handler You now have all the code to make your program do something if someone hits the Ctrl-C key:
The program will ask for the user’s name and then wait for her to type.
But if  instead of  typing her name, the user just hits the Ctrl-C key, the operating system will automatically send the process an interrupt signal (SIGINT)
That interrupt signal will be handled by the sigaction that was registered in the catch_signal() function.
This will then be called, and the program will display a message and exit()
The operating system received the Ctrl-C and sent a SIGINT signal to the process, which then ran your handle_interrupt() function.
When you run the new version of  the program and press Ctrl-C, this happens:
There are a bunch of  different signals the operating system can send to your process.
Someone asked the process to stop and dump the memory in a core dump file.
There are a bunch of  different signals the operating system can send to your process.
Someone asked the process to stop and dump the memory in a core dump file.
Q: If the interrupt handler didn’t call exit(), would the program still have ended?
Q: So, I could write a program that completely ignores interrupts?
In general, if your program receives an error signal, it’s best to exit with an error, even if you run some of your own code first.
Use kill to send signals If  you’ve written some signal-handling code, how do you test it? Fortunately, on Unix-style systems, there’s a command called kill.
It’s called kill because it’s normally used to kill off  processes, but in fact, kill just sends a signal to a process.
By default, the command sends a SIGTERM signal to the process, but you can use it to send any signal you like.
Then, in the second terminal, you can send signals to your program with the kill command:
Each of  these kill commands will send signals to the process and run whatever handler the process has configured.
The SIGKILL signal can’t be caught by code, and it can’t be ignored.
That means if  you have a bug in your code and it is ignoring every signal, you can always stop the process with kill -KILL.
Send signals with raise() Sometimes you might want a process to send a signal to itself, which you can do with the raise() command.
Normally, the raise() command is used inside your own custom signal handlers.
It means your code can receive a signal for something minor and then choose to raise a more serious signal.
This is the program we want to send signals to.
Sending your code a wake-up call The operating system sends signals to a process when something has happened that the process needs to know about.
It might be that the user has tried to interrupt the process, or someone has tried to kill it, or even that the process has tried to do something it shouldn’t have, like trying to access a restricted piece of  memory.
But signals are not just used when things go wrong.
Sometimes a process might actually want to generate its own signals.
The alarm signal is usually created by the process’s interval timer.
The interval timer is like an alarm clock: you set it for some time in the future, and in the meantime your program can go and do something else:
But even though your program is busy doing other things, the timer is still running in the background.
But what does a process do with an alarm signal by default? It stops the process.
It’s really unlikely that you would ever want a timer to kill your program for you, so most of  the time you will set the handler to do something else:
If  you need to run a particular job every few seconds, or if  you want to limit the amount of  time you spend doing a job, then alarm signals are a great way of  getting a program to interrupt itself.
The sleep() function puts your program to sleep for a few seconds, but it works by using the same interval timer as the alarm() function, so if you try to use the two functions at the same time, they will interfere with each other.
This will catch the signal using the function you created earlier.
You’ve seen how to set custom signal handlers, but what if  you want to restore the default signal handler? Fortunately, the signal.h header has a special symbol SIG_DFL, which means handle it the default way.
Also, there’s another symbol, SIG_IGN, that tells the process to completely ignore a signal.
But you should be very careful before you choose to ignore a signal.
If  you ignore them, your program will be harder to stop.
OK, so if I receive TERM signal, I should just exit() like before…
Q: Can I set an alarm for less than a second? A: Yes, but it’s a little more complicated.
It lets you set the process’s interval timer directly in either seconds or fractions of a second.
Q: How do I do that? A: Go to http://tinyurl.com/3o7hzbm for more details.
Q: Why is there only one timer for a process? A: The timers have to be managed by the operating system kernel, and if processes had lots of timers, the kernel would go slower and slower.
To prevent this from happening, the operating system limits each process to one timer.
Q: Timers let me multitask?! Great, so I can use them to do lots of things at once?
Remember, your process will always stop whatever it’s doing when it handles a signal.
That means it is still only doing one thing at a time.
You’ll see later how you can really make your code do more than one thing at a time.
Q: What happens if I set one timer and it had already been set?
A: Whenever you call the alarm() function, you reset the timer.
This is the source code for a program that tests the user’s math skills.
It asks the user to work the answer to a simple multiplication problem and keeps track of how many answers he got right.The program will keep running forever, unless:
The user takes more than five seconds to answer the question.
You need to set the exit status to 0 and stop.
This is the source code for a program that tests the user’s math skills.
It asks the user to work the answer to a simple multiplication problem and keeps track of how many answers he got right.The program will keep running forever, unless:
The user takes more than five seconds to answer the question.
As long as you go through the loop in less than 5 seconds, the timer will be reset and it will never fire.
Raising SIGINT will make the program display the final score in end_game()
Test Drive To see if  the program works, you need to run it a couple of  times.
File  Edit   Window  Help   Test 1: hit Ctrl-C The first time, you’ll answer a few questions and then hit Ctrl-C.
Ctrl-C sends the process an interrupt signal (SIGINT) that makes the program display the final score and then exit()
Test 2: wait five seconds The second time, instead of  hitting Ctrl-C, wait for at least five seconds on one of  the answers and see what happens.
The program was waiting for the user to enter an answer, but because he took so long, the timer signal was sent; the process immediately switches to the times_up() handler function.
The handler displays the “TIME’S UP!” message and then escalates the signal to a SIGINT that causes the program to display the final score.
They allow your programs to end gracefully, and the interval timer can help you deal with tasks that are taking too long.
Q: Are signals always received in the same order they are sent?
The operating system might choose to reorder the signals if it thinks one is more important than the others.
Q: Is that always true? A: It depends on the platform.
On most versions of Cygwin, for example, the signals will always be sent and received in the same order.
Q: If I send the same signal twice, will it be received twice by the process?
On Linux and the Mac, if the same signal is repeated very quickly, the kernel might choose to only send the signal once to the process.
But again, you should not assume that just because you sent the same signal twice, it will be received twice.
When a process receives a signal, it runs a handler.
For most error signals, the default handler stops the program.
A new client, darling? I always knew your BLABing would come in useful one day.
Programs on different machines need to talk to each other.
You’ve learned how to use I/O to communicate with files and how processes on the same.
By the end of this chapter, you’ll be able to create.
The Internet knock-knock server C is used to write most of  the low-level networking code on the Internet.
Most networked applications need two separate programs: a server and a client.
You’re going to build a server in C that tells jokes over the Internet.
You’ll be able to start the server on one machine like this:
Other than telling you it’s running, the server won’t display anything else on the screen.
However, if  you open a second console, you’ll be able to connect to the server using a client program called telnet.
Telnet takes two parameters: the address of  the server, and the port the server is running on.
If  you are running telnet on the same machine as the server, you can use 127.0.0.1 for the address:
Use 127.0.0.1 if you’re running the server on the same machine.
You will need a telnet program in order to connect to the server.
If you don’t have telnet, you can install it in one of these ways:
Cygwin: Run the setup.exe program for Cygwin and search for telnet.
You’ll be using telnet quite a lot in this chapter to test our server code.
If you try to use the built-in Windows telnet, you might have problems because of the way it communicates with the network.
If you install the Cygwin version of telnet, you should be fine.
Knock-knock server overview The server will be able to talk to several clients at once.
The client and the server will have a structured conversation called a protocol.
Other protocols are high-level protocols, like the hypertext transfer protocol (HTTP), which controls how web browsers talk to web servers.
The joke server is going to use a custom high-level protocol called the Internet knock-knock protocol (IKKP)
A client and server have a structured conversation called a protocol.
The client and the server will exchange messages like this:
As long as the client and the server both follow those rules, everything is fine.
But if  one of them breaks the rules, the conversation usually stops pretty abruptly.
Protocol demands that you reply with “Who’s there?” I shall therefore terminate this conversation forthwith.
Before a server can use a socket to talk to a client program, it needs to go through four stages that you can remember with the acronym BLAB: Bind, Listen, Accept, Begin.
A computer might need to run several server programs at once.
It might be sending out web pages, posting email, and running a chat server all at the same time.
To prevent the different conversations from getting confused, each server uses a different port.
A port is just like a channel on a TV.
Different ports are used for different network services, just like different channels are used for different content.
When a server starts up, it needs to tell the operating system which port it’s going to use.
The knock-knock server is going to use port 30000, and to bind it you’ll need two things: the socket descriptor and a socket name.
A socket name is just a struct that means “Internet port 30000.”
When C programs need to talk to the outside world, they use data streams to read and write bytes.
You’ve used data streams that are connected to the files or Standard Input and Output.
But if  you’re going to write a program to talk to the network, you need a new kind of  data stream called a socket.
These lines create a name for the port meaning “Internet port 30000.”
This is the error() function you created in the last chapter.
If  your server becomes popular, you’ll probably get lots of  clients connecting to it at once.
Would you like the clients to wait in a queue for a connection? The listen() system call tells the operating system how long you want the queue to be:
They won’t all be immediately answered, but they’ll be able to wait.
The 11th client will be told the server is too busy.
Once you’ve bound a port and set up a listen queue, you then just have to…wait.
Servers spend most of  their lives waiting for clients to contact them.
The accept() system call waits until a client contacts the server, and then it returns a second socket descriptor that you can use to hold a conversation on.
Why do you think the accept() system call creates the descriptor for a new socket? Why don’t servers just use the socket they created to listen to the port?
A socket’s not your typical data stream So far, data streams have all been the same.
Whether you’re connected to files or Standard Input/Output, you’ve been able to use functions like fprintf() and fscanf() to talk to them.
A socket is two way: it can be used for input and output.
That means it needs different functions to talk to it.
If  you want to output data on a socket, you can’t use fprintf()
Remember: it’s important to always check the return value of  system calls like send()
Network errors are really common, and your servers will have to cope with them.
What port should I use? You need to be careful when you choose a port number for a server application.
There are lots of different servers available, and you need to make sure you don’t use a port number that’s normally used for some other program.
On Cygwin and most Unix-style machines, you’ll find a file called /etc/services that lists the ports used by most of the common servers.
When you choose a port, make sure there isn’t another application that already uses the same one.
Port numbers that are lower than 1024 are usually only available to the superuser or administrator on most systems.
This is because the low port numbers are reserved for well-known services, like web servers and email servers.
Operating systems restrict these ports to administrators only, to prevent ordinary users from starting unwanted services.
This is the message you’re going to send over the network.
This server generates random advice for any client that connects to it, but it’s not quite complete.
Also, this version of the code will send back a single piece of advice and then end.
Part of the code needs to be inside a loop.
And for a bonus point, if you add in the missing #include statements, the program will work.
But what has the programmer missed out? Hint: look at the system calls.
This server generates random advice for any client that connects to it, but it’s not quite complete.
Also, this version of the code will send back a single piece of advice and then end.
Part of the code needs to be inside a loop.
And for a bonus point, if you add in the missing #include statements, the program will work.
But what has the programmer missed out? Hint: look at the system calls.
Test Drive Let’s compile the advice server and see what happens.
Then, while the server is still running, open a second console and connect to the server using telnet a couple of  times.
You might want to rethink that haircut Connection closed by foreign host.
Here, you’re using 127.0.0.1 as the IP address, because the client is running on the same machine as the server.
But you could have connected to the server from anywhere on the network and we’d have gotten the same response.
The server looks like it’s starting correctly the second time, but the client can’t get any response from it.
Remember that the code was written without any error checking.
Let’s add a little error check into the code and see if  we can figure out what’s happening.
If I start the server, then run the client one time, it works…
Why your mom always told you to check for errors If  you add an error check on the line that binds the socket to a port:
Then you’ll get a little more information from the server if  it is stopped and restarted quickly:
If  the server has responded to a client and then gets stopped and restarted, the call to the bind system call fails.
But because the original version of  the program never checked for errors, the rest of  the server code ran even though it couldn’t use the server port.
Bound ports are sticky When you bind a socket to a port, the operating system will prevent anything else from rebinding to it for the next 30 seconds or so, and that includes the program that bound the port in the first place.
To get around the problem, you just need to set an option on the socket before you bind it:
This code makes the socket reuse the port when it’s bound.
That means you can stop and restart the server and there will be no errors when you bind the port a second time.
This is calling the error function you wrote a while back.
It will display the cause of the error and exit.
Reading from the client You’ve learned how to send data to the client, but what about reading from the client? In the same way that sockets have a special send() function to write data, they also have a recv() function to read data.
If  someone types in a line of  text into a client and hits return, the recv() function stores the text into a character array like this:
It means you might have to call recv() more than once:
It’s best to wrap recv() in a function that stores a simple \0-terminated string in the array it’s given.
You might need to call recv() a few times to get all the characters.
This is one way of simplifying recv(), but could you do better? Why not write your own version of read_in() and let us.
Keep reading until there are no more characters or you reach ‘\n’
Here are some other functions that are useful when you are writing a server.
Now that you have a set of server functions, let’s try them out…
You’ve used this error function a LOT in this book.
Don’t call this function if you want the program to keep running.
Yes, reuse the socket (so you can restart the server without problems)
You won’t want to stop the server if there’s just a problem with one client.
Now it’s time to write the code for the Internet knock-knock server.
You’re going to write a little more code than usual, but you’ll be able to use the ready-bake code from the previous page.
This will store the main listener socket for the server.
If someone hits Ctrl-C when the server is running, this function will close the socket before the program ends.
Now it’s over to you to write the main function.
You’ll need to create a new server socket and store it in listener_d.
Once that’s done, you need to write code that works like this:
Try to check error codes and if the user says the wrong thing, just send an error message, close the connection, and then wait for another client.
Now it’s time to write the code for the Internet knock-knock server.
You were to write a little more code than usual, but you’ll be able to use the ready-bake code from the previous page.
This will store the main listener socket for the server.
If someone hits Ctrl-C when the server is running, this function will close the socket before the program ends.
This is the kind of code you should have written.
Is yours similar? It doesn’t matter if the code is exactly the same.
The important thing is that your code can tell the joke in the right way, and cope with errors.
Test Drive Now that you’ve written the knock-knock server, it’s time to compile it and fire it up.
The server’s waiting for a connection, so open a separate console and connect to it with telnet:
The server can tell you a joke, but what happens if  you break the protocol and send back an invalid response?
The server is able to validate the data you send it and close the connection immediately.
Once you’re done running the server, you can switch back to the server window and hit Ctrl-C to close it down neatly.
That’s great! The server does everything you need it to do.
The server can only talk to one person at a time There’s a problem with the current server code.
Imagine someone connects to it and he is a little slow with his responses:
The server is running on a machine out on the Internet.
Then, if  someone else tries to get through to the server, she can’t; it’s busy with the first guy:
The server can’t respond to the second user, because it is busy dealing with the first.
What have you learned that might help you deal with both clients at once?
The problem is that the server is still busy talking to the first guy.
The main server socket will keep the client waiting until the server calls the accept() system call again.
But because of  the guy already connected, it will be some time before that happens.
Oh, great! I can’t get through to the server and I can’t even Ctrl-C my way out of telnet.
You can fork() a process for each client When the clients connect to the server, they start to have a conversation on a separate, newly created socket.
That means the main server socket is free to go and find another client.
When a client connects, you can fork() a separate child process to deal with the conversation between the server and the client.
While the client is talking to the child process, the server’s parent process can go connect to the next client.
The parent and child use different sockets One thing to bear in mind is that the parent server process will only need to use the main listener socket.
That’s because the main listener socket is the one that’s used to accept() new connections.
On the other hand, the child process will only ever need to deal with the secondary socket that gets created by the accept() call.
That means once the parent has forked the child, the parent can close the secondary socket and the child can close the main listener socket.
After forking the child, the parent can close this socket.
Q: If I create a new process for each client, what happens if hundreds of clients connect? Will my machine create hundreds of processes?
If you think your server will get a lot of clients, you need to control how many processes you create.
The child can signal you when it’s finished with a client, and you can use that to maintain a count of current child processes.
Once the child gets created, it can close this socket.
Hey, great to see you! I’ll just hand you over to someone who can deal with you.
This is a version of the server code that has been changed to fork a separate child process to talk to each client…except it’s not quite finished.
See if you can figure out the missing pieces of code.
What should the child do when the conversation is done?
This is a version of the server code that has been changed to fork a separate child process to talk to each client—except it’s not quite finished.
You were to figure out the missing pieces of code.
Once the child process has finished talking, it should exit.
That will prevent it from falling into the main server loop.
The child will use only the connect_d socket to talk to the client.
Once the conversation’s over, the child can close the socket to the client.
Test Drive Let’s try the modified version of  the server.
Everything seems the same, but if  you leave the client running with the joke half-told, you should be able to see what’s changed:
If  you open a separate console and start telnet, you can connect, just like you did before:
If  you open a third console, you will see that there are now two processes for the server: one for the parent and one for the child:
Now that you’ve built an Internet server, let’s go look at what it takes to build a client, by writing something that can read from the Web.
The ps command shows running processes in Unix and Cygwin.
Writing a web client What if  you want to write your own client program? Is it really that different from a server? To see the similarities and differences, you’re going to write a web client for the hypertext transfer protocol (HTTP)
Every time a web client and server talk, they say the same kind of things.
When your program connects to the web server, it will need to send at least three things:
But before you can send any data at all to the server, you need to make a connection from the client.
Most web clients actually send a lot more information, but you’ll just send the minimum amount.
You might get a slightly different address when you try it.
This is the path that follows the hostname in the URL.
In HTTP/1.1, you need to say what hostname you are using.
And then you need to hit return and leave a blank line.
The server first responds with some extra details about the web page.
Clients are in charge Clients and servers communicate using sockets, but the way that each gets hold of  a socket is a little different.
A server spends most of  its life waiting for a fresh connection from a client.
Until a client connects, a server really can’t do anything.
A client can connect and start talking to a server whenever it likes.
I was taught never to speak until I’m spoken to.
Remote ports and IP addresses When a server connects to the network, it just has to decide which port it’s going to use.
But clients need to know a little more: they need to know the port of  the remote server, but they also need to know its internet protocol (IP) address:
Internet addresses are kind of  hard to remember, which is why most of  the time human beings use domain names.
A domain name is just an easier-to-remember piece of  text like:
Even though human beings prefer domain names, the actual packets of  information that flow across the network only use the numeric IP address.
Addresses with four digits are in IP version 4 format.
Most will eventually be replaced with longer version 6 addresses.
Create a socket for an IP address Once your client knows the address and port number of  the server, it can create a client socket.
Client sockets and server sockets are created the same way:
The difference between client and server code is what they do with sockets once they’re created.
A server will bind the socket to a local port, but a client will connect the socket to a remote port:
Hello? I don’t want to know how to connect a socket to an IP address.
I’m actually human…I want to connect to a real domain name.
To connect a socket to a remote domain name, you’ll need a function called getaddrinfo()
Create a socket for a domain name Most of  the time, you’ll want your client code to use the DNS system to create sockets.
That way, your users won’t have to look up the IP addresses themselves.
To use DNS, you need to construct your client sockets in a slightly different way:
The getaddrinfo() constructs a new data structure on the heap called a naming resource.
The naming resource represents a port on a server with a given domain name.
Hidden away inside the naming resource is the IP address that the computer will need.
Sometimes very large domains can have several IP addresses, but the code here will simply pick one of  them.
You can then use the naming resource to create a socket.
Because the naming resource was created on the heap, you’ll need to tidy it away with a function called freeaddrinfo():
Once you’ve connected a socket to a remote port, you can read and write to it using the same recv() and send() functions you used for the server.
That means you should have enough information now to write a web client…
You’ll need to include this header for the getaddrinfo() function.
Now you can create the socket using the naming resource.
When you’ve connected, you can delete the address data with freeaddrinf0()
Code Magnets Here is the code for a web client that will download the contents of a page from Wikipedia and display it on the screen.
The web page will be passed as an argument to the program.
Think carefully about the data you need to send to a web server running HTTP.
Code Magnets Solution Here is the code for a web client that will download the contents of a page from Wikipedia and display it on the screen.
The web page will be passed as an argument to the program.
You were to think carefully about the data you need to send to a web server running HTTP.
Create a string for the path to the page you want.
This sends the host data as well as a blank line.
Add a ‘\0’ to the end of the array of characters to make it a proper string.
Test Drive If  you compile and run the web client, you make it download a page from Wikipedia like this:
You’ll have to replace any spaces with underscore (_) characters.
These tell you things about the server and the web page.
Then you get the contents of the web page from Wikipedia.
It works! The client took the name of  the page from the command line and then connected to Wikipedia to download the page.
Because it’s constructing the path to the file, you need to make sure that the you replace any spaces in the page name with underscore (_) characters.
Why not update the code to automatically replace characters like spaces for you? For more details on how to replace characters for web addresses, see:
Q: Should I create sockets with IP addresses or domain names? A: Most of the time, you’ll want to use domain names.
They’re easier to remember, and occasionally some servers will change their numeric addresses but keep the same domain names.
Q: So, do I even need to know how to connect to a numeric address? A: Yes.
If the server you are connecting to is not registered in the domain name system, such as machines on your home network, then you will need to know how to connect by IP.
Q: Can I use getaddrinfo() with a numeric address? A: Yes, you can.
But if you know that the address you are using is a numeric IP, the first version of the client socket code is simpler.
Your C Toolbox You’ve got Chapter 11 under your belt, and now you’ve.
Johnny told me he got his heap variables locked in a mutex.
Programs often need to do several things at the same time.
But be careful! Threads are powerful tools, but you don’t want.
In this chapter, you’ll learn how to put up traffic signs and.
Not only will your code need to do all of  these things, but it will need to do them all at the same time.
Chat programs will need to read text from the network and send data to the network at the same time.
Media players will need to stream video to the display as well as watch for input from the user controls.
How can your code perform several different tasks at once?
It will need to update the graphics on the screen.
It will need to calculate the latest locations of the objects that are moving in the game.
It will need to read control information from the games controller or keyboard.
It might need to communicate with the disk and the network.
In the last chapter, you built a network server that could deal with several different clients at once.
Each time a new user connected, the server created a new process to handle the new session.
Does that mean that whenever you want to do several things at once, you should just create a separate process? Well, not really, and here’s why.
Processes take time to create Some machines take a little while to create new processes.
If  the extra task you want to perform takes just a few hundredths of  a.
Processes can’t share data easily When you create a child process, it automatically has a complete copy of  all.
Processes are just plain difficult You need to create a chunk of  code to generate processes, and that can make.
You need something that starts a separate task quickly, can share all of  your current data, and won’t need a huge amount of  code to build.
Simple processes do one thing at a time Say you have a task list with a set of  things that you need to do:
You can’t do all of  the tasks at the same time, not by yourself.
If  someone comes into the shop, you’ll need to stop stocking the shelves.
If  it looks like rain, you might stop bookkeeping and get on the roof.
If  you work in a shop alone, you’re like a simple process: you do one thing after another, but always one thing at a time.
Sure, you can switch between tasks to keep everything going, but what if  there’s a blocking operation? What if  you’re serving someone at the checkout and the phone rings?
All of  the programs you’ve written so far have had a single thread of  execution.
It’s like there’s only been one person working inside the program’s process.
Employ extra staff: use threads A multithreaded program is like a shop with several people working in it.
If  one person is running the checkout, another is filling the shelves, and someone else is waxing the surfboards, then everybody can work without interruptions.
If  one person answers the phone, it won’t stop the other people in the shop.
In the same way that several people can work in the same shop, you can have several threads living inside the same process.
All of  the threads will have access to the same piece of  heap memory.
They will all be able to read and write to the same files and talk on the same network sockets.
If  one thread changes a global variable, all of  the other threads will see the change immediately.
That means you can give each thread a separate task and they’ll all be performed at the same time.
If one thread has to wait for something, the other threads can keep running.
All of the threads can run inside a single process.
If you employ more people, more than one thing can be done at once.
How do you create threads? There are a few thread libraries, and you’re going to use one of the most popular: the POSIX thread library, or pthread.
You can use the pthread library on Cygwin, Linux, and the Mac.
Let’s say you want to run these two functions in separate threads:
You’ll need to run both of  these functions in parallel in separate threads.
Did you notice that both functions return a void pointer? Remember, a void pointer can be used to point to any piece of data in memory, and you’ll need to make sure that your thread functions have a void* return type.
You’re going to run each of  these functions inside its own thread.
Create threads with pthread_create To run these functions, you’ll need a little setup code, like some headers and maybe an error() function that you can call if  there’s a problem.
The pthread_join() also receives the return value of  your thread function and stores it in a void pointer variable.
Once both threads have finished, your program can exit smoothly.
These are the headers for the main part of the code.
But then you can start the code for your main function.
You’re going to create two threads, and each one needs to have its info stored in a pthread_t data structure.
Then you can create and run a thread with pthread_create()
That code will run your two functions in separate threads.
If  your program just ran this and then finished, the threads would be killed when the program ended.
So you need to wait for your threads to finish:
The void pointer returned from each function will be stored here.
Test Drive Because you’re using the pthread library, you’ll need to make sure you link it when you compile your program, like this:
When you run the code, you’ll see both functions running at the same time:
When you run the code, the messages might come out in a different order than this.
Q: If both functions are running at the same time, why don’t the letters in the messages get mixed up? Each message is on its own line.
A: That’s because of the way the Standard Output works.
The text from puts() will all get output at once.
Q: I removed the sleep() function, and the output showed all the output from one function and then all the output from the other function.
A: Most machines will run the code so quickly that without the sleep() call, the first function will finish before the second thread starts running.
See if you can spot the missing code, and if you get the answer right, celebrate by cracking open a couple of cold ones yourself.
To save space, this example skips testing for errors, but don’t you do that!
This code waits for all the extra threads to finish.
To save space, we’ve skipped testing for errors—but don’t you do that!
Test Drive Let’s take a closer look at that last program.
If  you compile and run the code a few times, this happens:
The code usually doesn’t reduce the beers variable to zero.
The beers variable begins with a value of  2 million.
Shouldn’t that mean that the beers variable always goes to zero?
Look carefully at the code again, and try to imagine what will happen if several threads are running it at the same time.
Why is the result unpredictable? Why doesn’t the beers variable get set to zero when all the threads have run? Write your answer below.
The code is not thread-safe The great thing about threads is that lots of  different tasks can run at the same time and have access to the same data.
The downside is that all those different threads have access to the same data…
Unlike the first program, the threads in the second program are all reading and changing a shared piece of  memory: the beers variable.
To understand what’s going on, let’s see what happens if  two threads try to reduce the value of  beers using this line of  code:
Even though both of  the threads were trying to reduce the value of beers by 1, they didn’t succeed.
That’s why the beers variable didn’t get reduced to zero—the threads kept getting in the way of  each other.
And why was the result so unpredictable? Because the threads didn’t always run the line of  code at exactly the same time.
Sometimes the threads didn’t crash into each other, and sometimes they did.
First of all, both threads will need to read the current value of the beers variable.1
Be careful to look out for code that isn’t thread-safe.
You need to add traffic signals Multithreaded programs can be powerful, but they can also behave in unpredictable ways, unless you put some controls in place.
Imagine two cars want to pass down the same narrow stretch of  road.
Those traffic signals prevent the cars from getting access to a shared resource (the road) at the same time.
It’s the same thing when you want two or more threads to access a shared data resource: you need to add traffic signals so that no two threads can read the data and write it back at the same time.
The traffic signals that prevent threads from crashing into each other are called mutexes, and they are one of  the simplest ways of  making your code thread-safe.
The traffic signals prevent the two threads from accessing the same shared variable at the same time.
Use a mutex as a traffic signal To protect a section of  code, you will need to create a mutex lock like this:
The mutex needs to be visible to all of  the threads that might crash into each other, so that means you’ll probably want to create it as a global variable.
When the compiler sees that, it will insert all of  the code your program needs to create the mutex lock properly.
At the beginning of  your sensitive code section, you need to place your first traffic signal.
All the other threads will have to wait when they get to it.
Only one thread at a time will get past this.
That sets the traffic signal back to green, and another thread is allowed onto the sensitive code:
Now that you know how to create locks in your code, you have a lot of  control over exactly how your threads will work.
Thread functions can accept a single void pointer parameter and return a single void pointer value.
Quite often, you will want to pass and return integer values to a thread, and one trick is to use long values.
A thread function can accept a single void pointer parameter.
Cast it back to a void pointer when it’s returned.
Convert the return value to a long before using it.
There’s no simple way to decide where to put the locks in your code.
Where you put them will change the way the code performs.
Here are two versions of the drink_lots() function that lock the code in different ways.
Both pieces of code use a mutex to protect the beers variable, and each now displays the value of beers before they exit, but because they are locking the code in different places, they generate different output on the screen.
Can you figure out which version produced each of these two runs?
There’s no simple way to decide where to put the locks in your code.
Where you put them will change the way the code performs.
Here are two versions of the drink_lots() function that lock the code in different ways.
Both pieces of code use a mutex to protect the beers variable, and each now displays the value of beers before they exit, but because they are locking the code in different places, they generate different output on the screen.
You were to figure out which version produced each of these two runs.
Do you want to be a Linux hacker using pure C? Or a maker writing embedded C in small devices like the Arduino?
Maybe you want to go on to be a games developer in C++? Or a Mac and iOS programmer in Objective-C?
Whatever you choose to do, you’re now part of  the community that uses and loves the language that has created more software than any other.
The language behind the Internet and almost every operating system.
The language that’s used to write almost all the other languages.
And the language that can write for almost every processor in existence, from watches and phones to planes and satellites.
Q: Does my machine have to have multiple processors to support threads?
Most machines have processors with multiple cores, which means that their CPUs contain miniprocessors that can do several things at once.
But even if your code is running on a single core/ single processor, you will still be able to run threads.
Q: How? A: The operating system will switch rapidly between the threads and make it appear that it is running several things at once.
While threads can help you use more of the processors and cores on your machine, you need to be careful about the amount of locking your code needs to do.
If your threads are locked too often, your code may run as slowly as single-threaded code.
Q: How can I design my thread code to be fast?
A: Try to reduce the amount of data that threads need to access.
If threads don’t access a lot of shared data, they won’t need to lock each other out so often and will be much more efficient.
A: They usually are, simply because it takes a little more time to create processes than it does to create extra threads.
Q: I’ve heard that mutexes can lead to “deadlocks.” What are they?
A: Say you have two threads, and they both want to get mutexes A and B.
If the first thread already has A, and the second thread already has B, then the threads will be deadlocked.
This is because the first thread can’t get mutex B and the second thread can’t get mutex A.
Your C Toolbox You’ve got Chapter 12 under your belt, and now you’ve.
Threads allow a process to do more than one thing at the same time.
If two threads read and update the same variable, your code will be unpredictable.
This lab gives you a spec that describes a program for you to build, using the knowledge you’ve gained over the last few chapters.
This project is bigger than the ones you’ve seen so far.
So read the whole thing before you get started, and give yourself a little time.
And don’t worry if you get stuck; there are no new C concepts in here, so you can move on in the book and come back to the lab later.
We’ve filled in a few design details for you, and we’ve made sure you’ve got all the pieces you need to write the code.
It’s up to you to finish the job, but we won’t give you the code for the answer.
Write the arcade game Blasteroids Of  course, one of  the real reasons people want to learn C is so they can write games.
In this lab, you’re going to pay tribute to one of  the most popular and long-lived video games of  them all.
You lose a life when you get hit by an asteroid.
Use your keyboard to fly your spaceship, firing at asteroids while avoiding getting hit.
They float and rotate slowly across the screen, promising instant death to any passing space traveler who happens to meet them.
Welcome to the starship Vectorize! This is the ship that you will fly around the screen using your keyboard.
It’s armed with a cannon that can fire at passing asteroids.
If  an asteroid is hit by a blast from the spaceship’s cannon, it immediately splits into two, and the player’s score increases by 100 points.
Once an asteroid has been hit a couple of  times, it’s removed from the screen.
If  the ship gets hit by an asteroid, you lose a life.
You have three lives, and when you lose the last one, that’s the end of  the game.
Allegro Allegro is an open source game development library that allows you to create, compile, and run game code across different operating systems.
Allegro is pretty straightforward to use, but just because it’s a simple library doesn’t mean it lacks power.
Allegro can deal with sound, graphics, animation, device handling, and even 3D graphics if  your machine supports OpenGL.
You describe your 3D objects to OpenGL, and it handles (most) of the math for you.
Installing Allegro You can get the source for Allegro over at the Allegro SourceForge website:
The Web gets updated more often than books, so this URL might be different.
You can download, build, and install the latest code from the source repository.
There are instructions on the site that will tell you exactly how to do that for your operating system.
You may need CMake When you build the code, you will probably also need to install an extra tool called CMake.
CMake is a build tool that makes it a little easier to build C programs on different operating systems.
If  you need CMake, you will find all you need over at http://www.cmake.org.
If you download and install a newer version, you may need to make a few changes.
What does Allegro do for you? The Allegro library deals with several things:
GUIs Allegro will create a simple window to contain your game.
This might not seem like a big deal, but different operating systems have very different ways of  creating windows and then allowing them to interact with the keyboard and the mouse.
Events Whenever you hit a key, move a mouse, or click on something, your system generates an event.
An event is just a piece of  data that says what happened.
Events are usually put onto queues and then sent to applications.
Allegro makes it simple to respond to events so that you can easily, say, write code that will run if  a user fires her canyon by hitting the spacebar.
Timers You’ve already looked at timers at the system level.
Allegro provides a straightforward way to give your game a heartbeat.
All games have some sort of  heartbeat that runs so many times a second to make sure the game display is continuously updated.
Using a timer, you can create a game that, for example, displays a fresh version of  the screen at 60 frames per second (FPS)
Graphics buffering To make your game run smoothly, Allegro uses double buffering.
Double buffering is a game-development technique that allows you to draw all of  your graphics in an offscreen buffer before displaying it on the screen.
Because an entire frame of  animation is displayed all at once, your game will run much more smoothly.
Graphics and transformations Allegro comes with a set of  built-in graphics primitives that allow you to draw lines, curves, text, solids, and pictures.
If  you have an OpenGL driver for your graphics card, you can even do 3D.
In addition to all of  this, Allegro also supports transformations.
Transformations allow you to rotate, translate, and scale the graphics on the screen, which makes it easy to create animated spaceships and floating rocks that can move and turn on the screen.
Sounds Allegro has a full sound library that will allow you to build sounds into your game.
Building the game You’ll need to decide how you’re going to structure your source code.
Most C programmers would probably break down the code into separate source files.
That way, not only will you be able to recompile your game quicker, but you’ll also be dealing with smaller chunks of  code at a time.
That will make the whole process a lot less confusing.
There are many, many ways of  splitting up your code, but one way is to have a separate source file for each element that will be displayed in the game:
A file containing all of the source code to track and display the latest position of an asteroid.
The spaceship will be able to fire its cannon at passing asteroids, so you will need code to draw and move a cannon blast across the screen.
Unlike with the asteroids, you will probably need to manage only one of these at a time.
It’s always good to have a separate source file to deal with the core of the game.
The code in here will need to listen for keypresses, run a timer, and also tell all of the other spaceships, rocks, and blasts to draw themselves on the screen.
The spaceship When you’re controlling lots of  objects on a screen, it’s useful to create a struct for each one.
What the spaceship looks like If  you set up your code to draw around the origin (discussed later), then you could draw the ship using code like this:
The variable s is a pointer to a Spaceship struct.
Collisions If  your spaceship collides with a rock, it dies immediately and the player loses a life.
For the first five seconds after a new ship is created, it doesn’t check for collisions.
The new ship should appear in the center of  the screen.
Spaceship behavior The spaceship starts the game stationary in the center of  the screen.
To make it move around the screen, you need to make it respond to keypresses:
You probably don’t want the spaceship to move forward more than a couple hundred pixels per second.
The up and down arrows accelerate and decelerate the spaceship.
Reading keypresses The C language is used to write code for almost every piece of computer hardware in the world.
But the strange thing is, there’s no standard way to read a keypress using C.
All of  the standard functions, like fgets(), read only the keys once the return key has been pressed.
Every event that’s sent to an Allegro game comes in via a queue.
That’s just a list of  data that describes which keys have been pressed, where the mouse is, and so on.
Somewhere, you’ll need a loop that waits for an event to appear on the queue.
Once you receive an event, you need to decide if  it represents a keypress or not.
Even functions such as getchar() tend to buffer any characters you type until you hit return.
The blast Take that, you son of  a space pebble! The spaceship’s cannon can fire blasts across the screen, and it’s your job to make sure they move across the screen.
If  the user hits the fire key rapidly, the blasts will overlay each other and the line will look more solid.
That way, rapid firing will give the impression of  increased firepower.
Blast behavior Unlike the other objects you’ll be animating, blasts that disappear off  the screen won’t reappear.
That means you’ll need to write code that can easily create and destroy blasts.
Blasts are always fired in the direction the ship is heading, and they always travel in a straight line at a constant speed—say, three times the maximum speed of the ship.
If  a blast collides with an asteroid, the asteroid will divide into two.
Asteroid appearance This is the code to draw an asteroid around the origin:
Speed of rotation per frame Scaling factor to change its size.
How the asteroid moves Asteroids move in a straight line across the screen.
Even though they move in a straight line, they continually rotate about their centers.
If an asteroid drifts off  one side of  the screen, it immediately appears on the other.
When the asteroid is hit by a blast If  an asteroid is hit by a blast from the spaceship’s cannon, it immediately splits into two.
Each of  these parts will be half  the size of  the original asteroid.
Once an asteroid has been hit/split a couple of  times, it is removed from the screen.
The player’s score increases with each hit by 100 points.
You will need to decide how you will record the set of  asteroids on the screen.
Will you create one huge array? Or will you use a linked list?
The game status There are a couple of  things you need to display on the screen: the number of  lives you have left and the current score.
When you’ve run out of  lives, you need to display “Game Over!” in big, friendly letters in the middle of  the screen.
Use transformations to move things around You’ll need to animate things around the screen.
The spaceship will need to fly, and the asteroids will need to rotate, drift, and even change size.
Rotations, translations, and scaling require quite a lot of  math to work out.
But Allegro comes with a whole bunch of transformations built in.
When you’re drawing an object, like a spaceship, you should probably just worry about drawing it around the origin.
The x-coordinates go across the screen, and the y-coordinates go down.
You can use transformations to move the origin to where the object needs to be on the screen and then rotate it to point the correct way.
Once that’s all done, all you need to do is draw your object at the origin and everything will be in the right place.
For example, this is one way you might draw the spaceship on the screen:
The finished product When you’re done, it’s time to play Blasteroids!
There are lots of other things you could do to enhance the game.
As an example, why not try to get it working with OpenCV? Let us know how you get on at Head First Labs.
It’s been great having you here in Cville! We’re sad to see you leave, but there’s nothing like taking what you’ve learned and putting it to use.
There are still a few more gems for you in the back of the book and.
We’re dying to hear how things go, so drop us a line at the Head First Labs.
There are just a few more things we think you need to know.
Oh my, look at all the tasty treats we have left…
Operators We’ve used a few operators in this book, like the basic arithmetic operators +, -, *, and /, but there are many other operators available in C that can make your life easier.
That’s a very common operation in C code, particularly if  you have a loop that increments a counter.
The C language gives you four simple expressions that simplify increments and decrements:
Each of  these expressions will change the value of  i.
The position of  the ++ and -- say whether or not to return the original value of  i or its new value.
The ternary operator What if  you want one value if  some condition is true, and a different value if  it’s false?
First, the condition Next comes the value if the condition is true.
Bit twiddling C can be used for low-level programming, and it has a set of operators that let you calculate a new series of  bits:
Commas to separate expressions You’ve seen for loops that perform code at the end of  each loop:
But what if  you want to perform more than one operation at the end of  a loop? You can use the comma operator:
The comma operator exists because there are times when you don’t want to separate expressions with semicolons.
Preprocessor directives You use a preprocessor directive every time you compile a program that includes a header file:
The preprocessor scans through your C source file and generates a modified version that will be compiled.
In the case of  the #include directive, the preprocessing inserts the contents of  the stdio.h file.
Directives always appear at the start of  a line, and they always begin with the hash (#) character.
The preprocessor will scan through the C source and replace the macro name with the macro’s value.
Macros aren’t variables because they can never change at runtime.
You can even create macros that work a little like functions:
Conditions You can also use the preprocessor for conditional compilation.
You can make it switch parts of  the source code on or off:
This code will be compiled differently if  there is (or isn’t) a macro called SPANISH defined.
The static keyword Imagine you want to create a function that works like a counter.
What’s the problem with this code? It uses a global variable called count.
Any other function can change the value of  count because it’s in the global scope.
If  you start to write large programs, you need to be careful that you don’t have too many global variables because they can lead to buggy code.
Fortunately, C lets you create a global variable that is available only inside the local scope of  a function:
The static keyword will store the variable inside the global area of  memory, but the compiler will throw an error if  some other function tries to access the count variable.
It will prevent your data and functions from being accessed in ways that they weren’t designed to be.
You can use this variable only inside the current source file.
You can call this function only from inside this source file.
The static keyword means this variable will keep its value between calls to counter()
How big stuff is You’ve seen that the sizeof operator can tell you how much memory a piece of  data will occupy.
But what if  you want to know what range of  values it will hold? For example, if  you know that an int occupies 4 bytes on your machine, what’s the largest positive number you can store in it? Or the largest negative number? You could, theoretically, work that out based on the number of  bytes it uses, but that can be tricky.
Instead, you can use the macros defined in the limits.h header.
Want to know what the largest long value you can use is? It’s given by the LONG_MAX macro.
Here’s an example program that shows the ranges for ints and shorts:
The macro names come from the data types: INT (int), SHRT (short), LONG (long), CHAR (char), FLT (float), DBL (double)
You can optionally add the prefix U (unsigned), S (signed), or L (long) if  you are interested in a more specific data type.
Automated testing It’s always important to test your code, and life becomes a lot simpler if  you automate the tests.
Automated tests are now used by virtually all developers, and there are many, many testing frameworks used by C programmers.
AceUnit is very similar to the xUnit frameworks in other languages (like nUnit and jUnit)
If  you’re writing a command-line tool and you have a Unix-style command shell, then another great tool is called shunit2
More on gcc You’ve used the GNU Compiler Collection (gcc) throughout this book, but you’ve only scratched the surface of  what this compiler can do for you.
It has an immense number of  features that give you a tremendous amount of  control over the code it produces.
Optimization gcc can do a huge amount to improve the performance of  your code.
If  it sees that you’re assigning the same value to a variable every time a loop runs, it can move that assignment outside the loop.
If  you have a small function that is used only in a few places, it can convert that function into a piece of  inline code and insert it into the right places in your program.
It can do lots of  optimizations, but most of  them are switched off by default.
Why? Because optimizations take time for the compiler to perform, and while you’re developing code you normally want your compiles to be fast.
Once your code is ready for release, you might want to switch on more optimization.
Flag Description -O If  you add a -O (letter O) flag to your gcc command, you will get the.
Ofast The maximum amount of  optimization is done with -Ofast.
Be careful with -Ofast because the code it produces is less likely to conform to the C standards.
Warnings Warnings are displayed if  the code is technically valid but does something suspicious, like assign a value to a variable of  the wrong type.
You can increase the number of  warning checks with -Wall:
The -Wall option means “All warnings,” but for historic reasons is doesn’t actually display all of  the warnings.
Also, if  you want to have really strict compilation, you can make the compile fail if  there are any warnings at all with -Werror:
Werror is useful if  several people are working on the same code because it will help maintain code quality.
More on make make is an incredibly powerful tool for building C applications, but you’ve only had a very simple introduction to it in this book.
For more details on the amazing things you can do with make, see Robert Mecklenburg’s Managing Projects with GNU Make:
For now, here are just a few of  its features.
Variables Variables are a great way of  shortening your makefiles.
For example, if  you have a standard set of  command-line options you want to pass to gcc, you can define them with a variable:
In which case, you might want to use the % symbol to write a more general target/recipe:
This looks a little weird because of  all the symbols.
If  you want to make a file called fred, this rule tells make to look for a file called fred.c.
Implicit rules The make tool knows quite a lot about C compilation, and it can use implicit rules to build files without you telling it exactly how.
For example, if  you have a file called fred.c, you can compile it without a makefile by typing:
This compile command was created by make, without us telling it how.
That’s because make comes with a bunch of  built-in recipes.
Development tools If  you’re writing C code, you probably care a lot about performance and stability.
And if  you’re using the GNU Compiler Collection to compile your code, you’ll probably want to take a look at some of  the other GNU tools that are available.
This is invaluable if  you’re trying to chase down some pesky bug.
The GNU Profiler (gprof) will tell you which parts of  your program are the slowest so that you can tune the code in the most appropriate way.
Then the gprof command-line tool will let you analyze the performance report to track down the slow parts of  your code.
But while gprof is normally used to check the performance of  your code, gcov is used to check which parts of  your code did or didn’t run.
This is important if  you’re writing automated tests, because you’ll want to be sure that your tests are running all of  the code you’re expecting them to.
Creating GUIs You haven’t created any graphical user interface (GUI) programs in any of  the main chapters of  this book.
In the labs, you used the Allegro and OpenCV libraries to write a couple of  programs that were able to display very simple windows.
But GUIs are usually written in very different ways on each operating system.
Linux — GTK Linux has a number of  libraries that are used to create GUI applications, and one of  the most popular is the GIMP toolkit (GTK+):
GTK+ is available on Windows and the Mac, as well as Linux, although it’s mostly used for Linux apps.
Windows programming is a really specialized area, and you will probably need to spend some time learning the details of  the Windows application programming interfaces (APIs) before you can easily build GUI applications.
An increasing number of  Windows applications are written in languages based on C, such as C# and C++
You can create GUI programs in C on the Mac using a set of  libraries called Carbon.
But the more modern way of  programming the Mac is using the Cocoa libraries, which are programmed using another C-derived language called Objective-C.
Now that you’ve reached the end of  this book, you’re in a very good position to learn Objective-C.
Here at Head First Labs, we love the books and courses on Mac programming available at the Big Nerd Ranch:
Reference material Here’s a list of  some popular books and websites on C programming.
This is the book that defined the original C programming language, and almost every C programmer on Earth has a copy.
This is an excellent C reference book that you will want by your side as you code.
For more advanced programming, see Peter van der Linden’s excellent book.
Ever wished all those great C facts were in one place? This is a roundup of all the C topics and principles we’ve covered in the book.
Your source files should have a name ending in .c.
You need to compile your C program before you run it.
You can use the && operator on the command line to only run your program if it compiles.
A char pointer variable x is declared as char *x.
Initialize a new array with a string, and it will copy it.
You can change where the Standard Input, Output, and Error are connected to using redirection.
The Standard Error is a separate output intended for error messages.
The mode can be “w” to write, “r” to read, or “a” to append.
Command-line arguments are passed to main() as an array of string pointers.
The getopt() function makes it easier to read command-line options.
Save object code into files to speed up your builds.
Designated initializers let you set struct and union fields by name.
Bitfields give you control over the exact bits stored in a struct.
Recursive structs contain one or more links to similar data.
A memory leak is allocated memory you can no longer access.
Function pointers let you pass functions around as if they were data.
The name of every function is a pointer to the function.
Each sort function needs a pointer to a comparator function.
Comparator functions decide how to order two pieces of data.
Arrays of function pointers can help run different functions for different types of data.
Functions with a variable number of arguments are called “variadic.”
L<name> adds a directory to the list of standard library directories.
I<name> adds a directory to the list of standard include directories.
The ar command creates a library archive of object files.
Threads allow a process to do more than one thing at the same time.
If two threads read and update the same variable, your code will be unpredictable.
Chapter 2.5: Strings: String theory Desperately seeking Frank Create an array of arrays Find strings containing the search text Using the strstr() function It’s time for a code review Array of arrays vs.
Chapter 5: Structs, Unions, and Bitfields: Roll your own structures Sometimes you need to hand around a lot of data Cubicle conversation Create your own structured data types with a struct Just give them the fish Read a struct’s fields with the “.” operator Can you put one struct inside another? How do you update a struct? The code is cloning the turtle You need a pointer to the struct (*t).age vs.
Chapter 9: Processes and System Calls: Breaking boundaries System calls are your hotline to the OS Then someone busted into the system… Security’s not the only problem The exec() functions give you more control There are many exec() functions The array functions: execv(), execvp(), execve() Passing environment variables Most system calls go wrong in the same way Read the news with RSS exec() is the end of the line for your program Running a child process with fork() + exec() Your C Toolbox.
Chapter 10: Interprocess Communication: It's good to talk Redirecting input and output A look inside a typical process Redirection just replaces data streams fileno() tells you the descriptor Sometimes you need to wait… Stay in touch with your child Connect your processes with pipes Case study: opening stories in a browser In the child In the parent Opening a web page in a browser The death of a process Catching signals and running your own code sigactions are registered with sigaction() Rewriting the code to use a signal handler Use kill to send signals Sending your code a wake-up call Your C Toolbox.
Chapter 11: Sockets and Networking: There's no place like 127.0.0.1 The Internet knock-knock server Knock-knock server overview BLAB: how servers talk to the Internet A socket’s not your typical data stream Sometimes the server doesn’t start properly Why your mom always told you to check for errors Reading from the client The server can only talk to one person at a time You can fork() a process for each client Writing a web client Clients are in charge Create a socket for an IP address getaddrinfo() gets addresses for domains Your C Toolbox.
Appendix i: Leftovers: The top ten things (we didn't cover) #1
