Rather than textbook-style learning, Head First iPhone and iPad Development brings a humorous, engaging, and even enjoyable approach to learning iOS development.
With coverage of  key technologies including Core Data and even crucial aspects such as interface design, the content is aptly chosen and top-notch.
Head First iPhone and iPad Development explains iOS application development from the ground up.
The great thing about this book is its simple, step-by-step approach.
It doesn’t try to teach everything—it just launches you right into building iOS applications in a friendly, conversational way.
Head First iPhone and iPad Development continues the growing tradition of  taking complex technical subjects and increasing their accessibility without reducing the depth and scope of  the content.
What sets this book apart is its focus on learning.
Hidden behind the funny pictures and crazy fonts is a serious, intelligent, extremely well-crafted presentation of  OO Analysis and Design.
If  you’re a new software developer, Head First Software Development will get you started off  on the right foot.
Visual learners, kinesthetic learners, everyone can learn from this book.
Visual aids make things easier to remember, and the book is written in a very accessible style—very different from most Java manuals…Head First Java is a valuable book.
I can see the Head First books used in the classroom, whether in high schools or adult ed classes.
Another nice thing about Head First Java, 2nd Edition is that it whets the appetite for more.
With later coverage of  more advanced topics such as Swing and RMI, you just can’t wait to dive into those APIs and code that flawless, 100000-line program on java.net that will bring you fame and venture-capital fortune.
There’s also a great deal of  material, and even some best practices, on networking and threadsmy own weak spot.
Even if  you already know Java, you may pick up a thing or two.
Of  course it’s not the range of  material that makes Head First Java stand out, it’s the style and approach.
This book is about as far removed from a computer science textbook or technical manual as you can get.
The use of  cartoons, quizzes, fridge magnets (yep, fridge magnets…)
And, in place of  the usual kind of reader exercises, you are asked to pretend to be the compiler and compile the code, or perhaps to piece some code together by filling in the blanks or…you get the picture.
The first edition of  this book was one of  our recommended titles for those new to Java and objects.
This new edition doesn’t disappoint and rightfully steps into the shoes of  its predecessor.
Head First Web Design is your ticket to mastering all of  these complex topics, and understanding what’s really going on in the world of  web design...If  you have not been baptized by fire in using something as involved as Dreamweaver, then this book will be a great way to learn good web design.
Is it possible to learn real web design from a book format? Head First Web Design is the key to designing user-friendly sites, from customer requirements to hand-drawn storyboards to online sites that work well.
What sets this apart from other ‘how to build a web site’ books is that it uses the latest research in cognitive science and learning to provide a visual learning experience rich in images and designed for how the brain works and learns best.
I definitely recommend Head First Web Design to all of  my fellow programmers who want to get a grip on the more artistic side of  the business.
Wouldn’t it be dreamy if there was a book to help me.
O’Reilly Media books may be purchased for educational, business, or sales promotional use.
Many of  the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and O’Reilly Media, Inc., was aware of  a trademark claim, the designations have been printed in caps or initial caps.
While every precaution has been taken in the preparation of  this book, the publisher and the authors assume no responsibility for errors or omissions, or for damages resulting from the use of  the information contained herein.
No PCs were harmed in the making of  this book.
To Dan, my best friend, husband, and now business partner; and Vinny and Nick, the best boys a mother could ask for.
This book is dedicated to my family: my parents who made all of this possible, my brothers who keep challenging me, and my wife and sons, who don’t just put up with it—they help make it happen.
Dan Pilone is the founder and Managing Partner of  Element 84, a consulting and mobile software development company.
Dan has taught a number of  iPhone and iPad development courses for O’Reilly, iPhone Bootcamp, and private development teams.
He has taught project management, software design, and software engineering at The Catholic University in Washington, DC.
Dan’s previous Head First books are Head First Software Development and Head First Algebra, so he’s used to them being a little out of  the ordinary, but this is the first book to involve bounty hunters.
Dan’s degree is in computer science with a minor in mathematics from Virginia Tech and he is one of  the instructors for the O’Reilly iPhone Development Workshop.
Tracey Pilone is a project manager with Element 84, a startup in the DC area that offers mobile, Web, and backend development services.
Before working as a writer, she spent several years working in and around the Washington, DC, area for two of  ENR’s (Engineering News Record) top 20 contractors as a construction manager in commercial construction.
Tracey has a civil engineering degree from Virginia Tech and a masters of  education from the University of  Virginia, and holds a Professional Engineer’s License in Virginia.
Here you are trying to learn something, while here your brain is doing you a favor by making sure the learning.
So how do you trick your brain into thinking that your life depends on knowing.
Here’s what YOU can do to bend your brain into submission xxix.
The iPhone 4 “changed everything, again.” And now you’ve got the iPad to.
Hello, Renee!Apps have a lot of  moving parts.OK, actually, they don’t have any real moving parts, but they do have lots of UI controls.
A typical iPhone app has more going on than just a button, and now it’s time.
Working with some of the more complicated widgets means you’ll need.
We’ve written a cool app with one view, but anyone who’s used a smartphone knows.
Some of the more impressive iOS apps out there do.
That’s the story of every app! You get some functionality working, decide to add.
Developing an app isn’t always ever a linear process, but there’s a lot to be.
Dictionary name = Cupid’s Cocktail ingredients =  Cherry liqueur, peach ...
Modal views focus the user on the task at hand...
Displaying data is nice, but adding and editing information is what makes an app really hum.
DrinkMixer is great—it uses some cell customization, and works with plist dictionaries to.
It’s a handy reference application, and you’ve got a good start on adding new.
Now, it’s time to give the user the ability to modify the data—saving, editing, and.
When the iPad first launched, some panned it by saying that it was “just a big iPhone”
In many ways it is, but that screen opens up many.
Or many other things that you already know how to use, like a menu...
Companies large and small are a significant market for iPhone and iPad apps.
Most of these apps are going to manage lots of data, and since iOS 3.0, there has.
Working with that and another new controller, the tab bar.
But what about when the data has to change? Bob wants some new functionality, and what.
As any iPhone, iPod Touch, or iPad user knows, these devices go way beyond just.
The iPad is all about existing in the real world.
We’ve built a basic iPad port of an existing app for DrinkMixer a few chapters.
By mimicking things that people use in the real world, users know.
At least, not if you want to be able to carry this book around without a metallic.
Even then, it’s not just a matter of clicking a button.
Intro I can’t believe they put that in an iOS development book!
Note from marketing: this book is for anyone with a credit card.
Do you want to learn, understand, remember, and apply important iOS design and development concepts so that you can write your own iPhone and iPad apps and start selling them in the App Store?
Do you prefer stimulating dinner party conversation to dry, dull, academic lectures?
Are you already developing iOS apps and looking for a reference book on Objective-C?
Are you afraid to try something different? Would you rather have a root canal than mix stripes with plaid? Do you believe that a technical book can’t be serious if there’s a bounty hunter in it?
It definitely helps if you’ve already got some object-oriented chops, too.
Experience with Mac development is helpful, but definitely not required.
Check out Head First Java for an excellent introduction to object-oriented development, and then come back and join us in iPhoneville.
It was built that way, and it helps you stay alive.
So what does your brain do with all the routine, ordinary, normal things you encounter? Everything it can to stop them from interfering with the brain’s real job—recording things that matter.
It doesn’t bother saving the boring things; they never make it past the “this is obviously not important” filter.
How does your brain know what’s important? Suppose you’re out for a day hike and a tiger jumps in front of  you.
Or trying to learn some tough technical topic your boss thinks will take a week, 10 days at the most.
It’s trying to make sure that this obviously non-important content doesn’t clutter up scarce resources.
Resources that are better spent storing the really big things.
And there’s no simple way to tell your brain, “Hey brain, thank you very much, but no matter how dull this book is, and how little I’m registering on the emotional Richter scale right now, I really do want you to keep this stuff  around.”
In recent studies, student s performed up to 40% be.
Your brain pays attention to things that are out of t.
We think of a “Head First” r eader as a learner.
If  you really want to learn, and you want to learn more quickly and more deeply, pay attention to how you pay attention.
Most of  us did not take courses on metacognition or learning theory when we were growing up.
We were expected to learn, but rarely taught to learn.
But we assume that if  you’re holding this book, you really want to learn about iOS development.
And you probably don’t want to spend a lot of  time.
And since you’re going to build more apps in the future, you need to remember what you read.
To get the most from this book, or any book or learning experience, take responsibility for your brain.
The trick is to get your brain to see the new material you’re learning as Really Important.
Otherwise, you’re in for a constant battle, with your brain doing its best to keep the new content from sticking.
I wonder how I can trick my brain into remembering.
So just how DO you get your brain to think that iOS development is a hungry tiger?
There’s the slow, tedious way, or the faster, more effective way.
You obviously know that you are able to learn and remember even the dullest of  topics if  you keep pounding the same thing into your brain.
With enough repetition, your brain says, “This doesn’t feel important to him, but he keeps looking at the same thing over and over and over, so I suppose it must be.”
The faster way is to do anything that increases brain activity, especially different types of  brain activity.
The things on the previous page are a big part of  the solution, and they’re all things that have been proven to help your brain work in your favor.
For example, studies show that putting words within the pictures they describe (as opposed to somewhere else on the page, like a caption or in the body text) causes your brain to try to makes sense of  how the words and picture relate, and this causes more neurons to fire.
More neurons firing = more chances for your brain to get that this is something worth paying attention to, and possibly recording.
A conversational style helps because people tend to pay more attention when they perceive that they’re in a conversation, since they’re expected to follow along and hold up their end.
The amazing thing is, your brain doesn’t necessarily care that the “conversation” is between you and a book! On the other hand, if  the writing style is formal and dry, your brain perceives it the same way you experience being lectured to while sitting in a roomful of  passive attendees.
We used pictures, because your brain is tuned for visuals, not text.
As far as your brain’s concerned, a picture really is worth a thousand words.
And where text and pictures work together, we embedded the text in the pictures because your brain works more effectively when the text is within the thing the text refers to, as opposed to in a caption or buried in the text somewhere.
We used redundancy, saying the same thing in different ways and with different media types, and multiple senses, to increase the chance that the content gets coded into more than one area of  your brain.
We used concepts and pictures in unexpected ways because your brain is tuned for novelty, and we used pictures and ideas with at least some emotional content, because your brain is tuned to pay attention to the biochemistry of  emotions.
That which causes you to feel something is more likely to be remembered, even if  that feeling is nothing more than a little humor, surprise, or interest.
We used a personalized, conversational style, because your brain is tuned to pay more attention when it believes you’re in a conversation than if  it thinks you’re passively listening to a presentation.
We included loads of  activities, because your brain is tuned to learn and remember more when you do things than when you read about things.
We used multiple learning styles, because you might prefer step-by-step procedures, while someone else wants to understand the big picture first, and someone else just wants to see an example.
But regardless of  your own learning preference, everyone benefits from seeing the same content represented in multiple ways.
We include content for both sides of  your brain, because the more of  your brain you engage, the more likely you are to learn and remember, and the longer you can stay focused.
Since working one side of  the brain often means giving the other side a chance to rest, you can be more productive at learning for a longer period of  time.
And we included stories and exercises that present more than one point of  view, because your brain is tuned to learn more deeply when it’s forced to make evaluations and judgments.
We included challenges, with exercises, and asked questions that don’t always have a straight answer, because your brain is tuned to learn and remember when it has to work at something.
Think about it—you can’t get your body in shape just by watching people at the gym.
But we did our best to make sure that when you’re working hard, it’s on the right things.
That you’re not spending one extra dendrite processing a hard-to-understand example, or parsing difficult, jargon-laden, or overly terse text.
In stories, examples, pictures, etc., because, well, you’re a person.
And your brain pays more attention to people than it does to things.
These tips are a starting point; listen to your brain and figure out what works for you and what doesn’t.
Your brain works best in a nice bath of  fluid.
Dehydration (which can happen before you ever feel thirsty) decreases cognitive function.
Create something! Apply this to your daily work; use what you’re learning to make decisions on your projects.
Just do something to get some experience beyond the exercises and activities in this book.
All you need is a pencil and a problem to solve…a problem that might benefit from using the tools and techniques you’re studying for the exam.
Feel something! Your brain needs to know that this matters.
Groaning over a bad joke is still better than feeling nothing at all.
If  you find yourself  starting to skim the surface or forget what you just read, it’s time for a break.
Once you go past a certain point, you won’t learn faster by trying to shove more in, and you might even hurt the process.
If  you’re trying to understand something, or increase your chance of  remembering it later, say it out loud.
Better still, try to explain it out loud to someone else.
You’ll learn more quickly, and you might uncover ideas you didn’t know were there when you were reading about it.
Part of  the learning (especially the transfer to long-term memory) happens after you put the book down.
Your brain needs time on its own, to do more processing.
If  you put in something new during that processing time, some of  what you just learned will be lost.
They’re not optional sidebars—they’re part of  the core content! Don’t skip them.
We put them in, but if  we did them for you, that would be like having someone else do your workouts for you.
There’s plenty of evidence that physical activity while learning can increase the learning.
The more you understand, the less you have to memorize.
When the book asks you a question, don’t just skip to the answer.
The more deeply you force your brain to think, the better chance you have of learning and remembering.
Here’s what YOU can do to        bend your brain into submission.
Read me This is a learning experience, not a reference book.
We deliberately stripped out everything that might get in the way of  learning whatever it is we’re working on at that point in the book.
And the first time through, you need to begin at the beginning, because the book makes assumptions about what you’ve already seen and learned.
We start off by building an app in the very first chapter.
Believe it or not, even if  you’ve never developed for iOS before, you can jump right in and starting building apps.
You’ll also learn your way around the tools used for iOS development.
We don’t worry about preparing your app to submit to the App Store until the end of book.
In this book, you can get on with the business of  learning how to create iOS apps without stressing over the packaging and distribution of  your app out of  the gate.
But we know that’s what everyone who wants to build an iOS app ultimately wants to do, so we cover that process (and all its glorious gotchas) in an Appendix at the end.
We focus on what you can build and test on the simulator.
The simulator lets you try out your code without having to worry about getting it in the app store or on a real device.
There’s some cool iOS stuff  you just can’t test on the simulator, like the accelerometer and compass.
So, we don’t cover those kinds of  things in very much detail in this book since we want to make sure you’re creating and testing apps quickly and easily.
The exercises and activities are not add-ons—they’re part of  the core content of  the book.
Some of  them are to help with memory, some are for understanding, and some will help you apply what you’ve learned.
Even crossword puzzles are important—they’ll help get concepts into your brain so they stay there when you’re coding.
But more importantly, they’re good for giving your brain a chance to think about the words and terms you’ve been learning in a different context.
One distinct difference in a Head First book is that we want you to really get it.
And we want you to finish the book remembering what you’ve learned.
Most reference books don’t have retention and recall as a goal, but this book is about learning, so you’ll see some of  the same concepts come up more than once.
For some of  them, there is no right answer, and for others, part of  the learning experience of  the Brain Power activities is for you to decide if  and when your answers are right.
In some of  the Brain Power exercises, you will find hints to point you in the right direction.
System requirements To develop for the iPhone and iPad, you need an Intel-based Mac, period.
We wrote this book using Snow Leopard and Xcode 4.0
If  you’re running Leopard with an older version of  Xcode, we tried to point out where there were places that would trip you up.
For some of  the more advanced capabilities, like the accelerometer and the camera, you’ll need an actual iPhone, iPod Touch, or iPad and to be a registered developer.
In Chapter 1, we tell you where to get the SDK and Apple documentation, so don’t worry about that for now.
He began his career eons ago at Bell Labs, where his work with relational databases, Unix, and the Internet prepared him well for the world of  web technology.
He lives in New Jersey with his wife, Celia, whose singing provides a sweet counterpoint to the cacophony he produces in his Mac-based home recording studio.
Joe Heck is a software developer, technology manager, author, and instructor who’s been involved with computing for 25 years and developing for the iPhone platform since the first beta release.
He’s the founder of  the Seattle Xcoders developer group, which supports Macintosh and iPhone development in the Seattle area, and the author of  SeattleBus, an iPhone app that provides real-time arrival and departure times of  Seattle public transportation (available on the App Store)
Eric Shepherd got started programming at age nine and never looked back.
He’s been a technical writer, writing developer documentation since 1997, and is currently the developer documentation lead at Mozilla.
In his spare time, he writes software for old Apple II computers—because his day job just isn’t geeky enough—and spends time with his daughter.
His thorough review means that no one else has to go through the problems he had in actually making the code work.
Michael Morrison is a writer, developer, and author of  Head First JavaScript, Head First PHP & MySQL, and even a few books that don’t have squiggly arrows, stick figures, and magnets.
Michael spends a lot of  time wearing helmets, be it for skateboarding, hockey, or iPhone debugging.
Since he has iPhone Head First experience, Mike was a great resource to have helping us.
Thanks to Courtney Nash, who has turned into not just our editor, but general all-around O’Reilly handler.
She has listened to lots of rants, spent a week on camera with Dan, and still managed to carry us through two updates to the book, one that didn’t get published! She has had her hand in every single one of  the over 600 pages in the book and it’s better because of  her involvement.
And to Brett McLaughlin, who kicked off  the first edition of this book by responding to an IM that said, “What do you think about Head First iPhone?” and trained us both up in the ways of Head First.
To Karen Shaner, who, as always, kept things running smoothly, which is helpful when we keep changing things.
And to Laurie Petrycki, who continues to let us write more Head First books, which apparently is habit forming.
To all the Pilones and Chadwicks, who have always been supportive of  our efforts and helped us to become grown ups who can write this stuff.
To all our friends at Element 84, who have made this book part of  our company and helped us create a place where we enjoy working.
To Vinny and Nick, who think that everybody’s parents work together, thank you for putting up with us constantly talking about iOS development.
We’re hoping they’re going to be ready to intern this summer.
Finally, to Apple, as silly as it sounds, because iOS development has been good to us! We thought the iPhone was great, but the iPad has already changed how we read and interact with the Web.
We’re looking forward to being a part of  that change.
With a subscription, you can read any page and watch any video from our library online.
Access new titles before they are available for print, and get exclusive access to manuscripts in development and post feedback for the authors.
Copy and paste code samples, organize your favorites, download chapters, bookmark key sections, create notes, print out pages, and benefit from tons of  other time-saving features.
To have full digital access to this book and others on similar topics from O’Reilly and other publishers, sign up for free at http://my.safaribooksonline.com.
I just don’t see what all the iPhone and iPad fuss is about.
This phone works just fine and paper does all I.
Maybe you use an iPhone all the time and wish “it could do that.” Maybe you have an app you love that could be so much better.
You might have a business that wants to leverage computing power that fits in your customers’ hands.
Or perhaps you have an idea for an app that could start a business.
There are a lot of  motivations to want to code for iPhone and iPad, and lots of  customers, too.
Enterprises are starting to use iPhones, iPads, and iPod Touches for employees to perform work that they once did with a clipboard or even a laptop.
But while there’s a lot of  opportunity, there’s also plenty for you to learn, even as an experienced OO developer.
Most companies are choosing to outsource iOS development work, making it a great opportunity for freelancers, too.
Just look at the app store At the time this book went to print, there were over 500,000 different apps available for download from the App Store.
More than that, the percentage of  apps for sale that are games has held steady, while the gross number of  apps continues to rise.
That means that the number of  apps for sale that allow users to perform a task is going up  ; people are integrating mobile computing into their lives for more than just playing.
Let’s start with how an app gets from your head to a device...
Apps live in an iTunes universe To get an app approved, sold, distributed, or installed, you need to work with the Apple iOS SDK before getting your app into the iTunes App Store.
Here’s a quick picture of  the cycle of  which you’re going to be a part.
This is where we’ll be working for the rest of the book...
Time to make a decision You’re probably brimming with app ideas, but for this first one, we’re going to start simple.
Our first application is pretty straightforward: it is going to be a single view with a button that the user can push to make a decision.
For now we’ll build this just for iPhone; we’ll get into iPads a bit later in the book.
When users start up your application, the first thing they see is a view.
It’s essentially the user interface, and it needs to be easy to use and focused on what your application is supposed to do.
Throughout this book, whenever we start a new application, we’re going to take a little time to sketch up what we want our views to look like.
Press the button and the label text will change to tell you wh.
You can choose to hide it, but unless you’re writing a game, you should probably leave it.
We know what our app should look like, now we just need the tools to build it...
It all starts with the iOS SDK Head over to http://developer.apple.com/ios.
You can download the SDK (and other useful Apple development resources) for free with the basic registrationbut to distribute a completed app in the App Store or install your app on an iPhone, iPod Touch, or iPad for testing, you’ll need to become a paid Standard or Enterprise Developer.
The basic registration provides the SDK with a simulator for testing directly on your Mac, so you can go the free route for now to get started.
Download the latest SDK; this book is based on the Download button at the top of  the page.
Instruments helps assess memory usage and performance of your app during testing.
Now that you have everything installed, go ahead and double-click on Xcode to get it started.
Quartz Composer can be used to create motion graphics for your app.
Dashcode is used to write dashboard widgets and webapps, not iOS apps.
If  your installation went right, the install directory should have a few key things.
Xcode includes app templates to help you get started When you start Xcode, you’ll get a welcome screen where you can select Create a New Project.
This is the very same Xcode that you’d use to develop for the Mac.
Since we’re working with the iPhone, make sure iOS Application is selected..
Based on your selection, different code and files are set up for you.
As we go through the book, we’ll use different types of  projects and discuss why you’d choose one over another for each app.
For iDecide, we have just one screen (or view), so start with the View-based Application and give it the Product Name iDecide.
In the final dialog box, uncheck the box for Create Local Git Repository.
If you click on each project type, the description here will help fill you in on some details.
Maintaining your project resources Xcode will create a new directory for your project and sort the various files into subdirectories.
You don’t have to stick with the default layout, but if  you decide to reorganize, do it from within Xcode.
Xcode also has built-in support for version control tools like Git and Subversion and can be used to check out and commit your project changes.
Editing your code and resources You’ll use Xcode to edit your application code, and it supports a variety of  languages beyond just Objective-C.
Xcode also has a number of built-in editors for resource files like plists and xib and nib files (we’ll talk more about these later on)
For resources Xcode doesn’t handle natively, double-clicking on one of  those files in Xcode will launch the appropriate editor.
Some file types Xcode can only view, like pictures, or it will merely list, like sound files.
Building and testing your application Xcode comes with all of  the compilers necessary to build your code and generate a working application.
Once your application is compiled, Xcode can install it on the iOS Simulator or a real device.
Xcode includes LLVM and GDB debuggers with both graphical and commandline interfaces to let you debug your application.
You can also launch profiling tools like Instruments to check for memory or performance issues.
Prepare your application for sale Once you get your application thoroughly tested and you’re ready to sell it, Xcode manages your provisioning profiles and code signing certificates that let you put your application on real devices or upload it to the iTunes App Store for sale.
We’ve got more info on this process in the Appendix.
Xcode is a full-featured IDE Xcode is much more than just a text editor.
As you’ve already seen, Xcode includes templates to get you started developing an application.
Depending on your application, you may use all of  a template or just parts of  it, but you’ll almost always start with one of  them.
Once you get your basic app template in place, you’ll use Xcode for a lot more:
Xcode is the hub of your iOS project When Xcode opens your new View-based project, it is populated with all of  the files that you see here, but we’ve changed the view a bit.
By expanding the project and selecting a .xib file (which is your view, more on that in a minute), the GUI editor is open on the left.
To open the side-by-side assistant view, click the Assistant Editor button on the upper right of  the editor.
The iDecide folder has all the Objective-C class files that make up your app, as well as the .xib files that will make up the views for your app.
Supporting Files include your main function and an application-wide header file, pictures, data, and other data that your app will need to run.
Every class has a .h (header) and .m (implementation) file to go with it..
The Editor Pane shows the selected file w ith the.
Here is where you can configure whether to build your app for the simulator or a real device.
You don’t have to group your files this way, but this is the default from the template.
The Assistant Editor automatically selects related code and displays it here.
This button changes your view to show the Assistant Editor.
These buttons are all used to split up the view to show the debugger, versions, etc.
We’ll be using some of  the other tools that came with the SDK (especially the Simulator), but they are all working with the files that are included here.
The files and frameworks shown were stubbed out based on our selection of  a View-based application.
As we go forward, we’ll use different types of  apps, and that will lead to different defaults.
Every Objective-C class in the template has both a header (.h) and an implementation (.m) file.
When the app is compiled, they work together to create a class.
Those .h and .m pairs work together to create a class.
OK, so I have an idea about how Xcode is organized.
But what about the views? What are those .xib files anyway, and do I work with them in XCode, too?
Those .xib files (also called “nibs”) are XML documents that are loaded by the Cocoa Touch framework when the app starts up.
We’ll talk a lot more about this in the next chapter, but for now it’s just important to understand that the GUI editor in XCode (often also called Interface Builder) is not creating Objective-C code.
It’s creating an XML description of  the GUI you’re building, and the Cocoa Touch framework uses that to actually create the buttons and whatnot for your application at runtime.
Everything we do in Interface Builder could be done in pure Objective-C code, but as you’ll see, there are some things that are really just easier to lay out with a GUI builder.
Do this! To edit the view files in Xcode, you’ll need to open up the .xib file and change some settings in the workspace.
Only necessary if you opened it earlier to see the editor.
We’ll use it more later, but we’re focusing on the GUI for now.
Show the Objects Library for the views by clicking on this button.
Adjust the size of the library by dragging this bar up.
Build your interface within Xcode When you open up any .xib file in Xcode, the GUI editor will be launched in the main window.
With the view tweaking you just finished on the previous page, Xcode will be ready to work with the views.
Now it shows an overview of  items in your nib, your view, and a library of  UI elements (on the right)
You can drag and drop any of  the basic library elements into your view, edit them, and work with the connections between the code and these elements, using the assistant editor.
All of  these elements come from the Cocoa Touch framework, a custom UI framework for iOS devices.
This section shows the objects and views that are currently created for that particular nib.
File’s Owner and the First Responder exist for every nib, and the others will vary.
As you add UI elements, you can see what your view will look like (minus any data that needs to be loaded) in the app.
You can build views using code and/or by dragging and dropping controls from the library.
The library shows all the elements you can choose from to drop into your view.
If you scroll around, you’ll see there are a lot of options.
Add the button to your view To add elements, all you need to do is drag and drop the elements you want onto your view.
For our app, we just need a button with text that can be changed.
The initial size of  the button will be small, so resize it to be a bit bigger.
Edit the new label on the button to say “What should I do?” by double-clicking on the label and typing the new text.
Then move the text around to center it on the button.
To build the file, make sure that the scheme selected is the “iPhone 4.x Simulator,” then press the Build and Run button here.
The iOS simulator lets you test your app on your Mac The Simulator is a great tool for testing your apps quickly and for free.
It doesn’t come with all the applications that a real device does, but for the most part, it behaves the same way.
When you first start the simulator, you see the springboard—just like on a real iPhone (it’s the initial screen that shows all your app icons)—with iDecide installed (and a default icon that you can change later)
Xcode then opens the app and your code is running.
There are some differences between using the Simulator and your iPhone.
For starters, shaking and rotating your Mac won’t accomplish anything, so those don’t work in the Simulator.
To approximate rotation and check landscape and portrait views, there are some commands under the Hardware menu.
You also have limited gesture support, CPU and memory usage don’t represent reality, and hardware capabilities like tilt sensors (or the accelerometer or gyroscope) don’t exist at all.
Even with these issues, testing on the simulator is just so much quicker and easier than a real device that you’ll find you use it for major portions of  your development.
You can always start with the Simulator and then move to a real device as your application (or hardware needs) mature.
Memory, performance, camera, GPS, and other characteristics cannot be reliably tested using the Simulator.
We’ll talk more about these later, but memory usage and.
To test these things, you need to install on an actual device (which means joining one of the paid development programs)
You don’t have to do anything special to launch the Simulator other than build and run your app.
So, you probably want to push this button right now and see what happens, right?  Go ahead...
Interface Builder creates your button, but to make that button actually do something, you’ll need to write some code that tells the button how to behave.
Controls—which are the UI elements like the button you just addedtrigger events when things happen to them, like the button being pressed.
For events like button presses, Interface Builder can connect the view controls with code in your controller class for action methods, tagged with IBAction (for Interface Builder Action)
We’ll talk more about the Objective-C syntax for actions a bit later, but for now, you’ll need to declare a method in your header (.h) file and implement it in the .m.
OK, so the button exists, but it doesn’t do anything.
Here’s where you code up what should actually happen when the button is pressed.
You’ll likely notice all the files’ names have “ViewController” in them.
Don’t sweat that for now, we’ll explain that in a bit.
Changing the button text You know that the button is going to need an IBAction to respond to the button press and that we write up what the button should do in the implementation file.
But just what is it that the button should do?
We want to change the text in the button to provide an answer.
So that means we need some way to reach back “out” to the interface and change the label text.
The code here provides a place for IB to give us a reference to the label so we can change it.
The action responds to the interface to kick off the logic in the code.
IBActions and IBOutlets are both key for understanding how to work with controls, and we’ll go into a lot more detail on both in the next chapter.
Q: What happens if I don’ t implement everything in the .h file?
It’s going to check that you fully implemented the class you declared in the corresponding header file.
Since that’s not the case, you’ll start with a warning telling you that happened.
If you need that code to support anything else, then it’ll crash at runtime.
Q: What exactly are frameworks? Are they the same thing as libraries?
They include shared, compiled code like libraries, but they also can bundle in images, headers, documentation, etc.
You can do everything you can do in Interface Builder in code (and then some)
However, using Interface Builder doesn’t mean you can’t do things in code, too.
Since Interface Builder gives you a nice, graphical way of laying out your views, most apps have at least some of their UI built in Interface Builder then tweaked or animated in code.
Q: Do I have to write my application in Objective-C?
A: Earlier releases of the iOS Developer Agreement required the use of Objective-C for any application that will be distributed.
Apple later relaxed that requirement, opening up the possibility of using other tools or languages.
Having said that, nearly everything you’ll find about iOS development will make the assumption you’re using Objective-C.
All the underlying frameworks are written in Objective-C (or written to work with it), the documentation and sample code uses it, and the tool suite is built around it.
Basically, if you’re serious about writing native applications, you should learn Objective-C and start writing in that.
Q: Can I give applications I write out to friends?
First, if you want to put an application on anyone’s actual device (including your own), you’ll need to register for the paid Apple iOS Developer program.
Once you’ve done that, you can register up to 100 devices and install your application on them.
However, that’s not really a great way to get your application out there, since Apple limits how many devices you can register this way.
It’s great for testing your application, but not how you want to go about passing it around.
A better way is to submit your application to the iTunes App Store.
We’ll talk more about distributing apps later in the book.
Finally, there’s an Enterprise Developer program you can join that lets you distribute.
This works, but is more expensive than the normal program.
Q:Do I have to use an IDE? I’m really a command-line kinda developer.
A: Technically speaking, no, you don’t have to use the Xcode IDE for straight development.
However, the IDE makes iOS development so much easier that you really should ask yourself if you have a good reason for avoiding it, especially since testing on an actual device or the simulator is so tightly coupled to Xcode.
This book uses the Xcode IDE as well as other Apple development tools, and we encourage you to at least try them out before you abandon them.
For things like automated builds or automated testing, the SDK comes with a command-line build tool called xcodebuild that can build your application just like Xcode does, but you’ll most likely still want to do your actual development in Xcode.
Q: Can I develop an app for the iPhone and then rebuild it for other phones like Windows Mobile or Android phones?
When you develop for iPhone, you use Apple’s iOS frameworks, like Cocoa Touch, as well as Objective-C.
Below is the code for when the button gets tapped.
We are creating three things: the UILabel property, the IBAction to respond to the button press, and the IBOutlet to change the label when the button is pressed.
We need to change the label text to provide our answer, so we need an IBOutlet to be able to get to the label control that the framework will build from our nib.
This is the implementation of the method that gets called when the button is pressed.
We’ll use our reference to the label to change the text.
The @synthesize tells the compiler to create a getter and setter for the property we declared in the header file.
Here, we’re defining the method that is called when the button is pressed.
We use a constant string to change the text in the label.
Remember, decisionText is a reference to the UILabel we created in Interface Builder.
The IBOutlet is a reference to the label that we’ll change the text on the button, and the IBAction specifies what will actually happen when the button is pressed.
The Model contains the data your app needs, which for iOS apps is a datasource that works with the databases, plists, images, or general information that your app will need.
A component represents the GUI element that your user will interact with, like a button.
Generally, it will be assembled with the Xcode GUI editor, but it can be built in code, too.
You see it used a lot with GUI applications, and it’s all over the Cocoa Touch framework.
The short version is that as much as possible, you want to separate out your logic from your view and data.
It’s especially key when you want to write one set of  logic to support both iPhone and iPad UIs, which we’ll do later in the book.
Does our implementation of iDecide differ from MVC? If so, how?
So iDecide is simplified to more of  a View - View Controller pattern.
You can think of  it like the MVC pattern without an M—we don’t need a model here.
Something delegates responsibility out to another class that’s responsible for actually performing an action as a result.
In this case, the view needs to delegate out to the ViewController (through UI events) and let the ViewController know that something happened.
The ViewController (or delegate) then picks up the responsibility of  reacting to that event and doing whatever the app has to do next.
Sometimes setting up delegates is an explicit thing where you actually tell an object what its delegate is.
Sometimes it’s a little more indirect and you do it by linking controls up to methods, like Interface Builder does.
Our view is described in a nib (.xib file) that we built with Interface Builder.
Test Drive You’ve got your IBAction and IBOutlets set up, so build and run the code again.
Try clicking on the button in the simulator and see if it works.
Why didn’t the button change? Who’s not doing their job?
What happened? The Objective-C that we wrote is all set to handle things when the button is pressed, but the view hasn’t been set up to connect the button to that code.
We need to use the GUI editor to hook up our button to the buttonPressed method we just wrote.
Then when the .xib file is loaded by the framework, it will connect the button object it creates with our code.
Unless the UI components are hooked up to the code, nothing is going to happen.
We need to connect the button’s “Hey, I just got pressed” event to our buttonPressed action method.
That will get our method called when the user taps on the button.
We then need to get a reference to the UILabel that the framework is going to create for us when the nib is loaded—that’s where the IBOutlet comes in.
Let’s start with the outlet so we can change the UILabel text when the button is pressed.
This is the part we’re missing—the link between the instantiated button and the code that needs to get called.
OK—I get how we can now change the label, but how does the GUI know that you pressed a button?
Now let’s hook up the button to our new code.
If you don’t have a two-button mouse, just hold CTRL and then click.
Click on the circle next to New Referencing Outlet and drag it to the @property statement for the Outlet in the .h file on the right.
Now when the decisionText UILabel is generated, our decisionText property will reference the control, through the IBOutlet.
This will bring up a list of  events and references.
A component can trigger certain events We need to attach the right component event to our code.
Remember that action method you wrote earlier that you can connect the button to?
This is the name of the method that will get called.
The name can be anything, but the method must have one argument of type (id)
Now we need to pick the event that should trigger this method.
If  you right-click on the button in the editor, you’ll see a list of  events it could dispatch.
Components dispatch events when things happen to them Whenever something happens to a component—for instance, a button gets tapped—the component dispatches one or more events.
What we need to do is tell the button to notify us when that event gets raised.
If  you think about how you click a button on an iPhone or iPad, the actual click inside the button isn’t what matters: it’s when you remove your finger (or “touch up”) that the actual tap occurs.
Connecting an event to a method is just like connecting an element to an outlet, which you just did on the previous page.
Test Drive Now that everything is hooked up, it’s ready to run.
Make sure you save everything and then build and run.
This will bring up a list of events and references, like it did with the label.
Then click on the circle next to Touch Up Inside and drag it to the IBAction in the .h file.
Now when the button gets pressed, our buttonPressed method will be called.
You’ve built your first iPhone app! All the pieces are fitting together:
Interface Builder creates nib files (with a .xib extension) that describe the GUI in XML.
Nib files are loaded by the Cocoa Touch framework and are turned into real instances of Cocoa Touch classes at runtime.
In order to connect the components described in a nib to your code, you use IBOutlets and IBActions.
Xcode is where your code and files are maintained for your application.
Xcode is the hub for your project development and offers support for editing your code, building your application, and debugging it once it’s running.
The iPhone Simulator lets you test your application on your Mac without needing a real device.
The views are connected to the code in the View Controller.
Our views are connected to the implementation code through Interface Builder using IBOutlets and IBActions.
IBOutlets give us references to UI components, and IBActions are called when events happen.
Following the MVC pattern (or really, just the VC pattern), we have all of our behavior implemented in our View Controller, cleanly separated from the view itself.
The View Controller uses IBOutlets to get back to our actual UI controls if  it needs to update them.
You can change what class Interface Builder thinks it will be, but by default, a new project is set up so that the main View Controller created by Xcode is the File’s Owner for the main view created by Xcode.
The same thing happened with the TouchUpInside event, except in this case, instead of hooking up a component to a reference, it hooked up a component’s event to a method that should be called.
Beware—Interface Builder’s expectation of the class that will load the nib does not mean that other classes can’t try—it just might not work well if that class doesn’t have the necessary properties and methods.
Q: Why does our new text string have an @ in front of it?
A: The Cocoa Touch framework uses a string class named NSString for its text.
Since it’s so common, Objective-C has built-in support for creating them from constants.
You indicate a string constant should be an NSString by putting an @ symbol in front of it.
Otherwise, it’s just a normal char* like in C or C++
Q: How much of what we’ve covered is iPhone-specific? Is developing for the iPod Touch or iPad very different?
A: Not at all! One of the benefits of developing for iOS is that most things built for one iOS device can be used directly on another iOS device.
You’ll need to be careful about device-specific hardware capabilities (for example, trying to use a camera on an older iPod Touch or iPad won’t work), and the screen resolution of your views and images will need to change, but otherwise, developing for different devices is largely hidden from you.
If you keep the MVC pattern in mind and make sure to separate logic from views, it’s much easier to add new views for other devices to your app.
A: We’re going to get into this more in the coming pages.
The short version is that Xcode can gather up all your resources and code, link them together, and then spit out a nice package at the end that drops into the sandbox available on the iOS device.
A: Before, Xcode 4 views were edited in a separate application called Interface Builder.
Now it’s a part of XCode and isn’t really called Interface Builder any more.
Since this transition is still new, folks may still be working in and talking about IB.
Q: When the views are compiled, why do they stay .xib files? Shouldn’t something change?
A: After compilation, the .xib files are actually .nib files in their binary form.
Q: What exactly are these “undocumented APIs” I keep hearing about?
A: These are private methods that Apple gets to use, but you don’t.
It just became available for developer use with iOS 4, but some of Apple’s applications have been able to run in the background from the beginning (for example, the iPod application doesn’t stop playing when you switch to another app)
You typically see developers touching undocumented, private methods when trying to customize a standard iOS control or change what a physical button does.
Apple will catch it during the approval process and they will reject your application for it.
Protecting these APIs is part of Apple protecting the platform, and what is undocumented now may be allowed in the future.
The Model View Controller pattern where the view delegates behavior to a controller.
Maintaining and editing code and resources, debugging code, and preparing an app for deployment.
Indicates a method that can be called in response to an event.
Reference from the code to an object in the nib.
The Model View Controller pattern where the view delegates behavior to a controller.
Reference from the code to an object in the nib.
Maintaining and editing code and resources, debugging code, and preparing an app for deployment.
Indicates a method that can be called in response to an event.
Pool Puzzle Your job is to take filenames from the.
You may not use the same filename more than once, and you won’t need to use all the names.
Note: each thing from the pool can only be used once!
If we put together what we learned earlier about how the app works with the diagram about the code for the button press, you get an idea of which files do what.
Pool Puzzle Solution Your job is to take filenames from the.
You may not use the same filename more than once, and you won’t need to use all the names.
Note: each thing from the pool can only be used once!
The term to describe each screen of an iPhone app.
The folder used to organize  the images for the app.
These are used in Xcode to provide classes to be accessed.
This is used on a desktop to test an app.
This is the name of the editor used for Objective-C.
The name of a file used to create a view.
The term to describe each screen of an iPhone app.
The folder used to organize  the images for the app.
These are used in Xcode to provide classes to be accessed.
This is used on a desktop to test an app.
This is the name of the editor used for Objective-C.
The name of a file used to create a view.
Your iOS Toolbox You’ve got Chapter 1 under your belt and now you’ve added basic iOS app interactions to your tool box.
Back in Interface Builder, you connect your actions and outlets to the components you included in your view.
A view is made up of  nib (*.xib) files and the GUIs are edited with Interface Builder.
Then, you write the code that makes the views work...
This code is almost always written in Objective-C using Xcode, and includes IBActions and IBOutlets.
As you build your app, you can run your code in the simulator and test it to see if  it works.
OK, actually, they don’t have any real moving parts, but they do have lots of UI controls.
He has a great girlfriend, Renee, but they’ve been having some problems.
She thinks that he doesn’t talk about his feelings enough.
I could use my iPhone to send her emails about my feelings, but it’s so much work.
Using some solid design and the basic controls included in the Interface Builder library, you can have Mike sending off  emails in no time.
The app can handle filling out some basics, setting it up to go straight to Renee, and Mike can just fill in some blanks.
First, we need to figure out what Mike (really) wants Mike isn’t a complex guy.
He wants an easy interface to create his emails and he really doesn’t want to have to type much.
Here’s what Mike handed you at the end of the night.
App Magnets Now that we know what Mike wants, what do we need to do? Take the magnets below and put them in order of the steps you’ll follow to build his email app.
App Magnets Solution Now that we know what Mike wants, what do we need to do? Take the magnets below and put them in order of the steps you’ll follow to build his email app.
Before you start coding anything, sketch up what you’re thinking.
Some people write backend code first—we’re going to go back and forth depending on our project, but to get started, we’ll do the GUI first this time.
Here we need to manage the data coming from the controls.
Q: How do you figure out the app layout? A: We’re going to give you a couple to choose from to get started, but in general, it’s important to think about what your app needs to do and focus on those features first.
Q: Are we always going to start with a sketch? A: Yes! Good software design starts with knowing what you’re building and how the user is going to work with the app.
Expect to spend about 50 percent of your development time on the UI—it’s what separates the great apps from the rest.
Q: How do we talk to the email messaging framework?
A: Don’t worry, we’ll give you some code to help you to work with that.
Q: Why isn’t Mike texting Renee? Why send an email? A: Simply put, because that won’t work in the simulator.
Once you have a good handle on creating the email, porting that to texting isn’t hard.
Q: Does every control work differently than the others? A: For the most part, no—once you learn a few basic patterns, you’ll be able to find your way through most of the SDK.
Some of the controls have a few peculiarities here and there, but for the most part, they should start to look familiar.
Based on aesthetics, usability, and standard iPhone app behavior, which one is better for Mike?
Based on aesthetics, usability, and standard iPhone app behavior, which one is better for Mike?
Option #2 has a lot less typing and fewer fields overall.
Since the user doesn’t need to change his username or password often, there’s no reason to put it on the main view every time he runs the app.
Option #1 has a lot of typing and settings to remember.
If the user changes his mind, he hits the home button and the app is moved to the background.
This is the one you’re going to build for Mike.
Instead of having Mike type in what he’s doing and his feelings, we can give him a picker to selec.
Q: Do I really need to care about usability and aesthetics so much?
A: Usability and aesthetics are what made the iPhone a success, and Apple will defend them to the death.
Even more important, you don’t get to put anything on the App Store or on anyone else’s iPhone without their approval.
Apple has sold billions of apps—if yours doesn’t fit with the iPhone look and feel or is hard to use, people will find someone else’s app and never look back.
Q: We got rid of the username, password, and email fields.
The email one I understand, but what about the other two?
A: Anytime your app needs configuration information that the user doesn’t need to change frequently, you should keep it out of the main task flow.
Apple even provides a special place for these called a Settings bundle that fits in with the standard iPhone settings.
We’re not going to use that in this chapter (we’ll just hard code the values), but later we’ll show you how to put stuff in the Settings page.
That’s usually the right place for things like login details.
Q: How am I supposed to know what Apple thinks is good design or aesthetically pleasing?
App design rules—the iOS HIG The iOS Human Interface Guide (HIG) is a document that Apple distributes for guidance in developing iOS Apps for sale on the App Store.
This isn’t just something nice they did to help you out; when you submit an app for approval, you agree that your app will conform to the HIG.
We can’t overstate this: you have to follow the HIG, as Apple’s review process is thorough and they will reject your application if it doesn’t conform.
Apple also distributes a few other guides and tutorials, including the iPhone Application Programming Guide.
This is another great source of information and explains how you should handle different devices, like the iPhone, devices with old versions of  iOS, and the iPod Touch.
Not paying attention to the iPod Touch is another great way to get your app rejected from the App Store.
Application types The HIG details three main types of  applications that are commonly developed for the iPhone.
Each type has a different purpose and therefore offers a different kind of  user experience.
Figuring out what type of  application you’re building before you start working on the GUI helps get you started on the road to good interface design.
Immersive Apps Games are a classic example, but like this simulated level, immersive apps use a very custom interface that allows the user to interact with the device.
As a result, HIG guidelines aren’t as crucial in this case.
For each one, think about what kind of app it really is and match it to the app types on the right.
News Reader: Gives you a list of the news categories and you can get the details on stories you choose.
Marble Game: A marble rolling game that uses the accelerometer to drive the controls.
Stopwatch Tool: Gives you a stopwatch that starts and stops by touching the screen.
Recipe Manager: A meal listing that allows you to drill down and look at individual recipes.
InstaEmail1.0: Allows you to create an email with minimal typing.
News Reader: Gives you a list of the news categories and you can get the details on stories you choose.
Marble Game: A marble rolling game that uses the accelerometer to drive the controls.
Stopwatch Tool: Gives you a stopwatch that starts and stops by touching the screen.
Recipe Manager: A meal listing that allows you to drill down and look at individual recipes.
Since we have one screen and no typing, InstaEmail is more of a Utility App.
Since this App has a list-driven, drill-down interface, it’s Productivity.
We want a very focused stopwatch GUI, no real data to work through.
Lots of data to work through here: tables, a drill-down to recipes—definitely productivity.
This is just the beginning of  our relationship with the HIG.
Before you build the view with your controls, it’s a good idea to take a quick look at the recommendations from Apple.
The picker’s overall size is fixed, although you can hide it or have it be part of the view (like we do in InstaEmail)
The rounded rectangle button is pretty straightforward, but keep in mind it should always perform some kind of action.
The new project type in Xcode is not necessarily the same as your app type.
We’ll be working with these other project types later in the book.
Do this! To write an app that can send an email, we’ll need to add a new framework.
With the project and its targets highlighted, select Build Phases, expand the Link Binary With Libraries section, and push the + button.
Then select MessageUI Framework from the list and click Add.
Just to keep things organized, drag the new Framework into the Frameworks folder.
I still don’t really get this “a .xib file is a nib is a view” thing.
I get that I can edit this view in Interface Builder, but how does it all fit in with everything else?
Let’s take a look at how a nib really becomes a view...
The life of a root view In Chapter 1, we touched on how the Xcode GUI editor creates XML descriptions of  your view, called a nib, and that the Cocoa Touch framework turns that into a real view in your application.
Let’s take a closer look at what’s going on under the hood.
When your application is launched by the user, the iPhone provides a quick animation of  your app zooming into the screen (this is actually a PNG file you can include with your app), and then calls your main method.
Main is provided by the templates and you almost never need to touch it.
With the View template we used, it’s a nib called MainWindow.xib.
When we constructed the nib, we used the File’s Owner proxy object to stand in for the object that owns the nib contents.
When events occur with components, methods are invoked on our controller instance.
The nib file contains serialized instances of objects as we configured them.
They are usually control objects like buttons or labels, but can be anything that can be serialized.
It is launched by the framework, on the behalf of our ViewController.
Obviously, different people will have differing opinions about what UI looks better.
However, Apple has very specific guidelines about how certain controls should be used and best practices that should be followed.
In general, if you’re using a common iOS control, make sure you’re using it in a way that’s consistent with existing applications.
Q: Can I run apps that I build on my own device?
A: To get an app you write installed on your iPhone, you’ll need to sign up for either the Standard or Enterprise Developer programs at http://developer.apple.com/ios/
Everything in this book is designed to work with just the Simulator, so don’t feel like you need to go do that just yet.
We’ll talk more about putting apps on an actual phone later in the book.
A: The icon for an application is just a PNG file in your project.
We’ll add and configure icons later, but for now, just know that you’ll need a .png file in the resources directory for that purpose—we’ll hook you up with some cool icons in a bit.
Q: Do I have to use the GUI builder for the view?
Everything you do in the Xcode editor can be done in code.
Interface Builder makes it a lot easier to get things started, but sometimes you’ll need that code-level control of a view to do what you want.
We’ll be switching back and forth depending on the project and view.
Q: I’m still a little fuzzy on this nib thing.
When you assemble a view using the Interface Builder GUI editor, it keeps track of the controls you’re using and the links to other classes.
These controls are serialized into an XML document; when you save it out, this is your.
When the nib is restored from disk, objects in the nib are reinstantiated and populated with the values you gave them in Interface Builder.
You can think of it like “freeze-drying” the objects and then restoring them at runtime.
Q: So does the editor save out the File’s Owner, too?
File’s Owner represents whatever class is asking to have this nib loaded.
So the File’s Owner proxy isn’t actually stored in the nib, but Interface Builder needs that proxy so you can make association with controls you used in your view.
When the nib is restored (and the control objects are instantiated), the nib loading code will make the connections to the real owning object that asked to load the nib.
Using drag and drop, pull over the elements from the Utilities panel that you need to build the View.
Find each of  the elements (we’ve given them the proper names for you) in the objects library and drag and drop them into the View window.
The title can be edited in the top of  the utilities panel.
Edit the labels and button text for the title, “I’m”, “and feeling”, and “about it”, as well as the title for the button.
Don’t worry about the picker values (like “hello worlding”) just yet.
Once you save it, your view should look like this...
If you don’t see this library, check your buttons here and here.
Once you tweak everything to look just how you want it, we’ll run InstaEmail in the Simulator.
Filling in the picker data requires some code, and we’ll get to that in a minute.
Did you notice the blue guidelines in the simulator? They’re in the view when you’re laying out elements to help you center things and keep them lined up with each other.
We need data For the picker to actually show up, we have to give it data to display.
He likes what you have put together for the UI, so now we need a little more information from him to give to the picker.
Here’s my list of what I do and how I feel about it so you can fill in the rest.
Can’t wait until it’s done because I’m soooo over talking about it...
Use pickers when you want controlled input In our case, the picker is the perfect element for our app.
No typing at all, but it allows Mike to have control over what gets selected.
There’s some terminology that you need to know about pickers before we get our data in there.
The number of rows, or items, comes from Mike’s list, so 9 for each component.
Remember the screen size issue when building iPhone apps? The longest word needs to fit in a column or it’s going to be abbreviated.
OK, so we can just set the picker rows with the values Mike gave us like we did with the button label, right?
The picker doesn’t want to be told what to do, it’s going to ask when it wants your input.
You’re going to see this pattern show up with controls that could use a lot of  data like pickers, and later we’ll see something similar with table views.
Many of  the elements in the Cocoa Touch framework have the concept of  datasources along with delegates.
The datasource provides the bridge between the control and the data it needs to display.
The control will ask the datasource for what it needs and the datasource is responsible for providing the information in a format the control expects.
In our case, the datasource provides the number of  components (or columns) for the picker and the total number of rows for the picker.
When someone selects something—or in this case, scrolls the picker to a value—the control tells the delegate what happened and the delegate figures out what to do in response.
Just like with datasources, different controls need different kinds of  delegates.
You’re probably wondering how to use that picker, so don’t hesitate to check out the API documentation.
In Xcode, go to the Help menu and then the Xcode Help option.
Search for “UIPickerView” and it will pull up all the information on the class that you need to implement for the picker.
Q: Why is the delegate providing the content? That really seems like data.
A: That’s something particular to a picker and it has to do with the fact that the picker delegate can change how the data is shown.
In the simplest form, it can just return strings to the picker.
If it wants to get fancy, it can return an entire View (yes, just like the View you built with Interface Builder, but smaller) to use images or special fonts, for example.
You’ll probably remember that even the View-View Controller relationship we’ve been using follows this pattern (minus the datasource)
Each control has specific needs for its datasource and delegate, and we’ll talk about how that’s handled in Objective-C in a minute.
However, it’s important to realize that while the responsibilities are split between the datasource and the delegate in the pattern, they don’t necessarily have to be implemented in different classes.
The control wants a delegate and a datasource—it doesn’t care whether they’re provided by the same object or not: it’s going to ask the datasource for datasource-related things and the delegate for delegate-related things.
Let’s take a closer look at how the UIPicker uses its datasource and delegate to get an idea of  how all of  this fits together.
I don’t usually get to talk to anyone but my datasource and delegate, so this is a real treat.
So we’ve worked with controls like buttons and labels, but they just had properties.
Picker: Well, to be clear, I have properties toothere just isn’t too much exciting going on there.
What makes me different is that I could be working with a lot of  data.
I might only have one row or I might have a hundred; it just depends on the application.
A label only has one string in it, so there can be a property that holds just that string.
Picker: Exactly! So, instead of  trying to cram all of the data into me directly, it’s cleaner to just let me ask for what I need when I need it.
Head First: But you need to ask for it in a specific way, right?
For example, I need to know how many rows I need to show, so I ask my datasource.
It could be using an array, a database, a plist, whatever—I don’t care.
For a picker, I’m not that picky...all I need to know is how many rows.
Head First: That’s really nice—so you could be showing data coming from just about anything, and as long as your datasource knows how to answer.
I can draw the wheels and all that, but I don’t know what each application wants to do when someone selects a row, so I just pass the buck to my delegate.
Head First: So the delegate is implemented so that when you tell the delegate what happened, it performs the right action.
Like saving some value or setting a clock or whatever.
Picker: Exactly, so by using the delegate, you don’t have to subclass an object to customize behavior.
Now, I have to confess I have one little oddity going on...
This is where you ask the delegate for the value to show in a row, right?
I could come up with a lot of  excuses, but...well, we all have our little quirks, right?
It’s not all bad, though; your delegate can do some neat things with each row, can’t it?
Picker: Oh yeah! When I ask the delegate for a particular row, it can give me back a full view instead of  just a string.
Sometimes they have icons in them or pictures—really, anything you can cram in a view, I can display.
Well, we’re out of  time, but thanks again for stopping by.
Picker: My pleasure! Now I’m off  to take my new datasource for a spin.
The Picker Exposed This week’s interview: How to avoid spinning out of control...
Match each picker characteristic to where it belongs—the delegate or the datasource.
You’ll need to go digging in the API to figure out where the three methods go.
Match each picker characteristic to where it belongs—the delegate or the data source.
You’ll need to go digging in the API to figure out where the three methods go.
Working together, the delegate and the datasource provide what is needed to render the picker.
Hang on—there are protocols in both the datasource and the delegate?
Protocols define what messages the datasource and delegates need to respond to.
Pickers (and other controls that use delegates and datasources) have specific messages to which their supporting classes need to respond.
We’ll get into them in more detail in the next chapter, but for now what you need to know is that messages are defined in protocols.
When your class can speak a particular protocol, you’re said to conform to it.
Protocols typically have some required methods to implement and others that are optional.
So how do you know what protocols you need to worry about? The documentation for an element will tell you what protocols it needs to talk to.
Click on the protocol name and you’ll see the documentation for which messages are optional and which are required for a protocol.
We’ll talk more about how to implement these in the next chapter; for now, we’ll provide you the code to get started.
Protocols tell you what methods (messages) you need to implement.
We’ll need to add some methods to implement the required methods from the protocols, but we’ll get back to that in a second.
We’re going to use the two arrays we declared in the header to store the words that Mike gave us.
First, declare that the controller conforms to both protocols Now that you know what you need to make the picker work, namely a delegate and a datasource, let’s get back into Xcode and create them.
The .h and .m files work together, with the header file (.h) declaring the class’s interface, variable declarations, outlets, and actions, etc.; the implementation file (.m) holds the actual implementation code.
The break here skips commented out default code that we’re not using.
We’ve underscored the name here to keep the code easier to understand.
This method gets called on your view controller after the view is loaded from the .xib file.
This is where you can do some initialization and setup for the view.
We’ll call them in a bit to fill in the picker.
You need to release all these objects to free up the memory they were using.
NSStrings are real Objective-C objects, as opposed to a simple C-style character pointer.
Remove the /* marks that were here and then add the.
How many rows in each component? They come from different arrays, so we need to treat them separately.
The datasource protocol has two required methods Let’s focus on the datasource protocol methods first.
Since we know we want two wheels (or components) in our view, we can start by putting that method in our implementation file.
Our second method needs to return the number of  rows for each component.
The number of  rows in each component is the just the number of  items in the appropriate array.
The #pragma notation is for Xcode; it helps break up the code, but doesn’t provide any logic.
Now that we have the methods implemented, let’s wire everything up to the picker.
Connect the datasource just like actions and outlets Now that the datasource protocol is implemented, the data is in place and it’s just a matter of  linking it to the picker.
Right-click on the Picker in the view to bring up the picker connections box.
You need to connect the picker’s dataSource to our controller, or the File’s Owner.
To do that, click inside the circle next to the dataSource, and drag over the to File’s Owner.
To see this view of the items in the editor, click this arrow button here.
This method has to return an NSString with the title for the given row in the given component.
Again, both of  these values are indexed from 0, so we can use the component value to figure out which array to use, and then use the row value as an index.
Our choice of two methods, one of which needs to be implemented.
Now back to the view to wire up the delegate...
Spin those dials—they’re all the things on Mike’s list and they work great!
Right-click on the picker again and bring up the connections window.
Click inside the circle next to the delegate and drag over the to File’s Owner.
Q: What happens if I don’t implement a required method in a protocol?
A: Your project will compile, but you’ll get a warning.
If you try to run your application, it will almost certainly crash with an “unrecognized selector” exception when a component tries to send your class the missing required message.
Q: What if I don’t implement an optional method in a protocol?
But whatever functionality that it would provide isn’t going to be there.
You do need to be a little careful in that sometimes Apple marks a couple of methods.
If you don’t implement at least one of the methods specified in the docs, your app will crash with an error when you try to run it.
Q: Are there limits to the number of protocols a class can realize?
Now, the more you realize, the more code you’re going to need to put in that class, so there’s a point where you really need to split things off into different classes to keep the code manageable.
But technically speaking, you can conform to as many as you want.
Q: I’m still a little fuzzy, what’s the difference between the interface we put in a header file and a protocol?
A: An interface in a header file is how Objective-C declares the properties, fields, and messages a class responds to.
It’s like a header file in C++ or the method declarations in a Java file.
However, you have to provide implementation for everything in your class’s interface.
A protocol, on the other hand, is just a list of messages—there is no implementation.
It’s the class that realizes the protocol that has to provide implementation.
These are equivalent to interfaces in Java and pure virtual methods in C++
The picker needs a delegate and a datasource to work.
Protocols define the messages your class must realize—some of them might be optional.
We got the picker working, but if  you try out the “Send Email” button, nothing happens when something’s selected.
We still need to get the button responding to Mike and then get the whole thing to generate and send an email.
Think about what we need to do to get the button working.
What files will we use? What will the button actually do?
So we just need to go back to the view and wire up the TouchUpInside event for the “Send Email” button again, right? Just like in.
Q: What is an event again? A: UI controls trigger events when things happen to them.
You can “wire” these events to methods so that your method is called when an event is triggered.
Most of the time, you can wire events to methods using Interface Builder, but you can also do it in code (we’ll do this later in the book)
Q: Why didn’t we have to wire up the picker methods? All we did there was set up a delegate and datasource.
A: Great question! Some controls have very fine-grained events that they trigger.
Those individual events can be wired to specific methods on other objects (like File’s Owner)
Other controls want higher-level concepts, like a Datasource or a Delegate.
In order to be a Datasource or a Delegate for those controls, you have to provide a set of methods that the control can call.
In the case of the UIPickerView, it doesn’t have lots of fine-grained events—instead, it has two key protocols and just wants to know which object(s) will implement them.
You can’t choose to have half the Datasource methods go to one object and the other half to go somewhere else.
You simply give it a datasource and it will call all of the datasource methods on that object as it needs to.
Yes! We still need to write the actual delegate functionality the button is going to trigger, but that’s the idea.
Actions, outlets, and events Back in iDecide, we used actions and outlets with a button press.
Let’s go back for a second to revisit what happened:
This is the name of the method that will get called.
The name can be anything, but the method must have one argument of type (id)
Here’s the action we created for the button press in Chapter 1:
My job is to do something when something else happens—an event.
You just sit there and point to stuff  going on.
Yeah, but when the user does something, I make it happen! I do the saving, I do the email sending!
Well, for starters, the “IB” in IBAction stands for Interface Builder!
Anyway, Interface Builder knows when I’m around so that some event in a nib can set me off  and keep me informed.
Listen, it’s true that I’m just an instance variable that works with an object in a nib, but that doesn’t mean I’m not important.
You know, there is one thing that you have that I’ve always wanted.
You can be anything! Stick IBOutlet in front of  a UI component’s variable name and you’re good.
I have more complicated syntax, because I need to have the idea of  a sender in there.
Without me, the code couldn’t change anything in the UI.
An IBOutlet variable can point to a specific object in the nib (like a text field or something), and code (yes, probably your code) can use me to change the UI, set a text field’s content, change colors, etc.
I do like the freedom! Glad we could work things out.
Then provide an implementation for that method in our .m file, and write a message to the log so you know it worked before creating the email and sending it off.
Start with the header and add an IBAction named sendButtonTapped.
Declare your IBAction here so we can use it in the .m file and Interface Builder knows we have an action available.
The IBAction is what allows the code to respond to a user event, remember...
Declare your IBAction in the header file and provide the implementation in the .m file.
You should get the “Email button tapped!” message in the console in Xcode.
To see it, you need to enable the debugging pane and select All Output.
Connect the event to the action Now that you have an action, you need to wire up the event to the action.
You should get the “Email button tapped!” message in the console in Xcode.
To see it, you need to enable the debugging pane and select All Output.
So now we need to get the data from that picker for the email, right? Would an IBOutlet be the right thing for that?
In Chapter 1, we used an outlet to access and change the text field value on the button.
Now, to gather up the actual message to create the email, we need to extract the values chosen from the picker, then create a string including the label text.
So far, the picker has been calling us when it needed information; this time, when Mike hits the “Send Email” button, we need to get data out of  the picker.
This lets Interface Builder know you have something to connect to.
IBOutlet identifiers are actually #defined to nothing; they’re just there for Interface Builder.
Here, we declare a field in the class called emailPicker_
Add the IBOutlet and property to your view controller We need to declare an IBOutlet property and a class attribute to back it.
We’ll talk more about properties in the next chapter, but in short, that will get us proper memory management and let the Cocoa Touch framework set our emailPicker property when our nib loads.
Start with the header file by adding the code in bold below:
The last thing you need to do with emailPicker is release our reference to it—another memory thing.
We’ll come back to the memory management in Chapter 3, we promise.
Once we set up the declarations for the property and instance variable, we need to link them up in the implementation file.
We need to make sure we release any memory we’ve allocated.
We’ll talk a lot more about memory management in Chapter 3, but for now, make sure you release each of  your class attributes.
Connect the picker to our outlet You’re probably expecting this by now! Back into the view to make the connection from the UIPickerView to the IBOutlet in your view controller.
What do you need to do now to get the data out of the picker and into your email message? Think about the “Send Email” button action and how that will need to change...
When you click and drag up to File’s Owner, you will be able to connect it to the emailPicker outlet you just created.
Use your picker reference to pull the selected values Now all that’s left is to use our reference to the picker to get the actual values Mike selects.
We need to change the sendButtonTapped method to pull the values from the picker.
That method returns a row index we can use as an index into our arrays.
We’ll pull this log message out and put in the one above to see what the final email message will be.
To figure out what Mike chose on the picker, we need to ask the picker which row is selected for each component, and get the corresponding string from our arrays.
For now we’re just going to log this message to the console so we can see the string we’re building, and then we’ll generate the email to send out in just a minute.
Let’s make sure we implemented this correctly first before emailing Renee.
Once we add the e mail code, this is w.
To send the email, we’re going to use the messaging API.
Rather than go into all the details of  the messaging framework right now, we’ll give you the code you need.
As you get further in the book, this type of  framework will become easy to use.
Add the bolded code you see below into the appropriate files, and you’ll be ready to go.
After adding that code, you can just save, build, and go.
That is great! Now, Renee is happy and feels included and I don’t actually have to talk out loud about my feelings.
This is the document Apple uses to evaluate apps for the App Store.
You see this listed in the view and it controls the view.
We’ve listed a couple of descriptions of a some different apps.
Using the app description, sketch out a rough view and answer the questions about each one.
Generic giant button app There are several of  these currently up for sale on the App Store.
This app consists of pushing a big button and getting some noise out of  your iPhone.
What are the main concerns in the HIG about this app type?
Book inventory app This app’s mission is to keep a list of  the books in your library, along with a quick blurb of what each is about and the author.
What are the main concerns in the HIG about this app type?
You see this listed in the view and it controls the view.
We’ve listed a couple of descriptions of a some different apps.
Using the app description, sketch out a rough view and answer the questions about each one.
Generic giant button app There are several of  these currently up for sale on the App Store.
This app consists of pushing a big button and getting some noise out of  your iPhone.
What are the main concerns in the HIG about this app type?
This app’s mission is to keep a list of  the books in your library, along with a quick blurb of what each is about and the author.
What are the main concerns in the HIG about this app type?
The big thing Apple cares about is that controls “provide an internally consistent experience.” So everything can be custom, but it needs to focused and well organized.
The HIG has many more specific rules about this app type, because you’ll be using standard controls.
Another View for details, need to figure out how to get to it...
Your iOS Toolbox You’ve got Chapter 2 under your belt and now you’ve.
Protocols define the messages your class must realize—though some of them might be optional.
It’s so great that Mike and I are communicating now! But I’ve noticed that Mike’s starting to sound like he’s in a rut, saying the same thing over and over again.
Sounds like Mike is going to need some modifications to InstaEmail to keep his relationship on solid ground...
I know these are letters and all, but I have no idea what you’re saying...
Unless you work that out, all your apps will be just default widgets!
InstaEmail is working great and is so easy to use! But I think Renee is on to me.
I need to be able to add some variation to my emails or this isn’t going to work much longer.
Mike has been diligently using InstaEmail to communicate his feelings, but his girlfriend is starting to think something weird is going on.
Even for Mike, who is a guy who likes his routines, his emails are starting to sound suspicious.
We need to make some adjustments to our InstaEmail design.
Take a look at the various UI controls available in Interface Builder, and think about what would be a quick and easy way for Mike to add to his emails.
Design Magnets Using what you know from adding the picker and the button, match the magnet with the method or file that you’ll need to edit to add the text field.
Make room for custom input It’s nothing fancy, but Mike could add a little personal flavor to his emails with a text field at the start.
It means he’ll need to do some typing, but in the end his emails will be more unique.
Design Magnets Solution Using what you know from adding the picker and the button, match the magnet with the method or file that you’ll need to edit to add the text field.
We keep adding code to this .h file, but I still don’t know what a .h file really does! What gives?
It’s where you declare the interface and methods for a class.
All of  the classes we’ve used so far, like UITextField, NSString, and NSArray, have header files.
Take a minute to look through a couple and start thinking about what is happening in those files.
Fill in the blanks and explain what each line does.
Header files describe the interface to your class In Objective-C, classes are defined with interfaces in the header file.
It’s where you declare whether your class inherits from anything, as well as your class’s instance variables, properties, and methods.
Fill in the blanks and explain what each line does.
This is where we can declare instance variables of our class.
Here, we specify what we inherit from and what protocols we conform to.
Next comes the class name and, if it inherits from something, then a colon and the super class’s name.
Any protocols you implement go in angle brackets separated by commas.
Protocols are like Java interfaces or pure virtual classes in C++, and a class can realize as many as you want.
The syntax for instance variables is just like in C++: Basic types like int and float are used as-is; pointer types use an asterisk.
Once you’ve closed the field section of your interface, you can declare properties.
Design Magnets Solution (Continued) Using what you know from adding the picker and the button, match the magnet with the method or file that you’ll need to edit to add the text field.
The equals sign tells the compiler that we’re mapping our notesField property to the notesField_ field on the class.
OK, so if we declared a property in the .h file, then adding @synthesize in the .m file.
Using @property lets the compiler know we have a property, but that’s not enough.
Using the @synthesize keyword in the implementation files, we can have the compiler auto-generate the setter and getter method we talked about earlier.
The compiler will generate a getter, and, if  it’s a readwrite property, a setter and implement it based on the @property attributes declared in the .h file.
When you want the property to be modifiable by people.
The compiler will generate a getter and a setter for you.
Below is a list of  the most commonly used property attributes and definitions.
When you’re dealing with basic types, like ints, floats, etc.
The compiler just creates a setter with a simple myField = value statement.
This is the default, but not usually what you want.
The compiler will retain the value you pass in (we’ll talk more about retaining in a minute) and release the old value when a new one comes in.
You can still change the field value backing the property, but the compiler won’t generate a setter.
When you want to hold onto a copy of some value instead of the value itself; for example, if you want to hold onto an array and don’t want people to be able to change its contents after they set it.
This sends a copy message to the value passed in, then keeps that.
When you want the property to be modifiable by people.
The compiler will generate a getter and a setter for you.
When you’re dealing with basic types, like ints, floats, etc.
The compiler just creates a setter with a simple myField = value statement.
This is the default, but not usually what you want.
The compiler will retain the value you pass in (we’ll talk more about retaining in a minute) and release the old value when a new one comes in.
You can still change the instance variable value backing the property, but the compiler won’t generate a setter.
When you want to hold onto a copy of some value instead of the value itself; for example, if you want to hold onto an array and don’t want people to be able to change its contents after they set it.
This sends a copy message to the value passed in, then keeps that.
Q: How does the compiler know what field to use to hold the property value?
A: By default, the compiler assumes the property name is the same as the field name, however, it doesn’t have to be.
We prefer to explicitly name them differently so you know when you’re using the property versus the field.
Q: What about that nonatomic keyword? A: By default, generated accessors are multithread safe and use mutexes when changing a property value.
However, if your class isn’t being used by multiple threads, that’s a waste.
You can tell the compiler to skip the whole mutex thing by declaring your property as nonatomic.
Note that just making your properties atomic doesn’t mean your whole class is thread safe, so be careful here.
Below is a list of  the most commonly used property attributes and definitions.
Auto-generated accessors also handle memory management Objective-C under iOS doesn’t have a garbage collector and instead uses a mechanism called reference counting.
That involves keeping up with how many references there are to an object, and only freeing it up when the count drops to zero (it’s no longer being used)
An object can have more than one owner, and as long as it has at least one, it continues to exist.
If  an object doesn’t have any owners left (its retain count hits 0), it’s freed and cleaned up.
The properties we’ve declared so far have all used the retain attribute.
When the compiler generates a setter for that property, it will properly handle memory management for us, like this:
Write the code that Objective-C generates for each property declaration below.
Assume each one is backed by a field named myField_
Below is the code that the compiler will generate for each property.
Assume each one is backed by a field named myField_
I bet that release just lets go of the memory that your properties use up, right?
When you care about an object sticking around, you can take ownership of  it by sending it a retain message (and remember, an object can have multiple owners)
By sending an object a release message, you relinquish that ownership.
If  no one else owns the object, it will be cleaned up.
Because of this, it’s critically important that you don’t send release messages to objects you don’t own (that is, objects you haven’t already sent a retain message to)
You own objects you create with alloc, new, copy, or mutableCopy.
If  you create an object with alloc, new, copy, or mutableCopy, it will have a retain count of  1, and you’re responsible for sending a release when you’re done with the object.
You can also put the object in the autorelease pool if  you want the system to handle sending a release later.
Assume everything else could go away at the end of the event loop unless you take ownership.
This means that if you want to hang onto that object outside of  the method that got the object, you’ll need to take ownership by sending it a retain (and a corresponding release later when you’re done with it)
To keep your memory straight, you need to remember just two things Memory management can get pretty hairy in larger apps, so Apple has a couple of  rules established to keep track of  who’s in charge of  releasing and retaining when.
We’ll explain more about retain counts in just a bit—hang on.
There are times when you want to give up ownership of  an object, but you need it to stick around long enough for someone else to take it over.
In those cases, Objective-C has the concept of  an autorelease pool.
This is basically an array of  objects that the runtime will call release on after it’s finished processing the current event.
To put something in the autorelease pool, you simply send it the autorelease message (instead of  a plain release message):
It will still have the same retain count and stick around, but after the current event loop finishes, it will be sent a release message on your behalf.
You won’t want to use this all the time because it’s not nearly as efficient and releases objects as soon as you’re done with them.
It’s not a bad thing to use, but it’s better to explicitly retain and release when you can.
Memory management is definitely important on iOS, but that doesn’t mean it’s complicated.
Once you get the hang of  a few key principles, you’ll be able to structure your app so that it doesn’t leak memory and get you kicked out of  the app store.
When you create an object, it starts with a count of  1, and different things you do can raise and lower the count.
When the count reaches 0, the object is released and the memory is made available.
This is some of the memory management code that YOU have already written!
If another object (like this array) needs to hang onto your object, it will take ownership by sending a retain message to it....
Determine how many references are left at the end of the chunk of code and whether we have to send it a release for each string.
Determine how many references are left at the end of the chunk of code and whether we have to send it a release for each string.
This still has a retain count of 1 because of the alloc, but is now in the autorelease pool, meaning it will be sent a release automatically by the system later.
This will have a retain count of 1, but will be in the autorelease pool because we don’t own it (we didn’t get it via an alloc, new, or some form of a copy)
Next, it goes to 2 because “newArray” takes ownership by sending a retain when an object is inserted.
Then it goes back to 1 because an array will send a release to all its items when the array is destroyed.
Note the array wasn’t alloc’ed either, so it will be autoreleased, too.
Then one more retain from the dictionary, also not alloc’ed and will be autoreleased.
So, even though “sixth” has a retain count of 4, we, the developers, only need to send one release to “sixth” and let everything else clean up with the autorelease pool.
Determine how many references are left at the end of the chunk of code and if we have to send it a release for each string.
Design Magnets Solution (Continued) Using what you know from adding the picker and the button, match the magnet with the method or file that you’ll need to edit to add the text field.
We don’t need an action or a datasource for the notes field.
You’ll also need to put a label that says “Notes” in front of  the text field.
You will probably need to move the picker, labels, and button down a little.
Right-click on the File’s Owner icon and create a new Reference to “notesField.”
Test Drive Now that everything is saved, go back into Xcode and click Build and Run, and launch the Simulator.
Click here to write a note to customize the email....
Hey, we didn’t even have to do anything to make the keyboard show up for the text field.
I’ve been getting a lot of  attention recently with this whole iPhone thing.
Head First: So you have a pretty strong lineage, right? Why don’t you tell us a little about yourself ?
I’m an object-oriented language, so I have classes and objects, but I come from strong C roots.
Head First: What do you mean you come from C roots?
Objective-C: Well, nearly all of  my syntax is just like C syntax.
You can easily use other C libraries like SQLite with me.
Most obviously, I am an OO language, so classes, abstract interfaces (which I call protocols), inheritance, etc.
Objective-C: Well, malloc and free work just like they do in C, but I have a really nice memory management model for objects.
Head First: Ah—so you keep track of  who’s using what?
When there aren’t any references left, I’ll clean up the object and free up the memory for you.
You know those getter and setter methods you need to write for other OO languages to wrap fields in a class? Not here.
Not only that, you can tell me how you want to handle the memory associated with them.
Oh, and one of  my favorites: I can graft new methods onto classes without a problem.
We’re about out of time, so just one more question.
What’s up with all those “NS”s all over the place, like NSString and NSInteger?
Objective-C: Ah—those are all part of  the Cocoa Touch framework.
I mentioned my strong lineage earlier; most of  the core classes that people use on iOS come from Cocoa Touch, which is a port of Cocoa, which came from OpenStep, which came from NeXTStep, and that’s where the NS comes from.
The frameworks are written in Objective-C, but they’re frameworks, not really language things.
When you write for iOS, you’ll be using things like that all the time.
For example, instead of  using char*s for strings, you usually use NSStrings or NSMutableStrings.
Head First: This is great information! Thanks again for coming by, and best of  luck with the iPhone!
Q: What happens if I don’t retain an object I’ll need later?
A: Most likely, the object’s retain count will hit 0 and it will be cleaned up before you get to use it.
Now here’s the sad part: it might not crash your object on the simulator every time.
The simulator has a lot more memory to work with and behaves differently than a real iPhone, iPad, or iPod Touch.
Everything might look great until you put it on your device to test it.
Q: What if I release my object too many times?
When the reference count hits 0, the object will be released and memory will be freed.
Sending that now-freed memory another release message will almost certainly crash your application.
Q: What if my project works on the simulator and dies on the real phone? Could that be a memory problem?
Memory on a real device is much tighter than on the simulator.
We’ll talk more about debugging these and using Instruments to track memory usage and leaks in a later chapter.
Q: How can I check if I’m managing my memory effectively?
Q: What happens if I set things to nil? A: Well, it depends on what you’re setting to nil.
The variable is now nil, but the memory for the object it used to point to is still allocated and you’ve almost certainly leaked something.
Now, if it’s a property, things are probably a little different.
Q: Do I have to retain things I want to set on my properties?
That’s what the “retain” parameter is on the @property declaration.
If you put retain there, the property will automatically send values retains and releases when the property is set or cleared.
If you have a property with a retain parameter and it still has a value when your object is released, then whatever that property is set to hasn’t been freed.
You must send the instance variable an explicit release in your dealloc.
One more quick note: the automatic retain/ release ability of properties only works if you use the “.” notation or the generated setters and getters.
If you explicitly modify the field that backs the property, there’s nothing the property can do about it and it can’t retain/ release correctly.
Q: Doesn’t Objective-C have garbage collection like Java or .NET?
Apple didn’t provide garbage collection on iOS, however, so you need to fall back to reference counting with retain and release.
Q: What about malloc and free? Can I still use them?
Malloc and free work fine for basic blocks of memory as they do in C, but use alloc to instantiate classes.
Q: What’s with that init call that you always put after the alloc?
A: Objective-C doesn’t have constructors like other object-oriented languages do.
Instead, by convention, you can provide one or more init methods.
You should always call init on any class you allocate, so you almost always see them together as [[SomeClass alloc] init]
Q: How do I know if something retains my object, like an array or something?
Follow the memory rules that say if you got it from alloc, new, copy, or mutableCopy, you have to send it a release.
Otherwise, retain/ release it if you want to use it later.
Beyond that, let the other classes handle their own memory management.
The textField works great, but how do I get the keyboard to go away?
The keyboard is permanent? Go ahead, play with it and try to get the keyboard to go away.
Return won’t do it, and neither will clicking anywhere else on the screen.
How should the view communicate what has to happen to the user? What should the user see?
What does the View Controller need to do to make these View changes happen?
The user needs to understand what to do to make the keyboard go away, so change the “return” button to say “done”
The View Controller needs to receive the “done”message and then make the keyboard go away.
Q: Why didn’t we have to do anything to make the keyboard appear in the first place?
A: When the users indicate that they want to interact with a specific control, iOS gives that control focus and sets it to be the “first responder” to events.
When certain controls become the first responder, they trigger the keyboard to show automatically.
Conventions like using “done” to let the user hide the keyboard are discussed in Apple’s HIG.
There are lots more; “done” is just one of them.
This kind of back and forth between the View and View Controller is common and is going to show up all over the place.
Remember, a View Controller provides the behavior for a View.
Beyond the Text and Placeholder fields, changing some of the other options may hurt your usability and make Apple unhappy, so be careful.
Now, get the keyboard to talk to the View Controller...
Change the label on the return key Changing the name of  the button in the keyboard (so it’s “done” instead of  the “return”) is another option in the inspector.
The big thing that changing the label on the button brings to the table is that it clearly communicates to the user what to do to make the keyboard go away.
Click on the Return Key pop-up menu and pick Done.
When users click in the text field, iOS gives that control focus and assigns it as “first responder” for later events.
A component can get focus a number of  ways: the users explicitly tap on the control, the keyboard is set up so that the Return key moves to the next control they should fill out, the application sets some control to explicitly become first responder because of  some event, etc.
What a component does when it becomes the first responder varies by component, however; for a UITextField, it asks iOS to display the keyboard.
All this chatter between the application and components is fundamental to writing an application, and it all happens through message passing.
When one object wants to communicate with another object, it sends it a message.
Here, we’re sending the objectAtIndex message to the activities array.
And it responds to that message with the value @“sleeping”
In Objective-C, you send a message to an object and it responds to that message (basically returning a value from a method)
The Objective-C runtime turns those messages into method calls on objects or classes (in the case of  static methods), but get used to thinking about these as messages; you’ll see things like “the receiver of  this message will...” all over Apple’s documentation.
Now, let’s use message passing to get rid of  the keyboard when the user is done with it.
Ask the UITextField to give up focus In order to get the keyboard to go away, we need to tell the text field that the user is done with it.
We do this by asking the UITextField to resign its first responder status.
Sending messages in Objective-C is easy: you list the receiver of  the message, the message to send, and any arguments you need to pass along.
This is the receiver for the message, in our case, the notesField.
In our case, we have no arguments, so this is all we need.
See the Apple documentation for details on what messages each component will respond to.
You can pass messages to nil with no obvious problems.
Be careful of uninitialized variables or nil values coming back as other nil values when you debug.
Is that how the View is sending the View Controller information?
Yes! Our View Controller can respond to a number of messages like sendButtonTapped and viewDidLoad.
Now here’s the trick: the textField can send a message when the user taps the Done button on they keyboard.
We just need to tell it that our ViewController is interested in knowing when that happens.
This is a statement like any other—don’t forget the semicolon.
You’ve been handling messages since Chapter 1, but we really haven’t talked about the syntax to make it work.
Method declarations go in your header files and the implementation goes in the .m.
Here are some snippets from our sendButtonTapped implementation from InstaEmail.
Implementation files (.m) start with @implementation, then the name of the class you’re implementing.
Finally, provide the implementation of the method declared in our interface.
The “-” means it’s an instance method (whereas a “+” means a static or class method)
You specify the response type in parentheses before the message names.
The full message name (with arguments) is called a selector in Obj-C and tends to be long and descriptive.
If there are arguments to your message, follow the message name with a colon, then the type and name of the local variable.
The syntax for declaring a message in a header file is the similar to the implementation file, it just ends differentl.
Messages in Objective-C use named arguments In Objective-C, message names tend to be long and descriptive.
This really starts to make sense when you see arguments tacked on.
When you send a message with arguments, the message and argument names are all specified.
This method returns the number of  rows for a given component in a picker view.
Q: You keep switching terms back and forth between methods and messages.
In Objective-C, you send messages to objects and they respond.
The Objective-C runtime turns your message into a method call, which returns a value.
So, generally you talk about sending some receiver a message, but if you’re implementing what it does in response, you’re implementing a method.
A: In Objective-C, you can have a public name and a local name for arguments.
The public name becomes part of the selector when someone wants to send that message to your object.
The name after the type is the local variable; this is the name of the variable that holds the value.
Methods can have internal and external names for arguments; the external name is used when sending the message to the receiver.
So when something wants to send this message to our delegate, it creates a call like this:
Use message passing to tell our View Controller when the Done button is pressed The UITextField can tell our ViewController when the Done button was pressed on the keyboard; we just need to tell it what message to send.
You’ll need to declare an action in the .h file and implement it in the .m file:
Just like we did with the “Send Email” button, go back into Xcode and add this:
Now that we have an action that will be called when the Done button is pressed, we just need to ask the textField to resign its first responder status and it will hide the keyboard.
If  you right-click on the UITextField, you’ll bring up the connections.
The UITextField has a number of events it can raise, just like the round rectangular  button.
Take a second and check out the list that’s there.
Q: Why did we send the message back to the sender in our action and not to our notesField property?
A: Either one would work fine; they’re both references to the same object.
We used the sender argument because it would work regardless of whether we had a property that was a reference to our UITextField.
Q: You mentioned selectors, but I’m still fuzzy on what they are.
A: Selectors are unique names for methods when Objective-C translates a message into an actual method call.
It’s basically the method name and the names of the arguments separated by colons.
You’ll see them show up again in later chapters when we do more interface connecting in code.
A: “id” is an Objective-C type that can point to any Objective-C object.
Since Objective-C is a dynamically typed language, it’s perfectly ok with sending messages to an object of type “id”
It will figure out at runtime whether or not the object can actually respond to the message.
Q: What happens if an object can’t respond to a message?
This is the reason you should use strongly typed variables whenever possible—it will generate warnings at compile time, not just runtime problems.
However, there are times when generic typing makes a lot of sense, such as callback methods when the sender could be any number of different objects.
Method declarations go in the header (.h) file after the closing brace of an interface.
Method arguments are usually named, and those names are used when sending a message.
Use a “-” to indicate an instance method; use “+” to indicate a static method.
Sometimes you’ll come across a really tempting method that’s not defined in the Apple Documentation.
Using undocumented APIs will get your app rejected from the iTunes store.
It works! The keyboard goes away and you can play around with the text field and add some notes now.
Where’s the custom note? You’re ready to try out the custom field with a demo for Mike, but when he puts in his custom text and sends his message...
The custom note doesn’t do anything! It’s not going to show up in my email.
You can fix this with no problem now that you’ve gotten the hang of events and message passing...
Build the email with strings We need to incorporate the note text into our email.
In order to do that, we’re going to do a little string manipulation with the NSString class.
You’ve already built a message to create an email, but this time we have more text to include.
Before you refactor the code to send the email with the new text in it, let’s take a closer look at what you did in Chapter 2:
Now all you need to do is update this to include the text from the Notes field.
Take a look at the magnets on the next page and get it working.
This string didn’t come from alloc, new, copy, or mutableCopy, so it’ll be autoreleased.
Using the information you just learned and the magnets below, fill in the missing code.
Using the information you just learned and the magnets below, fill in the missing code.
We have to handle the case where the user didn’t enter any text.
If the text field is empty, its text property will be nil.
If notesField.text isn’t nil, it will use the value in notesField.text.
The ? is a ternary operator, just like in Java or C++, where if the expression is true it returns the first value; otherwise, it returns the second.
Test Drive Go ahead and build and run the app with the new text code in it.
It’s so great that we can talk about our feelings...
Your Objective-C Toolbox You’ve got Chapter 3 under your belt and now you’ve added.
The compiler will generate a getter and a setter for you.
You can still change the field value backing the property, but the compiler won’t generate a setter.
The compiler just creates a setter with a simple myField = value statement.
This is the default, but not usually what you want.
The compiler will retain the value you pass in and release the old value when a new one comes in.
For example, if you want to hold onto an array and don’t want people to be able to change its contents after they set it.
This sends a copy message to the value passed in, then keeps that.
Memory Management You own objects you create through an alloc, new, copy, or mutableCopy.
You need to take ownership of objects you get through other means if you want to stick around by sending them a retain message.
Assume everything else will be cleaned up later (pretend it has a retain count of 1 and is in the autorelease pool)
Objective-C cross Solution Practice some of  your new Objective-C terminology.
I like my coffee with two sugars, cream, a sprinkle of cinnamon, stirred twice, then...
We’ve written a cool app with one view, but anyone who’s used a smartphone knows that.
Some of the more impressive iOS apps out there do a great.
Look, I don’t have time for talking about my feelings.
I need to know a ton of drink recipes every night.
This chapter is about apps with more than one view.
What views would you need to have for a bartending app?
Sam needs a list of drink names and to be able to look up what’s in them.
This bar will have buttons, like the back and forward buttons in a web browser.
We’re not going to use the keyboard for now—it’s a reference app, and Sam just needs to read stuff...
So, how do these views fit together? Before you pick the template for our bartending app, take a minute to look at how you want the user to interact with the drink information.
We’re going to have a scrollable list of  drink names, and when the user taps on a row, we’ll show the detailed drink information using view #2, our detail view.
Once our user has seen enough, they’re going to want to go back to the drink list.
The navigation template pulls multiple views together For this app, we’re going to use a Navigation-based project.
The navigation template comes with a lot of  functionality built in, including a navigation controller, which handles transitions between views, and the ability to deal with hierarchical data.
Hierarchical data means there's layers to it, and each view gives you more detail than the previous one.
The built-in navigation controller provides back buttons, title bars, and a view history that will keep your user moving through the data without getting lost.
Add sugar to the rim of glass, pour ingredients into shaker...
Pour ingredients into a rocks glass filled with ice.The navigation template helps us to move through hierarchical data, starting with a table view that lists all the drinks.
The Navigation Controller provides transitions between views, with really nice animations.
The table view is built in The navigation template comes with a navigation controller and a root view that the controller displays on startup.
That root view is set up with a table view by default, and that works great for our app, so we'll keep it that way.
A table view is typically used for listing items, one of  which can then be selected for more details about that item.
The navigation controller provides a navigation bar.This is where you’ll find the back buttons, forward.
The table view provides an easy way to work with data.
It starts with an empty, scrollable list for the main view of your application.
Q: If the navigation template is about handing lots of views, why does it only come with one?
A: Most navigation-based applications start out with a table view and show detailed views from there.
The navigation template doesn’t assume anything beyond the initial table view.
Q: Which built-in apps on iOS use the Navigation control?
A: Contacts and Mail, which are both core iOS apps, use this design.
It’s a good idea to spend some time with those apps on your phone to see how the entire template is implemented.
For a neat twist, take a look at the Messages (SMS) app.
On the iPad, Mail uses navigation control, too, but it’s part of a split view-based application.
We’ll get into that more in a couple of chapters.
We're going to go on to use that field in a few different ways, so think about it again at the end of the app in a couple of chapters.
To make it look less editable, you can change the font or change the border.
Q: Do I have to use a table view for my root view?
A: No, it’s just the most common, since it provides a natural way to show an overview.
Table views are very easily customized, too, so some apps that might not seem like table views really are, like Notes or the iTunes store, for example.
Q: How does the navigation controller relate to view controllers?
A: We'll talk a lot more about this in a minute, but the Navigation Controller coordinates the transition between view controllers.
Typically, each top-level view is backed by a View Controller, and as views transition onscreen, the corresponding View Controller starts getting events from its view.
There's a whole view lifecycle that we'll work through that lets a View Controller know what's going on with its view.
Left-click on the navigation control and bring up the utilities.
Test Drive Add a title to the main view, and take a look at what your empty table view will look like.
This is the table view and will hold our drink list.
Add a title to the main view right away, and take a look at what your empty table view will look like.
If you don’t add the title here, you won’t have a back button later.
The navigation controller uses the title of the current view as the label in a back button when presenting a second, more detailed view.
Navigation controllers and table views are almost always used together to work with hierarchical data.
When you selected the navigation-based project as your template, Xcode created a different view setup than we’ve used in the past.
A table is a collection of cells The UITableView provides a lot of  the functionality we need right away, but it still needs to know what data we’re actually trying to show and what to do when the user interacts with that data.
A table view is easy to customize and is set up by the template to talk to the datasource and delegate to see what it needs to show, how many rows, what table cells to use, etc.
The navigation controller, not the table view, provides the navigation bar.
Since we’re editing the view now, there’s no navigation control.
Table views have built-in support for editing their contents, including moving rows around, deleting rows, and adding new ones.
Table views can tell you when your user taps on a cell.
It’ll tell you the section and row that was tapped.
We’re using the default table view cell, but you can create your own and lay them out any way you want.
Look through some of the apps you have on your device.
What are some of the most customized table views you can find? Are they using sections? Are they grouped? How did they lay out their cells?
Remember that MVC pattern from Chapter 1? Now we're adding in the Model piece with a datasource for our drinks list.
This is where we create table cells and populate them with the drink list information.
This method is called when the table view needs a cell.
These methods tell the table view how many sections we have and how many rows are in each section.
The auto-generated code needs to be modified to tell the table that it will have the same number of  rows as there are drinks in the array.
Modify the implementation file under this line: // Customize the number of  rows in the table view.
Implement the code that we talked about in “Table Cell Code Up Close” so that the table gets populated with the items from the array.
Q: How do cells get into that reusable list to begin with?
When cells scroll off the screen (either the top or the bottom), the table view will queue up cells that are no longer needed.
When it asks the datasource for a cell for a particular.
When you do more complex table views, you can create custom cell types depending on what.
You use the cell identifier to make sure that when you ask for a reusable cell, the table view gives you back the type you expect.
The identifier can be anything you want—just make sure you have a unique name for each unique cell type you use.
This is the active view with the table cells that are currently visible.
As the user scrolls, some cells slide off the screen.
The cells that are off the view go into a bucket until iOS needs memory or the table view can reuse them when the user scrolls.
Wait, memory in iOS is a big deal, right? Three drinks is no problem, but what happens if we add a whole bunch of drinks?
Each drink gets its own temporary cell The UITableView only has to display enough data to fill an iPhone screen—it doesn’t really matter how much data you might have in total.
The UITableView does this by reusing cells that scrolled off  the screen.
Like everything else on iOS, the UITableView does have to worry about memory.
So, how does it balance concerns about memory with an unknown amount of  data to display? It breaks things up into cells.
In this part of the MVC pattern, the datasource (M) updates the view (V) whenever it has to scroll to a new row.
Now it tells the table view that we have the same number of rows as the number of items in the drinks array.
We’re using the instance variable directly here since we already own th.
Save it and run it, and you’ll see the three drinks in your app in the main view.
Q: You mentioned the table view’s datasource and delegate, but why didn’t I have to conform to anything like we did with UIPickerView?
Normally you would, but the navigation-based template we used has already set this up.
If we weren’t using a template, you’d have to set these up yourself (we’ll revisit this again later in the book)
A: No—both NSMutableArray and NSArray can be initialized with values when you create them.
We’re using an NSMutableArray because we’re going to manipulate the contents of this array later.
Q: What’s the nil at the end of the drink names when we create the drink array?
It uses nil to know it’s reached the end of the arguments.
The last element in the array will be the value before the nil—nil won’t (and can’t) be added to the array.
A: The @ symbol is shorthand for creating an NSString.
NSArrays store arrays of objects, so we need to convert our text names (char*s) to NSStrings.
We do that by putting an @ in front of the text constant.
Q: When we customized the table view cells, we used the cell.textLabel.
Are there other labels? What’s the difference between cell.textLabel and cell.text?
A: Before the iPhone 3.0 SDK, there was just one label and set of disclosure indicators in the default cell, and it was all handled by the cell itself.
You just set the text you wanted on the cell.text property.
Nearly everyone wanted a little more information on the table cells, so in the iPhone 3.0 SDK, Apple added a few different styles with different label layouts.
Once they did that, they introduced specific properties for the different text areas, like textLabel, detailLabel, etc., and deprecated the old cell.text property.
You shouldn’t use cell.text in your apps—Apple will likely remove it at some point in the future.
We’ll talk more about the other labels later in the chapter.
Q: You mention that we can use section headers and footers—how do you specify those?
There are optional methods you can provide that return the title for section headers and the title for section footers based on the section number.
Q: What’s the difference between a plain table view and a grouped table view?
In a plain table view, like the one we’re using, all the sections touch each other and are separated by the section header and footer if you have them.
In a grouped table view, the table view puts space between the sections and shows the section header in bigger letters.
Take a look at your contact list, then select a contact.
The first view, where all of your contacts are listed together and separated by letters, is a plain table view.
The detailed view, where the phone numbers are separated from email addresses, etc., is a grouped table view.
Q: So why are you putting underscores after instance variables again?
A: Remember there are really different things in play when we talk about instance variables and properties.
We use _'s after those names to help indicate that those are actually internal class information, not really something we want other classes poking around with (we also mark them as private so the compiler enforces that for us)
By declaring something as a property, we get the ability to use the dot notation.
Memory management, copying values we want copied, etc., are all handled in those accessors.
To make sure we don't accidentally refer to an instance variable when we really want the functionality of the accessors and vice-versa, we name the instance variable with an '_' and property without.
Can’t we just import the list Sam sent us somehow?
We could, but not the way we’re set up now.
Since the drinks are populated with an array that’s hardcoded into the implementation file, we can’t import anything.
What would work well is a standardized way to read and import data; then we would be able to quickly get that drink list loaded.
How can we speed up getting 40 drinks in our list?
Plists are an easy way to save and load data Plist stands for “property list” and has been around for quite a while with OS X.
In fact, there are a number of  plists already in use in your application.
This is created by Xcode when you first create your project, and besides the app icons, it stores things like the main nib file to load when the application starts, the application version, and more.
Xcode can create and edit these plists like any other file.
Some of these items are obvious, like the icon file and the main.
Others are less obvious, but we’ll talk more about them in later chapters.
Before you import Sam’s list, let’s create a sample plist that’s the same format.
We’ll make sure we get that working properly, and then pull in Sam’s list.
Built-in types can save and load from plists automatically All of  the built-in types we’ve been using, like NSArray and NSString, can be loaded or saved from plists automatically.
We can take advantage of  this and move our drink list out of  our source code and into a plist.
With the sample list created, we can use it for testing before we get the big list.
Plists are used in Mac development as well as iOS development, so they’re listed here.
Ask the app bundle for a path to our DrinkArray plist.
Test Drive After you’ve finished up these two things, go ahead and build and run.
It should look the same, with just the three drinks.
Arrays (and more) have built-in support for plists Changing the array initialization code to use the plist is remarkably easy.
Most Cocoa collection types like NSArray and NSDictionary have built-in support for serializing to and from a plist.
The only piece missing is telling the array which plist to use.
Once this list works, head over to http://www.headfirstlabs.com/ books/hfiphonedev/ and download the DrinkArray.plist file.
It has the complete list of the drinks from the Head First Lounge.
Drop this in on top of your test plist, rebuild DrinkMixer, and try it out!
By moving the drinks out of the code and into an external file, you can change the drink list without needing to touch a line of code.
PLists are just one way to save data on the iOS —we’ll talk about others later in the book.PLists work great for built-in types.
If you’re going to be using custom types, you will need to write some serialization code.
How are we going to get from the list to the detail view? And how are we going to display the details?
Now we just need to get that detail view all set up, right?
The entire list of  drinks is great, but Sam still needs to know what goes in those views and how to make them.
That information is going to go in the detail view that we sketched up earlier.
Use a detail view to drill down into data Earlier, we classified DrinkMixer as a productivity app and we chose a navigation controller because we have hierarchical data.
We have a great big list of  drinks loaded, but what Sam needs now is the detailed information for each drink: what are the ingredients, how do you mix them, etc.
Now we’ll use that navigation controller to display a more detailed view of  a drink from the list.
The standard pattern for table views is that you show more information about an item when a user taps on a table cell.
We’ll use that to let the user select a drink and then show our detailed view.
The detail view follows the same MVC pattern as our other views.
Detail The detail view shows all the elements that make up a drink: the ingredients and how to mix them.Since the detail view.
When the user taps on a drink, we’ll display the detail view.
It will tell the nav controller to show the detailed view.
UITextField for the drink name It will be populated with “Name:” and the drink info, so we don’t need a label.
A closer look at the detail view We sketched out the detail view earlier—but let's look more closely at what we’re about to build.
Start building your detail view by creating the files and code you’ll need, then put it together in Interface Builder and wire it up.
Use the object library to drag and drop the elements that you need and build the view we sketched out earlier.
Hint: to reserve the space for the navigation controller, just bring up the Utilities Panel and choose the Attributes Inspector.
That will make sure that you lay out your view below the navigation bar.
Write the code to handle the declarations and outlets for the new properties.
Don’t forget to create the instance variables then synthesize and release everything.
Just like we did for InstaEmail, use Interface Builder to link the controls to the properties.
To create the new view, you need a new *.xib file, as well as the supporting header and implementation files.
The file type is a Cocoa Touch Class type, and it’s a UIViewController subclass.
Using the inspector, find the checkbox that makes the fields uneditable.
Navigation controllers are a good way to manage multiple views.
Q:We keep drawing the datasource, view, and View Controller as separate things, but then we stick the datasource and controller together into the same class.
In general, you’ll have a view defined in a xib, a View Controller backing it, and a set of data it needs to work on.
Whether these are combined into one class or not really depends on the complexity of your application.
If you’re not using Interface Builder, you can go completely off the deep end and have your single class create the view programmatically.
Conceptually, however, you still have a view that’s calling into the View Controller when things happen.
Likewise, you usually have one or more datasource protocols being realized somewhere that are providing data to your view.
Q: Why do we have to move the *.xib file into the Resources group?
A: You don’t have to, but we recommend it to help keep your code organized.
Xcode really doesn’t care; it’s just important that you know how your code is organized and you can find what you’re looking for.
Reusing a structure that others will recognize is a good practice so people can pick up your code quickly and you can understand their code.
We’ll cover the more common ones in this book in different projects.
The one you’re using now, plists, is the simplest, but it does limit what you can save and load.
That doesn’t make it bad; if it works for what you need, it’s a fine solution—it’s just too limited for everything.
There’s a serialization protocol called NSCoding that works well for custom objects, but can make version migration a challenge.
This used to be the preferred way to go if you had a lot of data or needed to search and access it without loading it all into memory.
However, with the iPhone 3.0 SDK (now just iOS), Apple introduced Core Data.
It’s definitely not trivial to get started, but it’s really powerful.
Q: Why didn’t you use a label for the name field?
A: UITextFields allow you to have placeholder text that appears in the field when it’s empty.
Rather than using up screen space with a Name label, we chose to use the placeholder.
If the meaning of the text shown on the screen is obvious to the user, consider using placeholder text.
Q: So why didn’t we use it for the ingredients and directions?
A: We could have, but since those contain multiple lines of text, we wanted to break them up with labels clearly showing what they were.
Ultimately it’s an aesthetic and usability decision, not a technical one.
Make sure that you have the Cocoa Touch Class line selected under iOS.
After clicking Next, you can confirm the subclass of UIViewController.
In our case, we need both the nib and the supporting files, so leave the "With XIB for user interface" box checked and click Next.
Xcode will create all your files in the DrinkMixer group, keeping them with the other class files.
After this, you should have a working (but still empty) detail view.
This is the same UITextField that we used in InstaEmail.
Write the code to handle the declarations and outlets for the new fields.
After this, you should have a working (but still empty) detail view.
Use the drag and drop from the fields into the code to make the link.
You can right-click on File's Owner when you're finished to see all the outlets.
We need to disable both the UITextField and the two UITextViews to prevent the user from making changes.
Simply click on each field and toggle the Enabled or Editable checkboxes to off.
Once those changes are made, the keyboard issue goes away, because there won’t be one!
You just put in a lot of work, and it’s a good time to check for errors.
You won't see a difference yet, just the drinks list again...
When your users browse through the drink information, they’re going to need to switch between the list and detail views.
Take a few minutes to think about how to do that while keeping the user from getting lost.
How can we keep track of  what view to show?2
How does the detail view know what drink to show?3
How do you get the user back to the table view?4
We still need to get that detail view to load when Sam selects a drink.
When your users browse through the drink information, they’re going to need to switch between our list and detail views.
Think about how we do that and keep the user from getting lost.
How can we keep track of  what view to show?2
How does the detail view know what drink to show?3
How do you get the user back to the table view?4
The user is going to tap on the cell of the drink name.
That’s based on the table cell that the user selects.
The Navigation Controller can supply a back button that can get us back to the main view.
In the simulator, Xcode will generate a back button with the text that says “Drink Mixer”
A view stack for moving between views As users move back and forth, you can ask the Navigation Controller to display the appropriate view.
The Navigation Controller keeps track of  where the users are and gives them buttons to go back.
A navigation bar for buttons and a title The Navigation Controller interacts with the navigation bar to display buttons that interact with the view being shown, along with a title to help the users know where they are.
A navigation toolbar for view-specific buttons The Navigation Controller can display a toolbar at the bottom of  the screen that shows custom buttons for its current view.
Since the views get told when they’re shown and hidden, that’s all we need for our app.
Use the Navigation Controller to switch between views Now that we’ve got the table view populated and the detail view built, it’s time to manage moving between the two views.
The navigationbased template comes preloaded with the functionality we need:
Now we need to get the Table View and Nav Controller working together to display the detail view.
View Controller When the delegate method is called, our RootViewController (the delegate) needs to create a.
Navigation Controllers maintain a stack of View Controllers We’ve been dragging the Navigation Controller along since the beginning of  this project, and now we finally get to put it to use.
The Navigation Controller maintains a stack of  views and displays the one on top.
It will also automatically provide a back button, as well as the cool slide-in and-out animations.
We’re going to talk more about the whole Navigation Controller stack in the next chapter, but for now, we’re just going to push our new view onto the stack and let the controller take care of  the rest.
We just need to figure out how to get that new view.
Once the new view is created, we’ll use the Navigation Controller to push the view onto the screen.
Here's where things get interesting: our RootViewController is our delegate, so it needs to hand off control to a new View Controller to push the detail view onto the screen.
Instantiate a View Controller like any other class The only piece left to create is the View Controller for the detail view.
Instantiating a View Controller is no different than instantiating any other class, with the exception that you can pass in the nib file it should load its view from:
Let’s put all of  this together by implementing the callback in the delegate and creating the new View Controller to push onto the stack:
Since we’re going to create the new View Controller, we need to include its header.
Here’s the delegate callback—the indexPath tells us which row (drink) was selected.
You have this method already started, just edit the existing code.
Try clicking in the text fields—there's no keyboard because they’re not editable!
Now that both views can talk to each other, go ahead and build and run.
All that’s left is to get the ingredients and directions in the detail view, and we’ll have a bartender’s brain.
To save you from having to type in the ingredients and directions, we put together a new file with all the extra information.
The problem is we can’t just jam that information into an array.
To add the drink details to this version, we need a different data model.
Which options below are possible ways to load the drink data?
Which of these options is the best for DrinkMixer? Why?
Use dictionaries in our plist to hold the drink details.
So, now we can get to the detail view from the drink list, but there aren’t any details in there.
We don’t have that info in our plist, do we?
Our current drink plist is just a single array of drink names.
That worked great for populating the table view with just drink names, but doesn’t help us at all with drink details.
For this plist, instead of  an array of  strings, we created an array of  dictionaries.
Within each dictionary are three keys: name, ingredients, and directions.
Each of  these have string values with the corresponding information.
Since NSDictionary adopts the NSCoding protocol, it can be saved and loaded in plists just like our basic array from before.
Which options below are possible ways to load the drink data?
Use dictionaries in our plist to hold the drink details.
Which of these options is the best for DrinkMixer? Why?
We could use a database to store drink information, but since.
We already have a plist of strings—switching over to a plist of dictionaries won’t be much work and gives us a data structure that can hold the drink info.
This would work too, but has the same hurdle as using a DB.
We’re not parsing any XML right now, so we’d have to define the schema, then add parsing code.
This is basically the worst of all the optio nswe’d have to make sure multiple arrays line.
Since we already have code written that uses plists, we can change our plist to have an array of dictionaries instead of an array of strings without a lot of effort.
This way we don’t have to introduce SQL or XML into our project.
However, we do lose out on the strong typing and data checking that both SQL and XML could give us.
Since this is a smaller project, we’re going to go with dictionaries.
Test Drive Build and run the application, but you should pay close attention.
Umm, not that we think anything bad is going to happen, just, well, because...
It has a different name, so you’ll need to make a couple of quick modifications.
Open up the new plist in Xcode (again, in the resources directory), and look at what it comes with—all that data is ready to go!
Go into the code and change the references from DrinkArray to DrinksDirections.
What is that? A: NSCoding is a protocol that provides an API for encoding and decoding objects.
A lot of the basic container types like NSArray NSDictionary conform to this protocol; that’s why we can serialize them in and out of a plist.
You can conform to this protocol on your own custom objects as well.
Q: Where did the back button in the detail view come from? We didn’t do that...
A: It’s automatic functionality that comes with the Navigation Controller.
When you added a title for the main view, the Navigation Controller kept track of that name as part of the view stack for navigation, and added a back button with the title in it.
That’s not our problem, though: at this point our code is (at least it should be) warning and compile-error-free.
The good news is that when an app crashes in the Simulator, it doesn’t go away completely (like it would on a real device)
Xcode stops the app right before the OS would normally shut it down.
Debugging—the dark side of iOS development Something has gone wrong, but honestly, this is a pretty normal part of  the development process.
There are lots of  things that could cause our application to crash, so we need to figure out what the problem is.
Warnings can help find problems first In general, if  your application doesn’t build, Xcode won’t launch it—but that’s not true for warnings.
Xcode will happily compile and run an application with warnings and your only indication will be a little yellow yield signs in the gutter of  the Xcode editor.
Two minutes spent investigating a warning can save hours of  debugging time later.
Sending a message to an object that it doesn’t claim to understand (from a typo or an autocompletion error) will trigger warnings.
Your app will compile, but will likely end up in a runtime exception when that code is executed.
They will appear in the gutter next to the offending code.
They'll also show up in the corner of the editor window.
First stop on your debugging adventure: the console We need to figure out why our app crashed, and thankfully, Xcode has a lot of  strong debugging capabilities.
For now we’re just going to look at the information it gave us about the crash, but later in the book, we’ll talk about some of  the more advanced debugging features.
Since you ran the program in the simulator, Xcode is going to bring up the debugging pane at the bottom of  the editor.
You'll probably want to resize it to make the log easier to review.
The console has the information about what happened that caused our application to be shut down.
The console also gives us a stack trace of where our application was, but there’s a mu.
The console tells us that our app was shut down because of an uncaught exception, and what that exception was.
Interact with your application while it’s running Xcode 4 is a very powerful debugging tool.
This information is printed into the console and can help you diagnose problems quickly.
The console isn’t just read-only, though; it is your window into your running application.
We’ll see log messages displayed in the console, and when your application hits a breakpoint, you’ll be placed at the console prompt.
From there you can use debugging commands like print, continue, where, up, and down to inspect the state of  your application.
And when it’s about to stop running In this case, we’re dealing with a nearly dead application, but the idea is the same.
Since DrinkMixer has crashed, Xcode provides you with the basic information of  what went wrong.
In our case, an “unrecognized selector” was sent to an object.
Remember that a selector is basically a method call—it means that some code is trying to invoke methods on an object and those methods don’t exist.
The console debugger is actually the gdb (GNU debugger) prompt, so nearly all gdb commands work here.
The console prompt lets you interact with your application at the command line.
To see this output, you'll need to select "Debugger Output" from this dropdown box.
Xcode supports you after your app breaks, too So far we’ve used Xcode to write code and compile and launch our applications.
Its usefulness doesn’t stop once we hit the “Build and Debug” button.
First, we can set breakpoints in our code to let us keep an eye on what’s going on.
Simply click in the gutter next to the line where you want to set a breakpoint.
Xcode will put a small blue arrow next to the line and when your application gets to that line of  code, it will stop and let you poke around using the console.
This switch indicates whether the breakpoints are on or not.
Once your app hits a breakpoint, Xcode will insert Step Into, Step Over, Continue, and Debugger buttons to let you walk through your code.
Slide the scrubber all the way to the right to see the full stack from the app...
Since we know that we’re having a problem near the array, try setting a breakpoint on the line that creates the array.
Then build and run the app again and see what happens.
The Xcode debugger shows you the state of your application The debugger shows your code and also adds a stack view and a window to inspect variables and memory.
When you click on a stack frame, Xcode will show you the line of  code associated with that frame and set up the corresponding local variables.
There isn’t anything in the debugger window you couldn’t do with the console, but this provides a nice GUI on top of  it.
If you click on a frame, Xcode will show you the corresponding code.
Here are the Step and Continue buttons to let you walk through your code.
Test Drive When you step over the breakpoint at the point where you load the array, everything is OK:
To set a breakpoint, you’ll need to click in the gutter, here.
What the heck is going on? Our application is crashing, and it’s not at the array loading code, so get back into Xcode.
It will show you the line that’s causing the problem, can you see what’s wrong?
MultipleViews cross Take what you’ve learned about the Navigation Controller and multiple views to fill in the blanks.
The set of views that the nav controller deals with.
A template that combines a table view and nav controls.
A more versatile way to manage data beyond an array.
To use a new class you need to ___________ it.
The @ symbol is shorthand for creating one of these.
Your iOS Toolbox You’ve got Chapter 4 under your belt and now you’ve.
Come with support for editing contents, scrolling, and moving rows.
Can be customized so your cells look like more than one column.
Plists: Files that can be created and edited in Xcode.
Are good for handling data, but have some limitations—we’ll cover another option, Core Data, in a couple chapters coming up.
Xcode: Has a built-in console with debugging and logging information.
Gives you errors and warnings as you compile to identify problems.
Has a built-in debugger that allows you to set breakpoints and step through the code to find the bug.
Navigation Controller: Maintains a view stack for moving between view controllers.
Can support custom toolbars at the bottom of the view as needed.
MultipleViews cross Solution Take what you’ve learned about the navigation controller and multiple views to fill in the blanks.
The set of views that the nav controller deals with.
A template that combines a table view and nav controls.
A more versatile way to manage data beyond an array.
To use a new class you need to ___________ it.
The @ symbol is shorthand for creating one of these.
That’s the story of every app! You get some functionality working, decide to add something.
Developing an app isn’t always ever a linear process, but there’s a lot to be learned along.
This soup would be even better with the perfect cocktail, maybe a Neon Geek...
DrinkMixer has two views: a table view of the drinks and a detail view about each individual drink.
Sam wanted an app to make his bartending work easier.
You got one up and rolling pretty quick, but hit a snag filling in the details for each drink because of  a plist of  dictionaries.
When we last left DrinkMixer, you were in the middle of debugging it...
The debugger stopped our application and displayed the debugging console.
By setting a breakpoint in our code, what we discovered at the end of  Chapter 4 is that before your app imported the file, there was no crash; so far so good.
Let’s walk through loading our plist and make sure that works by typing next twice.
The first “next” sets up the path to the plist, the second one actually loads the data.
We told the debugger to let DrinkMixer execute the next two lines.
It made it past loading the plist, so let’s let it continue running...
Let’s have the application continue running and see where it fails.
Use the debugger to investigate the crash We can reliably get DrinkMixer to crash, and it doesn’t seem to be our plist loading code.
Xcode has suspended our application right before iOS shuts it down, so we can use the debugger to see exactly what it was trying to do before it crashed.
Switch back to the debugger and take a look at the stack on the left.
This is the call stack that led to the crash.
Trying to continue now will just keep failing—DrinkMixer has been stopped by iOS.
Using what you’ve learned so far, figure out what’s going on!
What dictionary is it talking about? Where is it coming from?
Who’s sending messages to the dictionary? Why did we get an unrecognized selector?
We’re trying to stuff a dictionary into a string Putting a dictionary into the text field of  the label, which wants a string, isn’t going to work.
Our previous array was an array of  strings, so that code worked fine.
Now that we have an array of  dictionaries, we need to figure out how to get the drink name value (a string) out of  the dictionary, and then assign that to the text label.
As we saw earlier, dictionaries store their values using keys; they’re just a collection of  key-value pairs.
Using what you’ve learned so far, figure out what’s going on!
What dictionary is it talking about? Where is it coming from?
Who’s sending messages to the dictionary? Why did we get an unrecognized selector?
The dictionaries are coming from the plist! When we load the plist, we now have an array of dictionaries instead of an array of strings.
Messages are being sent to the dictionary when we try to set the cell’s label text.
It’s actually the label sending it a message (see the next stack frame, it’s code in UILabel)
It’s sending messages as though the cell label text were a string.
But now we’re assigning a dictionary to the label text!
Instead of assigning the array value right to the text label, you’ll need to pull out the name value from the appropriate dictionary.
Go ahead and make the changes below to your app.
After this, it should know that you’re using an array of dictionaries, not strings—and the detail view should have a reference to the drink it should display.
Add a reference to a drink dictionary in the detail view.
Don’t forget about the NSDictionary documentation if you want to know more about dictionaries.
Update your code to handle a plist of dictionaries Armed with the knowledge of  how the dictionaries are put together, we can use this information to populate the detail view, too.
If  you give the detail view controller the dictionary of  the selected drink, it can populate the view’s fields before the view is shown to the user.
We need to get that dictionary to the datasource for the detail view.
Go through the code and make sure that you’ve got everything right...
Test Drive Now that we’ve told DrinkMixer how to deal with dictionaries, go ahead and build and run.
It’s working again! Now that it’s not crashing, it’s time to fill in the details.
The Detail View needs data Now that you’ve figured out how to deal with dictionaries, it’s time to fill in the drink details.
But getting the details out of  the array of dictionaries to give to the datasource requires another step.
The datasource needs the dictionary information for the selected drink...
Since we’re going to need the name, ingredients, and directions keys in the View Controller, we should clean up the code to start using real constants.
Create a new file called DrinkConstants.h (right-click on the DrinkMixer folder, then choose New File, and then choose Other and an empty file)
The View Controller needs direct access to the datasource, and the easiest way to get to that data is going to mean some quick code refactoring.
In the root View Controller, after you instantiate the detail View Controller when a cell is tapped, you need to set the drink property on the new controller to the selected drink.
Add code to the detail View Controller to populate values on the UI controls.
Before the Detail View appears, the View Controller should use the drink dictionary to set the contents of  the name, ingredients, and directions components.
Don’t forget to use the constants you just set up!
The other keys are key Right now we’re just pulling the name of  each drink into the app using the name key.
In order to populate the ingredients and directions, we need to use the other keys.
You could just type those right into our code, but you’re a better developer than that, so let’s pull them up into constants.
The only thing left is getting the proper dictionary to the detail view controller so it can pull the information it needs.
Here’s all the added code to make the Detail View work.
Add a method to the detail View Controller to populate the fields.3
We need to make sure we delegate this up to the UIViewController superclass before we do anything else.
Add this whole line to grab a dictionary from the array.
Q: We re-create the Detail View every time someone taps on a drink.
A: For DrinkMixer, it really won’t matter too much; since the view is pretty lightweight, we won’t suffer too much overhead recreating it when a drink is tapped.
However, for best performance, you can refactor it to reuse the same detail View Controller and just change the drink it should be showing when a row is tapped.
Q: Why did we have to pull out the dictionary key names into a separate file?
A: Having magic string values in your code is generally a bad idea—no matter what programming language or platform you’re using.
By pulling them up into constants using #define, they are checked by the compiler.
Q: I looked at the NSDictionary documentation and there’s a valueForKey: and an objectForKey:
The subtle catch is that NSDictionary usually just turns a call to valueForKey: into a call to objectForKey, and it looks like either one will work.
However, valueForKey actually checks the key you pass it and has different behavior depending on your key.
That’s almost never what you want (unless you’re doing Cocoa binding stuff, of course)
Is that app up on the App Store? Then I can just download it on my phone and start making even more tips!
Looks like there’s a market there! A quick submission to Apple and...
Sam, ready for your app to make his (and your) wallet fatter...
Later in the book, we’ll take you through the process of  preparing an app for.
Seriously, this can and will happen if you don’t follow the HIG.
We have a usability problem We know that the user needs to touch the name of  the drink to see the details about each individual drink, but how is the user supposed to know that? The HIG has a number of recommendations for how to deal with drill-down, hierarchical data.
We’re already on the right track using table views, but the HIG has a number of  additional recommendations for helping the user understand how to navigate the app.
It’s time to dive into the HIG and figure out what went wrong.
Take a look at disclosure indicator elements—when should we be using these?
Here is the root view that users see, the table view.
When the user taps, the View Controller hands off control to the detailed view.
The HIG mentions detail disclosure buttons and disclosure indicators—which should we use? Why?
Table cells have a number of built-in usability items that help users understand how to use your app—even if it’s the first time they’ve run it.
We’re already using the Navigation Controller’s back button to help the user know how to get back to where they came from...
So, what exactly is the detail disclosure button, and where does it go? Let’s look a little deeper in the HIG.
In the HIG, the “Table View” section, you can pretty quickly find out why you’re in violation over those disclosure indicators:
DrinkMixer uses default cells, but you can easily customize your cells for a different app, besides just adding detail disclosure buttons.
Even though the table only supports one column, you can make it look like more by adding a thumbnail, for example.
You can also adjust the font sizes to open up some room for each table cell if  you need to.
Most really polished apps use some kind of  table cell customizing, so keep that in mind while you’re looking through the API.
For now, we just need to add the disclosure button to our cells to indicate that there’s more information available if  a user taps on them.
Depending on what cell style you use, it can show up in different places, fonts, and colors.
The HIG mentions detail disclosure buttons and disclosure indicators—which should we use? Why?
It’s time to dive into the HIG and figure out what went wrong.
Take a look at disclosure indicator elements—when should we be using these?
Adding a detail disclosure indicator is simply a matter of  telling the cell what type of  accessory icon it should use.
Take a look at the UITableViewCell documentation for some of  the other options.
Just set the accessory type to the detail disclosure indicator.
There’s just one quick line of  code to set the cell’s accessory type when we configure the cell:
Test Drive Go ahead and build and run...make sure it’s working!
Test Drive One little line of code fixed all of your App Store approval issues.
There are those disclosure indicatorsnow the user knows what to do!
After resubmitting to the App Store, DrinkMixer is up on iTunes!
This app is great! I’m going to use it every night.
Sales were going strong But then bad reviews started coming in.
I’m going to switch to iDrinkit’s more expensive, but it lets me add new drinks and customize my list.”“I don’t like any of the drinks on the.
Think about how you originally designed DrinkMixer, what’s not working based on the feedback, and figure out what you’ll do next.
Given the structure of  DrinkMixer, how would you refactor the code to fix the problem?2
Is there an easy way to fix the code? A hard way?3
Think about how you originally designed DrinkMixer, what’s not working based on the feedback, and figure out what you’ll do next.
The easiest way to fix the problem is to update the app so users can add more drinks to the list.
We could add a new view that lets users enter their drink information.
It could look like the detail view, but allow them to type in the information they want.
We’ll have to save that new information and update the table to show the new drink.
There are lots of hard ways and probably a few good “easy” ways.
In general, the easiest way for us to add this functionality is to reuse as much of what we’ve already done as possible.
We can definitely take advantage of our Navigation Controller, and let’s see if we can’t do something useful with our DetailDrinkView too...
How would you go about implementing a view where users can add drinks to DrinkMixer?
Given the structure of  DrinkMixer, how would you refactor the code to fix the problem?2
Is there an easy way to fix the code? A hard way?3
Some kind of button in the Navigation Controller to kick off a new view.
Add a new toolbar with some buttons below the Nav Controller.
You’d have room for an add button and others, when you need them.
Here is the table view for DrinkMixer with two possible designs.
Based on aesthetics, usability, and standard iOS App behavior, which one is better for showing the users where they should add a drink?
Because by putting the icon in the Nav Controller, you don’t take space away from.
Option #2 makes the interface a bit more cluttered and requires more code.
This type of interface is good when you have several new views to add, not just one.
There’s also built-in support for that button in the Nav Controller already.
The toolbar will cover up part of the table view, too.
Based on aesthetics, usability, and standard iOS App behavior, which one is better for showing the users where they should add a drink?
Users will be able to tap the + button to add a drink.
Using Xcode, add the button to the Nav Controller and the associated IBActions and IBOutlets.
Scroll through the library and drag a Bar Button Item to the Main Window (this will add it to the list after the Table View)
It won’t show up on the Navigation Controller in the editor—we’ll need to add code so it shows up at runtime.
Add the instance variable and property declaration for addButton and IBAction for addButtonPressed.
Finally, pull up the inspector in the Utilities pane for the Bar Button Item and change the Identifier to Add.
It won’t show up because the Navigation Controller in Interface Builder is SIMULATED, not real.
Use Navigation Controller buttons to add drinks So far we’ve used the Navigation Controller to move between views.
But if  you’ve spent much time with other iOS apps, you know it’s capable of  much more.
Since a UITableView is almost always embedded in a Navigation Controller, table editing is usually done through buttons on the controller itself.
Let’s start out by adding a + button to the Navigation Controller that will let the users add a drink when they tap it.
Using Xcode, add the button to the Nav Controller and the associated IBActions and IBOutlets.
Scroll through the library and drag a Bar Button Item to the Main Window (it will get added to the list)
Add the instance variable and property declaration for addButton and IBAction for addButtonPressed.
We’ll start just by logging the button press so we can test it before implementing anything further...
Finally, pull up the inspector for the Bar Button Item and change the Identifier to Add.
Put this inside of ViewDidLoad, it’s a tweak of the code that’s stubbed out.
The button shows up in the view, but now what?
The button works! Now you get an affirmative message in the console...
What do we need for the user to be able to enter a new drink? Exactly what fields do you need and how will you lay them out? How will the View Controller work?
The button should create a new view Our new button works: the action gets called, but really doesn’t do anything useful yet.
We need to give our user a place to enter the new drink information, and we can do that with a new view.
Just like with the detailed view, we can let the Navigation Controller handle the transition.
These are the directions, mix, pour over ice, then layer the rest.
Touching the disclosure indicator still moves the user into the detail view about that particular drink.
The add drink view needs to contain exactly the same fields as the detail view—it just needs to be editable.
When you click on these text fields, the keyboard will pop up and let you enter new information.
We need a view...but not necessarily a new view Our “new” drink view is really just an editable version of  our detailed view.
So instead of  creating a whole new nib, let’s take advantage of  the fact that the UI (the nib) is separate from our behavior (the UIView subclass in the .m file) and reuse the detail view.
Up until now, we’ve had a one-to-one pairing between our nibs and our View Controllers.
That’s definitely the norm, but our View Controllers are really just normal Objective-C classes.
That means we can use object-oriented extension mechanisms like inheritance to add the behavior we want.
We need to support different behavior than the detail View Controller, though.
Really, a new view controller but not a new nib? I thought they always go together.
Remember that a xib is just the XML representation of  a view.
Using nibs is a lot easier than trying to lay out your view using code.
And since the nib is just graphical information, you need to put the actual code somewhere else.
The View Controller defines the behavior for the view From the user’s perspective, we’ll have three views: the table view, the detailed view, and the new drink view.
But, since we’re reusing the .xib to create the “new” view, all we need is a new view controller class that supports adding a drink.
That means there isn’t any Interface Builder work to do at all!
These are the directions, mix, pour over ice, then layer the rest.
The nib defines the GUI and since both views will look the same, we can reuse it.
Separating the UI from behavior helps you reuse your view.
Reusing both the .xib file and the detail view controller is also an option.
But where could we run into problems with that approach?
Remember, we don’t just use Interface Builder to lay out the interface; we use it to wire up the components to the class that will load the nib.
When you pass the nib to the view controller, it will deserialize the nib and begin making connections to the outlet names stored in the nib file.
This means that if  we want to pass that nib into another, new view controller, we need to make sure we have the same outlets with the same names, the same actions, etc.
Reusing our nib gets us what we need for this app, but it’s not for every app out there.
Because of the way DrinkMixer is built, we can just subclass our detailed view to get what we need.
That works great for this app, but be careful doing this in more complex apps, because your code.
Often, it’s better to just bite the bullet and build a new view...and sometimes you’ll realize they shouldn’t even look the same.
Q: I still don’t get it about the new view controller without a new nib.
A: There’s nothing in that nib that you couldn’t create in normal Objective-C by hand.
As you’ve likely discovered with Interface Builder, nibs are generally a lot easier to work with than trying to lay out your view using code, so when you create a new view, you typically create a nib to go with it.
But really, you could build an entire application without a single nib.
In our case, we’re going to do something somewhere in the middle: we’re going to create a new view but reuse the UI information from another view.
Q: So why the “Watch it” warning about reusing the nib? Is this a good idea or not?
For DrinkMixer, we can reuse our DetailDrinkView and its nib since we want the layouts to look the same and the DetailDrinkView doesn’t really do anything specific.
However, in a more complex application, you might run into problems where you’re constantly fighting between the two view controllers or you have to expose so much information to the subclass that your code becomes unmaintainable.
This isn’t a problem unique to iOS development; you always have to be careful when you start subclassing things.
For our app, subclassing works fine, and you’ll see it in some of Apple’s example applications, too (which is part of the reason we included it here)
But it’s equally likely that in some other application you’ll want views to be similar, but not quite exactly the same.
In those cases, create a new view controller and nib.
A: It depends on how complex your table view and cells are.
As you get more complicated table views (in particular, grouped table views with different kinds of cells), it gets unwieldy.
Instead, consider creating helper methods that can configure a particular kind of cell.
Another really important thing to keep straight is resetting a cell back to defaults.
Obviously, you can factor that code out into a helper method too, but don’t forget to do it!
This new view will get all of  the fields, behavior (which we’ll change), and the nib we need.
In the New File dialog box, you need to create new UIViewController subclass files.
Be sure to uncheck the With XIB for user interface box, since we don’t need that .xib file.
A: We could do that, but the problem is we’re not just dealing with GUI layout.
We have text fields and labels in there that need to get populated.
We’d have to reimplement that in our new view controller if we didn’t subclass.
Q: Is this some kind of contrived Head First example, or should I really be paying attention?
This pattern shows up pretty often and a lot of Apple’s example applications use it.
It’s very common, particularly in table-driven applications, to have one view that just displays the data and another to edit it when the user puts the table in editing mode (we’ll talk about that more later)
Sometimes you should use totally different views; sometimes you can reuse one you have.
If you don’t put an access specifier there, Objective-C defaults to protected for fields.
Joe: That makes sense—we used the Navigation Controller to drill down into the data just by pushing a detailed view on the stack...
Frank: Adding a new drink to our list is a little different, though.
Frank: Well, adding a new drink is really a sub-task.
Frank: The users are stepping out of  the usual browsing drinks workflow to create a new drink.
Frank: Right, so for times like this, it’s important to communicate to the users that they have to complete the task.
Which of these views better communicates what the user needs to do? Is one more ambiguous than the other?
Modal views focus the user on the task at hand...
When users navigate through your app, they are used to seeing views pushed and popped as they move through the data.
However, some tasks are different than the normal drilldown navigation and we really need to call the user’s attention to what’s going on.
These are normal views from your (the developer’s) perspective, but feel different to the user in a few ways:
They have to either save the added drink or discard (cancel) it before they can return to the main DrinkMixer app.
So we want a view that encourages the user to make that choice.
The modal view is going to cover up the navigation control...
Modal views have to be dismissed, either by saving the changes or cancelling out of the view.
Any view can present a modal view Up until now, we’ve presented new views using our Navigation Controller.
Things are a little different for modal views: any UIViewController can show a modal view, then dismiss it when necessary.
Since our RootViewController is the View Controller that needs to show the modal view, we can just send this message to ourselves, using self, like this:
Be careful about your memory management—don’t leak references to the controllers.
If you say NO to animated, then the view just appears.
By saying YES, we get the smooth slide in from the bottom.This is the View Controller.
The RootViewController will retain a reference to the new View Controller when we present it.
Don’t forget to release the reference to the View Controller!
Test Drive Now that the add view is fully implemented, build and run the project.
Make sure you try out all the functionality: scrolling, drilling down to details, and finally adding a drink.
You’ll see there’s still a little work left to be done...
Touch in the title to bring up the keyboard and make sure it works.
If your keyboard isn’t working, your fields might still not be editable.
Back in Chapter 4, we had you make the fields uneditable in the utilities panel.
If your keyboard isn’t appearing, try going back into Interface.
That’s great, but after I type in the drink, nothing happens! I can’t get the view to go away, and I can’t add the drink.
Earlier, we decided that the add drink detail view needs to go away one of  two ways: either the user cancels out or saves the drink.
How should we lay out the Save and Cancel buttons? Is there anything unique about this view that we have to deal with?
Our modal view doesn’t have a navigation bar To be consistent with the rest of  DrinkMixer, we really should put the save and cancel buttons at the top of  the view in a navigation bar.
The problem is, we don’t have one in our modal version of  the detail view.
We could add one by hand, but remember we’re sharing the detail drink view nib, which gets its navigation bar from the navigation controller.
Since we’re showing the add drink view as a modal view, we cover up the navigation bar.
Instead of  trying to solve this from within the detail drink view nib, we can embed our add drink view in a Navigation Controller of  its own, like this:
The detail view is pushed on top of the table view, preserving the Nav Controller.
This will add a Nav Controller to wrap the add drink view.
Instead of presenting our addViewController, we can present an addNavController View Controller.
It will retain the controller, since it needs to display it.
Notice our “autorelease” here—normally, we alloc a class, assign it to where it needs to go, then release our reference to it.
By autoreleasing when we create it, we ask Objective-C to handle releasing it for us later.
Not quite as efficient as explicitly handling it ourselves, but a little cleaner looking in the code.
Just like when we made an add b utton, we’re.
Create the Save and Cancel buttons Since both the Save and Cancel buttons need to dismiss the modal view, let’s start by wiring them up to do that.
We’ve covered how to do that in Interface Builder—and you can do that now if  you want, but this time, let’s write them in code so see how that approach works.
Since we’re using the navigation bar, we get built-in support for left and right-hand buttons.
We just need to create those buttons and assign them to our leftBarButtonItem and rightBarButtonItem to place them where we want them.
Write the Save and Cancel actions When the user clicks either Save or Cancel, we need to exit the modal view by asking the View Controller that presented the view to dismiss it.
However, to make things easier, we can send the modal view the dismiss message, and it will automatically forward the message to its parent View Controller.
Since we are in the modal view, this dismiss message will be delegated up to our parent View Controller, which will actually make the view go away.
Test Drive The modal view can be dismissed now, and the keyboard works, too!
Just like that, the buttons are in the detail view.
Congratulations, the modal view is working! You did a lot of  view manipulation in this chapter and have a solid foundation of  an application to show for it.
You can transition to and from detail views and jump.
Next, we just need to tackle saving the new drink.
Q: Why don’t we need an outlet for the Save/Cancel button? And what about Interface Builder?
A: We don’t need to do anything with the Save and Cancel buttons after we’ve created them (like disabling one, or swapping one out for something else briefly), so we create them and immediately hand them off to our navigationItem to put in the upper left and upper right.
If we needed to do anything with them later, we’d probably want to hang onto a reference, and we could use an instance variable for that.
As for Interface Builder, we created the buttons in code this time.
In our case, we only needed to create simple buttons, so we did that in code.
That’s how we hooked the buttons up to our Save and Cancel methods.
So can I add some new drinks yet? I just learned how to make this cool new one from another bartender and want to put it in my app.
You can create  ________________ bars in IB or in code.
Your iOS Toolbox You’ve got Chapter 5 under your belt and now you’ve.
Debugging If you know where your problem is likely to be, set the breakpoint there.
You can use the debugger to step through the problem area.
If your application does crash, pay close attention to the call stack.
Your code frames are in black; framework code (code without source) is in grey.
Approvals can take time, so try and get it right with the first submission.
Once your app is up for sale, the reviews stay with it, even with updates.
Views Are typically used in a view stack with a Navigation Controller or presented modally.
Modal views help communicate to a user that they have to complete a distinct task or abandon it entirely.
You can create  ________________ bars in IB or in code.
If these records were on an iPhone and I could edit them, life would be grand!
Displaying data is nice, but adding and editing information is what makes an app really hum.
DrinkMixer is great—it uses some cell customization, and works with plist dictionaries to.
It’s a handy reference application, and you’ve got a good start on adding new.
Now it’s time to give the user the ability to modify the data—saving, editing, and.
Sam was clicking around, ready to add his new drink.
We have a problem with our view, since we can’t get to some of the fields.
Sam went to try DrinkMixer with the new add view and ran into problems right away.
You can’t see the directions at all, and part of the ingredients information is covered up.
When Sam taps on a control, it gets focus (becomes the first responder) and asks iOS to show the keyboard.
How did we deal with the keyboard last time? Will that work this time? What do you want the view to do when the keyboard appears?
When Sam taps in the Drink name field, the keyboard appears like it’s supposed to—that’s good.
We had a similar problem in InstaEmail where the user couldn’t get to the controls under the keyboard.
In DrinkMixer, it would be fine for the name field, but what about the directions and the ingredients fields? As soon as the keyboard comes up, they’re covered.
The user has a smaller screen to work with once the keyboard shows up—we need to set up the view to scroll things in when the user needs them.
How did we deal with the keyboard last time? Will that work this time? What do you want the view to do when the keyboard appears?
The scroll view draws and manages a scroll bar, panning and zooming, and controlling which part of  the content view is displayed.
It does all of  this by knowing how big the area it needs to show is (called the contentSize) and how much space it has to show it in (the frame)
All a scroll view needs to care about are the subviews it has to manage.
It doesn’t matter if  it’s one huge UIImageView that shows a big image you can pan around, or if  it’s lots of  text fields, buttons, and labels.
To get a scrollable view, we need to move our components into a UIScrollView instead of  a UIView.
UIScrollView has built-in support for zooming and panning around the content view—you just need to tell it how big the content is.
The scroll view acts like a magnifying lens on the content view, so that only a portion is visible to the user.
The content doesn’t have to be just buttons and text fields; UIScrollViews work well with images, too.
The scroll view will be the size of the entire view (minus the nav control)
Remember when we said sometimes Interface Builder makes things (a lot) easier? This is one of  those times...
All these components need to be children of the scroll view.
You mean we have to pull all those components off and then lay out the view again? Isn’t there an easier way?
Wrap your content in a scroll view We want the user to be able to scroll through our controls when the keyboard covers some of  them up.
In order to do that, we need to add a UIScrollView to our view and then tell it about the controls (the content view) we want it to handle.
Interface Builder will create a UIScrollView just big enough to hold all our components.
Since we want the whole view to scroll, grab the corners of the new UIScrollView and drag them out to the corners of the screen, right up to the edge of the navigation bar (we don’t want that to scroll)
Apparently we aren’t the first people to realize after we’ve built a view that it needs to be scrollable.
Interface Builder has built-in support for taking an existing view and wrapping it in a UIScrollView.
How will this new scroll view know how much content needs to be scrolled?
Now you have the same listing of widgets as before, but they are under a scroll view.
The scroll view is the same size as the screen Interface Builder created the UIScrollView, but there are a few finishing touches necessary to make this work the way we want.
You need to tell the UIScrollView how big its content area is so it knows what it will need to scroll—you do that by setting its contentSize property.
Then you’ll need to add an outlet and property for the UIScrollView, then wire it up in Interface Builder so we can get to it.
So how do we figure out how big the contentSize should be? When the UIScrollView is the same size as our screen, we don’t have anything outside of  the visible area that it needs to worry about.
Since the scroll view is the same size as our UIView that it’s sitting in, we can grab the size from there, like this:
Once you’ve added that line, you’ll have a scroll view that takes up all of  the available space, and it thinks its content view is the same size.
Once you resize it, the UIScrollView and its contentSize are the same size.
We just need to tell that to the scroll view.
You’ll need the field declaration and IBOutlet property, then you will synthesize it in the .m and release it in dealloc.
Wire up the new property to the UIScrollView in Interface Builder by adding a new Referencing Outlet to the UIScrollView connected to your scrollView property.
Remember, we’re telling the scrollView that its content is the same size as the view it’s sitting in.
Add a field and a property for the new scrollView.
You’ll need the field declaration, an IBOutlet property, to synthesize it in the .m and release it in dealloc.
Why isn’t it working yet? Think about all the things that you have going into this view—the scroll view, the main view, and the keyboard...
Wire up the new property to the UIScrollView in Interface Builder.2
The keyboard changes the visible area The problem is that the keyboard changes the visible area but the scroll view has no idea that just happened.
The scroll view still thinks it has the whole screen to display its content, and from its perspective, that’s plenty of  room.
We need to tell the scroll view that the visible area is smaller now that the keyboard is there.
Just because iOS knows that the keyboard is there, it doesn’t know how your app wants.
In DrinkMixer, the content view is the same size as our scroll view’s initial size, which is the whole screen...
Wouldn't it be dreamy if iOS could just tell the app when the keyboard appears? But I know it's just a fantasy…
Just like component events being passed around our application, there are system-level events, called Notifications, that are being passed by iOS.
The secret to knowing what’s going on with the keyboard is knowing about these events.
Sam taps in the Drink name field and the field becomes the first responder.
Objects are registered by providing a selector (method) to call if  the event is triggered.
Then unregister when you’re done Just like memory management, we need to clean up our registrations from the notification center when we don’t need them any longer.
We’ll register for events in viewWillAppear: and unregister in viewWillDisappear:
Unregistering for an event is easy—just ask the notification center to removeObserver for the object you registered.
You can get a reference to the default one by calling this:
With the notification center, you can register for events by passing the object you want the notification center to call back to (usually yourself), the method to call, an event you are interested in (or nil for any event), and, optionally, the sender you want to listen to (or nil for all senders)
Since we will only register for keyboard events when our window is visible, we don’t care who sends the event.
Create the selector from a method name just like with actions.
Make sure you unregister from the same notification center you registered with.
Don’t forget the colon here, because you’re going to get details about the notification as an argument.
Head First: Um, this is embarrassing, but I’m not entirely sure I have the right Notification Center here...
Notification Center: Well, unless you need something weird, it’s probably me.
Head First: Wow—so you know about every app that starts and stops?
I’m the default center; all the system events go through me.
Now, not everybody is interested in what’s going on, but if  they want to know, I’m the guy to see.
Head First: So when someone wants to know what’s going on, they tell you what they’re interested in, right?
If  somebody wants to know about somethin’ in the system, they register with me.
They tell me the notification they want me to watch for, who I should tell when it happens, and, if  they’re really picky, who should have sent it.
Head First: So then you tell them when that notification happens?
Notification Center: Right—they tell me what message to send them when I see the notification they were interested in.
I package up the notification information into a nice object for them and then call their method.
Doesn’t take me long at all; the sender almost always waits for me to finish telling everyone what happened before it does anything else.
Notification Center: Well, the sender could use a notification queue to have me send out the notifications later, when the sender isn’t busy, but that’s not typically how it’s done.
Notification Center: It’s similar to message passing, but there are some differences.
First, the senders don’t need to know who to tell.
They just tell me that something happened and I’ll figure out if anyone cares.
Second, there might be lots of  people interested in what’s going on.
In normal message passing, the senders would have to tell each one individually.
With notifications, they just tell me once and I’ll make sure everyone knows.
Third, unlike the delegate pattern—where the message gets sent to only one object—I can send messages to any number of  objects.
Finally, the receiver of  the notification doesn’t need to care who’s sending the message.
If some object wants to know that the application is shutting down, it doesn’t care who’s responsible for saying the app’s quitting, the object just trusts me to make sure they’ll know when it happens.
Anybody can ask me to post a notification and if  anyone’s registered to get it, I’ll let them know.
Head First: How do they know which notifications to send?
Different frameworks have their own messages they pass around; you’ll have to check with the framework to see what they’ll send out.
If you’re going to be posting your own notifications, you almost certainly don’t want to go blasting out someone else’s notifications; you should come up with your own.
They’re just strings—and a dictionary if  you want to include some extra infonothing fancy.
Fill in the blanks and get a plan for the next step!
We’ll adjust the size of  the when the keyboard appears and disappears.
Bonus Question: What file will you put all these changes in?
So registering for the keyboard event sounds pretty easy, but there’s more to do after that, right?
We need to tell the scroll view what to do once the keyboard does pop up (and when it goes away)
Now you have a plan for what to do next.
Q: I can’t find the list of notifications that are sent by the iOS.
A: There isn’t a central list of all the notifications that could be sent.
For example, the UIDevice class offers a set of notifications to tell you about when the battery is being charged or what’s happening with the.
Apple’s documentation is usually pretty clear about what notifications are available and what they mean.
The keyboard notifications are described in the UIWindow class documentation.
Q: Why would I want to create my own notifications?
Remember, notifications let you decouple the sender from the receiver.
For example, let’s say you had a view that let you add or remove items from your application and your app has several different ways to view those things.
Notifications could give you a nice way to announce to all the other views that something has changed without your add/ remove view needing to have a reference to each of them.
We’ll adjust the size of  the when the keyboard appears and disappears.
Go ahead and make the changes to your code to register for the keyboard events.
We’ll implement the code to handle the scroll view shortly.
For now, just have them print out an NSLog when they are called.
Both methods should take an NSNotification*, as they’ll be called by the notification center and will be given notification information.
Create this method and use it to add the code to unregister for events.
We’ll talk more about this in a minute, but you’re going to need a flag to keep track of  whether the keyboard is already visible.
These are both new methods for the keyboard notifications in the implementation file.
If you don’t give it a notification to unregister from, it will remove you from anything you’ve registered for.
We need to keep track of whether the keyboard is showing or not.
Go ahead and make the changes to your code to register for the keyboard events.
We’ll implement the code to handle the scroll view shortly.
Keyboard events tell you the keyboard state and size The whole point of  knowing when the keyboard appears or disappears is to tell the scroll view that the visible area has changed size.
We need to know how big the keyboard is so.
The notification object contains the name of the notification and the object it pertains to (or nil if there’s no related object)
Getting the notification is easy, but we get told every time the keyboard is shown, even if it’s already there.
That’s why we need the BOOL to keep track of whether or not the keyboard is currently displayed.
If the keyboard isn’t visible when we get the notification, then we need to tell our scroll view its visible size.
If the keyboard is hidden, we set the scroll view back to full size.
Keyboard Code Magnets Part I Below are the code magnets you’ll need to implement the keyboardDidShow method.
Get the origin of the keyboard when it finishes animating.
Get the top of the keyboard in view’s coordinate system.
We need to set the bottom of the scroll view to line up with it.
Resize the scroll view to make room for the keyboard.
Keyboard Code Magnets Part II Below are the code magnets you’ll need to implement the.
Use the comments in the code on the right to help you figure out what goes where.
Resize the scroll view back to the full size of our view.
Get the origin of the keyboard when it finishes animating.
Get the top of the keyboard in view’s coordinate system.
We need to set the bottom of the scroll view to line up with it.
Resize the scroll view to make room for the keyboard.
NSNotification contains a dictionary with the event details; we pull that out here.We get the keyboard size from the dictionary...
Finally, update the scroll view with the new size and mark that the keyboard is visible.
We will get this notification whenever the user switches text fields, even if the keyboard is already showing.
So we keep track of it and bail if it’s a repeat.
Resize the scroll view back to the full size of our view.
Once you get into the detail view, you should be able to scroll the view to all the fields, and the messages in the console help you keep track of what’s going on.
Q: Manipulating that scroll view size is kind of tricky—how would I have figured that out without magnets?
A: A great reference for the code samples and information for programming apps in general is the Text, Web and Editing Programming Guide for iOS that is available on the Apple developer website.
That has sample code for common problems like managing the keyboard and text views.
Q: Tell me again why we need to keep track of whether the keyboard is already visible? Isn’t iOS doing that?
A: The iOS knows the state of the keyboard, but it sends keyboard events out when different controls get focus.
You need to keep track of whether you already knew it was visible so you don’t resize the scroll view to the wrong size.
Q: The scroll view works, but depending on what the users pick, they still have to scroll to the widget?
You can ask the scroll view to scroll to a particular spot on the content view if you keep track of which control has the focus.
The Text, Web and Editing Programming Guide for iOS has good sample code for that.
Q: Don’t we know the dimensions of the keyboard that pops up? Why do we.
A: It’s not always the same! If your application is landscape, your keyboard is wider than it is tall.
If your app is portrait, then it’s taller than it is wide.
Apple also makes it clear that they may change the size of the keyboard if necessary and you should never assume you know how big it is.
Q: What are the animation and curve properties in the notification about?
A: The Keyboard notification includes information on how quickly the keyboard is animating in.
You can use this information to animate the size change of your content so the keyboard comes in as your content view shrinks.
Everything scrolls OK, and I can put a drink in, but as soon as I get back to the list, the drink I added isn’t there!
As soon as he leaves the drink detail view, the new drink no longer shows up in the main list.
We need to figure out how to keep it around longer...
Work through the following questions to think about what this means for our app.
What happens to new drinks when the user hits Save?
What happens to new drinks when the user hits save? We dismiss the view and the drink information.
We need to add some code that actually stores the values.
Since we already store our drinks in dictionaries, we can.
We can create a new dictionary by allocing it, but we’re going to need to get a reference to the array from somewhere.
We can set the drink interaction on the dictionary using setObjectForKey:
What’s going to take a little more work is adding it to the drink array.
Let’s start by having the RootViewController pass the new drink in after we’ve created it.
Work through the following questions to think about what this means for our app.
Give the AddDrinkController a reference to the master drink array.
You’re going to need to add a drinkArray field to the class, a corresponding property, and then synthesize it and release the reference in dealloc.
Finally, you need to make sure that the RootViewController passes on a reference to the drink array when it’s setting up the AddDrinkController.
You need to update the save: method to get the drink details from the controls and store them in a new dictionary.
After that, add the dictionary to the master drink array using addObject:
We need the constant key names so we can populate the new dictionary.
Give the AddDrinkController a reference to the master drink array.1
Add it to the master drink array and release our reference.
Pop the modal view and go back to the list.
Since we want to add keys and objects, we need to create a mutable dictionary.
What problems could you run into later if you created an immutable version?
The Case of  the Missing Reservations Nicole has been a maitre d’ at Chez Platypus since it opened nearly 10 years ago.
This upscale restaurant has a number of distinguished customers who like their dining experience to be just perfect.
The VIP guest list hasn’t changed in years and Nicole knows everyone’s face.
She takes them right to their favorite table when they show up and makes sure everything is just right.
A prominent, if  eccentric, Nobel Prize-winning scientist who is known for his particular tastes.
Restaurant management dug up the dusty VIP list and added the scientist’s name at the bottom, along with all the detailed instructions for making sure.
They trusted that Nicole would take good care of  him and didn’t give it another thought.
Last night, their new investor arrived a few minutes before some of the other VIP guests.
She continued to move the regular VIPs to their seats and, for all she knew, their new investor did not even exist.
Test Drive That was a lot of code! Run the app and make sure everything is working.
Here’s a drink to add to the list (it’s the new house drink in the Head First Lounge)
Add the whiskey, then the cream soda to a shot glass and drink.
Test Drive To properly test the app now, click the Add button and enter the data for the new drink in the detail view.
We implemented the Save method, created a new drink, added it to the array...and we’re pretty sure all that code works.
Before we move on, let’s use the debugger and do a quick sanity check.
If the breakpoints are on, it will launch the debugger when you run.
After looking at the initial values, go ahead and continue the application and add a new drink.
Now we’re going to use the debugger to help us figure out what’s going on.
What did you find? The array initially has 40 dictionaries in it; after adding our new drink, it.
We’ve added it to the drink array, has one more.
If we use that console command, we can step through them and see that it’s right.
We have 41 objects in the drink array now! That’s our new drink, so we’re adding it to the drink array correctly.
Nicole hasn’t needed to look at the VIP list in years.
She was so concerned that their important customers feel welcome that she didn’t want to have to do something as crass as go back and read a list every time someone arrived.
She made a point of  memorizing that list so when they came to the restaurant she could recognize and seat them immediately.
As far as Nicole knew, there were 10 VIPs on that list and she knew them all.
The problem was that the list was changed and no one told her.
The table view doesn’t know its data has changed The table view does a number of  things to improve performance as much as possible.
As a result, if  you just change values in the datasource without telling it, it won’t know that something has changed.
In our case, we added a new value to the array used by our datasource but didn’t let the table view know about it.
You need to ask the table view to reload its data Since we’re modifying the underlying data used by the datasource, the easiest way to refresh the table is to ask it to reload its data.
This tells the tableview to reconstruct everything—how many sections it thinks it has, the headers and footers of  those sections, its data rows, etc.
Ask the table view to reload its data right before the RootViewController appears.
The Save button controller modified the drink array used by the datasource...
Add the whiskey, then the cream soda to a shot glass and drink.
Test Drive To properly test the app now, click the Add button and enter the data for the new drink in the detail view.
Uhh—that drink is at the end of the list, not in with the Rs.
Q: Telling the table to reload all its data seems pretty drastic.
A: It’s the simplest way to refresh the table data, but not necessarily the most efficient.
If you’re modifying the table while it’s visible, you can call beginUpdates and endUpdates to tell it you’re about to make a number of changes and it will animate those changes for you and let you avoid a reloadData call.
There are also versions that only reload the specified rows or for a given section.
Which you use depends on your application, how much you know about what changed in your data, and how big your dataset is.
Q: We didn’t add any code to the cancel button.
This will clean up any memory associated with the controller and throw away any data the user entered in the fields.
As long as we don’t manipulate the drink array, we’ve properly canceled any action the user started.
Q: Why can’t I see the drink information in the debugger when I expand the drinks array and dictionaries?
A: This is one of the disadvantages of using a generic class like NSMutable Dictionary for storing our drinks.
The debugger knows the class is a dictionary, but that’s about all it can tell us, since all the keys and values are dynamic.
You can get to them through the debugging console, but that’s not as convenient as seeing real attributes on classes when you debug something.
Q: Did we really need to use the debugger back there? Couldn’t I have just printed out how many items were in the array using NSLog?
A: Sure, but then you wouldn’t have been able to practice debugging again...
Q: Why can’t we use the po command for the GDB debugger to see the names in the dictionary?
The catch is that sometimes Xcode has trouble figuring out which object you want, so use the command from earlier if that happens.
Why is the drink showing up at the bottom of the table? What do we need to do?
Sort your array using NSSortDescriptor In order to get the table view properly sorted, we need to sort our data array.
You tell descriptors what to compare by specifying a property, how to compare them with an optional selector, and then which order to display the information in.
In our case, we’re looking for alphabetical sorting by the name of  the drink.
Sort the array since we just added a new drink.
Add this in the save method after you add the data to the array but before the view gets popped off the stack.
The array is out of order, too Our table view gets its information directly from our drink array.
If we didn’t provide a selector, it does a case-sensitive comparison, but we want a case-insensitive one.To do the sort, simply ask the array.
Let’s add another drink; this one should end up in the right place.
Great, that new drink is there, but what about the RedHeaded School Girl from before? Don’t we need to deal with saving more.
We’re positive we’re updating the array with our new drink, but obviously that new array doesn’t survive quitting and restarting our app.
What do we need to do? When should it happen?
Jim: OK, so we should save the array after each new drink is added, right? That will make sure we always have the right data.
Frank: But that means you could be saving every time you add a drink.
Jim: Oh, I see, that means we’ll have to go through reading in the array and saving it back out multiple times.
Joe: Well then, when are we supposed to do it?
Frank: When we background the app! With multitasking, apps don’t really close anymore, but when it goes to background, we can save it.
Jim: How do we do that? How can we tell when the user backgrounds the app?
Joe: But the app delegate doesn’t know anything about our drink list or where to save it...
Q: What notification tells us the application is going into the background?
Since iOS 4, iPhone supports multitasking, so they can do limited tasks in the background, but in general, they suspend shortly after entering the background state.
Q: What if the user hits the home button or the phone rings or...?
Q: What happens if my app crashes? A: Then you’re not going to get the notification.
You need to balance how critical it is to make sure no data is lost with the performance impact of saving more frequently.
In our case, we’re just going to save on background.
In general, Apple advises you to save as close to the user interaction as possible—we’ll build an app that behaves that way later in the book.
Use Jim, Frank, and Joe’s discussion and your skills at working with the API to figure out what to implement to save the array.
Add the code to save out the new plist of dictionaries.
We’re going to give you a little code snippet to use.
This code will only work on the simulator, but we’ll revisit this issue in a later chapter.
The code used to save the plist will work fine on the simulator, but fail miserably on a real device.
The problem is with file permissions and where apps are allowed to store data.
We’ll talk a lot more about this in Chapter 8, but for now, go ahead with this version.
Use Jim, Frank, and Joe’s discussion and your skills at working with the API to figure out what to implement to save the array.
This is the code that’s going to give us problems on a real device.
We’ll run into this again (and fix it) in the next chapter—bear with us for now....
Stopping and hitting “Build and Debug” in Xcode is NOT the same as pushing the Home key and relaunching the app in the simulator!
When you stop the app using Xcode’s Stop button, you are killing the app right then and there.
No termination notifications are sent, no saving is done—it’s just stopped.
Likewise, when you click Build and Debug, Xcode will reinstall the application on.
To test our load and save code, make sure you restart the app by tapping the icon in the simulator.
Author’s note: we thought about showing the same screenshot twice, but figured that still wouldn’t prove that it saves after hitting the home key and coming back in.
Pour the liqueur and vodka over ice and then fill with pineapple juice and garnish with a grape.
Make sure when you run DrinkMixer the second time you tap on the icon in the simulator; don’t hit Build and Debug again!
Arrays load and save using a Cocoa technique called NSCoding.
Any objects you want to load and save must conform to the NSCoding protocol, which includes initWithCoder and encodeWithCoder method—basically, load and save.
You’d need to conform to the NSCoding protocol and provide those methods to so that objects can be archived and distributed.
However, NSDictionaries do conform to NSCoding (as do the strings inside of them), and that’s why we can load and save so easily.
Q: What is the deal with giving us code that won’t work on the device? What happens?
A: Well, to find out what happens, we encourage you to run it on a real device.
Then think about why it isn’t working the way you’d expect.
We’ll talk a lot more about this in the next app.
To give you a hint, it has to with where we’re trying to save the data.
This is also a real-world example of something working just fine in the simulator only to behave differently on a real device.
It’s more of a style and design question than anything else.
You could argue we’d be breaking encapsulation if we exposed what needs to be loaded and saved for each view up to the AppDelegate.
Since we only need to save a single array, it’s not a big deal either way, but if you have a number of views that need to save information or complex persistence code, it’s often cleaner to leave it with the class that needs to know about it rather than lumping it all into the AppDelegate.
Q: Why did we register and unregister in the viewDidLoad and viewDidUnload methods instead of the *Appear methods?
A: The problem is when and how often those methods are called.
That starts out OK—we’ll get that call before the table view shows up and we can register.
However, the viewWillDisappear will be called right before we show the detail or add drink view controllers (since our RootViewController is about to be hidden)
If we unregister there, we won’t get the backgrounding notification if the user decides to quit while looking at the details for a drink.
We show the detailed view, he’s happy, then he quits the app.
Our RootViewController has unregistered for the backgrounding notification and the drink is lost.
Instead, we use the load and unload methods, which are called when the view is loaded from the nib or unloaded.
Since that view is in use throughout the application, those won’t be called except at startup and shutdown.
Q: What’s the deal with hitting “Build and Run” versus tapping on the icon to start DrinkMixer the second time?
We’ll talk more about it in the next chapter, but the problem is when you hit.
This means it’s replacing the modified drink plist with the one that we ship with the application and you lose your drink.
That’s great! Now I can add the extra drinks I need.
But there are a couple of other things that I need to really make this app work for me.
How can we implement these things? Where in the app do we need to handle this stuff?
Table views have built-in support for editing and deleting Good news! The table view comes complete with almost everything we need for deleting data.
This is behavior that acts a bit like implementing a Save or Cancel button, and a lot of  it comes preloaded.
Editing mode adds an Edit button to the Navigation Control in the main view, and when it’s pressed, indicators appear to the left of  the table cell that can be selected and deleted like this:
The edit button in the view tells the user how to.
The delegate (our view controller) will handle which mode the table is in and handle deleting drinks.
The drinks array will be modified as needed after the drinks are deleted.
Using the view below, write what each part of the editing view does.
Using the view below, write what each part of the editing view does.
The Done button turns off editing mode and puts the table back to normal.
The delete icons let the user delete a row from the table.
The + button is unchanged: it lets us add a new drink.
When tapping on a row in edit mode, we should be able to edit a drink instead of just displaying it.
The Xcode template we chose for this app comes with a good bit of the code we’ll need, and at this point, you’re pretty familiar with the RootViewController and the table view.
We’ll give you some hints on what to implement next, but let you take it from here.
We need an Edit button in the upper left of  the navigation bar.
Once the table view is in editing mode, we’ll get a call when the user tries to delete a row either by swiping across the row or tapping the delete indicator.
Most of this method is stubbed out for us too, but you’ll need to add code to update the datasource with the change.
Remember, we’ve been mapping rows to indexes in our array.
Finally, you don’t need to call reloadData after this change because we ask the tableView to explicitly remove the row.
You’ll need to tell the app that it must edit a drink instead of  creating a new one, then have it populate the controls with the existing information, and finally update the drink on save.
Verify that “Allow Selection While Editing” is checked for the Drinks table view.
We need an Edit button in the upper left of  the navigation bar.
Once the table view is in editing mode, we’ll get a call when the user tries to delete a row either by swiping across the row or tapping the delete indicator.
Most of  this method is stubbed out for us too, but you’ll need to add code to update the datasource with the change.
Remember, we’ve been mapping rows to indexes in our array.
Finally, you don’t need to call reloadData after this change because we ask the tableView to explicitly remove the row.
All we need to do is add it to the nav bar.
The Xcode template comes with a good bit of the code we’ll need, and at this point you’re pretty familiar with the RootViewController and the table view.
We’ll give you some hints on what to implement next, but let you take it from here.
First, we need to check to see if we’re in editing mode.
The Xcode template comes with a good bit of the code we’ll need, and at this point you’re pretty familiar with the RootViewController and the table view.
We’ll give you some hints on what to implement next, but let you take it from here.
Verify that “Allow Selection While Editing” is checked for the Drinks table view.
Now create a new drink dictionary for the new values.
You’ll need to tell it that it must edit a drink instead of  creating a new one, then have it populate the controls with the existing information, and finally update the drink on save.
If there’s a drink set, then we need to update it.
We can either update the existing object or replace it.
Since we need to re-sort the whole array anyway (in case the drink name changed), we just remove the old one and readd it.
You should be able to remove drinks and fine-tune them all you want.
Remember to restart your app by tapping on the icon, though; otherwise, you’ll lose your changes.
Q: I like the automatic editing support in the table view, but how do I do those cool “Add New Address” rows that the iPhone has when you edit a contact?
Basically, when you’re in editing mode, you tell the table view you have one more row than you actually have in your data.
If it is, return a cell that says “Add New Address” or whatever.
Q: We haven’t talked about moving rows around, but I’ve seen tables do that.
A: No, the table view part is really easy; it’s the datasource part that can be tricky.
The users will see a row handle on the side of the cells when they’re in editing mode.
When they move a row, you’ll get a call to your new method that provides the IndexPath the row started at and the IndexPath for the new position.
It’s your job to update your datasource to make sure they stay that way.
Q: What if I don’t want the users to be able to delete a row? Can I still support editing for some of the rows?
Q: When we edit a drink, we replace the object in the array.
What if we had some other view that had a reference to the original?
The short answer is you’re going to have a problem, no matter how you handle it.
If some other view has a reference to the object we removed, that’s not tragic since the retain count should still be at least 1; the object won’t get deallocated when we remove it.
However, the other views obviously won’t see any of the changes the user made since we’re putting them in a new dictionary.
Even if they had the old dictionary, they wouldn’t have any way of knowing the values changed.
One option is you could change our code to leave the original object in the array and modify it in place, then make sure that any other view you have refreshes itself on viewWillAppear or something along those lines.
Another option is you could send out a custom notification that the drink array changed or that a particular drink was modified.
Q: Aren’t we supposed to be concerned about efficiency? Isn’t removing the drink and reading it inefficient?
A: It’s not the most efficient way since it requires finding the object in the array and removing it before reinserting it, but for the sake of code clarity, we decided it was simpler to show.
We’d have to re-sort the array regardless of which approach we took, however, since the name of the drink (and its place alphabetically) could change with the edit.
Q: We added the edit button on the left-hand side of the detail view, but what about a back button? Isn’t that where they usually go?
When you get into having an add button, an edit button, and a back button, you run into a real estate problem.
The way we solved it was fine, but you’ll need to make sure that your app flows the way you need it to when your Navigation Controller starts to get crowded.
Q: We still have some oddities like the drink being editable in the detail view.
So much of what has made iOS and the app store successful is the polish that Apple and iOS developers have put on their applications.
It’s the difference between a pretty good app and a chart-topping, wowinducing success purchased by hundreds of thousands of users.
Your iOS Development Toolbox You’ve got Chapter 6 under your belt and now you’ve added saving, editing, and.
Scroll View Acts like a lens to show only the part of the view you need and scrolls the rest off the screen.
Notifications Are system-level events that you can monitor and use in your app.
Different frameworks use different notifications, or you can create your own.
Table View EditingThere’s built-in support for editing a table view.The edit button comes with lots of functionality, including methods to delete rows from the table view.
In many ways it is, but that screen opens up many opportunities.
DrinkMixer on the iPad It happens all the time: a new device comes out and now your clients want to use it.
People tend to use the iPhone most in portrait mode, like this.
Do this! Open up DrinkMixer in Xcode and run it in the iPad simulator.
Every iPhone app on the App Store will run on iPads right out of  the box, but there’s a catch.
The iPad simulator The simulator will launch the iPad with the DrinkMixer iPhone app, as is.
You didn’t have to change a line of  code, and it does work.
Of  course, the simulator is enough to show you that just running the iPhone app on the iPad isn’t ideal.
First off, it’s the size of  an iPhone app, but on an iPad.
You can change the size of  the view to fill the entire screen by “doubling” the pixels, but that doesn’t change the resolution of  the view, so the graphics don’t look as good.
Play with it in the simulator, too, and we’ll bet it doesn’t really feel right, either...
I don’t know how you fix it, but that is not what I was thinking an iPad version of DrinkMixer would look like...
When using pixel doubling, the app looks not only pixelated, but wrong! It looks totally out of proportion.
The HIG covers iPads, too Since the device has changed, let’s go back to the HIG.
If  you work your way through the iOS Human Interface Guidelines, you’ll find a section called “For iPad: Restrain Your Information Hierarchy.” For DrinkMixer, that means we need to use the extra real estate that comes from the big screen to reduce the number of  screen transitions.
For example, you can easily display a detail view next to a list view using a Split View Controller.
What are some apps that you’ve used for both iPad and iPhone? Are there any elements that are iPad-specific?
The view shows two levels of data, called a Split View Controller.
It’s another way to consolidate information into a single view rather than introduce a hierarchy.
Head First: Hi, iPad! It really exciting to be interviewing a famous device like you.
There are lots of  other tablets out there, but once you know me, you know the best.
How do you answer the critics that say you’re just a big iPhone?
We do have some things in common, like the touch screen, iOS, accelerometers, and awesome apps, but the apps are usually different.
My screen is bigger, but because of  that, you interact with me very differently.
Head First: How so? People still use the same gestures?
Me, you want to sit down and spend some time with.
Anyway, because the screen is small, you’re going between screens a lot on iPhone.
To reduce the number of  views, there is a Split View Controller just for my apps.
In landscape, it shows a table view on the left side of  the screen and the detail view on the other side.
So as soon as you pick something, you can see the details without hiding the list.
And if  you shift that Split View Controller to portrait, it just shows the detail view, until you click on a navigation button and see the popover.
It’s like a dialog box that appears on the screen without covering the whole thing up.
Great for little bits of  information, color settings, stuff  like that.
Use visual clues from the real world to help people use your app.
You have lots of  space to work with and room for lots of  fingers touching things.
Think about how real books, calendars, switches, dials, and real physical controls look and feel.
Sketch up the UI for the new DrinkMixer iPad app.
You’ve got more room, so be sure to use it well! Consult the HIG and make sure you know what information is going in which element of the view.
Remember, we want to convert this whole app into an iPad app, with the right iPad controls.
This is the popover that comes with the Split View Controller.
Now we have an idea of the UI for the new iPad app.
Having this all put together first is going to help keep everything going in the right place as you code.
It handles restraining the hierarchy and it looks good too, even in portrait mode with a popover!
Q: Is building an app for iPad really that different than building for iPhone?
A: From a coding and development perspective, no, they’re nearly identical.
But from a design and UI perspective, yes, they’re very different.
It’s important to spend time with an iPad to make sure you “get it.” When designing iPad apps, there will be a point where an app will just start to feel like an iPad app.
It’s lots of little design elements like the use of space, textures on controls and UI components, interaction patterns, etc.
People sit on couches and really soak in iPad apps.
Q: Does “restraining the hierarchy” just mean using a split-view control?
That’s one way to help get there, but it’s definitely not the only way.
For example, let’s say you have summary information about chapters in a book.
In an iPhone app, you might have a table view listing the chapters, and tapping on a chapter will show that summary information.
In an iPad app, you might want to have a fancy table of contents only showing three or four summaries at a time but indicate to the user that they can turn the page to see the next set.
Hook that up with a swipe gesture and a nice page curl animation and you have a much more natural way of flipping through the same material without needing to slide views in and out as the user moves through data.
Q: Are we going to have the same hardware issues with iPad as we did with iPhone? Specifically different capabilities and features?
You already had that to some extent with just the first iPadthere are 3G iPads with a GPS while the.
Wi-Fi–only ones obviously don’t have 3G connectivity or a true GPS.
The iPad 2 has two cameras while the original iPad doesn’t have any.
The good news is that you should handle it just like iPhone and iPod Touch differencessimply check for device capabilities and code around not having them.
Q: Does the iPad run a different version of iOS or anything?
A: No; well, no more so than iPod Touch vs.
There are some controls that are only available on the iPad (and you need to check for them if you build a universal appmore on that later), but the basic OS is the same and you can have a single build that runs on all iOS devices.
Now that you’re ready to build this thing, what exactly is it called? When Apple designed the iPad and iPhone to share one OS, Apple introduced the concept of  a Universal app, an app that is built for both devices.
That still means different views for iPhone and iPad, but only one code base that gets submitted to the App Store.
Users get both a native iPhone app and native iPad app when they buy your application instead of  needing to purchase two separate apps.
It really just makes more sense to support iPhones and iPads everywhere, like I do.
True, but if  I’m written right, most of  my code is shared between the devices.
It’s really not that hard to just use the right view controllers on the right device and everything else goes from there.
I’d be happy to trade worrying about a couple more devices for better sales and reviews.
The reviews I see have a lot of  people complaining about needing to purchase the same app again just to use it on another device.
I’m usually a little more expensive, but users love getting more value for their money.
You do support everyone, that’s true, but that makes you kinda hefty, right? You have to check for like, everything!
See, my apps don’t have that much to worry about.
If  you build two apps, then you can sell twice per user.
Every person out there with an iPhone and an iPad has to pay twice to get all of  me.
I cost less but only work on a specific kind of  device.
I think we both agree that you don’t want two completely separate code bases, right?
So I guess really we’re arguing about a packaging issue.
Do the users want to pay a little more and get iPhone and iPad support, or do they want to pay a little less when they only want support for one device, but end up paying more if  they want both?
Even if  you are going to make two different apps, you should be sharing a code base.
You definitely don’t want to be in a situation where you’re fixing the same bug in multiple projects or trying to keep them in sync.
You know, I bet there isn’t a simple answer to that.
There are lots of  users who have lots of  different opinions.
It probably depends on the app and how the developer wants to interact with the users.
He wants the iPad version of DrinkMixer to be tied in with the original iPhone app.
What kind of app distribution are we going to have to use?
Use Xcode to build your Universal app Since we’re looking to support Sam and keep things easier, it makes more sense to build a universal app that creates one software bundle.
This isn’t too hard to implement, because when the code is cleanly separated in the MVC pattern, we just need to talk to another view.
Upgrade your app Highlight the project in the Navigator window and you’ll see the basic project settings.
Under devices, the drop-down box will let you select iPhone, iPad, or Universal.
Wait—what’s a target? What does it have to do with iPads?
Xcode completes the build process based on the targets that you identify.
A target keeps track of which files and the instructions of  what to do with them for a build.
We upgraded our target to be a universal build, so now it has everything it needs to build an app that runs on iPhones, iPod Touches, and iPads.
As part of  the upgrade process, Xcode introduced the new .xib for us and added it to the target.
Since Xcode is used for Mac development too, there are lots of reasons to create several targets, such as frameworks or libraries.
Targets are frequently used to build unit tests or application tests as well.
The test code is only included in the test targets and won’t be in the release builds.
Xcode only builds the active target, so you can build  just one piece at a time.
We only have one target for DrinkMixer, so it’s always active.
Test Drive Make sure that the iPad simulator is still selected for the build and build and run the app.
The detail view looks really bad, and it’s just a regular table view—we never told it to use the Split View Controller.
Since we’re working with iPhone and a new view, Xcode just ported what we had over to the iPad—in this case, a table view.
To put the new Split View Controller into play, we need to fix that.
Split-view Magnets Adding the split view isn’t really that hard if you think about it a bit.
Use these magnets to order the steps we need to work through.
We’ll walk you through the coding, you just get them in order!
Split-view Magnets Solution Adding the split view isn’t really that hard if you think about it a bit.
Use these magnets to order the steps we need to work through.
This is the initial file listing that was created by Xcode when the new target was created.
For the Split View Controller to work, you need to have two children.
By default, they are a Navigation Controller with an embedded Table View and a standard view controller.
We want a Navigation Control on top of the View Controller for the righthand pane.
Using a real navigation controller for the detail view gets us access to a navigation bar and the usual edit buttons, like we had for the iPhone version of  the app.
The easiest way to swap out the right view controller is to drag and drop a Navigation Controller into the right pane.
Interface Builder will update the right view controller to be a Navigation Controller for us and drop the navigation bar right where we want it.
Just like we did with the detail view, change the class type for the table view controller to “Root View Controller.”
But the App Delegate is for the iPhone and the iPad, right?  Don’t we need to tell it which.
Check your devices This is where the code paths for the iPhone and the iPad are going to intersect—in the App Delegate.
Because we’re migrating an existing iPhone application, we already have an AppDelegate and it’s set up to add our RootViewController to the window when the application launches.
Now that we’ve added iPad-specific views, we need to update our AppDelegate to add the correct one to the window depending on the device.
This returns a constant that tells you the type of  device your application is running on; we can use this to figure out which view controller to show in the window.
Add the navigation controller’s view to the window and display.
You may need to switch Xcode back to the iPad setting for the Simulator...
Rotating DrinkMixer should expose the Split View Controller that we’ve been working on.
Rotation is key with iPad An important part of  coding for the iPad is that is has to support all orientations, since Apple is big on there being no wrong way to use an iPad.
Users will expect to be able to pick up their iPad any way and have it work.
To start supporting all orientations, we need each of  our controllers to know that we want to do that.
Override to allow orientations other than the default portrait orientation.
This method is in all your view implementation files, just commented out.
Remove this line and replace it with YES to support all orientations.
Now you’re supporting all the orientations, everything is linked, and devices are checked.
The app looked OK once it got started, but something weird happened at startup.
The code is all set up to handle a rotation when you’re in the app.
At startup, iPad apps should show a launch image first, while they’re loading, like a splash screen.
Apple’s HIG recommends that the image should be your actual initial user interface (minus specific data)
Depending on the application, though, some people use actual splash screens.
Once the images are set up, iOS will pick the image that goes with the current orientation and avoid that awkward rotation of  the interface that you saw without appropriate launch images.
We have two images you can use for launch images, you just need to download them and drop them in your project.
Go to http://www.headfirstlabs.com/books/hfiphonedev and download the launch images for this chapter.
Select the project in Xcode and scroll down to iPad Deployment Info.
Drop the portrait launch image into the Portrait Launch image box and the landscape image into the Landscape Launch Image box.
We’re just about ready to fully support the launch in any orientation.
In the iPad Deployment Info, you should have all launch orientations selected and the images dropped into Launch Images.
This ~ipad notation is standard in iOS and can be used to provide device specific resources.
Test Drive Now we’re supporting all the different orientations, right from the beginning.
Try stopping it and relaunching in the simulator from landscape.
Test Drive What if you tap on one of those rows in the horizontal split-view orientation?
Your job is to play Detail View Controller and figure out why you’re not displaying the right thing.
When should it get called? What classes are you going to need to update?
What’s the difference here between the iPad and the iPhone?
The detail view needs to be updated each time the user selects a row.
When should it get called? What classes are you going to need to update?
What’s the difference here between the iPad and the iPhone? That restrained hierarchy thing.
The iPhone has to show two different views for the detail view and the root view.
Since the views are together for the Split View Controller on the iPad, the view isn’t being presented, but it still has to change.
A persistent view problem We built things for the iPhone to populate the detail view when it’s about to be displayed.
The problem is that with the iPad version, it’s always displayed.
What worked well on the iPhone (repopulating the data as the view was presented) doesn’t work well on the iPad, since it will only get one viewWillAppear message—right after the app launches.
The wrong solution would be to duplicate our viewWillAppear code.
Don’t forget the tableview Instead of  swapping out the table view when a row is selected, the detail view needs to change and the table view should stay the same—but only for the iPad, not the iPhone.
To fix that problem, we need to split the code, just like we did in our AppDelegate.
Test Drive Before you build and run, go into Interface Builder and link up the detail view in the split pane to our new split ViewDetailView property on the RootViewController.
Now you’re pushing the detail view onto the right-hand side of the pane, while the left-hand side is still showing the table view.
We need to check to see if w e’re on an iPad, and if so, us.
Now you’re pushing the detail view onto the right-hand side of the pane, while the left-hand side is still showing the table view.
But if you rotate the thing, it still doesn’t look right.
To fully implement the Split View Controller, we need to have the popover working in the portrait view.
If  it doesn’t, the user will be stuck in the detail view unless they rotate back to landscape.
This is the popover that comes with the Split View Controller.
Match each control in the landscape view (table, detail view, nav control) to its equivalent in the portrait view.
Then you’ll have an idea of  what needs to go where!
When the iPad is rotated to portrait, the views that we’re working with are the same, just like you saw in the exercise.
While DrinkMixer supports the detail view in portrait, we need to enable the other hidden view, the table view.
The popover is an iPad exclusive control that is used to present a table view temporarily, just to allow the user to select another detail view and keep working with the data.
We also need to set up a button to allow the user to access the popover view in the navigation control of  the detail view in portrait.
This button needs to be created, since it doesn’t map to anything specific in landscape.
Match each control in the landscape view (table, detail view, nav control) to its equivalent in the portrait view.
Then you’ll have an idea of  what needs to go where!
Create an instance variable named popOver_ and a corresponding property that’s an IBOutlet.
Get started based on what you can find in the documentation.
You’ll have to open up the iPad main window and expand the Split View Controller to make the connection.
Use that to figure out how to implement the items below.
Once you’re finished implementing the Split View Controller delegate, it can handle all the information properly in landscape and portrait.
Create an instance variable named popOver_ and a corresponding property that’s an IBOutlet.
Get started based on what you can find in the documentation.
This method gives us a popover controller and button that we can use to show that hidden view when necessary.
You’ll have to open up the iPad main window and expand the Split View Controller to make the connection.
Everything should be working now! Try using the button and rotating the simulator.
Q: The detail view still doesn’t look all that great.
A: If we were going up on the App Store, yes.
In our next iPad app, later in the book, we’re going to focus a lot more on look and feel.
For now, we wanted you to get the controls figured out.
Q: When we enabled various launch orientations in Xcode, what did that actually do?
A: If you take a look at your Info.plist in your project, you’ll see that Xcode quietly added an array of enumerations that list the launch orientations you support.
The GUI option we used is just a convenience (and new in Xcode 4) for setting those values.
Once the iPad entered the scene, Apple added the concept of ~<device> to filenames.
A: Most definitely not! Popovers are used pretty often in iPad applications.
They’re very straightforward to use—they simply wrap a view and you can tell them which control they should appear next to.
Q: We really didn’t do much to support the various screen orientations.
When you edit the size information of a control in Xcode, you can set its Autoresizing properties.
With those properties, you can anchor a control to the top, bottom, or sides and control whether it stretches when the view changes size (which is typically due to a rotation)
If you’re using roughly the same layout for both landscape and portrait (which we are, minus the table view), you can use Autosizing to get you what you want.
For more complicated views, you might hide or show entire controls or resize and relayout controls depending on the orientation.
There are a number of view controller callbacks that will get called while the view is rotating to its new orientation, and in there you can update the size, position, and visibility of your controls if necessary.
Typically, you’ll use view animations here to make sure things transition smoothly.
Q: What happens if I try to use a popover on the iPhone?
There are controls and features that only exist on a particular device (and within a particular iOS version)
Now that’s gotten a little simpler, but you must always check that you’re on a particular device or that the device has the feature you are about to use before trying to do it.
Depending on what versions of iOS you support, you will also need to check to make sure certain classes exist before doing anything with them.
If you support old versions of iOS, you’ll need to do the same.
Apple has excellent documentation on writing backward compatible code that you should look into if you’re going to support older versions of iOS.
Here are some vocab words from your first iPad chapter.
Here are some vocab words from your first iPad chapter.
The images display when the app is starting up [LAUNCH]
Your iOS Development Toolbox You’ve got Chapter 7 under your belt and now you’ve added a bunch of iPad.
Universal Apps Depending on how you want to distribute your app, you can build two apps or a Universal app.
Universal apps are only sold once, but they contain code for both the iPhone and iPad, which makes maintenance easier and the customers happy!
Device Checking Once you build a Universal app, you’ll need to check for different devices so your app can behave differently as needed.
Split View Controller This controller’s job is to keep track of two child views that are displayed differently in portrait and landscape.
Once you set it up properly, you can have a small number of views that display lots of different ways.
Here’s what I ‘ve found: we just can’t be competitive anymore without an iPhone app!
Companies large and small are a significant market for iPhone and iPad apps.
Most of these apps are going to manage lots of data, and since iOS 3.0, there has been.
With my business, I’m out of the office a lot.
The courts will let me submit evidence from my iPhone now, so I need an app for that to get paid.
I picked up an iPad while I was at it, since I figured it would help me do more detailed research during boring.
Bounty hunting is not a desk job; Bob needs lots of information to pick up fugitives on the go.
His iPhone is ideal to take along while he’s chasing bad guys, while his iPad will great for more detailed background work.
They’ll have a location and details about what the fugitive was doing there.
For research, Bob needs the full dossier on each fugitive.
Picture and details should all be in the same view.
All the information he uses in the iPhone app, too.
Jim: OK, so he wants the entire package, iPhone and iPad.
Frank: Well, we’re going to want to create another universal app.
Joe: Right, then we can keep the logic and everything together, just like we did last time, but with different views.
Joe: What if  we start with the iPad, write that, and then do the iPhone, since it’s smaller?
Frank: Because we want to figure out what the two views will have in common and make sure it’s set up right.
Frank: Second, since the customer gets paid based on using the iPhone app, pretty sure he’s going to want that first.
Joe: But it’s smaller! I think we should do the hardest one first.
Frank: Listen, we work for Bob and this is what he wants.
Jim: We’ll start with designing both views, then code up the iPhone and the backend together.
Frank: Right, then we can lay the iPad view on top.
If  you’re planning on supporting both devices from the beginning, it’s best to start with an app set up to do just that.
Remember, a universal app comes with all this stuff  built right in:
The iPad app store is full of XD and XL versions of apps that you can charge for again.
That means that changes only need to be tracked once.
Universal apps have two separate view controllers and Interface Builder files, one each for the iPhone view and the iPad view.
Since all of  the logic code will be shared (if  we do our job right), there’s going to need to be more device checking than before.
Instead of  just 4 generations of  iPhones and iPod Touches, you’ll also need to watch out for iPad-specific stuff.
The way the App Store is set up, universal apps are sold as an app that will run on both devices.
Users buy the app, put it in their iTunes libraries, and then those who have iPhones and iPads can install it on both as a native app.
It may look and act differently, like iBountyHunter will, but you only get paid once.
Now, what is this iPad app going to look like? Since iPad apps MUST support both landscape and portrait, you need to think about both.
Remember—the HIG wants you to have different-looking views for the different orientations...
Fugitive ID# Bounty: This area is for notes and details about the fugitive.
The map will have pushpins for each location known for the fugitive.
When Bob selects an entry, a UIWebView will display HTMLformatted text describing the sightings for the fugitive.
We’ll add some fun UI touches, too, like a pushpin holding the description.
To show the list of fugitives, we’ll have a popover that can appear in this corner with this full list.
Fugitive ID# Bounty: This area is for notes and details about the fugitive.
The map will have pushpins for each location known for the fugitive.
When Bob selects an entry, a UIWebView will display HTML-formatted text describing the sightings for the fugitive.
More UI goodness: cool page background that looks like a corkboard.
For the landscape view, we’ll have the full list of fugitives displayed, since we have extra space.
We‘ll have the background for the text look like notebook paper.
All the views are created up front and easily accessed by clicking the tab, with each tab being tied to a specific view.
Tab bars are better suited to tasks or data that are related, but not necessarily hierarchical.
The UITabBarController keeps track of  all of  the views and swaps between them based on user input.
Standard iPhone apps that have tab bar controllers include the phone app and the iPod.
A new iPhone control Now that we’ve designed the larger interface, we need to get into the iPhone views.
In some ways, designing an iPhone view after an iPad is more difficult.
Smaller screen size and shorter interaction times are the key things to consider in creating this view, especially when there’s plenty of  data to display.
To leverage the smaller screen, we’re going to use a new controller: the tab bar.
Take a second to go back to Bob’s requirements and your iPad UI—think about how many views you’ll need for the iPhone version and then sketch up what you think you’ll need to build.
For the iPhone app, we’re going to need three views.
The quickest way to switch between different lists is with a tab bar controller.
He keeps track of  everyone he’s looking for or has captured.
Bob wants to be able to quickly display a list of  just the captured fugitives.
For each list, we’ll use a table view, like we did with DrinkMixer.
We’ll keep track of the fugitive data sorted by name.
With the tab bar controller, the user can click on the tab at the bottom of the screen to jump between views.
Q: Why are there so many UI touches in the iPad version?
A: The iPad is all about eye candy, so we’re going to show you how to add some! To get an idea of the importance of realistic UI to Apple, go check out the iPad HIG.
Another good way to get an idea of what they’re focused on is to go play with the.
There are a lot of little touches aimed at realism.
Q: How do I keep track of integrating the iPad and the iPhone UIs together?
Now that we have the UI worked out for the iPad, it’s a good idea to sit down and make up a list of the fields that we’ve included.
Since the iPhone app is smaller, we should take the iPad list of fields and pick and choose the ones we need.
Q: Can I embed a Navigation Control inside of a tab bar controller?
A: Yes, you can, but NOT the other way around.
If you have too much information to fit within one tab, but the contents are related, this may be the way to go.
The detail view for each fugitive will be available by clicking on any name.
This area is for notes and details about the fugitive.
Bob wants a separate display with the detailed information about each fugitive.
For managing these data, we’re going to use a technology introduced with.
It can manage a lot of different data types for your app.
Choose a template to start iBountyHunter This time around, we have a lot going on in our app.
A universal app with a Navigation Controller, a tab bar, and Core Data, too.
As we saw earlier, the only template that supports universal apps right now is the window-based app; so we’ll start there and add the tab bar and the Navigation Controller with Interface Builder and a little bit of  code.
After you pick the window-based application, you get this dialog box.
They’re completely different than what we had earlier when we upgraded our target to be a universal app for DrinkMixer.
Yes! This app is being designed with two front ends in mind from the start.
That means that we need to be smart about how we split up the functionality, with some of  the logic shared for both UIs and some for each device.
Now that we have the files in place, let’s focus on the iPhone stuff first...
There’s a different structure for universal apps Since we’re starting out building an app that will build for both devices, there’s a different structure from the beginning.
Some logic will be shared between the two devices, like data management, while the UI logic will be separated for each device.
All the files here are for iPhone, including the view.
Jim: OK, what do we do now? All we have is an empty view.
Joe: Well, we need to add two table views, the tab bar navigation controller to switch between those views, and the detail view.
Frank: So do we need a bunch of  new nib files to handle all these views and controls?
I like to think of  it as a blank slate.
Let’s see, we can start with the tab bar and tab bar controller...
Frank: Right, that will switch between the two table views for Fugitive and Captured.
Those views will each need nav controllers as well, to get in and out of  the detailed view.
Joe: So do we need separate nibs for the tab bar and those two views? It seems like maybe we could have all those controls in just one nib, for the tab bar and the two views, since they’re basically the same.
Jim: Yeah, but we’d still need view controllers, headers, and .m files for each of  those views.
Joe: Yup, they’re the views that need the tables in them.
We’d also need a detail view with it’s own nib and view controller, with the .h and .m files, right?
We can use Interface Builder to create the tab bar and navigation controllers.
Joe: What do we do about the rest of  the stuff ? Add new files in Xcode?
Frank: That’ll work—like before, we just need to specify that the nib files are created at the same time, and we should be good to go.
Jim: I think that all makes sense—it’s a lot to keep track of.
Joe: Well, we’re combining like three different things now, so it’s definitely going to get more complicated! Maybe it would help to diagram how this will all fit together?
The main tab controller is going to be responsible for presenting a few different views to the user, and our data will be stored in a SQLite database.
Putting all this info together is definitely easier if  you can see how it all works.
Each of our views will have a view controller that’s responsible for fetching the appropriate data for that view.
The tab bar controller gives us all the functionality we need right out of the box, so we don’t need to subclass it.
We’ll use a Navigation Controller to transition to and from the detail view.
Contains all the Core Data setup code for hooking up to our fugitive data.
Once you get into either the iPhone or the iPad app, each one has its own AppDelegate to control the views and data within each individual app.
We’ll work on this file when we get into the iPad UI.
Now that you know how the views all fit together...
So we only need two nibs: one to handle the controls for the tab bar switching between Fugitive and Captured views and another to handle the detail view.
We need to put the table view components somewhere, and we can either create new nibs for each view and have the tab controller load them...
Jim: ...or we can just include it all in one nib.
Since we don’t plan to reuse those table views anywhere else and they’re not too complicated, we can keep everything a bit simpler with just one nib.
Jim: And we need view controllers for the two table views, along with the detail view.
They’ll handle getting the right data, depending on which view the user is in.
Frank: Plus a Navigation Controller for the table views to transition to and from the detail view.
Jim: Call me picky, but I’d still like to list it all out...
Create a detail vie w with a nib and a.
Q: Why are we using a tab bar controller and a table view?
A: Our Fugitive data is hierarchical and lends itself well to a table view.
The problem is, we have two table views: the Fugitive list and the Captured list.
To support two top-level lists, we chose a tab bar.
Q: Couldn’t you have done something similar with a toggle switch, like a UISegmentControl?
The two lists are really different lists, not just different ways of sorting or organizing the same data.
Q:OK, I’m still a bit confused about the business with using just one nib for the tab controller and the two table views.
A: Well, there is a lot going on in this app, and we could have done this a different way.
We could create two more nibs, each with a Nav Controller and a table view in it.
Then we’d tell the Tab Bar Controller to load the first one as the Fugitive List and the second one as the Captured List.
Rather than do that, since the views look the same, we just put all those controls for the list in the same nib as the tab bar.
Remember, the nib is just the UI controls, not the behavior.
Q: Can you use a tab bar controller for the iPad, too? A: Yup, but you might not need them.
With the Split View Controller (which we’ll be using), you can display both a list and some details on the same screen, so you may be able to handle your data filtering with other elements.
These will be the view controllers for the Fugitive List and the Captured List.
Create a new class for the Fugitive view controller in Xcode, and then add your tab bar controller in Interface Builder.
Create a new class for the Fugitive view controller in Xcode, and then add your tab bar controller in Interface Builder.
Here’s what your file listing should look like once you’re done.
When you create these, make sure that they are UIViewController subclasses.
Add the tab bar controller.2 The window template doesn’t give us a whole lot out of  the box.
We’re going to use Xcode to assemble our views and view controllers the way we want them.
Drag the tab bar controller from the Library into your main window listing.
It’s the window that our app delegate will display when it starts.
The tab bar controller comes with a tab bar and two built-in view controllers, but we’re going to change those shortly...
Build the fugitive list view We’re going to focus on the Fugitive List first, but the same steps will apply to the Captured List when we get to it.
Delete those two view controllers and replace them with Navigation Controllers.
Since we want all the functionality that comes with a Nav Controller, delete those View Controllers and drag two new Nav Controllers in their place from the Library.
Nothing’s changed in the view—the main window listing just reflects what you’ve updated.
We don’t want the default; we want it to use our Fugitive List view controller.
To change the title for the Fugitive List view controller, double-click on the title in the nav bar and type “Fugitives”
For the tab, in the Utilities pane, change the Bar Item Title to “Fugitives”
Updated Nav Controller title is changed with the badge item.
If  you want to figure out what they are, it wouldn’t hurt!
Create a detail vie w with a nib and a.
That’s going to mean some code and IB work; we’ll come back to it in a minute.
Just do the same thing we did earlier with the Fugitives view for these two items.
Next up: the Captured view You’ve just gone through and created the classes for your two table views and dropped in a tab controller to switch between the two.
You’ve already checked quite a few things off  your list!
Use the To Do list from Jim, Frank, and Joe to figure out what’s left.
It’s up to you to create the captured view and then connect the views up with the tab bar controller...
You should end up with a list that looks like this.
Follow the same steps from earlier for creating the Fugitive view.
Right now, there isn’t an outlet to connect the tab bar controller to anything, so it won’t work.
You should be pretty familiar with how to do this by now.
Ugh! Nothing! Why isn’t the tab bar controller (or anything else) being displayed?
You’ve just done a lot of work on your app—new view controllers, new Nav Controllers, table views—all from scratch.
Check and make sure that you have the iPhone Simulator scheme selected in Xcode, so the iPad doesn’t launch instead.
Figure out why all you see is an empty view.
Look at what we did earlier in Interface Builder (shown below) and see if you can figure out what’s missing.
The window template doesn’t give us a whole lot out of  the box.
We’re going to use Xcode to assemble our views and view controllers the way we want them.
Drag the tab bar controller from the Library into your main window listing.
Q: We have a lot jammed in our main window nib.
If you’re still having trouble with the idea, it might help to open the MainWindow.xib file in Interface Builder and view it in tree mode.
The easiest way is to pick a standard icon using Interface Builder.
To do that, click on the question mark icon on.
If you want to use a custom image, set the Identifier to custom, then select your image in the Image field (you’ll need to add it to your project, just like we did with the application icon earlier)
There are a couple of peculiarities with Tab Bar icons, though: they should be 30x30, and the alpha values in the icon are used to actually create the image.
Q: How many views can I have in a tabbar?
If you add more views than can fit across the tab bar at the bottom, the UITabBarController will automatically add a “More” item and show the rest in a table view.
By default, the UITabBarController also includes an Edit button that lets the user edit which tabs are on the bottom bar.
Q: Is there any way of knowing when a user switches tabs?
A: Yes, there’s a UITabBarDelegate protocol you can conform to and set as the tab bar delegate.
You’ll be notified when the users are customizing the bottom bar and when they change tabs.
Q: Why did we add a reference to the tab bar controller in the App Delegate?
A: We’ve added the tab bar controller to the nib, but there’s a little more tweaking we’re going to have to do to get everything displaying properly.
Go ahead and give it a Test Drive to see what’s going on...
As apps get more complex, building the UI becomes more difficult.
The hierarchy view for the xib files helps visualize how the components go together.
Separating the iPhone and iPad UIs is important, but the logic needs to remain consistent.
We need to embed the tab bar controller into the UIWindow, then it will have the subviews that it needs and will display them correctly.
The window template doesn’t give us a whole lot out of  the box.
We’re going to use Xcode to assemble our views and view controllers the way we want them.
Drag the tab bar controller from the Library into your main window listing.
The problem is that the tab bar is a top-level element in the nib.
The AppDelegate has the UIWindow as its window, so the delegate will display that window.
Figure out why all you see is an empty view.
Look at what we did earlier in Interface Builder (shown below) and see if you can figure out what’s missing.
A view’s contents are actually subviews All the UI components we’ve used are subclasses of  UIView.
By dropping them into a view, we’ve made them subviews of  some bigger container view.
We need to do the same thing with our tab bar.
We just need to go back into the GUI and add one more link between the main view and the Tab Bar Controller.
Link up the rootViewController outlet to the Tab Bar Controller.
Then everything should be working! Interface Builder knows how to work with tableviews and Nav Controllers, so the datasource and delegate will be automatically handled.
Build and run and you can see both tab views working with tables.
Looks good! So now we need to get some data in those tables, right?
While the court is in the process of going digital, I still only have this on paper.
Now that the iPhone app is up and running, you need to fill in the blanks.
The list is pretty simple right now, so we can make the data into any form we want and then import it.
Frank: I was thinking—I’m not sure a plist is such a good idea this time.
Jim: Why not? We used it for DrinkMixer, and it worked fine.
Frank: Well, this list could get pretty big—remember, the list of fugitives is going to be ongoing: the ones that Bob is trying to catch and those that he already has.
Joe: Oh, that’s right—and the plist loaded everything every time.
Jim: What about that Core Data thing, that’s supposed to handle large amounts of  data, right?
Frank: That was a new data framework introduced in iOS 3.0
Jim: Why use that and not just a database? Doesn’t iPhone have SQLite support?
Frank: It does, but I’m not a SQL expert, and Core Data can support all kinds of  data, including SQL, but you don’t have to talk SQL directly.
Frank: We are, but we’ll use Core Data to access it.
Frank: Core Data handles all the dirty work for us—we just need to tell it what data we want to load and save...
What are some other limitations with how we stored data in plists and dictionaries with DrinkMixer?
Core Data lets you focus on your app Loading and saving data, particularly lots of  data, is a major part (often a painful one) of  most applications.
We’ve already spent a lot of  time working with plists and moving objects in and out of  arrays.
But wait, there’s more! Core Data makes loading and saving your data a snap, but it doesn’t stop there.
It’s a mature framework that Apple brought over from Mac OS X to iOS in version 3.0 and gives you:
The ability to load and save your objects Core Data automatically loads and saves your objects based on Entity descriptions.
It can even handle relationships between objects, migrating between versions of  your data, required and optional fields, and field validation.
Different ways to store your data Core Data hides how your data is actually stored from your application.
You could read and write to a SQLite database or a custom binary file by simply telling Core Data how you want it to save your stuff.
Memory management with undo and redo Core Data can be extremely efficient about managing objects in memory and tracking changes to objects.
You can use it for undo and redo, paging through huge databases of  information, and more.
But before we do any of that, we need to tell Core Data about our objects...
Core Data needs to know what to load We need Core Data to load and save the fugitive information that we need to populate our detailed view.
If  you think back to DrinkMixer, we used dictionaries to hold our drink information and accessed them with keys, like this:
The problem with dictionaries and plists was that we had to store all our data by using basic types and get to this data with dictionary keys.
We could have easily had a bug if  we put the wrong type in the Dictionary or used the wrong key, causing lots of  problems down the road.
What we really want is to use normal Objective-C classes and objects where we can declare properties for the fields, use real data types, etc.
We want to use strongly typed data, have properties to get to that data, and use the usual object-oriented goodness of validating the data.
Core Data works with entities and properties to give us the OO benefits we want.
We need to define our types Not only can Core Data give us the OO-based view of  our data that we want, it can even define our data graphically.
There’s one snag thoughout of  the box, Core Data supports a specific set of  data types, so we need to define our entity using the types it offers...
Dictionaries worked for DrinkMixer, but don’t provide any kind of type safety or encapsulation of our data.
These are the types we’d use if we were writing this class in Objective -C.
Core Data looks at that Managed Object Model at runtime to figure out how to load and save data from its persistent store (e.g., a database)
The Xcode template we used comes with an empty Managed Object Model to get us started.
The Managed Object Model describes the objects we’re going to ask for or try to save.
It also contains all the information Core Data needs to read and write this data from storage.
By default, our object model is empty; we’ll need to define the Fugitive entity.
The template is set up so that Core Data will try to load all the Managed Object Models defined in your application at startup.
Technically, you can create a Managed Object Model in code or by hand, but the Xcode tools.
Since our Fugitive doesn’t have any relationships to other classes, we just need to add properties.
To add the Fugitive entity, click the “plus” button all the way down here at the bottom of  the window and change the name to “Fugitive”
Once the entity exists, you can add attributes to the data model, using this plus button here.
Use these fields to edit the name and type of  the property.
You should use your normal property naming convention when naming these.
The property editor lets you enter constraints for your properties, too—min, max, whether it’s required, etc.
If we had multiple entities, you’d see the others here too, along with their relationships.
You can change the Editor Style to a tree diagram style view.
When you’re writing your own apps, there are lots of ways to set up your data model, but since we’re going to give you a database for iBountyHunter, your model must match ours exactly!
Q: Why did you use an NSDecimalNumber for the bounty? Why not a float or a double?
A: We’re going to store a currency value in the bounty field, so we want precision with the decimal part of the figure.
Our choice of NSDecimalNumber for the bounty has nothing to do with Core Data and everything to do with what we’re trying to store.
Q: What are the Transient and Indexed checkboxes for in Xcode when you create properties?
A: The Transient checkbox indicates that Core Data doesn’t need to load or save that property.
Transient properties are typically used to hold values that you only want to calculate once for performance or convenience reasons, but can be calculated based on the other data you save in the Entity.
If you use transient properties, you typically implement a method named awakeFromFetch: that is called right after Core Data loads your Entity.
In that method, you can calculate the values of your transient properties and set them.
The Indexed checkbox tells Core Data it should try to create an index on that property.
Indexes take up space and can slow down inserting new data into the store, so only use them when they can actually improve search performance.
Q: I’ve seen constants declared with a “k” in front of them.
Q: What if I need to use a type that Core Data doesn’t support?
A: The easiest way is obviously to try to make your data work with one of the built-in types.
If that doesn’t work, you create custom types and implement methods to help Core Data load and save those values.
Finally, you could stick your data into a binary type (binary data or BLOB) and write some code to encode and decode it at runtime.
Q: What other types of persistence does Core Data support?
A: Core Data supports three types of persistence stores on the iPhone: Binary files, SQLite DBs, and in-memory.
SQLite store is the most useful and what we’re using for iBountyHunter.
Binary files are nice because they’re atomic, meaning that either everything is successfully stored at once, or nothing is.
The problem with them is that in order to be atomic, the iPhone has to read and write the whole file whenever something changes.
The in-memory persistence store is a type of store that isn’t actually ever saved on disk, but lets you use all the searching, sorting, and undo-redo capabilities that Core Data offers with data you keep in-memory.
Q: What SQL datatypes/table structures does Core Data use when it writes to a SQLite database?
A: The short answer is you don’t need to know.
Even though it’s writing to a SQLite database, the format, types, and structures are not part of the public API and could potentially be changed by Apple.
You’re supposed to treat the SQLite database as a blackbox and only access it through Core Data.
Q: So this is a nice GUI and all, but I still don’t see what this gets us over dictionaries.
A: We had to tell Core Data what kind of information we’re working with.
Now that we’ve done that, we can start putting it to work.
Finish building the Fugitive entity in the Managed Object Model based on the Fugitive information we want to store.
Make sure you name your properties the same as we have in the Fugitive diagram shown below.
Make sure you use the same property names as we did.
You should uncheck “Optional” for each of the properties you add —we want them all to be required.
Finish building the Fugitive entity in the Managed Object Model based on the Fugitive information we want to store.
Make sure you name your properties the same as we used in the Fugitive diagram.
Make sure that the “optional” box is unchecked for all the properties.
Check that you used the same types for your properties as we did.
Core Data is about managing objects So far we’ve talked about how to describe our objects to Core Data, but not how we’re actually going to do anything with them.
In order to do that, we need to take a quick look inside Core Data.
This class keeps track of all the Entities (Managed Objects) our application has in memory.
When you need Core Data to load an object, you ask the Managed Object Context for it...
There are different kinds of Persistent Object Stores for ea.
All these components know how to handle our data because of the Managed Object Model.
So, if we want to load or save anything using Core Data, we need to talk to the Managed Object Context, right?
Exactly! But, the next question is how do we get data in and out of  it?
The Xcode template we used set up the Core Data stack for us, but we still need to figure out how to talk to the Managed Object Context.
Given what you know about Core Data so far, how would you go about asking the framework to load and save data for you?
Use Core Data to generate classes to do the work for you.
Write custom save and load code to update the data.
Xcode can create a Fugitive class from our Managed Object Model that we can use like any other class.
Follow the steps below to create the Fugitive class you need.
You need to have a Core Data entity selected before you ask Xcode to generate a class for you.
After confirming the save location for the new file (iBountyHunter should be the Group)...
Click Create and you should have a Fugitive.h and a Fugitive.m added to your project.
Go ahead and drag these up to the /Supporting Files group.
Select the iBountyHunter .xcdatamodel and click on the Fugitive Entity.
You need to have a Core Data entity selected before you ask Xcode to generate a class for you.
After confirming the save location for the new file (iBountyHunter should be the Group)...
Click Create and you should have Fugitive.h and a Fugitive.m added to your project.
Go ahead and drag these up to the /Supporting Files group.
Now when you create a Cocoa Touch Class, you should have an option to create a Managed Object Class.
Xcode can create a Fugitive class from our Managed Object Model that we can use like any other class.
Your generated Fugitive class matches the Managed Object Model Xcode created two new files from our Fugitive entity: a Fugitive.h header file and a Fugitive.m implementation file.
Open up both files and let’s take a look at what was created.
The class has the properties we’d expect, but no fields in the class?!?!
NSManagedObject handles storage and memory for generated properties The generated Fugitive class has properties for name, description, etc., but no fields in the class.
The Core Data framework (and NSManagedObject in particular) are responsible for handling the memory associated with those properties.
You can override this if  you want, but in most cases, this does exactly what you need.
The Fugitive.m class is nearly empty, and instead of  synthesizing the properties, they’re declared with a new directive, @dynamic.
The implementation of the Fugitive class is almost completely empty!
NSManagedObject also implements the properties The new @dynamic directive tells the compiler not to worry about the getter and setter methods necessary for the properties.
They need to come from somewhere, though, or else code is going to crash at runtime when something tries to access those properties.
Because NSManagedObject handles the memory for the fields backing the properties, it also provides runtime implementations for the getter and setter methods.
By having NSManagedObject implement those methods, you get a number of  other neat benefits:
The NSManagedObject knows when properties are changed, can validate new data, and can notify other classes when changes happen.
NSManagedObject can be lazy about fetching property information until someone asks for it.
For example, it does this with relationships to other objects.
NSManagedObject can keep track of  changes to properties and provide undo-redo support.
You get all of this without writing a line of code!
How do you think you’ll get Core Data to load a Fugitive from the persistent store?
Ask the Managed Object Context to fetch data using your NSFetchRequest All that’s left is to ask the Managed Object Context to actually execute your NSFetchRequest.
That means we’ll need a reference to a Managed Object Context.
Fortunately, the template set one up for us in the App Delegate.
Use an NSFetchRequest to describe your search In order to tell the Managed Object Context what we’re looking for, we need to create an NSFetchRequest.
An NSFetchRequest describes the search we want Core Data to execute for us.
You can provide a predicate that describes conditions the entities must meet, like if you wanted only entities beginning with the letter B.
Where do we put all this code? And where are we going to store the results? What about actually displaying the fetched data?
All that’s left is to ask our Managed Object Context to go ahead and execute our fetch request.
We’ll ask it to give us back the results in an array and clean up our references.
Where do we put all this code? And where are we going to store the results? What about actually displaying the fetched data?
As for storing the results, we’ll get back an array, but we release it right away.
We need to keep a reference to that array in our view controller.
Take what we learned on the previous couple of  pages and get the fetch working.
You’ll need to get the Managed Object Context from the delegate, create the fetch, and then execute it.
Remember to update the code to actually hang onto the results by assigning them to the array we just created.
Don’t forget to synthesize the property and clean up memory.
The next two exercises together will get you all the code you need to view the fetched data properly...
Table Cell Magnets Use the code snippets below to customize the table cells for the fugitive list.
It’s a lot of code to implement, but when you’re done, Core Data will be fetching the data you need for the fugitive list.
Table Cell Magnets Solution Use the code snippets below to customize the table cells for the fugitive list.
Wow, the court got its digital program together fast! Here’s a URL for the data I’m getting.
In XCode, rightclick on your iBountyHunter project and select “Add Files to iBountyHunter” and make sure it is copied into the project’s /Supporting Files directory.
As you do that, think about what this means for your app.
Will adding in a new database mean a bunch of  refactoring, or can Core Data help out here, too?
Bob’s database is a resource We have all this code already in place to load data—it came with the Core Data template.
But how do we get from there to actually loading the database?
Back to the Core Data stack Remember the Core Data stack we talked about earlier? We’ve gotten everything in place with the Managed Object Context, and now we’re interested in where the data is actually coming from.
Just like with the Managed Object Context, the template set up the rest of  the stack for us.
Persistent Object Store The template set up the stack for us and we only have one Persistent Object Store, so we can leave the Coordinator as is.
The Persistent Object Store is the one responsible for actually reading and writing the raw data.
Let’s take a look at what the template set up for us in the App Delegate...
Now that the database is in place and the Persistent Object Store can be used as-is, go ahead and run the app.
The template sets things up for a SQLite DB The Core Data template set up the Persistent Store Coordinator to use a SQLite database named after our project.
The template sets things up to use a DB named the same as your project.
Our problem is with how Core Data looks for the database.
This worked great and our data loaded without a problem.
But remember how we talked about how this would only work in the simulator? It’s time to sort that out.
As part of iOS security, applications are installed on the device as read-only.
You can access any resources bundled with your application, but you can’t modify them.
The Core Data template assumes you’re going to want to read and write to your database, so it doesn’t even bother checking the application bundle.
This code will only work in the simulator!!The code used to save the plist will work fine on the simulator but fail.
Let’s take a closer look at how those directories are set up...
The iPhone’s application structure defines where you can read and write For security and stability reasons, iOS locks down the filesystem pretty tight.
When an application is installed, the iOS creates a directory under /User/Applications on the device using a unique identifier.
The application is installed into that directory, and a standard directory structure is created for the app.
The app itself is stored in a directory nam ed.
The Documents and Library directories are read-write for the application and also backed up by iTunes when the user syncs their device.
The tmp directory is read-write too, but it isn’t backed up during a sync.
Use the Documents directory to store user data Since most Core Data applications want to read and write data, the template sets up our Core Data stack to read and write from the Documents directory.
The caches directory lasts most of the time, between launches and through updates, but you need to be able to recreate it, since it isn’t backed up...
Copy the database to the Documents directory When the application first starts, we need to check to see if  there’s a copy of  the database in our Documents directory.
If  there is, we don’t want to mess with it.
Here, we grab the master DB from our application bundle; this is the read-only copy.
Now that the app knows where to find the database, it should load.
You need to uninstall the old version of your app from the simulator.
This deletes the empty database that Core Data created earlier.
When you build and run again, your new code will copy the correct DB into place.
Q: Why didn’t we have to do all of this directory stuff with the plist in DrinkMixer?
A: We only ran DrinkMixer in the simulator, and the simulator doesn’t enforce the directory permissions like the real device does.
We’d basically have the same problem with DrinkMixer on a device.
The reason this was so obvious with iBountyHunter is that Core Data is configured to look in the correct place for a writable database, namely the application’s Documents directory.
Q: How do I get paths to the other application directories?
You should never assume you know what the directory structure is or how to navigate it—always look up the specific directory you want.
Q: So what happens to the data when someone uninstalls my application?
A: When an application is removed from a device, the entire application directory is removed, so data, caches, preferences, etc., are all deleted.
Q: The whole Predicate thing with NSFetchRequest seems pretty important.
Q: So is there always just one Managed Object Context in an application?
A: No, there can be multiple if you want them.
For most apps, one is sufficient, but if you want to separate a set of edits or migrate data from one data source to another, you can create and configure as many Managed Object Contexts as you need.
For example, you could have a customer’s information coming from one database but product information coming from another.
You can configure two separate persistent object stores and let the persistent store coordinator sort out which one is used based on the database attached.
Q: How about object models? Can we have more than one of those?
A: Yup—in fact, we’re going to take a look at that in Chapter 9, too.
Q: Do I always have to get my NSManagedObjects from the Managed Object Context? What if I want to create a new one?
A: No, new ones have to be added to the context—however, you can’t just alloc and init them.
That will return a new Fugitive instance and after that you can use it like normal.
We have the database loading with detailed information, but the user can’t see it yet.
Now, we just need to build out the detail view to display that information as well.
Create a detail vie w with a nib, and a.
Building the detail view isn’t anything new for you—so get to it! Here is what you’re working with from our earlier sketch for the detail view.
The detail view for each fugitive will be available by clicking on any name.
This area is for notes and details about the fugitive.
Lay out the nib using Interface Builder to have the fields we need.
Then update the new view controller to have outlets for the fields we’ll need to set and a reference to the Fugitive it’s displaying.
All of the fields should be read only since we don’t want users tweaking the bounties.
When you create the new class files, you’ll have the .m, .h, and .xib files.
Go through and check the code, outlets, declarations, and dealloc.
Use the inspector to change the default values of each of these elements to “Fugitive Name”, “Fugitive ID”, etc.
To get the simulated navigation bar, in the Utilities Panel, set the Top Bar to “Navigation Bar”
Start out by getting all the elements in the right spots, and then go back and customize them.
Here’s the final listing of the components of the detail view.
These links are from File’s Owner to the appropriate view element.
Make sure that all the added elements are children of the main view.
We’re going to add some spit and polish to this view.
It’s fine the way it is, but here’s some iPhone coolness to add.
Add a rounded rectangular button, right on top of the UITextView.
In the element listing for the view, move the button above the Text View.
With the button still selected, use the Utilities pane to uncheck the enabled box (under the Attributes panel)
You know how to do this from what we did earlier with DrinkMixer.
The other files need to know that the detail view exists.
In that same implementation file, the table view needs some selection code.
It’ll be similar to the code that we used in DrinkMixer.
The detail view code needs to populate the existing fields with the data from the fields that were set up with the Fugitive.h and Fugitive.m classes and the Core Data code.
The other files need to know that the detail view exists.
In that same implementation file, the table view needs some selection code.
It’ll be similar to the code that we used in DrinkMixer.
Adding the stringValue on the end of these two declarations handles the fact that they were not strings, but NSNumber and NSDecimalNumbers.
Test Drive After populating the detail view, you can see the information about each fugitive.
The labels have been replaced with values from the database.
The back button is working thanks to the nav control.
It works great! Having all that information with me makes it much easier to catch outlaws.
I should be able to almost double my business with this app!
Great! After a couple of  weeks, Bob is back with a new request...
That really worked! I’ve caught a ton of people already! How can I keep track of who I’ve caught? And when do I get the iPad app?
CoreData cross There’s a lot of terminology with Core Data; let’s make sure you remember it!
Match each field we need to implement for the data view to its Core Data type.
Who am I?A bunch of Core Data code in full costume are playing a party game, “Who am I?” They’ll give you a clue—you try to guess who they are based on what they say.
Fill in the blanks to the right to identify the attendees.
Any of the charming items you’ve seen so far just might show up!
Describes the search you want to execute on your data.
Includes type of  information you want back, any conditions the data must meet, and how the results should be sorted.
Responsible for keeping track of  managed objects active in the application.
Captures how data should be sorted in a generic way.
You specify the field the data should be sorted by and how it should be sorted.
Describes entities in your application, including type information, data constraints, and relationships between the entities.
Subclasses of  this represent data you want to load and save through Core Data.
Provides the support for monitoring changes, lazy loading, and data validation.
CoreData cross Solution So, did you remember all those words?
Match each field we need to implement for the data view to its Core Data type.
We used a fixed-point decimal for Bounty because it’s a dollar value and we don’t want rounding errors.
Who am I?A bunch of Core Data code in full costume are playing a party game, “Who am I?” They’ll give you a clue—you try to guess who they are based on what they say.
Fill in the blanks to the right to identify the attendees.
Any of the charming items you’ve seen so far just might show up!
Describes the search you want to execute on your data.
Includes type of  information you want back, any conditions the data must meet, and how the results should be sorted.
Responsible for keeping track of  managed objects active in the application.
Captures how data should be sorted in a generic way.
You specify the field the data should be sorted by and how it should be sorted.
Describes entities in your application, including type information, data constraints, and relationships between the entities.
Subclasses of  this represent data you want to load and save through Core Data.
Provides the support for monitoring changes, lazy loading, and data validation.
Core Data Provides a stack that manages the data so you don’t have to.
The Data Model Works with entities that have properties called attributes.
Core Data is a persistence framework that offers loading, saving, versioning and undo-redo.
Core Data can be built on top of SQLite databases, binary files, or temporary memory.
The Managed Object Context is our entry point to our data.
The Managed Object Context is part of the Core Data stack that handles reading and writing our data.
How about this one? I just can’t seem to decide which outfit to wear...
To get paid, I need to be able to show who was captured when...
Bob has to keep track of  his work so he can be paid.
That means we need somewhere to store the day and time of  a capture and then use that to build the Captured view...
Remember that Captured view we built in the last chapter?
How are we going to update iBountyHunter to handle the new information?
We need to figure out how to update iBountyHunter to handle this new data.
Look at each piece of our application and write what, if anything, needs to change.
We need to figure out how to update iBountyHunter to handle this new data.
Look at each piece of our application and write what, if anything, needs to change.
Add information about the changes to the data for display in the app.
Since nearly everything depends on the new data we need to add, let’s get that in our object model first; then we can update the rest.
Everything stems from our object model So now you’ve figured out that the Fugitive entity needs a few more fields: the date and time, and something to indicate whether the fugitive has been captured.
The database is built from the data model, so we can just update the data model to add the information we need.
The Core Data date type includes both a date and time, so we only need two more properties on our Fugitive entity:
Since all fugitives will be either captured or not, it needs to exist for all of them.
Since this field will only exist for the captured fugitives, it’s optional.
Use the data model editor to update the model with the two new fields.
After you update the model, you’ll need to delete the two old fugitive class files and generate new ones with the new fields included.
Use the Data Model Editor to update the model with the two new fields.
After you update the model, you’ll need to delete the two old fugitive class files and generate new ones with the new fields included.
Use the tools that Xcode comes with to quickly make those changes.
Test Drive Once you’ve made the changes, go ahead and run iBountyHunter.
The new fields have been added as dynamic properties, just like the earlier ones.
The data hasn’t been updated If  you take a close look at the console report of  the crash, you can figure out what’s wrong...
It’s complaining that our data model isn’t compatible with the one that created the database.
The data model is different than what was used to actually write the data.
Core Data caught a mismatch between our DB and our model We created this problem when we added new fields to the Fugitive entity.
Our initial fugitive database was created with the old model, and Core Data has no idea where to get those new fields from.
Rather than risk data corruption, it aborted our application with an error.
That’s good, but we still need to figure out how to fix it.
Data migration is a common problem Realizing you need to add new data or changing the way you store old data is a pretty common problem in application development.
Core Data works hard to make sure it doesn’t corrupt or lose any data, so we’re going to have to tell it what to do with our new Fugitive entity.
The Persistent Object Store fails to load the data, saying it can’t load what’s in that database into the new entity.
Right now, we have the old data and the new data model.
Then go back and check that it’s working again; you may need to delete it from the simulator first.
Our two models need different versions It’s easy enough to change the data model by hand, but Core Data needs to be able to work with both the old and new data.
We need to give Core Data access to both, but tell them they’re different versions of  the same model.
Even more importantly, we need to tell Core Data which one we consider our current version.
Migrate the old data into the new model We made the changes to the data model, but we need everything up and down the Core Data stack to be able to deal with those changes.
In order to do that, we need to migrate the data.
To migrate anything, you need to go from somewhere to somewhere.
Core Data needs to have both of  these data models to make data migration work for the entire stack.
We need a new approach to changing the data model, besides just changing the old one.
Let’s undo what we did earlier so we can load the data from the database again.
This is what we started with, and the Persistent Object Store is expecting this data model.
The Persistent Object Store needs to know that this is what we consider our current version.
Then in the Versioned Data Model section, select “iBountyHunter 2” as the Current version.
Xcode makes it easy to version your data model Fortunately, it’s pretty easy to create a new version of  your data model using Xcode:
Select iBountyHunter 2.xcdatamodel and re-edit the data model to add the captdate and captured fields back in as we did before.
Now the old version is preserved and the changes are where they belong.
Normally, you’d also need to delete and regenerate the Fugitive class, but since we made the same changes to.
I guess we need to write a bunch of  migration code or something.
Jim: I assume we’re going to have to tell Core Data how to get from the old version of  the data to the new one, right?
Frank: Well, actually, I think we can do it automatically.
Frank: Core Data has a feature that allows you to tell the app about both models and it can migrate the data for you.
Frank: Runtime, when the Persistent Object Store sees that the data is in the old format.
That means that we’ll just need some code to tell iBountyHunter to actually do the migration.
Joe: OK, so it looks like some of  that code is auto-generated, and some of  it needs to be added.
Jim: This is great; so we can just change whatever we want?
Frank: There are certain data changes that Core Data can handle automatically, like adding new attributes.
More complex changes to the data need to be handled manually.
Joe: Yeah, it says here that we can do automatic migration if we’re adding attributes, or changing the optional status of  an attribute.
Frank: Renaming gets tricky—sometimes you can and sometimes you can’t.
Joe: So, how can we migrate the data we have?
Core Data can “lightly” migrate data Lightweight data migration is a powerful Core Data tool that allows you to cleanly update your underlying data to match a new data model without needing a mapping model.
It only works with basic data changes: adding new attributes, changing a required attribute to an optional one, or making an optional attribute required with a default value.
It can also handle limited renaming of  attributes, but that gets trickier.
Automatic data migration happens at runtime, which means that your app needs to know that it’s going to happen so that the data can be migrated.
After adding the code to the app delegate, build and debug...
Remember, by default, Core Data will load all the object models in your app bundle.
That means it will see both the old version and the current version of our model.
All we need to do to enable lightweight migration is turn it on.
If you run into issues here, try Build-> Clean first, then Build and Debug.
Strangely, Xcode doesn’t always properly recompile the first time you version your model, but cleaning should fix it.
It’s my job to read and write your actual data.
Head First: Right, you’re the guy who translates into a bunch of  different formats.
When you use Core Data, you don’t really need to know if  your data is going into a simple file or a sophisticated database.
You just ask me to read and write a bunch of  data and I handle it.
See, it’s my job to make sure your data is loaded and saved exactly right.
Head First: I get that, but still, small changes are OK, right?
Store: Sure—I just need to make sure you really want me to do them.
You need to tell me what data I’m looking at and then tell me how you want me to return it to you.
Tell me it’s OK to infer the differences and do the mapping and I’ll take care of the rest.
Head First: So do you actually migrate the data or just translate it when you load it?
Simple stores like the binary file ones just create a new file with the migrated data.
But if  I’m using a SQLite DB, I can usually do the migration right in place.
Don’t need to load the data and the whole migration is nearly instant.
Head First: Nice! I thought lightweight migration was kind of  a noob’s migration.
Store: Oh no, if  you can let me do the migration through lightweight migration, that’s definitely the way to go.
Now if  you need to do something more complicated, like split an old attribute into two new ones or change the type of  something, you’ll need to help me out.
Basically, you need to give me one more model, a mapping model.
That tells me how to move your data from the old format to the new format.
Store: Actually, most of  the time I can handle that too, as long as you tell me what the old name was.
If you look at the details of  an attribute in your object model, you can give me the old name of  an attribute.
If  it’s there, and I have to do a migration, I can handle renaming, too.
Head First: Wow, you’re not nearly as boring as I thought...
Q: How many versions of a data model can I have?
Once you start adding versions, you’ll need to keep track of your current version so that Managed Object Model knows what you want when you ask for an entity.
By keeping all the old versions around, Core Data can migrate from any prior version to the current one.
Q: When is renaming something OK for a lightweight migration? When isn’t it?
A: You can rename variables as long as you don’t change the type.
If you rename them, click on the little wrench on the attribute properties in Xcode and specify the renaming identifier to be the old attribute.
Q: Can I use migration to get data I have in some other format into Core Data?
If you have legacy data you want moved into Core Data, you’ll need to do that yourself.
Typically, you just read the legacy data with your own code, create a new NSManagedObject to hold it, populate the new object, and save it using Core Data.
There are a couple other approaches you can look at if you have large amounts of data to migrate or streaming data (for example, from a network feed)
Q: Does it make a difference if I use lightweight migration or migrate data myself?
It won’t work for all cases, but, if it can be done, Core Data can optimize the migration if you’re using a SQLite store.
Migration time can be really, really small when done through lightweight migration.
Q: What do I do if I can’t use lightweight migration?
Q: Xcode lets me enter a hash modifier in the Versioning Settings for an attribute.
A: Core Data computes a hash for entities using attribute information so it can determine if the model has changed since the data store was created.
However, it’s possible that you need to change the way your data is stored without actually changing the data model.
For example, let’s say you always stored your time values in seconds, but then decided you needed to store milliseconds instead.
You can continue to store the value as an integer but use the version hash modifier to let Core Data know that you want two models to be considered different versions and apply your migration code at runtime.
Lightweight automatic migration needs both versions of the data model before it will work.
Automatic migration can change a SQLite database without loading the data.
You can use lightweight migration to add variables, make a required variable optional, make an optional one required with default, and to do some renaming.
Add information about the changes to the data for display in the app.
What kind of changes do we need to make to the UI to add the captured information?
I want all this captured info on the detail view.
Here, I sketched up some ideas for you on how to do that.
I was thinking I could just type in Y or N when I capture a guy? Then fill in the date and time below.
As an experienced iOS developer, you can probably come up with some better UI designs.
Can Bob’s view actually work with the app as it’s currently written? (Circle one)1
To properly implement this view, you need to know what data is editable.
What data can the user edit and what is the best way to handle that input?
Now that you’ve thought through the design implications, what should the detail view look like?
Can Bob’s view actually work as is with the app as written? (Circle one)1
To properly implement this view, you need to know what data is editable.
What data can the user edit and what is the best way to handle input?
We already have a Back button where Bob wants to put a Cancel button.
Asking the user to input the “Y” or “N” and type the date and time is not.
The only data that will need to change is the Captured field and the Captured date and time.
Since Captured is a boolean, a switch or some kind of control will work better than.
That will mean NO typing required to input the data.
Since Bob will hit the control when he captures the bad guy, we can just get the current date and time from iOS and save even more typing.
Make the additions you need to the detail view to include the additional fields.
Go ahead and add the visual elements you need: the three labels and the segmented control.
You’ll need to add a simulated tab bar to make sure everything will fit.
Now that all those interface elements exist, give them the back end in Xcode, but don’t worry about linking them just yet...
Here are the additions to the view and the code to support them.
This is the label that will hold the captured date and time, but it’s empty unless the switch is toggled to Yes.
The segmented control needs to be configured (it says first/second by default)
Toggle this selection to get to the other half of the control.
Make sure “Segment 0 Yes” is selected and both segments are enabled.
Finally, link the capturedToggle outlet for the segmented control to File’s Owner in Interface Builder.
Q: Why didn’t we use the switch instead of the segmented control?
A: Because there’s no Apple-sanctioned way to change the text of the switch.
By default, the options are On and Off, which won’t work for us.
Q: Why didn’t we use a checkbox for the captured field?
A: It turns out that the checkbox isn’t a standard control.
It’s certainly surprising, since you see them so often in iOS apps.
They can be done, however, by creating a custom button with three images (an empty box, a selected box, and a checked box), and switching between them.
All the view elements look good! Now we just need to implement their behaviors...
Toggle Code Magnets Now that we have the controls laid out the way we want them, we need to actually give them some behavior.
Use the magnets below to implement the method that will handle the segmented control switching.
Then everything will be ready for linking to the segmented control in Interface Builder.
Toggle Code Magnets Solution Now that we have the controls laid out the way we want them, we need to actually give them some behavior.
Use the magnets below to implement the method that will handle the segmented control switching.
Then everything will be ready for linking to the segmented control in Interface Builder.
This will only be called if the value actually changed, so if the selected index is now 0, the fugitive wasn’t captured prior to this call.
This will return an NSDate set to the current date and time.
Core Data stores booleans as NSNumbers, so we need to convert our boolean YES/NO values to NSNumbers to update the fugitive.
If the fugitive isn’t captured, clear the old capture date if there was one.
Now that all that work is done, you should have a functioning detail view.
The view looks great and the segmented control is set to No, just like it should be.
If you toggle the segmented control, the date and time are filled in.
OK, but if I come in and out of the app, it’s not restarting.
What’s the deal with that? I thought that only one app was.
That means that apps don’t terminate when you leave them, or the phone rings, or you flip over to your iPod to change your music.
The problem is, as of  iOS 4, most iOS devices support multitasking and the application lifecycle has changed.
Because of  the constraints of  mobile hardware, the applications aren’t running in a full multitasking model like you’d see on a desktop.
Instead, applications have a very specific lifecycle they go through as iOS starts and stops them.
Your app will spend a lot of time here—running, getting UI events, generally doing normal app things.
This can also happen if the user unlocks the screen and you’re still running,  for example.
Add the save code to the right place to handle multitasking.
Multitasking rules of engagement Apple provides excellent documentation in the iOS Application Programming guide detailing each state transition and the corresponding method calls and notifications you’ll receive.
You have a limited time to handle moving to the background.
At a minimum, you should save any modified user data when moving into the background.
You should also save application state information you might want to restore the application to where the user left it.
They shouldn’t know that your application was terminated between when they left it and when it restarted.
You can request more background time if you need it.
Once you enter the background state, you won’t be told if you’re killed.
Once you enter the background state, iOS will try to keep you in memory in the suspended state.
However, applications are terminated based on resource availability, so if  you can reduce memory usage, your app may run longer.
Your app will not receive any further notifications before it’s killed off, which is why it’s so important to persist everything you need to start up again later as soon as you get backgrounded.
If the device doesn’t support multitasking, your app will be terminated.
If  the device your app is running on doesn’t support multitasking (iPhone 3G, for example) or you have opted out of  multitasking support, your application is simply terminated when the user leaves it.
The application isn’t going to terminate anymore, it’s going to go into the background, thanks to multitasking support.
The Managed Object Context saves new or changed items We’ve used the managed object context to load our Fugitives, but it is also responsible for coordinating saving your data.
Remember how NSManagedObject can keep track of  changes to entities? The Managed Object Context can take advantage of  this information to tell if  you if  there are any changes in the objects it’s managing.
Similarly, if  you create a new instance of  an NSManagedObject, you need to tell it which Managed Object Context it belongs to and that Managed Object Context knows it has new entities to keep track of.
The Core Data template takes advantage of  this during application exit to see if  the Managed Object Context has any new or changed data.
If  it does, the application simply asks the context to save them.
Saves changes in the application’s managed object context before the application terminates.
There are some notes that came with the template that you can delete in here...
Relocate the save code to the right place to handle multitasking.
Q: You said if I create new instances of NSManagedObjects, I need to tell them which Managed Object Context they belong to.
The Managed Object Context is provided right from the start.
Q: What’s the “&error” that’s being passed to the save call?
A: Most Core Data load/save operations point to an NSError in case something goes wrong.
The “&” in Objective-C behaves just like it does in C or C++ and returns the.
We declare a pointer to an NSError, then pass the address of that pointer into the save method in case something happens.
If the save call fails, Core Data will populate that error argument with more detailed information.
Keep in mind that just checking for an NSError does not work for determining if a method succeeded.
For that, you should check the BOOL return value, since the error is only tracking if success was NO.
Q: Speaking of errors, what should I do if this comes back with an error?
Depending on when you detect the problem, you can warn the user and try to recover; other times, there’s not too much you can do.
The Core Data template set it up this way for convenience, but you should save whenever it’s appropriate in your application.
In fact, if you’re using a SQLite database backend for your data, saves are significantly faster than when we were working with plists in DrinkMixer.
You should consider saving additions or changes to the data as soon as possible after they are made to try to avoid any kind of data loss.
Q: You said Core Data could do data validation; where does that fit into all of this?
A: At a minimum, Core Data will validate objects before they’re stored in the Persistent Store.
So, it’s possible that you could get a validation error when you try to save your changes if you have invalid data in one of your managed objects.
To avoid such late notice, you should validate your NSManagedObjects as close to the time of change as possible.
You can call these methods at any time to verify that the NSManagedObject is valid against constraints you put in the data model.
If it’s not, you can notify the user and ask them to correct the problem.
When a Managed Object Context is told to roll back, it will discard any newly inserted objects, deletions, and unsaved changes to existing objects.
A quick demo with Bob After seeing the detailed view and all the captured stuff, Bob’s thrilled, but has one quick comment:
This is definitely way easier than what I came up with.
After all that, we forgot to populate the Captured list!
OK, I know how to populate the table cells and stuff—but how can I only pick captured guys?
We already have capture information in our Fugitive data; we just need to use it to get the Captured list.
We need a way to tell Core Data we only want Fugitives where the captured flag is true.
Where is a natural place to put this kind of filtering?
Use predicates for filtering data In database languages all over the world, predicates are used to scope (or limit) a search to only find data that match certain criteria.
An NSFetchRequest describes the search we want Core Data to execute for us.
Entity Information tells Core Data the type of the data we’re searching for (and want back)
If it doesn’t match, it doesn’t get returned with the results.
We used the Sort Descriptor to order the data alphabetically in the results.
NSFetchRequest concepts are nearly identical to SQL The three major concepts in an NSFetchRequest are nearly identical to the expressions in standard SQL.
All we need to do is provide the predicate information to our NSFetchRequest and Core Data handles the rest.
Time to populate the Captured view! There’s some work to get the Captured view updated to where the fugitive view is, and then a tweak to display what we need.
Build and run the old version of  the app and toggle a handful of  the fugitives to “captured” before making any changes.
When we left off  in Chapter 8, we hadn’t yet done the work to populate the Captured list.
Since we’re just going to be filtering the data that’s in the Fugitive list, the easiest way is to start with the entire list and then add the filtering code.
Update your NSFetchRequest to use an NSPredicate so it only finds captured fugitives.
We need to set a predicate on our NSFetchRequest NSPredicate is a deceptively simple class that lets us express logical constraints on our NSFetchRequest.
You use entity and attribute names along with comparison operators to express your constraint information.
You can create a basic NSPredicate with a string format syntax similar to NSString, like this:
You can even build complex fetch requests graphically in Xcode.
For iBountyHunter, a simple attribute condition is all we need to get Bob’s view working, so we’ll create the predicate programmatically.
You should recognize the code from Chapter 8 to get the captured view working, and then add the predicate code to get the filtered data.
Just do this through the app—any 5 that you want!
Make sure the Captured view is importing all the delegates and data that we need.
Since the user could have changed how many fugitives are captured, we need to reload our table view.
You should recognize the code from Chapter 8 to get the captured view working, and then the predicate code to get the filtered data.
Get the Captured view to match the Fugitive view (continued).2
Go ahead and fire it up—the captured view should be ready to go!
It works! These are the five fugitives we marked as captured.
What problems would we introduce if we moved the fetching code to viewDidLoad? What else could we do to improve performance?
Hang on—you said we should be careful with memory and performance and blah blah...Now we have two arrays of fugitives and we reload them every time the view appears.
If  we move the code there, we’re going to end up with two new problems.
The problem is that viewWillAppear gets called every time the view is shown, which means we’re reloading all the fugitives and all the captured fugitives every time, regardless of  whether anything’s changed.
We could move the code to viewDidLoad, but that only gets called when the views are loaded from their nibs.
First, if  we mark a fugitive as captured, the Captured List won’t reflect that since it only loads its data once.
What we need is a better way to manage our fetched data.
High performance UITableView support UITableView needs to know how many sections there are, how many rows there are in each section, etc.
Built-in monitoring for data changes We’ve already talked about how the Managed Object Context knows when data is modified.
Delete the reference to the items array here and release the new controller.
Next we need to change the search to use the controller...
We want the controller to tell us when data changes—we need to conform to its delegate protocol.
We’re creating a read-only property since we don’t want anyone setting it.
If we’ve already initialized our results controller, just return it.
If we’ve already done this (the view is being shown again), we can just bail.
Now instead of asking the Managed Object Model to perform the fetch, we ask the controller.
Now you need to update the tableview delegate and datasource methods to use the controller instead of the view.
Use those to figure out how many sections there are and how many rows in each section.
In fact, it can do it a lot more efficiently.
For the number of sections, we can just return the count of the sections in the controller.
Nothing fancy here—just get the Fugitive at the given indexPath.
One more lookup for the indexPath to get the Fugitive, and we’re all set.
Test Drive Go ahead and run iBountyHunter to make sure the changes didn’t break anything.
The views should be loading just like they were...sort of.
Do some quick testing—if you mark a fugitive as captured, does he switch lists? What if you exit and come back into the app using the Home key?
Test Drive Now that you’re using the controller instead of just a predicate, the behavior of the app should be the same.
But people are showing up in the Captured list even when they’re not marked as captured!
Why aren’t fugitives properly changing lists when you change their captured status? Hint: think back to the “Five-Minute Mystery” from Chapter 6...
We need to refresh the data The fugitives aren’t properly changing lists when you change their status because we’re not refreshing the data every time the Captured list view is displayed.
We ask the whole tableview to reload its data when we detect a change.
There are more efficient means of just reloading modified rows when you have larger tableviews.
The view controller has built-in support for monitoring the data for changes through a delegate.
We had set ourselves up as that delegate but never implemented the code to handle data changing.
Test Drive Do the same thing you did last time, build and run, and then change the status of one of the fugitives to pull him dynamically out of the captured list.
This is awesome! The advantage I’m going to have over the competition is great, and having all that information with me means that I’ll be making way fewer trips back to the police station.
Q: Where can I find the full syntax for NSPredicate?
A: NSPredicate has a pretty complex syntax available for expressing constraints on your data.
There’s a simple summary available in the NSPredicate class documentation, but Apple has an entire document available to help you write advanced predicates.
Q: It seems like it would be pretty easy to make a mistake typing predicate syntax into code like that.
A: Yes, and Xcode can offer a lot of help here.
Instead of embedding your predicates in code, you can build them graphically using Xcode’s data modeler, just like we did with the Managed Object Model.
To build a predicate graphically, select an entity in Xcode, then click on the plus as though you were adding an attribute.
Select “Add Fetch Request” to create a new fetch request and click Edit Predicate to bring up the graphical editor.
Then just use that fetch request instead of one created in code.
You can also use Xcode’s builder to assemble a predicate, then just cut and paste that into your code if you’d prefer to keep them there.
Q: Reloading the whole table when data changes seems pretty inefficient.
There are a number of delegate methods you can implement to get finer-grained information about what’s happening with the Managed Object Context.
With that information, you can find out if you just need to update a specific table view cell, insert a cell, or remove a cell.
We took the easier route and just asked the table view to reload completely.
Q: What’s with that cache value we gave to the results controller?
A: The results controller will use that file name to cache information like the number of items, number of sections, etc.
It will keep an eye on the data store and regenerate the cache if something changes.
You can also forcibly ask it to remove a cache, but in general, you shouldn’t need to.
How do I get it to split things into multiple sections?
You can get really sophisticated and create a transient property if you want to group them by something you’re not actually storing in the database and calculate the value using a custom getter added to your object model.
NSFetchRequest can take an NSPredicate to filter data based on logical conditions.
You can express NSPredicate conditions in code or using Xcode’s predicate builder.
Be careful about what you put in viewWillAppear, as it will be called every time your view is shown.
DataMigration cross We have some new data lingo to try out, so flex those verbal skills...
DataMigration cross Solution We have some new data lingo to try out, so flex those verbal skills...
Your Data Toolbox You’ve got Chapter 9 under your belt and now you’ve added.
Core Data can use lightweight migration to automatically make database changes.
Versioning is used to keep track of the data migrations.
Lightweight migration can be used to add attributes or changing optional status.
Does data migration, sometimes without actually needing to load the data.
Uses mapping models if the changes are too much for lightweight migration.
Hey wait! The court says I’m gonna need pictures to get paid quickly.
It’s a good thing the iPhone comes with a camera...
As any iPhone, iPod Touch, or iPad user knows, these devices go way beyond just.
For Bob, payment requires proof Bob is working hard on getting as many fugitives off  the street as he can, but to get paid he has to document his captures.
I need a picture of the arrest when it happens, and since my phone has a camera, I was thinking you might be able to help out.
This is more important than the iPad app, that can wait...
Bob wants a picture of  his catch and he’s going to need it to be pretty big—so let’s go ahead and put it on its own view.
Those pictures will be great for advertising too, not to mention that it will speed up payment!
Here’s what we came up with for the photo view.
Flip over for the detail view We can use a built-in animation for some nice usability with a little flair here.
Since Bob will only want the photo after drilling down through to the detail view (what he’ll use to find his fugitive), it makes sense to stick it on the back of  the detail view.
This is a really common interface for the utility apps on the iPhone.
Typically, there will be two views, one with an info button on it, and another that is revealed by flipping over when the info button is clicked.
The flipping is just another transition that comes with UIKit.
We can steal the idea to give a nice baseball-card look to our fugitive detail view.
If we shrink up the space for the description, we can move the capture info up and leave room for the new button.
What kind of view will you need to implement for this? Hint: You used it for DrinkMixer...
The detail view needs a new info button, and an action to trigger the new flip view.
The info button is just a regular button with the Info Dark type.
Use a custom animation to show the new view when the info button is pressed.
You already know how to present a modal view, but this time we want to do it with a custom animation.
Take a look at the UIViewController documentation if  you’re stuck on how to use it.
That’s going to mean a view with a UIImageView and a Done button.
Don’t forget the action to tie in with the button and dismiss the view.
Don’t forget to connect the button and the IBAction in Interface Builder!
Don’t worry about an IBOutlet for the UIImageView yet; we’ll get to that in a second.
This one is a whole bunch of functionality that you added without much help! Here’s what we came up with:
Start by creating a new UIViewController subclass, with a .xib file to use for our image.
When the done button is pressed, we want the view to go away.
Use a custom animation to show the new view when the info button is pressed.
Instantiate the view controller and open up the flip view nib.
Wire this up to File’s Owner, at the top of the dialog box.
The info button is just a UIButton configured in the inspector as an “info dark” type.
Make sure you have the simulated tab bar in here too, so it doesn’t get hidden!
This one is a whole bunch of functionality that you added without much help! Here’s what we came up with:
Test Drive Run the app and see the cool animation working!
This is the image view —it’s empty, but not for long...
The and the need to be again so this will work.
The has to know about the image and where to display it.
Now the views and animations are all working properly, what about the image itself? Think about the data model when you fill in the blanks below.
The and the need to be again so this will work.
The has to know about the image and where to display it.
Now the views and animations are all working properly, what about the image itself? Think about the data model when you fill in the blanks below.
Do this! You’ve migrated a database before, and you’re going to need to do it again.
Just so it’s handled and out of the way, get into Xcode and do another database migration.
Then in the Versioned Data Model section, select “iBountyHunter 3” as the Current version.
Add the new field to the new data model (iBountyHunter3) and generate the new Fugitive class.
For the image, we’ll need a new attribute called “image” that is a binary data type.
Then delete the old Fugitive.h and Fugitive.m files and generate new ones via the New File menu option.
Check out Chapter 9 if you’re still fuzzy on how to do this.
Why? Because our real mission here is to pick an image (after one is taken by the camera, or from a stored one)
UIImage The view for the image picker is already written and will automatically be used when you present the controller.
If it received an image, our view controller needs to update its fugitive with the image that will be persisted the next time save is called.
The delegate gets an image the same way, regardless of whether it came from the Photo Library or was just taken with the camera.
Here is some code you’ll need to tie the image picker together.
When the view appears, display the fugitive capture image if there is one.
This allows the users to edit the photo they are choosing.
Time to get some images! Using the code for the image picker that we gave you, as well as some of your Objective-C skills, let’s get the image going.
Import the Fugitive header file and declare a property for the fugitive.
Using Interface Builder, you’ll need to create a button that covers the entire UIImageView and is then set behind it.
Store the image when it’s selected and update the UIImageView.
You need to set the image information on the fugitive when the picker gives us an image, then make sure the UIImageView is updated when the view is shown.
You’ll need an outlet for the UIImageView; then link it in Interface Builder.
Import the Fugitive header file and declare a property for the fugitive.
Here are all the pieces put together to implement the button.
Store the image when it’s selected and update the UIImageView.
We’ll need an outlet so we can update the UIImageView with the selected image.
To keep them in the right order in the view, make sure the button is listed above the image view in the listing.
Here’s all of the pieces put together to implement the button.
This is a little tough to make out, but the button is behind the UIImageView.
Change the default text to “Tap here to add a photo”; since it’s behind the picture, you’ll only see it if there’s no image.
Build and run to see your new picture view in action.
The simulator is reacting to the fact that you are asking for the camera and it doesn’t have one.
But more than the simulator not having the camera, some iPod touches and iPads don’t either.
The iPhone isn’t the only device using apps One of  the things that Apple requires when you release an app is that it can work on all devices you claim it can, even if  a particular device lacks certain hardware capabilities.
Part of  the approval process for apps is that they are checked for compatibility with the iPod Touch and iPad.
All this means that you need to be aware of  when your app may be straying into areas where an iPhone behaves differently than other devices.
Pool Puzzle Your job is to take items from the pool and place them into the list for the iPhone, iPad, or iPod Touch.
Your goal is to make a complete list of the functionality for the iPhone, iPad, and iPod Touch.
Note: Each thing from the pool can  be used more than once!
Pool Puzzle Solution Your job is to take items from the pool and place them into the list for the iPhone, iPad, or iPod Touch.
Your goal is to make a complete list of the functionality for the iPhone, iPad, and iPod Touch.
Note: Each thing from the pool can be used more than once!
You may have noticed some random stuff on this list—who would’ve thought about the speaker?
Apple is always coming out with new devices and updating.
There’s a method for checking With all these little things that can be different between devices, pretty much every time you go to use something from the device, you need to check and see if it’s there.
You need to be careful to check for specific capabilities for a device, too.
For example, we only use still image capture, but if  you wanted to do video capture, you need to check that not only does the device have a camera, but also that it’s capable of  video capture.
If  you’re trying to capture HD video, you need to make sure it can do that, too.
Since we’re getting the info from a source, we need to check and see if the source you want is there.
So what happens when the user taps the “Take a photo” button? You check for the camera, then what? What’s the user flow?
In our case, we have another option: the photo library.
If  there’s no camera, we can get an image from there instead.
If  you’re writing an application that cannot do something without a camera and the check fails, you need to disable that feature (and potentially hide the controls so the user isn’t confused trying to enable that feature)
Prompt the user with action sheets Action sheets slide up from the bottom of  the page and give the user options to proceed.
It’s similar to a modal view because the user has to address the action sheet before she can move on to anything else.
Action sheets are really straightforward to use: they take strings for their buttons and have built-in animations for appearing and disappearing.
Our code for the action sheet has some standard stuff  included:
Go to the camera, take a picture, and then come back and put your new image into the Fugitive.
Go to the photo library, pick an image, and then come back and stuff that image into the Fugitive.
Use action sheets to let the user pick the image source We know that our options are to use the camera, use the photo library, or cancel, so we’ll need to implement the behavior for each option.
First, allocate the action sheet, and pass it a title.
All action sheets need a cancel button, so you can dismiss it, just like modal views.
There’s a lot here to think about since we’re changing the flow of the app a bit.
If not, the app should just go straight into the photo library.
Think about the options for case 1 and the default, and make sure you release the picker and present the view.
The action sheet should be ready to go and your app has a good user flow now...
Test Drive Fire up iBountyHunter and drill down through a fugitive to the point of taking a picture.
The action sheet pops up, and once you select choose the existing photo...
It might be time to register with Apple’s Developer Program.
If you do, you can install the app on your actual iPhone and test it yourself.
Check out the appendix at the end of the book to help you walk through the provisioning process to make it work.
Your simulator will not have images unless you install them.
The easiest way to do that is to drag and drop photos onto the simulator, then click and hold on them in Safari and save the image.
Q: Don’t newer iPhones and iPads support video now? How do I get to that?
By default, it uses still images, which is what we want for iBountyHunter.
Q: What about the whole augmented reality thing with the camera? Can I do something like that?
There are still limitations on what you can actually do in the camera view, but you can overlay it with your own information if you want.
A: The picker controller has built-in support for cropping and zooming images.
The allowEditing flag controls whether or not the users get a chance to move and resize their image before it’s sent to the delegate.
If you enable it, and the user tweaks the image, you’ll be given editing information in the callback.
Q: Do we really have to worry about the devices without cameras?
When you submit your application to Apple for inclusion in the iTunes App Store, you specify the devices your application works with.
If you say it works, Apple will test it on both types of devices.
They also run tests where your application cannot get network access to ensure you handle that properly as well.
Apple is going to test your application in a variety of scenarios.
Q: Is there any way to test the camera in the simulator?
What we’ve done is about as close as you can get, which is to implement.
You’ve learned a lot so far, and lots of the functionality that you’re moving into has outgrown the simulator.
A: In order to install an app on your device or to submit an app to the App Store, you need to be a registered iOS developer with Apple.
Even if you want to just install an app for your own personal use, you’ll need to be registered.
Look at the appendix for more detailed directions on how installing an app on your phone actually works.
Bob needs the where, in addition to the when You’ve given Bob a way to record the proof  he captured someone with a photo, and an easy way to note when it happened, but what about the where?
Cool—I love the pictures—but I need location info about the grab, too.
There are rules about where Bob can nab criminals, so he needs to keep track of  where the capture occurred.
The easiest way for Bob to keep track of these things is by recording the latitude and longitude of  the capture.
How are two new fields going to affect the app? Use this space to show where, and on what view, the latitude and longitude info will end up.
What needs to happen to the data model and the data itself?
Here’s what we came up with for the new view and the data changes:
The database needs to be updated: we’re going to be getting a latitude and longitude value in degrees.
To hold them in the database, they’ll need to be broken up into two new attributes for the Fugitive class: latitude and longitude.
What needs to happen to the data model and the data itself?
Get into it and get the app ready for the capture coordinates:
Implement the new fields in the view for the location label and the latitude and longitude fields.
Migrate the database again and produce the new Fugitive class with the latitude and longitude fields.
We called them capturedlat and capturedlon and made them type “Double”
Get into it and get the app ready for the capture coordinates:
Implement the new fields in the view for the location label and the latitude and longitude fields.
The values will be added here when the fugitive is captured.
Migrate the database again and produce the new Fugitive class with the latitude and longitude fields.
The new fields, capturedLat and catpuredLon, are both of type “Double”
OK, so I’d bet you can get latitude and longitude from the GPS on the iPhone, but didn’t you just warn us that iPod Touches and Wi-Fi iPads don’t have that?
You may remember back in that pool puzzle we said something about the iPod Touch and Wi-Fi iPads being able to handle limited location.
Core Location can find you in a few ways GPS is often the first thing most people think of  for getting location information, but the first generation iPhone didn’t have GPS, and neither do iPod Touches or Wi-Fi iPads.
There are actually three ways available for iOS to determine your location: GPS, cell tower triangulation, and Wi-Fi Positioning Service.
If  your head is starting to spin, don’t worry! Core Location actually decides which method to use based on what’s available to the device and what kind of  accuracy you’re after.
That means none of  that checking for source stuff; the iOS will handle it for you with the LocationManager:
Core Location relies on the LocationManager To use Core Location, you simply need to create a location manager and ask it to start sending updates.
It can provide position, altitude, and orientation, depending upon the device’s capabilities.
In order for it to send you this info, you need to provide it with a delegate as well as your required accuracy.
The CLLocationManager will notify you when positions are available or if  there’s an error.
You’ll want to make sure you’re also properly handling when you don’t get a position from the location manager.
Even if  the device supports it, the users get asked before you collect location information, and can say “No” to having their position recorded (either intentionally or by accident)
Higher accuracy can take longer to get a fix, affecting the performance of your app.
Once the locationManager has the position, it will start sending it back to the delegate.
I guess we’re going to need a new header file for some Core Location constants?
To keep the size of  your app small, Apple breaks apart functionality into libraries.
As you start adding new functionality, like Core Location, you’ll need to start adding frameworks.
Since the Core Location framework isn’t included by default, we need to add it.
Add a new framework It’s time to add the Core Location framework to the app.
Then click the + button and choose the CoreLocation framework.
The new framework should be relocated to the /Frameworks folder.
We’re working through the delegate, so tha t needs to be there.
Declare the CLLocationManager so we ca n use it and.
Making frequent calls from your app to find locations will quickly drain batteries, since it turns on the GPS/cellular/ Wi-Fi receiver.
Bob needs the location and date and time to mark a capture.
What method will be used to kick off  Core Location in the detail view?1
What happens when the location is returned to the view controller?2
What happens if  Core Location can’t get anything or the user disables it?3
Bob needs the location and date and time to mark a capture.
What method will be used to kick off Core Location in the detail view?
What happens when the location is returned to the view controller?2
We’ll know the location manager can get the current position.
If the user marks the fugitive as captured, we need to get the current position from the location manager and update the fugitive.
This is going to call our new method with all the fugitive information, including updated location information.
We don’t need the continually updating locations, so we’ll ask the location manager for its last location when the user toggles the captured control.
Disable the capture toggle button until we have a location fix.
Since Bob needs the location info when he marks a fugitive as captured, we’ll need to disable the captured switch if we can’t get anything.
What happens if  Core Location can’t get anything or the user disables it?3
Since the segmented controller really doesn’t have a nice disabled look, you might want to consider using a UIAlertView to warn the user that they can’t mark anyone as captured.
The location manager will notify the delegate (us) when it gets a valid position update.
If the location manager can’t get a fix, it will send us error information.
We’ll shut it down when we leave the detail view.
All we do is tell Core Location the accuracy we want and it deals with the rest.
So, the iPod Touch can get just the best data it can, and we’ll get that.
Implement all this code and then take it for a spin...
Make sure you shut down the location manager when you don’t need it to conserve batteries.
Q: We start and stop Core Location in viewWillAppear and viewWillDisappear.
A: It’s normal to start and stop Core Location as you need it.
It uses a fair amount of power while it’s running, so it’s best to shut it down if you don’t need it.
This gets a little tricky because Core Location can require some time to get its initial position information.
To try to make that a little smoother for the user, we enable it as soon as the view appears to give it a head start before the user needs the location.
Q: Is there any way to speed up that initial position? A: Core Location will try to cache previous position information so it can give you something as quickly as possible.
Because of this, if you’re really concerned about accuracy, you should check the timestamp sent along with the position information to make sure the position is recent enough for your needs.
Q: Does location accuracy impact things like startup time or battery usage?
The more accurate a position you ask for, the more battery Core Location will consume, and it will potentially take longer to figure out.
Use whatever accuracy you need for your application, but be aware of the implications of high-resolution information.
Q: Is there a way to just wait for Core Location to have a position rather than having it call back to the delegate like that?
Core Location, like a lot of other frameworks in iOS, calls back asynchronously as data is available.
You need to make sure you keep your users informed of what’s going on in the application and what they can and can’t do at the moment.
For example, we disable the Captured button if there’s no position information available.
Other options display a wait indicator (like a spinning gear) or display position status with a disabled indicator like an icon, button, or label.
Q: Why did we have to move the code around and do all that refactoring?
We cleaned up the code and eliminated duplication by pulling it out into a separate method and calling that from the two places that need it.
Q: What’s the deal with the private interfaces again? A: Remember that our header file captures our public interface or API.
We don’t want this internal method to be part of our API (in other words, we don’t want other people to call it)
We still want to declare it so the compiler can check that we’re calling a valid method, so we add a Private set of methods to our interface in the implementation file.
Some people actually put an _ (underscore) before their private method names so that it’s obvious that you shouldn’t be calling this from anywhere but the class’s own implementation.
Test Drive Implementing Core Location really wasn’t that hard, but making it work in the user flow required a bit more work.
Now that it’s all done, you should be up and running...
To operate the app here, Bob will navigate into the detail view, which will kick off the Core Location manager.
When the user navigates away from the detail view, Core Location shuts down to save batteries.
That’s great for my forms and everything, but I’m more of a visual person...
What’s the point of  all the network connectivity and fancy graphics if we just show a text field? With just a little bit of  code and the iOS Map Kit, we’ve got something a lot more appealing in the works.
Map Kit comes with iOS When Apple opened up the API for the Map Kit in iOS 3.0, developers gained access to the maps that come from Google maps, including satellite imagery.
There’s lots of  customization that you can do with the maps, such as how wide an area they show, what view they start with, and pins and annotations.
MKMapView is a control that pulls map information from Google Maps.
You can configure it for the normal road display, satellite imagery, or a hybrid, like you see here.
Map Kit comes with built-in support for pushpins at specified locations, called annotations.
Depending on the information you want to show on the map, you can create your own views for annotations and show anything you want, like pictures, formatted text, etc.
Since Map Kit pulls imagery information from Google, you’ll need to have a network connection for it to be useful.
That’s not a problem for the simulator (assuming your Mac is online), but it could be an issue for any device with.
Map Kit handles this gracefully, but it’s something to be aware of.
A little custom setup for the map Like Core Location, it’s not a lot of  work to get basic Map Kit support going in iBountyHunter.
Here, we’ll pass in the value of the lat and lon where the fugitive was captured.These values allow us to configure the size of the default map shown.
We pull all this information together to initialize the map.
We want the map to be pretty zoomed in.The mapRegion specifies where the map should be centered and how much should be visible north and south (in degrees)
There are a few map types; hybrid is both satellite and road information.
Implement the map to show the area where the fugitive was captured.
Add the framework just like we did with Core Location.
While you’re at it, make sure that you do the #import in the detail view to include the Map Kit header.
Rather than adding a whole new view, go ahead and add the map to the CapturedPhotoView with the image.
Resize the image and the button then drag an MKMapView to the bottom half  of  the view.
Now that you have all the support stuff  in place, go ahead and add the outlets and the actual Map Kit code we gave you to make the map work.
Make sure you wire up the outlet in Xcode and call the new initializeMapView method in viewWillAppear.
Q: What’s the difference between Core Location and Map Kit? A: Map Kit is about displaying a map, position-sensitive information, and user interface.
Core Location is about getting you information about where you are.
You can drag and drop a map onto your view in Interface Builder; you pass it some values and it just works.
Core Location, on the other hand, returns values to the delegate, and you need to decide what to do with them.
We’re going to take that information from Core Location and give it to Map Kit to show us a map of the capture location, for example.
Q: Where do all these frameworks come from? What if I want one that’s not on the list?
A: The frameworks are included as part of the SDK.
The actual path to the frameworks varies by version and what platform you’re developing for.
In general, you should be able to add frameworks using the method we described in Xcode and not need to worry about a specific location, but if a framework isn’t listed or you’re adding a custom one, you can point Xcode to the actual path.
Implement the map to show the area where the fugitive was captured.
If the fugitive has image data, then we ask UIImage to create an image from it and set it on our image view.
Test Drive Go ahead and build and run the app.
You’ll need to make sure that you mark a fugitive as captured, and that the lat/lon field fills in, then flip over the view to look at the map.
To try out the zooming on the map, you’d use the “pinching” motion on a real device.
Center on the fugitive location and set the zoom level.
Test Drive To try out the zooming on the map; this is the “pinching” motion in real life.
Excellent! Now all we need is a pin to show where the capture happened.
You can click in the map and move it around.
The simulator pulls your location based on the net connection for your computer.
Annotations require a little more work Annotations are the little flags that come up when you see a point of  interest, represented by a pin.
The catch? Incorporating annotations means conforming to the Map Kit annotation protocol.
Map Kit uses an annotation protocol so that you can use your existing classes and provide them directly to Map Kit.
The downside is that means we need to add code to our Fugitive class:
The MKAnnotation protocol is a little odd in that it defines a property and two getters.
These are used by the MapView to position the pin and populate the overlay if a pin is tapped.
If you use automatic NSManagedObject file generation again, you’ll wipe out these customizations.
Fully implement the annotation protocol The protocol requires us to have a coordinate property, a title, and a subtitle.
Instead of synthesizing that coordinate property, we’ll implement it ourselves and just return the fugitive’s position, name, etc.
For an application in which you expect to have to do more data migration, you should implement a separate class conforming to the protocol that has a reference to its Fugitive (composition) rather than adding code to the Fugitive class directly.
Do this! Go ahead and add the code from the previous page for the Fugitive.h and Fugitive.m files.
If we have a lat / lon for the fugitive, we add the fugitive as an annotation on the map.
We can do this since the fugitive now conforms to the MKAnnotation protocol.
You may not have noticed as you’ve been working through all this code, but this app is huge and awesome!
This invokes the camera, which you can see on your phone, not the simulator.
Now, how about that iPad app? I’m ready to get into some more research.
Your app must be able to work on the ____________ , too.
Your app must be able to work on the ____________ , too.
Your Location Toolbox You’ve got Chapter 10 under your belt and now you’ve added.
Is not on all devices and you need to handle that.
Allows you to select and edit an image for use in your app directly from your library.
Can be customized for a variety of views, including pushpin annotations.
Core Location Can use either GPS, cell tower triangulation, or Wi-Fi positioning service.
Chooses for you which method to use based on the user’s device.
I think it’s important to work with things in nature...
The iPad is all about existing in the real world.
We’re going to use some real-world elements to help Bob catch.
The iPhone app is up and running and things are great.
His on-the-run scenario is handled, but Bob also has some research to do and that isn’t going to be comfortable on his iPhone.
Bob is going to be sitting down, doing some research, coming up with a plan to track the fugitive.
Keep this in mind as we work through building the app.
While there are cases where you’re using similar apps on both devices, often the data is going to be consumed differently.
Fugitive ID# Bounty: This area is for notes and details about the fugitive.
The map will show the last known location for the fugitive.
To show the list of fugitives, we’ll have a popover that can appear in this corner with this full list.
When Bob selects an entry, a TexView will display text describing the sightings for the fugitive.
They’ll have a location and details about what the fugitive was doing there.
For research, Bob needs the full dossier on each fugitive.
Picture and details should all be in the same view.
All the information he uses in the iPhone app, too.
Fugitive ID# Bounty: This area is for notes and details about the fugitive.
When Bob selects an entry, a TextView will display text describing the sightings for the fugitive.
More UI goodness—cool page background that looks like a corkboard.
For the landscape view, we’ll have the full list of fugitives displayed, since we have extra space.
Why are we wasting all this time on a custom UI?
DrinkMixer worked fine, but it missed out on a lot of  what makes iPad apps easy to use.
We simply ported our minimalist iPhone UI to a bigger screen.
While that was fine for what we wanted to do, it’s time to step it up to what the iPad is really good at, which is making interfaces that are closer to the real world.
Natural user interfaces make things more real (and easier) One of  the reasons that the iPad, and tablets in general, have been so successful is due to their ability to take on the form factor of  lots of  things that we regularly use in the real world.
Books, calendars, menus, clipboards, newspapers, magazines, control panels, dials, and displays  —they can all be replaced with the right interface in the tablet form factor.
Natural user interfaces (NUIs) is a broad term that means any computer interface that tries to mimic more closely the way we interact with objects in the real world.
Beyond multitouch tablets, Wii uses a gesture recognition in 3D, and Kinect reads body movements to control the system.
All these interfaces have exploited the way we already know how to play sports or other games in the real world to allow us to quickly adapt to their apps.
Tablet computing and iPads in particular strive to do the same thing.
By leveraging the knowledge that users already have—how to read a book, use a calendar —NUIs make using an app easier and the learning time shorter.
The iOS Human Interface Guidelines—User Experience Guidelines, and the Case Studies section in particular, are full of  pointers about what to do and not do.
There is a great example of  migrating mail from iPhone to iPad.
The main thrust of  moving an app from iPhone to iPad? Realism.
It’s about realism and details When you read about iPad design, the HIG is full of  references to “stunning graphics” and “adding physicality and realism.” As you design your own interfaces, with increased real estate and expected time of  interaction with the user, it’s important to keep in mind subtle things that you can add that increase the appeal of  your app.
It’s also partly why iPad apps have a greater value to the user, which means you can charge more!
Iterate your interface, too Most developers are familiar with iterative development for software but for some reason don’t apply those same practices to user interfaces.
User interfaces, possibly more than any other part of  an application, need real user feedback.
This iterative approach to user interface design is why taking advantage of  natural user interfaces when possible is so important —the designers of  those interfaces (and users themselves) have spent a lot of  time going back and forth fine-tuning how people interact with them.
By incorporating natural UIs into your application, you can take advantage of  all that refinement and preloaded user knowledge in your application.
Sketches and wire-frames are a critical part of  user interface design, but before you pull out your pencil and start drawing, you need to put thought into what exactly is important to your user.
A critical part of  user interface design is determining what needs to be left out.
Some user interface elements only make sense in certain contexts; other elements just confuse things and clutter up the user experience.
Pencil sketches and wire-frames are an important part of the UI design process, but nothing takes the place of real-world usage.
Is this a custom UI, or are we using standard controls?
Frank: When you’re working with iOS, most apps are a blend of  standard controls and custom interface, and that’s what we’ll do.
We still have a hierarchical data structure we’re working with, so that works for us, but we need to add more detail for Bob to be able to do his research.
Frank: We need to start with the overall app structure.
So we’ll build the Split View Controller first, then get the views to work properly, and then we’ll add the realism.
Joe: What are we adding again to make this realistic?
Frank: We’re going to add a corkboard feeling, make the borders on the map and photo thicker, a pushpin, stuff like that.
So that will make it easier for Bob to digest what’s going on.
BountyHunterHD is based on a Split View Controller Just like we did with DrinkMixer, we’re going to add a Split View Controller, and then modify the basics to add a detail view.
Unlike DrinkMixer, we’re not going to be reusing our detail view from the iPhone app.
The overall structure of  the app means that we’ll be working with the same data and some of  the same controls between the iPhone and the iPad, but when it comes to the views, we’re going to be keeping things separate.
Often you start with a given data set that then needs to be applied to different use cases.
This is especially true when you’re talking about augmenting a website or existing backend framework with an iOS or mobile component.
Your work is really about effectively providing data to the user and setting up the interactivity for each use case.
For iBountyHunter on the iPad, Bob needs to do some research.
We’ll walk you through the coding, you just get them in order!
Since you’re such a pro at getting split views set up, we think you should skip some steps.
Author’s note: If you want to code it up from scratch—go for it, you already know how to do it!
If you’re rusty on the Core Data stuff, go back to chapter 8 to brush up...
Test Drive Go ahead and run what we’ve given you so you know where we are.
The mapView doesn’t have working data yet, so a default is shown.
This is the spot for the image for the fugitive.
This is the spot for the image for the fugitive.
Joe: How are we going to populate this detail view?
Frank: Just like we did in the iPhone version, I’d think, but we should probably break things into a couple of  separate methods.
There’s that map view, the image, and the text that all need to be updated.
Joe: Oh right, and that map view needs a decent amount of  setup, right?
Plus, remember that with the Split View Controller, we don’t re-create the view for each fugitive.
We need to be able to update the view when a fugitive is selected, not just when viewDidLoad kicks off.
Frank: We need to implement a couple of  methods on the detail view to populate the description, the images, etc.
This sets the current fugitive and then calls the updateDossier method and dismisses the popover if  it’s visible.
It works!  Everything is updated, but now we need some polish...
Here is where the image from our database will go.
There’s nothing in there right now, so it’s empty (but we’ll deal with that in a bit)
This is where the map information for the last known location will go.
Fugitive ID# Bounty: This area is for notes and details about the fugitive.
When Bob selects an entry, a TextView will display text describing the sightings for the fugitive.
More UI goodness—cool page background that looks like a corkboard.
For the landscape view, we’ll have the full list of fugitives displayed, since we have extra space.
Here is the sketch we came up with for the UI before.
Q: We still have a few issues in the code; for instance, picking a fugitive without a last known location shows.
A: Yes, we’ll definitely fix some of them as we clean up the UI, but some we’ll leave for you to either put on some finishing touches or add new functionality.
By putting it as a class extension at the top of the implementation file, we aren’t declaring the method to be part of the public interface, meaning people who might look at our class’s header file won’t see the method there.
However, there’s nothing preventing someone from actually trying to invoke the method if they knew it existed.
So, from that perspective, it’s not really private as much as “unlisted.”
Q: Isn’t all this “Natural User Interface” stuff just a new way of saying “eye candy”?
Sure, by moving to more natural user interfaces, you generally improve the look and feel of an application, but that’s almost a side effect.
You make assumptions about how to interact with things in the real world all the time.
For example, you generally want to pull on a handle but push on a touch plate on a swinging door.
You probably assume that turning a dial to the right will increase whatever it is you’re adjusting while turning it to the left will decrease it, etc.
If you’re writing a calendar application, don’t assume that you should (or even can) reinvent how people want to view their calendar.
Take advantage of established “user interfaces” in day planners and wall calendars—they’ve been around a lot longer and have had lots of time to get it wrong evolve.
Q: Wait—so if I’m supposed to incorporate things people are used to, doesn’t this depend on who the people are?
By incorporating familiar interfaces and real-world analogs, you can take advantage of existing user knowledge, but you’re relying on the user having that knowledge to some extent.
If you target an international audience, you need to keep each audience in mind when you localize your application.
For example, if one group of users’ paper calendars always start on Monday (versus Sunday) and you’re trying to mirror the paper calendar look, getting the starting day wrong can be pretty jarring (and break the very familiarity you’re trying to achieve)
Q: I’ve meant to ask this for a while, but is stuffing images in the database really a good idea?
A: For our application it’s OK because it simplifies things, but in general you might want to go with something a little more scalable.
One option is to have the image wrapped in its own Core Data entity that’s lazy-fetched rather than part of our main.
An even better option is to store the image on the file system and just keep a URL (path) to it in the Core Data entity.
Neither of these approaches would be major changes to what we’ve done so far but would give you better scalability as the number (and size) of the images grow.
Q: Is it normal to come back and do the UI after you’ve implemented functionality?
A: It’s normal to come back and theme the UI after you have functionality in place, but you definitely shouldn’t leave the rough UI work until the end.
Things that seem like neat UI “innovations” turn out to be really difficult to use or annoying after the first few minutes.
It’s also very common to realize that you really want Functionality X to be.
Something that was just two taps away now seems very distracting to constantly move in and out of views to reach.
These are the kinds of things that are difficult to find without working prototypes of the UI and really can’t be put off until later.
Styling a navigation bar with a leather texture can wait— figuring out the basic UI flow through critical use cases can’t.
Q: How come we aren’t using any detail indicators in the table view?
A: Good question! Since pushing the detail view doesn’t involve changing views in the iPad, we aren’t going to have a disclosure indicator.
Remember, disclosure indicators mean that there is another view that will displace the current one.
Since the table view list isn’t going anywhere, it isn’t appropriate.
The app works great! Now we need to add the custom stuff, right?
Yes! The app works, everything updates, and now it’s time to add the UI on top.
This is going to add that touch of  realism that makes the app easier to use and takes advantage of  the iPad’s capabilities.
We also need to do something about what happens when there isn’t any data—empty map views and image views don’t look very good.
This area is for notes and details about the fugitive.
When we first sketched up a view, we said that we needed some “UI goodness” and had a couple of ideas about what that would mean, like a corkboard background, for instance.
One important thing to realize is that a lot of what we’ll do here is styling.
That’s important, and will make a difference, but on more complicated applications, you need to think not just about how things look, but how users will interact with your application.
We’re giving our UI a natural look, but for bigger applications, you need to think about a natural feel too.
To make this app really look good, all those added elements need to work together, and they’ll work to create a theme.
Unifying the custom stuff More than just adding some touches of  realism, like we talked about with NUIs, we’re going to put together a unified look, or theme, for the app.
A UI theme consists of fonts, images, colors, and backgrounds that all work together to create a consistent look for an app.
Look and feel goes beyond just images and colors, though.
Smooth animations, transitions, etc., all play a role and need to be consistent with the look and feel you’re trying to achieve.
For example, using a page curl transition when you’ve styled everything to look like brushed metal with steel rivets isn’t going to look cool or seem intuitive.
Creating a consistent look and feel is also where you’re likely going to start to need help.
App development can be a profession, and while you can work with some small apps on your own, adding final polish may require some design help.
For our purposes here though, using the real-world analog of  pushpins on a corkboard and an appropriate font will be enough for iBountyHunter.
Do this! Download the four images you’ll need for the theme.
Looks like a typewriter with bolded text for each item.
First, we’ll start by setting up the placeholder images and the background image with a little code.
You probably noticed that the image for the corkboard is way too small to fill up a whole screen.
We’re going to write a little code to set the backgroundColor, which in this case will be a pattern based on our corkboard image, like this:
Since the dossier view is just displaying an image, we need to handle which image is shown if  the database entry is empty.
The code needs to be changed to display the default image only if  there isn’t another image from the database:
The mapView doesn’t display an image at all right now, so you’ll need to add an imageView called mapOverlay on top of  the mapView in the GUI editor, and then set the image the same way you set it for the fugitive.
First, we’ll start by setting up the placeholder images and the background image with a little code.
The mapView doesn’t display an image at all right now, so you’ll need to add an imageView called mapOverlay on top of  the mapView in the GUI editor, and then set the image the same way you set it for the fugitive.
If you create a new fugitive without an image or map information, does your new code work? What about for old fugitives?
What, where did the map go? Now it only shows the question mark, no matter what.
When we created the new imageView in Xcode, we put it on top of  the mapView.
But we only want the imageView to be the top visible layer if  there isn’t any map information.
If  you’re not used to working with graphics programs for layout (including those to build GUIs), there is a concept at work here that we need to point out.
That means you can lay images on top of  each other, and they can be completely hidden, partially hidden, or partially shown.
Each view can have multiple subviews stacked (layered) in a specific order.
In iBountyHunter, when there is map information, we need to hide the imageView.
Put this code inside the updateDossier code to fix the overlay issues.
If you have data for a fugitive, the images will switch.
Go into Xcode and highlight one of  the UITextViews, then you can see what changes you can make.
Here, you can set the font type, color, and size.
Rather than going the NSAttributeString route, we can take advantage of  everyone’s favorite markup language, HTML, with some styling through CSS.
That’s true, you’re really good at what you do, it’s just...well, you’re so limited.
All true, but it really starts to fall apart when you need to get fancy.
Without any code at all, you can cut and paste, scroll through text, select text, and search it.
And if  you really want fancy colors and whatnot, you can get there if  you try hard enough.
UIWebview has lots of options Although inserting a web view might not be your first thought, it’s often one of  the best ways to handle complex text formatting.
Web views not only allow you to embed material on the web directly into your app without leaving and going into Safari, but you can also load from HTML/ CSS files that you ship (or generate) as part of  your application.
UIWebViews are basically Safari in a box—not only can they render HTML, they can also be used to embed lots of  document types, including Microsoft Office and Apple’s iWork office suite (Pages, Numbers, and Keynote), PDFs, and RTF documents.
In short, anything Safari can render, a WebView can render too, inside your application.
More than just a developer convenience, this can also be really important for user flow.
With CSS, you get all the styling and layout support you get with normal web development—and you can use the same tool.
Not only that, but you can use JavaScript for interactivity.
Actually, you can give me a string, too—it just has to be an HTML string.
I also support loading local resources like embedded CSS files, images, JavaScript, or even full HTML files.
I can show HTML forms and things like that, but no, I guess I really don’t fit for text editing or things like that.
Like I said, basically anything you can do with a web page you can do with me in terms of  interacting with the user.
As for interacting with the rest of  the application, that’s a little tricker.
I have a couple of  delegate methods that get called when I need to know if  I can follow a link that the application can use to move information out, and I can evaluate any JavaScript the application sends me and return the results.
But, admittedly, it’s not quite as simple as just manipulating a string.
But we’re talking about jamming a web browser into the application.
You can just hand me a string and I’m good to go, you don’t need to go and load a website or anything.
Can you interact with the user or the rest of  the application at all?
I think I’m more about straightforward text editing, you’re more about style.
Using UIWebView For our purposes, we’re going to need to generate an HTML version of  our fugitive description and last known location.
We can then apply some basic CSS to get it to look however we want.
We’re going to be working with CSS to actually draw the notebook paper area within the view, so it won’t be an image.
We’re also going to set up the pushpin image directly from the CSS so it will stay within the WebView and move and scale as needed for the view.
To do this we’re going to need to make a couple of  changes.
First, we need to swap out our text views for UIWebViews.
Normally it’s a lot easier to write the HTML and CSS you want and get things set up using a Web Browser or any other HTML editing tool, and then move it into code.
We came up with HTML that looks like what you see on the opposite page:
HTML, CSS, and Objective-C Using a UIWebView is like a cross between a website with basic HTML/CSS and Objective-C.
All three of  these things work together to create the view that the user is going to see.
The Dossier View Controller constructs a new block of HTML (based on the selected fugitive) that uses a static CSS file for formatting.
The description will get drawn in our view, with bolding, lines, and an included pushpin image.
The view controller then asks the web view to load the new HTML (and associated CSS)
First we’ll get the HTML and webViews working to replace the textViews.
Leave out the CSS link code for now, we’ll get to that in a minute.
Delete the two text views and replace them with UIWebViews.
Turn off  “User Interaction Enabled” and uncheck “opaque” in the Utilities pane for both UI WebView.
Don’t forget to handle the IBOutlets to these views as well.
You’ll need to change their types in the header and then reconnect them in Interface Builder.
We’ll need to prepare the fugitive description with HTML and then we’ll #define a constant to handle the case when we don’t have a fugitive.
We’ll need to prepare the fugitive description with HTML and then we’ll #define a constant to handle the case when we don’t have a fugitive’s position.
Now that we can create HTML versions of  our descriptions, we need to update our updateDossier method and viewDidLoad to tell the WebView to load its content from an HTML string rather than just setting a simple string on the text view like before.
Finally, we’ll need to tell the new WebViews to load our dynamic HTML by using loadHTMLString.
We want to use our local CSS file, so we need to give the WebView a code format baseURL that points to our application bundle.
We’ll get into more detail about the CSS in a minute...
Delete the two text views and replace them with UIWebViews.
Turn off  “User Interaction Enabled” and uncheck “opaque” in the Utilities pane for both UI WebViews.
Don’t forget to handle the IBOutlets to these views as well! You’ll need to change their types in the header, then reconnect them in Interface Builder.
First, we’ll get the HTML and webViews working to replace the textViews.
Leave out the CSS link code for now, we’ll get to that in a minute.
We’ll need to prepare the fugitive description with HTML and then we’ll #define a constant to handle the case when we don’t have a fugitive.
We use stringWithFormat to populate our generic HTML template with real fugitive data.
If we don’t have a fugitive selected, we just use static HTML.
We’ll need to prepare the fugitive description with HTML and then we’ll #define a constant to handle the case when we don’t have a fugitive’s position.
This constant is for when we have a fugitive selected, but don’t have a last known location.
First, we’ll get the HTML and webViews working to replace the textViews.
Leave out the CSS link code for now, we’ll get to that in a minute.
Now that we can create HTML versions of  our descriptions, we need to update our updateDossier method and viewDidLoad to tell the WebView to load its content from an HTML string rather than just setting a simple string on the text view like before.
Here, we get a URL to ou r application bundle.
Once we have the baseURL, we simply ask the WebView to load the generated HTML string with the fugitive information.
Use CSS for the remaining formatting Now we’re ready to get into the CSS.
We have a bunch of  things we need to accomplish with the formatting, and all of  it’s going to happen inside this CSS file:
The formatting isn’t done yet (that will happen with the CSS), but for now, the webViews should be in place and functioning...
We set the background to clear, but other than that, it still looks pretty much the same...
Here’s our stylesheet that we’ll use for formatting the text in our webview.
Again, we do this in CSS s o that the.
I love it! Now I can use all this information to track down my.
Justice is served! Bob is really happy, and this is a great universal app.
Two completely different use cases have been handled: catching the fugitive and reporting it, as well as researching the fugitive in detail.
There’s only one database to maintain, but two totally different views, and the code is shared, so making updates should be a breeze.
This type of view displays text with lots of formatting options.
Your NUI Toolbox You’ve got Chapter 11 under your belt and now you’ve added.
Custom UIs Try to be consistent by using a theme.
Fonts, images, and textures all work together to create a theme.
UIWebView Can talk to local material in the app or the web.
This type of view displays text with lots of formatting options.
So take a peek and see what you (still) might be missing out on.
Depending on your application, you should consider supporting multiple languages and cultures.
Location or culture-specific icons and images such as flags or text.
Once you’ve identified the culture or language-specific parts of  your application, the next step is to localize them.
Up until now, our resources have been included in our application in the .app directory.
Once you start localizing resources, Xcode creates an lproj directory for each localization (locale) you add and moves the locale-specific resources there.
For example, if  you provide both English and French translations of  your nibs, then you will have an en.lproj (or English.lproj) and fr.lproj directories in your application.
Before you start translating anything, you need to ask Xcode to create the localespecific directories.
Next, click on the + button under the Locialization group.
Xcode will turn your nib entry in the project list into a group with each localization listed beneath it.
The next time you click the + button, a drop-down box will appear and you can select any language you want to use.
There will be a new nib created for each language.
Click on the “+” button here to have the directory structure created.
Now all you need to do to localize the nib is double-click the language you want to localize and translate any text.
Remember that depending on the language, you may need to adjust layout as well.
For large projects, there is a command-line tool called ibtool that you can use to extract all string values from a nib into an external file, then merge translations back into the nib later.
This allows for bulk extraction and translation, but you need to be particularly careful about layout issues since you’re not visually inspecting each nib.
Once a nib has been translated, you can have Interface Builder mark it as locked to prevent any accidental changes to the text or layout that could impact your translations.
See Apple’s documentation on bundles and nib localization for more information.
Localizing string resources In addition to nib text, text in your application that you intend on showing the user needs to be localized as well.
For example, the Action Sheet used in iBountyHunter offers the user the option to take a photo, choose an existing one, or cancel.
That button text is generated programmatically and needs to be translated appropriately.
For this type of  text, called string resources, the iOS uses strings files.
You’ll generally have one of  these files for each language you support.
Each file contains a description of  what the string is trying to communicate, the default language version of  the string, and the translated version, like this:
Title for the important alert view */ “This is important!” = “This is important!”;
Are you sure?” = “This will empty your bank account.
If  you’ve used the NSLocalizedString macros in your code, you can generate your strings file simply by running the genstrings command at the command line, like this:
You’ll want to run this for each translation you support.
You’ll need to add that strings file to your Xcode project like any other resource, but once it’s there, the iOS will look in the appropriate strings file at runtime based on the language the users select for their device.
The iOS provides robust localization capabilities, including currency, time, and date presentation support; we’ve just scratched the surface.
If you’ve installed your app before doing translations, it’s likely that the iOS has cached resources so that.
Generating your strings file You could create your strings file by hand, but a much simpler way is to have Xcode generate it for you.
Xcode does this by looking for the localization macros that load the translated text.
To support localized strings, you should use one of  the NSLocalizedString macros, like this:
The second argument is the comment to be shown with the string in the strings file.
View animations If  you’ve spent any time with an iOS device, you know that smooth transitions and graceful animations define the user experience.
In the applications we’ve built so far, we’ve only touched on a few basic animations (like the flip animation used in iBountyHunter)
However, everything from adding and removing table rows to sliding controls around the screen can be animated.
Animating table view updates If  you’re going to add or remove multiple rows in a table view, you can ask it to provide a smooth animation (as well as a more efficient handling of  updating the table view itself) by sending it the beginUpdates message before you start manipulating the data, then an endUpdates when you’re finished, like this:
The tableView will immediately ask the datasource and delegate for cell information for those new rows and, if you specify the animation information, they’ll smoothly slide into the table.The beginUpdates and endUpdates tell the tableView that you’
Animating view and control changes Similar to table views, UIViews have built-in support for smoothly animating changes to several of their properties.
You simply need to tell the view that you want it to animate a change by sending it the beginAnimations message, describing the end point of  the change, and then asking it to start the transition by sending it the commitAnimations message.
UIView property Description frame The physical rectangle that describes the view—the view’s origin.
Accelerometer One of  the most versatile pieces of  hardware in iOS devices is the accelerometer.
The accelerometer allows the device to detect acceleration and the pull of  gravity along three axes.
With just a few lines of  code, you can tell whether the device is right-side up, upside down, laying flat on a table, etc.
You can even detect how quickly the device is changing direction.
All you need is the UIAccelerometer Getting orientation information from your device is straightforward.
To receive acceleration information, you simply need to tell the accelerometer about the delegate and how frequently to send acceleration information, like this:
Each UIAcceleration object contains acceleration information along the x, y, and z axes and a timestamp indicating when the data was collected.
In a simple example, you can update labels with the acceleration information, like this:
You’ll get no information back, regardless of  how much you shake your Mac.
You need to install the application on a real device to get actual accelerometer information back.
If the device is held still, the pull of gravity is defined as 1.0 along some axis.
The Z axis runs through the display of the phone, with positive Z pointing out of the front of the display.
Place the device face-up on the table and your Z axis value will be -1
If  you’re building a typical view-based application, UIKit hides a lot of  the need for the accelerometer by letting you know about orientation changes and automatically providing undo/redo when the user shakes the phone.
The accelerometer is most useful for custom-drawn applications like games (steering or balance) and utility applications (for example, levels)
Multi-touch You probably noticed that we only used one of  the possible events that can be triggered for a button in our apps, the touch up inside event.
In addition to touches, iOS can detect swipes and gestures that can be configured as well.
By defining the length and direction of a swipe, you can create lots of  different ways to interact with your application.
Pinching is a custom gesture that Apple uses in many of  its default applications, most notably Safari, to zoom in and out of  a view.
It is just registering for a two-finger touch and keeping track of  the change in the distance between them: If  it increases, zoom out, if  it decreases, zoom in.
Using these events means you can create custom interfaces—not just touching buttons—for your user.
Working with multi-touch means that your view needs to be configured to be a multi-touch view, and then you need code to work with each different type of event you’re interested in leveraging.
Working with these events requires working with the responder chain (see the UIResponder class reference) and the UIEvents class reference.
It’s outside of  the scope of  our book to get into those applications—which can use multi-touch interactions, Quartz and OpenGL graphics, and peer-to-peer networking—but here, we’ll give you a quick pass at the technologies that you can use and where to find more information about them.
These are all the button events than can be triggered.
Quartz and OpenGL Quartz and OpenGL are the two ways to create graphics on iOS, and they’re both big enough to be books on their own.
Here’s a small sample of  what you’d be dealing with:
Quartz Quartz is the simpler of  the two, allowing you to draw in two dimensions directly into the view.
The drawing code uses the Core Graphics Framework and renders directly into the view.
It follows a painter’s model, which means that the order of  commands is important.
The first thing drawn will be covered up with a subsequent drawing in the same location.
Quartz can handle shading, color, and interfacing with other image and video types.
The Quartz 2D Programming Guide in the developer documentation has a lot of information to help get you started.
OpenGL OpenGL can work in two or three-dimensional graphics and is significantly more complex, but that means that you have more flexibility to work with.
It is a well-established, crossplatform library that has been implemented for mobile devices with OpenGL ES, and it’s used through the OpenGL ES Framework.
You can use it to draw lines, polygons, and objects, and animate them as well.
A good place to get started is with the OpenGL ES Programming Guide for iOS in the developer documentation.
Game Kit New with the iOS 3, the Game Kit framework allows you to use both peer-to-peer networking and voiceover bluetooth to facilitate interaction with other devices within game play.
This functionality does not exist for the first generation iPhone, iPod Touch, or the simulator alone.
After that connection is established, you can transmit data or voice between devices.
A good place to get started is with the Game Kit Programming Guide to leverage this new functionality in your app.
It’s time to take this thing out for a spin, don’t you think?
And the only way to do that is to register with.
Even then, it’s not just a matter of clicking a button in Xcode to get.
Apple has rules We’ve talked about the HIG and how stringent Apple can be throughout the approval process—they’re protecting their platform.
Part of  that requires keeping track of  what goes on your own device, even when it’s stuff  you’ve written yourself.
Here, we’re going to give you an overview of  how you can get an app onto your device, and then, in turn, ready for submission.
We can’t get into the nitty gritty of  the full process—for that, you need to be a member of  the iOS Development Program and pay the $99 fee.
Start at the Apple Developer Portal The Developer Portal, where you first downloaded the SDK, is also your hub for managing all the parts of  electronic signatures that you’ll need to get an app up and running on your iOS device.
First, get your Development Certificate Getting through the process to go from having your app in Xcode to installing it on an iPhone, iPad, or iPod Touch for testing requires a Development Certificate and a Provisioning Profile.
This certificate is signed by you and Apple to register you as a developer.
It creates a public and a private key, and the private key is stored on the keychain app on your Mac.
Xcode will use it to sign the apps you build to install on a device.
The iOS Development Guide in the Xcode documentation has some more good information that you can look at before you join the Development Program.
The Provisioning Profile pulls it all together Now that you have a Development Certificate in place, to complete the process, you need a Provisioning Profile.
That electronic document ties the app (through a UDID), the developer, and the certificate together for installation onto the device.
To start, you need to enter your Device ID into the Developer’s Portal to request a Provisioning Profile.
Apple will issue a Provisioning Profile that you’ll need to download to the Organizer in Xcode.
In Xcode, you’ll use the Organizer to keep all your devices and profiles straight.
In the Organizer, you’ll attach the Profile to your device.
Finally, when you compile your app in Xcode, you’ll be able to select your iPhone as the location for the build, rather than the simulator.
If you have your iPhone plugged in, you’ll get a similar display.
Here, you’ll be able to get to your Provisioning Profiles.
In here, you’ll be able to configure your device for development.
The Organizer will make sure that you have a valid software version for development, and if not, help you choose one that works.
This quick overview gives you an idea of  how the process works, but you need to get into the Developer Program to learn all the details.
Our goal here was just to help you see the big picture of  the process.
There are a couple of  things to be aware of.
First, when you’re developing as part of  a team, the team admin has to be involved in many of  these steps.
Second, you need to go through this process to install anything on your device, regardless of  whether you plan to release it to the world or not.
And finally, what about the app store? Once you’ve joined the Developer Program and the application has been tested, then you can submit it for approval.
This Identifier is required for a Provisioning Profile and is unique to each device.
More InformationAfter you’ve joined the Developer Program, get into the Developer’s Portal and look for the iPhone Development Program User Guide.It has a lot of good information to get you through the process.
Getting Started: Going Mobile with iOS So, you want to build an iOS app...
That pattern is back First, declare that the controller conforms to both protocols The datasource protocol has two required methods Connect the datasource just like actions and outlets There’s just one method for the delegate protocol Actions, outlets, and events Connect the event to the action Add the IBOutlet and property to your view controller Next, synthesize the property...
Connect the picker to our outlet Use your picker reference to pull the selected values.
Objective-C for iOS: Email needs variety Renee is catching on....
Make room for custom input Header files describe the interface to your class Auto-generated accessors also handle memory management To keep your memory straight, you need to remember just two things But when Mike’s finished typing...
Customize your UITextField Components that use the keyboard ask it to appear...
Ask the UITextField to give up focus Messages in Objective-C use named arguments Use message passing to tell our View Controller when the Done button is pressed Where’s the custom note?
Multiple Views: A table with a view So, how do these viewsfit together? The navigation template pulls multiple views together The table view is built in A table is a collection of cells Just a few more drinks...
Plists are an easy way to save and load data Arrays (and more) have built-in support for plists Use a detail view to drill down into data A closer look at the detail view Use the Navigation Controller to switch between views Navigation Controllers maintain a stack of View Controllers Dictionaries store information as key-value pairs Debugging—the dark side of iOS development First stop on your debugging adventure: the console Interact with your application while it’s running Xcode supports you after your app breaks, too The Xcode debugger shows you the state of your application.
Use the debugger to investigate the crash Update your code to handle a plist of dictionaries The Detail View needs data The other keys are key We have a usability problem Use a disclosure button to show that there are more details available Sales were going strong Use Navigation Controller buttons to add drinks The button should create a new view We need a view...but not necessarily a new view The View Controller defines the behavior for the view A nib file contains the UI components and connections...
You can subclass and extend view controllers like any other class Modal views focus the user on the task at hand...
Any view can present a modal view Our modal view doesn’t have a navigation bar Create the Save and Cancel buttons Write the Save and Cancel actions.
Migrating to iPad: We need more room DrinkMixer on the iPad The iPad simulator The HIG covers iPads, too Use Xcode to build your Universal app Check your devices Rotation is key with iPad A persistent view problem Don’t forget the tableview.
Tab Bars and Core Data: Enterprise apps HF bounty hunting A new iPhone control Choose a template to start iBountyHunter There’s a different structure for universal apps Drawing how iBountyHunter iPhone works...
Core Data lets you focus on your app Core Data needs to know what to load Core Data describes entities with a Managed Object Model Build your Fugitive entity Use an NSFetchRequest to describe your search Bob’s database is a resource Back to the Core Data stack The template sets things up for a SQLite DB iOS Apps are read-only The iPhone’s application structure defines where you can read and write Copy the database to the Documents directory.
Migrating and Optimizing with Core Data: Things are changing Bob needs documentation Everything stems from our object model The data hasn’t been updated Data migration is a common problem Migrate the old data into the new model Xcode makes it easy to version your data model Core Data can “lightly” migrate data Here’s what you’ve done so far...
Bob has some design input Your app has a lifecycle all its own...
There’s a method for checking Prompt the user with action sheets Bob needs the where, in addition to the when Core Location can find you in a few ways Add a new framework Just latitude and longitude won’t work for Bob Map Kit comes with iOS A little custom setup for the map Annotations require a little more finesse Fully implement the annotation protocol.
