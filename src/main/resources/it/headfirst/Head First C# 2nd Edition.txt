I’ve never read a computer book cover to cover, but this one held my interest from the first page to the last.
It is very approachable while covering a great amount of  detail in a unique style.
I’d reccomend this book to anyone looking for a great introduction into the world of  programming and C#
From the first page onwards, the authors walks the reader through some of  the more challenging concepts of  C# in a simple, easy-to-follow way.
Head First C# is a highly enjoyable tutorial, full of  memorable examples and entertaining exercises.
I will recommend this book to any developer wanting to jump into the C# waters.
I will recommend it to the advanced developer that wants to understand better what is happening with their code.
Andrew and Jenny have crafted another stimulating Head First learning experience.
Going through this Head First C# book was a great experience.
Kathy and Bert’s Head First Java transforms the printed page into the closest thing to a GUI you’ve ever seen.
Beyond the engaging style that drags you forward from know-nothing into exalted Java warrior status, Head First Java covers a huge amount of  practical matters that other texts leave as the dreaded “exercise for the reader….”  It’s clever, wry, hip and practical—there aren’t a lot of  textbooks that can make that claim and live up to it while also teaching you about object serialization and network launch protocols.
Just the right tone for the geeked-out, casual-cool guru coder in all of  us.
There are books you buy, books you keep, books you keep on your desk, and thanks to O’Reilly and the Head First crew, there is the penultimate category, Head First books.
They’re the ones that are dogeared, mangled, and carried everywhere.
Head First SQL is at the top of  my stack.
Usually when reading through a book or article on design patterns, I’d have to occasionally stick myself in the eye with something just to make sure I was paying attention.
Odd as it may sound, this book makes learning about design patterns fun.
Wouldn’t it be dreamy if there was a C# book that was more fun than endlessly.
O’Reilly Media books may be purchased for educational, business, or sales promotional use.
Many of  the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and O’Reilly Media, Inc., was aware of  a trademark claim, the designations have been printed in caps or initial caps.
While every precaution has been taken in the preparation of  this book, the publisher and the authors assume no responsibility for errors or omissions, or for damages resulting from the use of  the information contained herein.
No bees, space aliens, or comic book heroes were harmed in the making of  this book.
You were only in our canal for a day, but you’ll be in our hearts forever.
Jennifer Greene studied philosophy in college but, like everyone else in the field, couldn’t find a job doing it.
Luckily, she’s a great software engineer, so she started out working at an online service, and that’s the first time she really got a good sense of  what good software development looked like.
She moved to New York in 1998 to work on software quallity at a financial software company.
She managed a team of  testers at a really cool startup that did artificial intelligence and natural language processing.
Since then, she’s traveled all over the world to work with different software teams and build all kinds of cool projects.
Andrew Stellman, despite being raised a New Yorker, has lived in Pittsburgh twice.
The first time was when he graduated from Carnegie Mellon’s School of  Computer Science, and then again when he and Jenny were starting their consulting business and writing their first book for O’Reilly.
When he moved back to his hometown, his first job after college was as a programmer at EMICapitol Records—which actually made sense, since he went to LaGuardia High School of Music and Art and the Performing Arts to study cello and jazz bass guitar.
He and Jenny first worked together at that same financial software company, where he was managing a team of programmers.
He’s had the privilege of  working with some pretty amazing programmers over the years, and likes to think that he’s learned a few things from them.
When he’s not writing books, Andrew keeps himself  busy writing useless (but fun) software, playing music (but video games even more), experimenting with circuits that make odd noises, studying taiji and aikido, having a girlfriend named Lisa, and owning a pomeranian.
Jenny and Andrew have been building software and writing about software engineering toge ther since they.
You’re sitting around trying to learn something, but your brain keeps telling you all that learning isn’t important.
Better leave room for more important things, like which wild animals to avoid and.
You can get a lot of work done using the IDE.
Sure, there are a lot of repetitive tasks that you do when.
And the IDE is great at doing those things for.
Once you get the hang of coding, there’s nothing your programs can’t do.
When you’re building a program, it’s always a good idea to start by thinking about what.
When you use objects right, you end up with code that’s.
Data type, database, Lieutenant Commander Data… it’s all important stuff.
You need information from your users, and you use that to look up or produce new.
Joe, Bob, and Al love going to the track, but they’re tired of losing all their money.
They need you to build a simulator for them so they can figure out winners before they lay their money down.
And, if you do a good job, they’ll cut you in on their profits.
Sometimes you DO want to be just like your parents.
Ever run across an object that almost does exactly what you want your object to do?
Found yourself wishing that if you could just change a few things, that object would.
Kathleen needs to figure out the cost of  her parties, no matter what kind of  parties they are.
Sometimes you need to group your objects together based on the things they can.
In the real world, you don’t get to handle your data in tiny little bits and pieces.
No, your data’s going to come at you in loads, piles, and bunches.
They let you store, sort, and manage all the data that your programs.
That way, you can think about writing programs to work.
Your job is to build an adventure game where a mighty adventurer is on a quest to defeat level after level of deadly enemies.
You’ll build a turn-based system, which means the player makes one move and then the enemies make one move.
The player can move or attack, and then each enemy gets a chance to move and attack.
The game keeps going until the player either defeats all the enemies on all seven levels or dies.
So far, all of your programs have been pretty short-lived.
You’ve worked your tail off, waded through technical manuals and a few engaging.
Head First books, and you’ve reached the pinnacle of your profession: master.
But you’re still getting panicked phone calls in the middle of the night.
Nothing pulls you out of the programming groove like having to fix a strange bug…
Better yet, you can even react to those problems, and keep things running.
When your program throws an exception, .NET generates an Exception object.
Until you’ve actually written working code, it’s hard to be sure if you really get some.
In this chapter, we’re going to use what we’ve learned.
We’ll also get a preview of some of the new ideas coming up soon.
And we’ll do all that by building phase I of a really complex application to make.
Sometimes you have to take graphics into your own hands.
We’ve spent a lot of time relying on controls to handle everything visual in our applications.
But sometimes that’s not enough—like when you want to animate a picture.
It all begins with the Graphics object, bitmaps, and a determination to not accept the.
It’s a data-driven world…you better know how to live in it.
Gone are the days when you could program for days, even weeks, without dealing with.
In this lab you’ll pay homage to one of the most popular, revered and replicated icons in video game history, a game that needs no further introduction.
Here are some of the topics that didn’t make the.
But even though we couldn’t get to them, we still think that they’re important and.
Do you like to tinker—do you learn by doing, rather than just reading?
Do you prefer stimulating dinner party conversation to dry, dull, academic lectures?
Does the idea of writing a lot of code make you bored and a little twitchy?
Are you a kick-butt C++ or Java programmer looking for a reference book?
Are you afraid to try something different? Would you rather have a root canal than mix stripes with plaid? Do you believe that a technical book can’t be serious if C# concepts are anthropomorphized?
It was built that way, and it helps you stay alive.
So what does your brain do with all the routine, ordinary, normal things you encounter? Everything it can to stop them from interfering with the brain’s real job—recording things that matter.
It doesn’t bother saving the boring things; they never make it past the “this is obviously not important” filter.
How does your brain know what’s important? Suppose you’re out for a day hike and a tiger jumps in front of  you, what happens inside your head and body?
Or trying to learn some tough technical topic your boss thinks will take a week, ten days at the most.
It’s trying to make sure that this obviously non-important content doesn’t clutter up scarce resources.
Resources that are better spent storing the really big things.
Like how you should never have posted those “party” photos on your Facebook page.
And there’s no simple way to tell your brain, “Hey brain, thank you very much, but no matter how dull this book is, and how little I’m registering on the emotional Richter scale right now, I really do want you to keep this stuff  around.”
We think of a “Head First” r eader as a learner.
If  you really want to learn, and you want to learn more quickly and more deeply, pay attention to how you pay attention.
Most of  us did not take courses on metacognition or learning theory when we were growing up.
We were expected to learn, but rarely taught to learn.
But we assume that if  you’re holding this book, you really want to learn how to build programs in C#
And you probably don’t want to spend a lot of  time.
If  you want to use what you read in this book, you need to remember what you read.
To get the most from this book, or any book or learning experience, take responsibility for your brain.
The trick is to get your brain to see the new material you’re learning as Really Important.
Otherwise, you’re in for a constant battle, with your brain doing its best to keep the new content from sticking.
So just how DO you get your brain to treat C# like it was a hungry tiger?
There’s the slow, tedious way, or the faster, more effective way.
You obviously know that you are able to learn and remember even the dullest of  topics if  you keep pounding the same thing into your brain.
With enough repetition, your brain says, “This doesn’t feel important to him, but he keeps looking at the same thing over and over and over, so I suppose it must be.”
The faster way is to do anything that increases brain activity, especially different types of  brain activity.
The things on the previous page are a big part of  the solution, and they’re all things that have been proven to help your brain work in your favor.
For example, studies show that putting words within the pictures they describe (as opposed to somewhere else in the page, like a caption or in the body text) causes your brain to try to makes sense of  how the words and picture relate, and this causes more neurons to fire.
More neurons firing = more chances for your brain to get that this is something worth paying attention to, and possibly recording.
A conversational style helps because people tend to pay more attention when they perceive that they’re in a conversation, since they’re expected to follow along and hold up their end.
The amazing thing is, your brain doesn’t necessarily care that the “conversation” is between you and a book! On the other hand, if  the writing style is formal and dry, your brain perceives it the same way you experience being lectured to while sitting in a roomful of  passive attendees.
Here’s what WE did: We used pictures, because your brain is tuned for visuals, not text.
As far as your brain’s concerned, a picture really is worth a thousand words.
And when text and pictures work together, we embedded the text in the pictures because your brain works more effectively when the text is within the thing the text refers to, as opposed to in a caption or buried in the text somewhere.
We used redundancy, saying the same thing in different ways and with different media types, and multiple senses, to increase the chance that the content gets coded into more than one area of  your brain.
We used concepts and pictures in unexpected ways because your brain is tuned for novelty, and we used pictures and ideas with at least some emotional content, because your brain is tuned to pay attention to the biochemistry of  emotions.
That which causes you to feel something is more likely to be remembered, even if  that feeling is nothing more than a little humor, surprise, or interest.
We used a personalized, conversational style, because your brain is tuned to pay more attention when it believes you’re in a conversation than if  it thinks you’re passively listening to a presentation.
We included more than 80 activities, because your brain is tuned to learn and remember more when you do things than when you read about things.
We used multiple learning styles, because you might prefer step-by-step procedures, while someone else wants to understand the big picture first, and someone else just wants to see an example.
But regardless of  your own learning preference, everyone benefits from seeing the same content represented in multiple ways.
We include content for both sides of  your brain, because the more of  your brain you engage, the more likely you are to learn and remember, and the longer you can stay focused.
Since working one side of  the brain often means giving the other side a chance to rest, you can be more productive at learning for a longer period of  time.
And we included stories and exercises that present more than one point of  view, because your brain is tuned to learn more deeply when it’s forced to make evaluations and judgments.
We included challenges, with exercises, and by asking questions that don’t always have a straight answer, because your brain is tuned to learn and remember when it has to work at something.
Think about it—you can’t get your body in shape just by watching people at the gym.
But we did our best to make sure that when you’re working hard, it’s on the right things.
That you’re not spending one extra dendrite processing a hard-to-understand example, or parsing difficult, jargon-laden, or overly terse text.
In stories, examples, pictures, etc., because, well, because you’re a person.
And your brain pays more attention to people than it does to things.
When you define a class, you define its methods, just like a blueprint defines the layout of the house.
You can use one blueprint to make any number of houses, and you can use one class to make any number of objects.
These tips are a starting point; listen to your brain and figure out what works for you and what doesn’t.
Your brain works best in a nice bath of  fluid.
Dehydration (which can happen before you ever feel thirsty) decreases cognitive function.
Write a lot of software! There’s only one way to learn to program: writing a lot of  code.
And that’s what you’re going to do throughout this book.
Coding is a skill, and the only way to get good at it is to practice.
We’re going to give you a lot of  practice: every chapter has exercises that pose a problem for you to solve.
Don’t just skip over them—a lot of  the learning happens when you solve the exercises.
But try to solve the problem before you look at the solution.
And definitely get it working before you move on to the next part of  the book.
Groaning over a bad joke is still better than feeling nothing at all.
If  you find yourself  starting to skim the surface or forget what you just read, it’s time for a break.
Once you go past a certain point, you won’t learn faster by trying to shove more in, and you might even hurt the process.
If  you’re trying to understand something, or increase your chance of  remembering it later, say it out loud.
Better still, try to explain it out loud to someone else.
You’ll learn more quickly, and you might uncover ideas you hadn’t known were there when you were reading about it.
Part of  the learning (especially the transfer to long-term memory) happens after you put the book down.
Your brain needs time on its own, to do more processing.
If  you put in something new during that processing time, some of  what you just learned will be lost.
They’re not optional sidebars—they’re part of  the core content! Don’t skip them.
The more you understand, the less you have to memorize.
When the book asks you a question, don’t just skip to the answer.
The more deeply you force your brain to think, the better chance you have of learning and remembering.
Here’s what YOU can do to        bend your brain into submission.
We put them in, but if  we did them for you, that would be like having someone else do your workouts for you.
There’s plenty of evidence that physical activity while learning can increase the learning.
All of the screenshots that you see throughout the book were taken from that edition, so we recommend that you use it.
If  you’re using Visual Studio 2010 Professional, Premium, Ultimate or Test Professional editions, you’ll see some small differences, which we’ve pointed out wherever possible.
You can download the Express Edition for free from Microsoft’s website—it installs cleanly alongside other editions, as well as previous versions of  Visual Studio.
If you absolutely must use an older version of Visual Studio, C# or the .NET Framework, then please keep in mind that you’ll come across topics in this book that won’t be compatible with your version.
The C# team at Microsoft has added some pretty cool features to the language.
Keep in mind that if you’re not using the latest version, there will be some code in this book that won’t work.
Read me This is a learning experience, not a reference book.
We deliberately stripped out everything that might get in the way of  learning whatever it is we’re working on at that point in the book.
And the first time through, you need to begin at the beginning, because the book makes assumptions about what you’ve already seen and learned.
The exercises and activities are not add-ons; they’re part of  the core content of  the book.
Some of  them are to help with memory, some for understanding, and some to help you apply what you’ve learned.
The pool puzzles are the only things you don’t have to do, but they’re good for giving your brain a chance to think about twisty little logic puzzles.
One distinct difference in a Head First book is that we want you to really get it.
And we want you to finish the book remembering what you’ve learned.
Most reference books don’t have retention and recall as a goal, but this book is about learning, so you’ll see some of  the same concepts come up more than once.
The one big assumption that we made when we wrote this book is that you want to learn how to program in C#
So we know you want to get your hands dirty right away, and dig right into the code.
We gave you a lot of  opportunities to sharpen your skills.
We’ve labeled some of  them “Do this!”—when you see that, it means that we’ll walk you through all of  the steps to solve a particular problem.
But when you see the Exercise logo with the running shoes, then we’ve left a big portion of  the problem up to you to solve, and we gave you the solution that we came up with.
Don’t be afraid to peek at the solution—it’s not cheating! But you’ll learn the most if  you try to solve the problem first.
We’ve also placed all the exercise solutions’ source code on the web so you can download it.
For some of  them, there is no right answer, and for others, part of  the learning experience of  the Brain Power activities is for you to decide if  and when your answers are right.
In some of  the Brain Power exercises you will find hints to point you in the right direction.
You should do ALL of the “Sharpen your pencil” activities.
Activities marked with the Exercise (running shoe) logo are really important! Don’t skip them if you’re serious about learning C#
If you see the Pool Puzzle logo, the activity is optional, and if you don’t like twisty logic, you won’t like these either.
When we wrote this book, it had a bunch of  mistakes, issues, problems, typos, and terrible arithmetic errors.
But we’re still really grateful for the work that our technical reviewers did for the book.
We would have gone to press with errors (including one or two big ones) had it not been for the most kick-ass review team EVER.…
First of  all, we really want to thank Chris Burrows and David Sterling for their enormous amount of  technical guidance.
We also want to thank Lisa Kellner—this is our sixth book that she’s reviewed for us, and she made a huge difference in the readability of  the final product.
And special thanks to Jon Skeet for his thorough review and suggestions for the first edition!
David really helped us out, especially with some very neat IDE tricks.
We want to thank our editors, Brett McLaughlin and Courtney Nash, for editing this book.
Brett helped with a lot of the narrative, and the comic idea in Chapter 14 was completely his, and we think it turned out really well.
There are so many people at O’Reilly we want to thank that we hope we don’t forget anyone.
Special thanks to production editor Rachel Monaghan, indexer Lucie Haskins, Emily Quill for her sharp proofread, Ron Bilodeau for volunteering his time and preflighting expertise, and Sanders Kleinfeld for offering one last sanity check—all of  whom helped get this book from production to press in record time.
And as always, we love Mary Treseler, and can’t wait to work with her again! And a big shout out to our other friends and editors, Andy Oram and Mike Hendrickson.
And if you’re reading this book right now, then you can thank the greatest publicity team in the industry: Marsee Henon, Sara Peyton, Mary Rotman, Jessica Boyd, Kathryn Barrett, and the rest of  the folks at Sebastopol.
Lou Barr is an amazing graphic designer who went above and beyond on this one, putting in unbelievable hours and coming up with some pretty amazing visuals.
If  you see anything in this book that looks fantastic, you can thank her (and her mad InDesign skillz) for it.
She did all of  the monster and alien graphics for the labs, and the entire comic book.
Thanks so much, Lou! You are our hero, and you’re awesome to work with.
With a subscription, you can read any page and watch any video from our library online.
Access new titles before they are available for print, and get exclusive access to manuscripts in development and post feedback for the authors.
Copy and paste code samples, organize your favorites, download chapters, bookmark key sections, create notes, print out pages, and benefit from tons of  other time-saving features.
To have full digital access to this book and others on similar topics from O’Reilly and other publishers, sign up for free at http://my.safaribooksonline.com/?portal=oreilly.
With Visual Studio and C#, you’ll be able to program so fast that you’ll never.
With the Visual Studio IDE, you’ll never have to spend hours.
When you’re working with C#, the IDE is your best friend and constant companion.
Here’s what the IDE automates for you… Every time you want to get started writing a program, or just putting a button on a form, your program needs a whole bunch of  repetitive code.
It takes all this code just to draw a button on a form.
Adding a few more visual elements to the form could take 10 times as much code.
The result is a better looking application that takes less time to write.
It’s a program that helps you edit your code, manage your files, and publish your projects.
The language is powerful and easy to learn, and the Visual Studio IDE does a lot of  work for you automatically.
You can leave mundane coding tasks to the IDE and focus on what your code should accomplish.
The IDE includes an easy-to-use interface for building databases, and integrates seamlessly with SQL Server Compact Edition and many other popular database systems.
The Form Designer in the Visual Studio IDE  is one of  the easiest design tools to use out there.
It does so much for you that you’ll find that making stunning user interfaces is one of  the most satisfying parts of  developing a C# application.
You can build full-featured professional programs without having to spend hours writing a graphical user interface entirely from scratch.
The IDE does a lot for you, but you are still in control of  what you build with C#
But the IDE handles all the grunt work, such as:
Keeping track of  your project’s graphics, audio, icons, and other resources.
All this means you’ll have all the time you would’ve spent doing this routine programming to put into building killer programs.
When you use C# and Visual Studio, you get all of these great features, without having to do any extra work.
C# and the Visual Studio IDE make lots of things easy.
He loves hiking, coffee, and nature…and he’s decided that to help save forests, he wants to become a paperless executive, starting with his contacts.
He’s heading to Aspen to go skiing for the weekend, and expects a new address book program by the time he gets back.
Otherwise…well…it won’t be just the old CEO who’s looking for a job.
You’d better find a way to get this data onto the CEO’s laptop quick.
The CEO wants to be able to run his program on his desktop and laptop, so an installer is a must.
Get to know your users’ needs before you start building your program Before we can start writing the address book application—or any application—we need to take a minute and think about who’s going to be using it, and what they need from the application.
The CEO needs to be able to run his address book program at work and on his laptop, too.
He’ll need an installer to make sure that all of  the right files get onto each machine.
The Objectville Paper Company sales team wants to access his address book, too.
They can use his data to build mailing lists and get client leads for more paper sales.
The CEO figures a database would be the best way for everyone in the company to see his data, and then he can just keep up with one copy of  all his contacts.
Think about your users and their needs before you start building the code, and they’ll be happy with the final product once you’re done!
The application has a separate data layer that interacts with the database.
You’re going to need an application with a graphical user interface, objects to talk to a database, the database itself, and an installer.
It sounds like a lot of  work, but you’ll build all of this over the next few pages.
Here’s the structure of  the program we’re going to create:
Each of these objects represents a control on the address book form we’ll create.
We’ll need objects to talk to our tables, a diagram to let our application know what the database structure is, and more.
The data is all stored in a table in a SQL Server Compact database.
Once the program’s built, it’ll be packaged up into a Windows installer.
Here’s the database itself, which Visual Studio will help us create and maintain.
The sales department will just need to point and click to install and then use his program.
The code that defines the form and its objects lives here.
This file contains the C# code that defines the behavior of the form.
What you do in Visual Studio… Go ahead and start up Visual Studio, if  you haven’t already.
Skip over the start page and select New Project from the File menu.
Select Windows Forms Application and choose “Contacts” as the name for your new project.
This has the code that starts up the program and displays the form.
Designer.cs, and Program.cs file, when you create a new project.
This is what the “New Project” window looks like in Visual Studio 2010 Express Edition.
If you’re using the Professional or Team Foundation edition, it might be a bit different.
Make sure that you save your project as soon as you create it by selecting “Save All” from the File menu—that’ll save all of the project files out to the folder.
If you select “Save”, it just saves the one you’re working on.
Below is what your screen probably looks like right now.
You should be able to figure out the purpose of most of these windows and files based on what you already know.
Make sure you open the Toolbox and Error List windows by choosing them from the View >> Other Windows menu.
Then in each of the blanks, try and fill in an annotation saying what that part of the IDE does.
This toolbar has buttons that apply to what you’re currently doing in the IDE.
We’ve blown up this window below so you have more room.
If your IDE doesn’t look exactly like this picture, you can select “Reset Window Layout” from the Window menu.
We’ve filled in the annotations about the different sections of the Visual Studio C# IDE.
You may have some different things written down, but you should have been able to figure out the basics of what each window and section of the IDE is used for.
This toolbar has buttons that apply to what you’re currently doing in the IDE.
This window shows properties of the control currently selected on your form.
It has a bunch of visual controls that you can drag onto your form.
The Form1.cs and Program.cs files that the IDE created for you when you added the new project appear in the Solution Explorer.
You can switch between files using the Solution Explorer in the IDE.
See this little pushpin icon? If you click it, you can turn auto-hide on or off.
Q: So if the IDE writes all this code for me, is learning C# just a matter of learning how to use the IDE?
Q: I created a new project in Visual Studio, but when I went into the “Projects” folder under My Documents, I didn’t see it there.
Q: What if the IDE creates code I don’t want in my project?
Q: Is it OK that I downloaded and installed Visual Studio Express? Or do I need to use one of the versions of Visual Studio that isn’t free in order to do everything in this book?
Q: Can I change the names of the files the IDE generates for me?
Q: I’m looking at the IDE right now, but my screen doesn’t look like yours! It’s missing some of the windows, and others are in the wrong place.
Visual Studio will generate code you can use as a starting point for your applications.
Making sure the application does what it’s supposed to do is entirely up to you.
Adding controls and polishing the user interface is as easy as dragging and dropping with the Visual Studio IDE.
Click on the PictureBox control in the Toolbox, and drag it onto your form.
If you don’t see the toolbox, try hovering over the word “Toolbox” that shows up in the upper left-hand corner of the IDE.
It’s OK if  you’re not a pro at user interface design.
We’ll talk a lot more about designing good user interfaces later on.
Every control on your form has properties that you can set.
Click the little black arrow for a control to access these properties.
Change the PictureBox’s Size property to “Zoom” to see how this works:
Choose “Zoom” so that the PictureBox frame will change to match the size of the picture you put in it.
Then click the PictureBox properties arrow, and select Choose Image.
Click the “Local Resource” radio button to enable the “Import…” button at the top of  the form.
Click that button, find your logo, and you’re all set.
You can also use the “Properties” window in the IDE to set the Size property.
The little black arrow is just there to make it easy to access the most common properties of any control.
Then click “Choose Image” to bring up the Select Resource dialog box so you can import a local resource.
Every time you do something in the Visual Studio IDE, the IDE is writing code for you.
When you created the logo and told Visual Studio to use the image you downloaded, Visual Studio created a resource and associated it with your application.
A resource is any graphics file, audio file, icon, or other kind of  data file that gets bundled with your application.
The graphics file gets integrated into the program, so that when it’s installed on another computer, the graphic is installed along with it and the PictureBox can use it.
When you dragged the PictureBox control onto your form, the IDE automatically created a resource file called Form1.resx to store that resource and keep it in the project.
Double-click on this file, and you’ll be able to see the newly imported image.
This image is now a resource of the Contact List application.
When you imported the image, the IDE created this file for you.
It contains all of the resources (graphics, video, audio and other stored data) associated with Form1
Go to the Solution Explorer and click on the “expand” icon next to Form1.cs to expand it (if  it’s not already expanded)
That file is what links it to the PictureBox, and the IDE added code to do the linking.
If you chose the other “Import.” button from the Select Resource dialog on the last page, then your image will show up in the Resources folder in the Solution Explorer instead.
Don’t worry—just go back to Select Resources, choose “Local Resource,” and reimport the image into the resources, and it’ll show up here.
Add to the auto-generated code The IDE creates lots of  code for you, but you’ll still want to get into this code and add to it.
Let’s set the logo up to show an About message when the users run the program and click on the logo.
When you’re editing a form in the IDE, double-clicking on any of the toolbox controls causes the IDE to automatically add code to your project.
Make sure you’ve got the form showing in the IDE, and then double-click on the PictureBox control.
The IDE will add code to your project that gets run any time a user clicks on the PictureBox.
You should see some code pop up that looks like this:
When you double-clicked on the PictureBox control, the IDE created this method.
It will run every time a user clicks on the logo in the running application.
When you double-click on the PictureBox, it will open this code up with a cursor blinking right here.
Ignore any windows the IDE pops up as you type; it’s trying to help you, but we don’t need that right now.
It causes a message box to pop up with the text you provide.
Once you’ve typed in the line of code, save it using the Save icon on the IDE toolbar or by selecting “Save” from the File menu.
Press the F5 key on your keyboard, or click the green arrow button ( ) on the toolbar to check out what you’ve done so far.
This is called “debugging,” which just means running your program using the IDE.
You can stop debugging by selecting “Stop Debugging” from the Debug menu or clicking this toolbar button:
Clicking on the OPC logo brings up the About box you just coded.
All three of these buttons work—and you didn’t have to write any code to make them work.
Q: In my IDE, the green arrow is marked as “Debug.” Is that a problem?
Q: I don’t see the Stop Debugging button on my toolbar.
This isn’t a mistake; there are two levels of folders.
C# turns your program into a file that you can run, called an executable.
We’ve built a form and created a PictureBox object that pops up a message box when it’s clicked on.
Next, we need to add all the other fields from the card, like the contact’s name and phone number.
Visual Studio can connect fields directly to that database for us, which means we don’t have to mess with lots of  database access code (which is good)
But for that to work, we need to create our database so that the controls on the form can hook up to it.
So we’re going to jump from the .NET Visual Objects straight to the Data Storage section.
Visual Studio can generate code to connect your form to a database, but you need to have the database in place BEFORE generating that code.
This step is about connecting our form to the database, so we’re not ready for it yet, since we don’t have a database.
So we need to focus on this step next: creating our database, and putting some initial data into it.
If you’re not using the Express edition, you’ll see “Server Explorer” instead of “Database Explorer.”
Instead, they have a Server Explorer window, which does everything the Database Explorer does, but also lets you explore data on your network.
Before we add the rest of  the fields to the form, we need to create a database to hook the form up to.
The IDE can create lots of  the code for connecting our form to our data, but we need to define the database itself  first.
For now, we want to skip configuring a data source, so click the Cancel button.
We’ll come back to this once we’ve set up our database structure.
It gives you an easy way to embed a database into your program.
Go to the Solution Explorer, and you’ll see that ContactDB has been added to the file list.
Double-click ContactDB.sdf  in the Solution Explorer and look at the left side of  your screen.
We’re just about to define tables and data for it, and all of that will be stored in here too.
When you told the IDE to add a new SQL database to your project, the IDE created a new database for you.
A SQL database is a system that stores data for you in an organized, interrelated way.
The IDE gives you all the tools you need to maintain your data and databases.
For now, you can think of  a table like a spreadsheet.
The columns are the data categories, like a contact’s name and phone number, and each row is the data for one contact card.
A SQL database can hold stored procedures, which are a bunch of  SQL statements and queries that are stored in the database and can be run at any time.
The IDE generates SQL statements and stored procedures for you automatically to let your program access the data in the database.
A SQL database stores your data, and has information about how it’s structured and SQL code to help you access it.
Your data’s stored in a table with columns and rows, like in a spreadshee.
Creat ing the table for the Contact List We have a database, and now we need to store information in it.
But our information actually has to go into a table, the data structure that databases use to hold individual bits of  data.
For our application, let’s create a table called “People” to store all the contact information:
This will open up a window where you can define the columns in the table you just created.
First, let’s add a column called ContactID to our new People table, so that each Contact record has its own unique ID.
Type “ContactID” in the Column Name field, and select Int from the Data Type drop-down box.
Finally, let’s make this the primary key of  our table.
Highlight the ContactID column you just created, and click the Primary Key button.
This tells the database that each entry will have a unique primary key entry.
Add a new column called “ContactID” with data type “int”
This will make it so that the ContactID field updates automatically whenever a new record is added.
A primary key helps your database look up records quickly.
Since the primary key is the main way your program will locate records, it always needs to have a value.
Since ContactID is a number for the database, and not our users, we can tell our database to handle creating and assigning IDs for us automatically.
That way, we don’t have to worry about writing any code to do this.
In the properties below your table, set Identity to “True” to make ContactID an identity column for your table.
And make sure you specify the table name “People” in the Name box at the top of  the window.
This window is what you use to define your table and the data it will store.
You’ll need to click on the right column and select “True” from the drop-down next to Identity to designate ContactID as your table’s record Identifier.
The blanks on the contact card are columns in our People table Now that you’ve created a primary key for the table, you need to define all of  the fields you’re going to track in the database.
Each field on our written contact card should become a column in the People table.
Each blank on the card should map to a column in the people table.
For each person, we want to store data: her name, company, phone number, email address, if she’s an OPC client, and the date of the last time she was called.
What kinds of problems could result from having multiple rows stored for the same person?
Now that you’ve created a People table and a primary key column, you need to add columns for all of  the data fields.
See if  you can work out which data type goes with each of  the columns in your table, and also match the data type to the right description.
Now that you’ve created a People table and a primary key column, you need to add columns for all of  the data fields.
See if  you can work out which data type goes with each of  the columns in your table, and also match the data type to the right description.
If you set Allow Nulls to No, the column must have a value.
Click on the OK button to save your new table.
Bit fields hold True or False values and can be represented as a checkbox.
Finish building the table Go back to where you entered the ContactID column and add the other five columns from the contact card.
Here’s what your database table should look like when you’re done:
Some cards might have some missing information, so we’ll let certain columns be blank.
Once you click OK, Visual Studio adds a new People table to the database.
This new table is empty, but it’s ready for you to add data!
Now you’re ready to start entering cards into the database.
Here are some of  the boss’s contacts—we’ll use those to set up the database with a few records.
Once you see the Table grid in the main window, go ahead and add all of  the data below.
You’ll see all null values at first—just type over them when you add your first row.
And ignore the exclamation points that appear next to the data.
You don’t need to fill in the ContactID column; that happens automatically.
Your job is to enter the data from all six of these cards into the People table.
That’s different from “Save”, which just saves the file you’re working on.
Once you’ve entered all six records, select Save All from the File menu again.
Q: So what happened to the data after I entered it? Where did it go?
This file is actually a SQL database, and your program can use it with the code the IDE generated for you.
If your machine is set to a different location, you may need to enter dates differently; you might need to use 26/05/10 instead.
We’re finally ready to build the .NET database objects that our form will use to talk to your database.
We need a data source, which is really just a collection of  SQL statements your program will use to talk to the ContactDB database.
Once you’re done entering data, close the data entry window to get back to your form.
The data source you’re creating will handle all the interactions between your form and your database.
Connect your form to your database objects with a data source.
Close out the People table and the ContactDB database diagram.
These steps connect your new data source with the People table in the ContactDB database.
These files are what’s generated by the data source you just set up.
Now your form can use the data source to interact with the ContactDB database.
Now you need to set up your data source to use the ContactDB database.
In the Dataset Name field, make sure it says “ContactDBDataSet” and click Finish.
In the non-Express editions, you may be asked to save the connection in the app config.
All of the columns you created should show up here.
Now we can go back to our form and add some more controls.
But these aren’t just any controls—they are controls that are bound to our database and the columns in the People table.
That just means that a change to the data in one of  the controls on the form automatically changes the data in the matching column in the database.
It took a little work, but now we’re back to creating form objects that interact with our data storage.
This will bring up the Data Sources window, showing the sources you have set up for your application.
We’ve only got one setup, but you could have more for different tables or databases.
You can also look for, and click on, the Data Sources tab along the bottom of your Database Explorer window.
Under the ContactDBDataSet, you should see the People table and all of  the columns in it.
Click the “expand” icon next to the People table to expand it—you’ll see the columns that you added to your table.
When you click on the People table in the Data Sources window and drag it onto your form, the IDE automatically adds data controls to your form that the user can use to browse and enter data.
By default it adds a DataGridView, which lets the user work with the data using one big spreadsheet-like control.
Click the arrow next to the People table and select Details—that tells the IDE to add individual controls to your form for each column in the table.
If you don’t see this tab, select Show Data Sources from the Data menu.
When you dragged the People table onto the form, a control was created for each column in the table.
These won’t show up on your form, but represent the code that the IDE created to interact with the People table and ContactDB database.
The IDE creates this toolbar for navigating through the People table.
This adapter allows your controls to interact with SQL commands that the IDE and data source generated for you.
The binding navigator connects the toolbar controls  to your table.
Drag and drop the People table onto your form in the form designer window.
You should see controls appear for each column in your database.
Don’t worry too much about how they look right now; just make sure that they all appear on the form.
With just a few simple steps, you can make the form look a lot more like the paper cards we were using at the beginning of  the chapter.
Blue lines will show up on the form as you drag controls around.
Our form would be more intuitive if it looked a lot like the contact card.
Line up your fields and labels along the left edge of the form.
Your form will look like other applications, and make your users feel more comfortable using it.
When you first drag the fields onto the form, your Client checkbox will have a label to the right that needs to be deleted.
Right below the Solution Explorer, you’ll see the Properties window.
Scroll down to the Text property and delete the “checkbox1” label.
The Text property controls the heading on your form’s title bar.
You can change the name of  the form by clicking on any empty space within the form, and finding the Text property in the Properties window of  your IDE.
You can also turn off  the Maximize and Minimize buttons in this same window, by looking for the MaximizeBox and MinimizeBox properties.
A good application not only works, but is easy to use.
It’s always a good idea to make sure it behaves as a typical user would expect it to.
The reason you want to turn off the Maximize button is that maximizing your form won’t change the positions of the controls, so it’ll look weird.
If you don’t have a Properties window, you can turn it on by selecting it from the View drop-down menu.
You can always run your programs at any time, even when they’re not done—although if  there’s an error in the code, the IDE will tell you and stop you from executing it.
Click the X box in the corner to stop the program so you can move on to the next step.
The IDE builds f irst, then runs When you run your program in the IDE it actually does two things.
It compiles the code, or turns it into an executable file.
Then it places the compiled code, along with any resources and other files, into a subdirectory underneath the bin folder.
In this case, you’ll find the executable and SQL database file in bin/ debug.
Since it copies the database out each time, any changes you make will be lost the next time you run inside the IDE.
But if  you run the executable from Windows, it’ll save your data—until you build again, at which point the IDE will overwrite the SQL database with a new copy that contains the data you set up from inside the Database Explorer.
These controls let you page through the different records in the database.
We’ll spend more time on this in the next chapter.
Every time you build your program, the IDE puts a fresh copy of the database in the bin.
This will overwrite any data you added when you ran the program.
When you debug your program, the IDE rebuilds it if the code has changed—which means that your database will sometimes get overwritten when you run your program in the IDE.
If you run the program directly from the bin/debug or bin/release folder, or if you use the installer to install it on your machine, then you won’t see this problem.
That means that nobody else can use the app, pay you for it, see how great you are and hire you… and your boss and customers can’t see the reports you’re generating from the database.
C# makes it easy to take an application you’ve created, and deploy it.
Deployment is taking an application and installing it onto other machines.
And with the Visual C# IDE, you can set up a deployment with just two steps.
How to turn YOUR applicat ion into EVERYONE’S applicat ion.
Building the solution just copies the files to your local machine.
Publish creates a Setup executable and a configuration file so that any machine could install your program.
Just accept all of  the defaults in the Publish Wizard by clicking Finish.
You’ll see it package up your application and then show you a folder that has your Setup.
If you’re using Visual Studio Express, you’ll find “Publish” in the Project menu, but in other editions it may be in the Build menu.
This is how your users will install the program on their computers!
Once you’ve created a deployment, you’ll have a new folder called publish/
That folder has several things in it, all used for installation.
The most important for your users is setup, a program that will let them install your program on their own computers.
My secretary just told me that you’ve got the new contact database working already.
Pack your bags—we’ve got room on the jet to Aspen for a go-getter like you!
If SQL Server Compact isn’t already installed on the machine, the installer will automatically download and install it.
On some machines, this won’t work unless you run the setup as administrator, so right-click on “setup” and choose “Run as administrator” to install it.
If you don’t have access to do that, don’t worry! You don’t need to in order to move forward in the book.
They’re part of the ContactDB.sdf database file, which gets installed along with your program.
You can use the arrows and the text field to switch between records.
You’re NOT done: test your installat ion Before you pop the cork on any champagne bottles, you need to test your deployment and installation.
You wouldn’t give anyone your program without running it first, would you?
Click the setup program, and select a location on your own computer to install the program.
Now run it from there, and make sure it works like you expect.
You can add and change records, too, and they’ll be saved to the database.
Now you can make changes to the data, and they’ll get saved to the database.
You’ve built a complete data-dri ven applicat ion The Visual Studio IDE made it pretty easy to create a Windows application, create and design a database, and hook the two together.
You even were able to build an installer with a few extra clicks.
CSharpcross Take some time to sit back and exercise your C# vocabulary with this crossword; all of the solution words are from this chapter.
The _________ Explorer shows you all of the files in your project.
You drag controls out of this and onto your form.
The _________ Explorer shows you all of the files in your project [solution]
You drag controls out of this and onto your form [toolbox]
You can get a lot of work done using the IDE.
Sure, there are a lot of repetitive tasks that you do when.
And the IDE is great at doing those things for.
Once you get the hang of coding, there’s nothing your programs can’t do.
One of these days I’ll figure out what’s going on under there…
When you’re doing this… The IDE is a powerful tool—but that’s all it is, a tool for you to use.
Every time you change your project or drag and drop something in the IDE, it creates code automatically.
It’s really good at writing boilerplate code, or code that can be reused easily without requiring much customization.
Let’s look at what the IDE does in typical application development, when you’re…
It would take a lot longer to do it by hand.
Use the F4 shortcut to open the Properties window if it’s closed.
Creating a Windows Forms Application project There are several kinds of  applications the IDE lets you build, but we’ll be concentrating on Windows Forms applications for now.
Those are programs that have visual elements, like forms and buttons.
Dragging a button out of the toolbox and onto your form, and then double-clicking it Buttons are how you make things happen in your form.
We’ll use a lot of  buttons to explore various parts of  the C# language.
They’re also a part of  almost every C# application you’ll write.
Setting a property on your form The Properties window in the IDE is a really powerful tool that you can use to change attributes of just about everything in your program: all visual and functional properties for the controls on your form, attributes of  your databases, and even options on your project itself.
All of these tasks have to do with standard actions and boilerplate code.
Those are the things the IDE is great for helping with.
Make sure you always create a Windows Forms Application project—that tells the IDE to create an empty form and add it to your new project.
The IDE knows how to add an empty method to handle a button click.
But it doesn’t know what to put inside it—that’s your job.
These files are created from a predefined template that contains the basic code to create and display a form.
Every time you make a change in the IDE, it makes a change to the code, which means it changes the files that contain that code.
Sometimes it just modifies a few lines, but other times it adds entire files to your project.
Where programs come from A C# program may start out as statements in a bunch of files, but it ends up as a program running in your computer.
The .NET Framework gives you the right tools for the job C# is just a language—by itself, it can’t actually do anything.
Remember that Maximize button you turned off  for the Contacts form? When you click the Maximize button on a window, there’s code that tells the window how to maximize itself  and take up the whole screen.
Buttons, checkboxes, lists… those are all pieces of  the .NET Framework.
So are the internal bits that hooked your form up to the database.
It’s got tools to draw graphics, read and write files, manage collections of  things…all sorts of  tools for a lot of  jobs that programmers have to do every day.
The tools in the .NET Framework are divided up into namespaces.
You’ve seen these namespaces before, at the top of  your code in the “using” lines.
Every program starts out as source code f i les You’ve already seen how to edit a program, and how the IDE saves your program to files in a folder.
Those files are your program—you can copy them to a new folder and open them up, and everything will be there: forms, resources, code, and anything else you added to your project.
You can think of  the IDE as a kind of  fancy file editor.
It automatically does the indenting for you, changes the colors of  the keywords, matches up brackets for you, and even suggests what words might come next.
But in the end, all the IDE does is edit the files that contain your program.
The IDE bundles all of  the files for your program into a solution by creating a solution (.sln) file and a folder that contains all of  the other files for the program.
The solution file has a list of  the project files (which end in .csproj) in the solution, and the project files contain lists of  all the other files associated with the program.
In this book, you’ll be building solutions that only have one project in them, but you can easily add other projects to your solution using the IDE’s Solution Explorer.
There’s no reason you couldn’t build your programs in Notepad, but it’d be a lot more time-consuming.
Build the program to create an executable When you select “Build Solution” from the Build menu, the IDE compiles your program.
It does this by running the compiler, which is a tool that reads your program’s source code and turns it into an executable.
The executable is a file on your disk that ends in .exethat’s what you double-click on to run your program.
When you build the program, it creates the executable inside the bin folder, which is inside the project folder.
When you publish your solution, it copies the executable (and any other files necessary) into the folder you’re publishing to.
When you select “Start Debugging” from the Debug menu, the IDE compiles your program and runs the executable.
It’s got some more advanced tools for debugging your program, which just means running it and being able to pause (or “break”) it so you can figure out what’s going on.
Your program runs inside the CLR When you double-click on the executable, Windows runs your program.
But there’s an extra “layer” between Windows and your program called the Common Language Runtime, or CLR.
Once upon a time, not so long ago (but before C# was around), writing programs was harder, because you had to deal with hardware and low-level machine stuff.
You never knew exactly how someone was going to configure his computer.
The CLR—often referred to as a virtual machine—takes care of  all that for you by doing a sort of  “translation” between your program and the computer running it.
You’ll learn about all sorts of  things the CLR does for you.
For example, it tightly manages your computer’s memory by figuring out when your program is finished with certain pieces of  data and getting rid of  them for you.
That’s something programmers used to have to do themselves, and it’s something that you don’t have to be bothered with.
You won’t know it at the time, but the CLR will make your job of  learning C# a whole lot easier.
You don’t really have to worry about the CLR much right now.
It’s enough to know it’s there, and takes care of running your program for you automatically.
The IDE helps you code You’ve already seen a few of  the things that the IDE can do.
Let’s take a closer look at some of  the tools it gives you.
The Solution Explorer shows you everything in your project You’ll spend a lot of  time going back and forth between classes, and the easiest way to do that is to use the Solution Explorer.
Use the tabs to switch between open files Since your program is split up into more than one file, you’ll usually have several code files open at once.
When you do, each one will be in its own tab in the code editor.
The IDE displays an asterisk (*) next to a filename if  it hasn’t been saved yet.
When you’re working on a form, you’ll often have two tabs for it at the same time—one for the form designer, and one to view the form’s code.
The Solution Explorer shows you how the different files in the solution folder.
Here’s the form’s resource file that you added the Objectville Paper Company logo to.
The Error List helps you troubleshoot compiler errors If  you haven’t already discovered how easy it is to make typos in a C# program, you’ll find out very soon! Luckily, the IDE gives you a great tool for troubleshooting them.
When you build your solution, any problems that keep it from compiling will show up in the Error List window at the bottom of  the IDE:
Double-click on an error, and the IDE will jump to the problem in the code:
The IDE helps you write code Did you notice little windows popping up as you typed code into the IDE? That’s a feature called IntelliSense, and it’s really useful.
One thing it does is show you possible ways to complete your current line of  code.
If  you type MessageBox and then a period, it knows that there are three valid ways to complete that line:
The IDE also has shortcuts called snippets that let you type an abbreviation to tell it to fill in the rest of  the code.
Here’s a useful one: type mbox and press the Tab key twice, and the IDE will fill in the MessageBox.Show method for you:
That can be a real timesaver if you’re typing a lot of really long method names.
This means that there are 21 different ways that you can call the MessageBox’s Show method (like ways to display different buttons or icons)
When you use Start Debugging to run your program inside the IDE, the first thing it does is build your program.
If not, it won’t run, and will show you errors in the Error List.
The IDE will show a red underscore to show you that there’s an error.
A missing semicolon at the end of a statement is one of the most common errors that keeps your program from building!
The IDE is great at writing visual code for you.
Open up Visual Studio, create a new Windows Forms Application project, and see for yourself.
But this time, instead of  opening it in the Form Designer, open up its code by right-clicking on it in the Solution Explorer and selecting “View Code.” Look for the Form1 class declaration:
Notice how it’s a partial class? We’ll talk about that in a minute.
Scroll down and look for this line in the code:
Click on the + on the left-hand side of  the line to expand the code.
Don’t worry if the numbers in your code for the Location and Size lines are a little different than these…
When you change things in the IDE, you’re also changing your code.
When you see a “Do this!”, pop open the IDE and follow along.
We’ll tell you exactly what to do, and point out what to look for to get the most out of the example we show you.
Open up the Form designer and add a PictureBox to your form Get used to working with more than one tab.
Go to the Solution Explorer and open up the Form designer by double-clicking on Form1.cs.
There’s nothing more attractive to a kid than a big sign that says, “Don’t touch this!” Come on, you know you’re tempted… let’s go modify the contents of  that method with the code editor! Add a button to your form, and then go ahead and do this:
What do you think it will do to the Properties window in the IDE? Give it a shot—see what happens! Now go back to the form designer and check the Text property.
Stay in the designer, and use the Properties window to change the Name property to something else.
See if  you can find a way to get the IDE to change the Name property.
It’s in the Properties window at the very top, under “(Name)”
What happened to the code? What about the comment in the code?
Change the code that sets the Location property to (0,0) and the Size property to make the button really big.
Go back to the designer, and change the button’s BackColor property to something else.
You don’t have to save the form or run the program to see the changes.
Just make the change in the code editor, and then click on the tab labeled “Form1.cs [Design]” to flip over to the form designer—the changes should show up immediately.
It’s always easier to use the IDE to change your form’s Designer‑generated code.
But when you do, any change you make in the IDE ends up as a change to your project’s code.
Wait, wait ! What did that say? Scroll back up for a minute.
There it is, at the top of  the Windows Form Designer–generated code section: Most comments only start.
These are XML comments, and you can use them to document your code.
Flip to “Leftovers” section #1 in the Appendix of this book to learn more about them.
Every time you make a new program, you define a namespace for it so that its code is separate from the .NET Framework classes.
And methods are made up of statements—like the ones you’ve already seen.
A class contains a piece of your program (although some very small programs can have just one class)
The code file starts by using the .NET Framework tools You’ll find a set of  using lines at the top of  every program file.
They tell C# which parts of the .NET Framework to use.
If  you use other classes that are in other namespaces, then you’ll add using lines for them, too.
Since forms often use a lot of  different tools from the .NET Framework, the IDE automatically adds a bunch of  using lines when it creates a form and adds it to your project.
Every C# program’s code is structured in exactly the same way.
All programs use namespaces, classes, and methods to make your code easier to manage.
Let’s take a closer look at your code Open up the code from your Contacts project’s Form1.cs so we can go through it piece by piece.
These using lines are at the top of every code file.
They tell C# to use all of those .NET Framework classes.
Each one tells your program that the classes in this particular .cs file will use all of the classes in one specific .NET Framework namespace.
One thing to keep in mind: you don’t actually have to use a using statement.
A class can do anything, but most classes do one specific thing.
When you created the new program, the IDE added a class called Form1 that displays a form.
Classes contain methods that perform actions When a class needs to do something, it uses a method.
A method takes an input, performs some action, and sometimes produces an output.
The way you pass input into a method is by using parameters.
Methods can behave differently depending on what input they’re given.
If  you see the keyword void in front of  a method, that means it doesn’t return anything.
When your program calls a method, it executes the first statement in the method, then the next, then the next, etc.
When the method runs out of  statements or hits a return statement, it ends, and the program resumes after the statement that originally called the method.
It contains all of the code to draw the form and the Toolbox controls on it.
The IDE created it when you told it to create a new Windows Forms Application project.
You already know what it does—it pops up a little message box window.
The first one was a string of text to display in the message box, and the second one was a string to display in its title bar.
When you called your program Contacts, the IDE created a namespace for it called Contacts by adding the namespace keyword at the top of your code file.
Everything inside its pair of curly brackets is part of the Contacts namespace.
When you created the new Windows Application solution, one of  the files the IDE added was called Program.cs.
It’s got a class called Program, and inside that class is a method called Main()
That method is the entry point, which means that it’s the very first thing that’s run in your program.
This statement creates and displays the Contacts form, and ends the program when the form’s closed.
I do declare! The first part of every class or method is called a declaration.
Remember, this is just a starting point for you to dig into the code.
But before you do, you’ll need to know what you’re looking at.
Every time you run your program, it starts here, at the entry point.
Here’s some code the IDE built for you automatically in the last chapter.
Every C# program can only have one entry point method, and it’s always called Main()
That’s how it knows where to start when you run it.
Lines that begin with two or more slashes are comments, which you can add anywhere you want.
Every C# program must have exactly one method called Main.
When you run your code, the code in your Main() method is executed FIRST.
Namespaces let you use the same name in different programs, as long as those programs aren’t also in the same namespace.
You’ll find lines like this at the top of  almost every C# class file.
In this case, that namespace has lots of  visual elements in it like buttons and forms.
Here’s the namespace the IDE created for you—it chose Contacts based on your project’s name.
All of  the code in your program lives in this namespace.
The IDE created it and added the code that starts the program and brings up the Contacts form.
This code has one method, and it contains several statements.
A namespace has classes in it, and classes have methods.
In this program, the statements handle starting up the Contacts form.
Each program has a special kind of method called the entry point.
Every C# program must have exactly one method called Main.
Even though your program has a lot of  methods, only one can be the first one that gets executed, and that’s your Main method.
C# checks every class in your code for a method that reads static void Main()
Then, when the program is run, the first statement in this method gets executed, and everything else follows from that first statement.
Your programs will use more and more namespaces like this one as you learn about C# and .NET’s other built-in features throughout the book.
If you didn’t specify the “using” line, you’d have to explicitly type out System.
You can change your program’s entry point As long as your program has an entry point, it doesn’t matter which class your entry point method is in, or what that method does.
Open up the program you wrote in Chapter 1, remove the Main method in Program.cs, and create a new entry point.
Go back to Program.cs and change the name of  the Main method to NotMain.
You add a class to your program by right-clicking on the project name in the Solution Explorer and selecting “Add>>Class…”
The IDE will add a class to your program called AnotherClass.
Write down what happened when you changed the method name, and why you think that happened.
These four standard using lines were added to the file.
The IDE automatically named the class based on the filename.
This class is in the same Contacts namespace that the IDE added when you first created the Windows Application project.
Add this method to the AnotherClass class by typing it in between the curly brackets:4
Show() is a method that’s part of the MessageBox class.
Right-click on the project in Properties and select “Add” and “Class…”
So what happened? Instead of  popping up the Contacts application, your program now shows this message box.
When you made the new Main() method, you gave your program a new entry point.
There’s nothing else in that method, so once you click the OK button, the program runs out of  statements to execute and then it ends.
Figure out how to fix your program so it pops up Contacts again.5 Hint: You only have to change two lines in two files to do it.
Fill in the annotations so they describe the lines in this C# file that they’re pointing to.
Fill in the annotations so they describe the lines in this C# file that they’re pointing to.
All of the code lives in classes, so the program needs a class here.
When it’s executed, it pops up a little window with a message inside of it.
Q: I don’t quite get what the entry point is.
Q: How come I get errors in the Error List window when I try to run my program? I thought that only happened when I did “Build Solution.”
Its name is “DoSomething,” and when it’s called it pops up a MessageBox..
A lot of the errors that show up when you compile your code also show up in the Error List window and as red squiggles under your code.
Match each of  these fragments of  code generated by the IDE to what it does.
Some of  these are new—take a guess and see if  you got it right.
Nothing—it’s a comment that the programmer added to explain the code to anyone who’s reading it.
Disable the maximize icon (      ) in the title bar of  the Form1 window.
A special kind of  comment that the IDE uses to explain what an entire block of code does.
A block of  code that executes whenever a program opens up a Form1 window.
Nothing—it’s a comment that the programmer added to explain the code to anyone who’s reading it.
A special kind of  comment that the IDE uses to explain what an entire block of code does.
A block of  code that executes whenever a program opens up a Form1 window.
Match each of  these fragments of  code generated by the IDE to what it does.
Some of  these are new—take a guess and see if  you got it right.
Disable the maximize icon (      ) in the title bar of  the Form1 window.
Take a look at these two class files from a program called PetFiler2
They’ve got three classes: a Dog class, a Cat class, and a Fish class.
Since they’re all in the same PetFiler2 namespace, statements in the Dog.Bark() method can call Cat.Meow() and Fish.Swim()
It doesn’t matter how the various namespaces and classes are divided up between files.
You can only split a class up into different files if you use the partial keyword.
You probably won’t do that in any of the code you write in this book, but the IDE used it to split your form up into two files, Form1
Since these classes are in the same namespace, they can all “see” each other—even though they’re in different files.
A class can span multiple files too, but you need to use the partial keyword when you declare it.
There’s more to namespaces and class declarations, but you won’t need them for the work you’re doing right now.
Flip to #2 in the “Leftovers” appendix to read more.
Declare your variables Whenever you declare a variable, you tell your program its type and its name.
These are the names of these variables.These are the v ariable types.
C# uses the variable type to define what data these variables can hold.
Your programs use variables to work with data When you get right down to it, every program is basically a data cruncher.
Sometimes the data is in the form of  a document, or an image in a video game, or an instant message.
A variable is what your program uses to store data.
Variables vary A variable is equal to different values at different times while your program runs.
This is really important, because that idea is at the core of  every program that you’ve written or will ever write.
So if  your program sets the variable myHeight equal to 63:
Then, later on, if  you change its value to 12:
Whenever your program needs to work with numbers, text, true/false values, or any other kind of data, you’ll use variables to keep track of them.
If so, you might find a few things in this chapter seem really familiar.
Still, it’s worth taking the time to run through the exercises anyway, because there may be a few ways that C# is different from what you’re used to.
The drill’s variable speed bit let Bob change the drill speed from slow to fast based on the job he had to do.
If you write code that uses a variable that hasn’t been assigned a value, your code won’t compile.
It’s easy to avoid that error by combining your variable declaration and assignment into a single statement.
You have to assign values to variables before you use them Try putting these statements into a C# program:
You’ll get an error, and the IDE will refuse to compile your code.
That’s because the compiler checks each variable to make sure that you’ve assigned it a value before you use it.
The easiest way to make sure you don’t forget to assign your variables values is to combine the statement that declares a variable with a statement that assigns its value:
Once you’ve assigned a value to your variable, that value can change.
So there’s no disadvantage to assigning a variable an initial value when you declare it.
A few useful types Every variable has a type that tells C# what kind of  data it can hold.
In the meantime, we’ll concentrate on the three most popular types.
C# uses familiar math symbols Once you’ve got some data stored in a variable, what can you do with it? Well, if  it’s a number, you’ll probably want to add, subtract, multiply, or divide it.
Here’s a block of  code that uses operators to do some simple math:
You’ll use int a lot for counting, and when you do, the ++ and -- operators come in handy.
You’ll get to know them because you’ll see ’em over and over again.
When you use the + operator with a string, it just puts two strings together.
This MessageBox will pop up a box that says “hello again hello”
To programmers, the word “string” almost always means a string of text, and “int” is almost always short for integer.
When you set a breakpoint on a line of code, the line turns red and a red dot appears in the margin of the code editor.
When you debug your code by running it inside the IDE, as soon as your program hits a breakpoint it’ll pause and let you inspect and change the values of all the variables.
The debugger is a great tool for understanding how your programs work.
You can use it to see the code on the previous page in action.
Create a new Windows Forms Application project Drag a button onto your form and double-click it.
Then take a look at the comments in the screenshot below:
Insert a breakpoint on the first line of code Right-click on the first line of  code (int number = 15;) and choose “Insert Breakpoint” from the Breakpoint menu.
Creating a new Windows Forms Application project will tell the IDE to create a new project with a blank form and an entry point.
You don’t have to worry about what you type in between those marks, because comments are always ignored by the compiler.
Your program should start up as usual and pop up the form.
Click on the button to trigger the breakpoint As soon as your program gets to the line of  code that has the breakpoint, the IDE automatically brings up the code editor and highlights the current line of  code in yellow.
The Watch window should appear in the panel at the bottom of  the IDE:
Step through the code Press F10 to step through the code.
You can also choose Debug >> Step Over from the menu, or click the Step Over button in the Debug toolbar.
The next line of code will then be highlighted in yellow, and the Watch window will be updated:
Adding a watch can help you keep track of the values of the variables in your program.
This will really come in handy when your programs get more complex.
You can also hover over a variable while you’re debugging to see its value displayed in a tooltip…and you can pin it so it says open!
As soon as the number variable gets a new value (15), its watch is updated.
That’s a big part of why booleans are so important.
A loop uses a test to figure out if it should keep looping.
Here’s a peculiar thing about most large programs: they almost always involve doing certain things over and over again.
The statement will keep looping as long as the second one is true.
And the third statement gets executed after each time through the loop.
In a while loop, all of the statements inside the curly brackets get executed as long as the condition in the parentheses is true.
Use a code snippet to write simple for loops You’ll be typing for loops in just a minute, and the IDE can help speed up your coding a little.
Type for followed by two tabs, and the IDE will automatically insert code for you.
If  you type a new variable, it’ll automatically update the rest of  the snippet.
Press tab again, and the cursor will jump to the length.
If you change the variable to something else, the snippet automatically changes the other two occurrences of it.
Press tab to get the cursor to jump to the length.
The number of times this loop runs is determined by whatever you set length to.
You can change length to a number or a variable.
Loops perform an act ion over and over If your brackets (or braces—either name will do) don’t match up, your program won’t build, which leads to frustrating bugs.
Luckily, the IDE can help with this! Put your cursor on a bracket, and the IDE highlights its match:
Time to start coding The real work of  any program is in its statements.
So let’s set the stage for digging in and getting some code written.
Add statements to show a message Get started by double-clicking on the first button.
Look closely at the code and the output it produces.
Don’t forget that all your statements need to end in a semicolon:
You can add comments to your code by starting them with two slashes:
Variables are declared with a name and a type (there are plenty of types that you’ll learn about in Chapter 4):
The code for a class or a method goes between curly braces:
Most of the time, extra whitespace is fine: int j     =      1234  ;
There’s a built-in class called Math, and it’s got a member called PI.
Math lives in the System namespace, so the file this code came from needs to have a using System; line at the top.
The \n is an escape sequence to add a line break to the message box.
A lot of  if/else statements check if  two things are equal.
That’s different from the single equals sign (=) operator, which you use to set a value.
You use one equals sign (=) to set a variable’s value, but two equals signs (==) to compare two variables.
You won’t believe how many bugs in programs—even ones made by experienced programmers!—are caused.
You can have as many statements // as you want inside the brackets.
The statement inside the curly brackets is executed only if the test is true.
If the conditional test is true, the program executes the statements between the first set of brackets.
Set up condit ions and see if they’re true Use if/else statements to tell your program to do certain things only when the conditions you set up are (or aren’t) true.
Set a variable and then check its value Here’s the code for the second button.
See if you can tweak one line of code and get it to say “x must be 10” instead.
Make sure you stop your program before you do this—the IDE won’t let you edit the code while the program’s running.
You can stop it by closing the window, using the stop button on the toolbar, or selecting “Stop Debugging” from the Debug menu.
Use logical operators to check condit ions You’ve just looked at the == operator, which you use to test whether two variables are equal.
Don’t worry about memorizing them right now—you’ll get to know them over the next few chapters.
The != operator works a lot like ==, except it’s true if  the two things you’re comparing are not equal.
When you use them to test two variables or values, it’s called performing a conditional test.
When you use a conditional operator to compare two numbers, it’s called a conditional test.
Add another condit ional test The third button makes this output.
Now make a change to two lines of  code so that it pops up both message boxes.
This line checks someValue to see if it’s equal to 3, and then it checks to make sure name is “Joe”
Add loops to your program Here’s the code for the last button.
The first is a while loop, which repeats the statements inside the brackets as long as the condition is true—do something while this is true.
Before you click on the button, read through the code and try to figure out what the message box will show.
Then click the button and see if you were right!
It just assigns a value to the integer that’ll be used in it.
This statement gets executed at the end of each loop.
In this case, it adds one to i every time the loop executes.
This is called the iterator, and it’s run immediately after all the statements in the code block.
More about conditional tests You can do simple conditional tests by checking the value of a variable using a comparison operator.
The next statement will pop up a message box that says.
Let’s get a little more practice with conditional tests and loops.
Circle the conditional tests, and fill in the blanks so that the comments correctly describe the code that’s being run.
Then your loop runs forever! Every time your program runs a conditional test, the result is either true or false.
If  it’s true, then your program goes through the loop one more time.
Every loop should have code that, if  it’s run enough times, should cause the conditional test to eventually return false.
But if  it doesn’t, then the loop will keep running until you kill the program or turn the computer off !
Write down if each loop will repeat forever or eventually end.
If it’s going to end, how many times will it loop?
Remember, a for loop always runs the conditional test at the beginning of the block, and the iterator at the end of the block.
For Loop #3, how many times will this statement be executed?
For Loop #5, how many times will this statement be executed?
The next statement will pop up a message box that says.
Let’s get a little more practice with conditional tests and loops.
Circle the conditional tests, and fill in the blanks so that the comments correctly describe the code that’s being run.
Write down if each loop will repeat forever or eventually end.
If it’s going to end, how many times will it loop?
Here’s a perfect opportunity to try out the debugger on your own! Set a breakpoint on the statement q = p - q;
Add watches for the variables p and q and step through the loop.
Q: Are there any namespaces I’m not allowed to use? Are there any I have to use?
Q: Let’s say I drag something onto my form, so the IDE generates a bunch of code automatically.
Q: So exactly how careful do I have to be with the code that’s automatically generated by the IDE?
Code Magnets Part of a C# program is all scrambled up on the fridge.
The “” is an empty string—it means Result has no characters in it yet.
You can use the properties to change the font size and make it boldface.
Use the BackColor property to set to red—choose “Red” from the selection of  web colors.
Drag it out of  the toolbox and onto your form.
Use the Text property to change the text that’s next to it.
You also use the Text property to change the button and label text.
Pop up this message if the user clicks the button but the box IS NOT checked.
If  your checkbox is named checkBox1 (you can change the Name property if  you want), then here’s the conditional test to see if  it’s checked:
If the user clicks the button and the box IS checked, change the background color of the label.
If  the label background color is red, change it to blue when the button is clicked.
Here’s a statement that sets the background color of  a label called label1:
Hint: The conditional test to check whether a label’s background color is red looks a lot like that statement—but with one important difference.
We’ll give you a lot of exercises like this throughout the book.
We’ll give you the answer in a couple of pages.
If you get stuck, don’t be afraid to peek at the answer—it’s not cheating!
You’ll be creating a lot of applications throughout this book, and you’ll need to give each one a different name.
We recommend naming this one “2 Fun with if-else statements” based on the chapter number and the text in the title bar of the form.
Here’s the block of  code that goes inside the curly brackets:
This line tells the program to stop your loop momentarily and do the other things it needs to do, like refresh the form, check for mouse clicks, etc.
The form doesn’t redraw itself, because it’s waiting until the loop is done before it deals with those events.
You shouldn’t use this code outside of a toy program like this.
Later on in the book, you’ll learn about a much better way to let your programs do more than one thing at a time!
Make it smoother Let’s make the colors cycle back to where they started.
Use the same block of  code inside the curly brackets.
Keep it going Surround your two loops with another loop that continuously executes and doesn’t stop, so that when the button is pressed, the background starts changing colors and then keeps doing it.
When one loop is inside another one, we call it a “nested” loop.
Make it stop Make the loop you added in step #5 stop when the program is closed.
Now run the program and click the X box in the corner.
The window closes, and then the program stops! Except…there’s a delay of  a few seconds before the IDE goes back to edit mode.
Uh-oh! The program doesn’t stop! Run your program in the IDE.
Wait a minute—the IDE didn’t go back into edit mode! It’s acting like the program is still running.
You need to actually stop the program using the square stop button in the IDE (or select “Stop Debugging” from the Debug menu)
Can you figure out what’s causing that delay? Can you fix it so the program ends immediately when you close the window?
It’s how you string a bunch of conditional tests together into one big test that’s true only if the first test is true AND the second is true AND the third, etc.
When you’re checking a Boolean value like Visible in an if statement or a loop, sometimes it’s tempting to test for (Visible == true)
You can leave off the “== true”—it’s enough to include the Boolean.
When you’re working with a form or control, Visible is true as long as the form or control is being displayed.
If you set it to false, it makes the form or control disappear.
We named our solution “Fun with If Else”, so the IDE made the namespace Fun_with_If_Else.
If you gave your solution a different name, it’ll have a different namespace.
The IDE added the method called button1_Click() to your form when you double-clicked on the button.
If the label is currently red, it executes a statement to turn it blue.
The outer if statement checks the checkbox to see if it’s been checked.
This statement’s run if the label’s background color is not red to make it set back to red.
Sometimes we won’t show you the entire code in the solution, just the bits that changed.
All of the logic in the FlashyThing project is in this button1_Click() method that the IDE added when you double-clicked the button in the form designer.
Was your code a little different than ours? There’s more than one way to solve any programming problem—like you could have used while loops instead of for loops.
If your program works, then you got the exercise right!
We fixed the extra delay by using the && operator to make each of the for loops also check Visible.
That way the loop ends as soon as Visible turns false.
The outer loop keeps running as long as the form is visible.
As soon as it’s closed, Visible is false, and the while will stop looping.
The first for loop makes the colors cycle one way, and the second for loop reverses them so they look smooth.
When the IDE added this method, it added an extra return before the curly bracket.
Sometimes we’ll put the bracket on the same line like this to save space—but C# doesn’t care about extra space, so this is perfectly valid.
Can you figure out what’s causing that delay? Can you fix it so the program ends immediately when you close the window?
The delay happens because the for loops need to finish before the while loop can check if  Visible is still true.
You can fix it by adding && Visible to the conditional test in each for loop.
It’s just like saying “if it’s visible” instead of “if it’s true that it’s visible”—they mean the same thing.
Consistency is generally really important to make it easy for people to read code.
But we’re purposefully showing you different ways, because you’ll need to get used to reading code from different people using different styles.
Pool Puzzle Your job is to take code snippets from.
You may not use the same snippet more than once, and you won’t need to use all the snippets.
Note: each snippet from the pool can only be used once!
We included these “Pool Puzzle” exercises throughout the book to give your brain an extra-tough workout.
If you’re the kind of person who loves twisty little logic puzzles, then you’ll love this one.
If you’re not, give it a shot anyway—but don’t be afraid to look at the answer to figure out what’s going on.
And if you’re stumped by a pool puzzle, definitely move on.
The clues also provide mental twists and turns that will help you burn alternative routes to C# right into your brain.
A special method that tells your program where to start.
Code Magnets Solution Part of a C# program is all scrambled up on the fridge.
Can you rearrange the code snippets to make a working C# program that produces the message box? Some of the curly braces fell on the floor and they were too small to pick up, so feel free to add as many of those as you need!
The first time through the loop, x is equal to 3 so this conditional test will be true.
Pool Puzzle Solution Your job was to take code snippets from the.
Your goal was to make a class that will compile and run.
Did you get a different solution? Type it into the IDE and see if it works! There’s more than one correct solution to the pool puzzle.
If you want a real challenge, see if you can figure out what it is! Here’s a hint: There’s another solution that keeps the word fragments in order.
The kind of variable that contains a whole number [integer]
When you’re building a program, it’s always a good idea to start by thinking about what.
When you use objects right, you end up with code that’s.
How Mike thinks about his problems Mike’s a programmer about to head out to a job interview.
He can’t wait to show off  his C# skills, but first he has to get there—and he’s running late!
This is Frank Loudly with your eye-in-the-sky shadow traffic report.
It looks like a three-car pileup on Liberty has traffic backed.
I’ll take the 31st Street bridge, head up Liberty Avenue, and go through Bloomfield.
If I take Route 28 instead, I’ll still be on time!
Mike figures out the route he’ll take to get to the interview.1
Mike comes up with a new route to get to his interview on time.
Mike sets his destination, then comes up with a route.
Now he can come up with a new route to the interview.
How Mike’s car navigat ion system thinks about his problems Mike built his own GPS navigation system, which he uses to help him get around town.
The navigation system sets a destination and comes up with a route.
Mike’s navigation system solves the street navigation problem the same way he does.
The navigation system gets new information about a street it needs to avoid.
Here’s the output from the GetRoute() method—it’s a string that contains the directions Mike should follow.
GetRoute() gives a new route that doesn’t include the street Mike wants to avoid.
It shows the name on top, and the methods on the bottom.
Some methods have a return value Every method is made up of  statements that do things.
But other methods have a return value, or a value that’s calculated or generated inside the method, and sent back to the statement that called that method.
The type of  the return value (like string or int) is called the return type.
If  your method doesn’t have a return value—which means it’s declared with a return type of  void—then the return statement just ends with a semicolon, and you don’t always have to have one in your method.
But if  the method has a return type, then it must use the return statement.
Here’s a statement that calls a method to multiply two numbers.
Mike’s Navigator class has methods to set and modify routes Mike’s Navigator class has methods, which are where the action happens.
But unlike the button_Click() methods in the forms you’ve built, they’re all focused around a single problem: navigating a route through a city.
That’s why Mike stuck them together into one class, and called that class Navigator.
Mike designed his Navigator class so that it’s easy to create and modify routes.
To get a route, Mike’s program calls the SetDestination() method to set the destination, and then uses the GetRoute() method to put the route into a string.
Mike chose method names that would make sense to someone who was thinking about how to navigate a route through a city.
Here’s an example of a method that has a return type—it returns an int.
The method uses the two parameters to calculate the result and uses the return statement to pass the value back to the statement that called it.
Then add a class file to it called Talker.cs by right-clicking on the project in the Solution Explorer and selecting “Class…” from the Add menu.
When you name your new class file “Talker.cs”, the IDE will automatically name the class in the new file Talker.
Then it’ll pop up the new class in a new tab inside the IDE.
Use what you’ve learned to build a program that uses a class Let’s hook up a form to a class, and make its button call a method inside that class.
The BlahBlahBlah() method’s return value is an integer that has the total length of the message it displayed.
You can add “.Length” to any string to figure out how long it is.
This line of code adds the contents of thingToSay and a line break (“\n”) onto the end of it to the finalString variable.
When it calculates the length of a string, a line break (“\n”) counts as one character.
This statement declares a finalString variable and sets it equal to an empty string.
Then double-click on the button and have it run this code that calls BlahBlahBlah() and assigns its return value to an integer called len:
Set the default text of the TextBox to “Hello!” using its Text property.
Now run your program! Click the button and watch it pop up two message boxes.
The class pops up the first message box, and the form pops up the second one.
The BlahBlahBlah() method pops up this message box based on what’s in its parameters.
When the method returns a value, the form pops it up in this message box.
So what did you just build? The new class has one method called BlahBlahBlah() that takes two parameters.
The first parameter is a string that tells it something to say, and the second is the number of  times to say it.
When it’s called, it pops up a message box with the message repeated a number of  times.
The method needs a string for its thingToSay parameter and a number for its numberOfTimes parameter.
It’ll get those parameters from a form that lets the user enter text using a TextBox control and a number using NumericUpDown control.
You can add a class to your project and share its methods with the other classes in the project.
It’d be great if I could compare a few routes and figure out which is fastest....
Mike gets an idea The interview went great! But the traffic jam this morning got Mike thinking about how he could improve his navigator.
He could create three different Navigator classes… Mike could copy the Navigator class code and paste it into two more classes.
Whoa, that can’t be right! What if I want to change a method? Then I need to go back and fix it in three places.
Right! Maintaining three copies of the same code is really messy.
A lot of  problems you need to solve need a way to represent one thing a bunch of  different times.
But it could be a bunch of  turbines, or dogs, or music files, or anything.
All of  those programs have one thing in common: they always need to treat the same kind of  thing in the same way, no matter how many of  the thing they’re dealing with.
It lists all of the methods in a class, and it’s an easy way to see everything that it does at a glance.
Mike can use objects to solve his problem Objects are C#’s tool that you use to work with a bunch of  similar things.
Mike can use objects to program his Navigator class just once, but use it as many times as he wants in a program.
All you need to create an object is the new keyword and the name of a class.
Now you can use the object! When you create an object from a class, that object has all of the methods from that class.
Mike needed to compare three different routes at once, so he used three Navigator objects at the same time.
If  you wanted to build five identical houses in a suburban housing development, you wouldn’t ask an architect to draw up five identical sets of blueprints.
When you define a class, you define its methods, just like a blueprint defines the layout of the house.
You can use one blueprint to make any number of houses, and you can use one class to make any number of objects.
An object gets its methods from its class Once you build a class, you can create as many objects as you want from it using the new statement.
When you do, every method in your class becomes part of  the object.
When you create a new object from a class, i t’s called an instance of that class.
You’ll find the code that the IDE added to the form designer to create the instance of  the Button class.
The IDE search-andreplace feature finds every instance of  a word and changes it to another.
Guess what…you already know this stuff ! Everything in the toolbox is a class: there’s a Button class, a TextBox class, a Label class, etc.
When you drag a button out of  the toolbox, the IDE automatically creates an instance of  the Button class and calls it button1
When you drag another button out of  the toolbox, it creates another instance called button2
Each instance of Button has its own properties and methods.
But every button acts exactly the same way, because they’re all instances of  the same class.
Before: Here’s a picture of your computer’s memory when your program starts.
After: Now it’s got an instance of the House class in memory.
A better solut ion…brought to you by objects! Mike came up with a new route comparison program that uses objects to find the shortest of  three different routes to the same destination.
Mike set up a GUI with a text box—textBox1 contains the destination for the three routes.
Now Mike can call each object’s TotalDistance() method to figure out which route is the shortest.
And he only had to write the code once, not three times!
Any time you create a new object from a class, it’s called creating an instance of that class.
The navigator1 object is an instance of the Navigator class.
Wait a minute! You didn’t give me nearly enough information to build the navigator program.
A geographic navigation program is a really complicated thing to build.
But complicated programs follow the same patterns as simple ones.
Mike’s navigation program is an example of  how someone would use objects in real life.
Theory and pract ice Speaking of  patterns, here’s a pattern that you’ll see over and over again throughout the book.
We’ll introduce a concept or idea (like objects) over the course of  a few pages, using pictures and small code excerpts to demonstrate the idea.
This is your opportunity to take a step back and try to understand what’s going on without having to worry about getting a program to work.
After we’ve introduced a concept, we’ll give you a chance to get it into your brain.
Sometimes we’ll follow up the theory with a writing exercise—like the Sharpen your pencil exercise on the next page.
This combination of  theory and practice is an effective way to get these concepts off  of  the page and stuck in your brain.
A lit t le adv ice for the code exercises If  you keep a few simple things in mind, it’ll make the code exercises go smoothly:
It’s easy to get caught up in syntax problems, like missing parentheses or quotes.
It’s much better to look at the solution than get frustrated with a problem.
All of  the code in this book is tested and definitely works in Visual Studio 2010! But it’s easy to accidentally type things wrong (like typing a one instead of  a lowercase L)
If  your solution just won’t build, try downloading it from the Head First Labs website: http://www.headfirstlabs.com/hfcsharp.
When you run into a problem with a coding exercise, don’t be afraid to peek at the solution.
You can also download the solution from the Head First Labs website.
Follow the same steps that Mike followed on the facing page to write the code to create Navigator objects and call their methods.
Here’s the code Mike wrote to get the destination and street names from the textboxes.
The Math.Min() method built into the .NET Framework compares two numbers and returns the smallest one.
Mike used it to find the shortest distance to the destination.
And here’s the code to create the navigator object, set its destination, and get the distance.
Follow the same steps that Mike followed on the facing page to write the code to create Navigator objects and call their methods.
The Math.Min() method built into the .NET Framework compares two numbers and returns the smallest one.
Mike used it to find the shortest distance to the destination.
And here’s the code to create the navigator object, set its destination, and get the distance.
Here’s the code Mike wrote to get the destination and street names from the textboxes.
Yes! That’s why you used the static keyword in your methods.
Take another look at the declaration for the Talker class you built a few pages ago:
When you called the method you didn’t create a new instance of  Talker.
That’s how you call static methods, and you’ve been doing that all along.
If  you take away the static keyword from the BlahBlahBlah() method declaration, then you’ll have to create an instance of  Talker in order to call the method.
Other than that distinction, static methods are just like object methods.
You can pass parameters, they can return values, and they live in classes.
There’s one more thing you can do with the static keyword.
You can mark your whole class as static, and then all of  its methods must be static too.
If  you try to add a non-static method to a static class, it won’t compile.
I’ve written a few classes now, but I haven’t used “new” to create an instance yet! So does that mean I can call methods without creating objects?
Q: When I think of something that’s “static,” I think of something that doesn’t change.
Does that mean non-static methods can change, but static methods don’t? Do they behave differently?
Q: So I can’t use my class until I create an instance of an object?
Q: Then why would I want a method that needs an instance? Why wouldn’t I make all my methods static?
An instance uses f ie lds to keep track of things You change the text on a button by setting its Text property in the IDE.
When you do, the IDE adds code like this to the designer:
Now you know that button1 is an instance of  the Button class.
What that code does is modify a field for the button1 instance.
You can add fields to a class diagram—just draw a horizontal line in the middle of  it.
A property is very similar to a field—but we’ll get into all that a little later on.
When Mike created three instances of  Navigator classes, his program created three objects.
Each of  those objects was used to keep track of  a different route.
When the program created the navigator2 instance and called its SetDestination() method, it set the destination for that one instance.
An object’s behavior is defined by its methods, and it uses fields to keep track of its state.
Every instance of the class uses them to keep track of its state.
Add this line to separate the fields from the methods.
Every instance of Navigator knows its destination and its route.
What a Navigator object does is let you set a destination, modify its route, and get information about that route.
Let’s create some instances! It’s easy to add fields to your class.
Now every instance gets its own copy of  those variables.
Write down the contents of each message box that will be displayed after the statement next to it is executed.
Remember, when you see “void” in front of a method, it means that it doesn’t return any value.
When you want to create instances of your class, don’t use the static keyword in either the class declaration or the method declaration.
Write down the contents of each message box that will be displayed after the statement next to it is executed.
Each of these new statements creates an instance of the Clown class by reserving a chunk of memory on the heap for that object and filling it up with the object’s data.
Thanks for the memory When your program creates an object, it lives in a part of  the computer’s memory called the heap.
When your code creates an object with a new statement, C# immediately reserves space in the heap so it can store the data for that object.
Here’s a picture of the heap before the project starts.
When your program creates a new object, it gets added to the heap.
What’s on your program’s mind Here’s how your program creates a new instance of  the Clown class:
These statements create the second object and fill it with data.
There’s no new command, which means these statements don’t create a new object.
You can use class and method names to make your code intuit i ve When you put code in a method, you’re making a choice about how to structure your program.
Do you use one method? Do you split it into more than one? Or do you even need a method at all? The choices you make about methods can make your code much more intuitive—or, if  you’re not careful, much more convoluted.
It’s from a control program that runs a machine that makes candy bars.
Those statements don’t give you any hints about why the code’s doing what it’s doing.
In this case, the programmer was happy with the results because she was able to get it all into one method.
But making your code as compact as possible isn’t really useful! Let’s break it up into methods to make it easier to read, and make sure the classes are given names that make sense.
But we’ll start by figuring out what the code is supposed to do.
The nougat temperature must be checked every 3 minute s by an.
Fill the isolation cooling system with a solid stream of water.
Verify that there is no evidence of  air in the system.
The clsTrpV() method has one parameter, but we don’t know what it’s supposed to be.
The chkTemp() method returns an integer… but what does it do?
You can make your code easier to read and write by thinking about the problem your code was built to solve.
If you choose names for your methods that make sense to someone who understands that problem, then your code will be a lot easier to decipher…and develop!
What does the specification say to do if  the nougat is too hot? It tells us to perform the candy isolation cooling system (or CICS) vent procedure.
So let’s make another method, and choose an obvious name for the T class (which turns out to control the turbine) and the ics class (which controls the isolation cooling system, and has two static methods to fill and vent the system):
Now the code’s a lot more intuitive! Even if  you don’t know that the CICS vent procedure needs to be run if  the nougat is too hot, it’s a lot more obvious what this code is doing:
This method’s return type is Boolean, which means it returns a true or false value.
A void return type means the method doesn’t return any value at all.
The IsNougatTooHot() method’s return type By naming the class “Maker” and the.
Give your classes a natural structure Take a second and remind yourself  why you want to make your methods intuitive: because every program solves a problem or has a purpose.
It might not be a business problem—sometimes a program’s purpose (like FlashyThing) is just to be cool or fun! But no matter what your program does, the more you can make your code resemble the problem you’re trying to solve, the easier your program will be to write (and read, and repair, and maintain…)
Let’s build a class diagram Take another look at the if statement in #5 on the previous page.
Now take a look at the code and the class diagram.
Use class diagrams to plan out your classes A class diagram is a simple way to draw your classes out on paper.
It’s a really valuable tool for designing your code BEFORE you start writing it.
Write the name of the class at the top of the diagram.
Then write each method in the box at the bottom.
Now you can see all of the parts of the class at a glance!
The code for the candy control system we built on the previous page called three other classes.
Flip back and look through the code, and fill in their class diagrams.
There was one other class in the code on the previous page.
The code for the candy control system we built on the previous page called three other classes.
Flip back and look through the code, and fill in their class diagrams.
Class diagrams help you organize your classes so they make sense Writing out class diagrams makes it a lot easier to spot potential problems in your classes before you write code.
Thinking about your classes from a high level before you get into the details can help you come up with a class structure that will make sure your code addresses the problems it solves.
It lets you step back and make sure that you’re not planning on writing unnecessary or poorly structured classes or methods, and that the ones you do write will be intuitive and easy to use.
The class is called “Dishwasher”, so all the methods should be about washing dishes.
Write down what you think is wrong with each class, and how you’d fix it.
These two classes are part of a system that a pizza parlor uses to track the pizzas that are out for delivery.
This class is part of the candy manufacturing system from earlier.
The CashRegister class is part of a program that’s used by an automated convenience store checkout system.
We show just one possible way to fix the problems—but there are plenty of other ways you could design these classes depending on how they’ll be used.
These two classes are part of a system that a pizza parlor uses to track the pizzas that are out for delivery.
This class is part of the candy manufacturing system from earlier.
The CashRegister class is part of a program that’s used by an automated convenience store checkout system.
It looks like the DeliveryGuy class and the DeliveryGirl class.
All of the methods in the class do stuff that has to do with.
We added the Gender field because we assumed there was a reason to track delivery guys and girls separately, and that’s why there were two classes for them.
Pool Puzzle Your job is to take code snippets from the.
You may use the same snippet more than once, and you won’t need to use all the snippets.
Your goal is to make classes that will compile and run.
Note: Each snippet from the pool can be used more than once!
Build a class to work with some guys Joe and Bob lend each other money all the time.
The new statements that create the two instances live in the code that gets run as soon as the form is created.
Here’s what the heap looks like after the form is loaded.
We’ll create a Guy class and add two instances of it to a form The form will have two fields, one called joe (to keep track of  the first object), and the other called bob (to keep track of  the second object)
We’ll set each Guy object’s cash and name fields The two objects represent different guys, each with his own name and a different amount of  cash in his pocket.
We’ll give cash to the guys and take cash from them We’ll use each guy’s ReceiveCash() method to increase a guy’s cash, and we’ll use his GiveCash() method to reduce it.
Each guy has a Name field that keeps track of his name, and a Cash field that has the number of bucks in his pocket.
When you take an instance of Guy and call its ReceiveCash() method, you pass the amount of cash the guy will take as a parameter.
The method returns the number of bucks that the guy added to his Cash field.
You call a Guy object’s GiveCash() method to tell him to give up some of his cash, and his ReceiveCash() method when you want him to take some cash back.
Create a project for your guys Create a new Windows Forms Application project (because we’ll be using a form)
Then use the Solution Explorer to add a new class to it called Guy.
The Name field is a string, and it’ll contain the guy’s name (“Joe”)
And the Cash field is an int, which will keep track of how many bucks are in his pocket.
The GiveCash() method has one parameter called amount that you’ll use to tell the guy how much cash to give you.
He uses an if statement to check whether he has enough cash—if he does, he takes it out of his pocket and returns it as the return value.
The Guy makes sure that you’re asking him for a positive amount of cash, otherwise he’d add to his cash instead of taking away from it.
It’s easy to have the wrong number—make sure that every opening bracket has a matching closing bracket.
When they’re all balanced, the IDE will automatically indent them for you when you type the last closing bracket.
It’s passed an amount as a parameter, checks to make sure that amount is greater than zero, and then adds it to his cash.
If the amount was positive, then the ReceiveCash() method returns the amount added.
Build a form to interact with the guys The Guy class is great, but it’s just a start.
Now put together a form that uses two instances of  the Guy class.
It’s got labels that show you their names and how much cash they have, and buttons to give and take cash from them.
Add two buttons and three labels to your form The top two labels show how much cash each guy has.
We’ll also add a field called bank to the form—the third label shows how much cash is in it.
We’re going to have you name some of  the labels that you drag onto the forms.
You can do that by clicking on each label that you want to name and changing its “(Name)” row in the Properties window.
Add fields to your form Your form will need to keep track of  the two guys, so you’ll need a field for each of  them.
Then add a field to the form called bank to keep track of  how much money the form has to give to and receive from the guys.
Since we’re using Guy objects to keep track of Joe and Bob, you declare their fields in the form using the Guy class.
The amount of cash in the form’s bank field goes up and down depending on how much money the form gave to and received from the Guy objects.
Name the top label joesCashLabel, the label underneath it bobsCashLabel, and the bottom label bankCashLabel.
You can leave their Text properties alone; we’ll add a method to the form to set them.
This button will call the Joe object’s ReceiveCash() method, passing it 10 as the amount, and subtracting from the form’s bank field the cash that Joe receives.
This button will call the Bob object’s GiveCash() method, passing it 5 as the amount, and adding the cash that Bob gives to the form’s bank field.
Add a method to the form to update the labels The labels on the right-hand side of  the form show how much cash each guy has and how much is in the bank field.
So add the UpdateForm() method to keep them up to date—make sure the return type is void to tell C# that the method doesn’t return a value.
Type this method into the form right underneath where you added the bank field:
The “Receive $5 from Bob” button doesn’t need to check how much is in the bank, because it’ll just add whatever Bob gives back.
When the user clicks the “Give $10 to Joe” button, the form calls the Joe object’s ReceiveCash() method—but only if the bank has enough money.
The bank needs at least $10 to give to Joe.
If there’s not enough, it’ll pop up this message box.
It just updates the three labels by setting their Text properties.
You’ll have each button call it to keep the labels up to date.
That’s part of  that designer-generated method that gets run once, when the form is first initialized.
Add the lines of code here to create the two objects and set their Name and Cash fields.
Notice how the labels are updated using the Guy objects’ Name and Cash fields.
Make sure you save the project now—we’ll come back to it in a few pages.
It’s up to you to figure out how to get Joe and Bob to start out with their Cash and Name fields set properly.
Here’s where we set up the first instance of Guy.
The first line creates the object, and the next two set its fields.
Q: Why doesn’t the solution start with “Guy bob = new Guy()”? Why did you leave off the first “Guy”?
Q: OK, so then why not get rid of the “Guy bob;” line at the top of the form?
Then we do the same for the second instance of the Guy class.
Make sure you call UpdateForm() so the labels look right when the form first pops up.
There’s an easier way to init ialize objects Almost every object that you create needs to be initialized in some way.
And the Guy object is no exception—it’s useless until you set its Name and Cash fields.
It’s so common to have to initialize fields that C# gives you a shortcut for doing it called an object initializer.
Delete the second two lines and the semicolon after “Guy(),” and add a right curly bracket.2
Here’s the original code that you wrote to initialize Joe’s Guy object.
As soon as you do, the IDE pops up an IntelliSense window that shows you all of the fields that you’re able to initialize.
As soon as you do, the other field shows up.5
Object intializers save you time and make your code more compact and easier to read…and the IDE helps you write them.
This new declaration does exactly the same thing as the three lines of code you wrote originally.
Does it break down into pieces easily? How would you explain that problem to someone else? These are good things to think about when designing your classes.
What real-world things will your program use? A program to help a zoo keeper track her animals’ feeding schedules might have classes for different kinds of food and types of animals.
Someone should be able to figure out what your classes and methods do just by looking at their names.
Sometimes two classes can be combined into one if they’re really similar.
The candy manufacturing system might have three or four turbines, but there’s only one method for closing the trip valve that takes the turbine number as a parameter.
It’d be great if I could compare a few routes and figure out which is fastest....
Use an object initializer to initialize Bob’s instance of Guy You’ve already done it with Joe.
Now make Bob’s instance work with an object initializer too.
Before you double-click on the button, go to the Properties window and change each button’s name using the “(Name)” row—it’s at the top of the list of  properties.
Name the first button joeGivesToBob, and the second one bobGivesToJoe.
This button tells Joe to give 10 bucks to Bob, so you should use the “(Name)” row in the Properties window to name it joeGivesToBob.
This button tells Bob to give 5 bucks to Joe.
Make the buttons work Double-click on the joeGivesToBob button in the designer.
Fill in that method to make Joe give 10 bucks to Bob.
Make sure the form updates itself after the cash changes hands.
If you already clicked the button, just delete it, add it back to your form, and rename it.
Then delete the old button3_Click() method that the IDE added before, and use the new method it adds now.
Here are the object initializers for the two instances of the Guy class.
The trick here is thinking through who’s giving the cash and who’s receiving it.
Take a close look at how the Guy methods are being called.
The results returned by GiveCash() are pumped right into ReceiveCash() as its parameter.
To make Joe give cash to Bob, we call Joe’s GiveCash() method and send its results into Bob’s ReceiveCash() method.
Before you go on, take a minute and flip to #1 in the “Leftovers” appendix, because there’s some basic syntax that we haven’t covered yet.
You won’t need it to move forward, but it’s a good idea to see what’s there.
Objectcross It’s time to give your left brain a break, and put that right brain to work: all the words are object-related and from this chapter.
If a method's return type is _____, it doesn't return anything.
A good method __________ makes it clear what the method does.
A special kind of field that's used by the form controls.
This form control lets the user choose a number from a range you set.
This statement tells a method to immediately exit, and specifies the value that should be passed back to the statement that called the method.
Pool Puzzle Solution Your job was to take code snippets from.
Your goal was to make classes that will compile and run and produce the output listed.
If a method's return type is _____, it doesn't return anything.
A good method __________ makes it clear what the method does.
A special kind of field that's used by the form controls [property]
This form control lets the user choose a number from a range you set.
This statement tells a method to immediately exit, and specifies the value that should be passed back to the statement that called the method.
Data type, database, Lieutenant Commander Data… it’s all important stuff.
You need information from your users, and you use that to look up or produce new.
The variable’s type determines what kind of data it can store There are a bunch of  types built into C#, and each one stores a different kind of  data.
You’ve already seen some of  the most common ones, and you know how to use them.
But there are a few that you haven’t seen, and they can really come in handy, too.
Types you’ll use all the time It shouldn’t come as a surprise that int, string, bool, and double are the most common types.
More types for whole numbers Once upon a time, computer memory was really expensive, and processors were really slow.
And, believe it or not, if  you used the wrong type, it could seriously slow down your program.
Luckily, times have changed, and most of  the time if  you need to store a whole number you can just use an int.
But sometimes you really need something bigger… and once in a while, you need something smaller, too.
A lot of times, if you’re using these types it’s because you’re solving a problem where it really helps to have the “wrapping around” effect that you’ll read about in a few minutes.
The “s” in sbyte stands for “signed,” which means it can be negative (the “sign” is a minus sign)
When you used the Value property in your numericUpDown control, you were using a decimal.
Can you figure out why C# gives you those particular limits?
Types for storing really HUGE and really tiny numbers Sometimes 7 significant figures just isn’t precise enough.
A lot of  programs written for finance or scientific research run into these problems all the time, so C# gives us two more types:
You can see this for yourself—just enter this line of  code that assigns the literal 14.7 to an int variable:
That’s the same error you’ll get if  you try to set an int equal to a double variable.
What the IDE is telling you is that the literal 14.7 has a type—it’s a double.
You can change its type to a float by sticking an F on the end (14.7F)
Literal values for char are always inside single quotes ('x', '3')
You write an escape sequence in your C# code using two characters, but your program stores each escape sequence as a single character in memory.
You’ve already seen how you can create objects by creating instances of  classes.
Well, every one of  those objects can be assigned to an object variable.
You’ll learn all about how objects and variables that refer to objects work later in this chapter.
A “literal” just means a number that you type into your code.
When your program needs to deal with currency, you usually want to use a decimal to store the number.
Windows 7 has a really neat feature in Calculator called “Programmer” mode, where you can see binary and decimal at the same time!
A variable is like a data to-go cup All of  your data takes up space in memory.
They let you set aside enough space in memory to store your data.
Think of  a variable like a cup that you keep your data in.
C# uses a bunch of  different kinds of  cups to hold different kinds of  data.
And just like the different sizes of  cups at the coffee shop, there are different sizes of  variables, too.
Numbers that have decimal places are stored differently than whole numbers.
You can handle most of  your numbers that have decimal places using float, the smallest data type that stores decimals.
If  you need to be more precise, use a double.
And if  you’re writing a financial application where you’ll be storing currency values, you’ll want to use the decimal type.
You wouldn’t expect to get hot coffee in a plastic cup or cold coffee in a paper one.
The C# compiler also can handle characters and non-numeric types.
The char type holds one character, and string is used for lots of  characters “strung” together.
It expands to hold as much data as you need to store in it.
The bool data type is used to store true or false values, like the ones you’ve used for your if statements.
You’ll use long for whole numbers that are going to be really big.
These are the number of bits of memory set aside for the variable when you declare it.
Value types usually keep their data in another part of memory called the stack.
Three of these statements won’t compile, either because they’re trying to cram too much data into a small variable or because they’re putting the wrong type of data in.
When you declare your variable as one type, that’s how your compiler looks at it.
Even if  the value is nowhere near the upper boundary of  the type you’ve declared, the compiler will see the cup it’s in, not the number inside.
But since leaguesUnderTheSea is declared as an int, the compiler sees it as int-sized and considers it too big to put in a short container.
The compiler won’t make those translations for you on the fly.
You need to make sure that you’re using the right type for the data you’re working with.
All the compiler sees is an int going into a short (which doesn’t work)
It doesn’t care about the value in the int cup.
What if you later put a larger value in the int cup, one that wouldn’t fit into the short cup? The compiler is trying to protect you.
Three of these statements won’t compile, either because they’re trying to cram too much data into a small variable or because they’re putting the wrong type of data in.
You can only assign a value of “true” or “false” to a bool.
Even when a number is the r ight size, you can’t just assign it to any variable Let’s see what happens when you try to assign a decimal value to an int variable.
Create a new project and add a button to it.
Check out how the IDE figured out that you were probably missing a cast.
Make the error go away by casting the decimal to an int.
Once you change the second line so it looks like this, your program will compile and run:
So what happened? The compiler won’t let you assign a value to a variable if  it’s the wrong type—even if  that variable can hold the value just fine—because that’s the underlying cause behind an enormous number of  bugs.
When you use casting, you’re essentially making a promise to the compiler that you know the types are different, and that in this particular instance it’s OK for C# to cram the data into the new variable.
Here’s where you cast the decimal value to an int.
When you cast a value that’s too big , C# wil l adjust it automatically You’ve already seen that a decimal can be cast to an int.
It turns out that any number can be cast to any other number.
But that doesn’t mean the value stays intact through the casting.
And once you get back to 255 again, the conversion value “wraps” back to zero.
Hey, I’ve been combining numbers and strings in my message boxes since I learned about loops in Chapter 2! Have I been converting types all along?
What you’ve been doing is using the + operator, which does a lot of  converting for you automatically—but it’s especially smart about it.
When you use + to add a number or Boolean to a string, then it’ll automatically convert that value to a string, too.
If  you use + (or *, /, or -) with two different types, it automatically converts the smaller type to the bigger one.
Since an int can fit into a float but a float can’t fit into an int, the + operator converts myInt to a float before adding it to myFloat.
When you’re assigning a number value to a double, you need to add a D to the end of the number to tell the compiler that it’s a float, and not a double.
You can’t always cast any type to any other type.
That’ll help you figure out which types can be cast , and which can’t!
Wrap it yourself! There’s no mystery to how casting “wraps” the numbers—you can do it yourself.
When you use + it’s smart enough to convert the decimal to a string.
The - operator subtracted the short from the long, and the = operator converted the result to a double.
C# does some cast ing automatically There are two important conversions that don’t require you to do the casting.
The first is done automatically any time you use arithmetic operators, like in this example:
The other way C# converts types for you automatically is when you use the + operator to concatenate strings (which just means sticking one string on the end of  another, like you’ve been doing with message boxes)
When you use + to concatenate a string with something that’s another type, it automatically converts the numbers to strings for you.
The first two lines are fine, but the third one won’t compile.
But you can convert it to a string really easily by calling its ToString() method.
That method is a member of  every value type and object.
All of  the classes you build yourself  have a ToString() method that returns the class name.
You can’t always cast any type to any other type.
Create a new project, drag a button onto a form, and type these statements into its method.
That’ll help you figure out which types can be cast , and which can’t!
All methods will do that, even the ones you write yourself.
Go ahead and try typing this completely valid method into a class:
When the compiler gives you an “invalid arguments” error, it means that you tried to call a method with variables whose types didn’t match the method’s parameters.
It works just fine if  you pass it what it expects (a bool)—call MyMethod(true) or MyMethod(false), and it compiles just fine.
Did you notice how we wrote our if statement l ike this:
You can assign anything to a variable, parameter, or field with the type object.
A method with an int parameter can take a byte argument.
You can do that with non-reserved names too, if you want to.
Put the variables in the class definition at the top of  Form1
You need two whole number variables to track the starting odometer reading and the ending odometer reading.
Make them doubles and call them milesTraveled, reimburseRate, and amountOwed.
When you’re done with the form, double-click on the button to add some code to the project.
Make sure that the number in the Starting Mileage field is smaller than the number in the Ending Mileage field.
If  not, show a message box that says “The starting mileage must be less than the ending mileage”
Subtract the starting number from the ending number and then multiply it by the reimburse rate using these lines:
Try changing the starting value to be higher than the ending value and make sure it’s giving you the message box.
Did you remember that you have to change the decimal value from the numericUpDown control to an int?
This number could go all the way up to 999,999
This block is supposed to figure out how many miles were traveled and then multiply them by the reimbursement rate.
This button seems to work, but it has a pretty big problem.
We gave it two parameters: the first one is the message to display, and the second one goes in the title bar.
Let’s track down that problem by adding a button to your form that shows the value of  the milesTraveled field.
All we need to do is get the form to display the milesTraveled variable, right? So this line should do that:
When you’re done with the form, double-click on the Display Miles button to add some code to the project.
First enter a starting mileage and ending mileage, and click the Calculate button.
Then click the Display Miles button to see what’s stored in the milesTraveled field.
Um, something’s not right… No matter what numbers you use, the number of  miles always matches the amount owed.
Clicking this button after  you’ve clicked Calculate should show the number of miles traveled in a message box.
Take a good look at the operator we used to subtract ending mileage from starting mileage (-=)
The problem is it doesn’t just subtract, it also assigns a value to the variable on the left side of  the subtraction sign.
The same thing happens in the line where we multiply number of  miles traveled by the reimbursement rate.
This one subtracts startingMileage from endingMileage but also assigns the new value to endingMileage and milesTraveled at the same time.
This is better—now your code won’t modify endingMileage and milesTraveled.
Variables named like this are essentially useless in telling you what their purpose might be.
Objects use variables, too So far, we’ve looked at objects separate from other types.
Your code treats objects exactly like it treats numbers, strings, and Booleans.
When you have a class like Dog, you use it as the type in a variable declaration statement.
Objects are just one more type of variable your program can use.
If  your program needs to work with a whole number that’s really big, use a long.
If  it needs a whole number that’s small, use a short.
And if  it needs something that barks and sits, use a Dog.
No matter what type of  data your program needs to work with, it’ll use a variable.
So it doesn’t matter if I’m working with an object or a numeric.
If it’s going into memory, and my program needs to use it, I use a variable.
When you create a new object, you use code like new Guy()
But that’s not enough; even though that code creates a new Guy object on the heap, it doesn’t give you a way to access that object.
So you create a reference variable: a variable of  type Guy with a name, like joe.
So joe is a reference to the new Guy object you created.
Any time you want to use that particular guy, you can reference it with the reference variable called joe.
So when you have a variable that is an object type, it’s a reference variable: a reference to a particular object.
There’s an object, with the variable Joe referring to it.
This variable is named joe, and will reference an object of type Guy.
The ONLY way to reference this Guy object is through the reference variable called joe.
Creating a reference is like making a label with a label maker—instead of sticking it on your stuff, you’re using it to label an object so you can refer to it later.
In your kitchen, you probably have a container of  salt and sugar.
If  you switched their labels, it would make for a pretty disgusting meal—even though the labels changed, the contents of  the containers stayed the same.
You can move labels around and point them at different things, but it’s the object that dictates what methods and data are available, not the reference itself.
For example, you can’t write code like Guy.GiveCash() if  Guy is your object type.
The C# compiler doesn’t know which Guy you’re talking about, since you might have several instances of  Guy on the heap.
So you need a reference variable, like joe, that you assign to a specific instance, like Guy joe = new Guy()
And, as you saw above, you might have multiple labels pointing to the same instance.
So you could say Guy dad = joe, and then call dad.GiveCash()
There are lots of different references to this same Guy, because a lot of different methods use him for different things.
Each reference has a different name that makes sense in its context.
Every one of these labels is a different reference variable, but they all point to the SAME Guy object.
When your code needs to work with an object in memory, it uses a reference, which is a variable whose type is a class of the object it’s going to point to.
A reference is like a label that your code uses to talk about a specific object.
An instance of the Guy class is keeping a reference to this object in a variable called “Dad”
If  all of  the labels come off  of  an object, programs can no longer access that object.
That means C# can mark the object for garbage collection.
That’s when C# gets rid of  any unreferenced objects, and reclaims the memory those objects took up for your program’s use.
For an object to stay in the heap, it has to be referenced.
Some time after the last reference to the object disappears, so does the object.
If there aren’t any more references, your object gets garbage-collected.
When you use the “new” statement, you’re telling C# to create an object.
When you take a reference variable like “Joe” and assign it to that object, it’s like you’re slapping a new label on it.
Let’s take the reference to the first object, and change it to point at the second object.
Now joe is pointing to the same object as bob.
Now we have two Guy object instances, and two reference variables: one for each Guy.
But there is no longer a reference to the first Guy object…
When an object no longer has any references pointing to it, it's removed from the heap using ____________ collection.
What you're doing when you use the + operator to stick two strings together.
The four whole number types that only hold positive numbers.
You can combine the variable declaration and the ____________ into one statement.
Every object has this method that converts it to a string.
When you've got a variable of this type, you can assign any value to it.
Typecross Take a break, sit back, and give your right brain something to do.
It’s your standard crossword; all of the solution words are from this chapter.
When you’re done, turn the page and take on the rest of the chapter.
You’ve got to be careful when you start moving around reference variables.
Lots of  times, it might seem like you’re simply pointing a variable to a different object.
But you could end up removing all references to another object in the process.
That’s not a bad thing, but it may not be what you intended.
But Spot is just another reference to the first object.
Figure out how many objects and references there are at each stage.
On the right-hand side, draw a picture of the objects and labels in the heap.
Figure out how many objects and references there are at each stage.
On the right-hand side, draw a picture of the objects and labels in the heap.
One new Dog object is created but Spot is the only reference to it.
When Spot is set = to Rover, that object goes away.
Here a new Dog object is created, but when Fido is set to Rover, Fido’s object from #1 goes away.
Charlie was set to Fido when Fido was still on object #3
Then, after that, Fido moved to object #1, leaving Charlie behind.
Here the references move around but no new objects are created.
And setting Lucky to Rin Tin Tin did nothing because they already pointed to the same object.
Have a look at the Elephant class diagram—you’ll need an int field called EarSize and a String field called Name.
Then add a method called WhoAmI() that displays a message box that tells you the name and ear size of  the elephant.
Add two Elephant fields to the Form1 class (in the area right below the class declaration) named Lloyd and Lucinda.
Initialize them so they have the right name and ear size.
Here are the Elephant object initializers to add to your form:
Have the Lloyd button call  lloyd.WhoAmI() and the Lucinda button call lucinda.WhoAmI()
Make the Swap button exchange the two references, so that when you click Swap, the Lloyd and  Lucinda variables swap objects and a “Objects swapped” box is displayed.
Test out your program by clicking the Swap button and then clicking the other two buttons.
The first time you click Swap, the Lloyd button should pop up Lucinda’s message box, and the Lucinda button should pop up Lloyd’s message box.
If  you click the Swap button again, everything should go back.
So here’s your hint: If you want to pour a glass of beer into another glass that’s currently full of water, you’ll need a third glass to pour the water into....
Here’s the class diagram for the Elephant class you need to create.
Make sure the message includes the ear size and the title bar includes the name.
Why do you think we didn’t add a Swap() method to the Elephant class?
There’s no new statement for the reference because we don’t want to create another instance of Elephant.
If you just point Lloyd to Lucinda, there won’t be any more references pointing to Lloyd and his object will be lost.
That’s why you need to have the Holder reference hold onto the Lloyd object until Lucinda can get there.
This is the Elephant class definition code in the Elephant.cs file we added to the project.
Two references means TWO ways to change an object’s data Besides losing all the references to an object, when you have multiple references to an object, you can unintentionally change an object.
In other words, one reference to an object may change that object, while another reference to that object has no idea that something has changed.
Can you guess what’s going to happen when you click it?2
After this code runs, both the lloyd and lucinda variables reference the SAME Elephant object.
But lloyd points at the same thing that lucinda does.
This statement says to set EarSize to 4321 on whatever object the lloyd reference happens to point to.
Note that the data is NOT being overwritten—the only things changing are the references.
Notice that the array is an object, even though the 7 elements are just value types—like the ones on the first two pages of this chapter.
If  you have to keep track of  a lot of  data of  the same type, like a list of  heights or a group of  dogs, you can do it in an array.
What makes an array special is that it’s a group of  variables that’s treated as one object.
An array gives you a way of  storing and changing more than one piece of  data without having to keep track of  each variable individually.
When you create an array, you declare it just like any other variable, with a name and a type:
You declare an array by specifying its type, followed by square brackets.
Use each e lement in an array like i t is a normal variable When you use an array, first you need to declare a reference variable that points to the array.
Then you need to create the array object using the new statement, specifying how big you want the array to be.
Here’s an example of  code that declares and fills up an array—and what’s happening on the heap when you do it.
The first element in the array has an index of  zero.
You use the new keyword to create an array because it’s an object.
So an array variable is a kind of reference variable.
You reference these by index, but each one works essentially like a normal int variable.
You can create an array of  object references just like you create an array of  numbers or strings.
Arrays don’t care what type of  variable they store; it’s up to you.
So you can have an array of  ints, or an array of  Duck objects, with no problem.
Here’s code that creates an array of  7 Dog variables.
The line that initializes the array only creates reference variables.
Since there are only two new Dog() lines, only two actual instances of  the Dog class are created.
This line declares a dogs variable to hold an array of references to Dog objects, and then creates a 7-element array.
When you set or retrieve an element from an array, the number inside the brackets is called the index.
The first element in the array has an index of zero.
The first line of code only created the array, not the instances.
The array is a list of seven Dog reference variables.
Welcome to Sloppy Joe’s Budget House o’ Discount Sandwiches! Sloppy Joe has a pile of  meat, a whole lotta bread, and more condiments than you can shake a stick at.
But what he doesn’t have is a menu! Can you build a program that makes a new random menu for him every day?
Start a new project and add a MenuMaker class If  you need to build a menu, you need ingredients.
We’ll also need some way of  choosing random ingredients to combine together into a sandwich.
Luckily, the .NET Framework has a built-in class called Random that generates random numbers.
So we’ll have four fields in our class: a Randomizer field that holds a reference to a Random object, and three arrays of  strings to hold the meats, condiments, and breads.
Add a GetMenuItem() method to the class that generates a random sandwich The point of  the class is to generate sandwiches, so let’s add a method to do exactly that.
It’ll use the Random object’s Next() method to choose a random meat, condiment, and bread from each array.
When you pass an int parameter to Next(), the method returns a random that’s less than that parameter.
So how do you know what parameter to pass into the Next() method? Well, that’s easy—just pass in each array’s Length.
That will return the index of  a random item in the array.
The method puts a random item from the Meats array into randomMeat by passing Meats.Length to the Random object’s Next() method.
The field called Randomizer holds a reference to a Random object.
The class has three fields to store three different arrays of strings.
The GetMenuItem() method returns a string that contains a sandwich built from random elements in the three arrays.
Remember, use square brackets to access a member of an array.The value of Breads[2] is “wheat”
I eat all my meals at Sloppy Joe’s!How it works…
Then add code to set each label’s Text property using a MenuMaker object.
You’ll need to initialize the object using a new instance of  the Random class.
Use an object initializer to set the MenuMaker object’s Randomizer field to a new instance of the Random class.
Now you’re all set to generate six different random sandwiches using the GetMenuItem() method.
When you run the program, the six labels show six different random sandwiches.
What would happen if you forgot to initialize the MenuMaker object’s Randomizer field? Can you think of a way to keep this from happening?
Objects use references to talk to each other So far, you’ve seen forms talk to objects by using reference variables to call their methods and check their fields.
In fact, there’s nothing that a form can do that your objects can’t do, because your form is just another object.
And when objects talk to each other, one useful keyword that they have is this.
Any time an object uses the this keyword, it’s referring to itself—it’s a reference that points to the object that calls it.
Here’s a method to tell an elephant to speak Let’s add a method to the Elephant class.
You can add to button4_Click(), but add it before the statement that resets the references! (lloyd = lucinda;)
We called Lloyd’s TellMe() method, and passed it two parameters: “Hi” and a reference to Lucinda’s object.
The method uses its whoSaidIt parameter to access the Name parameter of  whatever elephant was passed into TellMe() using its second parameter.
Lloyd uses whoToTalkTo (which has a reference to Lucinda) to call TellMe()
This method in the Elephant class calls another elephant’s TalkTo() method.
Here’s a method that calls another method Now let’s add this SpeakTo() method to the Elephant class.
That’s a reference that lets an object talk about itself.
When Lloyd’s SpeakTo() method is called, it uses its talkTo parameter (which has a reference to Lucinda) to call Lucinda’s TellMe() method.
So Lucinda acts as if  she was called with (“Hello”, lloyd), and shows this message:
Q: You keep talking about garbage collecting, but what’s actually doing the collecting?
Where no object has gone before There’s another important keyword that you’ll use with objects.
When you create a new reference and don’t set it to anything, it has a value.
It starts off  set to null, which means it’s not pointing to anything.
Now that fido’s pointing to an object, it’s no longer equal to null.
When we set lucky to null, it’s no longer pointing at its object, so it gets garbagecollected.
Q: I’m still not sure I get how references work.
Q: Wait, then doesn’t that mean that every time I change a value through a reference I’m changing it for all of the other references to that object, too?
Any time you’ve got code in an object that’s going to be instantiated, the instance can use the special this variable that has a reference to itself.
Here’s an array of Elephant objects and a loop that will go through it and find the one with the biggest ears.
What’s the value of the biggestEars.Ears after each iteration of the for loop?
Be careful—this loop starts with the second element of the array (at index 1) and iterates six times until i is equal to the length of the array.
This line makes the biggestEars reference point at whatever elephant elephants[i] points to.
Code Magnets The code for a button is all scrambled up on the fridge.
Can you reconstruct the code snippets to make a working method that produces the output listed below?
Note: Each snippet from the pool can be used more than once.
Bonus Question! For extra bonus points, use snippets from the pool to fill in the two blanks missing from the output.
Flip back to Chapter 3 for a refresher on what the static keyword means.
You may use the same snippet more than once, and you won’t need to use all the snippets.
Build a typing game You’ve reached a milestone…you know enough to build a game! Here’s how your game will work.
If  the player types one of  them, it disappears and the accuracy rate goes up.
If  the player types an incorrect letter, the accuracy rate goes down.
As the player keeps typing letters, the game goes faster and faster, getting more difficult with each correct letter.
If  the form fills up with letters, the game is over! Do this.
Here’s what the form will look like in the form designer:
That way, the player won’t be able to accidentally drag and resize it.
Drag a ListBox out of  the Toolbox onto the form.
In the Toolbox, expand the “All Windows Forms” group at the top.
Find the Timer control and double-click on it to add it to your form.
Find the StatusStrip in the “All Windows Forms” group in the Toolbox and doubleclick on it to add a status bar to your form.
You should now see the StatusStrip and Timer icons in the gray area at the bottom of  the form designer:
See how you can use a Timer to make your form do more than one thing at once? Take a minute and flip to #3 in the “Leftovers” appendix to learn about another way to do that.
You’ll be using three new controls, but they’re easy to work with!
Even though you haven’t seen a ListBox, StatusStrip, or Timer before, you already know how to set their properties and work with them in your code.
You’ll learn a lot more about them in the next few chapters.
Did you notice how your Timer control didn’t show up on your form? That’s because the Timer is a non-visual control.
It doesn’t actually change the look and feel of  the form.
It does exactly one thing: it calls a method over and over again.
The IDE will do what it always does when you double-click on a control: it will add a method to your form.
Take a closer look at the status bar at the bottom of  the screenshot.
And on the other side, it’s got a label and a progress bar:
Add a StatusLabel to your StatusStrip by clicking its drop-down and selecting StatusLabel:
Use the Properties window to set its (Name) to correctLabel and its Text to “Correct: 0”
You’ll add a field called “random” in just a minute.
Add a class to keep track of the player stats.
If  the form is going to display the total number of  keys the player pressed, the number that were missed and the number that were correct, and the player’s accuracy, then we’ll need a way to keep track of  all that data.
Sounds like a job for a new class! Add a class called Stats to your project.
It’ll have four int fields called Total, Missed, Correct, and Accuracy, and a method called Update with one bool parameter: true if  the player typed a correct letter that was in the ListBox, or false if  the player missed one.
Every time the Update() method is called, it recalculates the % correct and puts it in the Accuracy field.
Add fields to your form to hold a Stats object and a Random object.
You’ll need an instance of  your new Stats class to actually store the information, so add a field called stats to store it.
And you already saw that you’ll need a field called random—it’ll contain a Random object.
Add the two fields to the top of  your form:
There’s one last thing your game needs to do: any time the player hits a key, it needs to check if  that key is correct (and remove the letter from the ListBox if  it is), and update the stats on the StatusStrip.
Your game’s done! Give it a shot and see how well you do.
This is the part that increases the difficulty as the player gets more keys right.
You can make the game easier by reducing the amounts that are subtracted from timer1.Interval, or make it harder by increasing them.
This if statement checks the ListBox to see if it contains the key the player pressed.
If it does, then the key gets removed from the ListBox and the game difficulty is increased.
When the player presses a key, the Form1_KeyDown() method calls the Stats object’s Update() method to update the player stats, and then it displays them in the StatusStrip.
Go back to the form designer and select the form.
Then go to the Properties window and click on the lightning bolt button.
This tells the IDE to add a method called Form1_KeyDown() that gets called every time the user presses a key.
The button to the left of it switches the Properties window back to showing you properties.
These are called events, and you’ll learn a lot more about them later on.
Namespaces make sure that the names you are using in your program don’t collide with the ones in the .NET Framework or other external classes you’ve used in your program.
All of the classes and methods in a program are inside a namespace.
This lets you do a loop that executes three statements.
First it declares the variable it’s going to use, then there’s the statement that evaluates the variable against a condition.
Properties are what they know and methods are what they do.
A public class can be used by every other class in the project.
When a variable or method is declared as public, it can be used by classes and called by methods that are outside of the one it’s being declared in.
Code that starts with else will get executed if the if statement preceding it fails.
You use this to create a new instance of an object.
This is a way of listing off all of the namespaces you are using in your program.
One way of setting up a conditional statement in a program.
It says if one thing is true, do one thing and if not do something else.
When an object no longer has any references pointing to it, it's removed from the heap using ____________ collection.
What you're doing when you use the + operator to stick two strings together.
The four whole number types that only hold positive numbers [unsigned]
You can combine the variable declaration and the ____________ into one statement.
Every object has this method that converts it to a string.
When you've got a variable of this type, you can assign any value to it [object]
The biggestEars reference is used to keep track of which element we’ve seen while going through the for loop has the biggest ears so far.
The for loop starts with the second elephant and compares it to whatever elephant biggestEars points to.
If its ears are bigger, it points biggestEars at that elephant instead.
Then it moves to the next one, then the next one…by the end of the loop biggestEars points to the one with the biggest ears.
Here’s an array of Elephant objects and a loop that will go through it and find the one with the biggest ears.
What’s the value of the biggestEars.Ears after each iteration of the for loop?
Code Magnets Solution The code for a button is all scrambled up on the fridge.
Can you reconstruct the code snippets to make a working method that produces the output listed below?
The result string is built up using the += operator to concatenate lines onto it.
This while loop pulls a value from the index[] array and uses it for the index in the islands[] array.
After this line, we’ve got an array of four Triangle references—but there aren’t any Triangle objects yet!
Notice how this class contains the entry point, but it also creates an instance of itself? That’s completely legal in C#
The setArea() method uses the height and length fields to set the area field.
Since it’s not a static method, it can only be called from inside an instance of Triangle.
The while loop creates the four instances of Triangle by calling the new statement four times.
This lab gives you a spec that describes a program for you to build, using the knowledge you’ve gained over the last few chapters.
This project is bigger than the ones you’ve seen so far.
So read the whole thing before you get started, and give yourself a little time.
And don’t worry if you get stuck—there’s nothing new in here, so you can move on in the book and come back to the lab later.
We’ve filled in a few design details for you, and we’ve made sure you’ve got all the pieces you need…and nothing else.
You can download an executable for this lab from the website…but we won’t give you the code for the answer.
The spec: build a racetrack simulator Joe, Bob, and Al love going to the track, but they’re tired of  losing all their money.
They need you to build a simulator for them so they can figure out winners before they lay their money down.
And, if  you do a good job, they’ll cut you in on their profits.
The Guys Joe, Bob, and Al want to bet on a dog race.
Before each race, they’ll each decide if  they want to bet, and how much they want to put down.
The guys can change their bets right up to the start of  the race…but once the race starts, all bets are final.
The Bett ing Parlor The betting parlor keeps track of  how much cash each guy has, and what bet he’s placed.
The parlor only takes one bet per person for any one race.
The parlor checks to make sure that the guy who’s betting has enough cash to cover his bet—so the guys can’t place a bet if  they don’t have the cash to cover the bet.
If  the dog wins, the bettor ends up with twice the amount that he bet (after the race is complete)
The Race There are four dogs that run on a straight track.
The winner of  the race is the first dog to cross the finish line.
The race is totally random, there are no handicaps or odds, and a dog isn’t more likely to win his next race based on his past performance.
If you want to build a handicap system, by all means do it! It’ll be really good practice writing some fun code.
Say a guy places a $10 bet at the window.
You’ll build three main classes in the project, as well as a GUI for the simulator.
You should have an array of  three Guy objects to keep track of  the three guys and their winnings, and an array of  four Greyhound objects that actually run the race.
Also, each instance of  Guy should have its own Bet object that keeps track of  his bet and pays out (or takes back) cash at the end of  the race.
We’ve gotten you started with class descriptions and some snippets of code to work from.
Your object can control things on your form… The Greyhound class keeps track of  its position on the racetrack during the race.
It also updates the location of  the PictureBox representing the dog moving down the race track.
Each instance of  Greyhound uses a field called MyPictureBox to reference the PictureBox control on the form that shows the picture of  the dog.
Suppose the distance variable contains the distance to move the dog forward.
Then this code will update the location of  MyPictureBox by adding distance to its X value:
We’ve given you the skeleton of the class you need to build.
See how the class diagram matches up with the code?
We’ve added comments to give you an idea of what to do.
You’ll have to make sure the form passes the right picture box into each Greyhound’s object initializer.
You only need one instance of Random—each Greyhound’s Randomizer reference should point to the same Random object.
Just make sure you pass a reference to the right PictureBox on the form to each Greyhound object.
The last two fields are the guy’s GUI controls on the form.
Guy willl use the this keyword to pass a reference to himself to the Bet’s initializer.
The key here is to use the Bet object…let it do the work.
This is the object that Guy uses to represent bets in the application.
When you initialize the Guy object, make sure you set its MyBet field to null, and call its UpdateLabels() method as soon as it’s initialized.
The object initializer for Bet just sets the amount, dog, and bettor.
Once you set MyLabel to one of the labels on the form, you’ll be able to change the label’s text using MyLabel.Text.
Among the visual objects will be four PictureBox controls for the pictures of the dogs.
You’ll pass references to them to the object initializers of the four Greyhound objects.
It’ll also have three RadioButton controls and three labels, which you’ll pass to the object initializers of the three Guy objects.
Each of those objects has a field called bet, which is a reference to a Bet object.
The form needs to initialize both of these arrays when it starts up.
It looks pretty complicated at first, but there’s nothing here you don’t know.
Your job is to recreate this architecture yourself, starting with the Greyhound and Guy arrays in your main form.
When a Guy places a bet, he creates a new Bet object.
The form te l ls the dogs to keep running unt il there’s a winner.
The Bet object f igures out if i t should pay out.
When the user tells the form to start the race, the form starts a loop to animate each dog running along the track.
Each dog’s Run() method checks to see if that dog won the race, so the loops should end immediately as soon as one of the dog wins.
So if the dog won, it should return Amount; otherwise, it’ll return -Amount.
The betting parlor in the form tells each Guy which dog won so he can collect any winnings from his bet.
Here’s what your GUI should look like The graphical user interface for the “Day at the Races” application consists of  a form that’s divided into two sections.
The top is the racetrack: a PictureBox control for the track, and four more for the dogs.
The bottom half  of  the form shows the betting parlor, where three guys (Joe, Bob, and Al) can bet on the outcome of  the race.
All three guys can bet on the race, but there’s only one betting window so only one guy can place a bet at a time.These radio buttons are used to select which guy places the bet.
When a Guy places a bet, it overwrites any previous bet he placed.
Once all bets are placed, click this button to start the race.
Each of the four dogs has its o wn PictureBox control.
MyPicturebox field will have a r eference to one of these object.
You’ll use the Length property of the racetrack PictureBox control to set the racetrack length in the Greyhound object, which it’ll use to figure out if it won the race.
The form should update this label with the minimum bet using the Minimum property of the NumericUpDown control for the bet amount.
Make sure you set each PictureBox’s SizeMode property to Zoom.
Placing bets Use the controls in the Betting Parlor group box to place each guy’s bet.
No bets have been placed yet When the program first starts up, or if  a race has just finished, no bets have been placed in the betting parlor.
You’ll see each guy’s total cash next to his name on the left.
Each guy places his bets To place a bet, select the guy’s radio button, select an amount and a dog, and click the Bets button.
His PlaceBet() method will update the label and radio button.
The minimum bet should be the same as the minimum value in the bet control.
When a guy places a bet, his Guy object updates this label using the MyLabel reference.
He also updates the cash he has using his MyRadioButton reference.
Once the race is complete and there’s a winner, each Guy object calls his Collect() method and adds his winnings or losses to his cash.
Once Bob places his bet, his Guy object updates this label and the radio button text.
Make sure all the Greyhound objects share one Random object! If each dog creates its own new instance of Random, you might see a bug where all of the dogs generate the same sequence of random numbers.
The Finished Product You’ll know your “Day at the Races” application is done when your guys can place their bets and watch the dogs race.
During the race, the four dog images run across the racetrack until one of them wins the race.
During the race, no bets can be placed…and make sure you can’t start a new race while the dogs are running!
But you won’t find the source code! In real life, you don’t get a solution to your programming problems.
Here’s your chance to really test your C# knowledge and see just how much you’ve learned!
She’s been planning dinner parties for her clients and she’s doing really well.
But lately she’s been having a hard time responding to clients fast enough with an estimate for her services.
When a new client calls Kathleen to do a party, she needs to find out the number of  guests, what kind of  drinks to serve, and what decorations she should buy.
Then she uses a pretty complicated calculation to figure out the total cost, based on a flow chart she’s been using for years.
The bad news is that it takes her a long time to work through her chart, and while she’s estimating, her potential clients are checking out other event planners.
It’s up to you to build her a C#-driven event estimator and save her business.
Kathleen would rather spend her time planning events, not planning estimates.
What does the est imator do? Kathleen runs down some of  the basics of  her system for figuring out the costs of  an event.
For each person on the guest list there’s a $25 food cha rge.
But they can also choose to have a p arty without alcohol.
Kathleen calls that the “Healthy Option,” and it only costs $
Choosing the Healthy Op tion is a lot easier for.
Here’s another look at this same set of  costs, broken down into a little flow chart to help you see how it works:
Some of these choices involve a change to the final price of the event, as well as individual per-person costs.
While most choices affect the cost for each guest, there are also one-time fees to figure in.
Create a new Windows Application project and add a class file to it called DinnerParty.cs, and build the DinnerParty class using the class diagram to the left.
For the fields, use decimal for the two costs, int for the number of  people, and bool to keep track of  whether or not the Healthy Option was selected.
Make sure you add an M after every literal you assign to a decimal value (10.0M)
Flip back to the previous page to be sure you’ve got all of  the logic right for the methods.
Only one of  them returns a value (a decimal)—the other two are void.
Use the CalculateCost() method to figure out the total cost by adding the cost of  the decorations to the cost of  drinks and food per person.
The Text Property is empty, the BorderStyle property set to Fixed3D, and the AutoSize property set to false.
Since the cost of  food won’t be changed by the program, you can declare it as a constant, which is like a variable except that its value can never be changed.
Instead of  using a button to calculate the costs, this form will update the cost label automatically as soon as you use a checkbox or the NumericUpDown control.
The first thing you need to do is create a method in the form that displays the cost.
Now hook up the NumericUpDown field to the NumberOfPeople variable you created in the DinnerParty class and display the cost in the form.
Double-click on the NumericUpDown control—the IDE will add an event handler to your code.
That’s a method that gets run every time the control is changed.
Can you spot it? Don’t worry if  you don’t see it just yet.
We’ll dig into it in just a couple of  minutes!
This method will get called by all of the other methods you create on the form.
It’s how you update the cost label with the right value whenever anything changes.
The first line will call the method you created in the class to figure out the costs, and the second will display the total cost on the form.
The value you send from the form to the method will be fancyBox.Checked.
That will be passed as a boolean parameter to the method in the class.
Add this method to the form—it’ll recalculate the cost of the party and put it in the Cost label.
Change the name of the label that displays the cost to costLabel.
This is true if the checkbox for the Healthy Option is checked.
You’ve been using event handlers all along—when you double-click on a button, the IDE adds a Click event handler.
Passing “c” to ToString() tells it to format the cost as a currency value.
If you’re in a country that uses dollars, it’ll add a dollar sign.
This applies the 5% discount to the overall event cost if the non-alcoholic option was chosen.
It also makes the code easier to read—it’s clear that this value never changes.
When the form first creates the object, it uses the initializer to set NumberOfPeople.
We used “if (Fancy)” instead of typing “if (Fancy == true)” because the if statement always checks if the condition is true.
We used parentheses to make sure the math works out properly.
We had you use a decimal for the prices because it’s designed for monetary values.
You can remember this because the M stands for Money!
We named our checkboxes “healthyBox” and “fancyBox” so you could see what’s going on in their event handler methods.
The new dinner party cost needs to be recalculated and displayed any time the number changes or the checkboxes are checked.
String formatting You’ve already seen how you can convert any variable to a string using its ToString() method.
If you pass “c” to ToString(), it converts it to the local currency.
Take a minute and see how each of these looks in your program!
We were out looking at decorations this morning and I think you’ll love the way the party’s going to look.
Listen, we just got a call from my wife’s aunt.
She and her husband are going to be visiting for the next couple of  weeks.
Kathleen: Sure! I’ll have that for you in just one minute.
Rob: Only $90 difference? That sounds like a great deal! What if  we decide to cut the fancy decorations? What’s the cost then?
When you start the program, the Fancy Decorations box should already be checked because you set its Checked property to true.
Did you change your pricing or something? If  it’s only $5 difference, we might as well go with the fancy decorations.
Kathleen: We just had this new program written to do the estimation for us.
Just one second while I add the fancy decorations back to the bill.
It looks like the cost with the fancy decorations just shot up to $770
I’m going to send it back for some bug fixes and work up your estimate by hand.
Rob: I am not paying $770 just to add two people to the party.
The price you quoted me before was a lot more reasonable.
I’ll pay you the $665 you quoted me in the first place, but I just can’t go higher than that!
When you turn the Fancy Decorations back on, the number shoots up to $770
Turning off the Fancy Decorations checkbox only reduces the amount by $5
Why do you think the numbers are coming out wrong every time Kathleen makes a change?
Each option should be calculated individually Even though we made sure to calculate all of  the amounts according to what Kathleen said, we didn’t think about what would happen when people made changes to just one of  the options on the form.
When you launch the program, the form sets the number of  people to 5 and Fancy Decorations to true.
It leaves Healthy Option unchecked and it calculates the cost of  the dinner party as $350
Here’s how it comes up with the initial total cost:
When you change the number of  guests, the application should recalculate the total estimate the same way.
The program is adding the old cost of decorations up with the new cost of food and drink.
But we’re not getting it! New food and drink cost.
We built a nasty little bug into the code we gave you to show you just how easy it is to have problems with how objects use one another’s fields…and just how hard those problems are to spot.
Uncheck the Fancy Decorations checkbox and then check it again.
Take a look at the method that handles changes to the value in the numericUpDown control.
Then it counts on that method to handle recalculating all the individual new costs.
So, when you make a change to the value in the NumberofPeople field, this method never gets called:
This line sets the value of NumberofPeople in this instance of DinnerParty to the value in the form.
People won’t always use your classes in exactly the way you expect.
Luckily, C# gives you a powerful tool to make sure your program always works correctly—even when people do things you never thought of.
It’s called encapsulation and it’s a really helpful technique for working with objects.
Hold on! I assumed Kathleen would always set all three options at once!
This variable is set to $125 from when the form first called it, and since this method doesn’t get called again, it doesn’t change.
That’s why the number corrects itself when you turn fancy decorations back on.
Clicking the checkbox makes the program run CalculateCostOf Decorations() again.
So even though your DinnerParty class worked just fine, the form called it in an unexpected way… and that caused problems.
How the DinnerParty class expected to be called The DinnerParty class gave the form a perfectly good method to calculate the total cost of  decorations.
Even though the form didn’t set up the party properly, CalculateCost() still returned a number…and there was no way for Kathleen to know that the number was wrong.
How the DinnerParty class was actually called The form set the number of  people, but just called the CalculateCost() method without first recalculating the cost of  the decorations.
That threw off the whole calculation, and Kathleen ended up giving Rob the wrong price.
Encapsulat ion means keeping some of the data in a class pri vate There’s an easy way to avoid this kind of  problem: make sure that there’s only one way to use your class.
Luckily, C# makes it easy to do that by letting you declare some of  your fields as private.
If  you’ve got an object with a public field, any other object can read or change that field.
But if  you make it a private field, then that field can only be accessed from inside that object (or by another object of  the same class)
The divers were fully encapsulated by their submersible, and could only enter and exit through the airlock.
If you want to make a field private, all you need to do is use the private keyword when you declare it.
That tells C# that if you’ve got an instance of DinnerParty, its numberOfPeople field can only be read and written by that instance—or another instance of DinnerParty.
Other objects still need a way to se t the.
By making the field that holds the number of party guests private, we only give the form one way to tell the DinnerParty class how many people are at the party—and we can make sure the cost of decorations is recalculated properly.
When you make some data private and then write code to use that data, it’s called encapsulation.
Use your laziness to your own benefit—if you leave off the “private” or “public”, then C# will just assume that your field is private.
Also, a class’s static methods can access the private field in any instance of that class.
Use encapsulat ion to control access to your class’s methods and f ie lds When you make all of  your fields and methods public, any other class can access them.
Everything your class does and knows about becomes an open book for every other class in your program…and you just saw how that can cause your program to behave in ways you never expected.
Encapsulation lets you control what you share and what you keep private inside your class.
Super-spy Herb Jones is defending life, liberty, and the pursuit of happiness as an undercover agent in the USSR.
His ciaAgent object is an instance of  the SecretAgent class.
Agent Jones has a plan to help him evade the enemy KGB agents.
He added an AgentGreeting() method that takes a password as its parameter.
If  he doesn’t get the right password, he’ll only reveal his alias, Dash Martin.
Seems like a foolproof  way to protect the agent’s identity, right? As long as the agent object that calls it doesn’t have the right password, the agent’s name is safe.
The KGB only gets the alias of the CIA agent.
Agent Jones can use private fields to keep his identity secret from enemy spy objects.
Once he declares the realName field as private, the only way to get to it is by calling methods that have access to the private parts of  the class.
Keeping your fields and methods private makes sure no outside code is going to make changes to the values you’re using when you don’t expect it.
You’d also want to make sure th at the field.
Why go through all of the trouble to guess his password? I can just get his name directly!
But is the realName f ie ld REALLY protected? So as long as the KGB doesn’t know any CIA agent passwords, the CIA’s real names are safe.
Right? But what about the field declaration for the realName field:
Setting your variables as public means they can be accessed, and even changed, from outside the class.
Just replace public with private, and boom, your fields are now hidden from the world.
The kgbAgent object can’t access the ciaAgent’s private fields because they’re instances of different classes.
Q: OK, so I need to access private data through public methods.
What happens if the class with the private field doesn’t give me a way to get at that data, but my object needs to use it?
Q: Why would I ever want to keep a field with no way for another class to access?
Q: Hey, I just noticed that all of the event handlers I’ve been using have the private keyword.
Private f ie lds and methods can only be accessed from inside the class There’s only one way that an object can get at the data stored inside another object’s private fields: by using the public fields and methods that return the data.
But while KGB and MI5 agents need to use the AgentGreeting() method, friendly spies can see everything—any class can see private fields in other instances of  the same class.
Now that the fields are private, this is pretty much the only way the mi5Agent can get the ciaAgent’s real name.
The only way that one object can get to data stored in a private field inside another object is by using public methods that return the data.
Circle the statements below that won’t compile if they’re run from outside the class using an instance of the object called mySuperChef.
After running all of the lines that will compile above, what’s the value of recipe?
After running all of the lines that will compile above, what’s the value of recipe?
The only way to get the secret ingredient is to order a whole lot of cookies.
Circle the statements below that won’t compile if they’re run from outside the class using an instance of the object called mySuperChef.
Because sometimes you want your class to hide information from the rest of the program.
A lot of  people find encapsulation a little odd the first time.
If I make a field private, all that does is keep my program from compiling another class that tries to use it.
But if I just change the “private” to “public” my program builds again! Adding “private” just broke my program.
Easy to maintain Remember that bug in Kathleen’s program? It happened because the form accessed a field directly rather than using a method to set it.
If  that field had been private, you would have avoided that bug.
Flexible A lot of  times, you’ll want to go back and add features to a program you wrote a while ago.
If  your classes are well encapsulated, then you’ll know exactly how to use them later on.
How could building a poorly encapsulated class now make your programs harder to modify later?
Remember Mike’s street navigation program from Chapter 3? Mike joined a geocaching group, and he thinks his navigator will give him an edge.
But it’s been a while since he’s worked on it, and now he’s run into a little trouble.
Mike’s navigator program has a Route class that stores a single route between two points.
But he’s running into all sorts of  bugs because he can’t seem to figure out how it’s supposed to be used! Here’s what happened when Mike tried to go back to his navigator and modify the code:
Mike set the StartPoint property to the GPS coordinates of  his home and the EndPoint property to the coordinates of  his office, and checked the Length property.
He uses the SetStartPoint() property to set the start point to the coordinates of  his home and the SetEndPoint() property to set the end point to his office.
When he tried using the SetStartPoint() method to set the starting point and the EndPoint property to set the ending point, the Length property contained 0, and the GetRouteLength() method caused the program to crash with an error that said something about not being able to divide by zero.
I was supposed to set the StartPoint field or use the.
Mike’s navigator program could use bet ter encapsulat ion Geocaching is a sport where people use their GPS navigators to hide and seek containers that can be hidden anywhere in the world.
Mike is really into GPS stuff, so you can see why he likes it so much.
Which properties or methods would you make private in order to make it easier to use?
There are lots of ways to solve this problem, all potentially correct! Write down the one you think is best.
Sometimes you’ll hear a programmer refer to an object as a “black box,” and that’s a pretty good way of  thinking about them.
When you call an object’s methods, you don’t really care how that method works—at least, not right now.
All you care about is that it takes the inputs you gave it and does the right thing.
Right now, Mike just wants to think about his Route object as a black box.
He wants to feed his coordinates into it and get a length out of it.
He doesn’t want to think about how the Route calculates that length…at least, not right now.
I know my Route object works! What matters to me now is figuring out how to use it for my geocaching project.
Back in Chapter 3, Mike was thinking about how to build his navigator.
That’s when he really cared about how the Route object worked.
Since then, he got his navigator working, and he’s been using it for a long time.
He knows it works well enough to be really useful for his geocaching team.
If you encapsulate your classes well today, that makes them a lot easier to reuse tomorrow.
If only Mike had thought about encapsulation when he originally built his Route object! If he had, then it wouldn’t be giving him a headache today!
When you come back to code that you haven’t looked at in a long time, it’s easy to forget how you intended it to be used.
That’s where encapsulation can make your life a lot easier!
And just like chess, there are an almost unlimited number of possible encapsulation strategies!
So a well-encapsulated class does exactly the same thing as one that has poor encapsulation!
Exactly! The difference is that the wellencapsulated one is built in a way that prevents bugs and is easier to use.
It’s easy to take a well-encapsulated class and turn it into a poorly encapsulated class: do a search-and-replace to change every occurrence of  private to public.
That’s one reason that encapsulation is difficult for some programmers to understand.
Until now, everything you’ve learned has been about making programs do things—perform certain behaviors.
It’s more about the “chess game” side of  programming: by hiding certain information in your classes when you design and build them, you set up a strategy for how they’ll interact later.
The better the strategy, the more flexible and maintainable your programs will be, and the more bugs you’ll avoid.
Is everything in your class public? If your class has nothing but public fields and methods, you probably need to spend a little more time thinking about encapsulation.
What fields require some processing or calculation to happen when they’re set? Those are prime candidates for encapsulation.
If someone writes a method later that changes the value in any one of them, it could cause problems for the work your program is trying to do.
Only make fields and methods public if you need to.
If you don’t have a reason to declare something public, don’t.
You could make things really messy for yourself by making all of the fields in your program public—but don’t just go making everything private, either.
Spending a little time up front thinking about which fields really need to be public and which don’t can save you a lot of time later.
The cost of decorations needs to be figured out first.
Encapsulat ion keeps your data prist ine Sometimes the value in a field changes as your program does what it’s supposed to do.
If  you don’t explicitly tell your program to reset the value, you can do your calculations using the old one.
When this is the case, you want to have your program execute some statements any time a field is changed—like having Kathleen’s program recalculate the cost every time you change the number of  people.
We can avoid the problem by encapsulating the data using private fields.
We’ll provide a method to get the value of  the field, and another method to set the field and do all the necessary calculations.
When you create a form to let a user enter the number of  cows into a numeric field, you need to be able to change the value in the numberOfCows field.
To do that, you can create a method that returns the value of  the field to the form object:
We’d better make this field private so nobody can change it without also changing bagsOfFeed—if they get out of sync, that’ll create bugs!
We’ll add a method to give other classes a way to get the number of cows.
And here’s a method to set the number of cows that makes sure the BagsOfFeed field is changed too.
Now there’s no way for the two to get out of sync.
A quick example of encapsulat ion A Farmer class uses a field to store the number of  cows, and multiplies it by a number to figure out how many bags of  cattle feed are needed to feed the cows:
We used camelCase for the private fields and PascalCase for the public ones.
PascalCase means capitalizing the first letter in every word in the variable name.
That makes the uppercase letters look like “humps” of a camel.
The farmer needs 30 bags of feed for each cow.
You can use properties, which are methods that look just like fields to other objects.
A property can be used to get or set a backing field, which is just a name for a field set by a property.
We’ll rename the private field to numberOfCows (notice the lowercase “n”)
This will become the backing field for the NumberOfCows property.
You’ll often use properties by combining them with a normal field declaration.
This is a set accessor that’s called every time the NumberOfCows property is set.
Even though the method doesn’t look like it has any parameters, it actually has one called value that contains whatever value the field was set to.
Here’s code for a button that sets the numbers of  cows and then gets the bags of  feed:
When this line sets NumberOfCows to 10, the set accessor sets the private numberOfCows field and then updates the public BagsOfFeed field.
Since the NumberOfCows set accessor updated BagsOfFeed, now you can get its value.
Build an applicat ion to test the Farmer class Create a new Windows Forms application that we can use to test the Farmer class and see properties in action.
Name this button “calculate”—it uses the public Farmer data to write a line to the output.
Use automatic properties to finish the class It looks like the Cow Calculator works really well.
Then change the number of  cows to 30 and click it again.
Add a button to the form that executes this statement:
But press that button and then press the Calculate button again.
Now your ouput tells you that you need 5 bags of  feed—no matter how many cows you have! As soon as you change the NumericUpDown, the Calculate button should work again.
Fully encapsulate the Farmer class The problem is that your class isn’t fully encapsulated.
You used properties to encapsulate NumberOfCows, but BagsOfFeed is still public.
In fact, it’s so common that C# has a way of  automatically fixing it.
Just change the public BagsOfFeed field to an automatic property.
And the IDE makes it really easy for you to add automatic properties.
Put your cursor where the field used to be, and then type prop and press the tab key twice.
When C# sees this, it works exactly the same as if  you had used a backing field (like the private numberOfCows behind the public NumberOfCows property)
But there’s an easy fix—just make it a read-only property:
Try to rebuild your code—you’ll get an error on the line in the button that sets BagsOfFeed telling you that the set accessor is inaccessible.
You can’t modify BagsOfFeed from outside the Farmer class—you’ll need to remove that line in order to get your code to compile, so remove the button from the form.
The prop-tab-tab code snippet adds an automatic property to your code.
Can you see how this could lead you to accidentally add a really irritating bug in your program?
What if we want to change the feed mult iplier? We built the Cow Calculator to use a const for the feed multiplier.
But what if  we want to use the same Farmer class in different programs that need different feed multipliers? You’ve seen how poor encapsulation can cause problems when you make fields in one class too accessible to other classes.
That’s why you should only make fields and methods public if  you need to.
Since the Cow Calculator never updates FeedMultiplier, there’s no need to allow any other class to set it.
So let’s change it to a read-only property that uses a backing field.
But instead of  adding an automatic property, use a backing field:
It starts out with the default value of  zero and never changes.
When it’s multiplied by the number of  cows, it still gives you zero.
You can only initialize public fields and properties inside an object initializer.
So how can you make sure your object gets initialized properly if some of the fields that need to be initialized are private?
It has a public get, which means any other class can read the val.
But since its set is private, that makes it read-only— it c.
Since we changed FeedMultiplier from a public const to a private int field, we changed its name, so it starts with a lowercase “f”
That’s a pretty standard naming convention you’ll see throughout the book.
Use a constructor to initialize private fields If  you need to initialize your object, but some of  the fields that need to be initialized are private, then an object initializer just won’t do.
Luckily, there’s a special method that you can add to any class called a constructor.
If  a class has a constructor, then that constructor is the very first thing that gets executed when the class is created with the new statement.
You can pass parameters to the constructor to give it values that need to be initialized.
But the constructor does not have a return value, because you don’t actually call it directly.
And you already know that new returns the object—so there’s no way for a constructor to return anything.
Add a constructor to your Farmer class This constructor only has two lines, but there’s a lot going on here.
We already know that we need the number of  cows and a feed multiplier for the class, so we’ll add them as parameters to the constructor.
Since we changed feedMultiplier from a const to an int, now we need an initial value for it.
So let’s make sure it gets passed into the constructor.
We’ll use the constructor to set the number of  cows, too.
Now change the form so that it uses the constructor The only thing you need to do now is change the form so that the new statement that creates the Farmer object uses the constructor instead of  an object initializer.
Once you replace the new statement, both errors will go away, and your code will work!
Notice how there’s no “void” or “int” or another type after “public”
The first thing we’ll do is set the feed multiplier, because it needs to be set before we can call the NumberOfCows set accessor.If we just set the private numberOfCows field, the NumberOfCows set accessor.
Well, it’s got a constructor too! That’s what this method is—notice how it’s named Form1 (like the class) and it doesn’t have a return value.
All you have to do to add a constructor to a class is add a method that has the same name as the class and no return value.
It looks just like any other new statement, except that it has parameters that it passes into the constructor method.
When you type it in, watch for the IntelliSense pop-up—it looks just like any other method.
This is the error you’ll get if your constructor takes parameters but your new doesn’t have any.
Q: Is it possible to have a constructor without any parameters?
When a method’s parameter has the same name as a field, then it masks the field.
Let’s take a closer look at the Farmer constructor so we can get a good sense of what’s really going on.
This constructor has two parameters, which work just like ordinary parameters.
The first one gives the number of cows, and the second one is the feed multiplier.
We need to set the feed multiplier first, because the second statement calls the NumberOfCows set accessor, which needs feedMultiplier to have a value in order to set BagsOfFeed.We need a way to differentiate the field called.
If you leave “this” off, then feedMultiplier refers to the parameter.
So the first line in the constructor sets the private feedMultiplier field equal to the second parameter of the constructor.
Q: Why would I need complicated logic in a get or set accessor? Isn’t it just a way of creating a field?
Q: Wait a minute—so what’s the difference between a method and a get or set accessor?
Q: So you can have ANY kind of statement in a property?
Q: If a set accessor always takes a parameter called value, why doesn’t its declaration have parentheses with “int value” in them, like you’d have with any other method that takes a parameter called value?
Q:Wait a sec—is that why I don’t add a return value to my constructor?
Q: Can I have a get without a set or a set without a get?
Q:I’ve been using objects for a while, but I haven’t written a constructor.
Properties (get and set accessors) are a special kind of method that’s only run when another class reads or writes a property.
Take a look at the get and set accessors here.
Write down the value of the amountOwed variable after the code below executed.
Q: I noticed that you used uppercase names for some fields but lowercase ones for others.
Write down what you think is wrong with the code, and what you’d change.
Write down what you think is wrong with the code, and what you’d change.
The “this” keyword is on a parameter, where it doesn’t belong.
It should be on price, because that field is masked by a parameter.
This parameter masks the private field called Price, and the comment says the method is supposed to be checking the value of the price backing field.
Lowercase price refers to the parameter to the constructor, not the field.
This line sets the PARAMETER to the value returned by the Price get accessor, but Price hasn’t even been set yet! So it doesn’t do anything useful.
If you change the constructor’s parameter to uppercase Price, this line will work properly.
Write down the value of the amountOwed variable after the code below executed.
If we make sure that the cost of the decorations is recalculated every time the number of people is updated, then CalculateCost() will always return the right amount.
We need to recalculate the decoration cost every time the number of people changes.
Add properties and a constructor All you need to do to fix Kathleen’s problem is make sure the DinnerParty class is well encapsulated.
Then you’ll add a constructor that makes sure the instance is initialized properly.
Finally, you’ll change the form so it uses the new constructor.
If  you do this right, that’s the only change you’ll need to make to the form.
Here’s the constructor for the form—everything else in the form stays the same:
Now that numberOfPeople is private, there’s no way for the form to change it without also recalculating the cost of the decorations.
That’ll fix the bug that almost cost Kathleen one of her best clients!
By using a property, you can make sure that the cost of decorations is recalculated every time the number of people changes.
You’ll need it to tell the difference between the parameter and private field named numberOfPeople.
So you’ll need to put “this.” in front of “fancyDecorations” because the fancyDecorations parameter masks the private field with the same name.
Make sure you store the fancy decorations in a field so the NumberOfPeople set accessor can use it.
Sometimes you DO want to be just like your parents.
Ever run across an object that almost does exactly what you want your object to do?
Found yourself wishing that if you could just change a few things, that object would.
I just got a call for a birthday party for 10 people.
Most of the changes have to do with cakes and writing.
Now that you got your program working, Kathleen is using it all the time.
But she doesn’t just handle dinner parties—she does birthdays too, and they’re priced a little differently.
Create a new BirthdayParty class Your new class will need to calculate the costs, deal with decorations, and check the size of  the writing on the cake.
Modifying your program to calculate the cost of  Kathleen’s birthday parties means adding a new class and changing the form to let you handle both kinds of  parties.
Add a TabControl to your form Each tab on the form is a lot like the GroupBox control you used to choose which guy placed the bet in the Betting Parlor lab.
Just click on the tab you want to display, and drag controls into it.
Label the first tab and move the Dinner Party controls into it You’ll drag each of  the controls that handle the dinner party into the new tab.
They’ll work exactly like before, but they’ll only be displayed when the dinner party tab is selected.
Label the second tab and add new Birthday Party controls to it You’ll design the interface for handling birthday parties just like you did for the dinner parties.
Wire your birthday party class up to the controls Now all you need to do is add a BirthdayParty reference to the form’s fields, and add the code to each of  your new controls so that it uses its methods and properties.
Q: Why can’t we just create a new instance of DinnerParty, like Mike did when he wanted to compare three routes in his navigation program?
You’ll do all this in a minute—but first you’ll need to get a sense of what the job involves.
Add the new BirthdayParty class to your program You already know how you’ll handle the NumberOfPeople property and the CostOfDecorations method—they’re just like their counterparts in DinnerParty.
We’ll start by creating your new class and adding those, and then we’ll add the rest of  the behavior.
So first we’ll add the constructor and the NumberOfPeople set accessor.
We’ll also add a couple more fields and a constant.
Make sure you use decimal as the type for the fields and properties that hold currency.
Build the Party Planner version 2.0 Start a new project—we’re going to build Kathleen a new version of  her program that handles birthdays and dinner parties.
We’ll start by creating a wellencapsulated BirthdayParty class to do the actual calculation.
The constructor’s calling the set accessor to set the cake writing, in case the parameter is too long for the cake, so it’s got to calculate the cake size first.
When the BirthdayParty object is initialized, it needs to know the number of people, the kind of decorations, and the writing on the cake, so it can start out with the right cake cost when CalculateCost() is called.
The constructor sets the properties and then runs the calculations.
Here’s where the CakeWriting property makes sure that the cake’s writing is never too long for the cake size.
Its set accessor checks the cake size, then uses the backing field’s Length property to make sure it’s not too long.
If it is, it cuts the string down to the right size.
You’ll need a CakeWriting string property to hold the writing on the cake.
The CakeWriting set accessor checks CakeSize because different sizes of  cake can hold different numbers of  letters.
Then it uses value.Length to check how long the string is.
Did you notice how we left out some of the brackets? When you only have one statement in a code block, you don’t need to add curly brackets around it.
Every string has a Substring() method that returns a portion of the string.
This one cuts it down to the allowed length, so you’ll need to reload the writing into the textbox when the text or cake size changes.
This property is a little more complex than the ones you’ve seen before.
It checks the cake size to see if it’s too long for the cake, using the maxLength variable to store the maximum length.
If it’s too long, it gives an error message and then cuts the backing field down to the right size, so it can be reloaded into the text box.
A lot of times you’ll have an if statement or while loop that’s just got a single.
When that happen s a lot, you can end up with a whole lot.
We’re using decimal because we’re dealing with prices and currency.
Making the CakeWriting method cut down the size of the cake is only half of the solution.
The other half is making sure that the CakeWriting set accessor gets run every time the number of people changes.
The CalculateCost() method is a lot like the one from DinnerParty, except that it adds the cost of the cake instead of the Healthy Choice option.
This method is just like the one in the DinnerParty class.
Finish off  the BirthdayParty class by adding the CalculateCost() method.
But instead of  taking the decoration cost and adding the cost of beverages (which is what happens in DinnerParty), it’ll add the cost of the cake.
Use a TabControl to add tabs to the form Drag a TabControl out of  the toolbox and onto your form, and resize it so it takes up the entire form.
Change the text of  each tab using the TabPages property: a “…” button shows up in the Properties window next to the property.
When you click it, the IDE pops up a window that lets you edit the properties of  each tab.
Set the Text property of  the tabs to “Dinner Party” and “Birthday Party”
Paste the Dinner Party controls onto their tab Open up the Party Planner program from Chapter 5 in another IDE window.
Select the controls on the tab, copy them, and paste them into the new Dinner Party tab.
You’ll need to click inside the tab to make sure they get pasted into the right place (otherwise you’ll get an error about not being able to add a component to a container of  type TabControl)
One thing to keep in mind here: when you copy and paste a control into a form, you’re only adding the control itself, not the event handlers for the control.
And you’ll need to check to make sure that the (Name) is set correctly in the Properties window for each of them.
Make sure that each control has the same name as it did in your Chapter 5 project, and then double-click on each control after you add it to add a new empty event handler.
Build the Birthday Party user interface The Birthday Party GUI has a NumericUpDown control for the number of  people, a CheckBox control for fancy decorations, and a Label control with a 3D border for the cost.
Then you’ll add a TextBox control for the cake writing.
Use the TabCollection property to change the text for each tab.
Click the “…” button next to it and select each tab’s Text property.
After you drag the Dinner Party controls onto the tab, they’ll only be visible when the Dinner Party tab is selected.
This tab uses the NumericUpDown, CheckBox, and Label controls just like the Dinner Party tab does.
Add a TextBox control called cakeWriting for the writing on the cake (and a label above it so the user knows what it’s for)
Use its Text property to give it a default value of “Happy Birthday”
Click on the Birthday Party tab and add the new controls.
The BirthdayParty instance is initialized in the form’s constructor, just like the instance of DinnerParty.
The CheckBox and NumericUpDown controls’ event handlers are just like the ones for the dinner party.
Put it all together All the pieces are there—now it’s just a matter of  writing a little code to make the controls work.
You’ll need fields in your form that have references to a BirthdayParty object and a DinnerParty object, and you’ll need to instantiate them in the constructor.
You already have code for the dinner party controls’ event handlers—they’re in your Chapter 5 project.
If  you haven’t double-clicked on the NumericUpDown and CheckBox controls in the Dinner Party tab to add the event handlers, do it now.
Then copy the contents of  each event handler from the Chapter 5 program and paste them in here.
Add code to the NumericUpDown control’s event handler method to set the object’s NumberOfPeople property, and make the Fancy Decorations checkbox work.
The way that the form handles the cake writing can be really simple because the BirthdayParty class is well encapsulated.
All the form has to do is use its controls to set the properties on the object, and the object takes care of the rest.
All the intelligence for dealing with the writing, the number of people, and the cake size is built into the NumberOfPeople and CakeWriting set accessors, so the form just has to set and display the values.
Use the Events page in the Properties window to add a new TextChanged event handler to the cakeWriting TextBox.
Click on the lightning bolt button in the Properties window to switch to the Events page.
Then select the TextBox and scroll down until you find the TextChanged event.
Double-click on it to add a new event handler for it.
When you select the cakeWriting TextBox and double-click on the TextChanged row in the Events page of the Properties window, the IDE will add a new event handler that gets fired every time the text in the box changes.
Your program’s done—time to run it Make sure the program works the way it’s supposed to.
Check that it pops up a message box if  the writing is too long for the cake.
Start up the program and go to the Dinner Party tab.
Make sure that it works just like your old Party Planner program.
Make sure the cost changes when you change the number of people or click the Fancy Decorations checkbox.
When you type in the Cake Writing text box, the TextChanged event handler should update the cost every time you add or remove a letter.
So what would it take to change your program to add in the extra charge?
Take a minute and think about how you’d add a fee to both the DinnerParty and BirthdayParty classes.
What code would you write? Where would it have to go?
Easy enough…but what happens if  there are three similar classes? Or four? Or twelve? And what if  you had to maintain that code and make more changes later? What if  you had to make the same exact change to five or six closely related classes?
Wow, I’d have to write the same code over and over again.
You’re right! Having the same code repeated in different classes is inefficient and error-prone.
Lucky for us, C# gives us a better way to build classes that are related to each other and share behavior: inheritance.
When your classes use inheritance, you only need to write your code once It’s no coincidence that your DinnerParty and BirthdayParty classes have a lot of  the same code.
When you write C# programs, you often create classes that represent things in the real world—and those things are usually related to each other.
Your classes have similar code because the things they represent in the real world—a birthday party and a dinner party—have similar behaviors.
A birthday party handles the number of people and the cost of decorations in almost the same way as a dinner party.
Kathleen needs to figure out the cost of her parties, no matter what kind of parties they are.
Dinner part ies and birthday part ies are both part ies When you have two classes that are more specific cases of  something more general, you can set them up to inherit from the same class.
When you do that, each of  them is a subclass of  the same base class.
Both kinds of parties have to keep track of the number of people and the cost of decorations, so you can move that into the base class.
The way both parties handle the number of people and calculating the total cost is similar but distinct.
We can break up the behavior for these things so the similar part is in the base class, while putting the distinct pieces in the two subclasses.
Both subclasses inherit the decoration calculation from the base class, so they don’t need to include it.
This arrow in the class diagram means the DinnerParty class inherits from the Party class.
She wanted the baby to inherit her big brown eyes, and not her husband’s beady blue ones.
Build up your class model by start ing general and get t ing more specif ic.
C# programs use inheritance because it mimics the relationship that the things they model have in the real world.
Real-world things are often in a hierarchy that goes from more general to more specific, and your programs have their own class hierarchy that does the same thing.
In your class model, classes further down in the hierarchy inherit from those above it.
If you have a recipe that calls for cheddar cheese, then you can use aged Vermont cheddar.
But if it specifically needs aged Vermont, then you can’t just use any cheddar—you need that specific cheese.
Every bird is an animal, but not every animal is a bird.
To someone looking for a pet, any songbird might do.
But to an ornithologist studying the mimidae bird family, confusing the Northern and Southern mockingbirds would be unacceptable.
In a class model, Cheese might inherit from DairyProduct, which would inherit from Food.
Something lower on the hierarchy inherits most or all of the attributes of everything above it.
All animals eat and mate, so Northern Mockingbirds eat and mate.
How would you design a zoo simulator? Lions and tigers and bears…oh my! Also, hippos, wolves, and the occasional cat.
Your job is to design a program that simulates a zoo.
Don’t get too excited—we’re not going to actually build the code, just design the classes to represent the animals.
We’ve been given a list of  some of  the animals that will be in the program, but not all of  them.
We know that each animal will be represented by an object, and that the objects will move around in the simulator, doing whatever it is that each particular animal is programmed to do.
More importantly, we want the program to be easy for other programmers to maintain, which means they’ll need to be able to add their own classes later on if  they want to add new animals to the simulator.
So what’s the first step? Well, before we can talk about specific animals, we need to figure out the general things they have in common—the abstract characteristics that all animals have.
Then we can build those characteristics into a class that all animal classes can inherit from.
What do a lion, a hippo, a tiger, a cat, a wolf, and a dalmatian have in common? How are they related? You’ll need to figure out their relationships so you can come up with a class model that includes all of  them.
It’s hard to maintain, and always leads to headaches down the road.
So let’s choose fields and methods for an Animal base class that you only have to write once, and each of  the animal subclasses can inherit from them.
Picture: an image that you can put into a PictureBox.
Right now, there can be only two values: meat and grass.
Hunger: an int representing the hunger level of  the animal.
It changes depending on when (and how much) the animal eats.
Boundaries: a reference to a class that stores the height, width, and location of  the pen that the animal will roam around in.
Location: the X and Y coordinates where the animal is standing.
In addition, the Animal class has four methods the animals can inherit:
MakeNoise(): a method to let the animal make a sound.
Eat(): behavior for when the animal encounters its preferred food.
Sleep(): a method to make the animal lie down and take a nap.
Roam(): the animals like to wander around their pens in the zoo.
Use inheritance to avoid duplicate code in subclasses Build a base class to give.
The fields, properties, and methods in the base class will give all of the animals that inherit from it a common state and behavior.
They’re all animals, so it makes sense to call the base class Animal.
You could have decided to use a ZooOccupant class that defines the feed and maintenance costs, or an Attraction class with methods for how the animals entertain the zoo visitors.
Different animals make different noises Lions roar, dogs bark, and as far as we know hippos don’t make any sound at all.
Each of  the classes that inherit from Animal will have a MakeNoise() method, but each of  those methods will work a different way and will have different code.
When a subclass changes the behavior of  one of  the methods that it inherited, we say that it overrides the method.
Think about what you need to override When a subclass changes the behavior of  a method it inherited, we call it overriding.
But a dog might take little bites of  meat, while a hippo eats huge mouthfuls of  grass.
So what would the code for that behavior look like? Both the dog and the hippo would override the Eat() method.
The hippo’s method would have it consume, say, 20 pounds of  hay each time it was called.
The dog’s Eat() method, on the other hand, would reduce the zoo’s food supply by one 12-ounce can of  dog food.
Grass is yummy! I could go for a good pile of hay right now.
We already know that some animals will override the MakeNoise() and Eat() methods.
Which animals will override Sleep() or Roam()? Will any of them? What about the properties—which animals will override some properties?
Figure out what each animal does that the Animal class does differently—or not at all.
What does each type of  animal do that all the other animals don’t? Dogs eat dog food, so the dog’s Eat() method will need to override the Animal.Eat() method.
Hippos swim, so a hippo will have a Swim() method that isn’t in the Animal class at all.
Just because a property or a method is in the Animal base class, that doesn’t mean every subclass has to use it the same way…or at all!
So when you’ve got a subclass that inherits from a base class, it must inherit all of the base class’s behaviors… but you can modify them in the subclass so they’re not performed exactly the same way.
Think about how to group the animals Aged Vermont cheddar is a kind of  cheese, which is a dairy product, which is a kind of  food, and a good class model for food would represent that.
Lucky for us, C# gives us an easy way to do it.
You can create a chain of  classes that inherit from each other, starting with the topmost base class and working down.
So you could have a Food class, with a subclass called DairyProduct that serves as the base class for Cheese, which has a subclass called Cheddar, which is what AgedVermontCheddar inherits from.
Don’t dogs and wolves seem pretty similar? They’re both canines, and it’s a good bet that if  you look at their behavior they have a lot in common.
They probably eat the same food and sleep the same way.
What about domestic cats, tigers, and lions? It turns out all three of  them move around their habitats in exactly the same way.
It’s a good bet that you’ll be able to have a Feline class that lives between Animal and those three cat classes that can help prevent duplicate code between them.
There’s a pretty good chance that we’ll be able to add a Canine class that the dogs and wolves both inherit from.
The subclasses inherit all four methods from Animal, but we’re only having them override MakeNoise() and Eat()
That’s why we only show those two methods in the class diagrams.
Our wolves and dogs eat the same way, so we moved their common Eat() method up to the Canine class.
The three cats roam the same way, so they share an inherited Roam() method.
But each one still eats and makes noise differently, so they’ll all override the Eat() and MakeNoise() methods that they inherited from Animal.
Since Feline overrides Roam(), anything that inherits from it gets its new Roam() and not the one in Animal.
Create the class hierarchy When you create your classes so that there’s a base class at the top with subclasses below it, and those subclasses have their own subclasses that inherit from them, what you’ve built is called a class hierarchy.
This is about more than just avoiding duplicate code, although that is certainly a great benefit of  a sensible hierarchy.
But when it comes down to it, the biggest benefit you’ll get is that your code becomes really easy to understand and maintain.
When you’re looking at the zoo simulator code, when you see a method or property defined in the Feline class, then you immediately know that you’re looking at something that all of  the cats share.
Your hierarchy becomes a map that helps you find your way through your program.
Now that you know how you’ll organize the animals, you can add the Feline and Canine classes.
You’re not limited to the methods that a subclass inherits from its base class…but you already know that! After all, you’ve been building your own classes all along.
When you add inheritance to a class, what you’re doing is taking the class you’ve already built and extending it by adding all of the fields, properties, and methods in the base class.
So if  you wanted to add a Fetch() method to the dog, that’s perfectly normal.
It won’t inherit or override anything—only the dog will have that method, and it won’t end up in Wolf, Canine, Animal, Hippo, or any other class.
C# always calls the most specif ic method If  you tell your dog object to roam, there’s only one method that can be called—the one in the Animal class.
But what about telling your dog to make noise? Which MakeNoise() is called?
A method in the Dog class tells you how dogs do that thing.
If  it’s in the Canine class, it’s telling you how all canines do it.
And if  it’s in Animal, then it’s a description of that behavior that’s so general that it applies to every single animal.
So if  you ask your dog to make a noise, first C# will look inside the Dog class to find the behavior that applies specifically to dogs.
If  Dog didn’t have one, it’d then check Canine, and after that it’d check Animal.
Use a colon to inherit from a base class When you’re writing a class, you use a colon (:) to have it inherit from a base class.
That makes it a subclass, and gives it all of  the fields, properties, and methods of  the class it inherits from.
The Bird class uses a colon to inherit from the.
You extend a class by adding a colon to the end of the class declaration, followed by the base class to inherit from.
Since the Bird class inherits from Vertebrate, every instance of Bird also has the fields and methods defined in the Vertebrate class.
When a subclass inherits from a base class, all of the fields, properties, and methods in the base class are automatically added to the subclass.
Q: Why does the arrow point up, from the subclass to the base class? Wouldn’t the diagram look better with the arrow pointing down instead?
Take a look at these class models and declarations, and then circle the statements that won’t work.
Take a look at these class models and declarations, and then circle the statements that won’t work.
CountCalories is a method, but this statement doesn’t include the parentheses () after the call to the method.
These properties are part of the instance, but the statements are trying to call them incorrectly using the class names.
We know that inheritance adds the base class f ie lds, propert ies, and methods to the subclass… Inheritance is simple when your subclass needs to inherit all of  the base class methods, properties, and fields.
Penguin objects shouldn’t be able to fly! But if the Penguin class inherits from Bird, then you’ll have penguins flying all over the place.
If this were your Bird Simulator code, what would you do to keep the penguins from flying?
Since it inherited the Fly() method, there’s nothing stopping it from flying.
Pigeon is a subclass of Bird, so any fields and methods in Bird are automatically part of Pigeon, too.
A subclass can override methods to change or replace methods it inherited Sometimes you’ve got a subclass that you’d like to inherit most of  the behaviors from the base class, but not all of  them.
When you want to change the behaviors that a class has inherited, you can override the methods.
Before you can override a method, you need to mark it virtual in the base class.
Adding the virtual keyword to the Fly() method tells C# that a subclass is allowed to override it.
Add the virtual keyword to the method in the base class A subclass can only override a method if  it’s marked with the virtual keyword, which tells C# to allow the subclass to override methods.
Add a method with the same name to the derived class You’ll need to have exactly the same signature—meaning the same return value and parameters—and you’ll need to use the override keyword in the declaration.
When you override a method, your new method needs to have exactly the same signature as the method in the base class it’s overriding.
In this case, that means it needs to be called Fly, return void, and have no parameters.
To override the Fly() method, add an identical method to the subclass and use the override keyword.
Any place where you can use a base class, you can use one of its subclasses instead One of  the most useful things you can do with inheritance is use a subclass in place of  the base class it inherits from.
So if  your Recipe() method takes a Cheese object and you’ve got an AgedVermontCheddar class that inherits from Cheese, then you can pass an instance of  AgedVermontCheddar to the Recipe() method.
Recipe() only has access to the fields, properties, and methods that are part of  the Cheese class, though—it doesn’t have access to anything specific to AgedVermontCheddar.
Let’s say we have a method to analyze Sandwich objects:1
You could pass a sandwich to the method—but you could also pass a BLT.
Since a BLT is a kind of  sandwich, we set it up so that it inherits from the Sandwich class:
You can always move down the class diagram—a reference variable can always be set equal to an instance of  one of  its subclasses.
You can assign myBLT to any Sandwich variable because a BLT is a kind of sandwich.
But you can’t assign mySandwich to a BLT variable, because not every sandwich is a BLT! That’s why this last line will cause an error.
One block of the program is missing! Your challenge is to match the candidate block of code (on the left) with the output—what’s in the message box that the program pops up—that you’d see if the block were inserted.
Not all the lines of output will be used, and some of the lines of output might be used more than once.
Draw lines connecting the candidate blocks of code with their matching output.
Here’s the entry point for the program—it doesn’t show a form, it just pops up a message box.
Don’t just type this into the IDE—you’ll learn a lot more if you figure this out on paper.
Hint: Think really hard about what this line really means.
Pool Puzzle Your job is to take code snippets from the pool and place them into the blank lines in the code.
You may use the same snippet more than once, and you might not need to use all the snippets.
Your goal is to make a set of classes that will compile and run together as a program.
You can always substitute a reference to a subclass in place of a base class.
In other words, you can always use something more specific in place of  something more general—so if you’ve got a line of  code that asks for a Canine, you can send it a reference to a Dog.
Names like A, a2, and C make for a good puzzle, but they’re a little hard to understand.
Here are a few lines that follow the same pattern, but have names that you can understand:
Q: About the entry point that you pointed out in the Pool Puzzle—does this mean I can have a program that doesn’t have a Form1 form?
Q: Can I inherit from the class that contains the entry point?
Q: I still don’t get why they’re called “virtual” methods—they seem real to me!
Q: What did you mean by only being able to move up the class diagram but not being able to move down?
You can always pass an instance of a subclass to any method whose parameters expect a class that it inherits from.
Flip back to the beginning of Chapter 2 if you need a refresher on Main() and the entry point!
There’s an important reason for virtual and override! The virtual and override keywords aren’t just for decoration.
Look, I just don’t see why I need to use those “virtual” and “override” keywords.
If I don’t use them, the IDE just gives me a warning, but the warning doesn’t actually mean anything—my program still runs! I mean, I’ll put the keywords in if it’s the “right”
Console applications don’t use forms If you create a console application instead of a Windows Forms application, all the IDE creates for you is a new class called Program with an empty Main() entry point method.
When you run it, it pops up a command window to display the output.
You can read more about console applications in Appendix A.
Right-click on the project in the Solution Explorer and add classes, just like normal.
Instead of creating a Windows Forms application, you’re going to create a new console application instead! This means it won’t have a form.
Here’s the code for the five new classes you added:
A Safe object keeps a Jewels reference in its contents field.
It doesn’t return that reference unless Open() is called with the right combination.
A locksmith can pick the combination lock and get the combination by calling the PickLock() method and passing in a reference to himself.
Notice how the private keyword hides the contents and combination.
But don’t run it just yet! Before you run the program, try to figure out what it’s going to print to the console.
Jewel thieves are locksmiths gone bad! They can pick the lock on the safe, but instead of  returning the jewels to the owner they steal them!
But when the OpenSafe() method calls ReturnContents() to return the jewels to the owner, the JewelThief steals them instead!
A Locksmith’s OpenSafe() method picks the lock, opens the safe, and returns the contents to the owner.
Before you run it, write down what you think it will print to the console.
A subclass can hide methods in the superclass Go ahead and run the JewelThief  program.
Since it’s a console application, instead of  writing its console output to the Output window, it’ll pop up a command window and print the output there.
Did you expect the program’s output to be different? Maybe something like this:
It looks like the JewelThief  acted just like a Locksmith! So what happened?
Hiding methods versus overriding methods The reason the JewelThief object acted like a Locksmith object when its ReturnContents() method was called was because of  the way the JewelThief class declared its ReturnContents() method.
There’s a big hint in that warning message you got when you compiled your program:
Since the JewelThief class inherits from Locksmith and replaces the ReturnContents() method with its own method, it looks like JewelThief is overriding Locksmith’s ReturnContents() method.
You probably expected JewelThief to override the method (which we’ll talk about in a minute), but instead JewelThief is hiding it.
When a subclass hides the method, it replaces (technically, it “redeclares”) a method in its base class that has the same name.
So now our subclass really has two different methods that share a name: one that it inherits from its base class, and another brand-new one that’s defined in its own class.
If a subclass just adds a method with the same name as a method in its superclass, it only hides the superclass method instead of overriding it.
Use different references to call hidden methods The JewelThief only hides the ReturnContents() method (as opposed to extending it), and that causes it to act like a Locksmith object whenever it’s called like a Locksmith object.
JewelThief inherits one version of  ReturnContents() from Locksmith, and it defines a second version of  it, which means that there are two different methods with the same name.
That means your class needs two different ways to call it.
If  you’ve got an instance of  JewelThief, you can use a JewelThief reference variable to call the new ReturnContents() method.
But if  you use a Locksmith reference variable to call it, it’ll call the hidden Locksmith ReturnContents() method.
The JewelThief subclass hides a method in the Locksmith base class, // so you can get different behavior from the same object based on the // reference you use to call it!
Use the new keyword when you’re hiding methods Take a close look at that warning message.
Sure, we never really read most of  our warnings, right? But this time, actually read what it says: To make the current member override that implementation, add the override keyword.
So go back to your program and add the new keyword.
As soon as you add new to your JewelThief class’s ReturnContents() method declaration, that error message will go away.
But your program still won’t act the way you expect it to! It still calls the ReturnContents() method defined in the Locksmith object.
If  JewelThief only hides the ReturnContents() method, its own ReturnContents() will never be called.
Can you figure out how to get JewelThief to override the ReturnContents() method instead of just hiding it? See if you can do it before turning to the next page!
Use the override and v irtual keywords to inherit behavior We really want our JewelThief class to always use its own ReturnContents() method, no matter how it’s called.
This is the way we expect inheritance to work most of  the time, and it’s called overriding.
And it’s very easy to get your class to do it.
The first thing you need to do is use the override keyword when you declare the ReturnContents() method, like this:
If  you just add that override and try to compile, you’ll get an error that looks like this:
Again, take a really close look and actually read the error.
JewelThief can’t override the inherited member ReturnContents() because it’s not marked virtual, abstract, or override in Locksmith.
Well, that’s an easy error to fix! Just mark Locksmith’s ReturnContents() with the virtual keyword:
If you want to override a method in a base class, always mark it with the virtual keyword, and always use the override keyword any time you want to override the method in a subclass.
If you don’t, you’ll end up accidentally hiding methods instead.
When I come up with my class hierarchy, I usually want to override methods and not hide them.
But if I do hide them, I’ll always use the new keyword, right?
Most of the time you want to override methods, but hiding them is an option.
When you’re working with a subclass that extends a base class, you’re much more likely to use overriding than you are to use hiding.
So when you see that compiler warning about hiding a method, pay attention to it! Make sure you really want to hide the method, and didn’t just forget to use the virtual and override keywords.
If  you always use the virtual, override, and new keywords correctly, you’ll never run into a problem like this again!
A subclass can access its base class using the base keyword Even when you override a method or property in your base class, sometimes you’ll still want to access it.
Luckily, we can use base, which lets us access any method in the base class.
All animals eat, so the Vertebrate class has an Eat() method that takes a Food object as its parameter.
So the Chameleon class inherits from Vertebrate but overrides Eat()
The chameleon needs to swallow and digest the food, just like any other animal.
Instead of  duplicating the code, we can use the base keyword to call the method that was overridden.
Now we have access to both the old and the new version of  Eat()
This line calls the Eat() method in th e base.
Now that you’ve had a chance to absorb some of  the ideas behind inheritance, here’s something to think about.
While reusing code is a good way to save keystrokes, another valuable part of  inheritance is that it makes it easier to maintain your code later.
When a base class has a constructor, your subclass needs one, too If  your class has constructors that take parameters, then any class that inherits from it must call one of  those constructors.
The subclass’s constructor can have different parameters from the base class constructor.
The base class constructor is executed before the subclass constructor But don’t take our word for it—see for yourself !
It means that your subclass didn’t call the base constructor.
Add this extra line to the end of your subclass’s constructor declaration to tell C# that it needs to call the base class’s constructor every time the subclass is instantiated.
Add this line to tell C# to call the c onstructor in.
Select Build >> Build Solution in the IDE and you’ll get an error from this code.
This is a parameter that the base class constructor needs.
This is how we send the base class the parameter its constructor needs.
Now you’re ready to f inish the job for Kathleen! When you last left Kathleen, you’d finished adding birthday parties to her program.
It seemed like you were going to have to write the same exact code twice, once for each class.
Now that you know how to use inheritance, you can have them inherit from the same base class that contains all of  their shared code, so you only have to write it once.
Let’s create the new class model We’ll still have the same DinnerParty and BirthdayParty classes, but now they’ll inherit from a single Party class.
We need them to have exactly the same methods, properties, and fields, so we don’t have to make any changes to the form.
But some of  those methods, properties, and fields will be moved into the Party base class, and we may have to override a few of  them.
If we play our cards right, we should be able to change the two classes without making any changes to the form!
Build the Party base class Create the Party class—make sure it’s public.
You’ll need to look really closely at the properties and methods in the class diagram, and figure out what you need to move out of DinnerParty and BirthdayParty and into Party.
Move the NumberOfPeople and CostOfDecorations properties into it so that they’re compatible with both DinnerParty and BirthdayParty.
If  those methods need any private fields, you’ll need to move them, too.
Remember, subclasses can only see public fields—once you move a private field to Party, the DinnerParty and BirthdayParty classes won’t have access to it.
After all, that’s why we’re doing this! It’s common to both birthday and dinner parties, so it belongs in Party.
Make DinnerParty inherit from Party Now that Party does a lot of  the things DinnerParty does, you can eliminate the overlap and only keep the part of  DinnerParty that’s unique to dinner parties.
Does it do anything the Party constructor doesn’t? If  so, keep that and then leave everything else to the base class constructor.
Any logic that has to do with setting the Healthy Option should stay in DinnerParty.
Uh-oh—we can’t override the CalculateCost() method here if  we want to keep the form code the same, because our form needs to pass it a bool called healthyOption.
So instead, we’ll overload it—which just means adding a new CalculateCost() method to the class that takes different parameters.
So you’ll use exactly the same declaration for the method that you used at the beginning of  the chapter.
But you can still take advantage of  inheritance by calling base.
CalculateCost() to access the CalculateCost() method in the Party class.
What does the BirthdayParty constructor need to do that’s not part of  Party?
You’ll need to deal with the cost of  the cake inside of  BirthdayParty.
That touches a method and a property, so you’ll need to override them.
Yes, you can override a property! It’s just like overriding a method.
You’ll need to use the base keyword to both get and set the value.
You’ll learn all about overloading in Chapter 8—this is just a sneak preview to give you a leg up on it later.
A protected field is public to a subclass, but private to everyone else.
The decoration calculation is identical in both birthday and dinner parties, so it makes sense to move it to Party.
That way none of the code is duplicated in multiple classes.
The cost calculation needs to be a virtual method because the birthday party overrides it (and also extends it by calling the base class method)
NumberOfPeople needs to be virtual because BirthdayParty needs to override it (so that a change to the number of people calculates a new cake size)
The Party constructor does everything that was previously in both the DinnerParty and BirthdayParty constructors.
This code was moved straight out of the DinnerParty and BirthdayParty classes and into Party.
The CakeWriting property stays intact in the BirthdayParty class too.
The constructor relies on the base class to do most of the work.
The NumberOfPeople property has to override the one in Party because the set accessor needs to recalculate the cake size.
NumberOfPeople so that the set accessor in Party also gets executed.
CalculateCost() also needs to be overridden, because it needs to first calculate the cost of the cake, and then add it to the cost that’s calculated in the Party class’s CalculateCost() method.
This public field is only used in dinner parties, not birthday parties, so it stays in the class.
To do what the old DinnerParty class did, the new constructor calls the Party constructor and then calls SetHealthyOption()
DinnerParty needs a different CalculateCost() that takes a parameter, so instead of overriding it we overloaded it.
It calls the CalculateCost() method in Party using the base keyword, and then adds the cost of the beverages and adds in the healthy option discount.
It’s so much easier to run my business now—thanks so much!
Now the DinnerParty class has two CalculateCost() methods, one that it inherits from Party and this new one that we added.
We haven’t fully encapsulated the class—someone could easily misuse this code by calling the wrong CalculateCost() method.
Sometimes there’s code in the base class that you don’t want to call directly.
Even worse, we never intended the Party class to be instantiated…but there’s nothing stopping someone from doing it.
Do we even know what will happen if  someone creates an instance of  Party? We can be pretty sure it’ll do something we didn’t plan for.
Luckily, C# gives us a really good solution to these problems, which you’ll learn about in the next chapter!
Build a beehive management system A queen bee needs your help! Her hive is out of  control, and she needs a program to help manage it.
She’s got a beehive full of  workers, and a whole bunch of  jobs that need to be done around the hive.
But somehow she’s lost control of  which bee is doing what, and whether or not she’s got the beepower to do the jobs that need to be done.
It’s up to you to build a beehive management system to help her keep track of  her workers.
The queen assigns jobs to her workers There are six possible jobs that the workers can do.
Some know how to collect nectar and manufacture honey, others can maintain the hive and patrol for enemies.
A few bees can do every job in the hive.
So your program will need to give her a way to assign a job to any bee that’s available to do it.
This drop-down list shows all six jobs that the workers can do.The queen knows what jobs need to be done, and she doesn’t really care which bee does each job.
So she just selects which job has to be done—the program will figure out if there’s a worker available to do it and assign the job to him.
The bees work shifts, and most jobs require more than one shift.
So the queen enters the number of shifts the job will take, and clicks the “Assign this job” button.
If there’s a bee available to do the job, the program assigns the job to the bee and lets the queen know it’s taken care of.
When the jobs are all assigned, it’s time to work Once the queen’s done assigning the work, she’ll tell the bees to work the next shift by clicking the “Work the next shift” button.
The program then generates a shift report that tells her which bees worked that shift, what jobs they did, and how many more shifts they’ll be working each job.
First you’l l build the basic system This project is divided into two parts.
The first part is a bit of  a review, where you’ll create the basic system to manage the hive.
You’ll build the form for the system, and hook it up to the two classes.
And you’ll make sure the classes are well encapsulated so they’re easy to change when you move on to the second part.
So a worker can figure out if he’s currently doing a job by checking his CurrentJob property—it’ll be equal to an empty string if he’s waiting for his next job.
The program has one Queen object that manages the work being done.
The Queen uses an array of  Worker objects to track each of  the worker bees and whether or not those bees have been assigned jobs.
It’s stored in a private Worker[ ] field called worker.
The form calls the AssignWork() method, passing a string for the job that needs to be performed and an int for the number of shifts.
It’ll return true if  it finds a worker to assign the job to, or false if  it couldn’t find a worker to do that job.
It tells each Worker object to work one shift, and then checks that worker’s status so it can add a line to the shift report.
The queen uses an array of  Worker objects to keep track of  all of  the workers and what jobs they’re doing.
If  the worker isn’t doing any job, it’ll return an empty string.
The Queen object attempts to assign a job to a worker using its DoThisJob() method.
If  that worker is not already doing the job, and if  it’s a job that he knows how to do, then he’ll accept the assignment and the method returns true.
When the WorkOneShift() method is called, the worker works a shift.
He keeps track of  how many shifts are left in the current job.
If  the job is done, then he resets his current job to an empty string so that he can take on his next assignment.
Each Worker object’s constructor takes one parameter, an array of strings that tell it what jobs it knows how to do.
You’ll pass that array of Worker object references to the Queen object’s constructor.
Build the form The form is pretty simple—all of  the intelligence is in the Queen and Worker classes.
The form has a private Queen field, and two buttons call its AssignWork() and WorkTheNextShift() methods.
You’ll need to add a ComboBox control for the bee jobs (flip back to the previous page to see its list items), a NumericUpDown control, two buttons, and a multiline text box for the shift report.
Look closely at this shift report, which the Queen object generates.
It starts with a shift number, and then reports what each worker is doing.
Use the escape sequences “\r\n” to add a line break in the middle of a string.
The nextShift button calls the queen’s WorkTheNextShift() method, which returns a string that contains the shift report.
Use its Items property to set the list, and set its DropDownStyle property to “DropDownList” so the user is only allowed to choose items from the list.
The Shifts box is a NumericUpDown control called “shifts.” Name this TextBox “report” and set its MultiLine property to true.
Build the Worker and Queen classes You’ve got almost everything you need to know about the Worker and Queen classes.
The Worker object checks its jobsICanDo string array to see if  it can do the job.
If  it can, it sets its private shiftsToWork field to the job duration, its CurrentJob to the job, and its shiftsWorked to zero.
When it works a shift, it increases shiftsWorked by one.
The read-only ShiftsLeft property returns shiftsToWork shiftsWorked—the queen uses it to see how many shifts are left on the job.
CurrentJob is a readonly property that tells the queen which job needs to be done.
The constructor just sets the JobsICanDo property, which is a string array.
It’s private because we want the queen to ask the worker to do a job, rather than make her check whether he knows how to do it.
The queen uses the worker’s DoThisJob() method to assign work to him—he checks his JobsICanDo property to see if he knows how to do the job.
The queen uses the worker’s WorkOneShift() method to tell him to work the next shift.
The method only returns true if this is the very last shift that he’s doing the job.
That way the queen can add a line to the report that the bee will be done after this shift.
First it checks the currentJob field: if the worker’s not working on a job, it just returns false, which stops the method.
If not, then it increments ShiftsWorked, and then checks to see if the job’s done by comparing it with ShiftsToWork.
We used !—the NOT operator—to check if the string is NOT null or empty.
ShiftsLeft is a read-only property that calculates how many shifts are left on the current job.
The queen keeps her array of workers private because once they’re assigned, no other class should be able to change them…or even see them, since she’s the only one who gives them orders.
When she assigns work to her worker bees, she starts with the first one and tries assigning him the job.
If he can’t do it, she moves on to the next.
When a bee who can do the job is found, the method returns (which stops the loop)
The queen’s WorkTheNextShift() method tells each worker to work a shift and adds a line to the report depending on the worker’s status.
The form uses its queen field to keep a reference to the Queen object, which in turn has an array of references to the worker objects.
The assignJob button calls the queen’s AssignWork() method to assign work to a worker, and displays a message box, depending on whether or not a worker’s available to do the job.
The nextShift button tells the queen to work the next shift.
Inheritancecross Before you move on to the next part of the exercise, give your brain a break with a quick crossword.
The constructor in a subclass doesn’t need the same _____ as the constructor in its base class.
A control on a form that lets you create tabbed applications.
If you want a subclass to override a method, mark the method with this keyword in the base class.
A method in a class that’s run as soon as it’s instantiated.
What a subclass does to replace a method in the base class.
What you’re doing by adding a colon to a class declaration.
A subclass uses this keyword to call the members of the class it inherited from.
The constructor in a subclass doesn’t need the same _____ as the constructor in its base class.
A control on a form that lets you create tabbed applications.
If you want a subclass to override a method, mark the method with this keyword in the base class.
A method in a class that’s run as soon as it’s instantiated.
What a subclass does to replace a method in the base class.
What you’re doing by adding a colon to a class declaration.
A subclass uses this keyword to call the members of the class it inherited from.
That way you c an always get back to the first s.
Explorer in the IDE, select “Add Existing Item” from the menu, n.
The IDE will NOT c hange the namespace, so you’ll nee.
Use inheritance to extend the bee management system Now that you have the basic system in place, use inheritance to let it track how much honey each bee consumes.
Different bees consume different amounts of  honey, and the queen consumes the most honey of  all.
So you’ll use what you’ve learned about inheritance to create a Bee base class that Queen and Worker inherit from.
Since honey consumption requires the number of shifts left, we’ll move the ShiftsLeft property into it and mark it as virtual so the Worker can override it.
The worker just needs to subclass Bee and override the ShiftsLeft method with the one you already wrote.
The queen needs to change her report to add honey consumption data.
Sometimes we’ll show you return values and private members in class diagrams.
We’ll make it a virtual method, so one of the subclasses can override it.
The queen needs to know how much honey the hive uses The queen just got a call from her accountant bees, who told her that the hive isn’t producing enough honey.
She’ll need to know how much honey she and her workers are using so she can decide whether to divert workers from egg maintenance to honey production.
All bees eat honey, so the hive runs through a lot of  honey.
That’s why they need to keep making more of  it.
They need the most honey when the job starts, to give them plenty of  energy for the job.
They consume less and less as the job goes on.
So if  the bee is working (meaning his ShiftsLeft is greater than zero), then you can find out how many units of  honey to consume by adding 9 to ShiftsLeft.
If  a bee doesn’t have a job (i.e., its ShiftsLeft is zero), he only uses 7.5 units of  honey for the shift.
A queen uses more honey when she’s got more workers doing jobs, because it’s a lot of  work overseeing them.
She needs to consume as much honey as if  she’d worked as many shifts as the worker with the most shifts left on his job.
The queen needs all the honey consumption numbers added to the end of  each shift report.
Create a Bee class to handle the honey calculations Since the workers and queen all do their honey calculations in similar ways, you’ll be able to avoid duplicating your code by having a Bee base class that Worker and Queen can inherit from.
You know that each bee needs to know its weight (so it knows whether to multiply its honey expenditure by 35%)
Since the workers and queen all need to do this calculation but the queen needs to do extra calculations as well, it makes sense for the worker to inherit it and the queen to override it.
The honey consumption calculation needs to know the bee’s weight, so the Bee constructor will need to take the weight as a parameter and store it in a field.
Since no other class needs to use it, you should make it private.
You should make fields and methods private by default, and only make them public if another class needs them.
That way you avoid bugs in your programs caused by one class accessing another class’s properties or methods incorrectly.
Make the Worker class inherit from Bee You’ll need to set up the constructor to call the base class constructor, like you did with Kathleen.
You’ll need to change the Worker constructor so that it takes the bee’s weight as a parameter, and pass that parameter on to the base class constructor.
Then, just add the override keyword to the Worker’s ShiftLeft method.
Once you do that, each worker will be able to calculate his honey consumption for the queen…and you don’t have to make any more changes to the Worker class!
Make the Queen class inherit from Bee The Queen class needs a little more alteration than the Worker class, since she needs to actually do the honey calculation and add it to the shift report.
Then she’ll need to add that to the number of  units she’d use if  she had the same number of  shifts left as the worker with the most shifts left.
Update the queen’s WorkTheNextShift() method by adding the honey consumption line to the report.
Add a loop to add up the honey consumption for each worker and also to find the worker with the largest honey consumption—do it before the queen tells each worker to work the shift (so she gets the consumption numbers for the current shift)
She’ll add those up, add her own consumption, and then add a line to the end of  the shift report that says, “Total Honey Consumption: xxx units” (where xxx is the number of  units of  honey consumed)
You’ll need to update the Queen constructor just like you did for Worker.
Update the form to instantiate the bees properly Since you changed the Queen and Worker constructors, you’ll also need to change the way they’re called.
Each constructor has a new Weight parameter, so you’ll need the weights to use:
That’s the only change you’ll need to make to the form!
Hint: You can use the slightly cryptic “no overload” error message to your advantage! Have the Worker class inherit from Bee, then build your project.
When the IDE displays the error, double-click on it and the IDE will jump right to the Worker constructor automatically.
Go to the Queen class and type “public override”—when you press the space bar, the IDE automatically lists all the methods you can override.
Select the method you want to override and it’ll fill in the base method call automatically.
Inheritance made it easy for you to update your code and add the new honey consumption behavior to the Queen and Worker classes.
It would have been a lot harder to make this change if you’d had a lot of duplicated code.
The only change to the form is that the weights need to be added to the Worker constructors.
The Bee class has a constructor that sets its Weight field and a HoneyConsumption() method that calculates how much honey a worker consumes.
If ShiftsLeft is zero, then the bee has no job.
It does the basic honey consumption calculation that’s used by both the Worker and Queen classes.
Only the form constructor changed—the rest of the form is exactly the same.
All the Worker class needed was to inherit from Bee and have its constructor adjusted so that it takes a Weight parameter and passes it on to the base class constructor, and overrides the Bee.ShiftsLeft property by adding the override keyword to the property declaration.
The Queen class needed a few changes, starting with inheriting from Bee.
This loop looks at the consumption of all the workers and finds the one with the largest consumption.
The rest of WorkTheNextShift() is the same, except that it adds the honey line to the report.
The constructor in a subclass class doesn’t need the same _____ as the constructor in its base class.
A control on a form that lets you create tabbed applications.
If you want a subclass to override a method, mark the method with this keyword in the base class.
A method in a class that’s run as soon as it’s instantiated.
What a subclass does to replace a method in the base class.
What you’re doing when add a colon to a class declaration.
A subclass uses this keyword to call the members of the class it inherited from.
Sometimes you need to group your objects together based on the things they can.
You’ve got three days before I send some Thug objects by to make sure you implement the WalksWithALimp() method.
Let’s get back to bee-sics The General Bee-namics corporation wants to make the Beehive Management System you created in the last chapter into a full-blown Hive Simulator.
Here’s an overview of  the specification for the new version of  the program:
To better represent life in the hive, we ’ll need to add specialized.
Queens assign work, monitor shift re ports, and tell workers to.
The bees in the new Hive Simulator will still consume honey in the same way they did before.
The queen still needs to be able to assign work to the workers and see the shift reports that tell who’s doing what.
The workers work shifts just like they did before, too, it’s just that the jobs they are doing have been elaborated a little bit.
The Bee and Worker classes don’t look like they’ll change much.
We can extend the classes we already have to handle these new features.
Looks like we’ll need to be able to store different data for the worker bees depending on the job they do.
Lots of things are st i l l the same.
We can use inheritance to create classes for different types of bees Here’s a class hierarchy with Worker and Queen classes that inherit from Bee, and Worker has subclasses NectarCollector and StingPatrol.
What happens if you have a bee that needs to sting and collect nectar?
Here’s where information about weight and honey consumption is stored.
And these classes hold the information particular to each job.
Here’s where all of the information about working shifts is kept.
Remember how the queen needed extra honey? Here’s where we overrode her HoneyConsumption() method.
An interface te l ls a class that it must implement certain methods and propert ies A class can only inherit from one other class.
So creating two separate subclasses for the StingPatrol and NectarCollector bees won’t help us if  we have a bee that can do both jobs.
You use an interface to require a class to include all of the methods and properties listed inside the interface—if it doesn’t, the compiler will throw an error.
The queen’s DefendTheHive() method can only tell StingPatrol objects to keep the hive safe.
She’d love to train the other bees to use their stingers, but she doesn’t have any way to command them to attack:
There are NectarCollector objects that know how to collect nectar from flowers, and instances of  StingPatrol that can sharpen their stingers and patrol for enemies.
But even if  the queen could teach the NectarCollector to defend the hive by adding methods like SharpenStinger() and LookForEnemies() to its class definition, she still couldn’t pass it into her DefendTheHive() method.
Even if the queen adds sting patrol methods to a NectarCollector object, she still can’t pass it to her DefendTheHive() method because it expects a StingPatrol reference.
She can’t just set a StingPatrol reference equal to a NectarCollector object.
Both of  those methods would be identical, because they’d call the same methods in the objects passed to them.
The only difference is that one method would take a StingPatrol, and the other would take a NectarCollector that happens to have the methods necessary for patrolling the hive.
And you already know how painful it is to maintain two identical methods.
Luckily, C# gives us interfaces to handle situations like that.
Interfaces let you define a bunch of  methods that a class must have.
An interface requires that a class has certain methods, and the way that it does that is by making the compiler throw errors if  it doesn’t find all the methods required by the interface in every class that implements it.
Those methods can be coded directly in the class, or they can be inherited from a base class.
The interface doesn’t care how the methods or properties get there, as long as they’re there when the code is compiled.
If she wanted to teach the BabyBeeCare or Maintenance objects to defend the hive, she’d need to keep adding new methods.
Any class that implements this method must have all of these methods and properties, or the program won’t compile.
Everything in a public interface is automatically public, because you’ll use it to define the public methods and properties of any class that implements it.
Interface names start with I Whenever you create an interface, you should make its name start with an uppercase I.
Just go into the IDE to any blank line inside any method.
Use the interface keyword to def ine an interface Adding an interface to your program is a lot like adding a class, except you never write any methods.
You just define the methods’ return type and parameters, but instead of  a block of  statements inside curly brackets you just end the line with a semicolon.
Interfaces do not store data, so you can’t add any fields.
The reason is that get and set accessors are just methods, and interfaces are all about forcing classes to have certain methods with specific names, types, and parameters.
So if  you’ve got a problem that looks like it could be solved by adding a field to an interface, try using a property instead—odds are, it’ll do what you’re looking for.
Any class that implements this interface will need a SharpenStinger() method that takes an int parameter.
Now that I know you can defend the hive, we’ll all be a lot safer!
So how does this help the queen? Now she can make one single method that takes any object that knows how to defend the hive:
This gives the queen a single method that can take a StingPatrol, NectarStinger, and any other bee that knows how to defend the hive—it doesn’t matter which class she passes to the method.
As long as it implements IStingPatrol, the DefendTheHive() method is guaranteed that the object has the methods and properties it needs to defend the hive.
Since this takes an IStingPatrol reference, you can pass it ANY object that implements IStingPatrol.
Q: I still don’t quite get how interfaces improve the beehive code.
You’ll still need to add a NectarStinger class, and it’ll still have duplicate code…right?
You implement an interface with a colon operator, just like you inherit.
You can use more than one interface if you separate them with commas.
Every method in the interface has a method in the class.
When you create a NectarStinger object, it will be able to do the job of both a NectarCollector and a StingPatrol worker bee.
This class inherits from Worker and implements INectarCollector and IStingPatrol.
The NectarStinger sets the backing field for the AlertLevel property in its LookForEnemies() method.
When you’ve got a class that implements an interface, it acts just like any other class.
You can instantiate it with new and use its methods:
Now you can create an instance of NectarSt inger that does both jobs You use the colon operator to implement an interface, just like you do for inheritance.
It works like this: the first thing after the colon is the class it inherits from, followed by a list of  interfaces—unless it doesn’t inherit from a class, in which case it’s just a list of  interfaces (in no particular order)
The bee retracts its stinger when there are no enemies around, so the backing field changes its value over time.
Classes that implement interfaces have to include ALL of the interface’s methods Implementing an interface means that you have to have a method in the class for each and every property and method that’s declared in the interface—if  it doesn’t have every one of  them, it won’t compile.
If  a class implements more than one interface, then it needs to include all of  the properties and methods in each of  the interfaces it implements.
Create a new application and add a new class file called IStingPatrol.cs Instead of  adding a class, type in the IStingPatrol interface from two pages ago.
Add a Bee class to the project Don’t add any properties or methods yet.
Try to compile the program Select “Rebuild” from the Build menu.
Add the methods and properties to the Bee class Add a LookForEnemies method and a SharpenStinger method—they don’t have to do anything, they just need to compile.
Then add a get accessor for an int called AlertLevel and get and set accessors for an int called StingerLength.
You’ll see one of these “does not implement” errors for.
You don’t need to type “public” inside the interface, because it automatically makes every property and method public.
You already know that everything inside an interface has to be public.
Create a new project and declare an interface on your own, like this:
Now try to declare a private method inside the interface:
Now go ahead and delete the private access modifier—the error will go away and your program will compile just fine.
Before you go on to the next page, see if  you can create the rest of  the IClown interface, and modify the TallGuy class to implement this interface.
Add your interface to your project just like you add a class: right-click on the project in the Solution Explorer and add a class file called IClown.cs.
Your new IClown interface should have a void method called Honk that doesn’t take any parameters, and a string read-only property called FunnyThingIHave that has a get accessor but no set accessor.
Get a li t t le pract ice using interfaces Interfaces are really easy to use, and the best way to understand them is to start using them.
So create a new Windows Forms Application project, drag a button onto the form, and get started!
OK, now modify the TallGuy class so that it implements IClown.
Remember, the colon operator is always followed by the base class to inherit from (if  any), and then a list of  interfaces to implement, all separated by commas.
Since there’s no base class and only one interface to implement, the declaration looks like this:
Then make sure the rest of  the class is the same, including the two fields and the method.
Select “Build Solution” from the Build menu in the IDE to compile and build the program.
The errors will go away as soon as you add all of  the methods and properties defined in the interface.
Add a readonly string property called FunnyThingIHave with a get accessor that always returns the string “big shoes”
Then add a Honk() method that pops up a message box that says, “Honk honk!”
Now your code will compile! Update your button so that it calls the TallGuy object’s Honk() method.
All the interface req uires is that a class t.
The interface says that you need a public void method called Honk, but it doesn’t say what that method needs to do.
It can do anything at all—no matter what it does, the code will compile as long as some method is there with the right signature.
What the IDE is telling you is that when you said TallGuy would implement IClown, you promised to add all of the properties and methods in that interface…and then you broke that promise!
Here’s an example of an interface that has a get accessor without a set accessor.
Remember, interfaces can’t contain fields, but when you implement this read-only property in a class, it’ll look like a field to other objects.
You can’t instant iate an interface, but you can reference an interface Say you had a method that needed an object that could perform the FindFlowers() method.
It could be a Worker object, Robot object, or Dog object, as long as it implements the INectarCollector interface.
You can use one to refer to an object that implements the interface you need and you’ll always be sure that it has the right methods for your purpose—even if  you don’t know much else about it.
The first line is an ordinary new statement, creating a reference called Fred and pointing it to a NectarStinger object.
The second line is where things start to get interesting, because that line of code creates a new reference variable using IStingPatrol.
That line may look a little odd when you first see it.
You know what this third statement does—it creates a new NectarStinger reference called ginger and points it at whatever object fred is pointing to.
Even though this object can do more, when you use an interface reference you only have access to the methods in the interface.
You can’t use the new keyword with an interface, which makes sense—the methods and properties don’t have any implementation.
If  you could create an object from an interface, how would it know how to behave?
So what happened? There’s only one new statement, so only one object was created.
The second statement created a reference variable called george that can point to an instance of  any class that implements IStingPatrol.
Remember how you could pass a BLT reference into any class that expects a Sandwich, because BLT inherits from Sandwich? Well, this is the same thing—you can use a NectarStinger in any method or statement that expects an IStingPatrol.
You can create an array of IWorker references, but you can’t instantiate an interface.
But what you can do is point those references at new instances of classes.
Now you can have an array that holds many different kinds of.
Interface references work just like object references You already know all about how objects live on the heap.
When you work with an interface reference, it’s just another way to refer to the same objects you’ve already been dealing with.
Create a couple of bees This is totally familiar stuff  by now.
Add IStingPatrol and INectarCollector references You can use interface references just like you use any other reference type.
Assign a new instance to an interface reference You don’t actually need an object reference—you can create a new object and assign it straight to an interface reference variable.
An interface reference will keep an object alive When there aren’t any references pointing to an object, it disappears.
But there’s no rule that says those references all have to be the same type! An interface reference is just as good as an object reference when it comes to keeping track of  objects.
This object didn’t disappear because defender is still pointing to it.
These two statements use interfaces to create new references to existing objects.
You can only point an interface reference at an instance of a class that implements it.
Let’s assume that StingPatrol implements the IStingPatrol interface and NectarCollector implements the INectarCollector interface.
You can f ind out if a class implements a certain interface with “is” Sometimes you need to find out if  a certain class implements an interface.
Suppose we have all our worker bees in an array, called Bees.
We can make the array hold the type Worker, since all worker bees will be Worker classes, or subclasses of that type.
But which of  the worker bees can collect nectar? In other words, we want to know if  the class implements the INectarCollector interface.
We can use the is keyword to find out exactly that.
We’ve got an array of Worker bees who are all eligible to go on a nectar.
Now that we know the be e is a nectar.
If you have some other class that doesn’t inherit from Worker but does implement the INectarCollector interface, then it’ll be able to do the job, too! But since it doesn’t inherit from Worker, you can’t get it into an array with other bees.
Can you think of a way to get around the problem and create an array with both bees and this new class?
We’ll use “is” to sort out which type of worker each bee is.
This is like saying, if this bee implements the INectarCollector interface…do this.
When I put a property in an interface, it looks just like an automatic property.
Does that mean I can only use automatic properties when I implement an interface?
Interfaces can inherit from other interfaces When one class inherits from another, it gets all of  the methods and properties from the base class.
Since there’s no actual method body in any interface, you don’t have to worry about calling base constructors or methods.
The inherited interfaces simply accumulate all of  the methods and properties from the interfaces they inherit from.
Any class that implements an interface that inherits from IWorker must implement its methods and properties When a class implements an interface, it has to include every property and method in that interface.
And if  that interface inherits from another one, then all of  those properties and methods need to be implemented, too.
We’ve created a new IWorker interface that the other interfaces inherit from.
Here’s the same IStingPatrol interface, but now it inherits from the IWorker interface.
It looks like a tiny change, but it makes a huge difference in any class that implements IStingPatrol.
When we draw an interface on a class diagram, we’ll show inheritance using dashed lines.
We can have it inherit from the IWorker interface, though, so it can do everything a normal worker bee can.
The RoboBee class implements all the methods from the IWorker interface.
This is our basic Robot class, so robots can run on gasoline.
Any class can implement ANY interface as long as it keeps the promise of implementing the interface’s methods and properties.
That means it’s a robot, but can do the job of a worker bee.
Remember, for other classes in the application, there’s no functional difference between a RoboBee and a normal worker bee.
They both implement the IWorker interface, so both act like worker bees as far as the rest of  the program is concerned.
But, you could distinguish between the types by using is:
We can see what class or interface workerBee implements or subclasses with “is”
But what if  you don’t know if  that object is the right type? You use is to find that out.
Then, you can use as to treat that object—which you now know is the right type—as having the method you need to call.
All these bees implement IWorker, but we don’t know which ones implement other interfaces, like INectarCollector.
They’re of type IWorker, and don’t know about INectarCollector methods.
For each of these statements, write down which values of i would make it evaluate to true.
For each of these statements, write down which values of i would make it evaluate to true.
A CoffeeMaker is also an Appliance If  you’re trying to figure out how to cut down your energy bill each month, you don’t really care what each of  your appliances does.
So if  you were writing a program to monitor your electricity consumption, you’d probably just write an Appliance class.
But if  you needed to be able to distinguish a coffee maker from an oven, you’d have to build a class hierarchy.
So you’d add the methods and properties that are specific to a coffee maker or oven to some CoffeeMaker and Oven classes, and they’d inherit from an Appliance class that has their common methods and properties.
Here’s a method in the program to monitor the power consumption for a house.
This code would appear later on in the program to monitor the coffee maker’s power consumption.
Even though the MonitorPower() method takes a reference to an Appliance object, you can pass it the misterCoffee reference because CoffeeMaker is a subclass of Appliance.
You already saw this in the last chapter, when you saw how you could pass a BLT reference to a method that expected a Sandwich.
Upcast ing works with both objects and interfaces When you substitute a subclass for a base class—like substituting a coffee maker for an appliance or a BLT for a sandwich—it’s called upcasting.
It’s a really powerful tool that you get when you build class hierarchies.
The only drawback to upcasting is that you can only use the properties and methods of  the base class.
In other words, when you treat a coffee maker like an appliance, you can’t tell it to make coffee or fill it with water.
But you can tell whether or not it’s plugged in, since that’s something you can do with any appliance (which is why the PluggedIn property is part of  the Appliance class)
Let’s create some objects We can create a CoffeeMaker and Oven class as usual:
What if we want to create an array of appliances? You can’t put a CoffeeMaker in an Oven[ ] array, and you can’t put an Oven in a CoffeeMaker[ ] array.
But you can put both of  them in an Appliance[ ] array:
But you can’t treat an appliance like an oven When you’ve got an Appliance reference, you can only access the methods and properties that have to do with appliances.
You can’t use the CoffeeMaker methods and properties through the Appliance reference even if  you know it’s really a CoffeeMaker.
So these statements will work just fine, because they treat a CoffeeMaker object like an Appliance:
But as soon as you try to use it like a CoffeeMaker:
This line won’t compile because powerConsumer is an Appliance reference, so it can only be used to do Appliance things.
We’ll start by instantiating an Oven object and a CoffeeMaker object as usual.
When downcast ing fails, as returns null So what happens if  you try to use as to convert an Oven object into a CoffeeMaker? It returns null—and if  you try to use it, .NET will cause your program to break.
Downcast ing le ts you turn your appliance back into a coffee maker Upcasting is a great tool, because it lets you use a coffee maker or an oven anywhere you just need an appliance.
But it’s got a big drawback—if  you’re using an Appliance reference that points to a CoffeeMaker object, you can only use the methods and properties that belong to Appliance.
And that’s where downcasting comes in: that’s how you take your previously upcast reference and change it back.
You can figure out if  your Appliance is really a CoffeeMaker using the is keyword.
And once you know that, you can convert the Appliance back to a CoffeeMaker using the as keyword.
We’ll start with the CoffeeMaker we already upcast Here’s the code that we used:
But what if we want to turn the Appliance back into a CoffeeMaker? The first step in downcasting is using the is keyword to check if  it’s even an option.
Now that we know it’s a CoffeeMaker, let’s use it like one The is keyword is the first step.
Once you know that you’ve got an Appliance reference that’s pointing to a CoffeeMaker object, you can use as to downcast it.
And that lets you use the CoffeeMaker class’s methods and properties.
And since CoffeeMaker inherits from Appliance, it still has its Appliance methods and properties.
Here’s our Appliance reference that points to a CoffeeMaker object from the last page.
The javaJoe reference points to the same CoffeeMaker object as powerConsumer.
But it’s a CoffeeMaker reference, so it can call the MakeCoffee() method.
So when you try to downcast it with “as”, the foodWarmer reference ends up set to null.
And when you try to use a null reference, this happens....
Upcast ing and downcast ing work with interfaces, too You already know that is and as work with interfaces.
Well, so do all of  the upcasting and downcasting tricks.
Let’s add an ICooksFood interface for any class that can heat up food.
And we’ll add a Microwave class—both Microwave and Oven implement the ICooksFood interface.
Now there are three different ways that you can access an Oven object.
And the IDE’s IntelliSense can help you figure out exactly what you can and can’t do with each of  them:
Any class that implements ICooksFood is an appliance that can heat up food.
Three different references that point to the same object can access different methods and properties, depending on the reference’s type.
It can only access ICooksFood members, but it can also point to a Microwave object.
It only lets you get to the public fields, methods, and properties in Appliance.
You can also point it at a CoffeeMaker object if you want.
As soon as you type the dot, the IntelliSense window will pop up with a list of all of the members you can use.
Q:So back up—you told me that I can always upcast but I can’t always downcast.
Q:Someone told me that an interface is like a contract, but I don’t really get why.
Q:What if I want to put a method body into my interface? Is that OK?
Q:Then why would I want to use an interface? It seems like it’s just adding restrictions, without actually changing my class at all.
Q:Is there an easier way to implement interfaces? It’s a lot of typing!
An interface is like a checklist that the compiler runs through to make sure your class implemented a certain set of methods.
Sometimes it’s hard to click on the icon, but Ctrl-period will work, too.
Extend IClown by creating a new interface, IScaryClown, that inherits from IClown.
A funny clown class called FunnyFunny that uses a private string variable to store a funny thing.
Use a constructor that takes a parameter called FunnyThingIHave and uses it to set the private field.
The Honk()method should say, “Honk honk! I have a ” followed by the funny thing it has.
The ScaryThingIHave get accessor should return a string consisting of  the number from the constructor followed by “spiders”
You can set a FunnyFunny reference equal to a ScaryScary object because ScaryScary inherits from FunnyFunny.
But you can’t set any IScaryClown reference to just any clown, because you don’t know if that clown is scary.
You could have implemented the IClown method and property again, but why not just inherit from FunnyFunny?
The Honk() method just uses this set accessor to display its message—no need to have the same code twice.
There’s more than just public and pri vate You already know how important the private keyword is, how you use it, and how it’s different from public.
C# has a name for these keywords: they’re called access modifiers.
The name makes sense, because when you change an access modifier on a property, field, or method of  a class—its members—or the entire class, you change the way other classes can access it.
There are a few more access modifiers that you’ll use, but we’ll start with the ones you know:
We call a class’s methods, fields, and properties its members.
Any member can be marked with the public or private access modifier.
Wouldn’t it be convenient if  the subclass could access those private fields? That’s why you have the protected access modifier.
Any class member marked protected can be accessed by any other member of  its class, and any member of  a subclass of  its class.
You can see a list of  assemblies by right-clicking on “References” in the Solution Explorer and choosing “Add Reference…”—when you create a new Windows Forms application, the IDE automatically includes the references you need to build a Windows application.
When you build an assembly, you can use the internal keyword to keep classes private to that assembly, so you can only expose the classes you want.
You can combine this with protected—anything you mark protected internal can only be accessed from within the assembly or from a subclass.
A lot of  the .NET Framework classes are like this—go ahead, try to make a class that inherits from String (that’s the class whose IsEmptyOrNull() method you used in the last chapter)
What happens? The compiler won’t let you build your code—it gives you the error “cannot derive from sealed type ‘string’”
You can do that with your own classes—just add sealed after the access modifier.
If you leave off the access modifier when you declare a class member, it defaults to private.
If you leave off the access modifier when you declare a class or an interface, then by default it’s set to internal.
And that’s just fine for most classes—it means that any other class in the assembly can read it.
If you’re not using multiple assemblies, internal will work just as well as public for classes and interfaces.
Give it a shot—go to an old project, change some of the classes to internal, and see what happens.
Sealed is a modifier, but it’s not an access modifier.
That’s because it only affects inheritance—it doesn’t change the way the cla.
Take a peek at leftover #2 in the appendix to learn more about them.
Access modif iers change v isibi li t y Let’s take a closer look at the access modifers and how they affect the scope of  the various class members.
This is a really common way to use “this”, since the parameter and backing field have the same name.
Then change the protected access modifier back to private and see what errors you get.
By adding “this”, we told C# that we’re talking about the backing field, not the parameter that has the same name.
The “this” keyword also changes what variable you’re referring to.
It says to C#, “Look at the current instance of the class to find whatever I’m connected to—even if that matches a parameter or local variable.”
When you use “this” with a property, it tells C# to execute the set or get accessor.
IClown defines a clown who honks his horn and has a funny thing.
A scary clown does everything a clown does, plus he has a scary thing and scares little children.
We made the funnyThingIHave field protected so that it can be accessed by any instance of  a subclass of  FunnyFunny.
The protected keyword tells C# to make something private to everyone except instances of a subclass.
If we’d left funnyThingIHave private, this would cause the compiler to give you an error.
But when we changed it to protected, that made it visible to any subclass of FunnyFunny.
Since this button click event handler is not part of FunnyFunny and ScaryScary, it can’t access the protected funnyThingIHave field.
The “base” keyword tells C# to use the value from the base class.
So only another instance of ScaryScary would be able to see it.
It also inherits from FunnyFunny, and since FunnyFunny implements IClown, that means ScaryScary does, too.
If  we’d made it private instead, then this code wouldn’t compile.
Take a look at how it uses as to downcast someFunnyClown to an IScaryClown reference.
We put in some extra steps to show you that you could upcast ScaryScary to FunnyFunny, and then downcast that to IScaryClown.
But all three of those lines could be collapsed into a single line.
Q: Why would I want to use an interface instead of just writing all of the methods I need directly into my class?
Q:Why do I need to use a property? Can’t I just include a field?
Q:What’s the difference between a regular object reference and an interface reference?
Q: Then why would I ever want to use an interface reference if it limits what I can do with the object?
Q: Why would I make something protected instead of private or public?
Interface references only know about the methods and properties that are defined in the interface.
Let’s start with a basic class for a student shopping at the student bookstore.
Remember our zoo simulator class hierarchy? You’ll definitely end up instantiating a bunch of  hippos, dogs, and lions.
But what about the Canine and Feline classes? How about the Animal class? It turns out that there are some classes that just don’t need to be instantiated…and, in fact, don’t make any sense if  they are.
The ArtStudent and EngineeringStudent classes both override the BuyFavoriteStuff() method, but they buy very different things.
So what happens when you instantiate Shopper? Does it ever make sense to do it?
A method that has a declaration but no statements or method body is called an abstract method.
Inheriting classes must implement all abstract methods, just like when they inherit from an interface.
An abstract class is like a cross bet ween a class and an interface Suppose you need something like an interface, that requires classes to implement certain methods and properties.
But you need to include some code in that interface, so that certain methods don’t have to be implemented in each inheriting class.
You get the features of  an interface, but you can write code in it like a normal class.
If you put an abstract method into a class, then you’ll have to mark that class abstract or it won’t compile.
You’ll learn more about how to mark a class abstract in a minute.
An abstract class is like a normal class You define an abstract class just like a normal one.
It has fields and methods, and you can inherit from other classes, too, exactly like with a normal class.
There’s almost nothing new to learn here, because you already know everything that an abstract class does!
An abstract class is like an interface When you create a class that implements an interface, you agree to implement all of  the properties and methods defined in that interface.
An abstract class works the same way—it can include declarations of  properties and methods that, just like in an interface, must be implemented by inheriting classes.
But an abstract class can’t be instantiated The biggest difference between an abstract class and a concrete class is that you can’t use new to create an instance of  an abstract class.
If  you do, C# will give you an error when you try to compile your code.
A concrete method is one that has a body, and all the classes you’ve been working with so far are concrete classes.
This error is because you have abstract methods without any code! The compiler won’t let you instantiate a class with missing code, just like it wouldn’t let you instantiate an interface.
Cannot create an instance of the abstract class or interface ‘MyClass’
Because you want to provide some code, but still require that subclasses fill in the rest of the code.
Sometimes bad things happen when you create objects that should never be created.
The class at the top of  your class diagram usually has some fields that it expects its subclasses to set.
An Animal class may have a calculation that depends on a Boolean called HasTail or Vertebrate, but there’s no way for it to set that itself.
Wait, what? A class that I can’t instantiate? Why would I even want something like that?
Before you flip the page, try to figure out what will happen when the user clicks the third button....
The constructors for the Mars and Venus subclasses set the three fields they inherited from Planet.
But those fields won’t get set if you instantiate Planet directly.
It doesn’t make sense to set these fields in the base class, because we don’t know what rocket or planet we’ll be using.
Here’s a class that the Objectville Astrophysics Club uses to send their rockets to different planets.
The astrophysicists have two missions—one to Mars, and one to Venus.
Like we said, some classes should never be instant iated The problems all start when you create an instance of  the PlanetMission class.
Its FuelNeeded() method expects the fields to be set by the subclass.
When the FuelNeeded() method tried to divide by RocketSpeedMPH, it was zero.
But we did instantiate it, and that’s where the problems started.
Solut ion: use an abstract class When you mark a class abstract, C# won’t let you write code to instantiate it.
It’s a lot like an interface—it acts like a template for the classes that inherit from it.
Now C# will refuse to compile our program until we remove the line that creates an instance of PlanetMission.
Adding the abstract keyword to the class declaration tells C# this is an abstract class, and can’t be instantiated.
Flip back to the solution to Kathleen’s party planning program in the previous chapter on pages 254–256, and take another look at the encapsulation problems that we left in the code.
Can you figure out how you’d use an abstract class to solve them?
An abstract method doesn’t have a body You know how an interface only has declarations for methods and properties, but it doesn’t actually have any method bodies? That’s because every method in an interface is an abstract method.
So let’s implement it! Once we do, the error will go away.
Any time you extend an abstract class, you need to make sure that you override all of  its abstract methods.
Just type “public override”—as soon as you press space, the IDE will display a drop-down box with a list of  any methods that you can override.
If  we add that method in and try to build the program, the IDE gives us an error:
So let’s implement it! Once we do, the error will go away.
Every method in an interface is automatically abstract, so you don’t need to use the abstract keyword in an interface, just in an abstract class.
Only abstract classes can have abstract methods… but they can have concrete methods too.
When you inherit from an abstract class, you need to override all of its abstract methods.
On the left you’ll find sets of class and interface declarations.
Your job is to draw the associated class diagrams on the right.
Don’t forget to use a dashed line for implementing an interface and a solid line for inheriting from a class.
Your job is to turn these into valid C# declarations.
Tonight’s talk: An abstract class and an interface butt heads over the pressing question, “Who’s more important?”
I think it’s obvious who’s more important between the two of  us.
Sure, I can’t be instantiated but then, neither can you.
And I can do pretty much anything else a regular class does.
Implementation is as good as inheritance, in fact it’s better!
Yeah? What if  you want a class that inherits from you and your buddy? You can’t inherit from two classes.
And that’s just plain rude! There’s no limit to the number of  interfaces a class can implement.
Talk about flexible! With me, a programmer can make a class do anything.
That’s exactly the kind of  drivel I’d expect from an interface.
Code is extremely important! It’s what makes your programs run.
Really? I doubt that—programmers always care what’s in their properties and methods.
You think that just because you can contain code, you’re the greatest thing since sliced bread.
But you can’t change the fact that a program can only inherit from one class at a time.
Nine times out of  ten, a programmer wants to make sure an object has certain properties and methods, but doesn’t really care how they’re implemented.
But think about how many times you’ve seen a programmer write a method that takes an object that just needs to have a certain method, and it doesn’t really matter right at that very moment exactly how the method’s built.
So bang! The programmer just needs to write an interface.
I’m still hung up on not being able to inherit from two classes.
I can’t inherit from more than one class, so I have to use interfaces.
If  C# let you inherit from more than one base class, it would open up a whole can of  worms.
When a language lets one subclass inherit from two base classes, it’s called multiple inheritance.
And by giving you interfaces instead, C# saves you from a big fat mess that we like to call....
Which ShowAMovie() method runs when you call ShowAMovie() on the HomeTheater object?
If  Television and MovieTheater are interfaces instead of  classes, then the same ShowAMovie() method can satisfy both of  them.
All the interface cares about is that there’s some method called ShowAMovie()
Television and MovieTheater both inherit from MoviePlayer, and both override the ShowAMovie() method.
Note: Each snippet from the pool can be used more than once!
Pool Puzzle Your job is to take code snippets from the pool and place them into the blank lines in the code and output.
You may use the same snippet more than once, and you won’t need to use all the snippets.
Your goal is to make a set of classes that will compile and run and produce the output listed.
OK, I think I’ve got a pretty good handle on objects now!
Before languages like C# came along, people didn’t use objects and methods when writing their code.
They just used functions (which is what they call methods in a non-OOP program) that were all in one place—as if  each program were just one big static class that only had static methods.
It made it a lot harder to create programs that modeled the problems they were solving.
Luckily, you’ll never have to write programs without OOP, because it’s a core part of  C#
The four principles of object oriented programming When programmers talk about OOP, they’re referring to four important principles.
They should seem very familiar to you by now because you’ve been working with every one of  them.
You’ll recognize the first three principles just from their names: inheritance, abstraction, and encapsulation.
It sounds a little odd, but it turns out that you already know all about it too.
Encapsulation means creating an object that keeps track of its state internally using private fields, and uses public properties and methods to let other classes work with only the part of the internal data that they need to see.
You’re using abstraction when you create a class model that starts with more general—or abstract—classes, and then has more specific classes that inherit from it.
Can you think of a time when an object has taken on many forms in your code?
This just means having one class or interface that inherits from another.
The idea that you could combine your data and your code into classes and objects was a revolutionary one when it was first introduced—but that’s how you’ve been building all your C# programs so far, so you can think of it as just plain programming.
Polymorphism means that one object can take many different forms Any time you use a mockingbird in place of  an animal or aged Vermont cheddar in a recipe that just calls for cheese, you’re using polymorphism.
That’s what you’re doing any time you upcast or downcast.
It’s taking an object and using it in a method or a statement that expects something else.
Keep your eyes open for polymorphism in the next exercise! You’re about to do a really big exercise—the biggest one you’ve seen so far—and you’ll be using a lot of  polymorphism in it, so keep your eyes open.
Here’s a list of  four typical ways that you’ll use polymorphism.
We gave you an example of  each of  them (you won’t see these particular lines in the exercise, though)
As soon as you see similar code in what you write for the exercise, check it off  the following list:
Taking any reference variable that uses one class and setting it equal to an instance of  a different class.
You’re using polymorphism when you take an instance of one class and use it in a statement or a method that expects a different type, like a parent class or an interface that the class implements.
Upcasting by using a subclass in a statement or method that expects its base class.
Creating a reference variable whose type is an interface and pointing it to an object that implements that interface.
If FeedAnAnimal() expects an Animal object, and Dog inherits from Animal, then you can pass Dog to FeedAnAnimal()
It uses as to point a HiveMaintainer reference to the worker.
You can move between the back yard and the front yard, and both of them connect to the garden.
You’ll need the blueprint for the house This house has three rooms, a front yard, a back yard, and a garden.
There are two doors: the front door connects the living room to the front yard, and the back door connects the kitchen to the back yard.
The living room connects to the dining room, which also connects to the kitchen.
Use the IHasExteriorDoor interface for rooms with an exterior door There are two exterior doors in the house, the front door and the back door.
Every location that has one (the front yard, back yard, living room, and kitchen) should implement IHasExteriorDoor.
The DoorDescription read-only property contains a description of  the door (the front door is “an oak door with a brass knob”, the back door is “a screen door”)
The DoorLocation property contains a reference to the Location where the door leads (kitchen)
Inside locations each have some kind of a decoration in a read-only property.
This symbol is an exterior door between the front yard and the living room.
There’s also an exterior door between the kitchen and back yard.
Outside locations can be hot, so the Outside class has a read-only Boolean property called Hot.
That’s why we shaded it darker in the class diagram.
All rooms have doors, but only a few rooms have an exterior door that leads inside or outside the house.
Here’s the Location class To get you started, here’s the Location class:
Remember, Location is an abstract class—you can inherit from it and declare reference variables of type Location, but you can’t instantiate it.
The constructor sets the name field, which is the read-only Name property’s backing field.
The Room class will override and extend Description to add the decoration, and Outside will add the temperature.
Create the classes First create the Room and Outside classes based on the class model.
Then create two more classes: OutsideWithDoor, which inherits from Outside and implements IHasExteriorDoor, and RoomWithDoor, which subclasses Room and implements IHasExteriorDoor.
Here are the class declarations to give you a leg up:
The Description property returns a string that describes the room, including the name and a list of all of the locations it connects to (which it finds in the Exits[] field)
Its subclasses will need to change the description slightly, so they’ll override it.
This one’s going to be a pretty big exercise…but we promise it’s a lot of fun! And you’ll definitely know this stuff once you get through it.
Get the classes started now—we’ll give you more details about them on the next page.
Finish building the classes, and instantiate their instances You’ve got all the classes—now it’s time to finish them and build your objects.
You’ll need to make sure that the constructor for the Outside class sets the read-only Hot property and overrides the Description property to add the text “It’s very hot here.” if  Hot is true.
It’s hot in the back yard but not the front yard or garden.
The constructor for Room needs to set the Decoration, and should override the Description property to add, “You see (the decoration) here.” The living room has an antique carpet, the dining room has a crystal chandelier, and the kitchen has stainless steel appliances and a screen door that leads to the back yard.
Your form needs to create each of  the objects and keep a reference to each one.
So add a method to the form called CreateObjects() and call it from the form’s constructor.
Your CreateObjects() method needs to populate the Exits[] field in each object:
How your house objects work Here’s the architecture for two of  your objects, frontYard and diningRoom.
Since each of them has a door, they both need to be instances of  a class that implements IHasExteriorDoor.
The DoorLocation property keeps a reference to the location on the other side of  the door.
FrontYard is an OutsideWithDoor object, which is a subclass of Outside that implements IHasExteriorDoor.
LivingRoom is an instance of RoomWithDoor, which inherits from Room and implements IHasExteriorDoor.
Exits is an array of Location references, so this line creates one that has two references in it.
You started building the IHasExteriorDoor interface and added these two classes that implement it.
One inherits from Room, the other is a subclass of Outside.
Every location will have its own field in the form class.
Build a form to explore the house Build a simple form to let you explore the house.
It’ll have a big multiline text box called description to show the description of  the current room.
A ComboBox called exits lists all of  the exits in the current room.
It’s got two buttons: goHere moves to the room selected in the ComboBox, and goThroughTheDoor is only visible when there’s an exterior door.
This is a multiline TextBox that displays the Description() of the current location.
This button is only visible when you’re in a room with an exterior door.
You can make it visible or invisible by setting its Visible property to true or false.
The ComboBox contains a list of all of the exits, so name it exits.
Now you just need to make the form work! You’ve got all the pieces, now you just need to put them together.
You’ll need a field in your form called currentLocation to keep track of  your current location.
This method should first set currentLocation to the new location.
Then it’ll clear the combo box using its Items.Clear() method, and then add the name of  each location in the Exits[ ] array using the combo box’s Items.Add() method.
Finally, reset the combo box so it displays the first item in the list by setting its SelectedIndex property to zero.
Set the text box so that it has the description of  the current location.
Use the is keyword to check if  the current location has a door.
If  it does, make the “Go through the door” button visible using its Visible property.
If  the “Go here:” button is clicked, move to the location selected in the combo box.
If  the “Go through the door” button is clicked, move to the location that the door connects to.
Hint: When you choose an item in the combo box, its selected index in the combo box will be the same as the index of the corresponding location in the Exits[] array.
Another hint: Your form’s currentLocation field is a Location reference.
You’ll need to downcast if you want to get the door location out of the object.
The Room class inherits from Location and adds a backing field for the read-only Decoration property.
It does everything that the room does, but it adds a description of the exterior door to the constructor.
It also adds DoorLocation, a reference to the location that the door leads to.
Outside is a lot like Room—it inherits from Location, and adds a backing field for the Hot property, which is used in the Description() method extended from the base class.
OutsideWithDoor inherits from Outside and implements IHasExteriorDoor, and it looks a lot like RoomWithDoor.
The base class’s Description property fills in whether or not the location is hot.
And that relies on the original Location class’s Description property to add the main description and exits.
The form uses these reference variables to keep track of each of the rooms in the house.
This is how the form keeps track of which room is being displayed.
The form’s constructor creates the objects and then uses the MoveToANewLocation method.
When the form creates the objects, first it needs to instantiate the classes and pass the right information to each one’s constructor.
Here’s where the Exits[] array for each instance is populated.
We need to wait to do this until after all the instances are created, because otherwise we wouldn’t have anything to put into each array!For the IHasExteriorDoor objects, we need to set their door locations.
Here’s where we pass the door description to the OutsideWithDoor constructors.
But we’re not done yet ! It’s fine to create a model of  a house, but wouldn’t it be cool to turn it into a game? Let’s do it! You’ll play Hide and Seek against the computer.
We’ll need to add an Opponent class and have him hide in a room.
And we’ll need to make the house a lot bigger.
Oh, and he’ll need someplace to hide! We’ll add a new interface so that some rooms can have a hiding place.
Finally, we’ll update the form to let you check the hiding places, and keep track of  how many moves you’ve made trying to find your opponent.
First we need to clear the combo box, then we can add each of the locations’ names to it.
Finally, we set its selected index (or which line is highlighted) to zero so it shows the first item in the list.
This makes the “Go through the door” button invisible if the current location doesn’t implement IHasExteriorDoor.
When the user clicks the “Go here:” button, it moves to the location selected in the combo box.
We need to use the as keyword in order to downcast currentLocation to an IHasExteriorDoor so we can get access to the DoorLocation field.
Add an IHidingPlace interface We don’t need to do anything fancy here.
Any Location subclass that implements IHidingPlace has a place for the opponent to hide.
Give it a get accessor, but no set accessor—we’ll set this in the constructor, since once a room has a hiding place we won’t ever need to change it.
Add a class for your opponent The Opponent object will find a random hiding place in the house, and it’s your job to find him.
He’ll need a private Location field (myLocation) so he can keep track of  where he is, and a private Random field (random) to use when he moves to a random hiding place.
The constructor takes the starting location and sets myLocation to it, and sets random to a new instance of  Random.
He starts in the front yard (that’ll be passed in by the form), and moves from hiding place to hiding place randomly.
When he encounters an exterior door, he flips a coin to figure out whether or not to go through it.
Add a Move() method that moves the opponent from his current location to a new location.
Then he chooses one of the exits from his current location at random and goes through it.
If  that location doesn’t have a hiding place, then he’ll do it again—he’ll choose a random exit from his current location and go there, and he’ll keep doing it over and over until he finds a place to hide.
Add a Check() method that takes a location as a parameter and returns true if  he’s hiding in that location, or false otherwise.
Add more rooms to the house Update your CreateObjects() method to add more rooms:
Add stairs with a wooden bannister that connect the living room to the upstairs hallway, which has a picture of  a dog and a closet to hide in.
The upstairs hallway connects to three rooms: a master bedroom with a large bed, a second bedroom with a small bed, and a bathroom with a sink and a toilet.
Someone could hide under the bed in either bedroom or in the shower.
The front yard and back yard both connect to the driveway, where someone could hide in the garage.
Also, someone could hide in the shed in the garden.
Create a new project, and use the IDE’s “Add Existing Item” feature to add the classes from the first part of the exercise.
So every room with an exterior door will also have a hiding place.
OK, time to update the form You’ll need to add a few buttons to the form.
And we’ll get a little more intricate with making them visible or invisible, depending on the state of  the game.
When the game first starts, the hide button is the only one displayed.
This is the button you’ll use to check the room’s hiding place.
Add a method to redraw the form, and another one to reset the game Add a RedrawForm() method that puts the right text in the description text box, makes the buttons visible or invisible, and puts the correct label on the middle button.
Then add a ResetGame() method that’s run when you find your opponent.
It resets the opponent object so that he starts in the front yard again—he’ll hide when you click the “Hide!” button.
It should leave the form with nothing but the text box and “Hide!” button visible.
The text box should say where you found the opponent, and how many moves it took.
Make the buttons work There are two new buttons to add to the form.
The middle button checks the hiding place in the current room and is only visible when you’re in a room with a place to hide using the opponent’s Check() method.
After each number, it tells the opponent to move by calling his Move() method.
Then it shows, “Ready or not, here I come!” for half  a second, and then the game starts.
Make it look right when you start the program When you first start the program, all you should see is an empty text box and the “Hide!” button.
Keep track of how many moves the player made Make sure the text box displays the number of  times you checked a hiding place or moved between rooms.
When you find the opponent, he should pop up a mesage box that says, “You found me in X moves!”
Flip back to Chapter 2 for a refresher on DoEvents() and Sleep()—they’ll come in handy.
It just has one string field with a get accessor that returns the name of the hiding place.
It creates a new instance of Random, which it uses to move randomly between rooms.
The Move() method first checks if the current room has a door using the is keyword—if so, it has a 50% chance of going through it.
Then it moves to a random location, and keeps moving until it finds a hiding place.
The guts of the Move() method is this while loop.
It keeps looping until the variable hidden is true—and it set.
The Check() method just checks the opponent’s location against the location that was passed to it using a Location reference.
If they point to the same object, then he’s been found!
It uses them to keep track of the locations, the opponent, and the number of moves the player has made.
The Form1 constructor creates the objects, sets up the opponent, and then resets the game.
We added a boolean parameter to ResetGame() so that it only displays its message when you win, not when you first start up the program.
RedrawForm() populates the combo box list, sets the text (adding the number of moves), and then makes the buttons visible or invisible depending on whether or not there’s a door or the room has a hiding place.
We need the hiding place name but we’ve only got the CurrentLocation object, which doesn’t have a HidingPlaceName property.
So we can use as to copy the reference to an IHidingPlace variable.
The new CreateObjects() method creates all the objects to build the house.
It’s a lot like the old one, but it has a whole lot more places to go.
Wow—you could add an entire wing onto the house just by adding a couple of lines! That’s why well-encapsulated classes and objects are really useful.
When you click the check button, it checks whether or not the opponent is hiding in the current room.
If not, it redraws the form (to update the number of moves)
The hide button is the one that starts the game.
Then it counts to 10 and tells the opponent to move.
Finally, it makes the first button and the combo box visible, and then starts off the player in the living room.
It displays the final message, then makes all the buttons except the “Hide!” one invisible.
We want to display the name of the hiding place, but CurrentLocation is a Location reference, so it doesn’t give us access to the HidingPlaceName field.
Luckily, we can use the as keyword to downcast it to an IHidingPlace reference that points to the same object.
The goHere and goThroughTheDoor button event handlers are identical to the ones in the first part of this exercise, so flip back a few pages to see them.
Remember DoEvents() from FlashyThing in Chapter 2? Without it, the text box doesn’t refresh itself and the program looks frozen.
Object __________ Programming means creating programs that combine your data and code together into classes and objects.
An interface can't technically include a __________, but it can define getters and setters that look just like one from the outside.
Object __________ Programming means creating programs that combine your data and code together into classes and objects.
An interface can't technically include a __________, but it can define getters and setters that look just like one from the outside.
Here’s where the Acts class calls the constructor in Picasso, which it inherits from.
It passes “Acts” into the constructor, which gets stored in the face property.
Properties can appear anywhere in the class! It’s easier to read your code if they’re at the top, but it’s perfectly valid to have the face property at the bottom of the Picasso class.
Face is a get accessor that returns the value of the face property.
Both of them are defined in Picasso and inherited into the subclasses.
Pool Puzzle Solution from page 305 Your job is to take code snippets from the pool and place them into the blank lines in the code and output.
You may use the same snippet more than once, and you won’t need to use all the snippets.
Your goal is to make a set of classes that will compile and run and produce the output listed.
When you use a pass  subclass to a method that expects its base class, you're using this OOP principle.
The OOP principle where you hide private data and only expose those methods and fields that other classes need access to.
Your class that implements an interface that __________ from another interface, then you need to implement all of its members too.
An access modifier that's not valid for anything inside an interface.
Object __________ Programming means creating programs that combine your data and code together into classes and objects.
When you move common methods from specific classes to more a general class that they all inherit from, you're using this OOP principle.
If a class that implements an interface doesn't implement all of its methods, getters and setters, then the project won't ___________
An abstract class can include both abstract and ____________ methods.
A class that implements this must include all of the methods, getters and setters that it defines.
The is keyword returns true if an ____________ implements an interface.
An interface can't technically include a __________, but it can define getters and setters that look just like one from the outside.
In the real world, you don’t get to handle your data in tiny little bits and.
No, your data’s going to come at you in loads, piles, and bunches.
You’ll need some pretty powerful tools to organize all of it, and that’s where.
They let you store, sort, and manage all the data that.
Strings don’t always work for storing categories of data Suppose you have several worker bees, all represented by Worker classes.
How would you write a constructor that took a job as a parameter? If  you use a string for the job name, you might end up with code that looks like this:
You could probably add code to the Worker constructor to check each string and make sure it’s a valid bee job.
However, if  you add new jobs that bees can do, you’ve got to change this code and recompile the Worker class.
What if  you have other classes that need to check for the types of  worker bees they can be? Now you’ve got to duplicate code, and that’s a bad path to go down.
What we need is a way to say, “Hey, there are only certain values that are allowed here.” We need to enumerate the values that are OK to use.
Our code would allow these values to be passed in a constructor even though the program only supports Sting Patrol, Nectar Collector, and other jobs that a bee does.
But these jobs don’t make any sense for a bee.
The Worker class really shouldn’t allow these types as valid data.
Our bee management software kept track of each worker’s job using a string like “Sting Patrol” or “Nectar Collector”
Enums le t you work with a set of valid values An enum is a data type that only allows certain values for that piece of  data.
So we could define an enum called Jobs, and define the allowed jobs:
Separate each value with a comma, and end the whole thing with a curly brace.
But you can’t just make up a new value for the enum! If  you do, the program won’t compile.
The last enumerator doesn’t have to end with a comma, but using one makes it easier to rearrange them using cut and paste.
The stuff inside the brackets is called the enumerator list, and each item is an enumerator.
You can cast the enum as a number and do calculations with it, or you can use the ToString() method to treat the name as a string.
If  you don’t assign any number to a name, the items in the list will be given values by default.
But what happens if  you want to use really big numbers for one of  the enumerators? The default type for the numbers in an enum is int, so you’ll need to specify the type you need using the : operator, like this:
Enums le t you represent numbers with names Sometimes it’s easier to work with numbers if  you have names for them.
You can assign numbers to the values in an enum and use the names to refer to them.
That way, you don’t have a bunch of  unexplained numbers floating around in your code.
Here’s an enum to keep track of  the scores for tricks at a dog competition:
These don’t have to be in any particular order, and you can give multiple names to the same number.
The (int) cast tells the compiler to turn this into the number it represents.
Since value is equal to 30, score gets set to TrickScore.Fetch.
If you tried to compile this code without specifying long as the type, you’d get thi s message:
Supply a name, then “=”, then the number that name stands in for.
This tells the compiler to treat values in the TrickScore enum as longs, not ints.
You can cast an int to an enum, and you can cast an (int-based) enum back to an int.
Here’s an excerpt from a method that uses the TrickScore enum by casting it to and from an int.
Some enums use a different type, like byte or long—like the one at the bottom of this page—and you can cast those back to their type.
And you’ll need a read-only property, Name (“Ace of Spades”, “Five of Diamonds”)
Use two enums to define the suits and values Use the familiar Add >> Class feature in the IDE to add them, replacing the word class with enum in the newly added files.
Add a property for the name of the card Name should be a read-only property.
The get accessor should return a string that describes the card.
This code will run in a form that calls the Name property from the card class and displays it:
To do this, you can take advantage of  a feature of  the built-in Random class that gives it three different ways to call its Next() method:
To make this work, your Card class will need a constructor that takes two parameters.
When you’ve got more than one way to call a method, it’s called overloading.
The Card class has a Suit property of type Suits, and a Value property of type Values.
The get accessor for the Name property can take advantage of the way an enum’s ToString() method returns its name converted to a string.
Here’s where we use the overloaded Random.Next() method to generate a random number that we cast to the enum.
Here’s the code for the button that pops up the name of a random card.
We could use an array to create a deck of cards… What if  you want to create a class to represent a deck of  cards? It would need a way to keep track of  every card in the deck, and it’d need to know what order they were in.
Here’s a starting point—a Deck that starts out  with a full deck of  52 cards.
How would you add a Shuffle() method to the Deck class that rearranges the cards in random order? What about a method to deal the first card off the top of the deck? How would you add a card to the deck?
This array declaration would continue all the way through the deck.
If you’re playing a card game, you routinely need to change the order of  the cards, and add and remove cards from the deck.
You just can’t do that with an array very easily.
Arrays are hard to work with An array is fine for storing a fixed list of  values or references.
But once you need to move array elements around, or add more elements than the array can hold, things start to get a little sticky.
Every array has a length, and you need to know the length to work with it.
You could use null references to keep some array elements empty:
It’s easy enough to add a Peek() method that just returns a reference to the top card—so you can peek at the top of  the deck.
But what if  you want to add a card? If  topCard is less than the array’s Length, you can just put your card in the array at that index and add 1 to topCard.
But if  the array’s full, you’ll need to create a new, bigger array and copy the existing cards to it.
Removing a card is easy enough—but after you subtract 1 from topCard, you’ll need to make sure to set the removed card’s array index back to null.
You’d need to keep track of  how many cards are being held.
So you’d need an int field, which we could call topCard that would hold the index of  the last card in the array.
We’ll add a topCard field to keep track of how many cards are in the array.
There’s actually an Array.Resize() method built into the .NET Framework that does exactly that.
Lists make it easy to store col lect ions of…anything The .NET Framework has a bunch of  collection classes that handle all of  those nasty issues that come up when you add and remove array elements.
Once you create a List<T> object, it’s easy to add an item, remove an item from any location in the list, peek at an item, and even move an item from one place in the list to another.
First you create a new instance of List<T> Every array has a type—you don’t just have an array, you have an int array, a Card array, etc.
You need to specify the type of  object or value that the list will hold by putting it in angle brackets <> when you use the new keyword to create it.
You specified <Card> when you created the list, so now this list only holds references to Card objects.
You can add as many cards as you want to the List - just call its Add() method.
It’ll make sure it’s got enough “slots” for the items.
If it starts to run out, it’ll automatically resize itself.
A list keeps its elements in order, just like an array.
King of Diamonds is first,  3 of Clubs is second, and Ace of Hearts is third.
The T gets replaced with a type—so List<int> just means a List of ints.You’ll get plenty of  practice with generics over the next few pages.
Which means they’re assignable to the type: interfaces, abstract classes, base classes, etc.
We’ll sometimes leave the <T> off because it can make the book a little hard to read.
Lists are more f lexible than arrays The List class is built into the .NET Framework, and it lets you do a lot of things with objects that you can’t do with a plain old array.
Check out some of  the things you can do with a List<T>
Now you can search for any Egg inside the list.
When we removed y, we left only x in the List, so it shrank! And eventually it will get garbage-collected.
Fill in the rest of the table below by looking at the List code on the left and putting in what you think the code might be if it were using a regular array instead.
We don’t expect you to get all of them exactly right, so just make your best guess.
Hint: You’ll need more than one line of code here.
Assume these statements are all executed in order, one after another.
Lists are objects that use methods just like every other class you’ve used so far.
You can see the list of  methods available from within the IDE just by typing a.
You need to set the size of  the array when you create it, and any logic that’ll need to be performed on it will need to be written on your own.
Your job was to fill in the rest of the table by looking at the List code on the left and putting in what you think the code might be if it were using a regular array instead.
The .NET Framework does have an Array class, which makes some of these things a little easier to do, but we’re concentrating on List objects because they’re a lot easier to use.
This returns the total number of Shoe objects in the List.
It will execute a statement for each object in the List.
As the loop goes through the items, it sets shoe equal to the first item in the list, then the second, then the third, until the loop is done.
The Remove() method will remove the object by its reference; RemoveAt() does it by index number.
The Clear() method removes all of the objects in a List.
The great thing about a List is that you don’t need to know how long it’ll be when you create it.
A List automatically grows and shrinks to fit its contents.
Here’s an example of  a few of  the methods that make working with Lists a lot easier than arrays.
Create a new Console Application and add this code to the Main() method.
It won’t print anything—use the debugger to step through the code and see what’s going on.
This foreach loop goes through each of the shoes in the closet.
Here’s the Shoe class we’re using, and the Style enum it uses.
You can use a new statement inside the List.Add() method.
We saved references to two shoes before we cleared the list.
This line will never run, because Contains() will return false.
We only added thirdShoe into the cleared list, not fifthShoe.
Generics can store any type You’ve already seen that a List can store strings or Shoes.
You could also make Lists of  integers or any other object you can create.
When you create a new List object, you tie it to a specific type: you can have a List of  ints, or strings, or Shoe objects.
That makes working with Lists easy—once you’ve created your list, you always know the type of  data that’s inside it.
The .NET Framework comes with some generic interfaces that let the collections you’re building work with any and all types.
The List class implement those interfaces, and that’s why you could create a List of integers and work with it in pretty much the same way that you would work with a List of  Shoe objects.
Type the word List into the IDE, and then right-click on it and select “Go To Definition”
That will take you to the declaration for the List class.
This doesn’t actually mean that you add the letter T.
It’s a notation that you’ll see whenever a class or interface works with all types.
Code Magnets Can you reconstruct the code snippets to make a working Windows Form that will pop up the message box below when you click a button?
Can you figure out why “2.2” never gets added to the list, even though it’s declared here?
RemoveAt() removes the element at index #2—which is the third element in the list.
The foreach loop goes through all of the elements in the list and prints them.
The printL() method uses a foreach loop to go through a list of strings, add each of them to one big string, and then show it in a message box.
Remember how we talked about using intuitive names back in Chapter 3? Well, that may make for good code, but it makes these puzzles way too easy.
Just don’t use cryptic names like “printL()” in real life!
Q: So why would I ever use an enum instead of a List? Don’t they solve the same problem?
So why would I ever want to use an array?
Why is it called a generic collection? Why isn’t an array generic?
Q: Can I have a list that doesn’t have a type?
When you create a new List object, you always supply a type—that tells C# what type of data it’ll store.
A list can store a value type (like int, bool, or decimal) or a class.
Arrays also take up less memory and CPU time for your programs, but that only accounts for a tiny performance boost.
If you have to do the same thing, say, millions of times a second, you might want to use an array and not a list.
But if your program is running slowly, it’s pretty unlikely that switching from lists to arrays will fix the problem.
The term “generic” refers to the fact that even though a specific instance of List can only store one specific type, the List class in general works with any type.
It’s the way that you tie a specific instance of a List to one type.
But the List class as a whole is generic enough to work with ANY type.
That’s why generic collections are different from anything you’ve seen so far.
Collect ion init ializers work just like object init ializers.
C# gives you a nice bit of  shorthand to cut down on typing when you need to create a list and immediately add a bunch of  items to it.
When you create a new List object, you can use a collection initializer to give it a starting list of  items.
It’ll add them as soon as the list is created.
You saw this code a few pages ago—it creates a new List<Shoe> and fills it with new Shoe objects.
The statement to create the list is followed by curly brackets that contain separate new statements, separated by commas.
You’re not limited to using new statements in the initializer—you can include variables, too.
A collection initializer makes your code more compact by letting you combine creating a list with adding an initial set of items.
You can create a collection initializer by taking each item that was being added using Add() and adding it to the statement that creates the list.
Notice how each Shoe object is initialized with its own object initializer? You can nest them inside a collection initializer, just like this.
Let’s create a List of Ducks Here’s a Duck class that keeps track of  your extensive duck collection.
Each duck has a size—this one is 17 inches long.
Here’s the init ializer for your List of Ducks We’ve got six ducks, so we’ll create a List<Duck> that has  a collection initializer with six statements.
Each statement in the initializer creates a new duck, using an object initializer to set each Duck object’s Size and Kind field.
We’ll use an enum called KindOfDuck to keep track of what sort of ducks are in your collection.
It’s also got some methods, which we’re not showing here.
You’ll be adding code to your Main() method to print to the console.
Make sure you keep this line at the end so the program stays open until you hit a key.
Lists are easy, but SORTING can be tr icky It’s not hard to think about ways to sort numbers or letters.
But what do you sort two objects on, especially if  they have multiple fields? In some cases you might want to order objects by the value in the name field, while in other cases it might make sense to order objects based on height or date of  birth.
There are lots of  ways you can order things, and lists support any of  them.
Lists know how to sort themselves Every list comes with a Sort() method that rearranges all of  the items in the list to put them in order.
Lists already know how to sort most built-in types and classes, and it’s easy to teach them how to sort your own classes.
After the list of ducks is sorted, it’s got the same items in it—but they’re in a different order.
Technically, it’s not the List<T> that knows how to sort itself.
It depends on an IComparer<T> object, which you’ll learn about in a minute.
Sort() uses an object’s CompareTo() method to compare it with other objects, and uses its return value (an int) to determine which comes first.
But sometimes you need to sort a list of  objects that don’t implement IComparable<T>, and .NET has another interface to help with that.
You can pass Sort() an instance of  a class that implements IComparer<T>
The List object’s Sort() method uses the comparer object’s Compare() method to compare pairs of  objects, in order to figure out which one comes first in the sorted list.
An object’s CompareTo() method compares it to another object One way to let our List object sort is to modify the Duck class to implement IComparable<Duck>
To do that, we’d add a CompareTo() method that takes a Duck reference as a parameter.
If  the duck to compare should come after the current duck in the sorted list, CompareTo() returns a positive number.
Update your project’s Duck class by implementing IComparable<Duck> so that it sorts itself  based on duck size:
You can make any class work with the List’s built‑in Sort() method by having it implement IComparable<T> and adding a CompareTo() method.
When you implement IComparable<T>, you specify the type being compared when you have the class implement the interface.
This method first compares the Size field against the other duck’s Size field.
If you want to sort your list from smallest to biggest, have CompareTo() return a positive number if it’s comparing to a smaller duck, and a negative number if it’s comparing to a bigger one.
Add this code to the end of  your Main() method above the call to Console.
ReadKey() to tell your list of  ducks to sort itself.
Use the debugger to see this at work by putting a breakpoint in the CompareTo() method.
Your List will sort differently depending on how you implement IComparer<T>
This class implements IComparer, and specifies the type of object it can sort: Duck objects.
Lists have a special interface built into the .NET Framework that lets you build a separate class to help the List<T> sort out its members.
By implementing the IComparer<T> interface, you can tell your List exactly how you want it to sort your objects.
You do that by implementing the Compare() method in the IComparer<T> interface.
It takes two object parameters, x and y, and returns an int.
If  x is less than y, it should return a negative value.
And if  x is greater than y, it should return a positive value.
Here’s an example of  how you’d declare a comparer class to compare Duck objects by size.
Use IComparer to te l l your List how to sort.
You can do whatever types of comparisons you want in the method.
Any negative number means object x should go before object y.
Here’s a method to print the ducks in a List<Duck>
Add this PrintDucks method to your Program class in your project so you can print the ducks in a list.
Update your Main() method to call it before and after you sort the list so you can see the results!
Create an instance of your comparer object When you want to sort using IComparer<T>, you need to create a new instance of  the class that implements it.
That object exists for one reasonto help List.Sort() figure out how to sort the array.
But like any other (non-static) class, you need to instantiate it before you use it.
Mult iple IComparer implementat ions, mult iple ways to sort your objects You can create multiple IComparer<Duck> classes with different sorting logic to sort the ducks in different ways.
Then you can use the comparer you want when you need to sort in that particular way.
Here’s another duck comparer implementation to add to your project:
We compared the ducks’ Kind properties, so the ducks are sorted based on the index value of the KindOfDuck enum.
Remember, when you compare the enum Kind, you’re comparing their index values.
Notice how “greater than” and “less than” have a different meaning here.
We left out the code you already saw a few pages ago to initialize the list.
Make sure you initialize your list before you try to sort it! If you don’t, you’ll get a null pointer exception.
You’ll pass Sort() a reference to the new DuckComparerBySize object as its parameter.
Add this code to your program’s Main() method to see how the ducks get sorted.
IComparer can do complex comparisons One advantage to creating a separate class for sorting your ducks is that you can build more complex logic into that class—and you can add members that help determine how the list gets sorted.
Its Compare() method takes the same parameters, but it looks at the public SortBy field to determine how to sort the ducks.
This enum tells the object which way to sort the ducks.
If it’s set to SizeThenKind, then it first sorts the ducks by size, and then within each size it’ll sort the ducks by their kind.
If SortBy isn’t set to SizeThenKind, then the comparer first sorts by the kind of duck.
If the two ducks are the same kind, then it compares their size.
Now you can change the way the list sorts it.
If  you don’t provide Sort() with an IComparer<T> object , it uses a default one that can sort value.
Create code to make a jumbled set of cards Create a new Console Application and add code to the Main() method that creates five random Card objects.
Create a class that implements IComparer<Card> to sort the cards Here’s a good chance to use that IDE shortcut to implement an interface:
When you click on the box, the IDE pops up its “Implement interface” window:
Click on “Implement interface IComparer<Card>” in the box to tell the IDE to automatically fill in all of  the methods and properties that you need to implement.
In this case, it creates an empty Compare() method to compare two cards, x and y.
In this case, make sure that any king comes after any jack, which comes after any four, which comes after any ace.
Make sure the output looks right Here’s what your output window should look like after you click the button.
ReadKey() waits for you to press a key before the program ends.
Your IComparer object needs to sort the cards by value, so the cards with the lowest values are first in the list.
Sometimes it’s a little hard to get this box to pop up, so the IDE has a useful shortcut.: just press ctrl-period.
If none of the other four return statements were hit, the cards must be the same—so return zero.
These statements only get executed if x and y have the same value—that means the first two return statements weren’t executed.
Here’s a generic List of Card objects to store the cards.
Once they’re in the list, it’s easy to sort them using an IComparer.
If  you use Ctrl-F5 to start your program, the IDE runs it without debugging.
When it finishes, it prints “Press any key to continue…” and waits for a keypress.
But it doesn’t debug your program (because it’s running without debugging), so.
Every .NET object has a method called ToString() that converts it to a string.
By default, it just returns the name of  your class (MyProject.Duck)
The method is inherited from Object (remember, that’s the base class for every object)
This is a really useful method, and it’s used a lot.
For example, the + operator to concatenate strings automatically calls an object’s ToString()
Put a breakpoint in the Main() method anywhere after the list is initialized and debug your program.
Then hover over any ducks variable so it shows the value in a window.
Any time you look at a variable in the debugger that’s got a reference to a List, you can explore the contents of  it by clicking the + button:
Luckily, ToString() is a virtual method on Object, the base class of  every object.
So all you need to do is override the ToString() method—and when you do, you’ll see the results immediately in the IDE’s Watch window! Open up your Duck class and start adding a new method by typing override.
As soon as you press space, the IDE will show you the methods you can override:
Click on ToString() to tell the IDE to add a new ToString() method.
Now the IDE shows you the contents of  your Ducks!
You can see that there are six Duck objects in the list (“MyProject” is the namespace we used)
If  you click the + button next to a duck, you can see its Kind and Size values.
But wouldn’t it be easier if  you could see all of  them at once?
When the IDE’s debugger shows you an object, it calls the object’s ToString() method and shows you its contents.
That also works with value types like ints and enums, too!
Overriding a ToString() method le ts an object describe itse lf.
The IDE calls the ToString() method when it displays an object in its Watch window.
But the ToString() method that Duck inherited from Object just returns its class name.
It would be really useful if we could make ToString() more informative.
Update your foreach loops to le t your Ducks and Cards print themselves You’ve seen two different examples of  programs looping through a list of  objects and calling Console.
WriteLine() to print a line to the console for each object—like this foreach loop that prints every card in a List<Card>:
The PrintDucks() method did something similar for Duck objects in a List:
This is a pretty common thing to do with objects.
But now that your Duck has a ToString() method, your PrintDucks() method should take advantage of  it:
Add this to your Ducks program and run it again.
And now if  you want to add, say, a Gender property to your Duck object, you just have to update the ToString() method, and everything that uses it (including the PrintDucks() method) will reflect that change.
Add a ToString() method to your Card object, too Your Card object already has a Name property that returns the name of  the card:
Now your programs that use Card objects will be easier to debug.
ToString() is useful for a lot more than just making your objects easier to identify in the IDE.
Keep your eyes open over the next few chapters, and you’ll see how useful it is for every object to have a way to convert itself to a string.
The + operator automatically calls the KindOfDuck enum’s ToString() method.
You’re still allowed to call ToString() like this, but now you know it’s not necessary in this case, because + calls it automatically.
Add a line to create a new array of  Duck objects:
That’s because all List, and arrays implement an interface called IEnumerable<T>, which contains one method.
It’s the Enumerator object that provides the machinery that lets you loop through a list in order.
Here’s a foreach loop that loops through a List<Duck> with a variable called duck:
And here’s what that loop is actually doing behind the scenes:
You can see this for yourself  by running both of  them; they’ll both have the same output.
When you’re looping through a list or array (or any other collection), the MoveNext() method returns true if  there’s another element in the list, or false if  the enumerator has reached the end of  the list.
The Current property always returns a reference to the current element.
Add it all together, and you get a foreach loop!
What do you think would happen during a foreach loop if your ToString() method changes one of the object’s fields?
When a collection implements IEnumerable<T>, it’s giving you a way to write a loop that goes through its contents in order.
Try experimenting with this by changing your Duck’s ToString() to increment the Size property.
Remember, each time you do it, the IDE calls its ToString() method.
Technically, there’s a little more than this, but you get the idea....
You can upcast an ent ire list using IEnumerable Remember how you can upcast any object to its superclass? Well, when you’ve got a List of  objects, you can upcast the entire list at once.
It’s called covariance, and all you need for it is an IEnumerable<T> interface reference.
Create a Console Application and add a base class, Bird (for Duck to extend), and a Penguin class.
We’ll use the ToString() method to make it easy to see which class is which.
Here’s a Bird class, and a Penguin class that inherits from it.
Add them to a new Console Application project, then copy your existing Duck class into it.
Here are the first few lines of  your Main() method to initialize your list and then upcast it.
Take a close look at that last line of  code.
Debug through it and you’ll see it’s pointing to the same object.
Combine your birds into a single list Covariance is really useful when you want to take a collection of  objects and add them to a more general list.
Here’s an example: if  you have a list of  Bird obects, you can add your Duck list to it in one easy step.
Here’s an example that uses the List.AddRange() method, which you can use to add the contents of  one list into another.
Copy the same collection initializer you’ve been using to initialize your List of ducks.
Once the ducks were upcast into an IEnumerable<Bird>, you could add them to a list of Bird objects.
You can build your own overloaded methods You’ve been using overloaded methods and even an overloaded constructor that were part of  the built-in .NET Framework classes and objects, so you can already see how useful they are.
Wouldn’t it be cool if  you could build overloaded methods into your own classes? Well, you can—and it’s easy! All you need to do is write two or more methods that have the same name but take different parameters.
Create a new project and add the Card class to it.
You can do this easily by right-clicking on the project in the Solution Explorer and selecting “Existing Item” from the Add menu.
The IDE will make a copy of  the class and add it to the project.
The file will still have the namespace from the old project, so go to the top of  the Card.cs file and change the namespace line to match the name of  the new project you created.
Then do the same for the Values and Suits enums.
Overloaded methods don’t have to be static, but it’s good to get a little practice writing static methods.
Add a button to the form to use the new methods.
Take a minute and play around with the two methods so you can get used to overloading.
You can also use a using statement instead of changing the namespace.
If you want to learn more about namespaces, take a minute and flip to Leftover #2 in the Appendix.
Build a form that lets you move cards between two decks.
Now it’s time to build a class to hold any number of  cards, which we’ll call Deck.
A real-life deck has 52 cards, but the Deck class can hold any number of  cards—or no cards at all.
Then you’ll build a form that shows you the contents of  two Deck objects.
Remember, you can use a control’s Name property to give it a name to make your code easier to read.
Then when you double-click on the button, its event handler is given a matching name.
In addition to the event handlers for the six buttons, you’ll need to add two methods for the form.
First add a ResetDeck() method, which resets a deck to its initial state.
The RedrawDeck() method shuffles the deck, draws random cards from it, and updates the two listbox controls with whatever happens to be in the two Deck objects.
Take a look at how we used the foreach loop to add each of the cards in the deck to the listbox.
Hint: The ListBox control’s SelectedIndex property will be the same as the index of the card in the list.
If no card is selected, it’ll be less than zero.
Another hint: The form makes it really easy to test your Shuffle() method.
Keep clicking the “Reset Deck #1” button until you get a three-card deck.
That’ll make it easy to see if your shuffling code works.
You’ll need to finish it by writing the Shuffle() and GetCardNames() methods, and you’ll have to get the Sort() method to work.
We also added two useful overloaded constructors: one that creates a complete deck of  52 cards, and another that takes an array of  Card objects and loads them into the deck.
When you have the declarations for a class without the implementation, it’s called a “skeleton”
If you don’t pass parameters into the constructor, it creates a complete deck of 52 cards.
This overloaded constructor takes one parameter—an array of cards, which it loads as the initial deck.
The Deck stores its cards in a List—but it keeps it private to make sure it’s well encapsulated.
The Deal method deals one card out of the deck—it removes the Card object from the deck and returns a reference to it.
You can deal from the top of the deck by passing it 0, or deal from the middle by passing it the index of the card to deal.
You’ll need to write the Shuffle() method and the GetCardNames() method, and add a class that implements IComparer to make the Sort() method work.
And you’ll need to add the Card class you already wrote.
If you use “Add Existing Item” to add it, don’t forget to change its namespace.
Here’s the constructor that creates a complete deck of 52 cards.
That means the inside loop that goes through the 13 values runs four separate times, once per suit.
Here’s the other constructor—this class has two overloaded constructors, each with different parameters.
The Deal method removes a card from the list, and the Add method adds a card to the list.
The Shuffle() method creates a new instance of List<Cards> called NewCards.
Then it pulls random cards out of the Cards field and sticks them in NewCards until Cards is empty.
Once it’s done, it resets the Cards field to point to the new instance.
The old instance won’t have any more references pointing to it, so it’ll get collected by the garbage collector.
To reset deck #1, this method first uses random.Next() to pick how many cards will go into the deck, and then creates a new empty deck.
It uses a for loop to add that many random cards.
Resetting deck #2 is easy—just create a new instance of Deck()
The form’s constructor needs to reset the two decks, and then it draws them.
Sorting by suit is a lot like sorting by value.
The only difference is that in this case the suits are compared first, and then the values are compared only if the suits match.
Instead of using if/else if, we used a series of if statements.
This works because each if statement only executes if the previous one didn’t—otherwise the previous one would have returned.
These buttons are pretty simple—first reset or shuffle the deck, then redraw it.
Naming your controls makes it a lot easier to read your code.
You can use the ListBox control’s SelectedIndex property to figure out which card the user selected and then move it from one deck to the other.
If it’s less than zero, no card was selected, so the button does nothing.
Once the card’s moved, both decks need to be redrawn.
Use a dict ionary to store keys and values A list is like a big long page full of  names.
But what if  you also want, for each name, an address? Or for every car in the garage list, you want details about that car? You need a dictionary.
A dictionary lets you take a special value—the key—and associate that key with a bunch of  data—the value.
And one more thing: a specific key can only appear once in any dictionary.
It’s how you look up a definition in (you guessed it) a dictionary.
This dictionary has string values for keys, and strings as the value.
The Add() method is how you add keys and values to the dictionary.
So you can declare one type for the key, and another type for the value.
The first type in the angle brackets is always the key, and the second is always the data.
Both types are flexible in letting you work with lots of  data types, and also come with lots of  built-in functionality.
You can add an item to a dictionary by passing a key and a value to its Add() method.
The most important thing you’ll do with a dictionary is look up values—which makes sense, because you stored those values in a dictionary so you could look them up using their unique keys.
Just like a List, you can remove an item from a dictionary using the Remove() method.
All you need to pass to the Remove method is the Key value to have both the key and the value removed.
You can get a list of all of the keys in a dictionary using its Keys property and loop through it using a foreach loop.
The Count property returns the number of key-value pairs that are in the dictionary:
Your key and value can be different types Dictionaries are really versatile and can hold just about anything, from strings to numbers and even objects.
Here’s an example of  a dictionary that’s storing an integer as a key and a duck object as a value.
This particular dictionary has string keys, so Keys is a collection of strings.
Keys are unique in a Dictionary; any key appears exactly once.
Values can appear any number of times—two keys can have the same value.
That way, when you look up or remove a key, the Dictionary knows what to remove.
It’s common to see a dictionary that maps integers to objects when you’re assigning unique ID numbers to objects.
Build a program that uses a Dict ionary Here’s a quick program that any New York baseball fan will like.
When an important player retires, the team retires the player’s jersey number.
Let’s build a program that looks up who wore famous numbers and when those numbers were retired.
Here’s a class to keep track of  a jersey number:
But in a Dictionary only one key can map to a single value, so we’ll only include numbers from one team here.
Can you think of a way to store retired numbers for multiple teams?
Use a collection initializer to populate your Dictionary with JerseyNumber objects.
Add each key from the dictionary to the ComboBox’s Items collection.
Since the Dictionary key is an int, we need to cast it to an int value before doing the lookup in the Dictionary.
There’s a good chance that you’re learning C# because you want a job as a professional developer.
That’s why we modeled this exercise after a professional assignment.
When you’re working as a programmer on a team, you don’t usually build a complete program from start to finish.
So we’re going to give you a puzzle that’s got some of  the pieces already filled in.
The code for the form is given to you in step #3
You just have to type it in—which may seem like a great head start, but it means that your classes have to work with that code.
Start with the spec Every professional software project starts with a specification, and this one is no exception.
You’ll be building a game of  the classic card game Go Fish! Different people play the game by slightly different rules, so here’s a recap of  the rules you’ll be using:
The pile of  cards that’s left after everyone’s dealt a hand is called the stock.
Each player takes turns asking for a value (“Do you have any sevens?”)
Any other player holding cards with that value must hand them over.
If  nobody has a card with that value, then the player must “go fish” by taking a card from the stock.
The goal of  the game is to make books, where a book is the complete set of  all four cards that have the same value.
The player with the most books at the end of  the game is the winner.
As soon as a player collects a book, he places it face-up on the table so all the other players can see what books everyone else has.
When placing a book on the table causes a player to run out of  cards, then he has to draw five more cards from the stock.
If  there are fewer than five cards left in the stock, he takes all of  them.
The game is over as soon as the stock is out of  cards.
The winner is then chosen based on whoever has the most books.
For this computer version of  Go Fish, there are two computer players and one human player.
Every round starts with the human player selecting one of  the cards in his hand, which is displayed at all times.
He does this by choosing one of  the cards and indicating that he will ask for a card.
Then the two computer players will ask for their cards.
The game will take care of  all of  the trading of  cards and pulling out of books automatically.
The game displays the name of  the winner (or winners, in case of  a tie)
No other action can be taken—the player will have to restart the program in order to start a new game.
If you don’t know what you’re building before you start, then how would you know when you’re done? That’s why most professional software projects start with a specification that tells you what you’re going to build.
Set the ReadOnly property of the two TextBox controls to True—that will make them read-only text boxes, and set the Multiline property to true.
Set this button’s Name property to buttonAsk, and set its Enabled property to False.
That will disable it, which means it can’t be pressed.
The form will enable it as soon as the game starts.
It’s disabled in this screenshot, but it starts out enabled.
This TextBox control should have its Name property set to textName.
In this screenshot, it’s disabled, but it should be enabled when the program starts.
The player’s current hand is displayed in a ListBox control called listHand.
Build the form Build the form for the Go Fish! game.
It should have a ListBox control for the player’s hand, two TextBox controls for the progress of  the game, and a button to let the player ask for a card.
To play the game, the user will select one of  the cards from the hand and click the button to ask the computer players if  they have that card.
Here’s the code for the form Enter it exactly like you see here.
The rest of  the code that you write will have to work with it.
This is the only class that the form interacts with.
When you start a new game, it creates a new instance of the Game class, enables the “Ask” button, disables the “Start Game” button, and then redraws the form.
This method clears and repopulates the ListBox that holds the player’s hand, and then updates the text boxes.
Using SelectionStart and ScrollToCaret() like this scrolls the text box to the end, so if there’s too much text to display at once it scrolls down to the bottom.
The player selects one of the cards and clicks the “Ask” button to see if any of the other players have a card that matches its value.
The Game class plays a round using the PlayOneRound() method.
The Enabled property enables or disables a control on the form.
The SelectionStart line moves the flashing text box cursor to the end, and once it’s moved, the ScrollToCaret() method scrolls the text box down to the cursor.
But you’ll need to add a few more methods to the Deck class…and you’ll need to understand them in order to use them.
The Peek() method lets you take a peek at one of the cards in the deck without dealing it.
Someone overloaded Deal() to make it a little easier to read.
If you don’t pass it any parameters, it deals a card off the top of the deck.
The ContainsValue() method searches through the entire deck for cards with a certain value, and returns true if it finds any.
Can you guess how you’ll use this in the Go Fish game?
You’ll use the PullOutValues() method when you build the code to get a book of cards from the deck.
It looks for any cards that match a value, pulls them out of the deck, and returns a new deck with those cards in it.
The HasBook() method checks a deck to see if it contains a book of four cards of whatever value was passed as the parameter.
It returns true if there’s a book in the deck, false otherwise.
The SortByValue() method sorts the deck using the Comparer_byValue class.
Now comes the HARD part: Build the Player class There’s an instance of  the Player class for each of  the three players in the game.
Look closely at each of the comments—they tell you what the methods are supposed to do.
You’ll need to add this method to the Card class It’s a static method to take a value and return its plural—that way a ten will return “Tens” but a six will return “Sixes” (with “es” on the end)
That Peek() method we added to the Deck class will come in handy.
It lets the program look at one of the cards in the deck by giving its index number, but unlike Deal() it doesn’t remove the card.
You’ll have to build TWO overloaded versions of the AskForACard() method.
The first one is used by the opponents when they ask for cards—it’ll look through their hands and find a card to ask for.
The second one is used when the player asks for the card.
Both of them ask EVERY other player (both computer and human) for any cards that match the value.
We used a partial class to add this static method to Card to make it easy for you to see what’s going on.
But you don’t need to use a partial class—if you want, you can just add it straight into the existing Card class.
Using IEnumerable<T>  in public class members is a great way to make your classes more flexible, and that’s something you need to think about when your code needs to be reused.
List<string>,  or something else entirely to instantiate the Game class.
The Player and Game classes both use a reference to the multiline TextBox on the form to print messages for the user to read.
Here are a couple of short methods that were already written for you:
The winners dictionary will let you use each player’s name to look up the number of books he made during the game.
First you’ll use a foreach loop to go through the books that the players made and build the dictionary.
Then you’ll use another foreach loop to find the highest number of books associated with any player.
But there might be a tie—more than one player might have the most books! So you’ll need one more foreach loop to look for all the players in winners that have the number of books that you found in the second loop and build a string that says who won.
Other operating systems (like Unix) only use a ‘\n’ to indicate the end of each line.
Every char turns into its own unique number called its Unicode value.
The Deal() method gets called when the game first starts—it shuffles the deck and then deals five cards to each player.
Then it pulls out any books that the players happened to have been dealt.
As soon as the player clicks the “Ask for a card” button, the game calls AskForACard() with that card.
After the player or opponent asks for a card, the game pulls out any books that he made.
If a player’s out of books, he draws a new hand by dealing up to 5 cards from the stock.
After the round is played, the game sorts the player’s hand to make sure it’s displayed in order on the form.
PullOutBooks() looks through a player’s cards to see if he’s got four cards with the same value.
If he does, they get added to his books dictionary.
And if he’s got no cards left afterward, it returns true.
The form needs to display a list of books, so it uses DescribeTheBooks() to turn the player’s books dictionary into words.
Once the last card’s been picked up, the game needs to figure out who won.
And it’ll use a dictionary called winners to do it.
Each player’s name is a key in the dictionary; its value is the number of books that player got during the game.
Next the game looks through the dictionary to figure the number of books that the player with the most books has.
Now that we know which player has the most books, the method can come up with a string that lists the winner (or winners)
It sets its private fields and adds a line to the progress text box saying who joined.
The GetRandomValue() method uses Peek() to look at a random card in the player’s hand.
DoYouHaveAny() uses the PullOutValues() method to pull out and return all cards that match the parameter.
This one is used by the opponents—it gets a random card from the hand and calls the other AskForACard()
This AskForACard() method looks through every player (except for the one asking), calls its DoYouHaveAny() method, and adds any cards handed over to the hand.
If no cards were handed over, the player has to draw from the stock using its Deal() method.
And yet MORE collect ion types… List and Dictionary objects are two of  the built-in generic collections that are part of  the .NET Framework.
Lists and dictionaries are very flexible—you can access any of  the data in them in any order.
But sometimes you need to restrict how your program works with the data because the thing that you’re representing inside your program works like that in the real world.
For situations like this, you’ll use a Queue or a Stack.
Those are the other two generic collections that are similar to lists, but they’re especially good at making sure that your data is processed in a certain order.
Generic col lect ions are an important part of the .NET Framework They’re really useful—so much that the IDE automatically adds this statement to the top of  every class you add to your project:
Almost every large project that you’ll work on will include some sort of  generic collection, because your programs need to store data.
And when you’re dealing with groups of  similar things in the real world, they almost always naturally fall into a category that corresponds pretty well to one of  these kinds of  collections.
Use a Queue when the first object you store will be the first one you’ll use, like:
Use a Stack when you always want to use the object you stored most recently, like:
A stack of  books where you want to read the most recently added one first.
A pyramid of  cheerleaders, where the ones on top have to dismount first… imagine the mess if  the one on the bottom walked away first!
The stack is first in, last out: the first object that goes into the stack is the last one that comes out of it.
A queue is first-in first-out, which means that the first object that you put into the queue is the first one you pull out of it to use.
A queue is like a list that lets you put objects on the end of the list and use the ones in the front.
A stack only lets you access the last object you put into it.
You can, however, use foreach to enumerate through a stack or queue, because they implement IEnumerable!
A queue is FIFO—First In, First Out A queue is a lot like a list, except that you can’t just add or remove items at any index.
To add an object to a queue, you enqueue it.
That adds the object to the end of  the queue.
You can dequeue the first object from the front of  the queue.
When you do that, the object is removed from the queue, and the rest of  the objects in the queue move up a position.
Peek() lets you take a “look” at the first item in the queue without removing it.
When we pull them out of the queue, they’ll come out in the same order they went in.
The first Dequeue() pulls the first item out of the queue.
Then the second one shifts up into the first place—the next call to Dequeue() pulls that one out next.
The queue’s Count property returns the number of items in the queue.
The first one in the queue is the first one to come out of it.
A stack is LIFO—Last In, First Out A stack is really similar to a queue—with one big difference.
You push each item onto a stack, and when you want to take an item from the stack, you pop one off of  it.
When you pop an item off  of  a stack, you end up with the most recent item that you pushed onto it.
It’s just like a stack of  plates, magazines, or anything elseyou can drop something onto the top of  the stack, but you need to take it off  before you can get to whatever’s underneath it.
Creating a stack is just like creating any other generic collection.When you push.
When you pop an item off the stack, you get the most recent item that was added.
The last object you put on a stack is the first object that you pull off of it.
NewLine instead of \n here, but we wanted the code to be easier to read.
You haven’t shown me anything I can do with a stack.
But I can’t get at the items in the middle of a stack or a queue.
Don’t worry—you don’t give up anything when you use a queue or a stack.
It’s really easy to copy a Queue object to a List object.
And it’s just as easy to copy a List to a Queue, a Queue to a Stack…in fact, you can create a List, Queue, or Stack from any other object that implements the IEnumerable interface.
All you have to do is use the overloaded constructor that lets you pass the collection you want to copy from as a parameter.
That means you have the flexibility and convenience of  representing your data with the collection that best matches the way you need it to be used.
But remember, you’re making a copy, which means you’re creating a whole new object and adding it to the heap.
Let’s set up a stack with four items—in this case, a stack of strings.
It’s easy to convert that stack to a queue, then copy the queue to a list, and then copy the list to another stack.
Fill in the get accessor for FlapjackCount and the TakeFlapjacks and EatFlapjacks methods.
It lets you enter the names of  lumberjacks into a text box so they get in the breakfast line.
You can give the lumberjack at the front of  the line a plate of  flapjacks, and then tell him to move on to eat them using the “Next lumberjack” button.
We’ve given you the click event handler for the “Add flapjacks” button.
Use a queue called breakfastLine to keep track of  the lumberjacks.
You’ll need to add a RedrawList() method to update the list box with the contents of the queue.
When the user clicks “Add Lumberjack”, add the name in the name text box to the breakfastLine queue.
Look at the addFlapjacks_Click method to figure out what they should be named.
Peek() returns a reference to the first lumberjack in the queue.
This button should dequeue the next lumberjack, call his EatFlapjacks(), then redraw the list box.
The NumericUpDown control is called howMany, and the label is called nextInLine.
The RedrawList() method uses a foreach loop to pull the lumberjacks out of their queue and add each of them to the list box.
We called the list box “line”, and the label between the two buttons “nextInLine”
This if statement updates the label with information about the first lumberjack in the queue.
The EatFlapjacks method uses a while loop to print out the lumberjack’s meal.
An instance of a ______________ collection only works with one specific type.
Two methods in a class with the same name but different parameters are...
A method to figure out if a certain object is in a collection.
This method returns the next object to come off of a stack or queue.
An instance of a ______________ collection only works with one specific type.
Two methods in a class with the same name but different parameters are...
This method returns the next object to come off of a stack or queue [peek]
This lab gives you a spec that describes a program for you to build, using the knowledge you’ve gained over the last few chapters.
This project is bigger than the ones you’ve seen so far.
So read the whole thing before you get started, and give yourself a little time.
And don’t worry if you get stuck—there’s nothing new in here, so you can move on in the book and come back to the lab later.
We’ve filled in a few design details for you, and we’ve made sure you’ve got all the pieces you need…and nothing else.
You can download an executable for this lab from the website…but we won’t give you the code for the answer.
The spec: build an adventure game Your job is to build an adventure game where a mighty adventurer is on a quest to defeat level after level of  deadly enemies.
You’ll build a turn-based system, which means the player makes one move and then the enemies make one move.
The player can move or attack, and then each enemy gets a chance to move and attack.
The game keeps going until the player either defeats all the enemies on all seven levels or dies.
The game window gives an overhead view of the dungeon where the player fights his enemies.
These four buttons are used to attack enemies and drink potions.
The player can use any of the buttons to drink a potion.
The game shows you the number of hit points for the player and enemies.
When the player attacks an enemy, the enemy’s hit points go down.
Once the hit points get down to zero, the enemy or player dies.
It shows what items the player’s picked up, and draws a box around the item that they’re currently using.
The player clicks on an item to equip it, and uses the Attack button to use the item.
The player can pick up weapons and potions along the way.
The enemies get a bit of an advantage—they move every turn, and after they move they’ll attack the player if he’s in range.
The player picks up weapons… There are weapons and potions scattered around the dungeon that the player can pick up and use to defeat his enemies.
All he has to do is move onto a weapon, and it disappears from the floor and appears in his inventory.
A black box around a weapon means it’s current ly.
Once the weapon’s picked up, it should disappear from the game floor.
Higher levels bring more enemies There are three different kinds of  enemies: a bat, a ghost, and a ghoul.
The seventh level is the last one, and it has all three enemies.
A ghoul moves quickly toward the player, and causes heavy damage when it attacks.
When it’s near the player, it causes a small amount of damage.
As soon as it’s close to the player, it attacks and causes a medium amount of damage.
The bat is to the right of the player, so he hits the Right attack button.
The design: building the form The form gives the game its unique look.
Use the form’s BackgroundImage property to display the image of  the dungeon and the inventory, and a series of  PictureBox controls to show the player, weapons, and enemies in the dungeon.
You’ll use a TableLayoutPanel control to display the hit points for the player, bat, ghost, and ghoul as well as the buttons for moving and attacking.
The dungeon itself is a static image, displayed using the BackgroundImage property of the form.
It doesn’t matter where you place them—the form will move them around.
Use the little black arrow that shows up when you click on the PictureBox to set each to one of the images from the Head First Labs website.
When the player equips one of the weapons, the form should set the BorderStyle of that weapon icon to FixedSingle and the rest of the icons’ BorderStyle to None.
Everything in the dungeon is a PictureBox Players, weapons, and enemies should all be represented by icons.
Add nine PictureBox controls, and set their Visible properties to False.
Then, your game can move around the controls, and toggle their Visible properties as needed.
Build your stats window The hit points are in a TableLayoutPanel, just like the attack and movement buttons.
For the hit points, create two columns in the panel, and drag the column divider to the left a bit.
Add four rows, each 25% height, and add in Label controls to each of  the eight cells:
Each cell has a Label in it, and you can update those values during the game.
Controls overlap each other in the IDE, so the form needs to know which ones are in front, and which are in back.
That’s what the “Bring to Front” and “Send to Back” form designer commands do.
You’ll need several types of  objects in your game: a Player object, several subtypes of  an Enemy object, and several sub-types of  a Weapon object.
And you’ll also need one object to keep up with everything that’s going on: the Game object.
The Game object handles turns When one of  your form’s move buttons is clicked, the form will call the Game object’s Move() method.
That method will let the player take a turn, and then let all the enemies move.
So it’s up to Game to handle the turn-based movement portion of  the game.
After the player moves, Game tells each of the enemies to Move()
When the user clicks one of the four move buttons, the form calls Game’s Move() method.
Game’s Move() method first calls the Player object’s Move() method to tell the player to move.
If any of the enemies end up near the player after they’ve moved, they attack the player.
Each Move() method takes a direction, and some of them take a Random object, too.
The form never interacts directly with the players, weapons, or enemies.
Game takes the input from the form and deals with the objects in the game.
The Game object keeps up with players, weapons, and a list of enemies.
We’ll give you a lot more details on how the player and enemies move, how the enemy figures out if it’s near the player, etc.
There’s only one weapon per level, so the game just needs a Weapon reference, not a List.
The Player, however, has a List<Weapon> to hold the inventory.
The form delegates act i v ity to the Game object Movement, attacking, and inventory all begin in the form.
So clicking a movement or attack button, or an item in inventory, triggers code in your form.
But it’s the Game object that controls the objects in the game.
So the form has to pass on anything that happens to the Game object, and then the Game object takes it from there:
The Form object calls the game’s Move(), and then calls its own UpdateCharacters() method to update the screen.
It reads the location of the player, enemies, and any weapons currently in the dungeon and moves the PictureBoxes to match them.
The inventory scroll displays all of the icons for the items that the player has picked up.
Attacking is like movement…the form calls Attack() on Game, and Game handles dealing with the attack.
The UpdateCharacters() method also checks the player’s inventory and makes sure the correct icons are displayed on the inventory scroll.
The BorderStyle property highlights the active item in the player’s inventory.
Game handles updating locations, so when UpdateCharacters() is called, things are moved to their new locations.
Game.Move() calls the enemies’ Move() methods, which all take a random reference.
When the player hits an enemy, it causes a random amount of damage (up to a maximum damage limit)
You’ll need Rectangle and Point from System.Drawing, so be sure to add this to the top of your class.
These are OK as public properties if Enemy and Weapon are well encapsulated…in other words, just make sure the form can’t do anything inappropriate with them.
The form will only interact with this through methods on Game, rather than directly.
The Rectangle object has Top, Bottom, Left, and Right fields, and works perfectly for the overall game area.
Building the Game class We’ve gotten you started with the Game class in the code below.
There’s a lot for you to do—so read through this code carefully, get it into the IDE, and get ready to go to work:
Movement is simple: move the player in the direction the form gives us, and move each enemy in a random direction.
Game doesn’t know how Player handles these actions, it just passes on the needed information and lets Player do the rest.
Game starts out with a bounding box for the dungeon, and creates a new Player object in the dungeon.
It’s your job to add cases for the other levels.
The player attacks, and the enemies all get a turn to move.
This is just a math trick to get a random location within the rectangle that represents the dungeon area.
Finish the rest of the levels It’s your job to finish the NewLevel() method.
So if the blue potion is still in the player’s inventory from.
This only appears if the red potion from Level 5 has already been used up.
We’ve only got room in the inv entory for one.
You already know that duplicate code is bad, and duplicate code usually shows up when two or more objects share the same behavior.
That’s the case in the dungeon game, too…both enemies and players move.
Let’s create a Mover class, to abstract that common behavior into a single place.
And even though weapons don’t move around, they inherit from Mover, too, because they need some of  its properties and methods.
Mover has a Move() method for moving around, and a read-only Location property that the form can use to position a subclass of  Mover.
Nearby() takes a point, and figures out if it’s within a certain distance away from the object.
You’ll only instantiate Player and Enemy, which inherit from it.
You can call Nearby() and Move() on both Enemy and Player now.Add a Direct ion enum The Mover class, as well as several other classes, need a Direction enum.
Create this enum, and give it four enumerated values: Up, Down, Left, and Right.
We added return values and parameters to this class diagram to make it easier for you to see what’s going on.
The Nearby method checks a Point against this object’s current location.
If they’re within distance of each other, then it returns true; otherwise, it returns false.
The Mover class source code Here’s the code for Mover:
Since protected properties are only available to subclasses, the form object can’t set the location…only read it through the public get method we define.
The Move() method tries to move one step in a direction.
If it hits a boundary, it returns the original Point.
If the end location is outside the boundaries, the new location stays the same as the starting point.
The Player class keeps track of the player Here’s a start on the Player class.
Start with this code in the IDE, and then get ready to add to it.
The player’s constructor sets its hitPoints to 10 and then calls the base class constructor.
And when a potion increases the player’s health, it increases it by a random amount.
The Equip() method tells the player to equip one of his weapons.
The Game object calls this method when one of the inventory icons is clicked.
All of the properties of Player are hidden from direct access.
Player inherits from Mover, so this passes in the Game and location to that base class.
A Player can hold multiple weapons in inventory, but can only equip one at a time.
Even though potions help the player rather than hurt the enemy, they’re still considered weapons by the game.
That way the inventory can be a List<Weapon>, and the game can point to one with its WeaponInRoom reference.
The Player and Enemy objects need to stay inside the dungeon, which means they need to know the boundaries of the playing area.
Use the Contains() method of the boundaries Rectangle to make sure they don’t move out of bounds.
Potions will implement an IPotion interface (more on that in a minute), so you can use the “is” keyword to see if a Weapon is an implementation of IPotion.
Write the Move() method for the Player Game calls the Player’s Move() method to tell a player to move in a certain direction.
Move() takes the direction to move as an argument (using the Direction enum you should have already added)
This happens when one of the movement buttons on the form is clicked.
You’ve got to fill in the rest of  this method.
Check and see if  the weapon is near the player (within a single unit of  distance)
If so, pick up the weapon and add it to the player’s inventory.
If  the weapon is the only weapon the player has, go ahead and equip it immediately.
That way, the player can use it right away, on the next turn.
The Weapon and form will handle making the weapon’s PictureBox invisible when the player picks it up…that’s not the job of the Player class.
Add an Attack() method, too Next up is the Attack() method.
This is called when one of  the form’s attack buttons is clicked, and carries with it a direction (again, from the Direction enum)
If  the player doesn’t have an equipped weapon, this method won’t do anything.
If  the player does have an equipped weapon, this should call the weapon’s Attack() method.
If  a potion is used, remove it from the player’s inventory, since it’s not available anymore.
The weapons all have an Attack() method that takes a Direction enum and a Random object.
If the weapon is a potion, then Attack() removes it from the inventory after the player drinks it.
When the player picks up a weapon, it needs to disappear from the dungeon and appear in the inventory.
Each different sort of  enemy has its own class that inherits from the Enemy class.
The different kinds of  enemies move in different ways, so the Enemy abstract class leaves the Move method as an abstract method—the three enemy classes will need to implement it differently, depending on how they move.
The Enemy class inherited the Nearby() method from Mover, which it can use to figure out whether it’s near the player.
When the player attacks an enemy, it calls the enemy’s Hit() method, which subtracts a random number from the hit points.
The form can use this read-only property to see if the enemy should be visible in the game dungeon.
Write the different Enemy subclasses The three Enemy subclasses are pretty straightforward.
Each enemy has a different number of  starting hit points, moves differently, and does a different amount of  damage when it attacks.
You’ll need to have each one pass a different startingHitPoints parameter to the Enemy base constructor, and you’ll have to write different Move() methods for each subclass.
Here’s an example of  how one of  those classes might look:
It’ll keep moving toward the player and attacking as long as it has one or more hit points.
After the bat moves, it checks if  it’s near the player—if  it is, then it attacks the player with up to 2 hit points of  damage.
The ghost is harder to defeat than the bat, but like the bat, it will only move and attack if  its hit points are greater than zero.
If  it’s near the player, it attacks the player with up to 3 hit points of  damage.
It starts with 10 hit points, and only moves and attacks if  its hit points are greater than zero.
If  it’s near the player, it attacks the player with up to 4 hit points of  damage.
Once an enemy has no more hit points, the form will no longer display it.
But it’ll still be in the game’s Enemies list until the player finishes the level.
You probably won’t need any constructor for these; the base class handles everything.
Each of these subclasses the Enemy base class, which in turn subclasses Mover.
We’ll have to make sure the form sees if an enemy should be visible at every turn.
The bat flies around somewhat randomly, so it uses Random to fly in a random direction half the time.
The ghost and ghoul use Random to make them move more slowly than the player.
We need a base Weapon class, just like we had a base Enemy class.
And each weapon has a location, as well as a property indicating whether or not it’s been picked up.
Each weapon class needs to implement a Name property and an Attack() method that determines how that weapon attacks.
The constructor sets the game and location fields, and sets pickedUp to false (because it hasn’t been picked up yet)
A pickedUp weapon shouldn’t be displayed anymore…the form can use this get accessor to figure that out.
Each weapon’s Name property returns its name (“Sword”, “Mace”, “Bow”)
Each weapon has a different range and pattern of attack, so the weapons implement the Attack() method differently.
It attempts to find an enemy in a certain direction and radius.
If it does, it calls the enemy’s Hit() method and returns true.
Weapon inherits from Mover because it uses its Nearby() and Move() methods in DamageEnemy()
The Nearby() method in the Mover class only takes two parameters, a Point and an int, and it compares the Point to the Mover field location.
You’ll need to add an overloaded Nearby() that’s almost identical, except that it takes three parameters, two Points and a distance, which compares the first Point to the second Point (instead of location)
Different weapons attack in different ways Each subclass of  Weapon has its own name and attack logistic.
The sword is the first weapon the player picks up.
It’s got a wide angle of  attack: if  he attacks up, then it first tries to attack an enemy that’s in that direction—if  there’s no enemy there, it looks in the direction that’s clockwise from the original attack and attacks any enemy there, and if it still fails to hit then it attempts to attack an enemy counterclockwise from the original direction of  attack.
Unlike the sword, which attacks in three directions (because the player swings it in a wide arc), when the player shoots the bow in a direction, it only shoots in that one direction.
The mace is the most powerful weapon in the dungeon.
Think carefully about this…what is to the right of the direction left? What is to the left of up?
Each subclass represents one of the three weapons: a sword, bow, or mace.
Each subclass relies on the base class to do the initialization work.
The Game object will pass on the direction to attack in.
If there’s no enemy there, it’ll try Left, then Down—that makes it swing in a full circle.
The player can use the weapons over and over—they never get dropped or used up.
Pot ions implement the IPot ion interface There are two potions, a blue potion and a red potion, which increase the player’s health.
They act just like weapons—the player picks them up in the dungeon, equips them by clicking on the inventory, and uses them by clicking one of  the attack buttons.
So it makes sense for them to inherit from the abstract Weapon class.
But potions act a little differently, too, so you’ll need to add an IPotion interface so they can have extra behavior: increasing the player’s health.
Potions only need to add one readonly property called Used that returns false if  the player hasn’t used the potion, and true if  he has.
The form will use it to determine whether or not to display the potion in the inventory.
The BluePotion class’s Name property should return the string “Blue Potion”
After the player uses the potion, the potion’s Used() method should return true.
The potions inherit from the Weapon class because they’re used just like weapons—the player clicks on the potion in the inventory scroll to equip it, and then clicks any of the attack buttons to use it.
The RedPotion class is very similar to BluePotion, except that its Name property returns the string “Red Potion”, and its Attack() method increases the player’s health by up to 10 hit points.
It’s also possible to find out if a Weapon is a potion with “if (weapon is IPotion)” because of this interface.
You should be able to write these classes using this class diagram and the information below.
The form brings it al l together There’s one instance of  the Game object, and it lives as a private field of your form.
It’s created in the form’s Load event, and the various event handlers in the form use the fields and methods on the Game object to keep the game play going.
Everything begins with the form’s Load event handler, which passes the Game a Rectangle that defines the boundaries of  the dungeon play area.
The form has a separate event handler for each of  these PictureBox’s Click events.
If  the player’s holding the sword, the form calls game.Equip() to equip it.
It then sets each PictureBox’s BorderStyle property to draw a box around the sword, and make sure none of  the other icons has a box around it.
Using a Rectangle You’ll find a lot of Rectangles any time you work with forms.
You can create one by passing it X, Y, Width, and Height values, or two Points (for opposite corners)
Once you’ve got a rectangle instance, you can also access its Left, Right, Top, and Bottom, as well as its X, Y, Width, and Height values.
These are the boundaries of the dungeon in the background image you’ll download and add to the form.
There’s an event handler for each of  the four movement buttons.
First the button calls game.Move() with the appropriate Direction value, and then it calls the form’s UpdateCharacters() method.
The four attack button event handlers are also really simple.
Each button calls game.Attack(), and then calls the form’s UpdateCharacters() method.
So make the Left, Right, and Down buttons invisible when the player equips a potion, and change the text on the Up button to say “Drink”
Remember to double-click on each PictureBox so the IDE adds a separate event handler method for each of them.
Make sure you change the buttons back when the player equips the sword, bow, or mace.
The form’s UpdateCharacters() method moves the PictureBoxes into posit ion The last piece of  the puzzle is the form’s UpdateCharacters() method.
Once all the objects have moved and acted on each other, the form updates everything…so weapons that been dropped have their PictureBoxes’ Visible properties set to false, enemies and players are drawn in their new locations (and dead ones are made invisible), and inventory is updated.
Update the player’s position and stats The first thing you’ll do is update the player’s PictureBox location and the label that shows his hit points.
Then you’ll need a few variables to determine whether you’ve shown each of  the various enemies.
Update each enemy’s location and hit points Each enemy could be in a new location and have a different set of  hit points.
You need to update each enemy after you’ve updated the player’s location:
Once you’ve looped through all the enemies on the level, check the showBat variable.
If the bat was killed, then showBat will still be false, so make its PictureBox invisible and clear its hit points label.
The showBat variable will be set to true if we made the bat’s PictureBox visible.
You’ll need two more if statements like this in your foreach loop—one for the ghost and one for the ghoul.
This will affect the visibility of the enemy PictureBox controls in just a bit.
Update the weapon PictureBoxes Declare a weaponControl variable and use a big switch statement to set it equal to the PictureBox that corresponds to the weapon in the room.
The rest of  the cases should set the variable weaponControl to the correct control on the form.
Here’s the rest of the method The rest of  the method does three things.
First it checks to see if  the player’s already picked up the weapon in the room, so it knows whether or not to display it.
And finally, it checks to see if  the player’s defeated all of the enemies.
If  he has, then the player advances to the next level.
If it’s been picked up, we need to make its icon invisible.
If there are no more enemies on the level, then the player’s defeated them all and it’s time to go to the next level.
It’s easy to end up with bugs that are difficult to track down if they don’t match.
The fun’s just beginning! Seven levels, three enemies…that’s a pretty decent game.
Make the enemies smarter Can you figure out how to change the enemies’ Move() methods so that they’re harder to defeat? Then see if you can change their constants to properties, and add a way to change them in the game.
Add more levels The game doesn’t have to end after seven levels.
See if you can add more…can you figure out how to make the game go on indefinitely? If the player does win, make a cool ending animation with dancing ghosts and bats! And the game ends pretty abruptly if the player dies.
Can you think of a more user-friendly ending? Maybe you can let the user restart the game or retry his last level.
Add different kinds of enemies You don’t need to limit the dangers to ghouls, ghosts, and bats.
See if you can add more enemies to the game.
Add more weapons The player will definitely need more help defeating any new enemies you’ve added.
Think of new ways that the weapons can attack, or different things that potions can do.
Take advantage of the fact that Weapon is a subclass of Mover—make magic weapons the player has to chase around!
Can you figure out how to use the KeyDown event and Timer you used in the Key Game in Chapter 4 to change this from a turn-based game into an action game?
So far, all of your programs have been pretty short-lived.
Any time your program reads or writes a file, connects to another computer over a network, or generally does anything where it sends or receives bytes from one place to another, you’re using streams.
Whenever you want to read data from a file or write data to a file, you’ll use a Stream object.Let’s say you have a simple program—a form.
And if your program needs to write data out to the file, it can use another Stream object.
You can use a different Stream object, but the process is the same.
You can write your data to a stream through a stream’s Write() method.
You can use the Read() method to get data from a file, or a network, or memory, or just about anything else, using a stream.
Most streams support a Seek() method that lets you find a position within the stream so you can read or insert data at a specific place.
Use the right kind of stream for the data you’re working with.
A FileStream object lets you read from and write to files.
A MemoryStream object lets you read from and write data to chunks of memory.
A NetworkStream object lets you read and write data to other computers or devices on a network.
A GZipStream object lets you compress data so that it takes up less space and is easier to download and store.
These are just some of the methods in the Stream class.
Stream is an abstract class, so you can’t instantiate it on its own.
Different streams read and write different things Every stream is a subclass of  the abstract Stream class, and there are a bunch of  built-in stream classes to do different things.
We’ll be concentrating on reading and writing regular files, but everything you learn in this chapter will just as easily apply to compressed or encrypted files, or network streams that don’t use files at all.
Each subclass adds methods and properties specific to that class’s functionality.
A FileStream reads and writes bytes to a f i le When your program needs to write a few lines of  text to a file, there are a lot of  things that have to happen:
Streams write bytes to files, so you’ll need to convert the string that you want to write to an array of  bytes.
Call the stream’s Write() method and pass it the byte array.4
Close the stream so other programs can access the file.5
Create a new FileStream object and tell it to write to the file.1
A FileStream can only be attached to one file at a time.
This is called encoding, and we’ll talk more about it later on…
All you have to do is create a new StreamWriter object and give it a filename.
Then you can use the StreamWriter’s Write() and WriteLine() methods to write everything to the file you want.
Use the StreamWriter’s constructor to open or create a file You can pass a filename to the StreamWriter() constructor.
StreamWriter also has an overloaded constructor that takes a bool: true if  you want to add text to the end of  an existing file (or append), or false if  you want to delete the existing file and create a new file with the same name.
Call the Close() method to release the file If  you leave the stream open and attached to a file, then it’ll keep the file locked open and no other program will be able to use it.
StreamWriter creates and manages a FileStream object for you automatically.
This line creates the StreamWriter object and tells it where the file will be.
Write() sends just the text, with no extra line feeds at the end.
Close() frees up any connections to the file and any resources the StreamWriter is using.
The text doesn’t get written if you don’t close the stream.
Can you figure out what’s going on with the location variable in this code?
The Swindler launches another diabolical plan The citizens of  Objectville have long lived in fear of  the Swindler.
Now he’s using a StreamWriter to implement another evil plan.
Create a new Console Application and add this to the Main() method::
StreamWriter is in the System.IO namespace, so make sure you add “using System.IO;” to the top of your program.
It’s probably not a good idea to write to your root folder, and your OS might not even let you do it.
StreamWriter Magnets Suppose you have the code for button1_Click() shown below.
Your job is to use the magnets to build code for the Flobbo class so that when the event handler is called, it produces the output shown at the bottom of the page.
StreamWriter Magnets Solution Your job was to construct the Flobbo class from the magnets to create the desired output.
The Blobbo() method is overloaded—it’s got two declarations with different parameters.
Make sure you close files when you’re done with them.
Just a reminder: we picked intentionally weird variable names and methods in these puzzles because if we used really good names, the puzzle would be too easy! Don’t use names like this in your code, ok?
Reading and writ ing using t wo objects Let’s read Swindler’s secret plans with another stream, a StreamReader.
StreamReader works just like StreamWriter, except instead of  writing a file you give the reader the name of  the file to read in its constructor.
The ReadLine() method returns a string that contains the next line from the file.
You can write a loop that reads lines from it until its EndOfStream field is true—that’s when it runs out of  lines to read:
This loop reads a line from the reader and writes it out to the writer.
This program uses a StreamReader to read the Swindler’s plan, and a StreamWriter to write a file that will get emailed to Captain Amazing.
Make sure to close every stream that you open, even if you’re just reading a file.
Pass the file you want to read from into the StreamReader’s constructor.
We’re playing a little fast and loose with the word “stream.” A StreamReader (which inherits from TextReader) is a class that reads.
The StreamReader and StreamWriter opened up their own streams when you instantiated them.
Calling their Close() methods tells them to close those streams.
Data can go through more than one stream One big advantage to working with streams in .NET is that you can have your data go through more than one stream on its way to its final destination.
One of  the many types of  streams that .NET ships with is the CryptoStream class.
This lets you encrypt your data before you do anything else with it:
Using a normal FileStream, your data gets written directly to a file as text.
Now your FileStream writes the encrypted text to the file.
CryptoStream inherits from the abstract Stream class, just like the other stream classes.
One stream can write to another stream, which writes to another stream…often ending with a network or file stream.
Pool Puzzle Your job is to take code snippets from.
You can use the same snippet more than once, and you won’t need to use all the snippets.
Note: Each snippet from the pool can be used more than once!
This enum (specifically, its ToString() method) is used to print a lot of the output.
The Party class has a StreamReader field, and its HowMuch() method reads a line from that StreamReader and writes it to a StreamWriter.
Use built-in objects to pop up standard dialog boxes When you’re working on a program that reads and writes files, there’s a good chance that you’ll need to pop up a dialog box at some point to prompt the user for a filename.
That’s why .NET ships with objects to pop up the standard Windows file dialog boxes.
ShowDialog() pops up a dialog box Displaying a dialog box is easy.
You can do this in code using new, or you can drag it out of  the Toolbox and onto your form.
A few useful ones include Title (which sets the text in the title bar), InitialDirectory (which tells it which directory to open first), and FileName (for Open and Save dialog boxes)
That pops up the dialog box, and doesn’t return until the user clicks the OK or Cancel button, or closes the window.
The ShowDialog() method returns a DialogResult, which is an enum.
Some of  its members are OK (which means the user clicked OK), Cancel, Yes, and No (for Yes/No dialog boxes)
Dialog boxes are just another .NET control You can add Windows standard file dialog boxes to your program by dragging them to your form—just drag an OpenFileDialog control out of  the Toolbox and drop it onto your form.
Instead of  showing up as a visual control, you’ll see it appear in the space below your form.
That’s because it’s a component, which is a special kind of non-visual Toolbox control that doesn’t appear directly on the form, but which you can still use in your form’s code just like you use any other control.
When you drag a component out of the Toolbox and onto your form, the IDE displays it in the space underneath the form editor.
The InitialDirectory property changes the folder that’s first displayed when the dialog opens.
These properties tell the dialog box to display an error message if the user tries to open up a file or path that doesn’t exist on the drive.
Display the dialog box using its ShowDialog() method, which returns a DialogResult.
That’s an enum that you can use to check whether or not the user hit the OK button.
The Filter property lets you change the filters that show up on the bottom of the dialog box, such as what types of files to show.
Dialog boxes are objects, too An OpenFileDialog object shows the standard Windows “Open” window, and the SaveFileDialog shows the “Save” window.
You can display them by creating a new instance, setting the properties on the object, and calling its ShowDialog() method.
The ShowDialog() method returns a DialogResult enum (because some dialog boxes have more than two buttons or results, so a simple bool wouldn’t be enough)
Change the “Save as type” list using the Filter property.
The DialogResult returned by the ShowDialog() method lets you figure out which button the user clicked.
The ShowDialog() method pops up the dialog box and opens the folder specified in the InitialDirectory property.
When the user chooses a file, its full path is saved in the FileName property.
The SaveFileDialog object pops up the standard Windows “Save as…” dialog box.
Just compare what’s between the | characters in the string with what shows up in the window.
Use the built-in File and Directory classes to work with f i les and directories Like StreamWriter, the File class creates streams that let you work with files behind the scenes.
You can use its methods to do most common actions without having to create the FileStreams first.
Directory objects let you work with whole directories full of files.
Find out if the file exists You can check to see if  a file exists using the Exists() method.
It’ll return true if  it does and false if  it doesn’t.
Read from and write to the file You can use the OpenRead() method to get data from a file, or the Create() or  OpenWrite() method to write to the file.
Append text to the file The AppendAllText() method lets you append text to an already-created file.
It even creates the file if  it’s not there when the method runs.
Create a new directory Create a directory using the CreateDirectory() method.
All you have to do is supply the path; this method does the rest.
Get a list of the files in a directory You can create an array of  files in a directory using the GetFiles() method; just tell the method which directory you want to know about and it will do the rest.
Delete a directory Deleting a directory is really simple too.
FileInfo works just like File If you’re going to be doing a lot of work with a file, you might want to create an instance of the FileInfo class instead of using the File class’s static methods.
The FileInfo class does just about everything the File class does except you have to instantiate it to use it.
You can create a new instance of FileInfo and access its Exists() method or its OpenRead() method in just the same way.
The only difference is that the File class is faster for a small number of actions, and FileInfo is better suited for big jobs.
File is a static class, so it’s just a set of methods that let you work with files.
FileInfo is an object that you instantiate, and its methods are the same as the ones you see on File.
Q:Why did you put an @ in front of the string that contained the filename?
Q:What was that in the beginning about converting a string to a byte array? How would that even work?
Q:If I’m just using a StreamWriter to write to a file, why do I really care if it’s creating a FileStream for me?
Q:Why do I need to worry about closing streams after I’m done with them?
The File class gives you methods to work with files, and the Directory class lets you work with directories.
Write down what you think each of these lines of code does.
See if you can guess what this one does—you haven’t seen it yet.
Use f i le dialogs to open and save f i les (al l with just a few lines of code) You can build a program that opens a text file.
It’ll let you make changes to the file and save your changes, with very little code, all using standard .NET controls.
Drop the OpenFileDialog and SaveFileDialog controls onto the form, too.
Double-click on the buttons to create their event handlers and add a private string field called name to the form.
Don’t forget to put a using statement up top for System.IO.
The Open button shows an OpenFileDialog and then uses File.
Set the initialFolder property to have the OpenFileDialog start in a specified directory.
Filter the OpenFileDialog so it will only show text files using the Filter property.
The ReadAllText() and WriteAllText() methods are part of the File class.
We’ll look at them in more detail in just a few pages.
If you don’t add a filter, then the drop-down lists at the bottom of the open and save dialog boxes will be empty.
Here’s a trick to make your TextBox fill up the form.
Drag a TableLayoutPanel from the Containers toolbox onto the form, set its Dock property to Fill, and use its Rows and Columns property editors to give it two rows and one column.
Then drag a FlowLayoutPanel out of the Toolbox into the bottom cell, set its Dock to Fill, set its FlowDirection property to RightToLeft, and drag the two buttons onto it.
Set the size of the top row in the TableLayoutPanel to 100%, and resize the bottom row so that the two buttons just fit.
The File class gives you methods to work with files, and the Directory class lets you work with directories.
Your job was to write down what each bit of code did.
IDisposable makes sure your objects are disposed of properly A lot of  .NET classes implement a particularly useful interface called IDisposable.
Whenever a class implements IDisposable, it’s telling you that there are important things that it needs to do in order to shut itself  down, usually because it’s allocated resources that it won’t give back until you tell it to.
The Dispose() method is how you tell the object to release those resources.
You can use the “Go To Definition” feature in the IDE to show you the official C# definition of  IDisposable.
Go to your project and type “IDisposable” anywhere inside a class.
Then right-click on it and select “Go To Definition” from the menu.
Expand all of  the code and this is what you’ll see:
A lot of classes allocate important resources, like memory, files, and other objects.
That means they take them over, and don’t give them back until you tell them you’re done with those resources.
The programming team was irritated at their project manager because he allocated all of  the conference rooms for a useless management seminar.
Any class that implements IDisposable will immediately release any resources that it took over as soon as you call its Dispose() method.
It’s almost always the last thing you do before you’re done with the object.
Declare an object in a using block and that object’s Dispose() method is called automatically.
Go To Definition There’s a handy feature in the IDE that lets you automatically jump to the definition for any variable, object, or method.
Just right-click on it and select “Go To Definition”, and the IDE will automatically jump right to the code that defines it.
You can also press F12 instead of using the menu.
Avoid f i le system errors with using statements We’ve been telling you all chapter that you need to close your streams.
That’s because some of  the most common bugs that programmers run across when they deal with files are caused when streams aren’t closed properly.
Luckily, C# gives you a great tool to make sure that never happens to you: IDisposable and the Dispose() method.
When you wrap your stream code in a using statement, it automatically closes your streams for you.
All you need to do is declare your stream reference with a using statement, followed by a block of  code (inside curly brackets) that uses that reference.
When you do that, the using statement automatically calls the stream’s Dispose() method as soon as it finishes running the block of  code.
A using statement is always followed by an object declaration…
When the using statement ends, the Dispose() method of the object being used is run.
In this case, the object bein g used is pointed.
These statements can use the object created in the using statement above like any normal object.
These “using” statements are different from the ones at the top of your code.
Use mult iple using statements for mult iple objects You can pile using statements on top of  each other—you don’t need extra sets of  curly brackets or indents.
Any time you use a stream, you should ALWAYS declare it inside a using statement.
Every stream has a Dispose() method that closes the stream.
So if you declare your stream in a using statement, it will always close itself!
You don’t need to call Close() on the streams now, because the using statemen.
He likes his job as a C# developer, but he loves taking the occasional day off.
His boss hates when people take vacation days, so Brian’s got to come up with a good excuse.
That’s the ninth vet appointment you’ve had since March, son.
If I find out you’re lying to me, you’d better start looking for a new job!
You can help Brian out by building a program to manage his excuses Use what you know about reading and writing files to build an excuse manager that Brian can use to keep track of  which excuses he’s used recently and how well they went over with the boss.
Let’s add a button to load up a random excuse from his excuse folder.
When Brian clicks the Save button, the current excuse is saved out to the folder.
Brian wants to keep all of his excuses in one place, so let’s let him select a folder to store all of them.
Build the form This form has a few special features:
When the form’s first loaded, only the Folder button should be enableddisable the other three buttons until the user selects a folder.
When the form opens or saves an excuse, it displays the file date for the excuse file using a Label control with AutoSize set to False and BorderStyle set to Fixed3D.
But when the user has changed any of  the three fields, the form adds an asterisk (*) to the title bar.
The asterisk goes away when the data is saved or a new excuse is opened.
The form will need to keep track of  the current folder and whether or not the current excuse has been saved.
You can figure out when the excuse hasn’t been saved by using the Changed event handlers for the three input controls.
This parameter indicates whether or not the form has changed.
You’ll need a field in your form to keep track of this status.
Make the Folder button open a folder browser When the user clicks on the Folder button, the form should pop up a “Browse for Folder” dialog box.
The form will need to store the folder in a field so that the other dialog boxes can use it.
When the form first loads, the Save, Open, and Random Excuse buttons are disabled, but if the user selects a folder then the Folder button enables them.
Double-click on the input controls so the IDE builds Changed event handlers for you.
When you drag a text box to a form and double-click on it, you create a Changed event handler for that field.
Remember, the ! means NOT—so this checks if the excuse path is NOT null or empty.
Make the Save button save the current excuse to a file Clicking the Save button should bring up the Save As dialog box.
The first line of  the file is the excuse, the second is the result, and the third is the date last used (using the DateTimePicker’s ToString() method)
The Excuse class should have a Save() method to save an excuse out to a specified file.
When the Save As dialog box is opened, its folder should be set to the folder that the user selected using the Folder button, and the filename should be set to the excuse plus a “.txt” extension.
Make the Open button open a saved excuse Clicking the Open button should bring up the Open dialog box.
When the Open dialog box is opened, its folder should be set to the folder that the user selected using the Folder button.
Finally, make the Random Excuse button load a random excuse When the user clicks the Random Excuse button, it looks in the excuse folder, chooses one of  the excuses at random, and opens it.
The form will need to save a Random object in a field and pass it to one of  the overloaded constructors of  the Excuse object.
If  the current excuse hasn’t been saved, the button should pop up the same warning dialog box as the Open button.
The form uses fields to store the current Excuse object to the selected folder and remember whether or not the current excuse has changed, and to keep a Random object for the Random Excuse button.
Here’s where the filters are set for the Save As dialog.
Use the DialogResult enum returned by the Open and Save dialog boxes to make sure you only open or save if the user clicked “OK”, and not “Cancel”
The two vertical bars mean OR—this  is true if description is empty OR results is empty.
We made sure to use a using statement every time we opened a stream.
Here are the three Changed event handlers for the three input fields on the form.
If any of them are triggered, that means the excuse has changed, so first we update the Excuse instance and then we call UpdateForm(), add the asterisk to the form’s title bar, and set Changed to true.
We declared the StreamWriter inside a using statement, so its Close() method is called for us automatically!
Passing true to UpdateForm() tells it to just mark the form as changed, but not update the input controls.
Writ ing f i les usually involves making a lot of decisions You’ll write lots of  programs that take a single input, maybe from a file, and have to decide what to do based on that input.
Here’s code that uses one long if statement—it’s pretty typical.
It checks the part variable and prints different lines to the file based on which enum it uses.
There are lots of  choices, so lots of  else ifs:
Here’s an enum—we’ll want to compare a variable against each of the four members and write a different line to the StreamWriter depending on which one it matches.
We’ll also write something different if none of them match.
If we use a series of if/else statements, then we end up writing this “if (part ==[option])” over and over.
We’ve got a final else in case we didn’t find a match.
What sort of things can go wrong when you write code that has this many if/else statements? Think about typos and bugs caused by brackets, a single equals sign, etc.
Use a switch statement to choose the r ight opt ion Comparing one variable against a bunch of  different values is a really common pattern that you’ll see over and over again.
It’s so common, in fact, that C# has a special kind of statement designed specifically for this situation.
A switch statement lets you compare one variable against many values in a way that’s compact and easy to read.
Here’s a switch statement that does exactly the same thing as the series of  if/else statements on the opposite page:
A switch statement compares ONE variable against MULTIPLE possible values.
Switch statements can end with a “default:” block that gets executed if none of the other cases are matched.
You’ll start with the switch keyword followed by the variable that’s going to be compared against a bunch of different possible values.
The body of the switch statement is a series of cases that compare whatever follows the switch keyword against a particular value.
Each of these cases consists of the case keyword followed by the value to compare and a colon.
After that is a series of statements followed by “break;”
Those statements will be executed if the case matches the comparison value.
Every case ends with “break;” so C# knows where one case ends and the next begins.
There’s nothing about a switch statement that’s specifically related to files.
It’s just a useful C# tool that we can use here.
You can also end a case with “return” – the program will compile as long as there’s no way for one case to “fall through” to the next one.
Here’s a method you can add to the Deck object that does exactly that:
But what about reading the file in? It’s not quite so simple.
The switch statement starts with a value to compare against.
This switch statement is called from a method that has a suit stored in a string.
Each of these case lines compares some value against the value in the switch line.
If they match, it executes all of the following statements until it hits a break.
If none of the cases match, the statements after the default get executed instead.
The switch statement lets you test one value against a bunch of cases and execute different statements depending on which one it matches.
You can use a switch statement to build a new constructor for the Deck class that you wrote in the last chapter.
This constructor reads in a file and checks each line for a card.
There’s a method that you can find on every string that’ll come in handy: Split()
It lets you split the string into an array of  substrings by passing it a char[] array of  separator characters that it’ll use to split the string up.
This switch statement checks the first word in the line to see if it matches a value.
If it does, the right value is assigned to the value variable.
We do the same thing for the third word in the line, except we convert this one to a suit.
Add an overloaded Deck() constructor that reads a deck of cards in from a f i le.
All that code just to read in one simple card? That’s way too much work! What if my object has a whole bunch of fields and values? Are you telling me I need to write a switch statement for each of them?
There’s an easier way to store your objects in files.
Instead of  painstakingly writing out each field and value to a file line by line, you can save your object the easy way by serializing it out to a stream.
Serializing an object is like flattening it out so you can slip it into a file.
And on the other end, you can deserialize it, which is like taking it out of  the file and inflating it again.
Ok, just to come clean here: There’s also a method called Enum.Parse() — you’ll learn about it in Chapter 14 that will convert the string “Spades” to the enum value Suits.Spades.
When you create an instance of  an object, it has a state.
Everything that an object “knows” is what makes one instance of  a class different from another instance of  the same class.
When C# serializes an object, it saves the complete state of  the object, so that an identical instance (object) can be brought back to life on the heap later.
The instance variable values for width and height are saved to the file “file.dat”, along with a little more info that the CLR needs to restore the object later (like the type of the object and each of its fields)
It seems like something mysterious has to happen to an object in order to copy it off  of  the heap and put it into a file, but it’s actually pretty straightforward.
Later—maybe days later, and in a different program—you can go back to the file and deserialize it.
That pulls the original class back out of  the file and restores it exactly as it was, with all of  its fields and values intact.
But what exact ly IS an object’s state? What needs to be saved? We already know that an object stores its state in its fields.
So when an object is serialized, every one of  those fields needs to be saved to the file.
Serialization starts to get interesting when you have more complicated objects.
But what if  an object has an instance variable that’s an object reference? What about an object that has five instance variables that are object references? What if those object instance variables themselves have instance variables?
What part of  an object is potentially unique? Imagine what needs to be restored in order to get an object that’s identical to the one that was saved.
Somehow everything on the heap has to be written to the file.
Each of the passenger objects has its own references to other objects.
But don’t worry—it may sound complicated, but it all happens automatically.
C# starts with the object you want to serialize and looks through its fields for other objects.
Every single object gets written out to the file, along with all the information C# needs to reconstitute it all when the object gets deserialized.
Some people call this whole group of connected objects a “graph.”
Serializat ion le ts you read or write a whole object al l at once You’re not just limited to reading and writing lines of  text to your files.
You can use serialization to let your programs copy entire objects to files and read them back in…all in just a few lines of  code! There’s a tiny amount of  prep work you need to do—add one [Serializable] line to the top of  the class to serialize—but once you do that, everything’s ready to write.
It’s quick to copy an object out to a file or read it in from one.
You’l l need a BinaryFormatter object If  you want to serialize an object—any object—the first thing you do is create an instance of  BinaryFormatter.
It’s really straightforward to do—and all it takes is one line of  code (and an extra using line at the top of  the class file)
Now just create a stream and read or write your objects Use the Serialize() method from the BinaryFormatter object to write any object out to a stream.
And once you’ve got an object serialized out to a file, use the BinaryFormatter object’s Deserialize() method to read it back in.
The method returns a reference, so you need to cast the output so that it matches the type of  the reference variable you’re copying it to.
The Serialize() method takes an object and writes it out to a stream.
That’s a whole lot easier than building a method to write it out yourself!
When you use Deserialize() to read an object back from a stream, don’t forget to cast the return value to match the type of object you’re reading.
If you want your class to be serializable, mark it with the [Serializable] at tribute An attribute is a special tag that you can add to the top of  any C# class.
It’s how C# stores metadata about your code, or information about how the code should be used or treated.
When you add [Serializable] to the top of  a class just above the class declaration, you’re telling C# that your class is safe for serialization.
And you only use it with classes that include fields that are either value types (like an int, decimal, or enum) or other serializable classes.
If  you don’t add the attribute to the class you want to serialize, or if  you include a field with a type that isn’t serializable, then your program will have an error when you try to run it.
Do this Create a class and serialize it Remember the Guy class from Chapter 3? Let’s serialize Joe so we can keep a file that knows how much money he’s got in his pocket even after you close your program.
Here’s code to serialize it to a file called Guy_file.dat—add a “Save Joe” button and a “Load Joe” button to the form:
Run the program and play around with it If  Joe had two hundred dollars saved up from his transactions with Bob during your time running the program, it would be a pain to lose all that money just because you needed to exit.
Now your program can save Joe out to a file and restore him whenever you want.
The first one is for the file and stream methods, and the second is for serialization.
You need to add this attribute to the top of any class in order to serialize it.
Let’s serialize and deserialize a deck of cards Take a deck of  cards and write it out to a file.
All you need to do is create a stream and write out your objects.
You’ll also need to add the two card comparer classes, since Deck uses them.
The IDE will copy the files into the new project—make sure you change the namespace line at the top of  each class file to match your new project’s namespace.
Mark the classes serializable Add the [Serializable] attribute to both classes you added to the project.
Add a couple of useful methods to the form The RandomDeck method creates a random deck of  cards, and the DealCards method deals all of  the cards and prints them to the console.
If you don’t do this, C# won’t let you serialize the classes to a file.
The DealCards() method deals each of the cards off of the deck and prints it to the console.
This creates an empty deck and then adds some random cards to it using the Card class from the last chapter.
Check the console output to make sure the deck you wrote out is the same as the deck you read.
The BinaryFormatter object takes any object marked with the Serializable attribute—in this case a Deck object—and writes it out to a stream using its Serialize() method.
The BinaryFormatter’s Deserialize() method returns an Object, which is just the general type that every C# object inherits from—which is why we need to cast it to a Deck object.
Now serialize a bunch of decks to the same file Once you open a stream, you can write as much as you want to it.
You can serialize as many objects as you need into the same file.
So now add two more buttons to write out a random number of  decks to the file.
You can serialize one object after another to the same stream.
As long as you cast the objects you read off the stream to the right type, there’s no limit to the number of objects you can serialize.
It may not be something you’d read on the beach, but it’s got all the information to restore your whole deck of  cards.
Notice how the line that reads a single deck from the file uses (Deck) to cast the output of Deserialize() to a Deck.
That’s because Deserialize() returns an object, but doesn’t necessarily know what type of object.
When you serialize objects out to a file, they’re written in a binary format.
That’s why you can recognize the strings when you open up a file with serialized objects in it: that’s the most compact way C# can write strings to a file—as strings.
But writing out a number as a string would be really wasteful.
I’m not sure I like all this writing objects out to some weird file that looks like garbage when I open it up.
When I wrote the deck of cards as strings, I could open up the output in Notepad and see everything in it.
When you look at all the letters and symbols that are used in languages all around the world, you realize just how many different things need to be written to a file just to store text.
That’s why .NET encodes all of  its strings and characters in a format called Unicode.
Encoding just means taking the logical data (like the letter H) and turning it into bytes (the number 72)
It needs to do that because letters, numbers, enums, and other data all end up in bytes on disk or in memory.
And that’s why Character Map is useful—it shows you how letters are encoded into numbers.
Select the Arial font and scroll down until you reach the Hebrew letters.
As soon as you click on the letter, its Unicode number shows up in the status bar.
Unicode is an industry standard developed by a non-profit group called the Unicode Consortium, and it works across programs and different computer platforms.
When that data’s written out as bytes to a file, each of  those Unicode numbers is written out to the file.
Write a normal string out to a file and read it back Use the same WriteAllText() method that you used in the text editor to have the first button write the string “Eureka!” out to a file called “eureka.txt”
Then create a new byte array called eurekaBytes, read the file into it, and then print out all of  the bytes read:
Now open up the file in the Simple Text Editor that you wrote earlier in the chapter.
The ReadAllBytes() method returns a reference to a new array of bytes that contains all of the bytes that were read in from the file.
Make the second button display the bytes as hex numbers It’s not just Character Map that shows numbers in hex.
Almost anything you read that has to do with encoding data will show that data in hex, so it’s useful to know how to work with it.
Make the code for the second button’s event handler in your program identical to the first one, except change the Console.Write() line so it looks like this instead:
That tells Write() to print parameter 0 (the first one after the string to print) as a two-character hex code.
Make the third button write out Hebrew letters Go back to Character Map and double-click on the Shin character (or click the Select button)
Now add the code for the third button’s event handler.
It’ll look exactly like button 2, except for one change.
Click the “Copy” button in Character Map, and then paste the letters over “Eureka!” and add the Encoding.Unicode parameter, so it looks like this:
Did you notice that the IDE pasted the letters in backward? That’s because it knows that Hebrew is read right-to-left, so any time it encounters Hebrew Unicode letters, it displays them right-to-left.
Put your cursor in the middle of  the letters—the left and right arrow keys reversed! That makes it a lot easier if  you need to type in Hebrew.
The first two characters are “FF FE”, which is the Unicode way of  saying that we’re going to have a string of  two-byte characters.
Now open the file up in your Simple Text Editor—it looks right!
Since all your data ends up encoded as bytes, it makes sense to think of  a file as one big byte array.
And you already know how to read and write byte arrays.
This is a static method for Arrays that reverses the order of the bytes.
We’re just using it to show that the changes you make to the byte array get written out to the file exactly.
When the program writes the byte array out to a file, the text is in reverse order too.
These numbers are the Unicode numbers for the characters in “Hello!!”
Use a BinaryWriter to write binary data You could encode all of  your strings, chars, ints, and floats into byte arrays before writing them out to files, but that would get pretty tedious.
That’s why .NET gives you a very useful class called BinaryWriter that automatically encodes your data and writes it to a file.
All you need to do is create a FileStream and pass it into the BinaryWriter’s constructor.
Then you can call its methods to write out your data.
So add another button to your program, and we’ll show you how to use BinaryWriter()
Start by creating a Console Application and setting up some data to write to a file.
To use a BinaryWriter, first you need to open a new stream with File.Create():
Each time you do, it adds new bytes onto the end of  the file that contain an encoded version of  whatever data you passed it as a parameter.
Each Write() statement encodes one value into bytes, and then sends those bytes to the FileStream object.
You can pass it any value type, and it’ll encode it automatically.
Here’s a hint: Strings can be different lengths, so the string has to start with a number to tell .NET how long it is.
Also, you can look up the string and char Unicode values using Character Map.
If you use File.Create(), it’ll start a new file—if there’s one there already, it’ll blow it away and start a brand new one.
There’s also the File.OpenWrite() method, which opens the existing one and starts overwriting it from the beginning.
Now use the same code you used before to read in the file you just wrote.
Can you figure out what bytes correspond to each of  the five Write() statements? Mark each group of  bytes with the name of  the variable.
The FileStream writes the bytes to the end of the file.
Use BinaryReader to read the data back in The BinaryReader class works just like BinaryWriter.
You create a stream, attach the BinaryReader object to it, and then call its methods.
But the reader doesn’t know what data’s in the file! And it has no way of  knowing.
So you’ll need to tell the BinaryReader exactly what types to read from the file.
Add one more button to your form, and have it read the data you just wrote.
If you’d used long or double, then they’d take up 8 bytes each.
If you use the Windows calculator to convert these bytes from hex to decimal, you can see that these are the numbers in byteArray.
The first byte in the string is 6—that’s the length of the string.
Start out by setting up the FileStream and BinaryReader objects:
You tell BinaryReader what type of  data to read by calling its different methods.
Each value type has its own method in BinaryReader() that returns the data in the correct type.
Most don’t need any parameters, but ReadBytes() takes one parameter that tells BinaryReader how many bytes to read.
You tell BinaryReader what type of  data to read by calling its different methods.
Replace the line that reads the float with a call to ReadInt32()
You’ll need to change the type of floatRead to int.
Then you can see for yourself what it reads from the file.
You can read and write serialized f i les manually, too Serialized files don’t look so pretty when you open them up in Notepad.
You’ll find all the files you write in your project’s bin\Debug folder—let’s take a minute and get more acquainted with the inner workings of  a serialized file.
Serialize two Card objects to different files Use the serialization code you’ve already written to serialize the Three of  Clubs to three-c.dat and Six of  Hearts to six-h.dat.
Check to make sure that both files were written out and are now in a folder, and that they both have the same file size.
Write a loop to compare the two binary files We used the ReadByte() method to read the next byte from a stream—it returns an int that contains the value of  that byte.
We also used the stream’s Length field to make sure we read the whole file.
This loop examines the first byte from each of the files and compares them, then the second byte, then the third, etc.
When it finds a difference, it writes a line to the console.
There are some words in the file, but it’s mostly unreadable.
The two files are read into two different byte arrays, so they can be compared byte by byte.
Since the same class was serialized to two different files, they’ll be almost identical…but let’s see just HOW identical they are.
When you write to a file, you don’t always start from a clean slate!
It doesn’t delete the file—it just starts overwriting the data starting at the beginning.
Take a look at the console output to see how the two files differ The console should show that two bytes differ:
And the second difference—six versus three—is pretty obviously the card’s value.
You might see different byte numbers, which isn’t  surprising: you might be using a different namespace, which would change the length of  the file.
Write code to manually create a new file that contains the King of Spades We’ll take one of  the arrays that we read, alter it to contain a new card, and write it back out.
Now deserialize the card from king-s.dat and see if  it’s the King of  Spades!
Now that you know which bytes contain the suit and value, you can change just those bytes in the array before it gets written out to king-s.dat.
If you found different byte numbers in step #3, substitute them in here.
Remember how the namespace was included as part of the serialized file? If your namespace is different, then the byte numbers will be different, too.
Find where the f i les differ, and use that information to alter them.
Hmm, if byte #322 in the serialized file represents the suit, then we should be able to change the suit of the card by reading that file in, changing that one byte, and writing it out again.
Remember, your own serialized file might store the suit at a different location.
The loop you just wrote pinpoints exactly where the two serialized Card files differ.
Since the only difference between the two objects were their Suit and Value fields, then that should be the only difference in their files, too.
So if  we find the bytes that hold the suit and value, we should be able to change them to make a new card with whatever suit and value we want!
Flip to leftover #9 in the appendix to learn more about it.
There’s another option—it’s a format called a “hex dump,” and it’s a pretty standard way to look at binary data.
It’s definitely more informative than looking at the file in Notepad.
Hexadecimal—or “hex”—is a convenient way to display bytes in a file.
Every byte takes 2 characters to display in hex, so you can see a lot of  data in a really small space, and a format that makes it easy to spot patterns.
Here’s what that same file looks like as a hex dump, using one of  any number of  free hex dump programs available for Windows:
Working with binary f i les can be tr icky What do you do if  you have a file and you aren’t quite sure what’s inside it? You don’t know what application created it, and you need to know something about it—but when you open it in Notepad, it looks like a bunch of  garbage.
What if  you’ve exhausted all your other options, and really need to just look inside? Looking at that picture, it’s pretty clear that Notepad just isn’t the right tool.
You can immediately see the numeric value of each byte in the file.
The number at the beginning of each line is the offset (or distance into the file) of the first byte in the line.
You still get to see the original text, but the garbage characters are replaced with dots.
How to make a hex dump Start with some familiar text:
We the People of the United States, in Order to form a more perfect Union...
Here’s what a hex dump of  that text would look like:
The reason some of  the “numbers” have letter values is that they’re hexadecimal (or hex)
Each line in our hex dump represents sixteen characters in the input that was used to generate it.
Other hex dumps look slightly different, but this one will do for us.
Use f i le streams to build a hex dumper A hex dump is a hexadecimal view of  the contents of  a file, and it’s a really common way for programmers to take a deep look at a file’s internal structure.
Most operating systems ship with a built-in hex dump utility.
Again, you can immediately see the numeric value of each byte in the file.
We’ll add the number at the beginning of each line by using the offset of the first byte in the line.
And we’ll need to replace the garbage characters with periods.
Working with hex You can put hex numbers directly into your program—just add the characters 0x (a zero followed by an x) in front of  the number:
When you use the + operator to concatenate a number into a string, it gets converted to decimal.
Format() method to convert your number to a hex-formatted string instead:
Our hex dumper will write its dump out to a file, and since it’s just writing text a StreamWriter will do just fine.
But we can also take advantage of  the ReadBlock() method in StreamReader.
It reads a block of  characers into a char array—you specify the number of  characters you want to read, and it’ll either read that many characters or, if  there are fewer than that many left in the file, it’ll read the rest of  the file.
So add one more button to your program—add this hex dumper to it.
Change the first two lines so that they point to real files on your hard drive.
Then see if  you can modify it to use the Open and Save As dialog boxes.
You can convert a char[] array to a string by passing it to the overloaded constructor for string.
Every string has a Substring method that returns a piece of the string.
In this case, it returns the first charactersRead characters starting at the beginning (position 0)
Look back at the top of the loop to see where charactersRead is set—the ReadBlock() method returns the numb.
A StreamReader’s EndOfStream property returns false if there are characters still left to read in the file.
This ReadBlock() call reads up to 16 characters into a char array.
This loop goes through the characters and prints each of them to a line in the output.
StreamReader and StreamWriter wil l do just f ine (for now) The reason the method’s called “ReadBlock()” is that when you call it, it “blocks” (which means it keeps executing and doesn’t return to your program) until it’s either read all the characters you asked for or run out of data to read.
Use Stream.Read() to read bytes from a stream The hex dumper works just fine for text files.
WriteAllBytes() to write an array of  bytes with values over 127 to a file and then run it through your dumper.
So let’s do this right—by reading the bytes directly from the stream using the Stream.Read() method.
And as a bonus, we’ll build it just like a real hex dump utility: we’ll make it take a filename as a command-line argument.
The code for the program is on the facing page.
Here’s what it will look like when you run the program:
If you run hexdumper without any arguments, it returns an error message and exits with an error code.
It also exits with an error if you pass it the name of a file that doesn’t exist.
If you pass it a valid filename, it’ll write a hex dump of the contents of the file to the console.
Using command-line arguments Every time you create a new Console Application project, Visual Studio creates a Program class with an entry point method that has this declaration: static void Main(string[] args)
If you run your program with command-line arguments, the args parameter will contain those arguments.
And it’s not just for Console Applications, either: open up any Windows Forms Application project’s Program.cs file, and you’ll see the same thing.
You’ll want to pass command-line arguments when you’re debugging your program.
To pass arguments when you run your program in the IDE’s debugger, choose “Properties…” from the Project menu and enter them on the Debug tab.
If args.Length is not equal to 1, then either zero or more than one argument was passed on the command line.
If it doens’t exist, print a different error message and return a different exit code.
If you pass it an int, it will return that error code (which is useful when writing command scripts and batch files)
We don’t need a StreamReader because we’re reading bytes directly from the stream.
This part of the program is exactly the same, except the buffer contains bytes and not characters (but String.Format() does the right thing in either case)
Use the Stream.Read() method to read bytes directly into a buffer.
Notice how this time the buffer is a byte array.
That makes sense—we’re reading bytes, not characters from a text file.
This is an easy way to convert a byte array to a string.
It’s part of Encoding.UTF8 (or another Unicode encoding, or ASCII, or another encoding) because different encodings can map the same byte array to different strings.
Q: If the FileStream has methods for reading and writing, why do I ever need to use StreamReader and StreamWriter?
Why was “Eureka!” written out with one byte per character, but when I wrote out the Hebrew letters they took up two bytes? And what was that “FF FE” thing at the beginning of the bytes?
If you’re writing a string that only has Unicode characters with low numbers, it writes one byte per character.
But if it’s got high‑numbered characters, they’ll be written using two or more bytes each.
The encoding is called UTF-8, which .NET uses by default.
Make the Excuse class serializable Mark the Excuse class with the [Serializable] attribute to make it serializable.
Change the Excuse.Save() method to serialize the excuse When the Save() method writes a file out to the folder, instead of  using StreamWriter to write the file out, have it open a file and serialize itself  out.
You’ll need to figure out how the current class can deserialize itself.
Hint: What keyword can you use inside of a class that returns a reference to itself?
Wow, that was really easy! All the code for saving and opening excuses was inside the Excuse class.
I just had to change the class—I barely had to touch the form at all.
It’s like the form doesn’t even care how the class saves its data.
Now just change the form so it uses a new file extension There’s just one very small change you need to make to the form.
Since we’re no longer working with text files, we shouldn’t use the .txt extension anymore.
Change the dialog boxes, default filenames, and directory search code so that they work with *.excuse files instead.
That’s right! Your code was very easy to change because the class was well encapsulated.
When you’ve got a class that hides its internal operations from the rest of  the program and only exposes the behavior that needs to be exposed, it’s called a well-encapsulated class.
In the Excuse Manager program, the form doesn’t have any information about how excuses are saved to files.
It just passes a filename into the excuse class, and the class takes care of  the rest.
That makes it very easy to make big changes to how your class works with files.
The better you encapsulate your classes, the easier they are to alter later on.
Remember how encapsulation was one of the four core OOP principles? Here’s an example of how using those principles makes your programs better.
We pass in “this” because we want this class to be serialized.
The only change to the form is to have it change the file extension it passes to the Excuse class.
The constructor for loading random excuses needs to look for the “.excuse” extension instead of “*.txt” files.
Standard save and open dialog boxes do the trick here.
You only need to change these three statements in the form: two in the Save button’s Click event, and one in the Open button’s—they just change the dialogs to use the .excuse extension, and set the default save filename.
An encoding system that assigns a uniue number to each character.
The StreamReader method that reads data into a char[] array [readblock]
This BinaryFormatter method reads an object from a stream [deserialize]
You’ve worked your tail off, waded through technical manuals and a few engaging.
Head First books, and you’ve reached the pinnacle of your profession: master.
But you’re still getting panicked phone calls in the middle of the night.
Nothing pulls you out of the programming groove like having to fix a strange.
Better yet, you can even react to those problems, and keep things.
Brian needs his excuses to be mobile Brian recently got reassigned to the international division.
But he still needs to keep track of  his excuses, so he installed the program you built on his laptop and takes it with him everywhere.
Same ol’ Brian… always looking for an excuse to get out of work.
An unhandled exception…must have been a problem we didn’t account for.
But the program isn’t working! Brian clicks the “Random Excuse” button, and gets a pretty nasty looking error.
There are five different exceptions that this code throws, and the error messages are shown on the right.
It’s your job to match the line of code that has a problem with the exception that line generates.
When you have a reference that doesn’t point to any object, it gets a special value called null.
Setting a reference to null tells C# it doesn’t point to anything.
Your job was to match the line of code that has a problem with the exception that line generates.
C# lets you cast myBee to a float—but th ere’s no way.
The Parse() method wants you to give it a string in a certain format.
The for loop will create a string called beesWeCanFeed that contains a number with o.
You’d never actually get all these exceptions in a row—the program would throw the first exception and then stop.
You’d only get to the second exception if you fixed the first.
Setting the anotherBee reference variable equal to null tells C# that it doesn’t point to anything.
So instead of pointing to an object, it points to nothing.
You can see just by looking at the code that there’s something wrong.
These problems were preventable—and the more you know about exceptions, the better you’ll be at keeping your code from crashing.
Dividing any integer by zero always throws this kind of exception.
Even if you don’t know the value of queens, you can prevent it just by checking the value to make sure it’s not zero before you divide it into drones.
When your program throws an except ion, .NET generates an Except ion object.
You’ve been looking at .NET’s way of  telling you something went wrong in your program: an exception.
In .NET, when an exception occurs, an object is created to represent the problem.
For example, suppose you have an array with four items.
Then, you try and access the sixteenth item (index 15, since we’re zero-based here):
While Jim usually hates peanut butter, he made an exception for Ken’s peanut butter fudge.
You may have code to fix, or you may just need to make some changes to how you handle a particular situation in your program.
You’ve also got information about exactly where in the code the problem occurred, making it easy to track down (even if  you’ve got thousands of  lines of  code)
The exception object has a message that tells you what’s wrong and a list of all of the calls that were made to the system’s memory leading up to.
You can see this detail by clicking on the View Detail link in the unhandled exception window.
As soon as your program runs into an exception, it generates an object with all the data it has about it.
Why are there so many different kinds of exceptions, again?
Q: So exceptions are there to help me, not just cause a pain in my butt?
Q: So when my code throws an exception, it’s not necessarily because I did something wrong?
Q: Once I knew what I was looking for, it was pretty clear that the code on the previous page was going to crash.
Exceptions are all about helping you find and fix situations where your code behaves in ways you didn’t expect.
Brian’s code did something unexpected When Brian wrote his excuse manager, he never expected the user to try to pull a random excuse out of  an empty directory.
The problem happened when Brian pointed his Excuse Manager program at an empty folder on his laptop and clicked the Random button.
Let’s take a look at it and see if  we can figure out what went wrong.
Here’s the unhandled exception window that popped up when he ran the program outside the IDE:
It’s telling us that the index was outside the bounds of  the array, right? So let’s look for an array in the code for the Random Excuse button’s event handler:
But it creates a new Excuse object using one of  the overloaded constructors.
We must be trying to use an index that’s past the end of the array.
Exceptions are a really useful tool that you can use to find places where your code acts in ways you don’t expect.
A lot of  programmers get frustrated the first time they see an exception.
But exceptions are really useful, and you can use them to your advantage.
When you see an exception, it’s giving you a lot of clues to help you figure out when your code is reacting to a situation that you didn’t anticipate.
And that’s good for you: it lets you know about a new scenario that your program has to handle, and it gives you an opportunity to do something about it.
Hey, we can test for that! All we need to do is add a check to make sure the directory’s not empty before we open a file, and the nasty unhandled exception window will be replaced with an informative message box.
By checking for excuse files in the folder before we create the Excuse object, we can prevent the exception from being thrown—and pop up a helpful message box, too.
Sometimes they identify bugs, but a lot of the time they’re just telling me that something happened.
All except ion objects inherit from Except ion .NET has lots of  different exceptions it may need to report.
Since many of  these have a lot of  similar features, inheritance comes into play.
The Message property stores an easy-to-read message about what went wrong.
And StackTrace tells you what code was being executed when the exception occurred, and what led up to the exception.
So you can write your own exception classes, and use Message and any other Exception properties and methods.
It’s really useful that .NET gives us so many types of exceptions, because each different exception is thrown in a different situation.
You can learn a lot about the unexpected action that’s causing the exception just by looking at which one was thrown.
ToString() generates a summary of all of the information in the exception’s fields and returns it in a string.
Continue: run until the next breakpoint is hit or the program ends.
The debugger helps you track down and prevent except ions in your code Before you can add exception handling to your program, you need to know which statements in your program are throwing the exception.
That’s where the debugger that’s built into the IDE can be really helpful.
You’ve been using the debugger throughout the book, but now let’s take a few minutes and really dig into it.
When you run the debugger, the IDE pops up a toolbar with some really useful buttons.
Take a minute and hover your mouse cursor over each of  them to see what it does:
Put your IDE into Expert mode to expand the Debug toolbar When you first start using Visual Studio 2010 Express, it’s set to Basic Settings mode, which is great for getting started.
But now that you’ve been using it for a while, let’s change it.
You’ll see that it added two new buttons (the other editions already have them turned on):
The Debug toolbar only shows up when you’re debugging your program in the IDE.
So you’ll have to run a program in order to hover over the toolbar icons.
Locals: show the values of  all of the local variables currently in.
Break all causes the program to stop in its tracks as if  it hit a.
Toggle hexadecimal mode on and off Press the Hex button to turn hexadecimal mode on, then hover over any field or variable.
The IDE automatically converts values to hex for you—and you learned last chapter how valuable that can be.
Here’s the same value displayed in hex mode on the left and decimal mode on the right.
Use the IDE’s debugger to ferret out exact ly what went wrong in the Excuse Manager Let’s use the debugger to take a closer look at the problem that we ran into in the Excuse Manager.
You’ve probably been using the debugger a lot over the last few chapters, but we’ll go through it step by step anyway—to make sure we don’t leave out any details.
Add a breakpoint to the Random button’s event handler You’ve got a starting point—the exception happens when the Random Excuse button is clicked after an empty folder is selected.
Select an empty folder and click the Random button to make your program break at the breakpoint:
Step through the event handler and into the Excuse constructor Use the Step Into command (using either the toolbar or the F11 key) to move through the application line by line.
Now select a folder with excuses in it and click the Random button again, then keep stepping into the code.
Make sure you’re using Step Into, not Step Over—although you might want to step over the CheckChanged() method.
When it gets to the line that creates the new Excuse object, it’ll jump straight into the constructor.
Step past the first line so it sets the fileNames variable.
Then hover over the variable to see its value, too.
Hover over the fileNames.Length property to show the hovering expression window, then click the pushpin to pin it so it doesn’t disappear.
Use the Watch window to reproduce the problem You’ve already seen how powerful the Watch window is.
Here’s what the Watch window should look like for a folder with three excuses (so fileNames has length 3)
Set fileNames equal to an empty string array The Watch window has another very useful feature—it lets you change the value of  variables and fields that it’s displaying.
It even lets you execute methods and create new objects—and when you do, it displays its re-evaluate icon ( ) that you can click to tell it to execute that line again, because sometimes running the same method twice will generate different results (like with Random)
Reproduce the problem that threw Brian’s original exception Here’s where debugging gets really interesting.
As soon as you type it in, the Watch window evaluates it…and that throws the exception.
It tells you that it found the exception by displaying an exclamation point, and displays the text of  the exception in the Value column.
When you get an exception, you can go back and reproduce it in the debugger.
That’s another way that more descriptive exception messages can help you fix your code.
This exclamation point is the Watch window’s way of telling you it found an exception.
This icon tells the Watch window to re-evaluate the Next() method.
We’ll use the Watch window to reproduce the problem that caused the exception.
We know the problem happened with an empty fileNames array, so we’ll use the Watch window to change its value to an empty string array.
Q: How come Brian’s unhandled exception window looked different from the one in the IDE?
Q: So that’s it? When an exception happens outside the IDE, my program just stops and there’s nothing I can do about it?
Q: How do I know where to put a breakpoint?
Q: Can I run any method in the Watch window?
Q: Wait, so isn’t it possible for me to run something in the Watch window that’ll change the way my program runs?
When you run your program inside the IDE, an unhandled exception will cause it to break as if it had run into a breakpoint.
Uh oh—the code’s st i l l got problems… Brian was happily using his Excuse Manager when he remembered that he had a folder full of  excuses that he made when he first built the program—but he forgot that he made that folder before he added serialization to the program.
You can re-create Brian’s problem—just create your own text-based Excuse file using Notepad.
Pop open the Excuse Manager and open up the excuse.
It throws an exception! But this time, click on the Details button so we can take a closer look at what it says.
Pay attention to the call stack—that’s what it’s called when a method is called by another method, which is called by another method, etc.
So the Details button in the unhandled exception window tells you a lot about what caused this problem.
Can you think of  anything you can do about it?
Can we figure out what line threw it from the exception details?
You can learn a lot from the call stack, which tells you which methods were running.
You can see that the Excuse class’s OpenFile() method was being called from its constructor (“.ctor”), which was called from the “Random Excuse” button’s click event handler.
Of course the program’s gonna crash—I gave it a bad file.
You can’t expect me to do anything about that, right?
Yes, it’s true that users screw up all the time.
But that doesn’t mean you can’t do anything about it.
There’s a name for programs that deal with bad data, malformed input, and other unexpected situations gracefully: they’re called robust programs.
And C# gives you some really powerful exception handling tools to help you make your programs more robust.
Because while you can’t control what your users do, you can make sure that your program doesn’t crash when they do it.
After the Tacoma Narrows Bridge disaster, the civil engineering team looked for a more robust design for the bridge that would replace it.
BinaryFormatter will throw an exception if there’s anything at all wrong with a serialized file.
When you try to deserialize an object from a file, BinaryFormatter expects the file to contain a serialized object that matches the class that it’s trying to read.
Handle except ions with try and catch In C#, you can basically say, “Try this code, and if  an exception occurs, catch it with this other bit of  code.” The part of  the code you’re trying is the try block, and the part where you deal with exceptions is called the catch block.
In the catch block, you can do things like print a friendly error message instead of  letting your program come to a screeching halt:
This is the simplest kind of exception handling: stop the program, write out the exception message, and keep running.
The catch keyword means that the block immediately following it contains an exception handler.
If throwing an exception makes your code automatically jump to the catch block, what happens to the objects and data you were working with before the exception happened?
Put the code that might throw an exception inside the try block.
If no exception happens, it’ll get run exactly as usual, and the statements in the catch block will be ignored.
But if a statement in the try block throws an exception, the rest of the try block won’t get executed.
In this case, we’ll put the existing code in it.
When an exception is thrown, the program immediately jumps to the catch statement and starts executing the catch block.
Let’s say your user is using your code, and gives it some input that it didn’t expect.
That method does something risky, something that might not work at runtime.
You need to know that the method you’re calling is risky.
What happens when a method you want to call is r isky?
You then write code that can handle the failure if it does happen.
They feed all sorts of  weird data into your program, and click on things in ways you never expected.
And that’s just fine, because you can handle unexpected input with good exception handling.
If you can come up with a way to do a less risky thing that avoids throwing the exception, that’s the best possible outcome! But some risks just can’t be avoided, and that’s when you want to do this.
Q: How can a program suggest a solution to a problem it doesn’t even know about in advance?
Q: So the debugger should really only be used to troubleshoot exceptions then?
Q: I’m not sure I totally got what you did with the Watch window.
The catch block is only executed when code in the try block throws an exception.
It gives you a chance to make sure your user has the information to fix the problem.
Any changes you make in the Watch window just affect the data in memory, and only last as long as the program is running.
Restart your program, and values that you changed will be undone.
An important part of  exception handling is that when a statement in your try block throws an exception, the rest of  the code in the block gets short-circuited.
The program’s execution immediately jumps to the first line in the catch block.
Make sure that you’ve incorporated all of  the code from this chapter into the Random Excuse button’s Click event handler in your Excuse Manager.
Place a breakpoint on the first line in the event handler.
Click the Folder button and specify a folder with a single excuse file in it—and make sure it’s not a valid excuse file (but still has the “.excuse” extension)
The debugger should break the program at the breakpoint you placed earlier.
Press the Step Over button (or F10) six times to get to the statement that calls the Excuse constructor.
Use Step Into (F11) to step into the new statement.
The debugger will jump to the Excuse constructor, and position its yellow “next statement” bar over the declaration line in the code.
Keep hitting Step Into (F11) to step into the OpenFile() method.
Use the debugger to fol low the try/catch f low.
Step over the statements until your yellow “next statement” bar shows that the next statement to get executed will create the new Excuse object.
Here’s the breakpoint we placed earlier on the first line of the event handler.
Use the Step Over (F10) command in the debugger so it doesn’t step into the CheckChanged() method.
As soon as you step into the new statement that creates the Excuse object, the debugger jumps to the constructor code.
As soon as the debugger executes the Deserialize() statement, the exception is thrown and the program short-circuits right past the call to UpdateForm() and jumps straight to the catch block.
You’ve noticed by now that a constructor doesn’t have a return value, not even void.
Its only purpose is to initialize an object—which is a problem for exception handling inside the.
When an exception is thrown inside the constructor, then the statement that tried to instantiate the class won’t end up with an instance of the object.
That’s why you had to move the try/catch block to the button’s event handler.
That way, if there’s an exception in the constructor, the code won’t expect CurrentExcuse to contain a valid Excuse object.
Here’s a career tip: a lot of C# programming job interviews include a question about how you deal with exceptions in a constructor.
Start the program again by pressing the Continue button (or F5)
It’ll begin running the program again, starting with whatever’s highlighted by the yellow “next statement” block—in this case, the catch block.
The debugger will highlight the catch statement with its yellow “next statement” block, but it shows the rest of the block in gray to show you that it’s about to execute the whole thing.
If you have code that ALWAYS should run, use a f inally block When your program throws an exception, a couple of  things can happen.
If  the exception isn’t handled, your program will stop processing and crash.
If  the exception is handled, your code jumps to the catch block.
But what about the rest of  the code in your try block? What if  you were closing a stream, or cleaning up important resources? That code needs to run, even if  an exception occurs, or you’re going to make a mess of  your program’s state.
The finally block always runs, whether or not an exception was thrown.
Here’s how you’d use it to finish the event handling in the Random Excuse button:
If the Excuse constructor throws an exception, we have no way of knowing what’s in CurrentExcuse.
But you do know that no instance of Excuse was created.
So the catch block creates a new Excuse object and clears out all its fields.
The finally block makes sure that UpdateForm() gets run whether or not an exception was thrown.
So if the Excuse constructor successfully read an excuse, it’ll call UpdateForm(), but it’ll also call it if the constructor threw an exception and cleared out the excuse.
You typically follow a catch statement with a specific kind of  exception telling it what to catch.
It’s valid C# code to just have “catch (Exception)” and you can even leave the exception type out and just use catch.
When you do that, it catches all exceptions, no matter what type of  exception is thrown.
But it’s a really bad practice to have a catch-all exception handler like that.
Your code should always catch as specific an exception as possible.
Update the Random Excuse button’s event handler with the code on the facing page.
Then place a breakpoint on the first line in the method and debug the program.
Run the program normally, and make sure that the Random Excuse button works when you set the program’s folder to one with a bunch of  normal excuse files in it.
Step through the rest of  the Random Excuse button’s event handler and make sure it runs the way you expect it to.
It should finish the try block, skip over the catch block (because no exceptions were thrown), and then execute the finally block.
Now set the program’s folder so that it’s pointed to the folder with one malformed excuse file in it and click the Random Excuse button.
It should start executing the try block, and then jump to  the catch block when it throws the exception.
After it finishes all of  the statements in the catch block, it’ll execute the finally block.
When the “next statement” bar and the breakpoint are on the same line, the IDE shows you the yellow arrow placed over the big red dot in the margin.
So every time my program runs into an exception, it’s going to stop whatever it’s doing unless I specifically write code to catch it.
Q: OK, so now what’s a handled exception and what’s an unhandled exception?
Q: But isn’t it easier to use a catch-all exception? Isn’t it safer to write code that always catches every exception?
Q: What happens when you have a catch that doesn’t specify a particular exception?
Q: If a catch block with no specified exception will catch anything, why would I ever want to specify?
Q: Does all error handling happen in a try/catch/finally sequence?
That’s why the program stops whenever it runs into one.
Pool Puzzle Your job is to take code snippets from.
You can use the same snippet more than once, and you won’t need to use all the snippets.
Note: Each snippet from the pool can be used more than once!
This catch block only catches exceptions where the code divides by zero.
The clue that this is a FileStream is that it has an OpenRead() method and throws an IOException.
You already know that you always have to close files when you’re done with them.
If you don’t, the file will be locked open, and if you try to open it again it’ll throw an IOException.
This code opens a file called “wobbiegong”  and keeps it open the first time it’s called.
But it never closed the file, which causes it to throw an IOException.
Joey.Wombat() is called three times, and the third time it returns zero.
But you should also avoid other things we do to make puzzles more interesting, like using obfuscated variable names.
Use the Except ion object to get information about the problem We’ve been saying all along that .NET generates an Exception object when an exception is thrown.
When you write your catch block, you have access to that object.
An object is humming along, doing its thing, when it encounters something unexpected and throws an exception.
Inside the catch block, it gave the exception a name: ex.
The exception object stays around until the catch block is done.
When you specify a type of exception in the catch block, if you provide a variable name, then your code can use it to access the Exception object.
Use more than one catch block to handle mult iple types of except ions You know that you can catch a specific type of  exception…but what if  you write code where more than one problem can occur? In these cases, you may want to write code that handles each different type of  exception.
That’s where using more than one catch block comes in.
Here’s an example from the code in the beehive nectar processing plant.
You can see how it catches several kinds of exceptions.
In some cases it uses properties in the Exception object.
It’s pretty common to use the Message property, which usually contains a description of  the exception that was thrown.
You can also call throw; to rethrow the message, so it can be handled further up the call stack.
When you have several catch blocks, they’re examined in order.
In this code, first it checks for a VatEmptyException and then a HiveLogException.
This catch block assigns the exception to the variable ex, which it can use to get information from the Exception object.
You can also call the exception’s ToString() method to get a lot of the pertinent data into your MessageBox.
If you won’t use the Exception object, there’s no need to declare it.
It’s fine for two blocks to use the same name (“ex”) for the Exception.
Sometimes you want to bubble an exception up to the method that called this one by using throw; to rethrow the exception.
One class throws an exception, another class catches the exception When you’re building a class, you don’t always know how it’s going to be used.
Sometimes other people will end up using your objects in a way that causes problems—and sometimes you do it yourself ! That’s where exceptions come in.
The whole point behind throwing an exception is to see what might go wrong, so you can put in place some sort of  contingency plan.
You don’t usually see a method that throws an exception and then catches it.
An exception is usually thrown in one method and then caught in a totally different one—usually in a different object.
Instead of this… Without good exception handling, one exception can halt the entire program.
Here’s how it would work in a program that manages bee profiles for a queen bee.
The BeeProfile object can intercept the exception and add a log entry.
Then it can turn around and throw the exception back to the hive, which catches it and recovers gracefully.
The BeeProfile object tried to read a file but it wasn’t there, so File.Open() threw an exception.
This BeeProfile object’s constructor expects the filename for a profile data file that it’ll open using File.Open()
If there’s a problem opening the file, the program bombs out.
Now when the hive tries to create a new BeeProfile object by passing it an invalid filename, it can trust BeeProfile to log the error and then alert it to the problem by throwing an exception.
The hive can catch the exception and take some corrective action—in this case, recreating the bee profile.
Notice how the BeeProfile object intercepts the exception, logs it using its WriteLogEntry() method, and then throws it again so it’s passed along to the hive.
Of course, one method in a single class can throw a method that’s caught by another method in the same class.
Bees need an OutOfHoney except ion Your classes can throw their own exceptions.
For example, if  you get a null parameter in a method that was expecting a value, it’s pretty common to throw the same exception a .NET method would:
But sometimes you want your program to throw an exception because of  a special condition that could happen when it runs.
The bees we created in the hive, for example, consume honey at a different rate depending on their weight.
If  there’s no honey left to consume, it makes sense to have the hive throw an exception.
You can create a custom exception to deal with that specific error condition just by creating your own class that inherits from Exception and then throwing the exception whenever you encounter a specific error.
You can catch a custom exception by name just like any other exception, and do whatever you need to do to handle it.
You need to create a class for your exception and make sure that it inherits from System.
Notice how we’re overloading the constructor so we can pass an exception message.
In this case, if the hive is out of honey none of the bees can work, so the simulator can’t continue.
The only way to keep the program working once the hive runs out of honey is to reset it, and we can do that by putting the code to reset it in the catch block.
If there’s honey in the hive, the exception will never get thrown and this code will run.
Your methods can throw this exception if they get invalid or unexpected values in their parameters.
Exception Magnets Arrange the magnets so the application writes the output to the console.
Exception Magnets Solution Arrange the magnets so the application writes the output to the console.
This line defines a custom exception called MyException, which gets caught in a catch block in the code.
The doRisky() method only throws an exception if it’s passed the string “yes”
This line only gets executed if doRisky() doesn’t throw the exception.
The Zero() method either prints “thaws” or “throws”, depending on whether it was passed “yes” or something else as its test parameter.
The finally block makes sure that the method always prints “w”
And the “s” is printed outside the exception handler, so it always prints, too.
An easy way to avoid a lot of problems: using gi ves you try and f inally for free You already know that using is an easy way to make sure that your files always get closed.
But what you didn’t know is that it’s really just a C# shortcut for try and finally!
When you use a using statement, you’re taking advantage of finally to make sure its Dispose() method is always called.
Remember, when you declare a reference in a “using” statement, its Dispose() method is automatically called at the end of the block.
The IDisposable interface only has one member: the Dispose() method.
Whatever you put in this method will get executed at the end of the using statement…or whenever Dispose() is called manually.
Your object must implement IDisposable if you want to use your object within a using statement.
You’ll see nested using statements like this when you need to declare two IDisposable references in the same block of code.
Except ion avoidance: implement IDisposable to do your own cleanup Streams are great, because they already have code written to close themselves when the object is disposed of.
But what if  you have your own custom object, and it always needs to do something when it’s disposed of ? Wouldn’t it be great if  you could write your own code that got run if  your object was used in a using statement?
C# lets you do just that with the IDisposable interface.
Implement IDisposable, and write your cleanup code in the Dispose() method, like this:
This particular code empties any remaining nectar into the hive and logs a message.
It’s important, and must happen, so we put it in the Dispose() method.
First, let’s use a built-in object Stream, which implements IDisposable.
Then, we’ll work with our updated Nectar object, which also implements IDisposable:
The Nectar object uses the log stream, which will close automatically at the end of the outer using statement.
Then the Bee object uses the Nectar object, which will add its nectar to the hive automatically at the end of the inner using statement.
IDisposable is a really effective way to avoid common exceptions and problems.
Make sure you use using statements any time you’re working with any class that implements it.
You can only use a class in a “using” statement if it implements IDisposable; otherwise, your program won’t compile.
One of  the guidelines for implementing IDispose is that your Dispose() method can be called multiple times without side effects.
This Dispose() method was written so it could be called many times, not just once.
If try/catch is so great, why doesn’t the IDE just put it around everything? Then we wouldn’t have to write all these try/ catch blocks on our own, right?
You want to know what type of exception is thrown, so you can handle that exception.
There’s more to exception handling than just printing out a generic error message.
If  we have an exception related to databases, we might send an email to the database administrator.
This is why there are so many classes that inherit from Exception, and why you may even want to write your own classes to inherit from Exception.
Q: Can I only use objects that implement IDisposable with a using statement?
Q: Can you call Dispose() outside of a using statement?
Does that mean it’s OK to have a try and finally without a catch?
The worst catch block EVER: catch-all plus comments A catch block will let your program keep running if  you want.
An exception gets thrown, you catch the exception, and instead of shutting down and giving an error message, you keep going.
Take a look at this Calculator class, which seems to be acting funny all the time.
Note from Jim: we need to figure out a way to prevent.
Just because you can keep your program running doesn’t mean you’ve handled your exceptions.
In the code above, the calculator won’t crash…at least, not in the Divide() method.
But what if some other code calls that method, and tries to print the results? If  the divisor was zero, then the method probably returned an incorrect (and unexpected) value.
Instead of  just adding a comment and burying the exception, you need to handle the exception.
And if  you’re not able to handle the problem, don’t leave empty or commented catch blocks! That just makes it harder for someone else to track down what’s going on.
It’s better to let the program continue to throw exceptions, because then it’s easy to figure out what’s going wrong.
The programmer thought that he could bury his exceptions by using an empty catch block, but he just caused a headache for whoever had to track down problems with it later.
Remember, when your code doesn’t handle an exception, the exception bubbles up the call stack.
Letting an exception bubble up is a perfectly valid way of handling an exception.
It’s sort of like using exception handling to place a marker in the problem area.
This still needs to be fixed, but short-term, this makes it clear where the problem occurred.
Still, wouldn’t it be better to figure out why your Divide method is being called with a zero divisor in the first place?
Handling exceptions doesn’t always mean the same thing as FIXING exceptions.
But it’s way worse to have no idea why it’s crashing or what it’s doing to users’ data.
That’s why you need to be sure that you’re always dealing with the errors you can predict and logging the ones you can’t.
Temporary solut ions are OK (temporarily) Sometimes you find a problem, and know it’s a problem, but aren’t sure what to do about it.
In these cases, you might want to log the problem and note what’s going on.
That’s not as good as handling the exception, but it’s better than doing nothing.
Only throw custom exceptions if you need to give custom information.
Think about code in your try block that COULD get short-circuited.
Put a breakpoint on the first line of  the Excuse.Save() method, then run the program and save an excuse.
When the program breaks, add a watch for the LastUsed property.
You’re getting that exception because the form tried to set the DateTimePicker control’s Value property to a value that’s lower than its MinDate.
But more importantly, before it threw the exception, the Excuse class wrote out a file.
This is a really useful technique that you should keep in mind: generating files with known bad data so you can use them later to test your program.
Add exception handling to the Open button’s Click event handler.
Just make a simple try/catch block that pops up a message box.
Here’s what it should pop up if  you try to open up a file that’s not a real excuse file:
You’ll get a different exception if  you try to open a file that’s not a valid excuse file.
Add an exception handling block nested inside the one you added in step 2 so it doesn’t fail when you try to load an invalid excuse file (which can happen in several situations)
Declare a Boolean variable called clearForm above the try/catch block.
You’ll set this to true if  there’s an exception, and check it later to see if  the form should be cleared.
Add another try/catch block inside the one you just added to the Open button.
Add a finally block to the outer try/catch to reset the form to its original empty state.
Reset LastUsed.Value to DateTime.Now (which returns the current date) if the clearForm variable is set to true.
Here’s the try/catch block to create a pop-up error, in case problems occur when the form calls the Excuse constructor to load an excuse.
It handles exceptions that happen if the file that gets loaded has data that is out of range.
That’s not the same as problems arising from the Excuse constructor.
Here’s the message box from the outer try/ catch block.
We’re not using the exception object, so the catch statement doens’t need a variable name after the exception type.
If the next statement is a method, “Step _____” tells the debugger to execute the first statement in that method.
If the next statement is a method, "Step _____" tells the debugger to execute the first statement in that method [INTO]
Never misses a day of work unless he’s got a real problem.
Your exception handling skills did more than just prevent problems.
They ensured that Brian’s boss has no idea anything went wrong in the first place! Good exception.
The program never crashes, and if there are problems, they are handled gracefully, without confusing error messages.
Ever wish your objects could think for themselves? Suppose you’re writing a baseball simulator.
You’re going to model a game, sell the software to the Yankees (they’ve got deep pockets, right?), and make a million bucks.
You create your Ball, Pitcher, Umpire, and Fan objects, and a whole lot more.
You even write code so that the Pitcher object can catch a ball.
You add an OnBallInPlay() method to Ball, and now you want your Pitcher object to respond with its  event handler method.
Once the methods are written, you just need to tie the separate methods together:
You really want your Ball object to only worry about getting hit, and your Pitcher object to only worry about catching balls that come its way.
In other words, you really don’t want the Ball telling the Pitcher, “I’m coming to you.”
The Ball doesn’t know which fielder will pick it up…maybe the Pitcher, or maybe the Catcher, or maybe ThirdBaseman who decided to ScootIn()
You want an object to worry about itself, not other objects.
That’s a commonly used way of naming methods—we’ll talk more about it later.
What you need to do when the ball is hit is to use an event.
An event is simply something that’s happened in your program.
Then, other objects can respond to that event—like our Pitcher object.
Even better, more than one object can listen for events.
So the Pitcher could listen for a ball-being-hit event, as well as a Catcher, ThirdBaseman, an Umpire, even a Fan.
So what we want is a Ball object that can raise an event.
Then, we want to have other objects to subscribe to that particular type of  event…that just means listen for it, and get notified when that event occurs.
If we subscribe to the BallInPlay event, we’ll always get notified when the ball’s in play.
The pitcher and other players want to try and field the ball.
The Fan object subscribes in case a ball goes into the seats.
The umpire checks every ball to see if it’s fair or foul, and monitors what happens.
You’ll see an icon like this next to events in IntelliSense and in the properties window.
When a Ball gets hit, it raises a BallInPlay event.
Any object can subscribe to this event…and the Ball object doesn’t need to know what objects are subscribed.
Once your object “hears” about an event, you can set up some code to run.
An event handler gets information about the event, and runs every time that event occurs.
So you write code to raise an event, and then you write code to handle those events, and fire up your application.
Then, whenever an event is raised, your handler kicks into action…without you doing anything.
Want to DO SOMETHING with an event? You need an event handler.
It’s time for the Ball object to raise a new event.
The ball raises an event A new event gets raised (we’ll talk about exactly how that works in just a minute)
That event also has some arguments, like the velocity of  the ball, as well as its trajectory.
Those arguments are attached to the event as an instance of  an EventArgs object, and then the event is sent off, available to anyone listening for it.
BallInPlay is an event that gets fired off by Ball.
Sometimes we’ll talk about raising an event, or firing it, or invoking it—they’re all the same thing.
First, other objects subscribe to the event Before the Ball can raise its BallInPlay event, other objects need to subscribe to it.
That’s their way of  saying, any time a BallInPlay event occurs, we want to know about it.
BallInPlay eve nt is raised.Every object adds its own event handler to listen for the event—just like you add button1_Click() to your programs to listen for Click events.
Subscribers get notification Since the Pitcher, Umpire, and Fan object subscribed to the Ball object’s BallInPlay event, they all get notified—all of  their event handler methods get called one after another.
Once an event is raised, all the objects subscribed to that event get notification, and can do something:
As soon as the ball raises its event, it creates a BallEventArgs object with the ball’s trajectory and distance so it can pass it to the subscribers’ event handlers.
Each object handles the event Now, Pitcher, Umpire, and Fan can all handle the BallInPlay event in their own way.
But they don’t all run at the same time—their event handlers get called one after another, with a reference to a BallEventArgs object as its parameter.
It might even subscribe to other events, like BallFielded or BallThrown, to further react to what happens.
The Fan object checks BallEventArgs to see if the ball is close enough to catch.
Events are handled on a first-come, first-served basis—the object that subscribes first gets notified first.
An event handler is just the method in the subscriber object that gets run when the event is raised.
Connect ing the dots Now that you’ve got a handle on what’s going on, let’s take a closer look at how the pieces fit together.
We need an object for the event arguments Remember, our BallInPlay event has a few arguments that it carries along.
So we need a very simple object for those arguments.
Its sole purpose is to allow your event arguments object to be passed to the event handlers that use it.
The ball will use these properties to pass information to the event handlers about where the ball’s been hit.
Next we’ll need to define the event in the class that’ll raise it The ball class will have a line with the event keyword—this is how it informs other objects about the event, so they can subscribe to it.
This line can be anywhere in the class—it’s usually near the property declarations.
But as long as it’s in the Ball class, other objects can subscribe to a ball’s event.
This event is defined in the Ball class, but we’ll want Pitcher, Umpire, etc., to be able to reference it.
You could make it private if you only wanted other instances of the same class to subscribe to it.
That’s not a reserved C# keyword—it’s defined as part of .NET.
The reason you need it is to tell the objects subscribing to the event what their event handler methods should look like.
When you use EventHandler, you’re telling other methods that their event handlers need to take two parameters: an object named sender and an EventArgs reference named e.
It means that you can upcast your EventArgs object in case you need to send it to an event that doesn’t handle it in particular.
The subscribing classes need event handler methods Every object that has to subscribe to the Ball’s BallInPlay event needs to have an event handler.
You already know how event handlers work—every time you added a method to handle a button’s Click event or a NumericUpDown’s ValueChanged event, the IDE added an event handler method to your class.
The Ball’s BallInPlay event is no different, and an event handler for it should look pretty familiar:
There’s no C# rule that says your event handlers need to be named a certain way, but there’s a pretty standard naming convention: the name of the object reference, followed by an underscore, followed by the name of the event.
The class that has this particular event handler method has a Ball reference variable called ball, so its BallInPlay event handler starts with “ball_”, followed by the name of the event being handled, “BallInPlay”
The BallInPlay event declaration listed its event type as EventHandler, which means that it needs to take two parameters—an object called sender and an EventArgs called e—and have no return value.
Each individual object subscribes to the event Once we’ve got the event handler set up, the various Pitcher, Umpire, ThirdBaseman, and Fan objects need to hook up their own event handlers.
Each one of  them will have its own specific ball_BallInPlay method that responds differently to the event.
So if  there’s a Ball object reference variable or field called ball, then the += operator will hook up the event handler:
This tells C# to hook the event handler up to the BallInPlay event of whatever object the ball reference is pointing to.
The += operator tells C# to subscribe an event handler to an event.
This part specifies which event handler method to subscribe to the event.
The event handler method’s signature (its parameters and return value) has to match the one defined by EventHandler or the program won’t compile.
If you raise an event with no handlers, it’ll throw an exception.
If no other objects have added their event handlers to an event, it’ll be null.
So always check to make sure your event handler isn’t equal to null before you raise it.
That’s also why you should copy the event to a variable before you check to see if it’s null—in extremely rare cases, the event can become null between the the null check and the time that it’s called.
The ball gets hit, and the Ball object goes into action…
A Ball object raises its event to notify subscribers that it’s in play Now that the events are all set up, the Ball can raise its event in response to something else that happens in the simulator.
Raising an event is easy—it just calls the BallInPlay event.
Use a standard name when you add a method to raise an event Take a minute and go to the code for any form, and type the keyword override any place you’d declare a method.
As soon as you press space, an IntelliSense window pops up:
There are a huge number of  events that a Form object can raise, and every one of  them has its own method that raises it.
The form’s OnDoubleClick() raises the DoubleClick event, and that’s the whole reason it’s there.
So the Ball event will follow the same convention: we’ll make sure it has a method called OnBallInPlay that takes a BallEventArgs object as a parameter.
The baseball simulator will call that method any time it needs the ball to raise its BallInPlay event—so when the simulator detects that the bat hit the ball, it’ll create a new instance of BallEventArgs with the ball’s trajectory and distance and pass it to OnBallInPlay()
Notice how each of these methods takes an EventArgs as a parameter? They all pass that parameter on to the event when they raise it.
BallInPlay is copied to a variable, ballInPlay, which is null-checked and used to raise the event.
Q: Why do I need to include the word EventHandler when I declare an event? I thought the event handler was what the other objects used to subscribe to the events.
Q: What happens if I try to use a method that doesn’t match the ones that are defined by EventHandler?
Q:Wait, “standard” event handler? There are other kinds of event handlers?
Q: So I can probably have my event handlers return something other than void, too, right?
Q: Is that why I used += when when I added my event handler? Like I’m somehow adding a new handler to existing handlers?
Q:Why does the ball use “this” when it raises the BallInPlay() event?
A SINGLE event is always raised by a SINGLE object.
But a SINGLE event can be responded to by MULTIPLE objects.
The IDE creates event handlers for you automatically Most programmers follow the same convention for naming their event handlers.
If there’s a Ball object that has a BallInPlay event and the name of  the reference holding the object is called ball, then the event handler would typically be named ball_BallInPlay()
That’s not a hard-and-fast rule, but if  you write your code like that, it’ll be a lot easier for other programmers to read.
Luckily, the IDE makes it really easy to name your event handlers properly.
It has a feature that automatically adds event handler methods for you when you’re working with a class that raises an event.
It shouldn’t be too surprising that the IDE can do this for you—after all, this is exactly what it does when you double-click on a button in your form.
Start a new Windows application and add the Ball and BallEventArgs Here’s the Ball class:
Start adding the Pitcher’s constructor Add a new Pitcher class to your project.
Then give it a constructor that takes a Ball reference called ball as a parameter.
There will be one line of  code in the constructor to add its event handler to ball.BallInPlay.
The IDE will add your event handler, too You’re not done—you still need to add a method to chain onto the event.
Luckily, the IDE takes care of  that for you, too.
Hit the tab key again to make the IDE add this event handler method to your Pitcher class.
Type += and the IDE will finish the statement for you As soon as you type += in the statement, the IDE displays a very useful little box:
As soon as you press the tab key, the IDE will finish the statement for you.
Finish the pitcher’s event handler Now that you’ve got the event handler’s skeleton added to your class, fill in the rest of  its code.
The pitcher should catch any low balls; otherwise, he covers first base.
Since BallEventArgs is a subclass of EventArgs, we’ll downcast it using the as keyword so we can use its properties.
Both should print out that the catcher has either caught the ball or run to first base.
Fan should also subscribe to the BallInPlay event in its constructor.
Write out what’s going on with the fan to the console.
You’ll need to implement these two methods to write a line of output to the console.
Look at the output window on the facing page to see exactly what it should print.
The application should have two NumericUpDown controls: one for the ball’s distance, and one for its trajectory.
Add a button labeled “Play ball!” When “Play ball!” is clicked, a ball is hit with the values in the two NumericUpDowns.
See if  you can make your simulator generate this output with three successive balls put into play.
Write down the values you used to get the result below:
Don’t forget to cast the Value properties to ints before you use them.
Read-only automatic properties work really well in event arguments because the event handlers only read the data passed to them.
The OnBallInPlay() method just raises the BallInPlay event—but it has to check to make sure it’s not null, otherwise it’ll throw an exception.
The Fan object’s constructor chains its event handler onto the BallInPlay event.
The fan’s BallInPlay event handler looks for any ball that’s high and long.
Here are the values we used to get the output.
The form needs one ball, one fan, and one pitcher.
It hooks the fan and pitcher up to the ball in its constructor.
When the button’s clicked, the form tells the pitcher to pitch the ball to the batter, which tells the ball to fire off its BallInPlay event, which calls the event handlers in the Pitcher and Fan objects.
Use implicit conversion by leav ing out the new keyword and the event type If  you use the IDE to automatically create the event handler method like you did a few pages ago, it will always contain the new keyword followed by the event handler type.
But if  you leave out the new keyword and the event handler type, C# will do an implicit conversion and figure out the type for you:
Try replacing the code in the Pitcher and Fan constructors with the line above.
When you run the program, it will still work just fine.
Take a look at the event declaration in your Ball class:
Now take a look at the Click event declaration from a button, form, and most of  the other controls you’ve been using:
Notice anything? They have different names, but they’re declared exactly the same way.
And while that works just fine, someone looking at your class declaration doesn’t necessarily know that the BallEventHandler will always pass it a BallEventArgs when the event is fired.
Luckily, .NET gives us a great tool to communicate that information very easily: a generic EventHandler.
Change your ball’s BallInPlay event handler so it looks like this:
You should see two errors in the Error List window:
Generic EventHandlers le t you def ine your own event types.
Now that you changed the event declaration, your Pitcher and Fan classes need to be updated so that they hook up to the events by passing the generic argument to EventHandler:
The generic argument to EventHandler has to be a subclass of EventArgs.
The forms you’ve been building all use events Every time you’ve created a button, double-clicked on it in the designer, and written code for a method like button1_Click(), you’ve been working with events.
Visual Studio did more than just write a little method declaration for you, though.
It also hooked the event handler up to the Form object’s Click event.
Now run the program and make sure your code works!
Remember those icons at the top of  the window? Click on the Events button (it’s the one with the lightning bolt icon) to bring up the events page in the Properties window:
Scroll down to Click and doubleclick on the word “Click”
When you do, the IDE will add a new click event handler to your form that gets fired every time you click on it.
You can see all of the events for a control: just click on it and then click on this events button in the Properties window.
You can create an event that will fire every time someone clicks on the form by selecting Form1_Click next to Click in the events window.
The IDE will automatically add an event handler method to your form called Form1_Click.
If you drag a button onto your form and add a method called button1_Click() that has the right parameters but isn’t registered to listen to your button, the method won’t ever get called.
Here’s a really useful thing that you can do with events: you can chain them so that one event or delegate calls many methods, one after another.
Let’s add a few buttons to your application to see how it works.
One event, mult iple handlers Q: When I added a new event handler to the Pitcher object, why did the IDE make it throw an exception?
Before you go on, take a minute and think about what those two buttons do.
Each button hooks up a new event handler to the form’s Click event.
Now you added two buttons that use the exact same syntax to chain additional event handlers onto the same Click event.
So before you go on, try to guess what will happen if  you run the program, click the first button, then click the second button, and then click on the form.
Can you figure it out before you run the program?
You can keep clicking the buttons, and they’ll keep chaining the same methods onto the event.
The event doesn’t care how many methods are chained on, or even if  the same method is in the chain more than once.
It’ll just call them all every time the event fires, one after another, in the order they were added.
SaySomethingElse() The same method can be chained on to an event more than once.
When you click these buttons, they chain different event handlers onto the form’s Click event.
That means you won’t see anything when you click the buttons! You’ll need to click on the form, because the buttons change the form’s behavior by modifying its Click event.
Click the form—you’ll see a message box pop up that says, “You just clicked on the form”
Now click button1 and then click on the form again.
You’ll see two message boxes pop up: “You just clicked on the form” and then “Something”
Click button2 twice and then click on the form again.
You’ll see four message boxes: “You just clicked on the form”, “Something”, “Something else”, and “Something else”
Just what you’d expect–the form’s Click event handler pops up a message box.
But every time you click a button, it causes yet another message box to pop up the next time you click on the form!
Connecting event senders with event receivers One of  the trickiest things about events is that the sender of  the event has to know what kind of  event to send—including the arguments to pass to the event.
And the receiver of  the event has to know about the return type and the arguments its handler methods must use.
But—and here’s the tricky part—you can’t tie the sender and receiver together.
You want the sender to send the event and not worry about who receives it.
And the receiver cares about the event, not the object that raised the event.
So both sender and receiver focus on the event, not each other.
Ball needs to know about BallInPlay, because it needs to raise that event.
Pitcher needs to know about BallInPlay, so it can respond to that event, and build an appropriate event handler.
It doesn’t care what type of object works with it: Fan, Pitcher, Umpire, etc.
It creates a reference variable that can point to any Ball object.
Instead, it can point to any ball object—or it can be null, and not point to anything at all.
An event needs a similar kind of  reference—except instead of  pointing to an object, it needs one that points to a method.
Every event needs to keep track of  a list of  methods that are subscribed to it.
You’ve already seen that they can be in other classes, and they can even be private.
So how does it keep track of  all of  the event handler methods that it needs to call? It uses something called a delegate.
A delegate STANDS IN for an actual method One of  the most useful aspects of  events is that when an event fires, it has no idea whose event handler methods it’s calling.
Anyone who happens to subscribe to an event gets his event handler called.
A delegate is a special kind of  reference type that lets you refer to a method inside a class…and delegates are the basis for events.
You’ve actually already been using delegates throughout this chapter! When you created the BallInPlay event, you used EventHandler.
If  you right-click on EventHandler in the IDE and select “Go to definition”, this is what you’ll see (try it yourself):
A delegate adds a new type to your project When you add a delegate to your project, you’re adding a delegate type.
And when you use it to create a field or variable, you’re creating an instance of  that delegate type.
But instead of  putting a class inside it, add a single line:
Next, add a method called HiThere() to your Program class:
Take a minute and step through the program in the debugger to see exactly what’s going on.
So this delegate can be used to reference any method that takes an object and an EventArgs and has no return value.
When you create a delegate, all you need to do is specify the signature of methods that it can point to.
This specifies the return value of the delegate’s signature—which means an EventHandler can only point to methods with void return values.
This is just like how you can use a class or interface as a type to define variables.
It’s a lot like a reference variable, except instead of putting a label on an object on the heap you’re putting a label on a method.
Delegates in act ion There’s nothing mysterious about delegates—in fact, they don’t take much code at all to use.
Let’s use them to help a restaurant owner sort out his top chef ’s secret ingredients.
It will have exactly one line of  code in it:
This delegate can be used to create a variable that can point to any method that takes one int parameter and returns a string.
Add a class for the first chef, Suzanne Suzanne.cs will hold a class that keeps track of  the first chef ’s secret ingredient.
But it also has a read-only property—and check out that property’s type.
Then add a class for the second chef, Amy Amy’s method works a lot like Suzanne’s:
Amy’s secret ingredient method also takes an int called amount and returns a string, but it returns a different string from Suzanne’s.
Suzanne’s secret ingredient method takes an int called amount and returns a string that describes her secret ingredient.
Create a new Windows project and add a delegate Build this form.
Use the debugger to explore how delegates work You’ve got a great tool—the IDE’s debugger—that can really help you get a handle on how delegates work.
First click the “Get the ingredient” button—it should write a line to the console that says, “I don’t have a secret ingredient!”
Now use the debugger to see exactly what’s going on.
Place a breakpoint on the first line of  each of the three methods in the form.
Then restart the program (which resets the ingredientMethod so that it’s equal to null), and start over with the above five steps.
Use the Step Into (F11) feature of  the debugger to step through every line of  code.
It steps right into the Suzanne and Amy classes, depending on which method the ingredientMethod field is pointing to.
Your job is to take snippets from the pool and place them into the blank lines in the code.
You can use the same snippet more than once, and you won’t need to use all the snippets.
Your goal is to complete the code for a form that writes this output to the console when its button1 button is clicked.
Note: Each thing from the pool can be used more than once.
An object can subscribe to an event… Suppose we add a new class to our simulator, a Bat class, and that class adds a HitTheBall event into the mix.
Here’s how it works: if  the simulator detects that the player hit the ball, it calls the Bat object’s OnHitTheBall() method, which raises a HitTheBall event.
So now we can add a bat_HitTheBall method to the Ball class that subscribes to the Bat object’s HitTheBall event.
Then when the ball gets hit, its own event handler calls its OnBallInPlay() method to raise its own event, BallInPlay, and the chain reaction begins.
Fielders field, fans scream, umpires yell…we’ve got a ball game.
Now its event handler can take information about how hard the swing was, figure out the distance and trajectory, and raise a BallInPlay event.
The simulator detects that the bat collided with the ball, so it calls the bat object’s OnHitTheBall() method.
But if  the Bat object uses an event to announce to the ball that it’s been hit, then any Ball object can subscribe to it.
And that means we’ve set ourselves up for a nasty little bug—what happens if  a programmer accidentally adds three more Ball objects? Then the batter will swing, hit, and four different balls will fly out into the field!
Uh-oh! These balls were supposed to be held in reserve in case the first one was hit out of the park.
Use a callback to control who’s listening Our system of  events only works if  we’ve got one Ball and one Bat.
If  you’ve got several Ball objects, and they all subscribe to the public event HitTheBall, then they’ll all go flying when the event is raised.
But that doesn’t make any sense…it’s really only one Ball object that got hit.
We need to let the one ball that’s being pitched hook itself  up to the bat, but we need to do it in a way that doesn’t allow any other balls to hook themselves up.
Instead of  exposing an event that anyone can subscribe to, an object uses a method (often a constructor) that takes a delegate as an argument and holds onto that delegate in a private field.
We’ll use a callback to make sure that the Bat notifies exactly one Ball:
The Bat will keep its delegate field private The easiest way to keep the wrong Ball objects from chaining themselves onto the Bat’s delegate is for the bat to make it private.
That way, it has control over which Ball object’s method gets called.
The Bat’s constructor takes a delegate that points to a method in the ball When the ball is in play, it creates the new instance of  the bat, and it passes the Bat object a pointer to its OnBallInPlay() method.
This is called a callback method because the Bat is using it to call back to the object that instantiated it.
When the bat hits the ball, it calls the callback method But since the bat kept its delegate private, it can be 100% sure that no other ball has been hit.
The bat saves that delegate in its private hitTheBallCallback field.
The other balls can’t chain themselves onto the delegate because it’s a private field in the Bat object.
Now the Bat object can call its hitBallCallback delegate, which calls the Ball object’s OnBallInPlay() method.
The constructor chains two event handlers onto the load events.
They get fired off as soon as the form is loaded.
The two Load event handlers hook up three separate event handlers to the button’s Click event handler.When the button is clicked, it calls the three event handlers that are chained to it.
He’s hot on the trail of  one of  the most prized possessions in the rare and unusual aquatic-themed jewelry markets: a jade-encrusted translucent gold crab.
They all got a reference to the same crab in their constructor, but Henry wants to claim the prize first.
In a stolen set of  class diagrams, Henry discovers that the GoldenCrab class raises a RunForCover event every time anyone gets close to it.
But none of  the other treasure hunters know about the event, so Henry figures he can cash in.
Everything goes according to plan, until Henry gets the new location and rushes to grab the crab.
He’s stunned to see three other TreasureHunters already there, fighting over the crab.
How did the other treasure hunters beat Henry to the crab?
A callback is just a way to use de legates A callback is a different way of  using a delegate.
It just describes a pattern—a way that you use delegates with your classes so that one object can tell another object, “Notify me when this happens—if  that’s OK with you!”
But in some cases, it makes more sense to set up the callback method using a public method or property’s set accessor.
Define another delegate in your baseball project Since the Bat will have a private delegate field that points to the Ball object’s OnBallInPlay() method, we’ll need a delegate that matches its signature:
Add the Bat class to the project The Bat class is simple.
It’s got a HitTheBall() method that the simulator will call every time a ball is hit.
That HitTheBall() method uses the hitBallCallback() delegate to call the ball’s OnBallInPlay() method (or whatever method is passed into its constructor)
We’ll need to hook the bat up to a ball So how does the Bat’s constructor get a reference to a particular ball’s OnBallInPlay() method? Easy—just call that Ball object’s GetNewBat() method, which you’ll have to add to Ball:
The Bat object’s callback will point to a Ball object’s OnBallInPlay() method, so the callback’s delegate needs to match the signature of OnBallInPlay()—so it needs to take a BallEventArgs parameter and have a void return value.
Make sure you check every delegate to make sure it’s not null, otherwise it could throw a null reference exception.
The Ball’s GetNewBat() method creates a new Bat object, and it uses the BatCallBack delegate to pass a reference to its own OnBallInPlay() method to the new bat.
That’s the callback method the bat will use when it hits the ball.
Delegates don’t always need to live in their own files.
Try putting this one in the same file as Bat.
We used = instead of  += because in this case, we only want one bat to listen to any one ball, so this delegate only gets set once.
The point of  the callback is that the object doing the calling is in control of  who’s listening.
In a callback, other objects simply turn over their delegates and politely ask to be notified.
Now we can encapsulate the Ball class a little better It’s unusual for one of  the On...
You can check this for yourself—go to the form and try to call the playBall button’s OnClick() event.
You won’t be able to, because it’s protected (so a subclass can override it)
So let’s follow that pattern with our ball, too, by making its OnBallInPlay() method protected:
All that’s left to do is hook up the form The form can’t call the Ball object’s OnBallInPlay() method anymore—which is exactly what we wanted.
Now the form needs to ask the Ball for a new bat in order to hit the ball.
And when it does, the Ball object will make sure that its OnBallInPlay() method is hooked up to the bat’s callback.
Now run the program—it should work exactly like it did before.
But it’s now protected from any problems that would be caused by more than one ball listening for the same event.
This is a really standard pattern that you’ll see over and over again when you work with .NET classes.
When a .NET class has an event that gets fired, you’ll almost always find a protected method that starts with “On”
If the form (or the simulator) wants to hit a Ball object, it needs to get a new Bat object from that ball.
The ball will make sure that the callback is hooked up to the bat.
Now when the form calls the bat’s HitTheBall() method, it calls the ball’s OnBallInPlay() method, which fires its BallInPlay event.
But don’t take our word for it—pop it open in the debugger!
Q: But it looks just like an event, except with the event keyword, right?
It’s a great way to learn about different patterns that you can apply to your own programs.
One object publishes information, and other objects subscribe to it.
The Case of  the Golden Crustacean How did the other treasure hunters beat Henry to the crab? The crux of  the mystery lies in how the treasure hunter seeks his quarry.
But first we’ll need to see exactly what Henry found in the stolen diagrams.
In a stolen set of  class diagrams, Henry discovers that the GoldenCrab class raises a RunForCover event every time anyone gets close to it.
Even better, the event includes NewLocationArgs, which detail where the crab is moving to.
But none of  the other treasure hunters know about the event, so Henry figures he can cash in.
So how did Henry take advantage of  his newfound insider information?
When he added the event handler to the TreasureHunter constructor, he was inadvertently doing the same thing for all of  the treasure hunters! And that meant that every treasure hunter’s event handler got chained onto the same RunForCover event.
So when the Golden Crustacean ran for cover, everyone was notified about the event.
And all of  that that would have been fine if  Henry were the first one to get the message.
But Henry had no way of  knowing when the other treasure hunters would have been called—if  they subscribed before he did, they’d get the event first.
Any time someone comes close to the golden crab, its SomeonesNearby() method fires off a RunForCover event, and it finds a place to hide.
Henry thought he was being clever by altering his class’s constructor to add an event handler that calls his MoveHere() method every time the crab raises its RunForCover event.
But he forgot that the other treasure hunters inherit from the same class, and his clever code adds their event handlers to the chain, too!
When you type in the code, add five button event handlers.
Fill in the blanks to make this game of Whack-a-mole work.
You need to supply the code that does the callbacks.
Once you’ve got it filled in, go ahead and type it into the IDE.
Or you can try to get it working in the IDE, and then fill in the blanks afterward.
Remember the Timer control? Drag it out of the toolbox, then double-click on it.
When you double-click on the timer in the form (after you drag it out of the toolbox), the IDE will create this event handler for it.
The form passes a delegate pointing to a callback method into the mole’s constructor.
Just add these event handlers the usual way by double-clicking on the buttons in the form designer.
This switch makes sure that the right button changes its color and text.
This method’s called to pop up or hide the mole when the timer’s elapsed.
Fill in the delegate and field to hold the delegate—they’re both at the top of the Mole class.
When the form creates a new Mole object, it passes it a reference to its callback method.
Take a look in the form to see how the constructor is called, and then fill in this blank.
After the mole shows itself, it needs to call the method on the form that displays the mole by turning the button red and showing the text “HIT ME!”
The HideAgain() and Smacked() methods also use the callback delegate to call the method on the form.
The way the game works is that it uses the timer to wait a random period of time between half a second and 1.5 seconds.
Once that time has elapsed, it tells the mole to show itself.
The form gives the Mole object a callback that it uses to tell the form to show or hide the mole in one of the five holes.
The game’s over after the mole shows itself 10 times.
Your score is the number of times you hit it.
Here’s where we make sure the callback is not null—if it is, the Mole object throws an ArgumentException.
Fill in the blanks to make this game of Whack-a-mole work.
You need to supply the code that does the callbacks.
Once you’ve got it filled in, go ahead and type it into the IDE.
This is where the form passes a reference to its MoleCallBack() method into the Mole object.
Here’s where the mole defines its delegate and uses it to set up a private field to hold a reference to the method on the form that changes the colors of the buttons.
When the form creates a new instance of the Mole object, it passes a reference to its MoleCallBack() method to the constructor as a parameter.
This line in the constructor copies that reference to its popUpCallback field.
Its methods can use that field to call the MoleCallBack() method in the form.
I just know I read about how upcasting and downcasting make event handling easier somewhere....
Until you’ve actually written working code, it’s hard to be sure if you really get some of.
In this chapter, we’re going to use what we’ve learned to.
We’ll also get a preview of some of the new ideas coming up soon.
You’ve come a long way, baby We’ve come a long way since we first used the IDE to help us rescue the Objectville Paper Company.
Here’s just a few of  the things you’ve done over the last several hundred pages:
You’ve used inheritance, as well as interfaces and subclasses, to build object trees.
You’ve built forms, used the .NET Framework, and even talked with databases.
Even complex types like arrays are no big deal to work with.
We’ve also become beekeepers Back in Chapter 6, we built some bee classes.
So let’s start from scratch, and build an animated beehive simulator over the next few chapters.
We’ll end up with a user interface that shows us the hive and the field the bees are flying around, and even a stats window letting users know what their bees are doing.
The stats window lets us monitor the simulation in detail.
We can even watch the bees work a field of flowers.
Even though the simulator will be controlling a lot of  different bees, the overall object model is pretty simple.
This is the object for the main window that shows the bee stats and messages.
The World object keeps track of everything in the simulator: the state of the hive, every bee, and every flower.
Building the beehive simulator Of  course, we’ve never built anything this complex before, so it’s going to take us a couple of  chapters to put all the pieces together.
Along the way, you’ll add timers, LINQ, and a lot of  graphical skill to your toolkit.
Here’s what you’re going to do in this chapter (more to come in the next):
Build a Flower class that ages, produces nectar, and eventually wilts and dies.
Build a Bee class that has several different states (gathering nectar from a flower, returning to the hive), and knows what to do based on its state.
Build a Hive class that has an entrance, exit, nursery for new bees, and honey factory for turning collected nectar into honey.
Build a World class that manages the hive, flowers, and bees at any given moment.
Build a main form that collects statistics from the other classes and keeps the world going.
Write the skeleton code for Flower Below is the class diagram for Flower.
For now, leave the methods blank; we’ll come back to those in a minute.
This is used only in the class, so it just needs to be a private field.
Add several constants to the class We need lots of  constants for flowers.
You should be able to figure out the types for each constant based on their values.
FYI, you don’t usually show constants in a class diagram.
Since this simulator will be animated, we’ll be drawing it frame by frame.
Build the constructor The constructor for Flower should take in a Point, indicating the flower’s location, and an instance of  the Random class.
You should be able to use those arguments to set the location of  the flower, and then set its age to 0, set the flower to alive, and set its nectar to the initial amount of  nectar for a flower.
Since no nectar has been harvested yet, set that variable correctly, as well.
This will only work if you’ve got your variables and constants named right, as well as the argument to the Flower constructor.
Write code for the HarvestNectar() method Every time this method is called, it should check to see if  the nectar gathered every cycle is larger than the amount of  nectar left.
Otherwise, you should remove the amount collected in a cycle from the nectar the flower has left, and return how much nectar was collected.
Oh, and don’t forget to add that amount to the NectarHarvested variable, which keeps up with the total nectar collected from this particular flower.
Write code for the Go() method This is the method that makes the flower go.
Assume every time this method is called, one cycle passes, so update the flower’s age appropriately.
You’ll also need to see if  the age is greater than the flower’s lifespan.
Assuming the flower stays alive, you’ll need to add the amount of  nectar each flower gets in a cycle.
Be sure and check against the maximum nectar your flower can store, and don’t overrun that.
Answers on the next page…try and finish your code and compile it before peeking.
The final product will be animated, with little pictures of bees flying around.
The Go() method will be called once every frame, and there will be several frames run per second.
You’ll need to add using System.Drawing; to the top of any class file that uses a Point.
Make sure the flower stops adding nectar after it’s dead.
Location, Age, Alive, and Nectar are all readonly automatic properties.
Flowers have random lifespans, so the field of flowers doesn’t all change at once.
A bee calls HarvestNectar() to get nectar out of a flower.
A bee can only harvest a little bit of nectar at a time, so he’ll have to sit near the flower for several turns until the nectar’s all gone.
As part of the simulator’s animation, the Go() method will be called each frame.
This makes the flower age just a tiny little bit per frame.
As the simulator runs, those tiny bits will add up over time.
Point lives in the System.Drawing namespace, so make sure you added using System.Drawing; to the top of the class file.
Q: It doesn’t look like NectarHarvested is used anywhere in the class, except where we increment it.
Life and death of a f lower Our flower goes through a basic turn, living, adding nectar, having nectar harvested, and eventually dying:
Now we need a Bee class With flowers ready to be harvested, we need a Bee class.
The Bee knows its age, whether or not it’s in the hive, and how much nectar it can collect.
We’ve also added a method to move the bee toward a specific destination point.
Like the Flower class, there are several bee-specific constants we need to define.
We’ll have to add a lot more code to Go() before we’re done, but this will get us started.
Each bee will be assigned its own unique ID number.
This method starts by figuring out if we’re already within our MoveRate of being at the destination.
If we’re not close enough, then we move toward the destination by our move rate.
We return false, since we’re not yet at the destination point.
The enum item  What the item means Idle   The bee isn’t doing anything FlyingToFlower  The bee’s flying to a flower GatheringNectar The bee’s gathering nectar from a flower ReturningToHive  The bee’s heading back to the hive MakingHoney  The bee’s making honey Retired   The bee’s hung up his wings.
Here we used Math.Abs() to calculate the absolute value of the difference between the destination and the current location.
If the bee reached its destination, the method returns true; otherwise, it returns false.
We also need a variable to track the state of each bee.
Did you remember to add using System.Drawing; to the top of the class file (because it uses Point)?
It’s OK if you didn’t come up with this code, but go ahead and add it in now.
If the age reaches the bee’s lifespan, the bee retires.
Returning to the hive is different based on whether we’re already in the hive or not.
The bee adds half a unit of nectar to the honey factory at a time.
If there’s not enough nectar to add, the factory can’t use it so the bee just discards it.
We need to write code so the bees can collect nectar, but before that happens, where do the bees get created in the first place? And where do they take all that nectar? That’s where a Hive class comes in.
The hive isn’t just a place for bees to come back to, though.
It has several locations within it, all with different points in the world.
There’s the entrance and the exit, as well as a nursery for birthing more bees and a honey factory for turning nectar into honey.
Bees come in the entrance, and leave from the exit.
New bees are created and start out in the hive nursery.
Each location is distinct, and bees can travel from one to the other just like they can go from the hive to a flower.
The hive runs on honey The other big part that the hive plays is keeping up with how much honey it has stored up.
It takes honey for the hive to keep running, and if  new bees need to be created, that takes honey, too.
On top of  that, the honey factory has to take nectar that bees collect and turn that into honey.
For every unit of  nectar that comes in, .25 units of  honey can be created.
Think about this for a second…as time passes, the hive uses honey to run, and to create more bees.
Meanwhile, other bees are bringing in nectar, which gets turned into honey, which keeps things going longer.
It’s up to you (with some help) to model all of this in the simulator code.
Write the skeleton code for Hive Like we did with the Flower class, you should start with a basic skeleton for Hive.
Make Honey a read-only automatic property, locations should be private, and beeCount is only used internally, so can be a private field.
Write the code to work with Locations First, write the GetLocation() method.
It should take in a string, look up that string in the locations dictionary, and return the associated point.
This method should set up the following locations in the hive:
Build the Hive constructor When a hive is constructed, it should set its honey to the initial amount of  honey all hives have.
It should set up the locations in the hive, and also create a new instance of  Random.
Then, AddBee() should be called—passing in the Random instance you just created—once for each bee that starts out in the hive.
Each of these maps to a location within the 2D space that our hive takes up.
Later on, we’ll have to make sure the simulator makes the hive cover all these points.
That’s OK, as long as you’re consistent in the rest of your code.
We made MaximumHoney a double, since it can range from InitialHoney (3.2) to this value.
Since InitialHoney will need to be a double, it’s best to make this a double, too.Remember dictionaries? Ours stores a location, keyed with a string value.
We don’t have code for these yet, but you should have built empty methods as placeholders.
This method protects other classes from working with our locations dictionary and changing something they shouldn’t.
That’s a great way to keep track of code you still have to build.
Isn’t this sort of a weird way to build code? Our bees don’t know about.
Real code is built bit by bit It would be nice if  you could write all the code for a single class at one time, compile it, test it, and put it away, and then start on your next class.
More often than not, you’ll write code just the way we are in this chapter: piece by piece.
We were able to build pretty much the entire Flower class, but when it came to Bee, we’ve still got some work to do (mostly telling it what to do for each state)
And now, with Hive, we’ve got lots of  empty methods to fill in.
Plus, we haven’t hooked any Bees up to the Hive.
And there’s still that nagging problem about how to call the Go() method in all these objects thousands of  times.…
First you design, then you build We started out the project knowing exactly what we wanted to build: a beehive simulator.
And we know a lot about how the bees, flowers, hive, and world all work together.
That’s why we started out with the architecture, which told us how the classes would work with each other.
Then we could move on to each class, designing them individually.
Projects always go a lot more smoothly if  you have a good idea of  what you’re building before you start building it.
But it makes all the difference in the final product.
Fil ling out the Hive class Let’s get back to the Hive class, and fill in a few of those missing methods:
Once we have a system, we need to add this bee to the system.
If there’s room, we add the honey to the hive.
This method takes an amount of honey, and tries to consume it from the hive’s stores.
If there’s not enough honey in the hive to meet the demand, we return false.
If there’s enough, remove it from the hive’s stores and return true.
This creates a point within 50 units in both the X and Y direction from the nursery location.
We’ll finish AddBee() and fill in the Go() method soon…
The hive’s Go() method We’ve already written a Go() method for Flower, and a Go() method for Bee (even though we’ve got some additional code to add in)
Lots of  times in a busy hive, the queen doesn’t have time to create more bees.
We don’t have a QueenBee class, but let’s assume that when there’s enough honey to create bees, a new bee actually gets created 10% of  the time.
The only constraint (at least for now) is the hive must have enough honey to create more bees.
The same instance of Random that got passed to Go() gets sent to the AddBee() method.
One reason to leave it out is so that you can save the Random seed—that way you can rerun a specific simulation…if you feel like doing that later!
Q: So the hive can create an infinite number of bees?
Q: Couldn’t we assign that instance of Random to a property of the class, instead of passing it on to AddBee()?
Q: I still don’t understand how all of these Go() methods are getting called.
We’re ready for the World With the Hive, Bee, and Flower classes in place, we can finally build the World class.
World handles coordination between all the individual pieces of  our simulator: keeping up with all the bees, telling the hive if  there is room for more bees, locating flowers, etc.:
We don’t have all the code for these classes written, but we’ve got the basic parts in place.
Our form, when we develop it, uses the World object to keep up with what’s going on.
World is really just a big container and engine for all the individual parts.
The World object keeps everything Go()ing One of  the biggest tasks of  the World object is, for each turn in the simulator, to call Go() on every Flower, Bee, and Hive instance.
In other words, World makes sure that life continues in the simulator world.
We still have to deal with calling World’s Go() method, but we’ll come back to that.
Go() in World calls Go() on all the other objects in the world.
We’re building a turn-based system Our Go() methods in each object are supposed to run each turn, or cycle, of  our simulator.
The main thing is that a turn affects every object in the world.
The hive ages by one “turn,” checking to see if  it needs to add more bees.
Then each bee takes a turn, moving a very small distance toward its destination or doing one small action, and getting older.
Then each flower takes a turn, manufacturing a little nectar and getting older too.
And that’s what World does: it makes sure that every time its Go() method is called, every object in the world gets a turn to act.
Every time Go() in World is called, every object in the world has to get a turn to Go()
Each Bee and each Flower must have Go() called, or the simulator breaks down.
One of the big object-oriented principles we’ve been using in the simulator is encapsulation (flip back to Chapter 5 for a refresher)
See if you can look over the code we’ve developed so far and come up with two examples of encapsulation for each class you’ve built.
Each “turn” will be drawn as a single frame of animation, so the world only needs to change a tiny little bit each turn.
Here’s the code for World The World class is actually one of  the simpler classes in our simulator.
But if  you look closely, you’ll notice that it’s missing a few things (which you’ll add in just a minute)
These define the bounds of the field, which is where flowers can live.
Every world has one hive, a list of bees, and a list of flowers.
This is easy…we just tell the Hive to Go(), passing in a Random instance.
We run through all the current bees and tell them Go()
We run through each flower and tell it to Go()
We need to keep up with how much nectar’s been collected this turn, too.
So we get that by summing up the nectar collected from each flower.Just like bees, we remove any flowers that die during this turn.
Take a look at the public Hive, Bees, and Flowers fields.
Another class could accidentally reset any of those to null, which would cause serious problems! Can you think of a way to use properties or methods to encapsulate them better?
Once they’ve harvested enough nectar from the flowers, they’ve pollinated enough for the world to add a new flower.
If there’s enough nectar in the field, the world adds a new flower.
One of the big object-oriented principles we’ve been using in the simulator is encapsulation (flip back to Chapter 5 for a refresher)
See if you can look over the code we’ve developed so far and come up with two examples of encapsulation for each class you’ve built.
Q: Why don’t you use foreach loops to remove dead flowers and retired bees?
Q: OK, then why does each of those for loops start at the end of the list and count down to 0?
STOP! At this point, you should be able to compile all of your code.
Q: Why did you throw an exception in the Hive class’s GetLocation() method?
Q: What’s the point of storing all the locations in a Point if we’re not drawing anything?
Q: Then why use Point to store the location, and not something else? Aren’t Points specifically for drawing?
It’s almost always easier to repurpose or extend an existing class that does MOSTLY what you want it to do, rather than creating an all‑new class from scratch.
You want to assign the world FIRST because the rest of the constructor needs to use it.
New bees need a reference to the world, and to the hive, now.
We can use the World object to see how many total bees there are, and compare that to the maximum bees for this hive.
We add the new bee to the world’s overall bee list.
This demonstrates one of the reasons we need a World reference in the Hive class.
If you’re having trouble getting this running, you can download the code for this exercise (and all the others, too) from: http://www.headfirstlabs.com/books/hfcsharp/
Giv ing the bees behavior The one big piece of  code that’s missing in our current classes is the Bee’s Go() method.
We were able to code a few of the states earlier, but there are plenty left (Idle is incomplete, FlyingToFlower, and part of  MakingHoney)
See if there are flowers left, and then consume enough honey to keep on going.
Assuming that all works out, go to the new flower.
If we can get to the exit, then we’re out of the hive.
Make sure the flower hasn’t died as we’re heading toward it.
If we’re out of the hive, and the flower is alive, get to it and start gathering nectar.
That’s why we passed a reference to the hive to the Bee constructor.
If the hive could use the nectar to make honey…
If we’ve made it to the hive, update our location and the insideHive status.
If we’re already in the hive, head to the honey factory.
Suppose you wanted to change the simulator so it took two turns to reach a flower, and two turns to go from a flower back to the hive.
Without writing any code, which methods of which classes would you have to change to put this new behavior into place?
When the hive stores its “Exit” location, it corresponds to the point on the Hive form that shows the picture of the exit.
When the bees fly back to the hive, they fly toward the entrance of the hive on the field form.
That’s why the location dictionary stores two separate “Exit” and “Entrance” locations.
Once the bee’s retired, he just has to wait around until the Hive removes him from the list.
The main form te l ls the world to Go() OK, so you know that the world advances by one frame every time its Go() method is called.
But what calls that Go() method? Why, the main form, of  course! Time to lay it out.
Go ahead and add a new form to your project.
We’re using some new controls, but we’ll explain them all over the next several pages.
Each of these labels lives in one cell of a TableLayoutPanel control.
You lay it out just like a table in Microsoft Word.
Click on the little black arrow to add, remove, and resize columns and rows.
The ToolStrip control puts a toolstrip at the top of your form.
You can add the two buttons using the drop-down that appears on the ToolStrip when you’re in the form designer.
Add a StatusStrip to put a status bar on the bottom.
Use the dropdown that appears on the StatusStrip in the designer to add a StatusLabel to it.
It doesn’t show up at all—it’s a non-visual component that the form designer displays as an icon in the space below the form.
The ToolStrip control adds a toolbar to the top of your form, and StatusStrip adds a status bar to the bottom.
But they also appear as icons in the area below the form, so you can edit their properties.
The labels in the right-hand column will show the stats.
Most of this just involves getting data from the world and updating labels.
Print the first parameter as a number with no decimals, then a space, then print the second parameter with one decimal followed by the letters “ms” (in parentheses)
This indicates how long passes for a turn…we’ll have to send this parameter in from somewhere else, in just a few pages.
We can use World to get stat ist ics Now we want to update all these controls.
But we don’t need click handlers for each one; instead, let’s use a single method that will update the different statistics in the simulator window (we’ll explain framesRun shortly):
Be sure you match your label names on the form with your code.
Whoa! Where did that World object come from…we haven’t created that yet, have we? And what’s all that time and frame stuff?
Let’s create a World You’re right, we need to create the World object.
Go ahead and add a private World field to your form called world.
We’ve always said we needed a way to run Go() in World over and over… sounds like we need some sort of  timer.
This code uses the same String.Format() method you used in the hex dump.
We’ll talk more about this when we create that TimeSpan object.
The frame rate is the number of frames run per second.
We’re using a TimeSpan object to store how long it took to run the frame.
We divide 1000 by the number of milliseconds it took to run the frame—that gives us the total number of milliseconds it took to run the last frame.
Timers f ire events over and over again Remember how you used a loop to animate the greyhounds? Well, there’s a better way to do it.
A timer is an especially useful component that triggers an event over and over again, up to a thousand times a second.
Do this Create a new project with a timer and three buttons You don’t have to close your current project—just pop open a new instance of  Visual Studio and start up a new project.
That number is measured in milliseconds—it tells the timer to fire its tick event once a second.
Open the IDE’s Properties window and click on the Events button.
Remember, the Events button looks like a lightning bolt, and it lets you manage the events for any of  your form’s controls.
Click on the Timer icon in the designer, then double-click on its row in the Events page and the IDE will create a new event handler method for you and hook it up to the property automatically.
The Events button in the Properties window lets you work with all the events for each of your controls.
The timer’s Start() method starts the timer and sets Enabled to true.
The Stop() method stops the timer and sets Enabled to false.
Take a minute and create a new project so you can see how timers work.
Then we’ll get back to the simulator and put your new knowledge to work.
These buttons let you play with the Enabled property and the Start() and Stop() methods.
The first one switches Enabled between true and false, and the other two call the Start() and Stop() methods.
You can also just double-click on the Timer icon to add the event handler instead of using the Properties window.
Use the IDE’s “Go To Definition” feature to remind yourself  how the EventHandler delegate works:
Scroll up in the file until you find this line:
Now right-click on EventHandler and select “Go To Definition” The IDE will automatically jump to the code that defines EventHandler.
Take a look at the name of  the new tab that it opened to show you the code: “EventHandler [from metadata]”
This means that the code to define EventHandler isn’t in your code.
It’s built into the .NET Framework, and the IDE generated a “fake” line of  code to show you how it’s represented:
The t imer ’s using an event handler behind the scenes.
Here’s one of the System’s delegates: the basic event handler.
What code would you write to run the World’s Go() method 10 times a second in our beehive simulator?
The timer’s Tick event is an average, everyday event handler, just like the ones to handle button clicks.
Add a t imer to the simulator Let’s add a timer to the simulator.
Instead of  using the IDE to generate a timer1_Tick() method, though, we can wire the timer to an event handler method called RunFrame() manually:
These will be used to figure out how long the simulator’s been running at any given point.
We also start out by updating stats, with a new TimeSpan (0 time elapsed)
We want to keep up with how many frames-or turns-have passed.
Increase the frame count, and tell the world to Go()
Next, we figure out the time elapsed since the last frame was run.
Finally, update the stats again, with the new time duration.
DateTime &TimeSpan .NET uses the DateTime class to store information about a time, and its Now property returns the current date and time.
If you want to find the difference between two times, use a TimeSpan object: just subtract one DateTime object from another, and that’ll return a TimeSpan object that holds the difference between them.
TimeSpan has properties like Days, Hours, Seconds, and Milliseconds that let you measure the span in different units.
Your job is to write the event handlers for the Start Simulation and Reset buttons in the ToolStrip.
Initially, the first button should read “Start Simulation.” Pressing it causes the simulation to start, and the label to change to “Pause Simulation.” If the simulation is paused, the button should read, “Resume simulation.”
The second button should say “Reset.” When it’s pressed, the world should be recreated.
If the timer is paused, the text of the first button should change from “Resume simulation” to “Start Simulation.”
What do you think is left to be done in this phase of the simulator? Try running the program.
Write down everything you think we still need to take care of before moving on to the graphical stuff.
There’s no single answer to this question—we just want you to think about what’s left to do.
Q: We’ve been using the term “turn,” but now you’re talking about frames.
If you haven’t dragged a ToolStrip and StatusStrip out of the toolbox and onto your form, do it now.
Just double-click on a ToolStrip button in the designer to make the IDE add its event handler, just like a normal button.
Your job was to write the event handlers for the Start Simulation and Reset buttons.
Resetting the simulator is just a matter of recreating the World instance and resetting framesRun.
The only time we need to change the first button’s label is if it says, “Resume simulation.” If it says, “Pause simulation,” it doesn’t need to change.
Be sure your form’s control names match up with what you use in your code.
Compile your code, fix any typos, and run the simulator.
Looks pretty good! All these numbers should update as the world moves along.
Hmmm…our status strip seems to be the only thing not working.
We need to allow bees to tell our simulator what they’re doing.
When they do, we want our simulator to update the status message in the simulator.
This time, it’s up to you to not only write most of the code, but to figure out what code you need to write.
How can you have a method in your simulator that gets called every time a bee changes its state?
To give you a little help, we’ve written the method to add to the form.
The Bee class should call this method any time its state changes:
You’ll need to make changes to all but one of your classes to make this work.
We used a callback to hook each individual bee object up to the form’s SendMessage() method.
If the status of the Bee changed, we call back the method our BeeMessage delegate points to, and let that method know about the status change.
Hive needs a delegate too, so it can pass on the methods for each bee to call when they’re created in AddBee()
AddBee() now has to make sure that each new bee gets the method to point at.
It uses a delegate called BeeMessage that takes a bee ID and a message.
The bee uses it to send messages back to the form.
World doesn’t need to have a delegate of its own.
It just passes on the method to call to the Hive instance.
We create a new delegate from the Bee class (make sure you declared BeeMessage public), and point it at our SendMessage() method.
Same thing here…create the world with the method for bees to call back.
This is the method we gave you…be sure to add it in, too.
Let’s work with groups of bees Your bees should be buzzing around the hive and the field, and your simulation should be running! How cool is that? But since we don’t have the visual part of  the simulator working yet—that’s what we’re doing in the next chapter—all the information we have so far is the messages that the bees are sending back to the main form with their callbacks.
So let’s add more information about what the bees are doing.
You know enough to gather the information you’d need to populate that ListBox—take a minute and think through how that would work.
But it’s a little more complex than it seems at first.
What would you need to do to figure out how many bees are in each of the various Bee.State states?
You already have the form updating these stats and displaying the messages that the bees send as they do their jobs.
At any time, there are a bunch of bees flying aroun.
The new ListBox will disp lay how many bees are doi.
We’ll use it to display some extra stats about the bees in the world.
And collection types really just store data…a lot like a database does.
So each bee is like a row of  data, complete with a state, and ID, and so on.
Here’s how our bees look as a collection of  objects:
There’s a lot of  data in the Bee objects’ fields.
You can almost think of  a collection of  objects the same way you think of rows in a database.
Each object holds data in its fields, the same way each row in a database holds data in its columns.
Suppose we had a Bees table, and each row in the table had an ID column and a currentState column.
Who cares if you can think about a collection as a database if you.
What if you could query collections, databases, and even XML documents with the same basic syntax? C# has a really useful feature called LINQ (which stands for Language INtegrated Query)
The idea behind LINQ is that it gives you a way to take an array, list, stack, queue, or other collection and work with all the data inside it all at once in a single operation.
But what’s really great about LINQ is that you can use the same syntax that works with collections as you can for working with databases.
If we had our bee data in a databaseor even an XML file—LINQ could work with them in exactly the same way.
Ready Bake Code is code you should type in, and it’s OK if you don’t understand it all.
The group’s Key is the bee’s CurrentState, so that’s the order the states will be displayed on the form.
It takes all the bees in the Bees collection, and groups them by their CurrentState property.
Make sure this matches the list box control’s name on your form.
Finally, add the group status (its key) and count to the list box.Here’s another nice feature.
If so, the hive’s out of honey, so let’s stop the simulation.
We’ll learn a lot more about LINQ in upcoming chapters.
You don’t need to memorize LINQ syntax or try to drill all of  this into your head right now.
Test dri ve (Part 2) Go ahead and compile your code and run your project.
If you get any errors, double-check your syntax, especially with the new LINQ code.
These stats come from the form querying the World object.
Bees call back your simulator form to update the form every.
You’ll add these standard items, and event handlers to make them work.
It might have data that you don’t want written to the disk.
Let’s say you’re building a system that a user logs into, and you want to save an object that stores the user’s options and settings to a file.
You might mark the password field with the [NonSerialized] attribute.
That way, when you Serialize() the object, it will skip that field.
The [NonSerialized] attribute is especially useful when your object has a reference to an object that is not serializable.
So if our object has a reference to a Form object, then when you try to serialize it the serializer will follow that link and try to serialize the Form, too…which will throw that exception.
But if you mark the field that holds the reference with the [NonSerialized] attribute, then Serialize() won’t follow the reference at all.
When one object has a method that’s hooked up to a delegate or event handler in another object, that’s a reference that serialization will try to follow.
Add the Open, Save, and Print icons The ToolStrip control has a really useful feature—it can automatically insert picture buttons for standard icons: new, open, save, print, cut, copy, paste, and help.
Just right-click on the ToolStrip icon at the bottom of  the Form Designer window and select “Insert Standard Items”
Then click on the first item—that’s the “new” icon—and delete it.
Keep the next three items, because they’re the ones we need (open, save, and print)
After that comes a separator; you can either delete it or move it between the Reset button and the save buton.
Make sure you set its CanOverflow property to false (so it doesn’t add an overflow menu button to the right-hand side of  the toolbar) and its GripStyle property to Hidden (so it removes the sizing grip from the left-hand side)
One f inal challenge: Open and Save We’re almost ready to take on graphics, and add some visual eye candy to our simulator.
First, though, let’s do one more thing to this version: allow loading, saving, and printing of  bee statistics.
You’ll add the Print button now—we’ll make it print a status page for the hive in the next chapter.
When you serialize the world, .NET will find its references to Hive, Flower, and Bee objects and serialize them, too.
Here’s where the world is written out to a file.
We decided to use “.bees” as the extension for simulator save files.
After we save the file, we can restart the timer (if we stopped it)
Remember, when we serialize World, everything it references gets serialized…all the bees, flowers, and the hive.
And make sure the MessageSender fields in the Hive and Bee classes are marked [NonSerialized]
Before opening the file and reading from it, save a reference to the current world and framesRun.
If there’s a problem, you can revert to these and keep running.
Set up the Open File dialog box and pop it up.
Here’s where we deserialize the world and the number of frames run to the file.
If the file operations throw an exception, we restore the current world and framesRun.
Once everything is loaded, we hook up the delegates and restart the timer.
You’ll need to get your simulator up and running before you move on to the next chapter.
Sometimes you have to take graphics into your own hands.
We’ve spent a lot of time relying on controls to handle everything visual in our applications.
But sometimes that’s not enough—like when you want to animate a picture.
It all begins with the Graphics object, bitmaps, and a determination to not accept the.
You’ve been using controls al l along to interact with your programs TextBoxes, PictureBoxes, Labels…you’ve got a pretty good handle by now on how you can use the controls in the IDE’s toolbox.
But what do you really know about them? There’s a lot more to a control than just dragging an icon onto your form.
You can create your own controls The controls in the toolbox are really useful for building forms and applications, but there’s nothing magical about them.
They’re just classes, like the classes that you’ve been writing on your own.
In fact, C# makes it really easy for you to create controls yourself, just by inheriting from the right base class.
Your custom controls show up in the IDE’s toolbox There’s also nothing mysterious about the toolbox in the IDE.
It just looks in your project’s classes and the built-in .NET classes for any controls.
If  it finds a class that implements the right interface, then it displays an icon for it in the toolbox.
If  you add your own custom controls, they’ll show up in the toolbox, too.
You can write code to add controls to your form, and even remove controls, while your program’s running Just because you lay out a form in the IDE’s form designer, it doesn’t mean that it has to stay like that.
You’ve already moved plenty of  PictureBox controls around (like when you built the greyhound race)
In fact, when you build a form in the IDE, all it’s doing is writing the code that adds the controls to the form…which means you can write similar code, and run that code whenever you want.
You can create a class that inherits from any of the existing control classes—even if it doesn’t have any other code in it—and it’ll automatically show up in the toolbox.
Form controls are just objects You already know how important controls are to your forms.
Well, it turns out that those controls are just objects, just like everything else you’ve been working with.
A control is just an object, like any other object—it just happens to know how to draw itself.
The Form object keeps track of  its controls using a special collection called Controls, which you can use to add or remove controls in your own code.
Its Controls collection keeps a reference to each of the control objects on the form.
Each control in the form is just an instance of a particular object.
Use controls to animate the beehive simulator You’ve built a cool simulator, but it’s not much to look at.
It’s time to create a really stunning visualization that shows those bees in action.
You’re about to build a renderer that animates the beehive…and controls are the key.
The user interface shows you everything that’s going on Your simulator will have three different windows.
You’ve already built the main “heads-up display” stats window that shows stats about the current simulation and updates from the bees.
Now you’ll add a window that shows you what’s going in inside the hive, and a window that shows the field of flowers where the bees gather nectar.
We’ll make the Print button in the stats window work The stats window has working Open and Save buttons, but the Print button doesn’t work yet.
We’ll be able to reuse a lot of  the graphics code to get the Print button on the ToolStrip to print an info page about what’s going on.
These two windows are child windows—when you minimize the main window, the other two disappear along with it.
And when you move the main window around, the other two follow it.
This window displays the field of flowers and the bees gathering nectar.
The hive window shows you what’s going on inside the hive As the bees fly around the world, you’ll need to animate each one.
Sometimes they’re inside the hive, and when they are, they show up in this window.
The bees are born in the nursery, they have to fly to the exit to leave the hive to gather nectar from the flowers, and when they come back they need to go to the honey factory to make honey.
The field window is where the bees collect the nectar Bees have one big job: to collect nectar from the flowers, and bring it back to the hive to make honey.
Then they eat honey to give them energy to fly out and get more nectar.
When bees fly into it, they disappear from the field form and reappear near the exit in the hive form.
The hive exit is on the hive form, and the entrance is on the field form.
That’s why we put both of them in the hive’s locations dictionary.
We need another class that reads the information in the world and uses it to draw the hive, bees, and flowers on the two new forms.
We’ll add a class called Renderer to do exactly that.
And since your other classes are well encapsulated, this won’t require a lot of  changes to your existing code.
This is the object for the main window that you’ve already built.
The Hive and Field objects are forms, tied to your main form.
The World object keeps track of everything in the simulator: the state of the hive, every bee, and every flower.
Each bee knows its location—and we can use that location to draw the bee on the form.
Because Bee, Hive, Flower, and World are well encapsulated, a class that renders those objects can be added without lots of changes to existing code.
The renderer reads the information from the World object and uses that information to update the two forms.
It keeps a reference to the World object, as well as the Hive form object and the Field form object.
Sally’s art teacher asked the class to look at all of  the shadows and lines in the model and render them on the page.
The renderer draws everything in the world on the t wo forms The World object keeps track of  everything in the simulation: the hive, the bees, and the flowers.
But it doesn’t actually draw anything or produce any output.
It reads all of  the information in the World, Hive, Bee, and Flower objects and draws them on the forms.
The simulator renders the world af ter each frame After the main form calls the world’s Go() method, it should call the renderer’s Render() method to redraw the display windows.
For example, each flower will be displayed using a PictureBox control.
But let’s go further with bees and create an animated control.
You’ll create this new control, called BeeControl, and define its behavior yourself.
The World is encapsulated, so Renderer only needs to use the properties on World and its related objects to get the information it needs, and render the information on the display windows.
Controls are well suited for v isual display e lements When a new bee is added to the hive, we’ll want our simulator to add a new BeeControl to the Hive form and change its location as it moves around the world.
When that bee flies out of  the hive, our simulator will need to remove the control from the Hive form and add it to the Field form.
And when it flies back to the hive with its load of  nectar, its control needs to be removed from the Field form and added back to the Hive form.
And all the while, we’ll want the animated bee picture to flap its wings.
Controls will make it easy to do all of  that.
The world adds a new bee, and the renderer creates a new BeeControl and adds it to the Hive form’s Controls collection.
When the bee flies out of  the hive and enters the field, the renderer removes the BeeControl from the hive’s Controls collection and adds it to the Field form’s Controls collection.
A bee will retire if  it’s idle and it’s gotten too old.
If  the renderer checks the world’s Bees list and finds that the bee is no longer there, it removes the control from the Hive form.
Can you figure out what each of these code snippets does? Assume each snippet is inside a form, and write down your best guess.
You don’t need to write down each line, as much as summarize what’s going on in the code block.
Try it out if you want, and write why you think you got the result that .NET gave you.
If you’ve got a ListBox on your form, you can use its AddRange() method to add list items.
Can you figure out what each of these code snippets does? Assume each snippet is inside a form, and write down what you think it does.
Create a new button and add it to the form.
It’ll have default values (e.g., the Text property will be empty)
There’s a second Form in the application called Form2, so this creates it, sets its background image to a resource image called “Mosaic”, makes the background image so it’s tiled instead of stretched, and then displays the window to the user.
This code creates a new label, sets its text, and moves it to a new position.
Then it creates a new list box, adds four items to the list, and moves it just underneath the label.
It adds the label and list box to the form, so they both get displayed immediately.
This loop searches through all the controls on the form until it finds a label with the text “Bobby”
Once it finds the label, it removes it from the form.
You can’t modify the Controls collection (or any other collection) in the middle of a foreach loop that’s iterating through it.
What happens if there’s no control named “Bobby” in the Controls collection?
Build your f irst animated control You’re going to build your own control that draws an animated bee picture.
If  you’ve never done animation, it’s not as hard as it sounds: you draw a sequence of  pictures one after another, and produce the illusion of movement.
Lucky for us, the way C# and .NET handle resources makes it really easy for us to do animation.
When you flash these four bees quickly one after another, it’ll look like their wings are flapping.
We want a control in the toolbox If  you build BeeControl right, it’ll appear as a control that you can drag out of  your toolbox and onto your form.
It’ll look just like a PictureBox showing a picture of  a bee, except that it’ll have animated flapping wings.
This is like a PictureBox, but the image is set, and there’s animation that we’ll build in.
BeeControl is LIKE a PictureBox…so le t’s start by INHERITING from PictureBox Since every control in the toolbox is just an object, it’s easy to make a new control.
All you need to do is add a new class to your project that inherits from an existing control, and add any new behavior you want your control to perform.
We want a control—let’s call it a BeeControl—that shows an animated picture of  a bee flapping its wings, but we’ll start with a control that shows a non-animated picture, and then just add animation.
So we’ll start with a PictureBox, and then we’ll add code to draw an animated bee on it.
But instead of  adding them to the form resources, add them to the project’s resources.
Double-click on it to bring up the project’s Resources page.
In Chapter 1, we added the logo graphic to the form’s Resources file.
We’ve drawn a four-cell bee animation to import into your resources that you can download from http://www.headfirstlabs.com/books/hfcsharp/
Then, go to the Resources page, select “Images” from the first drop-down at the top of  the screen, and select “Add Existing File…” from the “Add Resource” drop-down.
Take a minute and flip back to Chapter 1 to remind yourself how you did this.
This sets the image used for a particular PictureBox’s image (and for our starting image)
Note that “.” at the end…that’s what tells the IDE to pop up the properties and methods of the class you typed in.
Now add your BeeControl! Just add this BeeControl class to your project:
Go back to the form designer and look in the toolbox, and the BeeControl is there.
When you change the code for a control, you need to rebuild your program to make your changes show up in the designer.
Here’s where you initialize the timer by instantiating it, setting its Interval property, and then adding its tick event handler.
Each time the timer’s tick event fires, it increments cell, and then does a switch based on it to assign the right picture to the Image property (inherited from PictureBox)
When the program’s running, each picture is stored in memory as a Bitmap object.
Create a button to add the BeeControl to your form It’s easy to add a control to a form—just add it to the Controls collection.
And it’s just as easy to remove it from the form by removing it from Controls.
But controls implement IDisposable, so make sure you always dispose your control after you remove it.
That class has members that should be pretty familiar by now: Visible, Width, Height, Text, Location, BackColor, BackgroundImage… all of  those familiar properties you see in the Properties window for any control.
You can add your own control to the toolbox just by creating a class that inherits from Control.
Remove the BeeControl from your form, and then add a button Go to the form designer and delete the BeeControl from the form.
When you add a control to the Controls collection, it appears on the form immediately.
Add a button to add and remove the bee control Here’s the event handler for it:
Now when you run your program, if  you click the button once it’ll add a new BeeControl to the form.
It uses the private control field to hold the reference to the control.
It sets the reference to null when there’s no control on the form.
We’re taking advantage of a using statement to make sure the control is disposed after it’s removed from the Controls collection.
You can use an object initializer to set the BeeControl properties after it’s instantiated.
Override the Dispose() method and dispose of the timer Since BeeControl inherits from a control, then that control must have a Dispose() method.
So we can just override and extend that method to dispose our timer.
As soon as you click on Dispose(), the IDE will fill in the method with a call to base.Dispose():
Now the BeeControl will dispose of  its timer as part of  its own Dispose() method.
But don’t take our word for it—set a breakpoint on the line you added and run your program.
Every time a BeeControl object is removed from the form’s Controls collection, its Dispose() method is called.
Your controls need to dispose the ir controls, too! There’s a problem with the BeeControl.
But the BeeControl creates a new instance of  Timer, which is a control that shows up in the toolbox…and it never gets disposed! That’s a problem.
When you type “override” inside a class, the IDE pops up an IntelliSense window with all of the methods you can override.
Select the Dispose() method and it’ll fill one in for you!
Any control that you write from scratch is responsible for disposing any other controls (or disposable objects) that it creates.
The control class implements IDisposable, so you need to make sure every control you use gets disposed.
It should only dispose the timer if the disposing argument is true.
We won’t  go into any more detail about this particular disposal pattern.
But if  you plan on building custom controls, you definitely should read this: http://msdn.microsoft.com/en-us/library/system.idisposable.aspx.
A UserControl is an easy way to build a control There’s an easier way to build your own toolbox controls.
Instead of  creating a class that inherits from an existing control, all you need to do is use the IDE to add a UserControl to your project.
You can drag other controls out of  the toolbox and onto it—it uses the normal form designer in the IDE.
And you can use its events just like you do with a form.
A UserControl is an easy way to add a control to the toolbox.
Edit a UserControl just like a form—you can drag other controls out of the toolbox onto it, and you can use its events exactly like a form’s events.
Drag a button to the form and give it exactly the same code as to add and remove a BeeControl.
The IDE will open up the new control in the form designer.
It’ll show up at the bottom of  the designer, just like with a form.
Use the Properties window to name it animationTimer and set its Interval to 150 and its Enabled to true.
Then double-click on it—the IDE will add its Tick event handler.
Just use the same Tick event handler that you used earlier to animate the first bee control.
Now run your program—the button code should still work exactly the same as before, except now it’s creating your new UserControl-based BeeControl.
You can also do this from the Properties page in the IDE, instead of using code.
But I’ve been using controls all this time, and I’ve.
You didn’t dispose your controls because your forms did it for you.
When the form is disposed, it automatically disposes everything in its Controls collection so you don’t have to worry about it.
But once you start removing controls from that collection or creating new instances of  controls (like the Timer in the BeeControl) outside of  the Controls collection, then you need to do the disposal yourself.
Q: Why does the form code for the PictureBox-based BeeControl work exactly the same with the UserControl-based BeeControl?
Q: I double-clicked on my OldBeeControl class in the Solution Explorer, and it had a message about adding components to my class.
To add components to your class, drag them from the Toolbox and use the Properties window to set their properties.
Q: When I changed the properties in the OpenFileDialog, I noticed an error message in the IDE: “You must rebuild your project for the changes to show up in any open designers.” Why did I get this error?
Your simulator ’s renderer wil l use your BeeControl to draw animated bees on your forms Now you’ve got the tools to start adding animation to your simulator.
With a BeeControl class and two forms, you just need a way to position bees, move them from one form to the other, and keep up with the bees.
You’ll also need to position flowers on the FieldForm, although since flowers don’t move, that’s pretty simple.
All of  this is code that we can put into a new class, Renderer.
The renderer keeps a reference to the world and each child form At the very top of  the Renderer class you’ll need a few important fields.
The class has to know the location of  each bee and flower, so it needs a reference to the World.
And it’ll need to add, move, and remove controls in the two forms, so it needs a reference to each of  those forms:
The renderer needs to be able to look at each of  those Bee and Flower  objects and figure out what BeeControl and PictureBox they correspond to—or, if  it can’t find a corresponding control, it needs to create one.
These two dictionary collections let the renderer store exactly one control for each bee or flower in the world.
These dictionaries become one-to-one mappings between a bee or flower and the control for that bee or flower.
The stats form will be the parent of the hive and field forms The first step in adding graphics to the beehive simulator will be adding two forms to the project.
You’ll add one called HiveForm (to show the inside of  the hive) and one called FieldForm (which will show the field of  flowers)
Then you’ll add lines to the main form’s constructor to show its two child forms.
Pass a reference to the main form to tell Windows that the stats form is their owner:
If you want to set another form as its owner, just pass a reference to that form to Show()
You’ll want the hive and field forms “linked” to the stats form—that does useful things like minimizing the hive and field forms when you minimize the stats form.
You can do this by telling Windows that the stats form is their owner.
But before we jump in and start coding, let’s take a minute and come up with a plan for how the Renderer class will work…
The bees and flowers already know their locations There’s a reason we stored each bee and flower location using a Point.
Once we have a Bee object, we can easily look up its BeeControl and set its location.
For each bee or flower, we can look up the matching control.
Then, set that control’s location to match the location of the bee or flower object.
If a bee doesn’t have a control, the renderer adds it to the hive form It’s easy enough for the renderer to figure out if  a particular bee or flower has a control.
If  the dictionary’s ContainsKey() method returns false for a particular Bee object, that means there’s no control on the form for that bee.
So Renderer needs to create a BeeControl, add it to the dictionary, and then add the control to the form.
It also calls the control’s BringToFront() method, to make sure the control doesn’t get hidden behind the flower PictureBoxes.
ContainsKey() tells us if the bee exists in the dictionary.
If not, then we need to add that bee, along with a corresponding control.
BringToFront() ensures the bee appears “on top of” any flowers on the FieldForm, and on top of the background of the HiveForm.
The renderer is acting on the two forms, as well as all the objects you built in the last chapter for the simulator.
Remember how a dictionary can use anything as a key? Well, this one uses a Bee object as a key.
The renderer needs to know which BeeControl on the form belongs to a particular bee.
So it looks up that bee’s object in the dictionary, which spits out the correct control.
Add the hi ve and f ie ld forms to the project.
Figure out where your locations are You need to figure out where the hive is on your FieldForm.
Using the Properties window, create a handler for the MouseClick event for the Hive form, and add this code:
We’ll get your form running on the next few pages.
Once it’s running, click on the exit of  the hive in the picture.
The event handler will show you the exact coordinates of  the spot that you clicked.
Then, by clicking, get the coordinates of  the exit, the nursery, and the honey factory.
The UserControl has a .cs file, a .designer.cs file, and a .resx file—you’ll need to add all three.
Then open up the code for both the .cs and .designer.cs files, and change the namespace lines so they match the namespace of  your new project.
Rebuild your project; the BeeControl should now show up in the toolbox.
You’ll also need to add the graphics to the new project’s resources.
Then add two more Windows forms to the project by right-clicking on the project in the Solution Explorer and choosing “Windows Form…” from the Add menu.
If  you name the files HiveForm.cs and FieldForm.cs, the IDE will automatically set their Name properties to HiveForm and FieldForm.
You already know that forms are just objects, so HiveForm and FieldForm are really just two more classes.
When you load the hive pictures into the Resource Designer, they’ll show up in the list of resources when you click the “…” button next to BackgroundImage in the Properties window.
Set each form’s FormBorderStyle property to FixedSingle (so the user can’t resize it), the ControlBox property to false (to take away its minimize and maximize controls), and StartPosition to Manual (so its Location property is settable)
Remove the mouse click handler when you’re done…you just needed it to get the locations on your forms.These are the coordinates that worked for us, but if your form.
Remember, go to the Properties window, click on the lightning-bolt icon to bring up the Events window, scroll down to the MouseClick row and double-click on it.
Make sure you resize both forms so they look like these screenshots.
Once you get your simulator running, you can use this to tweak the Hive’s locations collection.
The main form calls this class’s Render() method right after it calls World.Go() to draw the bees and flowers on the forms.
You’ll need to make sure that the flower graphic (Flower.png) is loaded into the project, just like the animated bee images.
The world just calls Render() to draw the world to the forms, and Reset() to clear the controls on the forms if it needs to reset.
The world uses Bee and Flower objects to keep track of every bee and flower in the world.
The forms use a PictureBox to display each flower and a BeeControl to display each bee.
The renderer uses these dictionaries to connect each bee and flower to its own BeeControl or PictureBox.
When a flower dies or a bee retires, it uses the deadFlowers and retiredBees lists to clean out the dictionaries.
The timer on the main form that runs the animation calls the Render() method, which updates the bees and the flowers, and then cleans out its dictionaries.
It finds all of the controls in each of its two dictionaries  and removes them from the forms, calling Dispose() on each of them.
The first foreach loop uses the flowerLookup dictionary to check each flower to see if it’s got a control on the form.
If it doesn’t, it creates a new PictureBox using an object initializer, adds it to the form, and then adds it to the flowerLookup dictionary.
The first looks for new flowers and adds their PictureBoxes.
The second looks for dead flowers and removes their PictureBoxes.
DrawFlowers() uses the Location property in the Flower object to set the PictureBox’s location on the form.
The second foreach loop looks for any PictureBox in the flowerLookup dictionary that’s no longer on the form and removes it.
After it removes the PictureBox, it calls its Dispose() method.
Then it adds the Flower object to deadFlowers so it’ll get cleared later.
DrawBees() also uses two foreach loops, and it does the same basic things as DrawFlowers()
But it’s a little more complex, so we split some of its behavior out into separate methods to make it easier to understand.
DrawBees() checks if a bee is in the hive but its control is on the FieldForm, or vice versa.
It uses two extra methods to move the BeeControls between the forms.
The second foreach loop works just like in DrawFlowers(), except it needs to remove the BeeControl from the right form.
Once the BeeControl is removed, we need to call its Dispose() method—the user control will dispose of its timer for us.
GetBeeControl() looks up a bee in the beeLookup dictionary and returns it.
The bees on the field form are smaller than the ones on the hive form, so the method needs to change BeeControl’s Size property.
After all the controls are moved around, the renderer calls this method to clear any dead flowers and retired bees out of the two dictionaries.
Whenever DrawBees() and DrawFlowers() found that a flower or bee was no longer in the world, it added them to the deadFlowers and retiredBees lists to be removed at the end of the frame.
The main form’s constructor moves the two child forms in place, then displays them.
The form passes a reference to itself into Form.Show() so it becomes the parent form.
When the main form loads, it creates an instance of each of the other two forms.
They’re just objects in the heap for now—they won’t be displayed until their Show() methods are called.
This code moves the two forms so that the hive form is next to the main stats form and the field form is below both of them.
Adding this one line to RunFrame makes the simulator update the graphics each time the world’s Go() method is called.
The Move event is fired every time the main form is moved.
Calling MoveChildForms() makes sure the child forms always move along with the main form.
Use the Events button in the Properties window to add the Move event.handler.
Now connect the main form to your t wo new forms, Hi veForm and Fie ldForm It’s great to have a renderer, but so far, there aren’t any forms to render onto.
We can fix that by going back to the main Form class (probably called Form1) and making some code changes:
Move the code to instantiate the World into the ResetSimulator() method.
The code to reset the world moved to the ResetSimulator() method.
Make sure you’ve set the field and hive forms’ StartPosition property to Manual, or else MoveChildForms() won’t work.
Since both child forms have StartPosition set to Manual, the main form can move them using the Location property.
Finally, you’ll need to add code to the Open button on the ToolStrip to use the Reset() method to remove the bees and flowers from the two forms’ Controls collections, and then create a new renderer using the newly loaded world.
The Reset button needs to call Reset() to clear out all the BeeControls and flower PictureBoxes, and then reset the simulator.
Here’s where we create new instances of the World and Renderer classes, which resets the simulator.
Q: I saw that you showed the form using a Show() method, but I don’t quite get what was going on with passing this as a parameter.
Q:Can you alter the preexisting controls and muck around with their code?
Test dri ve…ahem…buzz Compile all your code, chase down any errors you’re getting, and run your simulator.
Try changing the constants on your simulator, and seeing how the renderer handles more bees or flowers.
Looks great, but something’s not quite r ight… Look closely at the bees buzzing around the hive and the flowers, and you’ll notice some problems with the way they’re being rendered.
Remember how you set each BeeControl’s BackColor property to Color.
Transparent? Unfortunately, that wasn’t enough to keep the simulator from having some problems that are actually pretty typical of  graphics programs.
The flowers’ “transparent” backgrounds aren’t really transparent And there’s another, completely separate problem.
When we saved the graphics files for the flowers, we gave them transparent backgrounds.
But while that made sure that each flower’s background matched the background of  the form, it doesn’t look so nice when flowers overlap each other.
When the bees are hovering over the flowers, the same “cut-out” glitch happens.
Transparency works a little better with the hive form, where the form’s background image does show through the transparent areas of  the bee graphics.
And if  you watch closely as the bees move around the hive, you’ll see some glitches where the bee images are sometimes distorted when they move.
When you set a PictureBox’s background color to Transparent, it draws any transparent pixels in the image so they match the background of the form…which isn’t always the right thing to do.
When one PictureBox overlaps another, C# draws the transparent pixels so they match the form, not the other control that it overlaps, causing weird rectangular “cut-outs” any time two flowers overlap.
There are some serious performance issues Did you notice how the whole simulator slows down when all the bees are inside the hive? If  not, try adding more bees by increasing the constants in the Hive class.
Keep your eye on the frame rate—add more bees, and it starts to drop significantly.
Let’s take a closer look at those performance issues Each bee picture you downloaded is big.
Pop one of  them open in Windows Picture Viewer and see for yourself.
That means the PictureBox needs to shrink it down every time it changes the image, and scaling an image up or down takes time.
The reason the bees move a lot slower when there’s a lot of  them flying around inside the hive is that the inside hive picture is HUGE.
And when you made the background for the BeeControl transparent, it needs to do double work: first it has to shrink the bee picture down, and then it needs to shrink a portion of  the form’s background down so that it can draw it in the transparent area behind the bee.
The PictureBox needs to scale the picture down to size every time it displays a new animation frame.
The bee picture is really big, and the PictureBox needs time to shrink it down every time it displays a new animation frame.
Every time a bee flies in front of it, its PictureBox needs to scale it down to the size of the control.
It needs to do that to show part of the picture any place the bee picture’s transparent background lets it show through.
All we need to do to speed up the graphics performance is add a method to the renderer that scales any image to a different size.
Then we can resize each picture once when it’s loaded, and only use the scaleddown version in the bee control and for the hive form’s background.
Here’s a static method that resizes bitmaps—add it to the Renderer class:
We’ll take a closer look at what this Graphics object is and how this method works in the next few pages.
Add this ResizeCells method to your BeeControl Your BeeControl can store its own Bitmap objects—in this case, an array of  four of  them.
Here’s a control that’ll populate that array, resizing each one so that it’s exactly the right size for the control:
Set the form’s background image manually Go to the Properties window and set the hive form’s background image to (none)
Then go to its constructor and set the image to one that’s sized properly.
Your form has a ClientRectangle property that contains a Rectangle that has the dimensions of its display area.
Change the switch statement so that it uses the cells array, not the resources The BeeControl’s Tick event handler has a switch statement that sets its BackgroundImage:
Add calls to ResizeCells() to the BeeControl You’ll need to add two calls to the new ResizeCells() method.
Then go back to the IDE designer by double-clicking on the BeeControl in the Properties window.
Go over to the Events page in the Properties window (by clicking on the lightning-bolt icon), scroll down to Resize, and double-click on it to add a Resize event handler.
Make the new Resize event handler call ResizeCells(), too—that way it’ll resize its animation pictures every time the form is resized.
These lines take each of the Bitmap objects that store the bee pictures and shrink them down using the ResizeImage() method we wrote.
You resized your Bitmaps using a Graphics object Let’s take a closer look at that ResizeImage() method you added to the renderer.
The first thing it does is create a new Bitmap object that’s the size that the picture will be resized to.
It uses that Graphics object’s DrawImage() method to draw the picture onto the Bitmap.
Notice how you passed  the width and height parameters to DrawImage()—that’s how you tell it to scale the image down to the new size.
Finally you returned the new Bitmap you created, so it can be used as the form’s background image or one of  the four animation cells.
You can see the image resizing in action—the squished bee image is much smaller than the PictureBox.
You pass a picture into the method, along with a new width and height that it’ll be resized to.
The FromImage() method returns a new Graphics object th at lets.
IntelliSense to look at the methods in the Graphics class.
DrawImage(), it copies the image into the resizedPicture bit map at the.
Forms and controls have a CreateGraphics() method that returns a new Graphics object.
The ResizeImage() method creates a Graphics object to draw on an invisible Bitmap object.
It returns that Bitmap so it can be displayed on a form or in a PictureBox.
But what, exactly, is your program doing with them once they’re imported?
You can also pass it integers for width and height—that’ll create a new Bitmap with no picture.
Then each Bitmap is drawn to the screen Once your images are in Bitmap objects, your form draws them to the screen with a call like this:
Resizing images takes a lot of processing power! If you do it once, it’s no big deal.
But if you do it EVERY FRAME, your program will slow down.
We gave you REALLY BIG images for the bees and the hive.
When the renderer moves the bees around (especially in front of the inside hive picture), it has to resize them over and over again.
If you don’t see any performance problems, keep adding bees until the program slows down!
The .NET Framework comes with some pretty powerful graphics tools that go a lot further than the simple PictureBox control that’s in the toolbox.
You can draw shapes, use fonts, and do all sorts of  complex graphics…and it all starts with a Graphics object.
Any time you want to add or modify any object’s graphics or images, you’ll create a Graphics object that’s linked to the object you want to draw on, and then use the Graphics object’s methods to draw on your target.
System.Drawing The graphics methods in the System.Drawing namespace are sometimes referred to as GDI+, which stands for Graphics Device Interface.
When you draw graphics with GDI+, you start with a Graphics object that’s hooked up to a Bitmap, form, control, or another object that you want to draw on using the Graphics object’s methods.
The form can call its own CreateGraphics() method, or another object can call it.
Either way, the method returns a reference to a Graphics object whose methods will draw on it.
The DrawLines() method, for example, draws a bunch of lines on whatever object created the Graphics instance.
Use the Graphics object’s methods to draw on your object Every Graphics object has methods that let you draw on the object that created it.
When you call methods in the Graphics object to draw lines, circles, rectangles, text, and images, they appear on the form.
Start with the object you want to draw on For instance, think about a form.
When you call the form’s CreateGraphics() method, it returns an instance of Graphics that’s set up to draw on itself.
Even though you’re calling methods in this Graphics object, the actual graphics appear on the object that created it.
Calls on this instance of Graphics affect the form that created the Graphics object.
A 30-second tour of GDI+ graphics There are all sorts of  shapes and pictures that you can draw once you’ve created a Graphics object.
All you need to do is call its methods, and it’ll draw directly onto the object that created it.
The first step is always to grab yourself  a Graphics object.
Use a form’s CreateGraphics() method, or have a Graphics object passed in.
Remember, Graphics implements the IDisposable() interface, so if  you create a new one, use a using statement:
If  you want to draw a line, call DrawLine() with a starting point and ending point, each represented by X and Y coordinates:
Here’s code that draws a filled slate gray rectangle, and then gives it a sky blue border.
You can draw an ellipse or a circle using the DrawCircle() or FillCircle() methods, which also use a Rectangle to specify how big the shape should be.
This code draws two ellipses that are slightly offset to give a shadow effect:
Use the DrawString() method to draw text in any font and color.
To do that, you’ll need to create a Font object.
You’ll need to make sure you’ve got a using System.Drawing; line at the top of your class to use these methods.
Or, when you add a form to your project, the IDE adds that line to your form class automatically.
If the above statements are executed in order, this is what will end up on the form.
Each of the statements above matches up with the numbers here.
Remember, this draws on the object that created this instance.
There’s no step 1 on this picture, since that was creating the actual Graphics object.
There are a whole lot of colors you can use—just type “Color”, “Pens”, or “Brushes” followed by a dot, and the IntelliSense window will display them.
Start the event handler with a using line to create the Graphics object.
When you work with GDI+, you use a lot of  objects that implement IDisposable.
If  you don’t dispose of  them, they’ll slowly suck up your computer’s resources until you quit the program.
So you’ll end up using  a lot of  using statements:
Use graphics to draw a picture on a form Let’s create a new Windows application that draws a picture on a form when you click on it.
Start by adding a Click event to the form Go to the Events page in the Properties window (by clicking on the lightning-bolt icon), scroll down to the Click event, and double-click on it.
Pay attention to the order you draw things on our form We want a sky blue background for this picture, so you’ll draw a big blue rectangle first—then anything else you draw afterward will be drawn on top of  it.
You’ll take advantage of  one of the form’s properties called ClientRectangle.
It’s a Rectangle that defines the boundaries of  the form’s drawing area.
Rectangles are really useful—you can create a new rectangle by specifying a Point for its upper left-hand corner, and its width and height.
Once you do that, it’ll automatically calculate its Top, Left, Right, and Bottom properties for you.
And it’s got useful methods like Contains(), which will return true if  a given point is inside it.
Draw the bee and the flower You already know how the DrawImage() method works.
Add a pen that you can draw with Every time you draw a line, you use a Pen object to determine its color and thickness.
There’s a built-in Pens class that gives you plenty of  pens (Pens.Red is a thin red pen, for example)
But you can create your own pen using the Pen class constructor, which takes a Brush object and a thickness (it’s a float, so make sure it ends with F)
Brushes are how you draw filled graphics (like filled rectangles and ellipses), and there’s a Brushes class that gives you brushes in various colors.
Here’s the first line in your Form1_Click() event handler method.
We’ll give you all the lines for the event handler—put them together to draw the picture.
Pens are for drawing lines, and they have a width.
If you want to draw a filled shape or some text, you’ll need a Brush.
This will come in really handy later on in the book! What do you think you’ll be doing with Contains()?
Add an arrow that points to the flower There are some Graphics methods that take an array of  Points, and connect them using a series of  lines or curves.
We’ll use the DrawLines() method to draw the arrow head, and the DrawCurve() method to draw its shaft.
There are other methods that take point arrays, too (like DrawPolygon(), which draws a closed shape, and FillPolygon(), which fills it in)
This goes inside the inner using statement that created the Pen.
Here’s where the using block ends—we don’t need the thickBlackPen any more, so it’ll get disposed.
Add a font to draw the text Whenever you work with drawing text, the first thing you need to do is create a Font object.
There are several overloaded constructors—the simplest one takes a font name, font size, and FontStyle enum.
Add some text that says “Nectar here” Now that you’ve got a font, you can figure out where to put the string by measuring how big it will be when it’s drawn.
The MeasureString() method returns a SizeF that defines its size.
SizeF is just the float version of  Size—and both of  them just define a width and height.
Since we know where the arrow ends, we’ll use the string measurements to position its center just above the arrow.
You can create a Rectangle by giving it a point and a Size (or width and height)
Once you’ve got it, you can find its boundaries and check its Contains() method to see if it contains a Point.
When you pass an array of points to DrawCurve(), it draws a smooth curve that connects them all in order.
Can you figure out what happens when you run the code below? Draw the output onto the form, using the grid you just rendered for locating specific points.
Most of your work with Graphics will involve thinking about your forms as a grid of X, Y coordinates.
Here’s the code to build the grid shown below; your job is to fill in the missing parts.
Figure out what’s drawn using the grid we’ve given you below.
FillPolygon(), DrawLines(), and a few other graphics methods have a constructor that takes an array of Points that define the vertices of a series of connected lines.
Your job was to fill in the missing code to draw a grid, and plot two chunks of code on the grids.
Next we draw the horizontal lines and X axis numbers.
First we draw the vertical lines and the numbers along the Y axis.
There’s a vertical line every 20 pixels along the X axis.
We used using statements to make sure the Graphics and Font objects get disposed after the form’s drawn.
Graphics can f ix our transparency problem… Remember those pesky graphics glitches? Let’s tackle them! DrawImage() is the key to fixing the problem in the renderer where the images were drawing those boxes around the bees and flowers that caused the overlap issues.
We’ll start out by going back to our Windows application with the picture and changing it to draw a bunch of  bees that overlap each other without any graphics glitches.
Add a DrawBee() method that draws a bee on any Graphics object.
It uses the overloaded DrawImage() constructor that takes a Rectangle to determine where to draw the image, and how big to draw it.
Take a close look at how it works—it draws the hive so that its upper left-hand corner is way off the form, at location (-Width, -Height), and it draws it at twice the width and height of  the form—so you can resize the form and it’ll still draw OK.
The renderer drew the bees so that they looked weird when they overlapped.
Run your program and click on the form, and watch it draw the bees! But something’s wrong.
When you drag the form off  the side of  the screen and back again, the picture disappears! Now go back and check the “Nectar here” program you wrote a few pages ago—it’s got the same problem!
Much better—click on the form and the bees overlap just fine.
But look what happens if you drag it off the side of the screen and back! Oh no!
First we’ll draw the hive background, with its corner far off the page so we only see a small piece of it.
Then we’ll draw four bees so that they overlap—if they don’t, make your form bigger and then click on it again so they do.
Use the Paint event to make your graphics stick What good are graphics if  they disappear from your form as soon as part of  your form gets covered up? They’re no good at all.
Luckily, there’s an easy way to make sure your graphics stay on your form: just write a Paint event handler.
Your form fires a Paint event every time it needs to redraw itself—like when it’s dragged off  the screen.
One of  the properties of  its PaintEventArgs parameter is a Graphics object called Graphics, and anything that you draw with it will “stick.”
Forms and controls redraw themselves all the timeIt may not look like it, but your forms have to redraw themselves all the time.
Any time you have controls on a form, they’re displaying graphics—labels display text, buttons display a picture of a button, checkboxes draw a little box with an X in it.
You work with them as controls that you drag around, but each control actually draws its own image.
Any time you drag a form off the screen or under another form and then drag it back or uncover it, the part of the form that was covered up is now invalid, which means that it no longer shows the image that it’s supposed to.
That’s when .NET sends a message to the form telling it to redraw itself.
The form fires off a Paint event any time it’s “dirty” and needs to be redrawn.
If you ever want your form or user control to redraw itself, you can tell .NET to make it “dirty” by calling its Invalidate() method.
Add a Paint event handler Double-click on “Paint” in the Events page in the Properties window to add a Paint event handler.
The Paint event is fired any time the image on your form gets “dirty.” So drawing your graphics inside of  it will make your image stick around.
Use the Graphics object from the Paint event’s EventArgs Instead of  starting with a using statement, make your event handler start like this:
You don’t have to use a using statement—since you didn’t create it, you don’t have to dispose it.
Forms and controls have a Paint event that gives you a Graphics object.
Copy the code that draws the overlapping bees and hive Add the new DrawBee() method from the previous page into your new user control.
Then copy the code from the Click event into your new Paint event—except for the first line with the using statement, since you already have a Graphics object called g.
Since you don’t have the using statement anymore, make sure you take out its closing curly bracket.
Its PaintEventArgs has a property called Graphics—and anything you draw with it will stick to your form.
Do the same with your “Nectar here” drawing to make it stick, too.
Add two TrackBar controls to a new user control Create a new Windows Application project.
Drag two TrackBar controls out of  the toolbox and onto it.
Then drag trackBar2 to the right-hand side of the control and set its Orientation property to Vertical.
Finally, double-click on each TrackBar to add a Scroll event handler.
Load a picture into a Bitmap object and draw it on the control Add a private Bitmap field called photo to your Zoomer user control.
When you create the instance of  Bitmap, use its constructor to load your favorite image file—we used a picture of  a fluffy dog.
Then drag your control onto the form—make sure to resize the form so the trackbars are at the edges.
Give the two trackbars white backgrounds because you’ll be drawing a white rectangle behind everything, and you want them to blend in.
When you move the trackbars, the picture will shrink and grow!
Whenever the user scrolls one of  the TrackBars, they call the user control’s Invalidate() method.
That will cause the user control to fire its Paint event and resize the photo.
Remember, since you didn’t create the Graphics object—it was passed to you in PaintEventArgs—you don’t need to dispose it.
So you don’t have to use a using statement with it.
Your user control has a Paint event, and it works just like the one you just used in the form.
It has a property called Graphics, and anything that you draw with that Graphics object will be painted onto any instance of  the user control you drag out of  the toolbox.
Each drag here is causing another image resize from DrawImage()
First we draw a big white rectangle so it fills up the whole control, then we draw the photo on top of it.
Every time the user slides one of the trackbar controls, it fires off a Scroll event.
By making the event handlers call the control’s Invalidate() method, we cause the form to repaint itself…and when it does, it draws a new copy of the image with a different size.
This particular Bitmap constructor loads its picture from a file.
It’s got other overloaded constructors, including one that lets you specify a width and height—that one creates an empty bitmap.
Substitute your own file—the Bitmap constructor can take many file formats.
Even better, see if you can use an OpenFileDialog to zoom any image you want!
Invalidate() essentially says that some part of the form might be “invalid,” so redraw that part to make sure it’s got the right things showing.
The form’s Refresh() method is Invalidate() plus Update() Forms and controls give you a shortcut.
They have a Refresh() method that first calls Invalidate() to invalidate the whole client area (the area of  the form where graphics appear), and then calls Update() to make sure that message moves to the top of  the list.
A closer look at how forms and controls repaint themselves Earlier, we said that when you start working with Graphics objects, you’re really taking control of  graphics.
It’s like you tell .NET, “Hey, I know what I’m doing, I can handle the extra responsibility.” In the case of  drawing and redrawing, you may not want to redraw when a form is minimized and maximized…or you may want to redraw more often.
Once you know what’s going on behind the scenes with your form or control, you can take control of  redrawing yourself:
Invalidate() controls when to redraw, and WHAT to redraw .NET fires the Paint event when something on a form is interfered with, covered up, or moved offscreen, and then shown again.
The Rectangle tells the Invalidate() method what part of  the form needs to be redrawn…i.e., what part of  the form is “dirty.” Then .NET calls OnPaint to tell your form to fire a Paint event and repaint the dirty area.
Every form has a Paint event that draws the graphics on the form Go to the event list for any form and find the event called Paint.
Whenever the form has to repaint itself, this event is fired.
Every form and control uses a Paint event internally to decide when to redraw itself.
But what fires that event? It’s called by a method called OnPaint that the form or user control inherits from the Control class.
That method follows the pattern you saw in Chapter 11, where methods that fire an event are named “On” followed by the event name.
Drag your form around—drag it halfway off  the screen, minimize it, hide it behind other windows.
You’ll see that your OnPaint method fires off  a Paint event any time part of  it is “dirty”—or invalid—and needs to be redrawn.
And if  you look closely at the ClipRectangle, you’ll see that it’s a rectangle that describes the part of  the form that needs to be repainted.
That gets passed to the Paint event’s PaintEventArgs so it can improve performance by only redrawing the portion that’s invalid.
The Update() method gives your Invalidate request top priority You may not realize it, but your form is getting messages all the time.
The same system that tells it that it’s been covered up and calls OnPaint has all sorts of  other messages it needs to send.
See for yourself: type override and scroll through all the methods that start with “On”—every one of  them is a message your form responds to.
The Update() method moves the Invalidate message to the top of  the message list.
So when you call it yourself, you’re telling .NET that your whole form or control is invalid, and the whole thing needs to be redrawn.
You can pass it your own clip rectangle if you want—that’ll get passed along to the Paint event’s PaintEventArgs.
Q: It still seems like just resizing the graphics in a program like Paint or PhotoShop would be better.
Q: But if I can resize it outside of .NET, that’s better, right?
Q:I get that CreateGraphics() gets the Graphics object for drawing on a form, but what was that FromImage() call in the ResizeImage() method about?
Q: So a Graphics object isn’t just for drawing on a form?
Q: Wait, I thought using was just something I used with streams.
Q:If I’m creating a new control, should I use a UserControl or should I create a class that inherits from one of the toolbox controls?
The IDE’s form designer lets you drag controls out of the toolbox and onto your new user control.
Even without resizing, it takes time to draw an image onto a form.
It still takes time to draw all those bees and flowers and the hive.
And right now, we’re drawing right to the Graphics object on the form.
So if your eye catches the tail end of  a render, you’re going to perceive it as a little flicker.
The problem is that a lot of  drawing is happening, so there’s a good chance that some flickering will occur, even with our resizing.
And that’s why you run into problems with some amateur computer games, for example: the human eye catches the end of  a rendering cycle, and perceives it as a little bit of  flickering on the screen.
I noticed a whole lot of flickering in my Zoomer control.
With all this talk of taking control of graphics, I’ll bet there’s something we can do.
How could you get rid of this flicker? If drawing lots of images onto the form causes flickering, and you have to draw lots of images, how do you think you might be able to avoid all the flickering?
Double buffering makes animation look a lot smoother Go back to your image zoomer and fiddle with the trackbars.
Notice how there’s a whole lot of  flickering when you move the bars? That’s because the Paint event handler first has to draw the white rectangle and then draw the image every time the trackbar moves a tiny little bit.
When your eyes see alternating white rectangles and images many times a second, they interpret that as a flicker.
It’s irritating…and it’s avoidable using a technique called double buffering.
That means drawing each frame or cell of  animation to an invisible bitmap (a “buffer”), and only displaying the new frame once it’s been drawn entirely.
By drawing each frame to an invisible bitmap, the users won’t see the flicker any more.
They’ll only see the finished frame when we copy it from the bitmap back to the form.
To do double buffering, we can add a Bitmap object to the program to act as a buffer.
Every time our form or control needs to be repainted, instead of  drawing the graphics directly on the form, we draw on the buffer instead.
It all gets copied at once, and that eliminates the flicker.
Here’s a typical program that draws some graphics on a form using its Graphics object.1
The users saw a lot of flickering because each frame was drawn in pieces.
Double buffering is built into forms and controls You can do double buffering yourself  using a Bitmap, but C# and .NET make it even easier with built-in support for double buffering.
All you need to do is set its DoubleBuffered property to true.
Try it out on your Zoomer user control—go to its Properties window, set DoubleBuffered to true, and your control will stop flickering! Now go back to your BeeControl and do the same.
That won’t fix all of  the graphics problems—we’ll do that in a minute—but it will make a difference.
Now you’re ready to fix the graphics problems in the simulator!
When you use the Paint event for all your graphics, you can turn on double buffered painting simply by changing one property.
Overhaul the beehive simulator In the next exercise, you’ll take your beehive simulator and completely overhaul it.
Don’t forget to change their namespace to match your new project.
You’ll start by removing the BeeControl user control There won’t be any controls on the hive and field at all.
The bees, flowers, and hive pictures will all be drawn using GDI+ graphics.
So rightclick on BeeControl.cs in the Solution Explorer and click Delete—they’ll be removed from the project and permanently deleted.
You’ll need a timer to handle the bee wing flapping The bees flap their wings much more slowly than the simulator’s frame rate, so you’ll need a second, slower timer.
This shouldn’t be too surprising, since the BeeControl had its own timer to do the same thing.
The big step: overhaul the renderer You’ll need to throw out the current renderer entirely, because it does everything with controls.
You won’t need those lookup dictionaries, because there won’t be any PictureBoxes or BeeControls to look up.
Instead, it’ll have two important methods: DrawHive(g) will draw a Hive form on a graphics object, and DrawField(g) will draw a Field form.
Last of all, you’ll hook up the new renderer The Hive and Field forms will need Paint event handlers.
Each of  them will call the Renderer object’s DrawField(g) or DrawHive(g) methods.
The two timers—one for telling the simulator to draw the next frame, and the other to flap the bees’ wings—will call the two forms’ Invalidate() methods to repaint themselves.
When they do, their Paint event handlers will render the frame.
Add a second timer to the main form to make the bees’ wings flap Drag a new timer onto the main form and set its Interval to 150ms and Enabled to true.
Then add this AnimateBees() method to the renderer to make the bees’ wings flap:
The whole idea here is to set a field called Cell that you can use when you’re drawing the bees in the renderer.
The timer will constantly call the AnimateBees() method, which will cause the cell field to keep changing, which will cause your bees to flap their wings.
As long as you keep the world up to date and both forms have a reference to the renderer object, all you need to do to animate them is call their Invalidate() methods.
Their Paint event handlers will take care of the rest.
Set up the hive and field forms for double-buffered animation Remove the code from the hive form’s constructor that sets the background image.
Then remove all controls from both forms and set their DoubleBuffered properties to true.
Finally, add a Paint event handler to each of  them.
The hive form and field form both need a public Renderer property Add a public Renderer property to the hive form and the field form:
To make this work, you’ll need to change the declaration of  your Renderer to add the public modifier: public class Renderer.
You’ll also need to do the same for the World, Hive, Bee, and Flower classes and the BeeState enum—add the public access modifier to each of  their declarations.
Then update your Renderer’s constructor to set each form’s Renderer property:
Overhaul the renderer by removing control-based code and adding graphics Here’s what you need to do to fix the renderer:
Remove the two dictionaries, since there aren’t any more controls.
And while you’re at it, you don’t need the BeeControl anymore, or the Render(), DrawBees(), or DrawFlowers() methods.
Add the PaintHive() method that takes a Graphics object as a parameter and paints the hive form onto it.
It should draw a sky blue rectangle on the top half  of the form, and a green rectangle on the bottom half.
Finally, draw each bee (using the small bee pictures)—draw them last so they’re in front of  the flowers.
When you’re drawing the bees, remember that AnimateBees() sets the cell field.
Make sure you turn on double buffering, or your forms will flicker!
All the Reset() method did was remove the controls from the forms, and there won’t be any controls to remove.
Here’s the complete Renderer class, including the AnimateBees() method that we gave you.
Make sure you make all the modifications to the three forms—especially the Paint event handlers in the hive and field forms.
Those event handlers call the renderer’s PaintHive() and PaintField() methods, which do all of the animation.
The InitializeImages() method resizes all of the image resources and stores them in Bitmap fields inside the Renderer object.
Don’t forget to change the class declaration in Renderer.cs from class Renderer to public class Renderer, and then do the same for World, Hive, Flower, and Bee; otherwise, you’ll get a build error about field and type accessibility.
Flip to Leftover #2 in the Appendix to learn about why you need to do this.
A form’s ClientSize property is a Rectangle that tells you how big its drawing area is.
Use a Graphics object and an event handler for print ing The Graphics methods you’ve been using to draw on your forms are the same ones you use to print.
All you need to do is create a PrintDocument object.
It’s got an event called PrintPage, which you can use exactly like you use a timer’s Tick event.
Then call the PrintDocument object’s Print() method, and it prints the document.
And remember, the IDE makes it especially easy to add the event handler.
Start a new Windows application and add a button to the form.
Press Tab and the IDE automatically fills in the rest of  the line.
This is just like how you added event handlers in Chapter 11:
As soon as you press Tab, the IDE generates an event handler method and adds it to the form.
Just replace the throw statement with code that calls the e.Graphics object’s drawing methods.
Now finish off  the button1_Click event handler by calling document.Print()
When that method is called, the PrintDocument object creates a Graphics object and then fires off  a PrintPage event with the Graphics object as a parameter.
Anything that the event handler draws onto the Graphics object will get sent to the printer.
Now you can put ANY graphics code here—just replace the throw line and use e.Graphics for all of the drawing.
PrintDocument works with the print dialog and print prev iew window objects Adding a print preview window or a print dialog box is a lot like adding an open or save dialog box.
All you need to do is create a PrintDialog or PrintPreviewDialog object, set its Document property to your Document object, and then call the dialog’s Show() method.
The dialog will take care of  sending the document to the printer—no need to call its Print() method.
So let’s add this to the button you created in Step 1:
Use e .HasMorePages to print mult ipage documents If  you need to print more than one page, all you need to do is have your PrintPage event handler set e.HasMorePages to true.
That tells the Document that you’ve got another page to print.
It’ll call the event handler over and over again, once per page, as long as the event handler keeps setting e.HasMorePages to true.
So modify your Document’s event handler to print two pages:
Once you’ve got a PrintDocument and an event handler to print the page, you can pop up a print preview window just by creating a new PrintPreviewDialog object.
If you set e.HasMorePages to true, the Document object will call the event handler again to print the next page.
Now run your program again, and make sure it’s displaying two pages in the print preview.
We’ll reuse our DrawBee() method from a few pages ago.
Make the button pop up a print preview window Add an event handler for the button’s click event that pauses the simulator, pops up the print preview dialog, and then resumes the simulator when it’s done.
If  the simulator is paused when the button is clicked, make sure it stays paused after the preview is shown.
Create the document’s PrintPage event handler It should create a page that looks exactly like the one on the facing page.
This PrintTableRow() method will come in handy You’ll find this method useful when you create the table of  bee stats at the top of  the page.
We created the oval with text in it using the MeasureString() method, which returns a Size that contains the size of a string.
We drew the oval and text twice to give it a shadow effect.
Each time you call PrintTableRow(), it adds the height of the row it printed to tableY and returns the new value.
Use the PrintTableRow() method to print the rows of the table.
Use the Width property in e.MarginBounds to make it half the width of the page.
Then use the renderer to do the same for the field form—make it the full page width using the X and Y fields in e.MarginBounds.
See if you can give them the same proportions as the two forms.
Once you figure out how tall to make the hive picture, align it to the bottom of the page.
Here’s a hint: To find the height of each form, find the ratio of its height divided by its width and multiply that by the final width.
Take a close look at the notes we wrote on the printout.
It draws the oval header, and sets up variables that you’ll use to draw the table of bee stats.
Did you figure out how the PrintTableRow() method works? All you need to do is call it once per row, and it prints whatever text you want in the two columns.
The trick is that it returns the new tableY value for the next row.
Don’t forget to draw the rectangle around the table and the line between the columns.
You’ll need a black pen that’s 2 pixels wide to draw the lines around the screenshots.
The PaintHive() method needs a Graphics object to draw on, so this code creates an empty Bitmap object and passes it to PaintHive()
Here’s where the height of the screenshot is calculated using the form’s height-width ratio.
It pauses the simulator (if it’s running), creates a PrintDocument, hooks it up to the PrintPage event handler, shows the dialog, and then restarts the simulator.
Since the pen and the two bitmaps need to be disposed, we put them all in one big using block.
The bitmaps need to be the same size as the form’s drawing area, so ClientSize comes in handy.
There’s so much more to be done… You’ve built a pretty neat little simulator, but why stop now? There’s a whole lot more that you can do on your own.
Here are some ideas—see if  you can implement some of  them.
Add a control panel Convert the constants in the World and Hive classes to properties.
Then add a new form with a control panel that has sliders to control them.
The more flowers there are, the more enemies are attracted to the hive.
Then add Sting Patrol bees to defend against the enemies, and Hive Maintenance bees to defend and repair the hive.
Add hive upgrades If the hive gets enough honey, it gets bigger.
A bigger hive can hold more bees, but takes more honey and attracts more enemies.
If enemies cause too much damage, the hive gets smaller again.
Add a queen bee who lays eggs The eggs need Baby Bee Care worker bees to take care of them.
More honey in the hive causes the queen to lay more eggs, which need more workers to care for them, who consume more honey.
Add animation Animate the background of the Hive form so the sun slowly travels across the sky.
Make it get dark at night, and draw stars and a moon.
Add some perspective—make the bees get smaller the further they get from the hive in the field of flowers.
Use your imagination! Try to think of other ways you can make the simulation more interesting or more interactive.
A good simulation will have lots of tradeoffs, and will give the user ways to decide which tradeoffs to make to influence the progress of the hive.
Below is the code detailing the fight between Captain Amazing and Swindler (not to mention his clone army)
Your job is to draw out what’s going on in memory when the FinalBattle class is instantiated.
Draw a picture of what the heap will look like exactly one second after the FinalBattle constructor runs.
We’ve gotten you started here, with what’s going on in the factory object.
You can assume that Clones was set using a collection initializer.
Based on your diagrams, where in the code did Captain Amazing die?
Make sure you draw in lines showing the architecture—we drew a line from the clone factory to the Villain object, because the factory has references to it (via its PeopleInFactory field)
We’ve left space, as there is more to be drawn at this stage.
Make sure you add labels to your objects to show the reference variables that are pointing to them.
Your job is to draw what’s going on in these two bits of memory, too.
There’s a Clone class that we’re not showing you in this code, too.
When the selfDestruct fires, the factory reference variable is set to null, and eligible for garbage collection.
The captainAmazing reference points to a Superhero object, and the swindler reference points to a Villain object, and the clone factory’s PeopleInFactory list contains references to both of them.
As long as there’s a reference to swindler from the escapePlane, he won’t get garbage-collected.
Here’s the object you should have added to this diagram.
Based on your diagrams, where in the code did Captain Amazing die?
Once finalBattleFactory was set to null, it was ready for garbage collection.
And it took the last reference to the Captain with it!
As soon as the factory reference was gone, it took the CloneFactory object with it—and that caused the List object referenced by its PeopleInFactory field to disappear…and that was the only thing keeping the SuperHero object alive.
Now he’ll be destroyed the next time the garbage collector runs.
Once the Superhero instance had no clone factory referencing it, it was marked for garbage collection too.
Some of this code is for learning purposes only, not for your real programs.
Throughout the book we’ve made reference to how objects “eventually” get garbage-collected, but we never really specified exactly when that.
We’re about to show you some code that automatically triggers garbage collection using GC.Collect() and pops up a MessageBox in a finalizer.
Sometimes you need to be sure something happens before your object gets garbage-collected, like releasing unmanaged resources.
A special method in your object called the finalizer allows you to write code that will always execute when your object is destroyed.
Think of it as your object’s personal finally block: it gets executed last, no matter what.
Here’s an example of  a finalizer in the Clone class:
Your last chance to DO something… your object’s f inalizer.
It looks like the CloneID and Location fields are populated any time a Clone gets created.
It sends a message to the villain telling the ill-fated clone’s location and ID.
But it will only run when the object is garbage-collected.
You write a finalizer method just like a constructor, but instead of  an access modifier, you put a ~ in front of  the class name.
That tells .NET that the code in the finalizer block should be run right before it garbage-collects the object.
Also, finalizers can’t have parameters, because .NET doesn’t need to tell it anything other than “you’re done!”
This ~ (or “tilde”) character says that the code in this block gets run when the object is garbage-collected.
In general, you’ll never write a finalizer for an object that only owns managed resources.
Everything you’ve encountered so far in this book has been managed—meaning.
But occasionally programmers need to access an underlying Windows resource that isn’t part of  the .NET Framework.
If  you find code on the Internet that uses the [DllImport] attribute, you.
And some of those non-.NET resources might leave your system unstable if  they’re not.
The finalizer for your object runs after all references are gone, but before that object gets garbage-collected.
And garbage collection happens after all references to your object go away.
But garbage collection doesn’t always happen right after the references are gone.
Suppose you have an object with a reference to it.
But since there are references to your object, the garbage collector ignores it and moves along.
That last object holding a reference to your object decides to move on.
Now, your object is sitting in memory, with no references.
Garbage collection is something that .NET controls, not your objects.
So if  the garbage collector isn’t sent out again for, say, a few seconds, or maybe even a few minutes, your object still lives on in memory.
And any finalizer your object has does not (yet) get run.
Your finalizer runs…possibly several minutes after the last reference to the object was removed or changed.
Now that it’s been finalized, your object is dead, and the collector tosses it away.
Most times, you’ll never use this method, because garbage collection is tuned to respond to a lot of  conditions in the CLR and calling it isn’t really a good idea.
But just to see how a finalizer works, you could call for garbage collection on your own.
If  that’s what you want to do, just call GC.Collect()
It just says, “Do garbage collection as soon as possible.”
You can SUGGEST to .NET that it’s t ime to col lect the garbage.
Eventually the garbage collector comes along, and trashes your object.
We can’t emphasize enough just how bad an idea it is to use GC.Collect() in a program that’s not just a toy, because it can really confuse the CLR’s garbage collector.
It’s an excellent tool for learning about garbage collection and finalizers, so we’ll build a toy to play with it.
Dispose() runs whenever an object that is created in a using statement is set to null or loses all of  its references.
If  you don’t use a using statement, then just setting the reference to null won’t cause Dispose() to be called—you’ll need to call it directly.
An object’s finalizer runs at garbage collection for that particular object.
Let’s create a couple of  objects, and see how these two methods differ:
Dispose() works with using , f inalizers work with garbage col lect ion.
Create a Clone class and make sure it implements IDisposable The class should have one int automatic property called Id.
It has a constructor, a Dispose() method, and a finalizer:
Create a Form with three buttons Create one instance of  Clone inside the Click handler for the first button with a using statement.
Here’s the first part of  the code for the button:
As soon as the using block is done and the Clone object’s Dispose() method is called, there’s no more reference to it and it gets marked for garbage collection.
The method creates a new Clone and then immediately kills it by taking away its reference.
Since the class implements IDisposable, it has to have a Dispose() method.
Since we declared clone1 with a using statement, its Dispose() method gets run.
And like you saw earlier, Dispose() works without using as well.
When you write a Dispose() method, it shouldn’t have any side effects that cause problems if it’s run many times.
Just a reminder: popping up a MessageBox in a finalizer can mess with the “guts” of the CLR.
Don’t do it outside of a toy program for learning about garbage collection.
Since this doesn’t use a using statement, Dispose() won’t ever get run, but the finalizer will.
Run the program and play with Dispose() and finalizers Click on the first button and check out the message box: Dispose() runs first.
In most cases, you won’t see the garbage collection message box, because your object is set to null, but garbage collection hasn’t run yet.
Now click on the second button…nothing happens, right? That’s because we didn’t use a using statement, so there’s no Dispose() method.
And until the garbage collector runs, you won’t see the message boxes from the finalizer.
Even though the Clone1 object has been set to null and its Dispose method has run, it’s still on the heap waiting for garbage collection.
When GC.Collect() is run, both objects run their finalizers and disappear.
Implement the other two buttons Create another instance of  Clone in the second button’s Click handler, and set it to null manually:
For the third button, add a call to GC.Collect() to suggest garbage collection occur.
Now Clone2 is on the heap, too, but without any references to it.
And once in a while, the garbage collector runs even though you didn’t ask it to using GC.Collect()
Remember, normally it’s not a great idea to do this.
But it’s fine here, because it’s a good way to learn about garbage collection.
Finalizers can’t depend on stabili t y When you write a finalizer, you can’t depend on it running at any one time.
And when it does, you have no way of  knowing what order the objects will be collected in.
So what does that mean, in practical terms? Well, think about what happens if  you’ve got two objects that have references to each other.
So what that means is that you can’t depend on references in your object’s finalizer.
Which means that it’s a really bad idea to try to do something inside a finalizer that depends on references being valid.
Serialization is a really good example of  something that you shouldn’t do inside a finalizer.
If  your object’s got a bunch of  references to other objects, serialization depends on all of  those objects still being in memory… and all of  the objects they reference, and the ones those objects reference, and so on.
So if  you try to serialize when garbage collection is happening, you could end up missing vital parts of  your program because some objects might’ve been collected before the finalizer ran.
Luckily, C# gives us a really good solution to this: IDisposable.
Anything that could modify your core data or that depends on other objects being in memory needs to happen as part of  a Dispose() method, not a finalizer.
Some people like to think of  a finalizers as a kind of fail-safe for the Dispose() method.
And that makes sense—you saw with your Clone object that just because you implement IDisposable, that doesn’t mean the object’s Dispose() method will get called.
But you need to be careful—if  your Dispose() method depends on other objects that are on the heap, then calling Dispose() from your finalizer can cause trouble.
The best way around this is to make sure you always use a using statement any time you’re creating an IDisposable object.
Let’s say you’ve got two objects that have references to each other…
Once you understand the difference between Dispose() and a finalizer, it’s pretty easy to write objects that serialize themselves out automatically when they’re disposed of.
Make the Clone class (from page 656) serializable Just add the Serializeable attribute on top of  the class so that we can save the file.
Modify Clone’s Dispose() method to Serialize itself out to a file Let’s use a BinaryFormatter to write Clone out to a file in Dispose():
Look inside the file and you’ll see the binary representation of  the object.
You’ll need a few more using directives to access the I/O classes we’ll use.
The Clone will create the C:\Temp directory and serialize itself out to a file called Clone.dat.
We hardcoded the filenamewe included them as string literals in the code.
That’s fine for a small toy program like this, but it’s not problemfree.
Can you think of problems this might cause, and how you could avoid them?
And is this Dispose() method really side-effect free? What happens if it’s called more than once? These are all things you need to think about when you implement IDisposable.
Tonight’s talk: The Dispose() method and a finalizer spar over who’s more valuable.
To be honest, I’m a little surprised I was invited here.
I thought the programming world had come to a consensus.
You can’t even serialize yourself  out, alter core data, anything.
OK, you’re right, programmers need to know they’re going to need me and either call me directly or use a using statement to call me.
But they always know when I’m gonna run, and they can use me to do whatever they need to do to clean up after their object.
And you? Nobody knows exactly when you’ll run or what the state of  the application will be when you finally do decide to show up.
So there’s basically nothing you can do that I can’t do.
But you think you’re a big shot because you run when garbage collection happens.
Well, I didn’t want to get into this, but since we’re already stooping this low…at least I don’t need an interface to get started.
And what happens when someone forgets to use a using statement when they instantiate their object? Then you’re nowhere to be found.
OK, but if  you need to do something at the very last moment when an object is garbage-collected, there’s no way to do it without me.
I can free up network resources and Windows handles and streams and anything else that might cause a problem for the rest of  the program if  you don’t clean it up.
I can make sure that your objects deal with being trashed more gracefully, and that’s nothing to sneeze at.
I’ll take that over your flash and attitude any day, pal.
Handles are what your programs use when they go around .NET and the CLR and interact directly with Windows.
Since .NET doesn’t know about them, it can’t clean them up for you.
Q: How soon after I call GC.Collect() will .NET start garbage collection?
Q: If I absolutely need something to run, I put it in a finalizer, right?
What’s wrong? Why are the Captain’s powers behaving differently? Is this the end?
One of  the types in .NET we haven’t talked about much is the struct.
And you can even pass them into a method that takes an object type parameter:
They can have methods and fields, but they can’t have finalizers.
They also can’t inherit from other classes or structs, or have classes or structs inherit from them.
You can mimic a standalone object with a struct, but structs don’t stand in very well for complex inheritance hierarchies.
The power of objects lies in their ability to mimic real‑world behavior, through inheritance and polymorphism.
Structs are best used for storing data, but the lack of inheritance and references can be a serious limitation.
That’s why every struct has a ToString() method – it gets it from Object.
But that’s all the inheriting that structs are allowed to do.
That’s why you use classes a lot more than structs.
But the thing that sets structs apart from objects more than almost anything else is that you copy them by value, not by reference.
You already have a sense of  how some types are different than others.
On one hand you’ve got value types like int, bool, and decimal.
On the other hand, you’ve got objects like List, Stream, and Exception.
And they don’t quite work exactly the same way, do they?
When you use the equals sign to set one value type variable to another, it makes a copy of  the value, and afterward the two variables aren’t connected to each other.
On the other hand, when you use the equals sign with references, what you’re doing is pointing both references at the same object.
Variable declaration and assignment works the same with value types or object types:
Differences creep in when you start to assign values, though.
This line sets the differentList reference to point to the same object as the temperatures reference.
This line copies the value that’s stored in the fifteenMore variable into the howMany variable and adds 15 to it.C hanging the.
The output here shows that fifteenMore and howMany are not connected:
So changing the List means both references see the update…since they both point to a single List object.
The output here demonstrates that differentList and temperatures are actually pointing to the same object:
Remember when we said that methods and statements ALWAYS live in classes? Well, it turns out that’s not 100% accurate -- they can also live in structs.
Structs are value types; objects are reference types When you create a struct, you’re creating a value type.
What that means is when you use equals to set one struct variable equal to another, you’re creating a fresh copy of  the struct in the new variable.
So even though a struct looks like an object, it doesn’t act like one.
Create a struct called Dog Here’s simple struct to keep track of  a dog.
Create a class called Canine Make an exact copy of  the Dog struct, except replace struct with class and then replace Dog with Canine.
Now you’ll have a Canine class that you can play with, which is almost exactly equivalent to the Dog struct.
Add a button that makes some copies of Dogs and Canines Here’s the code for the Main() method:
Before you press that button… Write down what you think will be written to the console when you run this code:
Here’s what happened… The bob and spot references both point to the same object, so both changed the same fields and accessed the same Speak() method.
When you created betty, you made a fresh copy of  the data in jake.
A new Canine object was created and the spot reference points to it.
The new reference variable bob was created, but no new object was added to the heap—the bob variable points to the same object as spot.
Since spot and bob both point to the same object, spot.Speak() and bob.Speak() both call the same method, and both of them produce the same output with “Spike” and “beagle”
When you set one struct equal to another, you’re creating a fresh COPY of the data inside the struct.
When you create a new struct, it looks really similar to creating an object—you’ve got a variable that you can use to access its fields and methods.
When you added the betty variable, you created a whole new value.
Since you created a fresh copy of the data, jake was unaffected when you changed betty’s fields.
What did you think would get written to the console?
It’s easy to understand how a struct differs from an object—you can make a fresh copy of  a struct just using equals, which you can’t do with an object.
The .NET CLR divides your data into two places in memory.
It also keeps another part of  memory called the stack to store all of  the local variables you declare in your methods, and the parameters that you pass into those methods.
You can think of  the stack as a bunch of  slots that you can stick values in.
When a method gets called, the CLR adds more slots to the top of  the stack.
When you call a method, the CLR puts its local variables on the top of the stack.
Here’s what the stack looks like after these two lines of code run.
When you create a new struct—or any other value type variable—a new “slot” gets added onto the stack.
That slot is a copy of the value in your type.
Remember, when your program’s running, the CLR is actively managing memory, dealing with the heap, and collecting garbage.
Even though you can assign a struct to an object variable, structs and objects are different.
Why do I even need to know this stuff? I can’t control any of it directly, right?
You definitely want to understand how a struct you copy by value is different from an object you copy by reference.
There are times when you need to be able to write a method that can take either a value type or a reference type—perhaps a method that can work with either a Dog struct or a Canine object.
If  you find yourself  in that situation, you can use the object keyword:
If  you send this method a struct, the struct gets boxed into a special object “wrapper” that allows it to live on the heap.
While the wrapper’s on the heap, you can’t do much with the struct.
You have to “unwrap” the struct to work with it.
Luckily, all of  this happens automatically when you set an object equal to a value type, or pass a value type into a method that expects an object.
Here’s what the stack and heap look like after you create an object variable and set it equal to a Dog struct.
If  you want to unbox the object, all you need to do is cast it to the right type, and it gets unboxed automatically.
You can’t use the as keyword with value types, so you’ll need to cast to Dog.
You can also use the “is” keyword to see if an object is a struct, or any other value type, that’s been boxed and put on the heap.
These are structs, so unless they’re boxed, they don’t live on the heap.
After a struct is boxed, there are two copies of the data: on the stack, and the copy boxed on the heap.
After this line runs, you’ve got a third copy of the data in a new struct called happy, which gets its own slot on the stack.
When a method is called, it looks for its arguments on the stack The stack plays an important part in how the CLR runs your programs.
One thing we take for granted is the fact that you can write a method that calls another method, which in turn calls another method.
In fact, a method can call itself  (which is called recursion)
The stack is what gives your programs the ability to do that.
Here are a couple of  methods from a dog simulator program.
The FeedDog() method takes two parameters, a Canine reference and a Bowl reference.
So when it’s called, the two arguments passed to it are on the stack.
FeedDog() needs to pass two arguments to the Eat() method, so they’re pushed onto the stack as well.
Remember the terminology here: a parameter is what you call the part of the method declaration that specifies the values it needs; an argument is the actual value or reference that you pass into a method when you call it.
As the method calls pile up and the program goes deeper into methods that call methods that call other methods, the stack gets bigger and bigger.
Speaking of  parameters and arguments, there are a few more ways that you can get values in and out of  your programs, and they all involve adding modifiers to your method declarations.
One of  the most common ways of  doing this is by using the out modifier to specify an output parameter.
Create a new Windows Forms application and add this empty method declaration to the form.
Use out parameters to make a method return more than one value.
Any time you use an out parameter, you always need to set it before the method returns—just like you always need to use a return statement if your method is declared with a return value.
Now that you’ve set the two out parameters, it compiles.
Uh oh! There are more build errors: Argument 1 must be passed with the out keyword.
Every time you call a method with an out parameter, you need to use the out keyword when you pass the argument to it.
A method can return more than one value by using out parameters.
This method needs to set all of its out parameters before it returns, otherwise it won’t compile.
Did you notice how you didn’t need to initialize b and c? You don’t need to initialize a variable before you use it as an argument to an out parameter.
One thing you’ve seen over and over again is that every time you pass an int, double, struct, or any other value type into a method, you’re passing a copy of  that value to that method.
There’s a name for that: pass by value, which means that the entire value of  the argument is copied.
But there’s another way to pass arguments into methods, and it’s called pass by reference.
You can use the ref keyword to allow a method to work directly with the argument that’s passed to it.
Just like the out modifier, you need to use ref when you declare the method and also when you call it.
It doesn’t matter if  it’s a value type or a reference type, either—any variable that you pass to a method’s ref parameter will be directly altered by that method.
You can see how it works—add this method to your program:
Built-in value types’ TryParse() method uses out parameters There’s a great example of out parameters built right into some of the built-in value types.
There are a lot of times that you’ll want to convert a string like “35.67” into a double.
Sometimes that’s exactly what you want, but other times you want to check if a string can be parsed into a value.
Also, remember back in Chapter 9 when we used a switch statement to convert “Spades” into Suits.Spades? Well, there are static methods Enum.Parse() and Enum.TryParse() that do the same thing, except for enums!
And add a button with this event handler to call the method:
But since they were passed by reference, the method was actually updating the q and b variables all along, and not just a copy of  them.
So when the method exits, the q and b variables are updated with the modified value.
Run the program and debug through it, adding a watch for the q and b variables to see how this works.
Under the hood, an out argument is just like a ref argument, except that it doesn’t need to be assigned before going into the method, and must be assigned before the method returns.
When this method sets value and button parameters, what it’s really doing is changing the values of the q and b variables in the button2_Click() method that called it.
A lot of  times, your methods will be called with the same arguments over and over again, but the method still needs the parameter because sometimes it’s different.
It would be useful if  you could set a default value, so you only needed to specify the argument when calling the method if  it was different.
You can specify an optional parameter in a method declaration by using an equals sign followed by the default value for that parameter.
You can have as many optional parameters as you want, but all of  the optional parameters have to come after the required parameters.
Here’s an example of  a method that uses optional parameters to check if  someone has a fever:
Bob's temperature is always a little low, so set tooLow to 95.5
Calling CheckTemperature() with one argument uses default values for both tooHigh and tooLow.
If  you call it with two arguments, it will use the second argument for the value of  tooHigh, but still use the default value for tooLow.
You can specify all three arguments to pass values for all three parameters.
If  you want to use some (but not all) of  the default values, you can use named arguments to pass values for just those parameters that you want to pass.
All you need to do is give the name of  each parameter followed by a colon and its values.
If  you use more than one named argument, make sure you separate them with commas, just like any other argument.
Add the CheckTemperature() method to your form, and then add a button with the following event handler.
Debug through it to make sure you understand exactly how this works:
Use optional parameters and named arguments when you want your methods to have default values.
Remember how you set up your table to allow nulls for each of  its columns? That way, if  someone left out a value or wrote something illegible, the database could use null to represent that it doesn’t have a value.
But for structs (and ints, booleans, and other value types), you can’t set them to null.
Let’s say your program needs to work with a date and time value.
But what if  that variable doesn’t always have a value? That’s where nullable types comes in really handy.
All you need to do is add a question mark (?) to the end of  any value type, and it becomes a nullable type that you can set to null.
Use nullable types when you need nonexistent values Did it seem odd that even the Client column was set to allow nulls? Someone’s either a client or not, right? But there was no guarantee that every card has the Client blank filled in, and the database needed a way to represent that we might not know if someone’s a client or not.
The question mark T? is an alias for Nullable<T> When you add a question mark to any value type (like int? or decimal?), the compiler translates that.
This is an example of an alias, and it’s not the first one y ou’ve.
You’ll see that it translates to a struct called System.In t32:
Every nullable type has a property called Value that gets or sets the value.
A DateTime? will have a Value of  type DateTime, an int? will have one of  type int, etc.
They’ll also have a property called HasValue that returns true if  it’s not null.
You can always convert a value type to a nullable type:
But you need to cast the nullable type in order to assign it back to a value type:
Nullable<T> is a struct that lets you store a value type OR a null value.
Here are some of the methods and properties on Nullable<DateTime>
You think you know how people will use a program you’re writing, but then someone clicks buttons in an unexpected order, or enters 256 spaces in a text box, or uses the Windows Task Manager to quit your program halfway through writing data to a file, and suddenly it’s popping up all manner of  errors.
Remember in chapter 10 when we talked about how a program that can gracefully handle badly formatted, unexpected, or just plain bizarre input is called robust? Well, when you’re processing raw input from your users, nullable types can be very useful in making your programs more robust.
Now see for yourselfcreate a new console application and add this RobustGuy class to it:
When you run the program, see what happens when you enter different values for dates.
When you enter a date it can’t parse, the RobustGuy’s Birthday property will have no value.
Since the Value property is a DateTime, you’ll see all the usual DateTime members.
Use the ToLongDateString() method to convert it to a human-readable string.
If the user entered garbage, the Nullable types won’t have values, so their HasValue() methods will return false.
Use the DateTime and int TryParse() methods to attempt to convert the user input into values.
Try experimenting with the other DateTime methods that start with “To” to see how they affect your program’s output.
When the user hits enter, it returns the input as a string.
Pool Puzzle Your job is to take snippets from the.
You may use the same snippet more than once, and you won’t need to use all the snippets.
Your goal is to make the code write this output to the.
Note: Each thing from the pool can be used more than once.
Q: I get how you get a fresh copy of a struct when you set one struct variable equal to another one.
Q: If Point is a struct, does that mean there are other structs that I’ve been working with all along?
Q: How do I know whether to use a struct or a class?
A struct can be very valuable when you want to add good encapsulation to your class, because a read‑only property that returns a struct always makes a fresh copy of it.
This method is supposed to kill a Clone object, but it doesn’t work.
With all this talk of  boxing, you should have a pretty good idea of  what was going on with the less-powerful, moretired Captain Amazing.
In fact, it wasn’t Captain Amazing at all, but a boxed struct:
Structs can’t inherit from classes or implement interfaces No wonder the Captain’s superpowers seemed a little weak! He didn’t get any inherited behavior.
You can’t create a fresh copy of an object When you set one object variable equal to another, you’re copying a reference to the same variable.
Structs are copied by value This is one of  the most useful things about them.
You can use the “as” keyword with an object Objects allow for polymorphism by allowing an object to function as any of the objects it inherits from.
That’s one big advantage of structs (and other value types)—you can easily make copies of them.
Sometimes you need to extend a class that you can’t inherit from, like a sealed class (a lot of  the .NET classes are sealed, so you can’t inherit from them)
And C# gives you a powerful tool for that:  extension methods.
When you add a class with extension methods to your project, it adds new methods that appear on classes that already exist.
All you have to do is create a static class, and add a static method that accepts an instance of  the class as its first parameter using the this keyword.
So let’s say you’ve got a sealed OrdinaryHuman class (remember, that means you can’t extend it):
Extension methods are always static methods, and they have to live in static classes.
Since we want to extend the OrdinaryHuman class, we make the first parameter this OrdinaryHuman.
The OrdinaryHuman class is sealed, so it can’t be subclassed.
But what if we want to add a method to it?
When the program creates an instance of the OrdinaryHuman class, it can access the BreakWalls() method directly—as long as it has access to the SuperSoldierSerum class.
All this method does is set its own parameter to null, but that parameter’s just a reference to a Clone.
It’s like sticking a label on an object and peeling it off again.
So the clone parameter is just on the stack, so setting it to null doesn’t do anything to the heap.
As soon as the SuperSoldierSerum class is added to the project, OrdinaryHuman gets a BreakWalls method.
You use an extension method by specifying the first parameter using the “this” keyword.
This method is supposed to kill a Clone object, but it doesn’t work.
Remember the sealed access modifier from Chapter 7? It’s how you set up a class that can’t be extended.
Go ahead, try it out! Create a new console application and add the two classes and the Main() method to it.
Debug into the BreakWalls() method and see what’s going on.
Q: Tell me again why I wouldn’t add the new methods I need directly to my class code, instead of using extensions?
Q:Why use extension methods at all? Why not just extend the class with inheritance?
Oh, I get it! So you’d use extension methods to add new behavior to one of the built-in .NET Framework classes, right?
Exactly! There are some classes that you can’t inherit from.
Pop open any project, add a class, and try typing this:
Try to compile your code—the IDE will give you an error.
The reason is that some .NET classes are sealed, which means that you can’t inherit from them.
You can do this with your own classes, too! Just add the sealed keyword to your class after the public access modifier, and no other class will be allowed to inherit from it.
Extension methods give you a way to extend it, even if  you can’t inherit from it.
But that’s not all you can do with extension methods.
In addition to extending classes, you can also extend interfaces.
All you have to do is use an interface name in place of the class, after the this keyword in the extension method’s first parameter.
When you do, the extension method is added to every class that implements that interface.
One more point to remember about extension methods: you don’t gain access to any of the class’s internals by doing an extension method, so it’s still acting as an outsider!
You don’t often get to change the behavior of  a language’s most fundamental types, like strings.
Put all of your extension methods in a separate namespace It’s a good idea to keep all of  your extensions in a different namespace than the rest of your code.
That way, you won’t have trouble finding them for use in other programs.
Set up a static class for your method to live in, too.
Create the static extension method, and define its first parameter as this and then the type you’re extending The two main things you need to know when you declare an extension method are that the method needs to be static and it takes the class it’s extending as its first parameter.
Create a form and add a string Now go to your form code and add using MyExtensions; to the top, and add a button to the form so you can try out your new extension method inside its event handler.
Now, when you use a string, you get the extension methods for free.
You can see this for yourself  by typing the name of  a string variable and a period:
This checks the string for a certain value…something definitely not in the default string class.
The class your extension method is defined in must be static.
As soon as you type the dot, the IDE pops up a helper window with all of string’s methods… including your extension method.
This toy example just shows you the syntax of extension methods.
To get a real sense of how useful they are, just wait until the next chapter.
It’s all about LINQ, which is implemented entirely with extension methods.
You want this class to be accessed by code in the other namespace, so make sure you mark it public!
Extension Magnets Your job was to arrange the magnets to produce this output:
The Green method extends a bool—it returns the string “be” if the bool is true, and “gets” if it’s false.
The entry point method uses the extensions that you added in the Margin class.
The Margin class extends string by adding a method called SendIt() that just writes the string to the console, and it extends int by adding a method called ToPrice() that returns “a buck” if the int’s equal to 1, or “more bucks” if it’s not.
Here’s where the Margin class extends bool by adding a Green() method to it.
If the bool is true, Green returns “be”, otherwise it returns “gets”
Captain Amazing deserializes himself, makes stunning comebackIn a stunning turn of  events, Captain Amazing has returned to Objectville.
Last month, Captain Amazing’s coffin was found empty, and only a strange note left where his body should have been.
Analysis of  the note revealed Captain Amazing’s object DNA—all his last fields and values, captured faithfully in binary format.
The Captain is back, deserialized from his own brilliant note.
When asked how he conceived of  such a plan, the Captain merely shrugged and mumbled, “Chapter 9.” Sources close to the Captain refused to comment on the meaning of  his cryptic reply, but did admit that prior to his failed assault on Swindler, the Captain had spent a lot of  time reading books, studying Dispose methods and persistence.
Output when you create a new Faucet object: back in 20 minutes.
If it were a class, then wine would point to the same object as book.Garden, which would cause this to overwrite the “back in” string.
If you pass a string to Lamp, it sets the Stairs field to whatever is in that string.
Remember, the as keyword only works with classes, not structs.
Since the Lamp() method takes an object parameter, boxing automatically happens when it’s passed an int or a string.
It’s a data-driven world…you better know how to live in it.
Gone are the days when you could program for days, even weeks, without dealing with.
So if you take the first word from this article, and the second word in that list, and add it to the fifth word over here…you get secret messages from the government!
All of Objectville Paper’s customers who are Starbuzz regulars get a free mug.
Just tell us who the mugs need to go to and what their favorite drinks are, OK?
Starbuzz has a frequent-customer program where they keep track of  which customers buy which drink and how often they buy it.
Objectville Paper wants to figure out which of  their customers are also Starbuzz regulars and send them a free mug and a coupon for their favorite coffee drink…and it’s up to you to combine the data and generate the list of  customers to send mugs and coupons to.
Starbuzz keeps all their data in classes, grouped together in a big List.
But the Objectville data is in a database (from way back in Chapter 1)
We want to find any Starbuzz customers who spent more than $90, match them to the Objectville Paper contact list, and make a final list of  people: we want each person’s name, the company they work for, and their favorite Starbuzz drink.
How would you combine the data from Starbuzz and the data from Objectville Paper Company to get a complete contact list?
You’ve already got the customer data You built the Objectville Paper Company contact list back in Chapter 1—it’s got part of  the data you need.
All of the Objectville Paper Company customer data is in a database.
You need to get the list of Starbuzz data, and find the customers that match Objectville customers.
You took advantage of  the power of  LINQ to write simple queries to pull data out of  a collection.
As long as a collection implements the IEnumerable<T> interface, you can use LINQ queries with it.
But LINQ also lets you work with more than just collections.
You can use the same queries to pull data from a database, or even an XML document.
So once we get collections under control, we can use LINQ on the Objectville Paper Company database.
Your code needs a using System.Linq; line at the top of  your file, but that’s it.
Even better, the IDE automatically puts a reference to LINQ in the header of  the class files it creates.
Here was the query we used in the bee simulator to group and order bees by their state.
We need a similar query to pull data from the Starbuzz customer data, which is also in a collection.
The nice thing about LINQ is that the same query works on.
We’ll see exactly how it works in a few pages.
Create an int array called linqtest, put some numbers in the array, and then type this line of  code (don’t worry, you’ll learn what it does in a minute):
Now comment out the using System.Linq; line up in the header of  the file you’ve created.
When you try to rebuild the solution, you’ll see that this line doesn’t compile anymore.
The methods you’re calling when you use LINQ are just extension methods that are being used to extend the array.
You’ll see that the IEnumerable interface defines a GetEnumerator() method:
This method requires your object to define a way to move through the elements in it, one element at a time.
If  you can move through a list of  data, item by item, then you can implement IEnumerable<T>, and LINQ can query the collection.
Now you can see why extension methods were so important in Chapter 14…they let .NET (and you) add all kinds of cool behavior to existing types.
It selects all the numbers in an int array that are under 37 and puts those numbers in ascending order.
It does that using four clauses that tell it what object to query, what criteria to use to determine which of  its members to select, how to sort the results, and how the results should be returned.
This assigns the letter “v” to stand in for each of the array values in the query.
In the example above,  when this line is compiled: var result = from v in values.
The compiler replaces “var” with this: IEnumerable<int> And while we’re on the subject of interfaces for collections, remember how we talked abou.
IEnumerable<T> is the interface that supports iteration? A lot of these great LINQ quer ies are.
If you’ve used SQL before, it may seem weird to put the select at the end, but that’s how things work in LINQ.
Now you can iterate through the sequence that LINQ returned to print the output.
This LINQ query has four clauses: the from clause, a where clause, an orderby clause, and the select clause.
Plus, you can read more about it in Leftover #6 in the Appendix.
Jimmy just sold his start-up company to a big investor, and wants to take some of  his profits and buy the most expensive issues of  Captain Amazing that he can find.
How can LINQ help him scour his data and figure out which comics are the most expensive?
After a few hours of  searching,  Jimmy was able to build a Dictionary<> that mapped issue numbers to values.
What do you think Jimmy has to put in his query to find the most expensive issues?
Jimmy downloaded a list of  Captain Amazing issues from a Captain Amazing fan page.
He put them in a List<T> of  Comic objects that have two fields, Name and Issue.
Jimmy used object initializers and a collection initializer to build his catalog:
There’s no special reason this method is static, other than to make it easy to call from a console application’s entry point method.
Remember this syntax for collection initializers for dictionaries from Chapter 8?
Take a minute and flip to Leftover #6 to learn about a really useful bit of  syntax that could come in handy here.
The LINQ query pulls Comic objects out of the comics list, using the data in the values dictionary to decide which comics to select.
The first clause in the query is the from clause.
This one tells LINQ to query the comics collection, and that the name comic will be used in the query to specify how to treat each individual piece of data in the collection.
The name comic was defined in the from clause specifically so it could be used in the where and orderby clauses.
The query returned its results into an IEnumerable<T> called mostExpensive.
The select clause determines what goes into the results—since it selected comic, the query returned Comic objects.
Anatomy of a query Jimmy could analyze his comic book data with one LINQ query.
The where clause tells LINQ which items from the collection should be included in the results.
But that clause doesn’t have to be just a simple comparison.
And the orderby clause works the same way—we can tell LINQ to order the comics by their value.
You can choose any name you want when you use a from clause.
I know SQL already—isn’t writing a LINQ query just like writing SQL?
If  you’ve done a lot of  work with SQL, it may be tempting to dismiss all this LINQ stuff  as intuitive and obvious—and you wouldn’t be alone, because a lot of  developers make that mistake.
It’s true that LINQ uses the select, from, where, descending, and join keywords, which are borrowed from SQL.
But LINQ is very different from SQL, and if  you try to think about LINQ the way you think about SQL you’ll end up with code that doesn’t do what you expect.
One big difference between the two is that SQL operates on tables, which are very different from enumerable objects.
One really important difference is that SQL tables don’t have an order, but enumerable objects do.
When you execute a SQL select against a table, you can be sure that the table is not going to be updated.
If  you want to get to the nuts and bolts: SQL queries are set operations, which means they don’t examine the rows in the table in any predictable order.
A collection, on the other hand, can store anything—values, structs, objects, etc.—and collections have a specific order.
A table’s rows aren’t in any particular order until you make a SQL query that orders them; items inside a list, on the other hand, are in order.
And LINQ lets you perform any operation that’s supported by whatever happens to be in the collection—it can even call methods on the objects in the collection.
And LINQ loops through the collection, which means that it does its operations in a specific order.
That may not seem all that important, but if  you’re used to dealing with SQL, it means your LINQ queries will surprise you if  you expect them to act like SQL.
Don’t worry if you’ve never used SQL—you don’t need to know anything about it to work with LINQ.
There are a lot of other differences between LINQ and SQL too, but you don’t need to delve into them just yet in order to start working with LINQ right now! Just approach it with an open mind, and don’t expect it to work the way SQL works.
And once you’ve generated a set of  result sequences, LINQ gives you a bunch of  methods that work with them.
Top to bottom, LINQ gives you the tools you need to manage your data.
Modify every item returned from the query This code will add a string onto the end of  each string in an array.
It doesn’t change the array itself—it creates a new sequence of  modified strings.
This adds the string “ on rye” to every item in the results from the query.
Notice that all the items returned have “ on rye” added to the end.
Output: ham and cheese on rye salami with mayo on rye turkey and swiss on rye chicken cutlet on rye.
This change is made to the items in the results of your query…but not to the items in the original collection or database.Perform calculations on collections.
Remember, we said LINQ provides extension methods for your collections (and database access objects, and anything else that implements IEnumerable<T>)
And some of  those are pretty handy on their own, without actually requiring a query:
None of these methods are part of the .NET collections classes…they’re all defined by LINQ.
These are all extension methods for IEnumerable<T> in the System.Linq namespace using a static class called Enumerable.
But don’t take our word for it! Click on any of them and use “Go to Definition” to see for yourself.
Store all or part of your results in a new sequence Sometimes you’ll want to keep your results from a LINQ query around.
You can use the ToList() command to do just that:
ToList() converts a LINQ var into a List<T> object, so you can keep results of a query around.
There’s also ToArray() and ToDictionary() methods, which do just what you’d expect.
This time, we’re sorting a list of numbers in descending order, from highest to lowest.
You can even take just a subset of  the results, using the Take() method:
Take() pulls out the supplied number of items, from the first set of the results from a LINQ query.
You can put these into another var, and then convert that into a list.
Q: That’s a lot of new keywords—from, where, orderby, select…it’s like a whole different language.
Why does it look so different from the rest of C#?
Check out Microsoft’s official “101 LINQ Samples” page There’s way more that LINQ can do.
Luckily, Microsoft gives you a great little reference to help you along.
It’s called “deferred evaluation”—the LINQ query doesn’t actually do any looping until a statement is executed that uses the results of the query.
That’s why ToList() is important: it tells LINQ to evaluate the query immediately.
A sequence is an ordered set of objects or values, which is what LINQ returns in an IEnumerable<T>
It’s always followed by the name of  a variable, followed by in and the name of  the input (from value in values)
It’s followed by the criteria that you’re using to sort them, and optionally descending to tell it to reverse the sort (orderby value descending)
Q: How does LINQ decide what goes into the results?
Here’s where we take the first three numbers in skunks and put them into a new sequence called bears.
This statement just subtracts 1 from each number in bears and puts them all into weasels.
Let’s take a closer look at that query and see how it works.
The query starts out just like the other queries you’ve seen—by pulling individual bee objects out of  the world.Bees collection, a List<Bee> object.
The next line in the query has a new keyword: group.
What that means is that rather than returning one single sequence, the query will return a sequence of  sequences.
Finally, we need to give LINQ a name for the group.
That’s what the next line is for: into beeGroup says that the name “beeGroup” refers to the new groups.
Key tells the query to put the sequence of  groups in order, sorting them by the group key.
Since we grouped the bees by their CurrentState, that’s what being used as a key.
Since the bees were grouped by their state, we call that state the “key”
A group’s key is the criteria it was grouped by.
Now we just have to use the select keyword to indicate what’s being returned by the query.
Since we’re returning groups, we select the group name: select beeGroup;
Note that this query returns groups of bees, not individual bees.
Combine Jimmy’s values into groups Jimmy buys a lot of  cheap comic books, some midrange comic books, and a few expensive ones, and he wants to know what his options are before he decides what comics to buy.
We’ll create a PriceRange enum that we’ll use as the key for the groups, and a method called EvaluatePrice() that’ll evaluate a price and return a PriceRange.
Now we can group the comics by their price categories The LINQ query returns a sequence of  sequences.
Each of  the sequences inside the results has a Key property, which matches the PriceRange that was returned by EvaluatePrice()
Look closely at the group by clause—we’re pulling pairs out of  the dictionary, and using the name pair for each of  them: pair.Key is the issue number, and pair.Value is the price from Greg’s List.
Adding group pair.Key tells LINQ to create groups of  issue numbers, and then bundles all of  those groups up based on the price category that’s returned by EvaluatePrice():
Every group needs a key—we’ll use an enum for that The group’s key is the thing that all of  its members have in common.
The key can be anything: a string, a number, even an object reference.
We’ll be looking at the prices that Jimmy got from Greg’s List.
Each group that the query returns will be a sequence of  issue numbers, and the group’s key will be a PriceRange enum.
The EvaluatePrice() method takes a price as a parameter and returns a PriceRange:
The query figures out which group a particular comic belongs to by sending its price to EvaluatePrice()
That returns a PriceRange enum, which it uses as the group’s key.
Each of the groups is a sequence, so we added an inner foreach loop to pull each of the prices out of the group.
Pool Puzzle Your job is to take snippets from the.
You can use the same snippet more than once, and you won’t need to use all the snippets.
Your goal is to make the code produce this output:
Note: Each snippet from the pool can be used more than once!
Output:    Horses enjoy eating carrots, but they love eating apples.
This first LINQ query divides the Line objects in the lines[] array into groups, grouped by their Value, in ascending order of the Value key.
Did you figure out that the two phrases “Horses enjoy eating carrots, but” and “they love eating apples” are in descending alphabetical order?
This loop does a LINQ query on the first Line object in the first group and the second Line object in the second group.
Use join to combine t wo collect ions into one query.
Jimmy’s got a whole collection of  comics he’s purchased, and he wants to compare them with the prices he found on Greg’s List to see if  the prices he’s been paying are better or worse.
He’s been tracking his purchases using a Purchase class with two automatic properties, Issue and Price.
And he’s got a List<Purchase> called purchases that’s got all the comics he’s bought.
But now he needs to match up the purchases he’s made with the prices he found on Greg’s List.
It does it by comparing items in the first collection with their matching items in the second collection.
But instead of  following it up with the criteria it’ll use to determine what goes into the results, you add: join name in collection.
The join clause tells LINQ to loop through both collections to match up pairs of  one member from each collection.
It assigns name to the member it’ll pull out of  the joined collection in each iteration.
You’ll continue the LINQ query with where and orderby clauses as usual.
You could finish it with a normal select clause, but you usually want to return results that pull some data from one collection and other data from the other.
That’s where you use select new to create a custom set of  results using an anonymous type.
Next you’ll add the on clause, which tells LINQ how to match the two collections together.
You’ll follow it with the name of  the member of the first collection you’re matching, followed by equals and the name of the member of  the second collection to match it to.
The select new is followed by curly brackets that contain the data to return in the results.
Jimmy’s joining his comics to purchases, a list of comics he’s bought.
Jimmy’s got his data in a collection of Purchase objects called purchases.
Flip to Leftover #8 in the Appendix to learn more about anonymous types!
Now he can do the join! You’ve seen all the parts of  this query already…now here they are, put together in one piece.
Jimmy saved a bunch of dough It looks like Jimmy drives a hard bargain.
He created a list of Purchase classes that contained his purchases, and compared them with the prices he found on Greg’s List.
Jimmy already had his first collection—he just used his BuildCatalog() method from before.
So all he had to do was write a FindPurchases() method to build his list of  Purchase classes.
Jimmy’s real happy that he knows LINQ, because it let him see just how hard a bargain he can drive!
When Jimmy used a join clause, LINQ compared every item in the comics collection with each item in purchases to see which ones have comic.Issue equal to purchase.Issue.
The select clause creates a result set with Name and Issue from the comic member, and Price from the purchase member.
OK, so now I know Jimmy played with his comic books using LINQ queries to query his collections…but what about the Starbuzz promotion problem? I still don’t see how.
You’ve already seen in Chapter 1 how easy .NET makes it to work with a database.
The IDE gives you a really convenient way to connect with databases, add tables, and even link data in those tables to your forms.
Now, you can take that same database you already connected to and query it with LINQ.
Not only that, LINQ lets you combine your data from your database with data from your objects seamlessly.
In fact, you can use the same exact query syntax…all you need is to get access to your database so you can run a LINQ query against it.
We can use LINQ to compare and combine data from more than one source and create a sequence of results.
Even though LINQ to SQL is very different under the hood, when you write your code it looks really similar to other LINQ queries.
Connect LINQ to a SQL database LINQ operates on objects that implement the IEnumerable<T> interface, right? So it should make sense that you access your SQL database using an object that implements IEnumerable.
And C# makes it easy to add that object to your project.
Add the Objectville contact database to a new console application project Back in Chapter 1, you created a SQL Server Compact database of  contacts for the Objectville Paper Company and saved it in a file called ContactDB.sdf.
Start a new Windows Application project, right-click on your project in the Solution Explorer, select “Add Existing Item”, and add the database.
Make sure you select “Data Files” from the file type filter drop-down, navigate to the file with the SQL database, and add it to your project.
The IDE will pop up the Data Source Configuration wizard, but you can cancel out of  it.
Use the SqlMetal.exe program to generate LINQ to SQL classes There’s one more step you need to do to connect the dots between your SQL database and your code, and you’ll do it using a program called SqlMetal.exe.
It’s a command-line tool that’s installed along with Visual Studio 2010 (it doesn’t matter which edition you install, it comes with all of  them)
Bring up a command prompt and run a command to add the Microsoft SDKs folder to your path.
If  you’re using a 64-bit version of  Windows, type this:
Next, change directory to your project folder (cd folder-name) and type this command:
Here’s what it should look like when your command is running:
After it’s done, your folder should contain three new files: ContactDB.dbml, ContactDB.
Use “Add Existing Item” to add ContactDB.dbml to your project (again, select “Data Files” from the file type filter drop-down)
When you add that file, the IDE automatically adds the others, too.
And if  for some strange reason the Visual Studio installer didn’t install it for you, that page has a link to the Microsoft SDK download page.
If it is, add “NETFX 4.0 Tools” to the end of the PATH= command.
Remember, LINQ queries are built to operate on objects that implement the IEnumerable<T> interface.
But a SQL Server Compact database isn’t an object at all! That’s where the LINQ to SQL classes come in.
They contain classes that know how to query the tables in your database, but also implement IEnumerable<T> with an enumerator that returns the data in that table.
The IDE has a great tool called the Object Relational Designer that shows you exactly what classes you generated with SqlMetal.exe.
Once ContactDB.dbml is added to your project, doubleclick on it to bring it up the Object Relational Designer.
You’re all set to write LINQ queries that pull data out of the database Add this code to the Main() method.
Notice how we used the select new keyword to create custom results that only contain the Name and Company.
The Object Relational Designer is showing you the People class, which is a data class that you generated with SqlMetal.exe.
It connects to the People table in your database and returns the data using the IEnumerable<T> interface so it can be queried using LINQ.
It’ll pull just the values from the Name and Company columns from the database.
Use its People property in a LINQ query to get data out of the People table.
Q: Hold on, that query will just give me a bunch of shirts.
What if I want to connect each player to his shirt size, and I don’t care about his number at all?
Q: Do I always have to add that .dbml file that was generated by SqlMetal.exe? I still don’t quite get what’s going on there.
You can use “select new” to construct custom LINQ query results that include only the items that you want in your result sequence.
Use a join query to connect Starbuzz and Object v il le Now you have all the tools that you need to combine the data from Starbuzz and Objectville Paper Company into one final result set.
Build the Starbuzz objects Here’s the list that contains the Starbuzz customer data.
We built this method so that it has some names that also appear in the Objectville contact list.
If you used different names, make sure you’ve got matching data here.
Add the SQL data to your project If  you haven’t already done it, create a new console application project and add the ContactDB SQL database to it.
Then use SqlMetal.exe to create the Object Relational Designer with the LINQ to SQL classes to the project, add it to the project, and write a simple test query just to make sure it’s all working.
The Starbuzz data comes as a collection of StarbuzzData objects.
It’s got a lot of data—you won’t need it all for the promotion, so you’ll have to select only the data you need in the LINQ query.
Starbuzz has plenty of great drinks, and each customer has his or her favorite.
GetStarbuzzData() uses a collection initializer and object initializers to set up the Starbuzz objects.
Again, you can leave the ()’s off of the collection and object Initializers.
Now join the SQL database to the Starbuzz collection Here’s the code for the query.
Check your results—make sure it works the way you expect it to.
We’ll need to do a join to combine the Starbuzz data with the customer data in the People table.
The People member in the DataContext is a collection that gives you access to the People table in the database.
Here’s where the select clause pulls the name and company from the database and the favorite drink from the Starbuzz data into one single result sequence.
This lab gives you a spec that describes a program for you to build, using the knowledge you’ve gained throughout this book.
This project is bigger than the ones you’ve seen so far.
So read the whole thing before you get started, and give yourself a little time.
And don’t worry if you get stuck—there’s nothing new in here, so you can move on in the book and come back to the lab later.
We’ve filled in a few design details for you, and we’ve made sure you’ve got all the pieces you need…and nothing else.
You can download an executable for this lab from the website…but we won’t give you the code for the answer.
The grandfather of v ideo games In this lab you’ll pay homage to one of  the most popular, revered, and replicated icons in video game history, a game that needs no further introduction.
As the player destroys the invaders, the score goes up.
The first ship is in play, and the other two are kept in reserve.
His spare ships are shown in the upper right-hand corner.
The multicolored stars in the background twinkle on and off, but don’t affect gameplay at all.
If one of the shots hits the ship, the player loses a life.
Once all lives are gone, or if the invaders reach the bottom of the screen, the game ends and a big “GAME OVER” is displayed in the middle of the screen.
The player moves the ship left and right, and fires shots at the invaders.
If a shot hits an invader, the invader is destroyed and the player’s score goes up.
The first wave moves slowly and fires a few shots at a time.
The next wave moves faster, and fires more shots more frequently.
If all 30 invaders in a wave are destroyed, the next wave attacks.
Your mission: defend the planet against wave af ter wave of invaders The invaders attack in waves, and each wave is a tight formation of  30 individual invaders.
The bottom invaders are shaped like stars and worth 10 points.
If  he loses all three lives or the invaders reach the bottom of  the screen, the game’s over.
The left arrow moves the ship toward the left-hand edge of the screen.
The right arrow key moves the ship to the right.
The game should keep track of which keys are currently being held down.
So pressing right and spacebar would cause the ship to move to the right and fire (if two shots aren’t already on the screen)
The spacebar shoots, but there can only be two player shots on the screen at once.
As soon as a shot hits something or disappears, another shot can be fired.
Otherwise, the shot disappears when it gets to the top of the screen.
There are five different types of invaders, but they all behave the same way.
They start at the top of the screen and move left until they reach the edge.
When they reach the right-hand boundary, they drop down and move left again.
If the invaders reach the bottom of the screen, the game’s over.
The first wave of invaders can fire two shots at once—the invaders will hold their fire if there are more than two shots on the screen.
The next wave fires three, the next fires four, etc.
The architecture of Invaders Invaders needs to keep track of  a wave of  30 invaders (including their location, type, and score value), the player’s ship, shots that the player and invaders fire at each other, and stars in the background.
As in the Quest lab, you’ll need a Game object to keep up with all this and coordinate between the form and the game objects.
It’s got timers to tell the game to go, it passes on key presses, and it animates the invaders and twinkling stars.
And it’s got a Paint event handler to draw the graphics, which just calls the Game object’s Draw() method.
It keeps track of how many lives the player has left and how many waves of invaders have attacked.
When the game’s over, it raises a GameOver event to tell the form to stop its timers.
All of the invaders on the screen are stored in a List.
When an invader is destroyed, it’s removed from the list so the game stops drawing it.
The object that represents the ship keeps track of its position and moves itself left and right, making sure it doesn’t move off the side of the screen.
The game keeps two lists of Shot objects: a list of shots the player fired at the invaders, and a list of shots the invaders fired back.
The Stars object keeps a List of Star structs (each of which contains a Point and a Pen)
Stars also has a Twinkle() method that removes five stars at random and adds five new onesthe game calls Twinkle() several times a second to make the stars twinkle in the background.
Design the Invaders form The Invaders form has only two controls: a timer to trigger animation (making the stars twinkle and the invaders animate by changing each invader picture to a different frame), and a timer to handle gameplay (the invaders marching left and right, the player moving, and the player and invaders shooting at each other)
Other than that, the only intelligence in the form is an event handler to handle the game’s GameOver event, and KeyUp and KeyDown event handlers to manage the keyboard input.
When the form initializes its Game object, it passes its ClientRectangle to it so it knows the boundaries of the form.
So you can change the size of the battlefield just by changing the size of the form.
The form fires a KeyDown event any time a key is pressed, and it fires a KeyUp event whenever a key is released.
The animation t imer handles the eye candy The stars in the game’s background and the invader animation don’t affect gameplay, and they continue when the game is paused or stopped.
That counter is used to update each of  the four-cell invader animations (creating a smooth animation)
Your handler should also call the Game object’s Twinkle() method, which will cause the stars to twinkle.
Finally, it needs to call the form’s Refresh() method to repaint the screen.
Make sure you set the game timer to a shorter interval, though.
The ship should move and gameplay should occur more quickly than the stars twinkle.
If the animation timer is set to 33ms, but the Game object’s Go() method takes longer than that to run, then animation will occur once Go() completes.
Try starting there and reducing each interval until you’re happy.
That way, the main gameplay will occur more quickly than the animation (which is really just background eye candy)
At the same time, the Go() method in Game (fired by the game timer, which we’ll talk about in a little bit) can take a lot of  CPU cycles.
If  the CPU is busy handling gameplay, the animation timer will just wait until the CPU gets to it, and then fire (and animate the stars and invaders)
Alternately, you can just set both timers to an interval of  5ms, and the game will run and animate about as fast as your system can handle (although on fast machines, animation could get annoyingly quick)
That means that the stars twinkle and the invaders animate even if the game is over, paused, or hasn’t been started.
Respond to keyboard input Before we can code the game timer, we need to write event handlers for the KeyDown and KeyUp events.
KeyDown is triggered when a key is pressed, and KeyUp when a key is released.
For most keys, we can simply take action by firing a shot or quitting the game.
For some keys, like the right or left arrow, we’ll want to store those in a list that our game timer can then use to move the player’s ship.
So we’ll also need a list of  pressed keys in the form object:
We need a list of keys so we can track which keys have been pressed.
Our game timer will need that list for movement in just a bit.
If the game has ended, reset the game and start over.
The Keys enum defines all the keys you might want to check key codes against.
When a key is released, we remove it from our list of pressed keys.
We want the most current key pressed to be at the very top of the list, so that if the player mashes a few keys at the same time, the game responds to the one that was hit most recently.
Then, when he lets up one key, the game responds to the next one in the list.
So if the player’s holding down the left arrow and spacebar at the same time, the list will contain Keys.Left and Keys.Space.
But we only want this to work if the game’s over.
Pressing S shouldn’t restart a game that’s already in progress.
One more form detail: the GameOver event Add a private bool field called gameOver to the form that’s true only when the game is over.
Then add an event handler for the Game object’s GameOver event that stops the game timer (but not the animation timer, so the stars still twinkle and the invaders still animate), sets gameOver to true, and calls the form’s Invalidate() method.
When you write the form’s Paint event handler, have it check gameOver.
If it’s true, have it write GAME OVER in big yellow letters in the middle of  the screen.
Then have it write “Press S to start a new game or Q to quit” in the lower right-hand corner.
You can start the game out in this state, so the user has to hit S to start a new game.
The KeyUp and KeyDown events use the Keys enum to specify a key.
It contains every key the player currently has pressed.The keysPressed.
This foreach loop goes through them until it finds a Left or Right key, then moves the player and returns.
The game t imer handles movement and gameplay The main job of  the form’s game timer is to call Go() in the Game class.
But it also has to respond to any keys pressed, so it has to check the keysPressed list to find any keys caught by the KeyDown and KeyUp events:
So the first thing it does is call the Game object’s Go() method to let gameplay continue.
Shots move up and down, the player moves left and right, and the invaders move left, right, and down.
You’ll need this enum to keep all those directions straight.
If we want the game to be robust, it needs to be able to handle that.
The KeyDown event handler just handles the space, S, and Q keystrokes without adding them to the keysPressed list.
What would happen if you moved the code for firing the shot when the space key is pressed to this event handler?
The form’s game t imer te l ls the game to Go() In addition to handling movement left and right, the main job of  the game timer is to call the Game object’s Go() method.
The Game object keeps track of  the state of  the game, and its Go() method advances the game by one frame.
Checking to see if  the player died, using its Alive property.
When the player dies, the game shows a little animation of  the ship collapsing (using DrawImage() to squish the ship down to nothing)
The animation is done by the PlayerShip class, so Go() just needs to check to see if  it’s dead.
If  it is, it returns—that way, it keeps the invaders from moving or shooting while the player gets a small break (and watches his ship get crushed)
Shots fired by the invaders move down, and shots fired by the player move up.
Game keeps two List<Shot> objects, one for the invaders’ shots and one for the player’s.
Any shot that’s moved off  the screen needs to be removed from the list.
Game calls each Invader object’s Move() method, and tells the invaders which way to move.
Game also keeps up with where the invaders are in case they need to move down a row or switch directions.
Then, Game checks to see if  it’s time for the invaders to return fire, and if  so, it adds new Shot objects to the List<>
If  a player’s shot hit any invaders, Game removes the invaders from the appropriate List<>
Then Game checks to see if  any of  the invader shots have collided with the player’s ship, and if  so, it kills the player by setting its Alive property to false.
If  the player’s out of  lives, then Game raises the GameOver event to tell the form that the game’s over.
The form’s GameOver event handler stops its game timer, so Go() isn’t called again.
The game timer fires more often than the animation timer, making gameplay happen quickly.
Here’s where that GameOver event from the last page comes into play.
The invaders have a four-cell animation sequence, so the form passes an int telling the game which cell to draw.
The Game object’s Draw() method calls the Draw() methods on all of the other objects.
You’ll see how each of the other classes’ Draw() methods work in the next few pages.
Everything that happens visually in the game happens in the form’s Paint event handler.
Taking control of graphics In earlier labs, the form used controls for the graphics.
But now that you know how to use Graphics and double-buffering, the Game object should handle a lot of  the drawing.
You’ll delegate the rest of  the drawing to the Game object by calling its Draw() method every time the form’s Paint event fires.
The score, livesLeft, and wave fields keep track of some basic information about the state of the game.
This List<> of Invader objects keeps track of all of the invaders in the current wave.
When an invader is destroyed, it’s removed from the list.
The game checks periodically to make sure the list isn’t empty—if it is, it sends in the next wave of invaders.
This Stars object keeps track of the multicolored stars in the background.
The Game object raises its GameOver event when the player dies and doesn’t have any more lives left.
You’ll build the event handler method in the form, and hook it into the Game object’s GameOver event.
The Game class is the controller for the Invaders game.
Here’s a start on what this class should look like, although there’s lots of work still for you to do.
You may need a lot more private methods to structure your code in a way that makes sense to you.
Most of these methods combine methods on other objects to make a specific action occur.
The Game class methods The Game class has five public methods that get triggered by different events happening in the form.
First, it should draw a black rectangle that fills up the whole form (using the display rectangle stored in boundaries, received from the form)
Then the method should draw the stars, the invaders, the player’s ship, and then the shots.
Finally, it should draw the score in the upper left-hand corner, the player’s ships in the upper right-hand corner, and a big “GAME OVER” in yellow letters if  gameOver is true.
The Twinkle() method twinkles the stars The form’s animation timer event handler needs to be able to twinkle the stars, so the Game object needs a one-line method to call stars.Twinkle()
The FireShot() method makes the player fire a shot at the invaders The FireShot() method checks to see if  there are fewer than two player shots on screen.
If so, the method should add a new shot to the playerShots list at the right location.
The Go() method does everything the game needs to do to advance itself  by a frame:
The game checks if  the player’s dead using its Alive property.
If  he’s still alive, the game isn’t over yet—if  it were, the form would have stopped the animation timer with its Stop() method.
So the Go() method won’t do anything else until the player is alive again—it’ll just return.
The game needs to loop through both List<Shot> objects, calling each shot’s Move() method.
If  any shot’s Move() returns false, that means the shot went off  the edge of  the screen—so it gets deleted from the list.
The game then moves each invader, and allows them to return fire.
Finally, it checks for collisions: first for any shot that overlaps an invader (and removing both from their List<T> objects), and then to see if  the player’s been shot.
We’ll add a Rectangle property called Area to the Invader and PlayerShip classes—so we can use the Contains() method to see if  the ship’s area overlaps with a shot.
We’ll write code for the Stars object in a few more pages.
The constructor sets everything up The Game object needs to create all of  the other objects—the Invader objects, the PlayerShip object, the List objects to hold the shots, and the Stars object.
The form passes in an initialized Random object and its own ClientRectangle struct (so the Game can figure out the boundaries of the battlefield, which it uses to determine when shots are out of  range and when the invaders reach the edge and need to drop and reverse direction)
Then, your code should create everything else in the game world.
Build a NextWave() method A simple method to create the next wave of  invaders will come in handy.
A few other ideas for pri vate methods Here are a few of  the private method ideas you might play with, and see if  these would also help the design of  your Game class:
We’ll talk about most of these individual objects over the next several pages of this lab.
Here’s an example of a private method that will really help out your Game class organization.
Fil ling out the Game class The problem with class diagrams is that they usually leave out any non-public properties and methods.
So even after you’ve got the methods from page 725 done, you’ve still got a lot of work to do.
It’s possible to show protected and private properties and methods in a class diagram, but you’ll rarely see that put into practice.
Any time you hear collections and searching in the same sentence, you should think LINQ.
Figure out if the invaders’ formation has reached the edge of the battlefield The invaders need to change direction if  any one invader is within 100 pixels of  the edge of  the battlefield.
When the invaders are marching to the right, once they reach the right-hand side of  the form the game needs to tell them to drop down and start marching to the left.
And when the invaders are marching to the left, the game needs to check if  they’ve reached the left edge.
To make this happen, add a private MoveInvaders() method that gets called by Go().The first thing it should do is check and update the private framesSkipped field, and return if  this frame should be skipped (depending on the level)
Then it should check which direction the invaders are moving.
If  the invaders are moving to the right, MoveInvaders() should use LINQ to search the invaderCollection list for any invader whose location’s X value is within 100 pixels of  the right-hand boundary.
If  it finds any, then it should tell the invaders to march downward and then set invaderDirection equal to Direction.Left; if  not, it can tell each invader to march to the right.
On the other hand, if  the invaders are moving to the left, then it should do the opposite, using another LINQ query to see if  the invaders are within 100 pixels of  the left-hand boundary, marching them down and changing direction if  they are.
Determine which invaders can return fire Add a private method called ReturnFire() that gets called by Go()
First, it should return if  the invaders’ shot list already has wave + 1 shots.
That makes the invaders fire at random, and not all the time.
If  it gets past both tests, it can use LINQ to group the invaders by their Location.X and sort them descending.
Once it’s got those groups, it can choose a group at random, and use its First() method to find the invader at the bottom of  the column.
All right, now you’ve got the shooter—you can add a shot to the invader’s shot list just below the middle of  the invader (use the invader’s Area to set the shot’s location)
Only the invaders at the bottom of the formation fire shots at the player.
If any invader reaches the bottom of the screen, the game’s over.
When any invader reaches the edge, the formation turns around.
Check for invader and player collisions You’ll want to create a method to check for collisions.
There are three collisions to check for, and the Rectangle struct’s Contains() method will come in really handy—just pass it any Point, and it’ll return true if  that point is inside the rectangle.
Use LINQ to find any dead invaders by looping through the shots in the player’s shot list and selecting any invader where invader.Area contains the shot’s location.
Add a query to figure out if  any invaders reached the bottom of  the screen—if  so, end the game.
You don’t need LINQ to look for shots that collided with the player, just a loop and the player’s Area property.
Remember, you can’t modify a collection inside a foreach loop.
This seems really complex when you first read it, but each LINQ query is just a couple of lines of code.
Since we know the invader’s location and we know its size (from its image field), we can add a get accessor that calculates a Rectangle for the area it covers…
An Invader object uses the ShipType enum to figure out what kind of enemy ship it is.
Every time its Go() method is called, it calls each invader’s Move() method to tell it to move.
And every time its Draw() method is called, it calls each invader object’s Draw() method.
So you’ll need to build out the Move() and Draw() methods.
You’ll want to add a private method called InvaderImage(), too—it’ll come in really handy when you’re drawing the invader.
Make sure you call it inside the Draw() method to keep the image field up to date:
The HorizontalInterval constant determines how many pixels an invader moves every time it marches left or right.
VerticalInterval is the number of pixels it drops down when the formation reaches the edge of the battlefield.
Move the invader ships First, you need a method to move the invader ships.
The Game object should send in a direction, using the Direction enum, and then the ship should move.
Remember, the Game object handles figuring out if  an invader needs to move down or change direction, so your Invader class doesn’t have to worry about that.
Draw the ship—and the r ight animation ce l l Each Invader knows how to draw itself.
Given a Graphics object to draw to, and the animation cell to use, the invader can display itself  onto the game board using the Graphics object the Game gives it.
Get the r ight invader image You’re going to need to grab the right image based on the animation cell a lot, so you may want to pull that code into its own method.
Build an InvaderImage() method that returns a specific Bitmap given an animation cell.
There are five types of invaders, and each of them has four different animation cell pictures.
So if you give its InvaderImage() method a number for its animation cell, it can return a Bitmap that’s got the right graphic in it.Remember, you can download these graphics from.
The player ’s ship can move and die The PlayerShip class keeps track of  the player’s ship.
Animate the player ship when it’s hit The Draw() method should take a Graphics object as a parameter.
If  it’s alive, it draws itself  using its Location property.
If  it’s dead, then instead of  drawing the regular bitmap on the graphics, the PlayerShip object uses its private deadShipHeight field to animate the player ship slowly getting crushed by the shot.
After three seconds of  being dead, it should flip its Alive property back to true.
PlayerShip The Location and Area properties are exactly like the ones in the Invader class.
The Move() method takes one parameter, a Direction enum, and moves the player in that direction.
The Draw() method just draws the player’s ship in the right location–unless the player died, in which case it draws an animation of the ship getting crushed by the shot.
PlayerShip needs to take in a Rectangle with the game’s boundaries in its constructor, and make sure the ship doesn’t get moved out of the game’s boundaries in Move()
Waiting three seconds is easy—just use the Alive property’s set accessor to set a private DateTime field to DateTime.Now.
The first thing the ship’s Go() method does is use a TimeSpan to check if three seconds have elapsed.
If three seconds haven’t elapsed, continue doing the crushing ship animation.
As soon as three seconds have elapsed, set Alive back to true so the game knows it should continue gameplay.
When the ship’s hit with a shot, the game sets the ship’s Alive property to false.
The game then keeps the invaders from moving until the ship resets its Alive property back to true.
Shot only needs a few things to work: a Point location, a method to draw the shot, and a method to move.
You can adjust these to make the game easier or harder…smaller shots are easier to dodge, faster shots are harder to avoid.
The shot updates its own location in the Move() method, so location can be a read-only automatic property.
The game passes the form’s display rectangle into the constructor’s boundaries parameter so the shot can tell when it’s off of the screen.
Game will call this every time the screen needs to be updated.
Move() moves the shot up or down, and keeps up with whether the shot is within the game’s boundaries.
Your job is to make sure Draw() takes in a Graphics object and draws the shot as a yellow rectangle.
Then, Move() should move the shot up or down, and return true if  the shot is still within the game boundaries.
Twinkle, t winkle…it’s up to you The last class you’ll need is the Stars class.
Each star has a point (its location) and a pen (for its color)
You’ll need to build a constructor for Stars that populates that list.
The constructor will get a Rectangle with the display boundaries, and a Random instance for use in creating the random Points to place each star in a random location.
Here’s the class diagram for Stars, with the other methods you’ll need:
Draw() should draw all the stars in the list, and Twinkle() should remove five random stars and add five new stars in their place.
You might also want to create a RandomPen() method so you can get a random color for every new star you create.
Game maintains an instance of Random that all the objects can use.
Here’s another hint: start out the project with just a form, a Game class, and  Stars class.
See if you can get it to draw a black sky with twinkling stars.
That’ll give you a solid foundation to add the other classes and methods.
And yet there’s more to do… Think the game’s looking pretty good? You can take it to the next level with a few more additions:
Add animated explosions Make each invader explode after it’s hit, then briefly display a number to tell the player how many points the invader was worth.
Add a mothership Once in a while, a mothership worth 250 points can travel across the top of the battlefield.
Add shields Add floating shields the player can hide behind.
You can add simple shields that the enemies and player can’t shoot through.
Then, if you really want your game to shine, add breakable shields that the player and invaders can blast holes through after a certain number of hits.
Add divebombers Create a special type of enemy that divebombs the player.
A divebombing enemy should break formation, take off toward the player, fly down around the bottom of the screen, and then resume its position.
Add more weapons Start an arms race! Smart bombs, lasers, guided missiles…there are all sorts of weapons that both the player and the invaders can use to attack each other.
See if you can add three new weapons to the game.
We provided blocky, pixelated graphics to give it that stylized ’80s look.
Can you come up with your own graphics to give the game a new style?
A good class design should let you change out graphics with minimal code changes.
Try making the shields last for fewer hits at higher levels of the game.
The top 10 things we wanted to include in this book.
Here are some of the topics that didn’t make the.
But even though we couldn’t get to them, we still think that they’re important and.
The Basics Before we get started, here’s a Guy class that we’ll be using throughout this appendix.
Notice how the class, its methods, and its properties are all commented with triple-slash (///) comments? Those are called XML comments, and the IDE will help you add them.
Just type “///” right before a class, method, property, or field declaration (and a few other places, too), and the IDE will fill in the skeleton of  the XML comment for it.
Then later, when you go to use the property, method, etc., the IDE will display information from the XML comments in its IntelliSense window.
That means those backing fields can only be set when * the object is initialized (in their declarations or in the constructor)
Cash is not readonly because it might change during the life of the Guy.
The XML comment for a class consists of a <summary> block.
Marking a field readonly is a useful tool for encapsulation, because it means that field can never be changed once the object is instantiated.
We wish we could give this material the same kind of thorough treatment we were able to provide throughout the book, but we just didn’t have enough pages to do it! But we still want to give you a good starting point and a place to go for more information.
When the IDE adds the skeleton for a constructor or another method, it adds <param> tags for each of the parameters.
Here are two useful keywords that you can use with loops.
There’s one more jump statement, goto, which * jumps to a label.
You’ll recognize these labels as having very similar syntax * to what you use in a case statement.
You could easily write this next loop without continue and break.
A really good way to get a handle on this is to debug through it and use watches to see what’s happening.
As you go through the book, try experimenting with some of these concepts.
The continue statement causes the program to jump over the rest of the iteration and back to the top of the loop.
It’s easy to get overwhelmed when learning any computer language, and C# is no exception.
That’s why we concentrated on the parts of  the language that, in our experience, are most common for novice and intermediate developers.
But there’s some basic C# and .NET syntax that’s really useful, but are a lot easier to approach at your own speed once you’re used to things.
A lot of people say that jump statements are bad practice.
There are typically other ways that you can achieve the same results.
But it’s useful to know how they work in case you run across them.
In both of those cases, B will never get executed * because the operator doesn’t need its value in order to come up with a return value.
Since bob is null, the ?? operator returns joe instead.
A label is a string of letters, numbers, or underscores, followed by a colon.
The goto statement causes execution to jump directly to a label.
We’ll use these values in the code on the next page!
This will make a lot more sense when you run the program and look at the output.
Remember, you don’t need to type in all of this code—you can download it all from the Head First Labs website! http://www.headfirstlabs.com/books/hfcsharp.
Using the logical “or” and “and” operators’ short-circuiting properties is another way you can effectively write an if/else statement.
We’ve used the + operator for string concatenation throughout the book, and that // works just fine.
However, a lot of people avoid using + in loops that will have // to execute many times over time, because each time + executes it creates an extra // object on the heap that will need to be garbage collected later.
This doesn’t have anything to do with logic, it’s just something useful that you see reasonably often.
One thing to note here: in this particular example, StringBuilder performs worse than +, because + will pre-compute the length of the string and figure out exactly how much memory to allocate.
You typically use StringBuilder when you don’t know in advance the number of concatenations you want to perform.
Namespaces and assemblies We made the decision to focus this book on the really practical stuff  you need to know in order to build and run applications.
Throughout every chapter, you create your projects in Visual Studio and run them in the debugger.
We showed you where your compiled code ended up in an executable, and how to publish that executable so that other people can install it on their machines.
That’s enough to get you through every exercise in this book, but it’s worth taking a step back and looking a little closer at what it is that you’re building.
When you compile your C# program, you’re creating an assembly.
An assembly is a file that contains the compiled code.
Executables (occasionally called “process assemblies”) have the EXE file extension.
All of the programs you write in this book are compiled as executables.
Those are the assemblies that you can execute (you know, EXE files you can double-click and run)
There are also library assemblies, which have the DLL file extension.
They contain classes that you can use in your programs, and, as you’ll see shortly, namespaces play a big role in how you use them.
You can get a handle on the basics of  assemblies by first creating a class library, and then building a program that uses it.
When the library is first created, it contains the file Class.cs.
Delete that file and add a new class called Guy.cs.
Notice how Visual Studio made the namespace match your class library name? That’s a very standard pattern.
Go ahead and fill in the Guy class with the code from Leftover #1—we’ll use it in a minute.
Go to the Solution Explorer and expand the “References” folder in your project.
Right-click on it and choose “Add Reference…”; a window should pop up:
This window is showing you the assemblies your program can access.
Some of them are stored in the Global Assembly Cache (GAC), but not every assembly in the GAC shows up in this.
The GAC is a central, machinewide set of  assemblies that all of  the .NET programs on the computer can.
You can see all of  the assemblies in it by typing.
Notice how there are many different versions of some assemblies? Your programs can reference a specific assembly version, so they won’t break even if a newer, incompatible version gets installed on the computer.
The “Add References” window figures out which assemblies to display by checking a registry key, not the GAC.
Take a close look at the declarations for LineWriter and HiThereWriter:
There are access modifiers on the class declarations: HiThereWriter is declared with the public access modifier, and LineWriter is declared with the internal one.
In a minute, you’ll write a console application that references this class library.
A program can only directly access another class library’s public classes—although they can be accessed indirectly, like when one method calls another or returns an instance of  an internal object that implements a public interface.
Now go back to your Guy class and look at its declaration:
We’ll want to declare a Guy from another class, so change the declaration to be public:
That makes sense when you think about it, because a class library doesn’t have an entry point.
It’s just a bunch of classes that other programs can use.
So let’s add an executable program that uses those classes—that way the debugger has something to run.
Visual Studio has a really useful feature that we’ll take advantage of  next: it can load multiple projects into a single solution.
Once your new program’s added, it should appear in the Solution Explorer right under the class library.
You should see your class library project listed—select it and click OK.
Go to the top of  your new project’s Program.cs file and start adding this using line:
Notice how the IntelliSense picks up “Csharp” and “Leftover2” as you’re typing?
Throughout the book we tell you that you compile your code.
When you do, it’s compiled to Common Intermediate Language (IL), the low-level language used by .NET.
It’s a human-readable assembly language, and all .NET languages (including C# and Visual Basic) are compiled into it.
The IL code is compiled into native machine language when you run your program using the CLR’s just-intime compiler, so named because it compiles the IL into native code just in time to execute it (rather than pre-compiling it before it’s run)
This is really useful: since VB.NET code compiles to IL, you can build an assembly in C# and use it in a VB.NET program (or vice versa)
If  you have a Macintosh or Linux box, try installing Mono.
We’re not going to talk any more about that, though, because this book is focused on Microsoft technology.
But we do have to admit that it is pretty cool to see the Go Fish game or beehive simulator running natively on Mac or Linux!
The IntelliSense window lists the entire namespace for Guy, so you can see that you’re actually using the class that you defined in the other assembly.
Oh, wait—you get the same error message as before, because you can’t run a class library! No problem.
Right-click on your new MyProgram project in the Solution Explorer and choose “Set as Startup Project”
Your solution can have many different projects, and this is how you tell it which one to start when you run it in the debugger.
You’ll get an error message when you try to build your program that says this:
You’ve seen this declaration so many times that you probably don’t even notice it anymore.
But take a careful look—when the IDE adds a form to your project, it automatically adds the public access modifier.
But your Renderer class is declared without an access modifier, so it defaults to internal.
Your build broke when you tried to add a public property of  type Renderer to the public HiveForm class.
But since Renderer wasn’t public, that caused the inconsistent accessibility error.
And that should make sense when you think about it.
After all, a program is an assembly, too, and another assembly can access its classes.
What would happen if  another assembly tried to reference the HiveForm class? It would see the public property of  type Renderer—but since the Renderer class is internal, it wouldn’t be able to access it.
That’s why there’s a rule: if  you have a public class in your assembly, then any public property, method, or any other member can only use public types.
There’s a lot more (including versioning and signing them for security)
Use BackgroundWorker to make your UI responsive Throughout the book, we’ve shown you two ways that you can make your programs do more than one thing at a time.
But that’s not a good solution (for a bunch of  reasons we didn’t get into), so we showed you a much better solution in Chapter 4: using a timer to trigger an event at a regular interval.
But even when you know how to use timers, there will be times when your program will still be busy and will become nonresponsive.
Luckily, .NET gives you a really useful component that makes it very easy to let your program do work in the background.
It’s called BackgroundWorker, and we’ll show you an example to demonstrate how it works.
It’ll show up in the gray box on the bottom of  the designer.
Notice how it only has a few properties that you can set.
Select the BackgroundWorker and go to the Events page in the Properties window (by clicking on the lightningbolt icon)
Double-click on each of  them to add an event handler for each event.
The code for the form is on the next two pages.
If we are using the background worker, use its RunWorkerAsync() // to tell it to start its work.
The WasteCPUCycles() does a whole bunch of mathematical calculations to tie up the CPU for 100 milliseconds, and then it returns.
When the user clicks on the Go! button, the event handler checks to see if the “Use BackgroundWorker” checkbox is checked.
If it isn’t, the form wastes CPU cycles for 10 seconds.
If it is, the form calls the BackgroundWorker’s RunWorkerAsync() method to tell it to start doing its work in the background.
If the form’s using the background worker, it enables the Cancel button.
When the BackgroundWorker’s RunWorkerAsync() method is called, it starts running its DoWork event handler method in th.
When you tell a BackgroundWorker to start work, you can give it an argument.
In this case, we’re passing it a Guy object (see leftover #1 for its definition)
Here’s a good example of how to use the ?? null coalescing operator we talked about in leftover #1
If e.Argument is null, this returns “null”, otherwise it returns e.Argument.
When the DoWork event handler calls the ProgressChanged() method, it causes the BackgroundWorker to raise its ProgressChanged event.
When the work is complete, the RunWorkerCompleted event handler re-enables the Go! button and disables the Cancel button.
If the user clicks Cancel, it calls the BackgroundWorker’s CancelAsync() method to give it the message to cancel.
It’s easy to see how BackgroundWorker makes your program much more responsive:
Make sure the “Use BackgroundWorker” checkbox isn’t checked, then click the Go! button.
If  you’re lucky, it might jump a bit as it eventually responds to your mouse drag.
When it’s done, check the “Use BackgroundWorker” checkbox and click the Go! button again.
You can move it around and even close it, and there’s no delay.
When it finishes, it uses the RunWorkerCompleted method to re-enable the buttons.
While the program is running (using BackgroundWorker), click the Cancel button.
Are you wondering why you need to use the ReportProgress() method rather than setting the ProgressBar’s Value property directly? Try it out.
So there are two threads: the GUI thread that’s running the form and the background thread.
One of  the .NET threading rules is that only the GUI thread can update form controls; otherwise, that exception is thrown.
This is just one of the many threading pitfalls that can trap a new developer—that’s why we didn’t talk about threading anywhere in this book.
If you’re looking to get started with threads, we highly recommend Joe Albahari’s excellent e-book about threading in C# and .NET: http://www.albahari.com/threading.
The Type class and GetType() One of  the most powerful aspects of  the C# programming language is its rich type system.
But until you’ve got some experience building programs, it’s difficult to appreciate it—in fact, it can be a little baffling at first.
But we want to give you at least a taste of  how types work in C# and .NET.
Here’s a console application that gives you an introduction to some of  the tools you have at your disposal to work with types.
They’re both structs (which you learned all about in Chapter 14)
We only mentioned it briefly, but here’s a reminder that you can nest classes inside of each other.
The FullName property we used in the first part of this program is a member of System.Type.
Numeric value types and DateTime have MinValue and MaxValue properties that return the lowest and highest valid value.
Literals have types, too! And you can use GetType() to get those types.
You can use the typeof keyword to turn a type (like Guy, int, or DateTime) into a Type object.
Then you can find out its full name and base type (and if it didn’t inherit from anything, its base type is System.Object)
When you get the type of a generic, its name is the type name followed by a backward quote and the number of its generic parameters.
Equalit y, IEquatable, and Equals() Throughout the book, when you’ve wanted to compare values in two variables, you’d use the == operator.
But you already know that all things being equal, some values are more “equal” than others.
The == operator works just fine for value types (like ints, doubles, DateTimes, or other structs), but when you use it on reference types you just end up comparing whether two reference variables are pointing to the same object (or if  they’re both null)
That’s fine for what it is, but it turns out that C# and .NET provide a rich set of  tools for dealing with value equality in objects.
To start out, every object has a method Equals(), which by default returns true only if  you pass it a reference to itself.
Here’s an example, which you can try yourself  in a console application:
There’s an interface built into .NET called IEquatable<T> that you can use to add code to your objects so they can tell if  they’re equal to other objects.
An object that implements IEquatable<T> knows how to compare its value to the value of  an object of  type T.
It has one method, Equals(), and you implement it by writing code to compare the current object’s value to that of  another object.
There’s an MSDN page that has more information about it (http://msdn.microsoft.com/en-us/library/ms131190.aspx)
Here’s a class called EquatableGuy, which extends Guy and implements IEquatable<Guy>:
Again, we’re using the same Guy class from leftover #1
The Equals() method compares the actual values in the other Guy object’s fields, checking his Name, Age, and Cash to see if they’re the same and only returning true if they are.
If you don’t do this, the compiler will give you a warning.
And here’s what it looks like when you use Equals() to compare two EquatableGuy objects:
And now that Equals() and GetHashCode() are implemented to check the values of  the fields and properties, the method List.Contains() now works.
We’re also overriding the Equals() method that we inherited from Object, as well as GetHashCode (because of the contract mentioned in that MSDN article)
Since our other Equals() method already compares guys, we’ll just call it.
Note the use of the bitwise XOR (^) operator, a prime number, and the conditional operator (?:)
List.Contains() will go through its contents and call each object’s Equals() method to compare it with the reference you pass to it.
Guy.Equals() will only return true if the actual values of the objects are the same.
Isn’t there something we can do about that? Flip the page and find out!
If  you try to compare two EquatableGuy references with the == or != operators, they’ll just check if  both references are pointing to the same object or if  they’re both null.
Wait, what happened? It’s calling Guy’s == and =! operators.
Can you figure out why? Since we’ve already defined ==, we can just invert it for !=
Using yie ld return to create enumerable objects In Chapter 8 we learned about the IEnumerable interface and how it’s used by the foreach loop.
C# and .NET give you some useful tools for building your own collections, starting with the IEnumerable interface.
Let’s say you want to create your own enumerator that returns values from this Sport enum in order:
You could manually implement IEnumerable yourself, building the Current property and MoveNext() method:
That’s a lot of  work to build an enumerator—it has to manage its own state, and keep track of  which sport it returned.
Luckily, C# gives you a really useful tool to help you easily build enumerators.
It’s called yield return, and you’ll learn about it when you flip the page.
The MoveNext() method increments current and uses it to return the next sport in the enum.
The foreach loop uses its Current property and MoveNext() method.
IEnumerable just contains one method, GetEnumerator(), but we also need to build the class for the enumerator it returns.
We didn’t show you how to build collections from the ground up, but understanding enumerators is definitely enough to get you started down that road.
The yield return statement is a kind of  all-in-one automatic enumerator creator.
This SportCollection class does exactly the same thing as the one on the previous page, but its enumerator is only three lines long.:
That looks a little odd, but if  you actually debug through it you can see what’s going on.
When the compiler sees a method with a yield return statement that returns an IEnumerator or IEnumerator<T>, it automatically adds the MoveNext() and Current methods.
When it executes, the the first yield return that it encounters causes it to return the first value to the foreach loop.
When the foreach loop continues (by calling the MoveNext() method), it resumes execution with the statement immediately after the last yield return that it executed.
Its MoveNext() method returns false if  the enumerator method returns.
This may be a little hard to follow on paper, but it’s much easier to follow if  you load it into the debugger and step through it using Step Into (F11)
To make it a little easier, here’s a really simple enumerator called NameEnumerator() that iterates through four names:
Use Step Into (F11) to see exactly what’s going on:
There’s another thing that you typically see in a collection: an indexer.
It looks a lot like a property, except it’s got a single named parameter.
Type indexer followed by two tabs, and the IDE will add the skeleton of  an indexer for you automatically.
Passing that indexer 3 will return the enum value Hockey.
Like we said earlier, this is just the start for a SportCollection class.
Here’s an IEnumerable<Guy> that keeps track of  a bunch of  guys, with an indexer that lets you get or set guys’ ages.
And here’s some code that uses the indexers to update one guy’s age and add two more guys, and then loop through them:
The enumerator uses this private Dictionary to keep track of the guys it’ll create, but it doesn’t actually create the Guy objects themselves until its enumerator is used.
We’re just doing this to show that the enumerator can create objects on the fly during a foreach loop.
This indexer has a set accessor that either updates a guy’s age or adds a new guy to the Dictionary.
Refactoring Refactoring means changing the way your code is structured without changing its behavior.
Whenever you write a complex method, you should take a few minutes to step back and figure out how you can change it so that you make it easier to understand.
Luckily, the IDE has some very useful refactoring tools built in.
There are all sorts of  refactorings you can do—here are some we use often.
Extract a method When we were writing the control-based renderer for Chapter 13, we originally included this foreach loop:
One of  our tech reviewers, Joe Albahari, pointed out that this was a little hard to read.
He suggested that we extract those two four-line blocks into methods.
Here’s how that foreach loop ended up—it’s a lot easier to read:
These four lines move a BeeControl from the Field form to the Hive form.
The IDE examined the code that we selected and figured out that it uses a BeeControl variable called beeControl, so it added it as a parameter to the method.
Rename a variable Back in Chapter 3, we explained how choosing intuitive names for your classes, methods, fields, and variables makes your code a lot easier to understand.
The IDE can really help you out when it comes to naming things in your code.
Just right-click on any class, variable, field, property, namespace, constant—pretty much anything that you can name—and choose “Refactor >> Rename”
You can also just use F2, which comes in handy because once you start renaming things, you find yourself  doing it all the time.
We selected “beeControl” in the code from the simulator and renamed it.
Consolidate a condit ional expression Here’s a neat way to use the “Extract Method” feature.
Open up any program, add a button, and add this code to its event handler:
This window lets you choose a new name for the item.
If we renamed this, say, to “Bobbo”, then the IDE would go through the code and change every single occurrence of it to “Bobbo”
If you rename a class, it’ll change every statement that instantiates it or uses it.
You can click on any occurrence of the name, anywhere in the code, and the IDE will make the change everywhere in your program.
Every conditional expression evaluates to a bool, so the IDE will create a method that returns a bool and replace the conditional test with a call to that method.
The expression uses two variables called value and text, so the IDE added parameters to the method using those names.
Not only will this make the code easier to read, but now you’ve got a new method that you can reuse elsewhere!
Plus, it’ll even figure out that it should create a static method, since it doesn’t use any fields.
Anonymous types, anonymous methods, and lambda expressions C# lets you create types and methods without using explicitly named declarations.
A type or method that’s declared without a name is called anonymous.
These are very powerful tools—for example, LINQ wouldn’t be possible without them.
But it’s a lot easier to master anonymous types, anonymous methods, and lambda expressions once you have a firm grasp on the language, so they didn’t make the cut for including in the book.
But here’s a quick introduction, so you can get started learning about them.
You can also create objects with anonymous types using var and new.
But that’s not the only way to serialize objects…which should make sense, because there are many different ways that the data in an object can be represented.
Let’s take a look at another, really useful way to serialize data: using the Data Contract Serializer.
It’s part of  Windows Communication Foundation (WCF), Microsoft’s unified programming model for building service-oriented applications.
Here’s an example of  how we can use it to serialize and deserialize our Guy object to and from XML.
Before you can serialize an object using the Data Contract Serializer, you need * to set up a data contract.
The easiest way to do this is by marking the class with * the [Serializable] attribute.
You can associate data with this particular class by * giving the contact a name and a namespace using named parameters.
You can serialize any [Serializable] class with the Data Contract Serializer.
But if you set up a data contract using the [DataContract] and [DataMember] attributes, you have a lot more control over what gets serialized.
Notice how the secretNumberOne field was deserialized as part of the contract, but the secretNumberTwo field wasn’t.
Try putting a breakpoint here and adding reader and reader.
It’s a lot easier to read than what BinaryFormatter writes.
We took our string with XML data, converted it into a UTF-8 encoded byte array, and deserialized it into a new SerializableGuy object.
And you can read more about Windows Communication Foundation here: http://msdn.microsoft.com/en-us/library/dd456779.aspx.
XML—or Extensible Markup Language—is a format for files and data streams that represents complex data as text.
The .NET Framework gives you some really powerful tools for creating, loading, and saving XML files.
And once you’ve got your hands on XML data, you can use LINQ to query it.
Use XElement objects to create elements under the XML tree.
Microsoft has a lot of  great documentation about LINQ and LINQ to XML online.
Query your data Here’s a simple LINQ query that queries the Starbuzz data using its XDocument:
Read data from an RSS feed You can do some pretty powerful things with LINQ to XML.
Here’s a simple query to read articles from our blog:
And its ToString() method renders everything inside it as one big XML document.
The Descendants() method returns a reference to an object that you can plug right into LINQ.
You already know that LINQ lets you call methods and use them as part of the query, and that works really well with the Element() method.
Element() returns an XElement object, and you can use its properties to check specific values in your XML document.
Unfortunately, while WPF is a really cool and highly capable technology, it’s not a particularly good tool for teaching C#
And that was our goal—getting C# concepts into your brain as quickly and easily as possible.
Just create a new project using the IDE, but don’t create a new Windows Forms Application project.
Look closely at the toolbox—it’s got a whole new set of controls.
The biggest difference you’ll see is that the form designer looks nothing like the one you’re used to.
We’ll take a closer look at it in a minute.
Here’s the familiar error list and output window that you’ve been using.
You use it to change attributes in a XAML file, and not properties on objects.
Instead, use the IntelliSense window that pops up to tell the IDE to add a new event handler.
As soon as you finish the line, you’ll see a new button appear in the designer.
That’s all the WPF and XAML that we can include here.
But now that you’ve got the tools to start learning about WPF, we definitely recommend that you take a look at Programming WPF by Chris Sells and Ian Griffiths.
Drag a button out of  the toolbox and onto the form.
But WPF is different—it uses an XML-based language called XAML to define how the user interface is laid out, how it interacts with objects, and more.
Go to the XML editor and add a second button by typing the bold line below into the XAML editor.
You’ll notice how the IDE’s IntelliSense does a good job of  helping you enter all the XML tags.
Drag this slider up and down to zoom in and out.
When you zoom in really close, your user interface still looks good—it doesn’t get pixelated.
The IDE has a really powerful XML editor that’s optimized for working with XAML.
Here’s a project to get your feet wet in WPF: try building the Contact application from Chapter 1 in WPF.
Most of the steps are exactly the same! Just make sure you use an Image instead of a PictureBox, and use the Events page in the Properties window to add a MouseDown event handler to it because it doesn’t have a Click event.
Free online edition for 45 days with purchase of this book.
Joseph Albahari helped us out a whole lot by giving the first edition of this book a really thorough tech review.
