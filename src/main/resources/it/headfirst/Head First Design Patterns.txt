I received the book yesterday and started to read it on the way home...
I took it to the gym and I expect people saw me smiling a lot while I was exercising and reading.
It is fun but they cover a lot of  ground and they are right to the point.
Head First Design Patterns’ manages to mix fun, belly-laughs, insight, technical depth and great practical advice in one entertaining and thought provoking read.
This book is close to perfect, because of  the way it combines expertise and readability.
It’s one of  the very few software books I’ve ever read that strikes me as indispensable.
I’d put maybe 10 books in this category, at the outside.
A Nose Dive into the realm of  patterns, a land where complex things become simple, but where simple things can also become complex.
My ﬁrst reaction was to roll on the ﬂoor laughing.
Jerry Rice runs patterns better than any receiver in the NFL, but the Freemans have out run him.
Great code design is, ﬁrst and foremost, great information design.
A code designer is teaching a computer how to do something, and it is no surprise that a great teacher of  computers should turn out to be a great teacher of  programmers.
There’s an old saying in the computer and videogame business – well, it can’t be that old because the discipline is not all that old – and it goes something like this: Design is Life.
What’s particularly curious about this phrase is that even today almost no one who works at the craft of  creating electronic games can agree on what it means to “design” a game.
Is the designer a software engineer?  An art director? A storyteller?  An architect or a builder?  A pitch person or a visionary?  Can an individual indeed be in part all of  these?  And most importantly, who the %$!#&* cares?
It has been said that the “designed by” credit in interactive entertainment is akin to the “directed by” credit in ﬁlmmaking, which in fact allows it to share DNA with perhaps the single most controversial, overstated, and too often entirely lacking in humility credit grab ever propagated on commercial art.
Good company, eh?  Yet if  Design is Life, then perhaps it is time we spent some quality cycles thinking about what it is.
Eric and Elisabeth Freeman have intrepidly volunteered to look behind the code curtain for us in “Head First Design Patterns.”  I’m not sure either of  them cares all that much about the PlayStation or X-Box, nor should they.
Yet they do address the notion of  design at a signiﬁcantly honest level such that anyone looking for ego reinforcement of  his or her own brilliant auteurship is best advised not to go digging here where truth is stunningly revealed.
Just the right tone for the geeked-out, casual-cool guru coder in all of  us.
This book combines good humors, great examples, and in-depth knowledge of  Design Patterns in such a way that makes learning fun.
Being in the entertainment technology industry, I am intrigued by the Hollywood Principle and the home theater Facade Pattern, to name a few.
The understanding of  Design Patterns not only helps us create reusable and maintainable quality software, but also helps sharpen our problem-solving skills across all problem domains.
If  there’s one subject that needs to be taught better, needs to be more fun to learn, it’s design patterns.
From the awesome Head First Java folks, this book uses every conceivable trick to help you understand and remember.
Not just loads of  pictures: pictures of  humans, which tend to interest other humans.
After using Head First Java to teach our freshman how to start programming, I was eagerly waiting to see the next book in the series.
Usually when reading through a book or article on design patterns I’d have to occasionally stick myself  in the eye with something just to make sure I was paying attention.
Odd as it may sound, this book makes learning about design patterns fun.
Java technology is everywhere—in mobile phones, cars, cameras, printers, games, PDAs, ATMs, smart cards, gas pumps, sports stadiums, medical devices, Web cams, servers, you name it.
Be watching for more books in the Head First series!
Wouldn’t it be dreamy if there was a Design Patterns.
To the Gang of  Four, whose insight and expertise in capturing and communicating Design Patterns has changed the face of software design forever, and bettered the lives of  developers throughout the world.
But seriously, when are we going to see a second edition? After all, it’s been only ten years!
Creators of the Head First series (and co-conspirators on this book)
Kathy has been interested in learning theory since her days as a game designer (she wrote games for Virgin, MGM, and Amblin’)
More recently, she’s been a master trainer for Sun Microsystems, teaching Sun’s Java instructors how to teach the latest Java technologies, and developing several of  Sun’s certiﬁ cation exams.
Together with Bert Bates, she has been actively using the Head First concepts to teach throusands of  developers.
She recently moved from California to Colorado, where she’s had to learn new words like, “ice scraper” and.
Likes: runing, skiing, skateboarding, playing with her Icelandic horse, and weird science.
You can ﬁ nd her on javaranch, or occasionally blogging on java.net.
Bert is a long-time software developer and architect, but a decade-long stint in artiﬁ cial intelligence drove his interest in learning theory and technology-based training.
Recently, he’s been heading up the development team for several of  Sun’s Java Certiﬁ cation exams.
One of  his all-time favorite projects was building a full rail system simulation for Union Paciﬁ c Railroad.
Bert is a long-time, hopelessly addicted go player, and has been working on a go program for way too long.
He’s a fair guitar player and is now trying his hand at banjo.
Here you are trying to learn something, while here your brain is doing you a favor by making sure the learning doesn’t stick.
In this chapter, you’ll learn why (and how) you can exploit the wisdom and lessons learned by other developers who’ve been down the same design problem road and survived.
The best way to use patterns is to load your brain with them and.
Instead of code reuse, with patterns you get experience reuse.
A design guru thinks about how to create ﬂ exible designs that are maintainable.
Keeping your Objects in the KnowDon’t miss out when something interesting happens! We’ve got a pattern that keeps your objects in the know when something they might care about happens.
The Observer Pattern is one of the most heavily used.
With Observer, you’ll be the life of the Patterns Party.
Decorating ObjectsJust call this chapter “Design Eye for the Inheritance Guy.” We’ll re-examine the typical overuse of inheritance and you’ll learn how to decorate your classes at runtime using a form of object composition.
That was until I learned the power of extension at runtime, rather than at compile.
Baking with OO GoodnessGet ready to cook some loosely coupled OO designs.
There is more to making objects than just using the new operator.
You’ll learn that instantiation is an activity that shouldn’t always be done in public and can.
And you don’t want that, do you? Find out how.
Each factory produces a different implementation for the family of products.
The job of the concrete pizza factories is to make pizza ingredients.
Each factory knows how to create the right objects for their region.
One of a Kind ObjectsThe Singleton Pattern: your ticket to creating one-of-a-kind objects, for which there is only one instance.
You might be happy to know that of all patterns, the Singleton is the simplest in terms.
Decorators provide a flexible responsibilities to an object dynamialternative to subclassi.
In this chapter we take encapsulation to a whole new level: we’re going to encapsulate method invocation.
That’s right, by encapsulating invocation we can crystallize pieces of computation.
The customer knows what he wants and creates an order.
The Waitress takes the Order, and when she gets around to it, she calls its orderUp() method to begin the Order’s preparation.
The Short Order Cook follows the instructions of the Order and produces the meal.
Being AdaptiveIn this chapter we’re going to attempt such impossible feats as putting a square peg in a round hole.
Why would we do that?  So we can adapt a design expecting one interface to a class that implements a different interface.
Encapsulating AlgorithmsWe’ve encapsulated object creation, method invocation, complex interfaces, ducks, pizzas...
Brew the coffee grindsPour coffee in a cup Add sugar and milk.
There are lots of  ways to stuff  objects into a collection.
Put them in an Array, a Stack, a List, a Map, take your pick.
Don’t worry—in this chapter you’ll see how you can let.
You’re also going to learn how to create some super collections of objects.
A little known fact: the Strategy and State Patterns were twins separated at birth.
As you know, the Strategy Pattern went on to create a wildly successful business around interchangeable algorithms.
Here’s the way we think the gu mball machine controller needs t.
We’re hoping you can impl ement this in Java for us!  We.
Controlling Object AccessEver play good cop, bad cop? You’re the good cop and you provide all your services in a nice and friendly manner, but you don’t want everyone asking you for services, so you have the bad cop control access to you.
Get ready to take your pattern skills to the next level;  it’s time for.
Just be careful—your co-workers might kill you if you’re struck.
Patterns in the Real WorldAhhhh, now you’re ready for a bright new world filled with Design Patterns.
But, before you go opening all those new doors of opportunity we need to cover a few details that you’ll encounter out in the real world—things get a.
Software ﬁ rst came out, developers have applied these patterns thousands of times.
The patterns we summarize in this appendix are full-ﬂ edged, card-carrying, ofﬁ cial.
GoF patterns, but aren’t always used as often as the patterns we’ve explored so.
But these patterns are awesome in their own right, and if your situation calls for.
All these composite classes have to do is add a getState() method (and not worry about exposing themselves  : )
The Client asks the Visitor to get information from the Composite structure...
New methods can be added to the Visitor without affecting the Composite.
Do you want to learn, understand, remember, and apply design patterns, including the OO design principles upon which design patterns are based?
You also might be okay with just a C++ background.
Are you afraid to try something different? Would you rather have a root canal than mix stripes with plaid? Do you believe that a technical book can’t be serious if Java components are anthropomorphized?
If  you can answer “yes” to any one of  these:
Are you a kick-butt OO designer/developer looking for a reference book?
Do you prefer stimulating dinner party conversation to dry, dull, academic lectures?
It was built that way, and it helps you stay alive.
So what does your brain do with all the routine, ordinary, normal things you encounter? Everything it can to stop them from interfering with the brain’s real job—recording things that matter.
It doesn’t bother saving the boring things; they never make it past the “this is obviously not important” ﬁlter.
How does your brain know what’s important? Suppose you’re out for a day hike and a tiger jumps in front of  you, what happens inside your head and body?
Or trying to learn some tough technical topic your boss thinks will take a week, ten days at the most.
It’s trying to make sure that this obviously non-important content doesn’t clutter up scarce resources.
Resources that are better spent storing the really big things.
And there’s no simple way to tell your brain, “Hey brain, thank you very much, but no matter how dull this book is, and how little I’m registering on the emotional Richter scale right now, I really do want you to keep this stuff  around.”
So what does it take to le arn something? First, yo.
A reader has to be motiv ated, engaged, curious, a.
And for that, you need ch allenges, exercises, and t.
We think of a “Head First” r eader as a learner.
If  you really want to learn, and you want to learn more quickly and more deeply, pay attention to how you pay attention.
Most of  us did not take courses on metacognition or learning theory when we were growing up.
We were expected to learn, but rarely taught to learn.
But we assume that if  you’re holding this book, you really want to learn design patterns.
And you probably don’t want to spend a lot of  time.
And you want to remember what you read, and be able to apply  it.
To get the most from this book, or any book or learning experience, take responsibility for your brain.
The trick is to get your brain to see the new material you’re learning as Really Important.
Otherwise, you’re in for a constant battle, with your brain doing its best to keep the new content from sticking.
I wonder how I can trick my brain into remembering.
So how DO you get your brain to think Design Patterns are as important as a tiger?
There’s the slow, tedious way, or the faster, more effective way.
You obviously know that you are able to learn and remember even the dullest of  topics, if  you keep pounding on the same thing.
With enough repetition, your brain says, “This doesn’t feel important to him, but he keeps looking at the same thing over and over and over, so I suppose it must be.”
The faster way is to do anything that increases brain activity, especially different types of  brain activity.
The things on the previous page are a big part of  the solution, and they’re all things that have been proven to help your brain work in your favor.
For example, studies show that putting words within the pictures they describe (as opposed to somewhere else in the page, like a caption or in the body text) causes your brain to try to makes sense of  how the words and picture relate, and this causes more neurons to ﬁre.
More neurons ﬁring = more chances for your brain to get that this is something worth paying attention to, and possibly recording.
A conversational style helps because people tend to pay more attention when they perceive that they’re in a conversation, since they’re expected to follow along and hold up their end.
The amazing thing is, your brain doesn’t necessarily care that the “conversation” is between you and a book! On the other hand, if  the writing style is formal and dry, your brain perceives it the same way you experience being lectured to while sitting in a roomful of  passive attendees.
We used pictures, because your brain is tuned for visuals, not text.
As far as your brain’s concerned, a picture really is worth 1024 words.
And when text and pictures work together, we embedded the text in the pictures because your brain works more effectively when the text is within the thing the text refers to, as opposed to in a caption or buried in the text somewhere.
We used redundancy, saying the same thing in different ways and with different media types, and multiple senses, to increase the chance that the content gets coded into more than one area of your brain.
We used concepts and pictures in unexpected ways because your brain is tuned for novelty, and we used pictures and ideas with at least some emotional content, because your brain is tuned to pay attention to the biochemistry of  emotions.
That which causes you to feel something is more likely to be remembered, even if  that feeling is nothing more than a little humor, surprise, or interest.
We used a personalized, conversational style, because your brain is tuned to pay more attention when it believes you’re in a conversation than if  it thinks you’re passively listening to a presentation.
We included more than 40 activities, because your brain is tuned to learn and remember more when you do things than when you read about things.
We used multiple learning styles, because you might prefer step-by-step procedures, while someone else wants to understand the big picture ﬁrst, while someone else just wants to see a code example.
But regardless of  your own learning preference, everyone beneﬁts from seeing the same content represented in multiple ways.
We include content for both sides of  your brain, because the more of  your brain you engage, the more likely you are to learn and remember, and the longer you can stay focused.
Since working one side of  the brain often means giving the other side a chance to rest, you can be more productive at learning for a longer period of  time.
And we included stories and exercises that present more than one point of  view, because your brain is tuned to learn more deeply when it’s forced to make evaluations and judgements.
We included challenges, with exercises, and by asking questions that don’t always have a straight answer, because your brain is tuned to learn and remember when it has to work at something.
Think about it—you can’t get your body in shape just by watching people at the gym.
But we did our best to make sure that when you’re working hard, it’s on the right things.
That you’re not spending one extra dendrite processing a hard-to-understand example, or parsing difﬁcult, jargon-laden, or overly terse text.
In stories, examples, pictures, etc., because, well, because you’re a person.
And your brain pays more attention to people than it does to things.
We assume that if  you’re going for a PhD in software design, this won’t be your only book.
These tips are a starting point; listen to your brain and ﬁgure out what works for you and what doesn’t.
Here’s what YOU can do to bend your brain into submission.
The more you understand, the less you have to memorize.
When the book asks you a question, don’t just skip to the answer.
The more deeply you force your brain to think, the better chance you have of learning and remembering.
We put them in, but if  we did them for you, that would be like having someone else do your workouts for you.
There’s plenty of evidence that physical activity while learning can increase the learning.
They’re not optional side-bars—they’re part of  the core content! Don’t skip them.
Part of  the learning (especially the transfer to long-term memory) happens after you put the book down.
Your brain needs time on its own, to do more processing.
If  you put in something new during that processing-time, some of  what you just learned will be lost.
Your brain works best in a nice bath of  ﬂuid.
Dehydration (which can happen before you ever feel thirsty) decreases cognitive function.
If  you’re trying to understand something, or increase your chance of  remembering it later, say it out loud.
Better still, try to explain it out loud to someone else.
You’ll learn more quickly, and you might uncover ideas you hadn’t known were there when you were reading about it.
If  you ﬁnd yourself  starting to skim the surface or forget what you just read, it’s time for a break.
Once you go past a certain point, you won’t learn faster by trying to shove more in, and you might even hurt the process.
Design something! Apply this to something new you’re designing, or refactor an older project.
Just do something to get some experience beyond the exercises and activities in this book.
All you need is a pencil and a problem to solve...
Feel something! Your brain needs to know that this matters.
Groaning over a bad joke is still better than feeling nothing at all.
We deliberately stripped out everything that might get in the way of  learning whatever it is we’re working on at that point in the book.
And the ﬁ rst time through, you need to begin at the beginning, because the book makes assumptions about what you’ve already seen and learned.
Although there’s a good chance you’ve run across UML, it’s not covered in the book, and it’s not a prerequisite for the book.
If  you’ve never seen UML before, don’t worry, we’ll give you a few pointers along the way.
So in other words, you won’t have to worry about Design Patterns and UML at the same time.
Our diagrams are “UML-like” -- while we try to be true to UML there are times we bend the rules a bit, usually for our own selﬁ sh artistic reasons.
There are a lot of  Design Patterns: The original foundational patterns (known as the GoF patterns), Sun’s J2EE patterns, JSP patterns, architectural patterns, game design patterns and a lot more.
But our goal was to make sure the book weighed less than the person reading it, so we don’t cover them all here.
Our focus is on the core patterns that matter from the original GoF patterns, and making sure that you really, truly, deeply understand how and when to use them.
You will ﬁ nd a brief  look at some of  the other patterns (the ones you’re far less likely to use) in the appendix.
In any case, once you’re done with Head First Design Patterns, you’ll be able to pick up any pattern catalog and get up to speed quickly.
The exercises and activities are not add-ons; they’re part of  the core content of  the book.
Some of  them are to help with memory, some for understanding, and some to help you apply what you’ve learned.
The crossword puzzles are the only things you don’t have to do, but they’re good for giving your brain a chance to think about the words from a different context.
We use the word “composition” in the general OO sense, which is more ﬂ exible than the strict UML use of “composition”
When we say “one object is composed with another object” we mean that they are related by a HAS-A relationship.
Our use reﬂ ects the traditional use of  the term and is the one used in the GoF text (you’ll learn what that is later)
More recently, UML has reﬁ ned this term into several types of  composition.
If  you are an UML expert, you’ll still be able to read the book and you should be able to easily map the use of  composition to more reﬁ ned terms as you read.
One distinct difference in a Head First book is that we want you to really get it.
And we want you to ﬁnish the book remembering what you’ve learned.
Most reference books don’t have retention and recall as a goal, but this book is about learning, so you’ll see some of  the same concepts come up more than once.
Our readers tell us that it’s frustrating to wade through 200 lines of  code looking for the two lines they need to understand.
Most examples in this book are shown within the smallest possible context, so that the part you’re trying to learn is clear and simple.
Don’t expect all of  the code to be robust, or even complete—the examples are written speciﬁcally for learning, and aren’t always fully-functional.
In some cases, we haven’t included all of  the import statements needed, but we assume that if  you’re a Java programmer, you know that ArrayList is in java.util, for example.
If  the imports were not part of  the normal core J2SE API, we mention it.
We’ve also placed all the source code on the web so you can download it.
Also, for the sake of  focusing on the learning side of  the code, we did not put our classes into packages (in other words, they’re all in the Java default package)
We don’t recommend this in the real world, and when you download the code examples from this book, you’ll ﬁnd that all classes are in packages.
For some of  them, there is no right answer, and for others, part of  the learning experience of  the Brain Power activities is for you to decide if  and when your answers are right.
In some of  the Brain Power exercises you will ﬁnd hints to point you in the right direction.
Our biggest thanks to Mike Loukides at O’Reilly, for starting it all, and helping to shape the Head First concept into a series.
And a big thanks to the driving force behind Head First, Tim O’Reilly.
Thanks to the clever Head First “series mom” Kyle Hart, to rock and roll star Ellie Volkhausen for her inspired cover design and also to Colleen Gorman for her hardcore copyedit.
Finally, thanks to Mike Hendrickson for championing this Design Patterns book, and building the team.
We are extremely grateful for our technical review director Johannes deJong.
And we deeply appreciate the contributions of  the co-manager of  the Javaranch review team, the late Philippe Maquet.
You have single-handedly brightened the lives of  thousands of developers, and the impact you’ve had on their (and our) lives is forever.
Jef  Cumps is scarily good at ﬁ nding problems in our draft chapters, and once again made a huge difference for the book.
Thanks Jef ! Valentin Cretaz (AOP guy), who has been with us from the very ﬁ rst Head First book, proved (as always) just how much we really need his technical expertise and insight.
Two newcomers to the HF review team, Barney Marispini and Ike Van Atta did a kick butt job on the book—you guys gave us some really crucial feedback.
The winner, Si Brewster, submitted the winning essay that persuaded us to pick the woman you see on our cover.
Your amazing technical expertise, relentless enthusiasm, and deep concern for the learner will inspire us always.
The large number of acknowledgments is because we’re testing the theory that everyone mentioned in a book acknowledgment will buy at least one copy, probably more, what with relatives and everything.
If you’d like to be in the acknowledgment of our next book, and you have a large family, write to us.
Writing a Head First book is a wild ride with two amazing tour guides: Kathy Sierra and Bert Bates.
With Kathy and Bert you throw out all book writing convention and enter a world full of  storytelling, learning theory, cognitive science, and pop culture, where the reader always rules.
Thanks to both of  you for letting us enter your amazing world; we hope we’ve done Head First justice.
Thanks for all your careful guidance, for pushing us to go forward and most of  all, for trusting us (with your baby)
You’re both certainly “wickedly smart” and you’re also the hippest 29 year olds we know.
Mike, your insightful feedback helped shape the book and your encouragement kept us moving ahead.
Mike H., thanks for your persistence over ﬁve years in trying to get us to write a patterns book; we ﬁnally did it and we’re glad we waited for Head First.
A very special thanks to Erich Gamma, who went far beyond the call of  duty in reviewing this book (he even took a draft with him on vacation)
Erich, your interest in this book inspired us and your thorough technical review improved it immeasurably.
Thanks as well to the entire Gang of  Four for their support & interest, and for making a special appearance in Objectville.
We are also indebted to Ward Cunningham and the patterns community who created the Portland Pattern Repository – an indespensible resource for us in writing this book.
It takes a village to write a technical book: Bill Pugh and Ken Arnold gave us expert advice on Singleton.
Daniel Steinberg acted as our “technical liason” and our emotional support network.
And thanks to Apple’s  James Dempsey for allowing us to use his MVC song.
Last, a personal thank you to the Javaranch review team for their top-notch reviews and warm support.
There’s more of  you in this book than you know.
Because of these two, we discovered (to our horror) that we aren’t the only ones who can do a Head First book.
However, if  readers want to believe that it’s really Kathy and Bert who did the cool things in the book, well, who are we to set them straight?
In this chapter, you’ll learn why (and how) you can exploit the wisdom and lessons learned by other developers who’ve.
Instead of code reuse, with patterns you get experience reuse.
Now that we’re living in Objectville, we’ve just got to get into Design Patterns...
Soon we’ll be the hit of Jim and Betty’s Wednesday night.
It started with a simple SimUDuck app Joe works for a company that makes a highly successful duck pond simulation game,  SimUDuck.
The game can show a large variety of duck species swimming and making quacking sounds.
The initial designers of  the system used standard OO techniques and created one Duck superclass from which all other duck types inherit.
All ducks quack and swim, the superclass takes care of the implementation code.
In the last year, the company has been under increasing pressure from competitors.
After a week long off-site brainstorming session over golf, the company executives think it’s time for a big innovation.
They need something really impressive to show at the upcoming shareholders meeting in Maui next week.
I just need to add a ﬂ y() method in the Duck class and then all the ducks will inherit it.
The executives decided that ﬂ ying ducks is just what the simulator needs to blow away the other duck sim competitors.
And of  course Joe’s manager told them it’ll be no problem for Joe to just whip something up in a week.
What he thought was a great use of inheritance for the purpose of reuse hasn’t turned out so well when it comes to maintenance.
OK, so there’s a slight ﬂ aw in my design.
I don’t see why they can’t just call it a “feature”
They just gave a demo and there were rubber duckies ﬂ ying around the screen.
Joe failed to notice that not all subclasses of  Duck should ﬂ y.
When Joe added new behavior to the Duck superclass, he was also adding behavior that was not appropriate for some Duck subclasses.
He now has ﬂ ying inanimate objects in the SimUDuck program.
A localized update to the code caused a nonlocal side effect (ﬂ ying rubber ducks)!
I could always just override the ﬂ y() method in rubber duck, the way I am with.
But then what happens when we add wooden decoy ducks.
I could take the ﬂ y() out of the Duck superclass, and make a Flyable() interface with a ﬂ y()
That way, only the ducks that are supposed to ﬂ y will implement that interface and have a ﬂ y() method...
How about an interface? Joe realized that inheritance probably wasn’t the answer, because he just got a memo that says that the executives now want to update the product every six months (in ways they haven’t yet decided on)
Joe knows the spec will keep changing and he’ll be forced to look at and possibly override ﬂ y() and quack() for every new Duck subclass that’s ever added to the program...
So, he needs a cleaner way to have only some (but not all) of  the duck types ﬂ y or quack.
That is, like, the dumbest idea you’ve come up with.
What would you do if you were Joe? We know that not all of  the subclasses should have ﬂying or quacking behavior, so inheritance isn’t the right answer.
But while having the subclasses implement Flyable and/or Quackable solves part of the problem (no inappropriately ﬂying rubber ducks), it completely destroys code reuse for those behaviors, so it just creates a different maintenance nightmare.
And of  course there might be more than one kind of  ﬂying behavior even among the ducks that do ﬂy...
At this point you might be waiting for a Design Pattern to come riding in on a white horse and save the day.
But what fun would that be? No, we’re going to ﬁgure out a solution the old-fashioned wayby applying good OO software design principles.
Wouldn’t it be dreamy if only there were a way to build.
We could spend less time reworking code and more making the program.
Okay, what’s the one thing you can always count on in software development?
No matter where you work, what you’re building, or what language you are programming in, what’s the one true constant that will be with you always?
No matter how well you design an application, over time an application must grow and change or it will die.
List some reasons you’ve had to change code in your applications (we put in a couple of our own to get you started)
My customers or users decide they want something else, or they want new functionality.
My company decided it is going with another database vendor and it is also purchasing its data from another supplier that uses a different data format.
So we know using inheritance hasn’t worked out very well, since the duck behavior keeps changing across the subclasses, and it’s not appropriate for all subclasses to have those behaviors.
The Flyable and Quackable interface sounded promising at ﬁrst—only ducks that really do ﬂy will be Flyable, etc.—except Java interfaces have no implementation code, so no code reuse.
And that means that whenever you need to modify a behavior, you’re forced to track down and change it in all the different subclasses where that behavior is deﬁned, probably introducing new bugs along the way!
In other words, if  you’ve got some aspect of  your code that is changing, say with every new requirement, then you know you’ve got a behavior that needs to be pulled out and separated from all the stuff  that doesn’t change.
Here’s another way to think about this principle: take the parts that vary and encapsulate them, so that later you can alter or extend the parts that vary without affecting those that don’t.
As simple as this concept is, it forms the basis for almost every design pattern.
All patterns provide a way to let some part of  a system vary independently of  all other parts.
Okay, time to pull the duck behavior out of  the Duck classes!
Take what varies and “encapsulate” it so it won’t affect the rest of your code.
The result?  Fewer unintended consequences from code changes and more f lexibility in your systems!
Identify the aspects of your application that vary and separate.
Where do we start?  As far as we can tell, other than the problems with ﬂy() and quack(), the Duck class is working well and there are no other parts of  it that appear to vary or change frequently.
So, other than a few slight changes, we’re going to pretty much leave the Duck class alone.
Now, to separate the “parts that change from those that stay the same”, we are going to create two sets of  classes (totally apart from Duck), one for ﬂy and one for quack.
Each set of  classes will hold all the implementations of  their respective behavior.
For instance, we might have one class that implements quacking, another that implements squeaking, and another that implements silence.
We know that ﬂy() and quack() are the parts of the Duck class that vary across ducks.
To separate these behaviors from the Duck class, we’ll pull both methods out of the Duck class and create a new set of classes to represent each behavior.
So how are we going to design the set of  classes that implement the ﬂ y and quack behaviors?
We’d like to keep things ﬂ exible; after all, it was the inﬂ exibility in the duck behaviors that got us into trouble in the ﬁ rst place.
And we know that we want to assign behaviors to the instances of  Duck.
For example, we might want to instantiate a new MallardDuck instance and initialize it with a speciﬁ c type of  ﬂ ying behavior.
And while we’re there, why not make sure that we can change the behavior of a duck dynamically? In other words, we should include behavior setter methods in the Duck classes so that we can, say, change the MallardDuck’s ﬂ ying behavior at runtime.
Given these goals, let’s look at our second design principle:
We’ll use an interface to represent each behavior – for instance, FlyBehavior and QuackBehavior – and each implementation of  a behavior will implement one of  those interfaces.
So this time it won’t be the Duck classes that will implement the ﬂ ying and quacking interfaces.
Instead, we’ll make a set of  classes whose entire reason for living is to represent a behavior (for example, “squeaking”), and it’s the  behavior class, rather than the Duck class, that will implement the behavior interface.
This is in contrast to the way we were doing things before, where a behavior either came from a concrete implementation in the superclass Duck, or by providing a specialized implementation in the subclass itself.
We were locked into using that speciﬁ c implementation and there was no room for changing out the behavior (other than writing more code)
With our new design, the Duck subclasses will use a behavior represented by an interface (FlyBehavior and QuackBehavior), so that the actual implementation of  the behavior (in other words, the speciﬁ c concrete behavior coded in the class that implements the FlyBehavior or QuackBehavior) won’t be locked into the Duck subclass.
From now on, the Duck behaviors will live in a separate class—a class that implements a particular behavior interface.
That way, the Duck classes won’t need to know any of the implementation details for their own behaviors.
There’s the concept of interface, but there’s also the Java construct interface.
You can program to an interface, without having to actually use a Java interface.
The point is to exploit polymorphism by programming to a supertype so that the actual runtime object isn’t locked into the code.
And we could rephrase “program to a supertype” as “the declared type of  the variables should be a supertype, usually an abstract class or interface, so that the objects assigned to those variables can be of  any concrete implementation of  the supertype, which means the class declaring them doesn’t have to know about the actual object types!”
This is probably old news to you, but just to make sure we’re all saying the same thing, here’s a simple example of  using a polymorphic type – imagine an abstract class Animal, with two concrete implementations, Dog and Cat.
Even better, rather than hard-coding the instantiation of  the subtype (like new Dog()) into the code, assign the concrete implementation object at runtime:
I don’t see why you have to use an interface for FlyBehavior.
Declaring the variable “d” as type Dog (a concrete implementation of Animal) forces us to code to a concrete implementation.
We know it’s a Dog, but we can now use the animal reference polymorphically.
Here’s the implementation of flying for all ducks that have wings.
And here’s the implementation for all ducks that can’t fly.
Implementing the Duck Behaviors Here we have the two interfaces, FlyBehavior and QuackBehavior along with the corresponding classes that implement each concrete behavior:
With this design, other types of objects can reuse our ﬂ y and quack behaviors because these behaviors are no longer hidden away in our Duck classes!
And we can add new behaviors without modifying any of our existing behavior classes or touching any of the Duck classes that use ﬂ ying behaviors.
Q: Do I always have to implement my application first, see where things are changing, and then go back and separate & encapsulate those things?
A: Not always; often when you are designing an application, you anticipate those areas that are going to vary and then go ahead and build the flexibility to deal with it into your code.
You’ll find that the principles and patterns can be applied at any stage of the development lifecycle.
As you’ll see once we’ve got everything hooked together, we do benefit by having Duck not be an interface and having specific ducks, like MallardDuck, inherit common properties and methods.
Now that we’ve removed what varies from the Duck inheritance, we get the benefits of this structure without the problems.
Q: It feels a little weird to have a class that’s just a behavior.
Aren’t classes supposed to represent things? Aren’t classes supposed to have both state AND behavior?
A: In an OO system, yes, classes represent things that generally have both state (instance variables) and methods.
And in this case, the thing happens to be a behavior.
Using our new design, what would you do if you needed to add rocket-powered ﬂying to the SimUDuck app?
Can you think of a class that might want to use the Quack behavior that isn’t a duck?
First we’ll add two instance variables to the Duck class called ﬂ yBehavior and quackBehavior, that are declared as the interface type (not a concrete class implementation type)
We’ll also remove the ﬂ y() and quack() methods from the Duck class (and any subclasses) because we’ve moved this behavior out into the FlyBehavior and QuackBehavior classes.
The key is that a Duck will now delegate its ﬂ ying and quacking behavior, instead of using quacking and ﬂ ying methods deﬁ ned in the Duck class (or subclass)
Pretty simple, huh? To perform the quack, a Duck just allows the object that is referenced by quackBehavior to quack for it.
In this part of  the code we don’t care what kind of  object it is, all we care about is that it knows how to quack()!
The behavior variables are declared as the behavior INTERFACE type.
Okay, time to worry about how the ﬂyBehavior and quackBehavior instance variables are set.
So MallardDuck’s quack is a real live duck quack, not a squeak and not a mute quack.
So what happens here?  When a MallardDuck is instantiated, its constructor initializes the MallardDuck’s inherited quackBehavior instance variable to a new instance of  type Quack (a QuackBehavior concrete implementation class)
And the same is true for the duck’s ﬂying behavior—the MallardDuck’s constructor initializes the ﬂyBehavior instance variable with an instance of  type FlyWithWings (a FlyBehavior concrete implementation class)
Remember, MallardDuck inherits the quackBehavior and flyBehavior instance variables from class Duck.
Wait a second, didn’t you say we should NOT program to an.
Later in the book we’ll have more patterns in our toolbox that can help us ﬁx it.
Still, notice that while we are setting the behaviors to concrete classes (by instantiating a behavior class like Quack or FlyWithWings and assigning it to our behavior reference variable), we could easily change that at runtime.
So, we still have a lot of  ﬂexibility here, but we’re doing a poor job of  initializing the instance variables in a ﬂexible way.
But think about it, since the quackBehavior instance variable is an interface type, we could (through the magic of  polymorphism) dynamically assign a different QuackBehavior implementation class at runtime.
Take a moment and think about how you would implement a duck so that its behavior could change at runtime.
You’ll see the code that does this a few pages from now.
Flying behavior implementation for ducks that do NOT fly (like rubber ducks and decoy ducks)
Setting behavior dynamically What a shame to have all this dynamic talent built into our ducks and not be using it! Imagine you want to set the duck’s behavior type through a setter method on the duck subclass, rather than by instantiating it in the duck’s constructor.
We can call these methods anytime we want to change the behavior of  a duck on the ﬂ y.
This invokes the model’s inherited behavior setter method, and...voila! The model suddenly has rocket-powered flying capability!If it worked, the model duck dynamically changed its flying behavior! You can’t do THAT if the implementation lives inside the duck class.
To change a duck’s behavior at runtime, just call the duck’s setter method for that behavior.
We have everything you’d expect: ducks extending Duck, ﬂ y behaviors implementing FlyBehavior and quack behaviors implementing QuackBehavior.
Notice also that we’ve started to describe things a little differently.
Instead of  thinking of  the duck behaviors as a set of  behaviors, we’ll start thinking of them as a  family of  algorithms.
Think about it: in the SimUDuck design, the algorithms represent things a duck would do (different ways of  quacking or ﬂ ying), but we could just as easily use the same techniques for a set of  classes that implement the ways to compute state sales tax by different states.
In fact, grab your pen and write the appropriate relationship (IS-A, HAS-A and IMPLEMENTS) on each arrow in the class diagram.
The Big Picture on  encapsulated behaviors Okay, now that we’ve done the deep dive on the duck simulator design, it’s time to come back up for air and take a look at the big picture.
The HAS-A relationship is an interesting one: each duck has a FlyBehavior and a QuackBehavior to which it delegates ﬂying and quacking.
When you put two classes together like this you’re using composition.
Instead of  inheriting their behavior, the ducks get their behavior by being composed with the right behavior object.
This is an important technique; in fact, we’ve been using our third design principle:
A duck call is a device that hunters use to mimic the calls (quacks) of ducks.
How would you implement your own duck call that does not inherit from the Duck class?
As you’ve seen, creating systems using composition gives you a lot more ﬂexibility.
Not only does it let you encapsulate a family of  algorithms into their own set of  classes, but it also lets you change behavior at runtime  as long as the object you’re composing with implements the correct behavior interface.
Composition is used in many design patterns and you’ll see a lot more about its advantages and disadvantages throughout the book.
Master: Grasshopper, tell me what you have learned of the ObjectOriented ways.
Student: Master, I have learned that the promise of the object-oriented way is reuse.
Student: Master, through inheritance all good things may be reused and so we will come to drastically cut development time like we swiftly cut bamboo in the woods.
Master: Grasshopper, is more time spent on code before or after development is complete?
We always spend more time maintaining and changing software than initial development.
Master: So Grasshopper, should effort go into reuse above maintaintability and extensibility?
Student: Master, I believe that there is truth in this.
Master: I can see that you still have much to learn.
I would like for you to go and meditate on inheritance further.
As you’ve seen,  inheritance has its problems, and there are other ways of achieving reuse.
That’s right, you used the Strategy Pattern to rework the SimUDuck app.
Thanks to this pattern, the simulator is ready for any changes those execs might cook up on their next business trip to Vegas.
Now that we’ve made you take the long road to apply it, here’s the formal deﬁnition of this pattern:
The Strategy Pattern deﬁnes a family of  algorithms, encapsulates each one, and makes them interchangeable.
Strategy lets the algorithm vary independently from clients that use it.
Below you’ll ﬁ nd a mess of  classes and interfaces for an action adventure game.
You’ll ﬁ nd classes for game characters along with classes for weapon behaviors the characters can use in the game.
Each character can make use of  one weapon at a time, but can change weapons at any time during the game.
I need a Cream cheese with jelly on white bread, a.
Jack Benny, a radio, a house boat, a coffee regular and.
What’s the difference between these two orders?  Not a thing! They’re both the same order, except Alice is using twice the number of  words and trying the patience of  a grumpy short order cook.
What’s Flo got that Alice doesn’t?  A shared vocabulary with the short order cook.
Not only is it easier to communicate with the cook, but it gives the cook less to remember because he’s got all the diner patterns in his head.
Design Patterns give you a shared vocabulary with other developers.
Once you’ve got the vocabulary you can more easily communicate with other developers and inspire those who don’t know patterns to start learning them.
It also elevates your thinking about architectures by letting you think at the pattern level, not the nitty gritty object level.
Rick, why didn’t you just say you were using the Observer Pattern?
It keeps track of all the objects listening to it and anytime.
What’s cool is that the listeners can join the broadcast at any.
Can you think of aspects of OO design that get communicated along with pattern names?  What qualities get communicated along with the name “Strategy Pattern”?
When you communicate with another developer or your team using patterns, you are communicating not just a pattern name but a whole set of  qualities, characteristics and constraints that the pattern represents.
When you use a pattern in a description, other developers quickly know precisely the design you have in mind.
Talking at the pattern level allows you to stay “in the design” longer.
Talking about software systems using patterns allows you to keep the discussion at the design level, without having to dive down to the nitty gritty details of  implementing objects and classes.
A team well versed in design patterns can move more quickly with less room for misunderstanding.
Shared vocabularies encourage more  junior developers to get up to speed.
When senior developers make use of  design patterns, junior developers also become motivated to learn them.
The power of a shared pattern vocabulary When you communicate using patterns you are doing more than just sharing LINGO.
We take them, write some code against their APIs, compile them into our programs, and beneﬁ t from a lot of  code someone else has written.
Think about the Java APIs and all the functionality they give you: network, GUI, IO, etc.
Libraries and frameworks go a long way towards a development model where we can just pick and choose components and plug them right in.
Design patterns don’t go directly into your code, they ﬁ rst go into your BRAIN.
Once you’ve loaded your brain with a good working knowledge of  patterns, you can then start to apply them to your new designs, and rework your old code when you ﬁ nd it’s degrading into an inﬂ exible mess of  jungle spaghetti code.
Q: If design patterns are so great, why can’t someone build a library of them so I don’t have to?
Design patterns tell us how to structure classes and objects to solve certain problems and it is our job to adapt those designs to fit our particular application.
A: Frameworks and libraries are not design patterns; they provide specific implementations that we link into our code.
Sometimes, however, libraries and frameworks make use of design patterns in their implementations.
That’s great, because once you understand design patterns, you’ll more quickly.
A: No, but you will learn later about pattern catalogs with lists of patterns that you can apply to your applications.
Patterns Guru Developer:  Okay, hmm, but isn’t this all just good object-oriented design; I mean as long as I follow encapsulation and I know about abstraction, inheritance, and polymorphism, do I really need to think about Design Patterns?  Isn’t it pretty straightforward?  Isn’t this why I took all those OO courses? I think Design Patterns are useful for people who don’t know good OO design.
Guru:  Ah, this is one of the true misunderstandings of object-oriented development: that by knowing the OO basics we are automatically going to be good at building ﬂexible, reusable, and maintainable systems.
As it turns out, constructing OO systems that have these properties is not always obvious and has been discovered only through hard work.
These, sometimes non-obvious, ways of constructing object-oriented systems have been collected...
Guru: ...yes, into a set of patterns called Design Patterns.
Developer: So, by knowing patterns, I can skip the hard work and jump straight to designs that always work?
Guru: Yes, to an extent, but remember, design is an art.
But, if you follow well thought-out and time-tested design patterns, you’ll be way ahead.
Developer: What do I do if I can’t ﬁnd a pattern?
A common misconception, Grasshopper, but it’s more subtle than that.
A design guru thinks about how to create ﬂexible designs that.
Guru: Yes, one of the secrets to creating maintainable OO systems is thinking about how they might change in the future and these principles address those issues.
It’s your standard crossword; all of the solution words are from this chapter.
Character is the abstract class for all the other characters (King, Queen, Knight and Troll) while Weapon is an interface that all weapons implement.
To switch weapons, each character calls the setWeapon() method, which is deﬁ ned in the Character superclass.
During a ﬁ ght the useWeapon() method is called on the current weapon set for a given character to inﬂ ict great bodily damage on another character.
Sharpen your pencil What are some factors that drive change in your applications? You might have a very different list, but here’s a few of  ours.
My customers or users decide they want something else, or they want new functionality.
My company decided it is going with another database vendor and it is also purchasing its data from another supplier that uses a different data format.
Well, technology changes and we’ve got to update our code to make use of protocols.
We’ve learned enough building our system that we’d like to go back and do things a little better.
Don’t miss out when something interesting happens! We’ve got a pattern that keeps your objects in the know when something they might care about happens.
Objects can even decide at runtime whether they want to be kept informed.
Pattern is one of the most heavily used patterns in the JDK, and it’s incredibly useful.
With Observer, you’ll be the life of the Patterns Party.
The three players in the system are the weather station (the physical device that acquires the actual weather data), the WeatherData object (that tracks the data coming from the Weather Station and updates the displays), and the display that shows users the current weather conditions.
The WeatherData object knows how to talk to the physical Weather Station, to get updated data.
The WeatherData object then updates its displays for the three different display elements: Current Conditions (shows temperature, humidity, and pressure), Weather Statistics, and a simple forecast.
Our job, if we choose to accept it, is to create an app that uses the WeatherData object to update three displays for current conditions, weather stats, and a forecast.
As promised, the next morning the WeatherData source ﬁ les arrive.
Remember, this Current Conditions is just ONE of three different display screens.
We don’t know or care how this method is called; we just know that it is.
These displays must be updated each time WeatherData has new measurements.
Currently, we know about only the initial three display types (current conditions, statistics and forecast)
The spec from Weather-O-Rama wasn’t all that clear, but we have to ﬁgure out what we need to do.
Call each display element to update its display, passing it the most recent measurements.
Grab the most recent measuremets by calling the WeatherData’s getter methods (already implemented)
For every new display element we need to alter code.
We have no way to add (or remove) display elements at run time.
Think back to all those Chapter 1 concepts and principles...
Umm, I know I’m new here, but given that we are in.
We’ll take a look at Observer, then come back and ﬁgure out how to apply it to the weather monitoring app.
A newspaper publisher goes into business and begins publishing newspapers.
You subscribe to a particular publisher, and every time there’s a new edition it gets delivered to you.
As long as you remain a subscriber, you get new newspapers.
You unsubscribe when you don’t want papers anymore, and they stop being delivered.
While the publisher remains in business, people, hotels, airlines and other businesses constantly subscribe and unsubscribe to the newspaper.
If you understand newspaper subscriptions, you pretty much understand the Observer Pattern, only we call the publisher the SUBJECT and the subscribers the OBSERVERS.
New data values are communicated to the observers in some form when they change.
A Duck object comes along and tells the Subject that it wants to become an observer.
Duck really wants in on the action; those ints Subject is sending out whenever its state changes look pretty interesting...
Now Duck and all the rest of the observers get a notiﬁcation that the Subject has changed.
The Mouse object asks to be removed as an observer.
The Mouse object has been getting ints for ages and is tired of it, so it decides it’s time to stop being an observer.
Mouse is outta here! The Subject acknowledges the Mouse’s request and removes it from the set of observers.
All the observers get another notiﬁcation, except for the Mouse who is no longer included.
Don’t tell anyone, but the Mouse secretly misses those ints...
Hi, I’m Jill, I’ve written a lot of EJB systems, I’m interested in any job you’ve got with Java development.
I’m putting you on my list of Java developers, don’t call me, I’ll call you!
I’ll add you to the list, you’ll know along with everyone else.
Five minute drama: a subject for observation In today’s skit, two post-bubble software developers encounter a real live head hunter...
Hey observers, there’s a Java opening down at JavaBeans-R-Us, jump on it!  Don’t blow it!
Meanwhile for Ron and Jill life goes on; if a Java job comes along, they’ll get notiﬁed, after all, they are observers.
She’s also enjoying the nice fat signing bonus that she got because the company didn’t  have to pay a headhunter.
But what has become of our dear Ron?  We hear he’s beating the headhunter at his own game.
He’s not only still an observer, he’s got his own call list now, and he is notifying his own observers.
The Observer Pattern deﬁnes a one-to-many dependency between objects so that when one object changes state, all of  its dependents are notiﬁed and updated automatically.
When you’re trying to picture the Observer Pattern, a newspaper subscription service with its publisher and subscribers is a good way to visualize the pattern.
In the real world however, you’ll typically see the Observer Pattern defined like this:
The observers are dependent on the subject such that when the subject’s state changes, the observers get notified.
Depending on the style of notification, the observer may also be updated with new values.
As you’ll discover, there are a few different ways to implement the Observer Pattern but most revolve around a class design that includes Subject and Observer interfaces.
The Observer Pattern defines a one-to-many relationship between a set of objects.
When the state of one object changes, all of its dependents are notified.
Let’s relate this definition to how we’ve been talking about the pattern:
Concrete observers can be any class that implements the Observer interface.
Each observer registers with a concrete subject to receive updates.
Q: What does this have to do with one-to-many relationships?
A: With the Observer pattern, the Subject is the object that contains the state and controls it.
The observers, on the other hand, use the state, even if they don’t own it.
There are many observers and they rely on the Subject to tell them when its state changes.
So there is a relationship between the ONE Subject to the MANY Observers.
A: Because the subject is the sole owner of that data, the observers are dependent on the subject to update them when the data changes.
This leads to a cleaner OO design than allowing many objects to control the same data.
Q: What does this have to do with one-to-many relationships?
A: With the Observer pattern, the Subject is the object that contains the state and controls it.
The observers, on the other hand, use the state, even if they don’t own it.
There are many observers and they rely on the Subject to tell them when its state changes.
So there is a relationship between the ONE Subject to the MANY Observers.
A: Because the subject is the sole owner of that data, the observers are dependent on the subject to update them when the data changes.
This leads to a cleaner OO design than allowing many objects to control the same data.
When two objects are loosely coupled, they can interact, but have very little knowledge of each other.
The Observer Pattern provides an object design where subjects and observers are loosely coupled.
The only thing the subject knows about an observer is that it implements a certain interface (the Observer interface)
It doesn’t need to know the concrete class of  the observer, what it does, or anything else about it.
Because the only thing the subject depends on is a list of  objects that implement the Observer interface, we can add new observers whenever we want.
In fact, we can replace any observer at runtime with another observer and the subject will keep purring along.
We never need to modify the subject to add new types of  observers.
Let’s say we have a new concrete class come along that needs to be an observer.
We don’t need to make any changes to the subject to accommodate the new class type, all we have to do is implement the Observer interface in the new class and register as an observer.
The subject doesn’t care; it will deliver notiﬁcations to any object that implements the Observer interface.
We can reuse subjects or observers independently of  each other.
If  we have another use for a subject or an observer, we can easily reuse them because the two aren’t tightly coupled.
Changes to either the subject or an observer will not affect the other.
Because the two are loosely coupled, we are free to make changes to either, as long as the objects still meet their obligations to implement the subject or observer interfaces.
Loosely coupled designs allow us to build ﬂexible OO systems that can handle change because they minimize the interdependency between objects.
Sharpen your pencil Before moving on, try sketching out the classes you’ll need to implement the Weather Station, including the WeatherData class and its display elements.
Make sure your diagram shows how all the pieces ﬁt together and also how another developer might implement her own display element.
If you need a little help, read the next page; your teammates are already talking about how to design the Weather Station.
Mary: Well, it helps to know we’re using the Observer Pattern.
Mary: That actually makes some sense when you think about it.
Our WeatherData class is the “one” and our “many” is the various display elements that use the weather measurements.
Mary: Yup, and when those measurements change, we have to notify all the display elements so they can do whatever it is they are going to do with the measurements.
Mary: There are still a few things to consider that I’m not sure I understand yet.
Mary: For one thing, how do we get the weather measurements to the display elements?
Sue: Well, looking back at the picture of  the Observer Pattern, if  we make the WeatherData object the subject, and the display elements the observers, then the displays will register themselves with the WeatherData object in order to get the information they want, right?
Sue: We gotta remember that every display element can be different...
Even though every component has a different type, they should all implement the same interface so that the WeatherData object will know how to send them the measurements.
So every display will have, say, an update() method that WeatherData will call.
Sue: And update() is deﬁned in a common interface that all the elements implement…
The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.
Back to the Weather Station project, your teammates have already started thinking through the problem...
This display element shows the current measurements from the WeatherData object.
This one keeps track of the min/avg/max measurements and displays them.
Developers can implement the Observer and Display interfaces to create their own display element.
Let’s also create an interface for all display elements to implement.
The display elements just need to implement a display() method.
These three display elements should have a pointer to WeatherData labeled “subject” too, but boy would this diagram start to look like spaghetti if they did.
We’re going to start our implementation using the class diagram and following Mary and Sue’s lead (from a few pages back)
You’ll see later in this chapter that Java provides some built-in support for the Observer pattern, however, we’re going to get our hands dirty and roll our own for now.
While in some cases you can make use of Java’s built-in support, in a lot of  cases it’s more ﬂexible to build your own (and it’s not all that hard)
Both of these methods take an Observer as an argument; that is, the Observer to be registered or removed.
This method is called to notify all observers when the Subject’s state has changed.
The Observer interface is implemented by all observers, so they all have to implement the update() method.
Here we’re following Mary and Sue’s lead and passing the measurements to the observers.
These are the state values the Observers get from the Subject when a weather measurement changes.
The DisplayElement interface just includes one method, display(), that we will call when the display element needs to be displayed.
Mary and Sue thought that passing the measurements directly to the observers was the most straightforward method of updating state.
Do you think this is wise?  Hint: is this an area of the application that might change in the future?  If it did change, would the change be well encapsulated, or would it require changes in many parts of the code?
Can you think of other ways to approach the problem of passing the updated state to the observers?
Don’t worry, we’ll come back to this design decision after we ﬁnish the initial implementation.
Remember our ﬁrst attempt at implementing the WeatherData class at the beginning of  the chapter? You might want to refresh your memory.
Now it’s time to go back and do things with the Observer Pattern in mind...
When an observer registers, we just add it to the end of the list.
Likewise, when an observer wants to un-register, we just take it off the list.
Here’s the fun part; this is where we tell all the observers about the state.
Because they are all Observers, we know they all implement update(), so we know how to notify them.
Okay, while we wanted to ship a nice little weather station with each book, the publisher wouldn’t go for it.
So, rather than reading actual weather data off a device, we’re going to use this method to test our display elements.
Or, for fun, you could write code to grab measurements off the web.
REMEMBER: we don’t provide import and package statements in the code listings.
Get the complete source code from the headfirstlabs web site.
You’ll find the URL on page xxxiii in the Intro.
Now that we’ve got our WeatherData class straightened out, it’s time to build the Display Elements.
Weather-O-Rama ordered three: the current conditions display, the statistics display and the forecast display.
Let’s take a look at the current conditions display; once you have a good feel for this display element, check out the statistics and forecast displays in the head ﬁrst code directory.
It also implements DisplayElement, because our API is going to require all display elements to implement this interface.
The constructor is passed the weatherData object (the Subject) and we use it to register the display as an observer.
A: In this simple example it made sense to call display() when the values changed.
However, you are right, there are much better ways to design.
Q: Why did you store a reference to the Subject?  It doesn’t look like you use it again after the constructor?
A: True, but in the future we may want to un-register ourselves as an observer and it would be handy to already have a reference to the subject.
The Weather Station is ready to go, all we need is some code to glue everything together.
We’ll come back later in the book and make sure all the components are easily pluggable via a conﬁguration ﬁle.
Run the code and let the Observer Pattern do its magic2
Create the three displays and pass them the WeatherData object.Simulate new weather.
If you don’t want to download the code, you can comment out these two lines and run it.
Johnny Hurricane, Weather-O-Rama’s CEO just called, they can’t possibly ship without a Heat Index display element.
The heat index is an index that combines temperature and humidity to determine the apparent temperature (how hot it actually feels)
To compute the heat index, you take the temperature, T, and the relative humidity, RH, and use this formula:
Don’t worry, you won’t have to type that formula in; just create your own HeatIndexDisplay.
How does it work?  You’d have to refer to Head First Meteorology, or try asking someone at the National Weather Service (or try a Google search)
Tonight’s talk:  A Subject and Observer spar over the right way to get state information to the Observer.
I’m glad we’re ﬁnally getting a chance to chat in person.
Well, I do my job, don’t I?  I always tell you what’s going on...
Just because I don’t really know who you are doesn’t mean I don’t care.
And besides, I do know the most important thing about youyou implement the Observer interface.
Well yeah, but that’s just a small part of  who I am.
Well, you’re always passing your state around to us Observers so we can see what’s going on inside you.
I have to send my state with my notiﬁcations so all you lazy Observers will know what happened!
Ok, wait just a minute here; ﬁrst, we’re not lazy, we just have other stuff  to do in between your oh-so-important notiﬁcations, Mr.
Subject, and second, why don’t you let us come to you for the state we want rather than pushing it out to just everyone?
I’d have to open myself  up even more though to let all you Observers come in and get the state that you need.
I can’t let you come in and just snoop around looking at everything I’ve got.
Why don’t you just write some public getter methods that will let us pull out the state we need?
But won’t that be less convenient for you?  If  you have to come to me every time you want something, you might have to make multiple method calls to get all the state you want.
Don’t be so pushy!  There’s so many different kinds of  us Observers, there’s no way you can anticipate everything we need.
Just let us come to you to get the state we need.
That way, if some of  us only need a little bit of  state, we aren’t forced to get it all.
Say, for example, you expand yourself  and add some more state, well if  you use pull, you don’t have to go around and change the update calls on every observer, you just need to change yourself  to allow more getter methods to access our additional state.
Well, I can see the advantages to doing it both ways.
I have noticed that there is a built-in Java Observer Pattern that allows you to use either push or pull.
Oh really? I think we’re going to look at that next....
What, us agree on something?  I guess there’s always hope.
Using  Java’s built-in Observer Pattern So far we’ve rolled our own code for the Observer Pattern, but Java has built-in support in several of  its APIs.
The most general is the Observer interface and the  Observable class in the java.util package.
These are quite similar to our Subject and Observer interface, but give you a lot of  functionality out of  the box.
You can also implement either a push or pull style of update to your observers, as you will see.
With Java’s built-in support, all you have to do is extend Observable and tell it.
Observable is a CLASS not an interface, so WeatherData extends Observable.
There will be a few changes to make to the update()
We left out the DisplayElement interface, but all the displays still implement it too.
The built in Observer Pattern works a bit differently than the implementation that we used on the Weather Station.
The most obvious difference is that WeatherData (our subject) now extends the Observable class and inherits the add, delete and notify Observer methods (among a few others)
You ﬁrst must call the setChanged() method to signify that the state has changed in your object.
Likewise, to remove yourself  as an observer just call deleteObserver()
This will be the data object that was passed to notifyObservers(), or null if a data object wasn’t specified.
The Subject that sent the notification is passed in as this argument.
If  not, then the Observer has to “pull” the data it wants from the Observable object passed to it.
It implements the update method, as before, but the signature of  the method is a bit different: data object.
The setChanged() method is used to signify that the state has changed and that notifyObservers(), when it is called,  should update its observers.
If  notifyObservers() is called without ﬁrst calling setChanged(), the observers will NOT be notiﬁed.
Let’s take a look behind the scenes of Observable to see how this works:
Wait, before we get to that, why do we need this.
Why is this necessary?  The setChanged() method is meant to give you more ﬂexibility in how you update observers by allowing you to optimize the notiﬁcations.
For example, in our weather station, imagine if  our  measurements were so sensitive that the temperature readings were constantly ﬂuctuating by a few tenths of  a degree.
That might cause the WeatherData object to send out notiﬁcations constantly.
Instead, we might want to send out notiﬁcations only if  the temperature changes more than half  a degree and we could call setChanged() only after that happened.
You might not use this functionality very often, but it’s there if  you need it.
In either case, you need to call setChanged() for notiﬁcations to work.
If  this functionality is something that is useful to you, you may also want to use the clearChanged() method, which sets the changed state back to false, and the hasChanged() method, which tells you the current state of  the changed ﬂag.
And after it notifies the observers, it sets the changed flag back to false.
We don’t need to keep track of our observers anymore, or manage their registration and removal, (the superclass will handle that) so we’ve removed the code for register, add and notify.
Our constructor no longer needs to create a data structure to hold Observers.
These methods aren’t new, but because we are going to use “pull” we thought we’d remind you they are here.
The Observers will use them to get at the WeatherData object’s state.
We now first call setChanged() to indicate the state has changed before calling notifyObservers()
Notice we aren’t sending a data object with the notifyObservers() call.
Observable and we use this to add the current conditions object as an Observer.
We’ve changed the update() method to take both an Observable and the optional data argument.
In update(), we first make sure the observable is of type WeatherData and then we use its getter methods to obtain the temperature and humidity measurements.
Code Magnets The ForecastDisplay class  is all scrambled up on the fridge.
Can you reconstruct the code snippets to make it work?  Some of the curly braces fell on the floor and they were too small to pick up, so feel free to add as many of those as you need!
You’ll see all the same calculations, but mysteriously, the order of  the text output is different.
Why might this happen?  Think for a minute before reading on...
Never depend on order of evaluation of the Observer notiﬁcations.
Who’s right? Neither; we just chose to implement things in different ways.
What would be incorrect, however, is if  we wrote our code to depend on a speciﬁc notiﬁcation order.
As you’ve noticed, Observable is a class, not an interface, and worse, it doesn’t even implement an interface.
That’s not to say it doesn’t provide some utility, but there are some large potholes to watch out for.
You already know from our principles this is a bad idea, but what harm does it really cause?
First, because Observable is a class, you have to subclass it.
That means you can’t add on the Observable behavior to an existing class that already extends another superclass.
This limits its reuse potential (and isn’t that why we are using patterns in the ﬁrst place?)
Second, because there isn’t an Observable interface, you can’t even create your own implementation that plays well with Java’s built-in Observer API.
Nor do you have the option of  swapping out the java.util implementation for another (say,  a new, multithreaded implementation)
On the other hand, you may need to roll your own implementation as we did at the beginning of  the chapter.
In either case, you know the Observer Pattern well and you’re in a good position to work with any API that makes use of  the pattern.
If  you look at the Observable API, the setChanged() method is protected.
So what?  Well, this means you can’t call setChanged() unless you’ve subclassed Observable.
This means you can’t even create an instance of  the Observable class and compose it with your own objects, you have to subclass.
The design violates a second design principle here…favor composition over inheritance.
At this point you understand enough about observer to explore these APIs on your own; however, let’s do a quick, simple Swing example just for the fun of  it.
You’ve got a button that says “Should I do it?” and when you click on that button the listeners (observers) get to answer the question in any way they want.
We’re implementing two such listeners, called the AngelListener and the DevilListener.
Let’s take a look at a simple part of  the Swing API, the JButton.
If  you look under the hood at JButton’s superclass, AbstractButton, you’ll see that it has a lot of  add/ remove listener methods.
These methods allow you to add and remove observers, or as they are called in Swing, listeners, to listen for various types of  events that occur on the Swing component.
For instance, an ActionListener lets you “listen in” on any types of  actions that might occur on a button, like a button press.
You’ll ﬁ nd various types of  listeners all over the Swing API.
Makes the devil and angel objects listeners (observers) of the button.
Here are the class definitions for the observers, defined as inner classes (but they don’t have to be)
Rather than update(), the actionPerformed() method gets called when the state in the subject (in this case the button) changes.
All we need to do is create a JButton object, add it to a JFrame and set up our listeners.
We’re going to use inner classes for the listeners, which is a common technique in Swing programming.
If  you aren’t up on inner classes or Swing you might want to review the “Getting GUI” chapter of  Head First Java.
You’ve added a few new things to your OO toolbox...
A new pattern for communicating state to a set of objects in a loosely coupled manner.
Identify the aspects of your application that vary and separate them from what stays the same.
Exercise Design Principle Challenge For each design principle, describe how the Observer Pattern makes use of the principle.
This is a hard one, hint: think about how observers.
Time to give your right brain something to do again!
Identify the aspects of your application that vary and separate them from what stays the same.
The Subject keeps track of objects implementing the Observer interface, while the observers.
For every new display element we need to alter code.
We have no way to add display elements at run time.
Just call this chapter “Design Eye for the Inheritance Guy.” We’ll re-examine the typical overuse of inheritance and you’ll learn how to decorate.
Starbuzz Coffee has made a name for itself as the fastest growing coffee shop around.
If you’ve seen one on your local corner, look across the street; you’ll see another one.
Because they’ve grown so quickly, they’re scrambling to update their ordering systems to match their beverage offerings.
When they ﬁ rst went into business they designed their classes like this...
Each subclass implements cost() to return the cost of the beverage.
The cost() method is abstract; subclassses need to define their own implementation.
In addition to your coffee, you can also ask for several condiments like steamed milk, soy, and mocha (otherwise known as chocolate), and have it all topped off with whipped milk.
Starbuzz charges a bit for each of these, so they really need to  get them built into their order system.
Let’s start with the Beverage base class and add instance variables to represent whether or not each beverage has milk, soy, mocha and whip...
It’s pretty obvious that Starbuzz has created a maintenance nightmare for themselves.
What happens when the price of milk goes up?  What do they do when they add a new caramel topping?
Thinking beyond the maintenance problem, which of the design principles that we’ve covered so far are they violating?
Hint: they’re violating two of them in a big way!
This is stupid; why do we need all these classes?  Can’t we just use instance variables and inheritance in.
Now we’ll implement cost() in Beverage (instead of keeping it abstract), so that it can calculate the costs associated with the condiments for a particular beverage instance.
Subclasses will still override cost(), but they will also invoke the super version so that they can calculate the total cost of the basic beverage plus the costs of the added condiments.
Now let’s add in the subclasses, one for each beverage on the menu:
Write the cost( ) methods for the following classes (pseudo-Java is okay):
I’m not so sure; I can see some potential problems.
What requirements or other factors might change that will impact this design?
Price changes for condiments will force us to alter existing code.
New condiments will force us to add new methods and alter the cost method in the superclass.
For some of these beverages (iced tea?), the condiments may not be appropriate, yet the Tea subclass will still inherit methods like hasWhip()
Master: Grasshopper, it has been some time since our last meeting.
While inheritance is powerful, I have learned that it doesn’t always lead to the most ﬂexible or.
So, tell me my student, how then will you achieve reuse if not through inheritance?
Student: Master, I have learned there are ways of “inheriting” behavior at runtime through composition and delegation.
Student: When I inherit behavior by subclassing, that behavior is set statically at compile time.
If however, I can extend an object’s behavior through composition, then I can do this dynamically at runtime.
Master:  Very good, Grasshopper, you are beginning to see the power of composition.
Student: Yes, it is possible for me to add multiple new responsibilities to objects through this technique, including responsibilities that were not even thought of by the designer of the superclass.
Master: What have you learned about the effect of composition on maintaining your code?
By dynamically composing objects, I can add new functionality by writing new code rather than altering existing code.
Because I’m not changing existing code, the chances of introducing bugs or causing unintended side effects in pre-existing code are much reduced.
I would like for you to go and meditate further on this topic...
Remember, code should be closed (to change) like the lotus ﬂower in the evening, yet open (to extension) like the lotus ﬂower in the morning.
If  your needs or requirements change (and we know they will), just go ahead and make your own extensions.
That’s right, we spent a lot of  time getting this code correct and bug free, so we can’t let you alter the existing code.
If  you don’t like it, you can speak to the manager.
Grasshopper is on to one of the most important design principles:
Our goal is to allow classes to be easily extended to incorporate new behavior without modifying existing code.
What do we get if we accomplish this?  Designs that are resilient to change and ﬂ exible enough to take on new functionality to meet changing requirements.
Q: Open for extension and closed for modiﬁcation?  That sounds very contradictory.
After all, the less modifiable something is, the harder it is to extend, right?
As it turns out, though, there are some clever OO techniques for allowing systems to be extended, even if we can’t change the underlying code.
You’ll see quite a few more ways of extending behavior with other OO design techniques.
Q: Okay, I understand Observable, but how do I generally design something to be extensible, yet closed for modiﬁcation?
A: Many of the patterns give us time tested designs that protect your code from being modified by supplying a means of extension.
In this chapter you’ll see a good example of using the Decorator pattern to follow the OpenClosed principle.
Q: How can I make every part of my design follow the Open-Closed Principle?
Making OO design flexible and open to extension without the modification of existing code takes time and effort.
In general, we don’t have the luxury of tying down every part of our designs (and it would probably be wasteful)
Following the Open-Closed Principle usually introduces new levels of abstraction, which adds complexity to our code.
You want to concentrate on those areas that are most likely to change in your designs and apply the principles there.
Q: How do I know which areas of change are more important?
A: That is partly a matter of experience in designing OO systems and also a matter of knowing the domain you are working in.
Looking at other examples will help you learn to identify areas of change in your own designs.
While it may seem like a contradiction, there are techniques for allowing code to be extended without direct modif ication.
Be careful when choosing the areas of code that need to be extended; applying the Open-Closed Principle EVERYWHERE is wasteful, unnecessary, and can lead to complex, hard to understand code.
Okay, enough of the “Object Oriented Design Club.” We have real problems here!  Remember us?  Starbuzz Coffee?  Do you think you could use some of those design principles to.
Okay, we’ve seen that representing our beverage plus condiment pricing scheme with inheritance has not worked out very well – we get class explosions, rigid designs, or we add functionality to the base class that isn’t appropriate for some of  the subclasses.
So, here’s what we’ll do instead: we’ll start with a beverage and “decorate” it with the condiments  at runtime.
For example, if  the customer wants a Dark Roast with Mocha and Whip, then we’ll:
Call the cost() method and rely on delegation to add on the condiment costs.
Okay, but how do you “decorate” an object, and how does delegation come into this?  A hint: think of  decorator objects as “wrappers.”  Let’s see how this works...
The customer wants Mocha, so we create a Mocha object and wrap it around the DarkRoast.
Whip is a decorator, so it also mirrors DarkRoast’s type and includes a cost() method.
So, a DarkRoast wrapped in Mocha and Whip is still a Beverage and we can do anything with it we can do with a  DarkRoast, including call its cost() method.
Now it’s time to compute the cost for the customer.
We do this by calling cost() on the outermost decorator, Whip, and Whip is going to delegate computing the cost to the objects it decorates.
Once it gets a cost, it will add on the cost of the Whip.
Now let’s see how this all really works by looking at the Decorator Pattern definition and writing some code.
The Decorator Pattern attaches additional responsibilities to an object dynamically.
Decorators provide a ﬂ exible alternative to subclassing for extending functionality.
Decorators can add new methods; however, new behavior is typically added by doing computation before or after an existing method in the component.
Each decorator HAS-A (wraps) a component, which means the decorator has an instance variable that holds a reference to a component.
The ConcreteComponent is the object we’re going to dynamically add new behavior to.
Let’s ﬁ rst take a look at the Decorator Pattern description:
While that describes the role of  the Decorator Pattern, it doesn’t give us a lot of  insight into how we’d apply the pattern to our own implementation.
Let’s take a look at the class diagram, which is a little more revealing (on the next page we’ll look at the same structure applied to the beverage problem)
Each component can be used on its own, or wrapped by a decorator.
And here are our condiment decorators; notice they need to implement not only cost() but also getDescription()
Before going further, think about how you’d implement the cost() method of the coffees and the condiments.
Also think about how you’d implement the getDescription() method of the condiments.
I think the point is that it’s vital that the decorators have the same type as the objects they are going to decorate.
So here we’re using inheritance to achieve the type matching, but we aren’t using inheritance to get behavior.
Mary:  Okay, I can see how decorators need the same “interface” as the components they wrap because they need to stand in place of  the component.
Sue:  When we compose a decorator with a component, we are adding new behavior.
We are acquiring new behavior not by inheriting it from a superclass, but by composing objects together.
Mary:  Okay, so we’re subclassing the abstract class Beverage in order to have the correct type, not to inherit its behavior.
The behavior comes in through the composition of  decorators with the base components as well as other decorators.
And because we are using object composition, we get a whole lot more ﬂexibility about how to mix and match condiments and beverages.
Sue:  Yes, if  we rely on inheritance, then our behavior can only be determined statically at compile time.
In other words, we get only whatever behavior the superclass gives us or that we override.
With composition, we can mix and match decorators any way we like...
Mary:  And as I understand it,  we can implement new decorators at any time to add new behavior.
If  we relied on inheritance, we’d have to go in and change existing code any time we wanted new behavior.
If  all we need to inherit is the type of  the component, how come we didn’t use an interface instead of  an abstract class for the Beverage class?
Sue:  Well, remember, when we got this code, Starbuzz already had an abstract Beverage class.
Traditionally the Decorator Pattern does specify an abstract component, but in Java, obviously, we could use an interface.
But we always try to avoid altering existing code, so don’t “ﬁx” it if the abstract class will work just ﬁne.
Make a picture for what happens when the order is for a “double mocha soy latte with whip” beverage.
Use the menu to get the correct prices, and  draw your picture using the same format we used earlier (from a few pages back):
It’s time to whip this design into some real code.
Let’s start with the Beverage class, which doesn’t need to change from Starbuzz’s original design.
Let’s implement the abstract class for the Condiments (Decorator) as well:
We’re also going to require that the condiment decorators all reimplement the getDescription() method.
Now that we’ve got our base classes out of the way, let’s implement some beverages.
Remember, we need to set a description for the speciﬁ c beverage and also implement the cost() method.
You can create the other two Beverage classses (DarkRoast and Decaf) in exactly the same way.
Now we need to comp ute the cost of our b.
We want our description to not only include the beverage - say “Dark Roast” - but also to include each item decorating the beverage, for instance, “Dark Roast,  Mocha”
So we first delegate to the object we are decorating to get its description, then append “, Mocha” to that description.
On the next page we’ll actually instantiate the beverage and wrap it with all its condiments (decorators), but first...
Sharpen your pencil Write and compile the code for the other Soy and Whip condiments.
It’s time to sit back, order a few coffees and marvel at the ﬂexible design you created with the Decorator Pattern.
We’re going to see a much better way of creating decorated objects when we cover the Factory Pattern (and the Builder Pattern, which is covered in the appendix)
How would you alter the decorator classes to handle this change in requirements?
Q: I’m a little worried about code that might test for a specfic concrete component – say, HouseBlend – and do something, like issue a discount.
Once I’ve wrapped the HouseBlend with decorators, this isn’t going to work anymore.
If you have code that relies on the concrete component’s type, decorators will break that code.
As long as you only write code against the abstract component type, the use of decorators will remain transparent to your code.
However, once you start writing code against concrete components, you’ll want to rethink your application design and your use of decorators.
Q: Wouldn’t it be easy for some client of a beverage to end up with a decorator that isn’t the outermost decorator?  Like if I had a DarkRoast with Mocha, Soy, and Whip, it would be easy to write code that somehow ended up with a reference to Soy instead of Whip, which means it would not include Whip in the order.
A: You could certainly argue that you have to manage more objects with the Decorator Pattern and so there is an increased chance that coding errors will introduce the kinds of problems you suggest.
However, decorators are typically created by using other patterns like Factory and Builder.
Once we’ve covered these patterns, you’ll see that the creation of the concrete component with its decorator is “well encapsulated” and doesn’t lead to these kinds of problems.
Q: Can decorators know about the other decorations in the chain?  Say, I wanted my getDecription() method to print “Whip, Double Mocha” instead of “Mocha, Whip, Mocha”?  That would require that my outermost decorator know all the decorators it is wrapping.
A: Decorators are meant to add behavior to the object they wrap.
When you need to peek at multiple layers into the decorator chain, you are starting to push the decorator beyond its true intent.
Real World  Decorators: Java I/O The large number of  classes in the java.io package is...
Don’t feel alone if  you said “whoa” the ﬁ rst (and second and third) time you looked at this API.
But now that you know the Decorator Pattern, the I/O classes should make more sense since the java.io package is largely based on Decorator.
Here’s a typical set of objects that use decorators to add functionality to reading data from a ﬁ le:
It adds the ability to count the line numbers as it reads data.
These InputStreams act as the concrete components that we will wrap with decorators.
There are a few more we didn’t show, like ObjectInputStream.
You can see that this isn’t so different from the Starbuzz design.
You should now be in a good position to look over the java.io API docs and compose decorators on the various input streams.
And you’ll see that the output streams have the same design.
And you’ve probably already found that the Reader/Writer streams (for character-based data) closely mirror the design of  the streams classes (with a few differences and inconsistencies, but close enough to ﬁ gure out what’s going on)
But Java I/O also points out one of  the  downsides of  the Decorator Pattern: designs using this pattern often result in a large number of  small classes that can be overwhelming to a developer trying to use the Decorator-based API.
But now that you know how Decorator works, you can keep things in perspective and when you’re using someone else’s Decorator-heavy API, you can work through how their classes are organized so that you can easily use wrapping to get the behavior you’re after.
Okay, you know the Decorator Pattern, you’ve seen the I/O class diagram.
You should be ready to write your own input decorator.
How about this: write a decorator that converts all uppercase characters to lowercase in the input stream.
In other words, if we read in “I know the Decorator Pattern therefore I RULE!” then your decorator converts this to “i know the decorator pattern therefore i rule!”
They take a byte (or an array of bytes) and convert each byte (that represents a character) to lowercase if it’s an uppercase character.
REMEMBER: we don’t provide import and package statements in the code listings.
Get the complete source code from the headfirstlabs web site.
You’ll find the URL on page xxxiii in the Intro.
Just use the stream to read characters until the end of file and print as we go.
We’ve heard that you’ve been a bit down on yourself  lately?
Decorator: Yes, I know the world sees me as the glamorous design pattern, but you know, I’ve got my share of  problems just like everyone.
HeadFirst: Can you perhaps share some of  your troubles with us?
Well, you know I’ve got the power to add ﬂexibility to designs, that much is for sure, but I also have a dark side.
You see, I can sometimes add a lot of  small classes to a design and this occasionally results in a design that’s less than straightforward for others to understand.
These are notoriously difﬁcult for people to understand at ﬁrst.
But if  they just saw the classes as a set of  wrappers around an InputStream, life would be much easier.
You’re still a great pattern, and improving this is just a matter of  public education, right?
I’ve got typing problems:  you see, people sometimes take a piece of  client code that relies on speciﬁc types and introduce decorators without thinking through everything.
Now, one great thing about me is that you can usually insert decorators transparently and the client never has to know it’s dealing with a decorator.
But like I said, some code is dependent on speciﬁc types and when you start introducing decorators, boom!  Bad things happen.
HeadFirst: Well, I think everyone understands that you have to be careful when inserting decorators, I don’t think this is a reason to be too down on yourself.
I also have the problem that introducing decorators can increase the complexity of  the code needed to instantiate the component.
Once you’ve got decorators, you’ve got to not only instantiate the component, but also wrap it with who knows how many decorators.
HeadFirst: I’ll be interviewing the Factory and Builder patterns next week – I hear they can be very helpful with this?
Decorator: That’s true; I should talk to those guys more often.
HeadFirst: Well, we all think you’re a great pattern for creating ﬂexible designs and staying true to the Open-Closed Principle, so keep your chin up and think positively!
In fact, they are the same type as the components they decorate, either through inheritance or interface implementation.
You’ve got another chapter under your belt and a new principle and pattern in the toolbox.
Or was it And here’s our first pattern for creating designs.
How would you alter the decorator classes to handle this change in requirements?
Here we get the size (which propagates all the way to the concrete beverage) and then add the appropriate cost.
There is more to making objects than just using the new operator.
Okay, it’s been three chapters and you still haven’t answered my.
Yes, when you use new you are certainly instantiating a concrete class, so that’s deﬁnitely an implementation, not an interface.
And it’s a good question; you’ve learned that tying your code to a concrete class can make it more fragile and less ﬂexible.
Here we’ve got several concrete classes being instantiated, and the decision of  which to instantiate is made at runtime depending on some set of  conditions.
When you see code like this, you know that when it comes time for changes or extensions, you’ll have to reopen this code and examine what needs to be added (or deleted)
Often this kind of  code ends up in several parts of  the application making maintenance and updates more difﬁcult and error-prone.
When you have a whole set of  related concrete classes, often you’re forced to write code like this:
Technically there’s nothing wrong with new, after all, it’s a fundamental part of  Java.
The real culprit is  our old friend CHANGE and how change impacts our use of  new.
By coding to an interface, you know you can insulate yourself from a lot of  changes that might happen to a system down the road.
Why? If  your code is written to an interface, then it will work with any new classes implementing that interface through polymorphism.
However, when you have code that makes use of  lots of  concrete classes, you’re looking for trouble because that code may have to be changed as new concrete classes are added.
So, in other words, your code will not be “closed for modiﬁcation.”  To extend it with new concrete types, you’ll have to reopen it.
So what can you do?  It’s times like these that you can fall back on OO Design Principles to look for clues.
Remember, our ﬁrst principle deals with change and guides us to identify the aspects that vary and separate them from what stays the same.
But you have to create an object at some point and.
Java only gives us one way to create an object, right?  So.
How might you take all the parts of your application that instantiate concrete classes and separate or encapsulate them from the rest of your application?
Remember that designs should be “open for extension but closed for modification” - see Chapter 3 for a review.
Identifying the aspects that vary Let’s say you have a  pizza shop, and as a cutting-edge pizza store owner in Objectville you might end up writing some code like this:
For flexibility, we really want this to be an abstract class or interface, but we can’t directly instantiate either of those.
So then you’d add some code that determines the appropriate type of  pizza and then goes about making the pizza:
Based on the type of pizza, we instantiate the correct concrete class and assign it to the pizza instance variable.
Note that each pizza here has to implement the Pizza interface.
Once we have a Pizza, we prepare it (you know, roll the dough, put on the sauce and add the toppings & cheese), then we bake it, cut it and box it!
You realize that all of  your competitors have added a couple of  trendy pizzas to their menus: the Clam Pizza and the Veggie Pizza.
Obviously you need to keep up with the competition, so you’ll add these items to your menu.
And you haven’t been selling many Greek Pizzas lately, so you decide to take that off  the menu:
Clearly, dealing with which concrete class is instantiated is really messing up our orderPizza() method and preventing it from being closed for modiﬁcation.
But now that we know what is varying and what isn’t, it’s probably time to encapsulate it.
But the pressure is on to add more pizza types.
So now we know we’d be better off  moving the object creation out of  the orderPizza() method.
But how?  Well, what we’re going to do is take the creation code and move it out into another object that is only going to be concerned with creating pizzas.
Then we place that co de in an object that.
We’ve got a name for this new object: we call it a Factory.
Any time it needs a pizza it asks the pizza factory to make one.
Gone are the days when the orderPizza() method needs to know about Greek versus Clam pizzas.
Now the orderPizza() method just cares that it gets a pizza, which implements the Pizza interface so that it can call prepare(), bake(), cut(), and box()
We’ve still got a few details to ﬁll in here; for instance, what does the orderPizza() method replace its creation code with?  Let’s implement a simple factory for the pizza store and ﬁnd out...
Building a simple pizza factory We’ll start with the factory itself.
What we’re going to do is deﬁne a class that encapsulates the object creation for all pizzas.
Q: What’s the advantage of this? It looks like we are just pushing the problem off to another object.
A: One thing to remember is that the SimplePizzaFactory may have many clients.
We’ve only seen the orderPizza() method; however, there may be a PizzaShopMenu class that uses the factory to get pizzas for their current description and price.
We might also have a HomeDelivery class that handles pizzas in a different way than our.
PizzaShop class but is also a client of the factory.
So, by encapsulating the pizza creating in one class, we now have only one place to make modifications when the implementation changes.
Don’t forget, we are also just about to remove the concrete instantiations from our client code!
Q: I’ve seen a similar design where a factory like this is defined as a static method.
A: Defining a simple factory as a static method is a common technique and is often called a static factory.
Why use a static method? Because you don’t need to instantiate an object to make use of the create method.
But remember it also has the disadvanage that you can’t subclass and change the behavior of the create method.
PizzaStore gets the factory passed to it in the constructor.
What we want to do is rely on the factory to create the pizzas for us.
We know that object composition allows us to change behavior dynamically at runtime (among other things) because we can swap in and out implementations.
How might we be able to use that in the PizzaStore?  What factory implementations might we be able to swap in and out?
The Simple Factory isn’t actually a Design Pattern; it’s more of  a programming idiom.
But it is commonly used, so we’ll give it a Head First  Pattern Honorable Mention.
Some developers do mistake this idiom for the “Factory Pattern,” so the next time there is an awkward silence between you and another developer, you’ve got a nice topic to break the ice.
Just because Simple Factory isn’t a REAL pattern doesn’t mean we shouldn’t check out how it’s put together.
Let’s take a look at the class diagram of  our new Pizza Store:
Next, we’ll explore two heavy duty patterns that are both factories.
Each product needs to implement the Pizza interface* (which in this case means “extend the abstract Pizza class”) and be concrete.
As long as that’s the case, it can be created by the factory and handed back to the client.
Just another reminder: in design patterns, the phrase “implement an interface” does NOT always mean “write a class the implements a Java interface, by using the “implements” keyword in the class declaration.” In the general use of the phrase, a concrete class implementing a method from a supertype (which could be a class OR interface) is still considered to be “implementing the interface” of that supertype.
Franchising the pizza store Your Objectville PizzaStore has done so well that you’ve trounced the competition and now everyone wants a PizzaStore in their own neighborhood.
As the franchiser, you want to ensure the quality of  the franchise operations and so you want them to use your time-tested code.
But what about regional differences?  Each franchise might want to offer different styles of  pizzas (New York, Chicago, and California, to name a few), depending on where the franchise store is located and the tastes of  the local pizza connoisseurs.
Another franchise wants a factory that makes Chicago style pizzas; their customers like pizzas with thick crust, rich sauce, and tons of cheese.
Then we create a PizzaStore and pass it a reference to the NY factory.
Likewise for the Chicago pizza stores: we create a factory for Chicago pizzas and create a store that is composed with a Chicago factory.
When we make pizzas, we get the Chicago flavored ones.
So you test marketed the SimpleFactory idea, and what you found was that the franchises were using your factory to create pizzas, but starting to employ their own home grown procedures for the rest of  the process: they’d bake things a little differently, they’d forget to cut the pizza and they’d use third-party boxes.
Rethinking the problem a bit, you see that what you’d really like to do is create a framework that ties the store and the pizza creation together, yet still allows things to remain ﬂexible.
So, how can we have our pizza and eat it too?
I’ve been making pizza for years so I thought I’d add my own “improvements” to the PizzaStore procedures...
There is a way to localize all the pizza making activities to the PizzaStore class, and yet give the franchises freedom to have their own regional style.
What we’re going to do is put the createPizza() method back into PizzaStore, but this time as an abstract method, and then create a PizzaStore subclass for each regional style.
Let’s take a look at how this is going to work.
Allowing the subclasses to decide Remember, the PizzaStore already has a well-honed order system in the orderPizza() method and you want to ensure that it’s consistent across all franchises.
What varies among the regional PizzaStores is the style of  pizzas they make – New York Pizza has thin crust, Chicago Pizza has thick, and so on – and we are going to push all these variations into the createPizza() method and make it responsible for creating the right kind of  pizza.
The way we do this is by letting each subclass of  PizzaStore deﬁ ne what the createPizza() method looks like.
So, we will have a number of  concrete subclasses of  PizzaStore, each with its own pizza variations, all ﬁ tting within the PizzaStore framework and still making use of  the well-tuned orderPizza() method.
Well, think about it from the point of  view of  the PizzaStore’s orderPizza() method: it is deﬁ ned in the abstract PizzaStore, but concrete types are only created in the subclasses.
Now, to take this a little further, the orderPizza() method does a lot of  things with a Pizza object (like prepare, bake, cut, box), but because Pizza is abstract, orderPizza() has no idea what real concrete classes are involved.
When orderPizza() calls createPizza(), one of  your subclasses will be called into action to create a pizza.
So, is there a real-time decision that subclasses make?  No, but from the perspective of orderPizza(), if  you chose a NYStylePizzaStore, that subclass gets to determine which pizza is made.
So the subclasses aren’t really “deciding” – it was you who decided by choosing which store you wanted – but they do determine which kind of  pizza gets made.
The NYPizzaStore extends PizzaStore, so it inherits the orderPizza() method (among others)
We’ve got to implement createPizza(), since it is abstract in PizzaStore.
All the regional stores need to do is subclass PizzaStore and supply a createPizza() method that implements their style of  Pizza.
We’ll take care of  the big three pizza styles for the franchisees.
Once we’ve got our PizzaStore subclasses built, it will be time to see about ordering up a pizza or two.
But before we do that, why don’t you take a crack at building the Chicago Style and California Style pizza stores on the next page.
For each type of Pizza we create the NY style.
We’ve knocked out the NYPizzaStore, just two more to go and we’ll be ready to franchise! Write the Chicago and California PizzaStore implementations here:
With just a couple of  transformations to the PizzaStore we’ve gone from having an object handle the instantiation of  our concrete classes to a set of subclasses that are now taking on that responsibility.
Code Up Close A factory method handles object creation and encapsulates it in a  subclass.
This decouples the client code in the superclass from the object creation code in the subclass.
A factory method is abstract so the subclasses are counted on to handle object creation.
I like Chicago style deep dish pizza with thick crust and.
Ethan needs to order his pizza from a NY pizza store.
Joel needs to order his pizza from a Chicago pizza store.
Let’s see how it works: ordering pizzas with the pizza factory method.
First, Joel and Ethan need an instance of  a PizzaStore.
With a PizzaStore in hand, both Ethan and Joel call the orderPizza() method and pass in the type of  pizza they want (cheese, veggie, and so on)
The orderPizza() method has no idea what kind of  pizza was created, but it knows it is a pizza and it prepares, bakes, cuts, and boxes it for Ethan and Joel.
To create the pizzas, the createPizza() method is called, which is deﬁned in the two subclasses NYPizzaStore and ChicagoPizzaStore.
As we deﬁned them, the NYPizzaStore instantiates a NY style pizza, and the ChicagoPizzaStore instantiates Chicago style pizza.
In either case, the Pizza is returned to the orderPizza() method.
Let’s check out how these pizzas are really made to order...
Let’s follow Ethan’s order: ﬁrst we need a NY PizzaStore:
Now that we have a store, we can take an order:
Finally we have the unprepared pizza in hand and the orderPizza() method ﬁnishes preparing it:
Remember, createPizza(), the factory method, is implemented in the subclass.
Our PizzaStore isn’t going to be very popular without some pizzas, so let’s implement them:
Each Pizza has a name, a type of d ough, a.
REMEMBER: we don’t provide import and package statements in the code listings.
Get the complete source code from the headfirstlabs web site.
You’ll find the URL on page xxxiii in the Intro.
The Chicago style deep dish pizza has lots of mozzarella cheese!
The Factory Method Pattern encapsulates object creation  by letting subclasses decide what objects to create.
Let’s check out these class diagrams to see who the players are in this pattern:
It defines an abstract factory method that the subclasses implement to produce products.
These are the concrete products - all the pizzas that are produced by our stores.
Another perspective: parallel class hierarchies We’ve seen that the factory method provides a framework by supplying an orderPizza() method that is combined with a factory method.
Another way to look at this pattern as a framework is in the way it encapsulates product knowledge into each creator.
Let’s look at the two parallel class hierarchies and see how they relate:
Notice how these class hierarchies are parallel: both have abstract classes that are extended by concrete classes, which know about  specific implementations for NY and Chicago.
Design Puzzle We need another kind of  pizza for those crazy Californians (crazy in a good way of  course)
Draw another parallel set of  classes that you’d need to add a new California region to our PizzaStore.
Okay, now write the ﬁ ve most bizarre things you can think of  to put on a pizza.
Then, you’ll be ready to go into business making pizza in California!
The Factory Method Pattern deﬁ nes an interface for creating an object, but lets subclasses decide which class to instantiate.
It’s time to roll out the ofﬁ cial deﬁ nition of  the Factory Method Pattern:
As with every factory, the Factory Method Pattern gives us a way to encapsulate the instantiations of  concrete types.
Looking at the class diagram below, you can see that the abstract Creator gives you an interface with a method for creating objects, also known as the.
Only subclasses actually implement the factory method and create products.
As in the ofﬁ cial deﬁ nition, you’ll often hear developers say that the Factory Method lets subclasses decide which class to instantiate.
They say “decides” not because the pattern allows subclasses themselves to decide at runtime, but  because the creator class is written without knowledge of  the actual products that will be created, which is decided purely by the choice of  the subclass that is used.
The ConcreteCreator implements the factoryMethod(), which is the method that actually produces products.
The ConcreteCreator is responsible for creating one or more concrete products.
It is the only class that has the knowledge of how to create these products.
Q: What’s the advantage of the Factory Method Pattern when you only have one ConcreteCreator?
A: The Factory Method Pattern is useful if you’ve only got one concrete creator because you are decoupling the implementation of the product from its use.
If you add additional products or change a product’s implementation, it will not affect your Creator (because the Creator is not tightly coupled to any ConcreteProduct)
Q: Would it be correct to say that our NY and Chicago stores are implemented using Simple Factory?  They look just like it.
It is up to each store to define the behavior of the createPizza() method.
In Simple Factory, the factory is another object that is composed with the PizzaStore.
Q: Are the factory method and the Creator always abstract?
A: No, you can define a default factory method to produce some concrete product.
Then you always have a means of creating products even if there are no subclasses of the Creator.
Q: Each store can make four different kinds of pizzas based on the type passed in.
Do all concrete creators make multiple products, or do they sometimes just make one?
A: We implemented what is known as the parameterized factory method.
It can make more than one object based on a parameter passed in, as you noticed.
Often, however, a factory just produces one object and is not parameterized.
Q: Your parameterized types don’t seem “typesafe.” I’m just passing in a String! What if I asked for a “CalmPizza”?
A: You are certainly correct and that would cause, what we call in the business, a “runtime error.”  There are several other more sophisticated techniques that can be used to make parameters more “type safe”, or, in other words, to ensure errors in parameters can be caught at compile time.
For instance, you can create objects that represent the parameter types, use static constants, or, in Java 5, you can use enums.
Q: I’m still a bit confused about the difference between Simple Factory and Factory Method.
They look very similar, except that in Factory Method, the class that returns the pizza is a subclass.
A: You’re right that the subclasses do look a lot like Simple Factory, however think of Simple Factory as a one shot deal, while with Factory Method you are creating a framework that let’s the subclasses decide which implementation will be used.
For example, the orderPizza() method in the Factory Method provides a general framework for creating pizzas that relies on a factory method to actually create the concrete classes that go into making a pizza.
By subclassing the PizzaStore class, you decide what concrete products go into making the pizza that orderPizza() returns.
Compare that with SimpleFactory, which gives you a way to encapsulate object creation, but doesn’t give you the flexibility of the Factory Method because there is no way to vary the products you’re creating.
Student: Master, I have taken my study of “encapsulate what varies” further.
Student: I have learned that one can encapsulate the code that creates objects.
When you have code that instantiates concrete classes, this is an area of frequent change.
I’ve learned a technique called “factories” that allows you to encapsulate this behavior of instantiation.
By placing all my creation code in one object or method, I avoid duplication in my code and provide one place to perform maintenance.
That also means clients depend only upon interfaces rather than the concrete classes required to instantiate objects.
As I have learned in my studies, this allows me to program to an interface, not an implementation, and that makes my code more ﬂexible and extensible in the future.
Student:  Master, I know that by encapsulating object creation I am coding to abstractions and decoupling my client code from actual implementations.
But my factory code must still use concrete classes to instantiate real objects.
Am I not pulling the wool over my own eyes?
Master:  Grasshopper, object creation is a reality of life; we must create objects or we will never create a single Java program.
But, with knowledge of this reality, we can design our code so that we have corralled this creation code like the sheep whose wool you would pull over your eyes.
Once corralled, we can protect and care for the creation code.
If we let our creation code run wild, then we will never collect its “wool.”
Sharpen your pencil Let’s pretend you’ve never heard of  an OO factory.
Here’s a version of  the PizzaStore that doesn’t use a factory;  make a count of  the number of  concrete pizza objects this class is dependent on.
If  you added California style pizzas to this PizzaStore, how many objects would it be dependent on then?
You can write your answers here: number number with C.
Looking at object dependencies When you directly instantiate an object, you are depending on its concrete class.
Take a look at our very dependent PizzaStore one page back.
It creates all the pizza objects right in the PizzaStore class instead of  delegating to a factory.
If  we draw a diagram representing that version of  the PizzaStore and all the objects it depends on, here’s what it looks like:
If the implementation of these classes change, then we may have to modify in PizzaStore.
Every new kind of pizza we add creates another dependency for PizzaStore.
This version of the PizzaStore depends on all those pizza objects, because it’s creating them directly.
At ﬁrst, this principle sounds a lot like “Program to an interface, not an implementation,” right?  It is similar; however, the Dependency Inversion Principle makes an even stronger statement about abstraction.
It suggests that our high-level components should not depend on our low-level components; rather, they should both depend on abstractions.
Well, let’s start by looking again at the pizza store diagram on the previous page.
PizzaStore is our “high-level component” and the pizza implementations are our “lowlevel components,” and clearly the PizzaStore is dependent on the concrete pizza classes.
Now, this principle tells us we should instead write our code so that we are depending on abstractions, not concrete classes.
That goes for both our high level modules and our low-level modules.
It should be pretty clear that reducing dependencies to concrete classes in our code is a “good thing.”  In fact, we’ve got an OO design principle that formalizes this notion; it even has a big, formal name: Dependency Inversion Principle.
Applying the Principle Now, the main problem with the Very Dependent PizzaStore is that it depends on every type of  pizza because it actually instantiates concrete types in its orderPizza() method.
While we’ve created an abstraction, Pizza, we’re nevertheless creating concrete Pizzas in this code, so we don’t get a lot of  leverage out of  this abstraction.
How can we get those instantiations out of  the orderPizza() method?  Well, as we know, the Factory Method allows us to do just that.
So, after we’ve applied the Factory Method, our diagram looks like this:
After applying the Factory Method, you’ll notice that our high-level component, the PizzaStore, and our low-level components, the pizzas, both depend on Pizza, the abstraction.
Factory Method is not the only technique for adhering to the Dependency Inversion Principle, but it is one of  the more powerful ones.
Okay, I get the dependency part, but why is it called.
The “inversion” in the name Dependency Inversion Principle is there because it inverts the way you typically might think about your OO design.
Look at the diagram on the previous page, notice that the low-level components now depend on a higher level abstraction.
Likewise, the high-level component is also tied to the same abstraction.
So, the top-tobottom dependency chart we drew a couple of  pages back has inverted itself, with both high-level and lowlevel modules now depending on the abstraction.
Let’s also walk through the thinking behind the typical design process and see how introducing the principle can invert the way we think about the design...
Right, you start at top and follow things down to the concrete classes.
But, as you’ve seen, you don’t want your store to know about the concrete pizza types, because then it’ll be dependent on all those concrete classes!
Since I now have a Pizza abstraction, I can design my.
Pizza Store and not worry about the concrete pizza classes.
So now, go back and think about the design of  the Pizza Store again.
But to do that you’ll have to rely on a factory to get those concrete classes out of your Pizza Store.
Once you’ve done that, your different concrete pizza types depend only on an abstraction and so does your store.
We’ve taken a design where the store depended on concrete classes and inverted those dependencies (along with your thinking)
If I follow these, I’ll never be able to write a single program!
You’re exactly right!  Like many of  our principles, this is a guideline you should strive for, rather than a rule you should follow all the time.
Clearly, every single Java program ever written violates these guidelines!
But, if  you internalize these guidelines and have them in the back of your mind when you design, you’ll know when you are violating the principle and you’ll have a good reason for doing so.
For instance, if  you have a class that isn’t likely to change, and you know it, then it’s not the end of  the world if  you instantiate a concrete class in your code.
Think about it; we instantiate String objects all the time without thinking twice.
If, on the other hand, a class you write is likely to change, you have some good techniques like Factory Method to encapsulate that change.
The following guidelines can help you avoid OO designs that violate the Dependency Inversion Principle:
If you override an implemented method, then your base class wasn’t really an abstraction to start with.
Those methods implemented in the base class are meant to be shared by all your subclasses.
The design for the PizzaStore is really shaping up: it’s got a ﬂ exible framework and it does a good job of  adhering to design principles.
Now, the key to Objectville Pizza’s success has always been fresh, quality ingredients, and what you’ve discovered is that with the new framework your franchises have been following your procedures, but a few franchises have been substituting inferior ingredients in their pies to lower costs and increase their margins.
You know you’ve got to do something, because in the long term this is going to hurt the Objectville brand!
So how are you going to ensure each franchise is using quality ingredients?  You’re going to build a factory that produces them and ships them to your franchises!
Now there is only one problem with this plan: the franchises are located in different regions and what is red sauce in New York is not red sauce in Chicago.
So, you have one set of  ingredients that need to be shipped to New York and a different set that needs to shipped to Chicago.
We’ve got the same product families (dough, sauce, cheese, veggies, meats) but different implementations based on region.
New York uses one set of ingredients and Chicago another.
Given the popularity of Objectville Pizza it won’t be long before you also need to ship another set of regional ingredients to California, and what’s next?  Seattle?
For this to work, you are going to have to ﬁ gure out how to handle families of ingredients.
Each family consists of a type of dough, a type of sauce, a type of cheese, and a seafood topping (along with a few more we haven’t shown, like veggies and spices)
Now we’re going to build a factory to create our ingredients; the factory will be responsible for creating each ingredient in the ingredient family.
In other words, the factory will need to create dough, sauce, cheese, and so on...
You’ll see how we are going to handle the regional differences shortly.
Let’s start by deﬁning an interface for the factory that is going to create all our ingredients:
Implement a set of  ingredient classes to be used with the factory, like ReggianoCheese, RedPeppers, and ThickCrustDough.
Then we still need to hook all this up by working our new ingredient factories into our old PizzaStore code.
Okay, here’s the implementation for the New York ingredient factory.
We’ve got our factories all ﬁred up and ready to produce quality ingredients; now we just need to rework our Pizzas so they only use factory-produced ingredients.
This is where we are going to collect the ingredients needed for the pizza, which of course will come from the ingredient factory.
Now that you’ve got an abstract Pizza to work from, it’s time to create the New York and Chicago style Pizzas – only this time around they will get their ingredients straight from the factory.
When we wrote the Factory Method code, we had a NYCheesePizza and a ChicagoCheesePizza class.
If  you look at the two classes, the only thing that differs is the use of  regional ingredients.
The pizzas are made just the same (dough + sauce + cheese)
The same goes for the other pizzas: Veggie, Clam, and so on.
They all follow the same preparation steps; they just have different ingredients.
So, what you’ll see is that we really don’t need two classes for each pizza; the ingredient factory is going to handle the regional differences for us.
Code Up Close The Pizza code uses the factory it has been composed with to produce the ingredients used in the pizza.
The Pizza class doesn’t care; it knows how to make pizzas.
Now, it’s decoupled from the differences in regional ingredients and can be easily reused when there are factories for the Rockies, the Paciﬁc Northwest, and beyond.
We’re setting the Pizza instance variable to refer to the specific sauce used in this pizza.
Revisiting our pizza stores We’re almost there; we just need to make a quick trip to our franchise stores to make sure they are using the correct Pizzas.
We also need to give them a reference to their local ingredient factories:
Compare this version of the createPizza() method to the one in the Factory Method implementation earlier in the chapter.
For each type of Pizza, we instantiate a new Pizza and give it the factory it needs to get its ingredients.
That was quite a series of code changes; what exactly did we do?
We provided a means of creating a family of ingredients for pizzas by introducing a new type of factory called an Abstract Factory.
An Abstract Factory gives us an interface for creating a family of products.
By writing code that uses this interface, we decouple our code from the actual factory that creates the products.
That allows us to implement a variety of factories that produce products meant for different contexts – such as different regions, different operating systems, or different look and feels.
Because our code is decoupled from the actual products, we can substitute different factories to get different behaviors (like getting marinara instead of plum tomatoes)
An Abstract Factory  provides an interface for a family of products.
What’s a family?  In our case it’s all the things we need to make a pizza: dough, sauce, cheese, meats and veggies.
From the abstract factory, we derive one or more concrete factories that produce the same products, but with different implementations.
We then write our code so that it uses the factory to create products.
By passing in a variety of factories, we get a variety of implementations of those products.
Ethan and Joel can’t get enough Objectville Pizza!  What they don’t know is that now their orders are making use of the new ingredient factories.
The first part of the order process hasn’t changed at all.
Now that we have a store, we can take an order:
From here things change, because we are using an ingredient factory.
When the createPizza() method is called, that’s when our ingredient factory gets involved:
Once the prepare() method is called, the factory is asked to prepare ingredients:
Finally we have the prepared pizza in hand and the orderPizza() method bakes, cuts, and boxes the pizza.
Creates a instance of Pizza that is composed with the New York ingredient factory.
The Abstract Factory Pattern provides an interface for creating families of  related or dependent objects without specifying their concrete classes.
We’re adding yet another factory pattern to our pattern family, one that lets us create families of  products.
Let’s check out the ofﬁ cial deﬁ nition for this pattern:
We’ve certainly seen that Abstract Factory allows a client to use an abstract interface to create a set of  related products without knowing (or caring) about the concrete products that are actually produced.
In this way, the client is decoupled from any of  the speciﬁ cs of  the concrete products.
Let’s look at the class diagram to see how this all holds together:
Each concrete factory can produce an entire set of products.
Each factory produces a different implementation for the family of products.
The clients of the Abstract Factory are the concrete instances of the Pizza abstract class.
The job of the concrete pizza factories is to make pizza ingredients.
Each factory knows how to create the right objects for their region.
That’s a fairly complicated class diagram; let’s look at it all in terms of our PizzaStore:
HeadFirst:  Wow, an interview with two patterns at once!  This is a ﬁrst for us.
Just because we’re both factory patterns doesn’t mean we shouldn’t get our own interviews.
HeadFirst:  Don’t be miffed, we wanted to interview you together so we could help clear up any confusion about who’s who for the readers.
You do have similarities, and I’ve heard that people sometimes get you confused.
Abstract Factory:  It is true, there have been times I’ve been mistaken for Factory Method, and I know you’ve had similar issues, Factory Method.
We’re both really good at decoupling applications from speciﬁc implementations; we just do it in different ways.
So I can see why people might sometimes get us confused.
After all, I use classes to create and you use objects; that’s totally different!
I noticed that each method in the Abstract Factory actually looks like a Factory.
Good catch! Yes, often the methods of  an Abstract Factory are implemented as factory methods.
It makes sense, right? The job of  an Abstract Factory is to deﬁne an interface for creating a set of  products.
Each method in that interface is responsible for creating a concrete product, and we implement a subclass of  the Abstract Factory to supply those implementations.
So, factory methods are a natural way to implement your product methods in your abstract factories.
Both Abstract Factory and I create objects – that’s our jobs.
So that means, to create objects using Factory Method, you need to extend a class and override a factory method.
Factory Method:  It creates objects, of  course!  I mean, the whole point of  the Factory Method Pattern is that you’re using a subclass to do your creation for you.
In that way, clients only need to know the abstract type they are using, the subclass worries about the concrete type.
So, in other words, I keep clients decoupled from the concrete types.
Abstract Factory:  And I do too, only I do it in a different way.
Abstract Factory:  I provide an abstract type for creating a family of  products.
Subclasses of  this type deﬁne how those products are produced.
To use the factory, you instantiate one and pass it into some code that is written against the abstract type.
So, like Factory Method, my clients are decoupled from the actual concrete products they use.
HeadFirst:  Oh, I see, so another advantage is that you group together a set of  related products.
HeadFirst:  What happens if  you need to extend that set of  related products, to say add another one?  Doesn’t that require changing your interface?
Abstract Factory:  That’s true; my interface has to change if  new products are added, which I know people don’t like to do....
Factory Method:   Oh, come on, that’s a big deal! Changing your interface means you have to go in and change the interface of  every subclass! That sounds like a lot of  work.
Abstract Factory:  Yeah, but I need a big interface because I am used to create entire families of  products.
You’re only creating one product, so you don’t really need a big interface, you just need one method.
HeadFirst:  Abstract Factory, I heard that you often use factory methods to implement your concrete factories?
Abstract Factory:  Yes, I’ll admit it, my concrete factories often implement a factory method to create their products.
In my case, they are used purely to create products...
Factory Method:   ...while in my case I usually implement code in the abstract creator that makes use of the concrete types the subclasses create.
HeadFirst:  It sounds like you both are good at what you do.
I’m sure people like having a choice; after all, factories are so useful, they’ll want to use them in all kinds of  different situations.
You both encapsulate object creation to keep applications loosely coupled and less dependent on implementations, which is really great, whether you’re using Factory Method or Abstract Factory.
Remember me, Abstract Factory, and use me whenever you have families of products you need to create and you want to make sure your clients create products that belong together.
Factory Method:   And I’m Factory Method; use me to decouple your client code from the concrete classes you need to instantiate, or if  you don’t know ahead of  time all the concrete classes you are going to need.
To use me, just subclass me and implement my factory method!
The createPizza() method is parameterized by pizza type, so we can return many types of pizza products.
Methods to create products in an Abstract Factory are often implemented with a Factory Method...
Each ingredient represents a product that is produced by a Factory Method in the Abstract Factory.
Here we have a New York ingredient family and a Chicago family.
Tools for your   Design Toolbox In this chapter, we added two more tools to your toolbox: Factory Method and Abstract Factory.
Both patterns encapsulate object creation and allow you to decouple your code from concrete types.
We have a new principle that guides us to keep things abstract whenever possible.
Grab a slice of Pizza and relax while doing this crossword; all of the solution words are from this chapter.
We’ve knocked out the NYPizzaStore; just two more to go and we’ll be ready to franchise! Write the Chicago and California PizzaStore implementations here:
Both of these stores are almost exactly like the New York.
Design Puzzle Solution We need another kind of  pizza for those crazy Californians (crazy in a GOOD way of course)
Draw another parallel set of  classes that you’d need to add a new California region to our PizzaStore.
Okay, now write the ﬁ ve silliest things you can think of  to put on a pizza.
Then, you’ll be ready to go into business making pizza in California!
Sharpen your pencil Let’s pretend you’ve never heard of  an OO factory.
Here’s a version of  the PizzaStore that doesn’t use a factory;  make a count of  the number of  concrete pizza objects this class is dependent on.
If  you added California style pizzas to this PizzaStore, how many objects would it be dependent on then?
You can write your answers here: number number with C.
Our next stop is the Singleton Pattern, our ticket to creating oneof-a-kind objects for which there is only one instance.
You might be happy to know that of all patterns, the Singleton is the simplest in terms of its class diagram;
You talkin’ to me or the car?  Oh, and when can I get my oven mitt.
Guru:  There are many objects we only need one of: thread pools, caches, dialog boxes, objects that handle preferences and registry settings, objects used for logging, and objects that act as device drivers to devices like printers and graphics cards.
In fact, for many of these types of objects, if we were to instantiate more than one we’d run into all sorts of problems like incorrect program behavior, overuse of resources, or inconsistent results.
Developer:  Okay, so maybe there are classes that should only be instantiated once, but do I need a whole chapter for this?  Can’t I just do this by convention or by global variables?  You know, like in Java, I could do it with a static variable.
Guru:  In many ways, the Singleton Pattern is a convention for ensuring one and only one object is instantiated for a given class.
If you’ve got a better one, the world would like to hear about it; but remember, like all patterns, the Singleton Pattern is a time-tested method for ensuring only one object gets created.
The Singleton Pattern also gives us a global point of access, just like a global variable, but without the downsides.
Guru: Well, here’s one example: if you assign an object to a global variable, then that object might be created when your application begins.
Right? What if this object is resource intensive and your application never ends up using it?  As you will see, with the Singleton Pattern, we can create our objects only when they are needed.
Developer:  This still doesn’t seem like it should be so difﬁcult.
Guru:  If you’ve got a good handle on static class variables and methods as well as access modiﬁers, it’s not.
But, in either case, it is interesting to see how a Singleton works, and, as simple as it sounds, Singleton code is hard to get right.
Just ask yourself: how do I prevent more than one object from being instantiated?  It’s not so obvious, is it?
And, what if  another object wanted to create a MyObject?  Could it call new on MyObject again?
So as long as we have a class, can we always instantiate it one or more times?
And if  not? Well, if  it’s not a public class, only classes in the same package can instantiate it.
No, I’d never thought of  it, but I guess it makes sense because it is a legal deﬁnition.
What does it mean? I suppose it is a class that can’t be instantiated because it has a private constructor.
Well, is there ANY object that could use the private constructor?
Hmm, I think the code in MyClass is the only code that could call it.
Why not ? Because I’d have to have an instance of  the class to call it, but I can’t have an instance because no other class can instantiate it.
It’s a chicken and egg problem:  I can use the constructor from an object of  type MyClass, but I can never instantiate that object because no other object can use “new MyClass()”
Why did you use MyClass, instead of some object name?
Well, getInstance() is a static method; in other words, it is a CLASS method.
You need to use the class name to reference a static method.
So, now can you think of  a second way to instantiate an object?
Can you ﬁnish the code so that only ONE instance of  MyClass is ever created?
The getInstance() method gives us a way to instantiate the class and also to return an instance of it.
Of course, Singleton is a normal class; it has other useful instance variables and methods.
Note that if we never need the instance, it never gets created; this is lazy instantiation.
By the time we hit this code, we have an instance and we return it.
If you’re just flipping through the book, don’t blindly type in this code, you’ll see a it has a few issues later in the chapter.
HeadFirst:  Today we are pleased to bring you an interview with a Singleton object.
Why don’t you begin by telling us a bit about yourself.
Singleton: Well, I’m totally unique; there is just one of  me!
I’m based on the Singleton Pattern, which assures that at any one time there is only one instance of  me.
HeadFirst: Isn’t that sort of  a waste?  Someone took the time to develop a full-blown class and now all we can get is one object out of  it?
Let’s say you have an object that contains registry settings.
You don’t want multiple copies of  that object and its values running around – that would lead to chaos.
By using an object like me you can assure that every object in your application is making use of  the same global resource.
I’m often used to manage pools of  resources, like connection or thread pools.
HeadFirst: Still, only one of  your kind?  That sounds lonely.
Singleton: Because there’s only one of  me, I do keep busy, but it would be nice if  more developers knew me – many developers run into bugs because they have multiple copies of objects ﬂoating around they’re not even aware of.
HeadFirst: So, if  we may ask, how do you know there is only one of  you?  Can’t anyone with a new operator create a “new you”?
HeadFirst: Well, do developers swear an oath not to instantiate you more than once?
HeadFirst: How does that work?  How do you EVER get instantiated?
Singleton: You see, to get a hold of  a Singleton object, you don’t instantiate one, you just ask for an instance.
Call that, and I’ll show up at once, ready to work.
In fact, I may already be helping other objects when you request me.
Singleton, there seems to be a lot under your covers to make all this work.
Thanks for revealing yourself  and we hope to speak with you again soon!
The Chocolate Factory Everyone knows that all modern chocolate factories have computer controlled chocolate boilers.
The job of  the boiler is to take in chocolate and milk, bring them to a boil, and then pass them on to the next phase of  making chocolate bars.
Check out the code; you’ll notice they’ve tried to be very careful to ensure that bad things don’t happen, like draining 500 gallons of  unboiled mixture, or ﬁ lling the boiler when it’s already full, or boiling an empty boiler!
This code is only started when the boiler is empty!
To boil the mixture, the boiler has to be full and not already boiled.
Once it’s boiled we set the boiled flag to true.
Choc-O-Holic has done a decent job of ensuring bad things don’t happen, don’t ya think?  Then again, you probably suspect that if two ChocolateBoiler instances get loose, some very bad things can happen.
How might things go wrong if more than one instance of ChocolateBoiler is created in an application?
Can you help Choc-O-Holic improve their ChocolateBoiler class by turning it into a singleton?
The Singleton Pattern ensures a class has only one instance, and provides a global point of  access to it.
Singleton Pattern  defined Now that you’ve got the classic implementation of Singleton in your head, it’s time to sit back, enjoy a bar of chocolate, and check out the ﬁ ner points of the Singleton Pattern.
Let’s start with the concise deﬁ nition of the pattern:
We’re also preventing any other class from creating a new instance on its own.
To get an instance, you’ve got to go through the class itself.
As you’ve seen, we can implement this so that the Singleton is created in a lazy manner, which is especially important for resource intensive objects.
The uniqueInstance class variable holds our one and only instance of Singleton.
It looks like the Chocolate Boiler has let us down; despite the fact we improved the code using Classic Singleton, somehow the ChocolateBoiler’s ﬁ ll() method was able to start ﬁ lling the boiler even though a batch of milk and chocolate was already boiling!  That’s 500 gallons of spilled milk (and chocolate)!  What happened!?
We don’t know what happened!  The new Singleton code was running ﬁ ne.
The only thing we can think of is that we just added some optimizations to the Chocolate Boiler Controller.
Could the addition of threads have caused this? Isn’t it the case that once we’ve set the uniqueInstance variable to the sole instance of ChocolateBoiler, all calls to getInstance() should return the same instance?  Right?
Your job is to play the JVM and determine whether there is a case in which two threads might get ahold of different boiler objects.
Use the  code Magnets to help you study how the code might interleave to create two boiler objects.
Make sure you check your answer on page 188 before turning the page!
Our multithreading woes are almost trivially ﬁxed by making getInstance() a synchronized method:
Good point, and it’s actually a little worse than you make out:  the only time synchronization is relevant is the ﬁrst time through this method.
In other words, once we’ve set the uniqueInstance variable to an instance of  Singleton, we have no further need to synchronize this method.
After the ﬁrst time through, synchronization is totally unneeded overhead!
Using this approach, we rely on the JVM to create the unique instance of  the Singleton when the class is loaded.
The JVM guarantees that the instance will be created before any thread accesses the static uniqueInstance variable.
For most Java applications, we obviously need to ensure that the Singleton works in the presence of  multiple threads.
But, it looks fairly expensive to synchronize the getInstance() method,  so what do we do?
Do nothing if the performance of getInstance() isn’t critical to your application That’s right; if  calling the getInstance() method isn’t causing substantial overhead for your application, forget about it.
Just keep in mind that synchronizing a method can decrease performance by a factor of  100, so if  a high trafﬁc part of  your code begins using getInstance(), you may have to reconsider.
Move to an eagerly created instance rather than a lazily created one If  your application always creates and uses an instance of  the Singleton or the overhead of creation and runtime aspects of  the Singleton are not onerous, you may want to create your Singleton eagerly, like this:
Go ahead and create an instance of Singleton in a static initializer.
Once in the block, check again and if still null, create an instance.
The volatile keyword ensures that multiple threads handle the uniqueInstance variable correctly when it is being initialized to the Singleton instance.
If  performance is an issue in your use of  the getInstance() method then this method of implementing the Singleton can drastically reduce the overhead.
Use  “double-checked locking” to reduce the use of synchronization in getInstance() With double-checked locking, we ﬁrst check to see if  an instance is created, and if  not, THEN we synchronize.
This way, we only synchronize the ﬁrst time through, just what we want.
While we’ve been off  diagnosing the multithreading problems, the chocolate boiler has been cleaned up and is ready to go.
But ﬁ rst, we have to ﬁ x the multithreading problems.
We have a few solutions at hand, each with different tradeoffs, so which solution are  we going to employ?
For each solution, describe its applicability to the problem of ﬁ xing the Chocolate Boiler code:
At this point, the Chocolate Factory is a happy customer and Choc-O-Holic was glad to have some expertise applied to their boiler code.
No matter which multithreading solution you applied, the boiler should be in good shape with no more mishaps.
You’ve not only managed to escape 500lbs of  hot chocolate in this chapter, but you’ve been through all the potential problems of  the Singleton.
Rumors of Singletons being eaten by the garbage collectors are greatly exaggerated.
Prior to Java 1.2, a bug in the garbage collector allowed Singletons to be prematurely collected if there was no global reference to them.
In other words, you could create a Singleton and if the only reference to the Singleton was in the Singleton itself, it would be collected and destroyed by the garbage collector.
This leads to confusing bugs because after the Singleton is.
In many applications, this can cause confusing behavior as state is mysteriously reset to initial values or things like network connections are reset.
Since Java 1.2 this bug has been ﬁxed and a global reference is no longer required.
If you are, for some reason, still using a pre-Java 1.2 JVM, then be aware of this issue, otherwise, you can sleep well knowing your Singletons won’t be prematurely collected.
Q: For such a simple pattern consisting of only one class, Singletons sure seem to have some problems.
A: Well, we warned you up front!  But don’t let the problems discourage you;  while implementing Singletons correctly can be tricky, after reading this chapter you are now well informed on the techniques for creating Singletons and should use them wherever you need to control the number of instances you are creating.
Q: Can’t I just create a class in which all methods and variables are deﬁned as static?  Wouldn’t that be the same as a Singleton?
A: Yes, if your class is selfcontained and doesn’t depend on complex initialization.
However, because of the way static initializations are handled in Java, this can get very messy, especially if multiple classes are involved.
Often this scenario can result in subtle, hard to find bugs involving order of initialization.
Unless there is a compelling need to implement your “singleton” this way, it is far better to stay in the object world.
Q: What about class loaders? I  heard there is a chance that two class loaders could each end up with their own instance of Singleton.
A: Yes, that is true as each class loader defines a namespace.
If you have two or more classloaders, you can load the same class multiple times (once in each classloader)
Now, if that class happens to be a Singleton, then since we have more than one version of the class, we also have more than one instance of the Singleton.
So, if you are using multiple classloaders and Singletons, be careful.
One way around this problem is to specify the classloader yourself.
Q: I’ve always been taught that a class should do one thing and one thing only.
For a class to do two things is considered bad OO design.
A: You would be referring to the “One Class, One Responsibility” principle, and yes, you are correct, the Singleton is not only responsible for managing its one instance (and providing global access), it is also responsible for whatever its main role is in your application.
So, certainly it can be argued it is taking on two responsibilities.
Nevertheless, it isn’t hard to see that there is utility in a class managing its own instance; it certainly makes the overall design simpler.
In addition, many developers are familiar with the Singleton pattern as it is in wide use.
That said, some developers do feel the need to abstract out the Singleton functionality.
Q: I wanted to subclass my Singleton code, but I ran into problems.
A: One problem with subclassing Singleton is that the constructor is private.
So, the first thing you’ll have to do is change your constructor so that it’s public or protected.
But then, it’s not really a Singleton anymore, because other classes can instantiate it.
The implementation of Singleton is based on a static variable, so if you do a straightforward subclass, all of your derived classes will share the same instance variable.
So, for subclassing to work, implementing registry of sorts is required in the base class.
Before implementing such a scheme, you should ask yourself what you are really gaining from subclassing a Singleton.
Like most patterns, the Singleton is not necessarily meant to be a solution that can fit into a library.
In addition, the Singleton code is trivial to add to any existing class.
Last, if you are using a large number of Singletons in your application, you should take a hard look at your design.
Q: I still don’t totally understand why global variables are worse than a Singleton.
A: In Java, global variables are basically static references to objects.
There are a couple of disadvantages to using global variables in this manner.
We’ve already mentioned one: the issue of lazy versus eager instantiation.
But we need to keep in mind the intent of the pattern: to ensure only one instance of a class exists and to provide global access.
A global variable can provide the latter, but not the former.
Global variables also tend to encourage developers to pollute the namespace with lots of global references to small objects.
Singletons don’t encourage this in the same way, but can be abused nonetheless.
Singleton gives you another method of creating objects – in this case, unique objects.objects.
As you’ve seen, despite its apparent simplicity, there are a lot of details.
Sit back, open that case of chocolate that you were sent for solving the multithreading problem, and have some downtime working on this little crossword puzzle; all of the solution words are from this chapter.
Can you help Choc-O-Holic improve their ChocolateBoiler class by turning it into a singleton?
Two different objects are returned!  We have two ChocolateBoiler instances!!!
For each solution, describe its applicability to the problem of ﬁxing the Chocolate Boiler code:
We are always going to instantiate the chocolate boiler in our code, so statically inializing the.
Given we have no performance concerns, double-checked locking seems like overkill.
In this chapter, we take encapsulation to a whole new level: we’re going to encapsulate method invocation.
That’s right, by encapsulating method invocation, we can crystallize pieces of computation so that the.
I just drop in my request and people disappear, governments change overnight and my dry cleaning.
I don’t have to worry about when, where, or how; it.
I’m also enclosing a set of  Java classes on CD-R that were.
We’d like you to create an API for programming the remote.
Note that it is important that we be ab le to control.
There are “on” and “off” buttons for each of the seven slots.
Here’s the global “undo” button that undoes the last button pressed.
These two buttons are used to control the household device stored in slot one...
Taking a look at the vendor classes Check out the vendor classes on the CD-R.
These should give you some idea of  the interfaces of  the objects we need to control from the remote.
It looks like we have quite a set of  classes here, and not a lot of industry effort to come up with a set of  common interfaces.
Not only that, it sounds like we can expect more of  these classes in the future.
Designing a remote control API is going to be interesting.
Mary: Yes, I thought we’d see a bunch of  classes with on() and off() methods, but here we’ve got methods like dim(), setTemperature(), setVolume(), setDirection()
Sue: Not only that, it sounds like we can expect more vendor classes in the future with just as diverse methods.
Mary: I think it’s important we view this as a separation of concerns: the remote should know how to interpret button presses and make requests, but it shouldn’t know a lot about home automation or how to turn on a hot tub.
But if  the remote is dumb and just knows how to make generic requests, how do we design the remote so that it can invoke an action that, say, turns on a light or opens a garage door?
Mary: I’m not sure, but we don’t want the remote to have to know the speciﬁcs of  the vendor classes.
Whenever a new vendor class comes out, we’d have to go in and modify the code, potentially creating bugs and more work for ourselves!
Your teammates are already discussing how to design the remote control API...
My ﬁrst observation is that we’ve got a simple remote with on and off buttons but a set of vendor classes that are quite.
Joe: The Command Pattern allows you to decouple the requester of  an action from the object that actually performs the action.
So, here the requester would be the remote control and the object that performs the action would be an instance of  one of  your vendor classes.
Sue: How is that possible? How can we decouple them?  After all, when I press a button, the remote has to turn on a light.
Joe: You can do that by introducing “command objects” into your design.
A command object encapsulates a request to do something (like turn on a light) on a speciﬁc object (say, the living room light object)
So, if  we store a command object for each button, when the button is pressed we ask the command object to do some work.
The remote doesn’t have any idea what the work is, it just has a command object that knows how to talk to the right object to get the work done.
So, you see, the remote is decoupled from the light object!
Sue: This certainly sounds like it’s going in the right direction.
Mary: Still, I’m having a hard time wrapping my head around the pattern.
Joe: Given that the objects are so decoupled, it’s a little difﬁcult to picture how the pattern actually works.
Mary: Let me see if  I at least have the right idea: using this pattern we, could create an API in which these command objects can be loaded into button slots, allowing the remote code to stay very simple.
And, the command objects encapsulate how to do a home automation task along with the object that needs to do it.
I also think this pattern can help you with that Undo button, but I haven’t studied that part yet.
Mary: This sounds really encouraging, but I think I have a bit of  work to do to really “get” the pattern.
The Waitress takes the Order, places it on the order counter and says “Order up!”
As Joe said, it is a little hard to understand the Command Pattern by just hearing its description.
But don’t fear, we have some friends ready to help: remember our friendly diner from Chapter 1?  It’s been a while since we visited Alice, Flo, and the short-order cook, but we’ve got good reason for returning (well, beyond the food and great conversation): the diner is going to help us understand the Command Pattern.
So, let’s take a short detour back to the diner and study the interactions between the customers, the waitress, the orders and the short-order cook.
Through these interactions, you’re going to understand the objects involved in the Command Pattern and also get a feel for how the decoupling works.
After that, we’re going to knock out that remote control API.
The customer knows what he wants and creates an order.
The Waitress takes the Order, and when she gets around to it, she calls its orderUp() method to begin the Order’s preparation.
The Short Order Cook follows the instructions of the Order and produces the meal.
An Order Slip encapsulates a request to prepare a meal.
Think of  the Order Slip as an object, an object that acts as a request to prepare a meal.
Like any object, it can be passed around – from the Waitress to the order counter, or to the next Waitress taking over her shift.
It has an interface that consists of  only one method, orderUp(), that encapsulates the actions needed to prepare the meal.
It also has a reference to the object that needs to prepare it (in our case, the Cook)
It’s encapsulated in that the Waitress doesn’t have to know what’s in the order or even who prepares the meal; she only needs to pass the slip through the order window and call “Order up!” Okay, in real life a waitress would probably.
The Waitress’s job is to take Order Slips and invoke the orderUp() method on them.
The Waitress has it easy: take an order from the customer, continue helping customers until she makes it back to the order counter, then invoke the orderUp() method to have the meal prepared.
As we’ve already discussed, in Objectville, the Waitress really isn’t worried about what’s on the order or who is going to prepare it; she just knows order slips have an orderUp() method she can call to get the job done.
Now, throughout the day, the Waitress’s takeOrder() method gets parameterized with different order slips from different customers, but that doesn’t phase her; she knows all Order slips support the orderUp() method and she can call orderUp() any time she needs a meal prepared.
Don’t ask me to cook, I just take orders and.
The Short Order Cook has the knowledge required to prepare the meal.
The Short Order Cook is the object that really knows how to prepare meals.
Once the Waitress has invoked the orderUp() method; the Short Order Cook takes over and implements all the methods that are needed to create meals.
Notice the Waitress and the Cook are totally decoupled: the Waitress has Order Slips that encapsulate the details of  the meal; she just calls a method on each order to get it prepared.
Likewise, the Cook gets his instructions from the Order Slip; he never needs to directly communicate with the Waitress.
Before we move on, spend some time studying the diagram two pages back along with Diner roles and responsibilities until you think you’ve got a handle on the Objectville Diner objects and relationships.
Once you’ve done that, get ready to nail the Command Pattern!
Okay, we have a Diner with a Waitress who is.
Think of  the Diner as a model for an OO design pattern that allows us to separate an object making a request from the objects that receive and execute those requests.
For instance, in our remote control API, we need to separate the code that gets invoked when we press a button from the objects of  the vendor-speciﬁ c classes that carry out those requests.
What if  each slot of  the remote held an object like the Diner’s order slip object? Then, when a button is pressed, we could just call the equivalent of  the “orderUp()” method on this object and have the lights turn on without the remote knowing the details of  how to make those things happen or what objects are making them happen.
Now, let’s switch gears a bit and map all this Diner talk to the Command Pattern...
The client calls setCommand() on an Invoker object and passes it the command object, where it gets stored until it is needed.
The actions and the Receiver are bound together in the command object.
From the Diner to the Command Pattern Okay, we’ve spent enough time in the Objectville Diner that we know all the personalities and their responsibilities quite well.
Now we’re going to rework the Diner diagram to reﬂ ect the Command Pattern.
You’ll see that all the players are the same; only the names have changed.
The client does a setCommand() to store the command object in the invoker.
Note: as you’ll see later in the chapter, once the command is loaded into the invoker, it may be used and discarded, or it may remain and be used many times.
Match the diner objects and methods with the corresponding names from the Command Pattern.
Our first  command object Isn’t it about time we build our ﬁ rst command object?  Let’s go ahead and write some code for the remote control.
While we haven’t ﬁ gured out how to design the remote control API yet, building a few things from the bottom up may help us...
Now, let’s say you want to  implement a command for turning a light on.
Referring to our set of  vendor classes, the Light class has two methods: on() and off()
Now that you’ve got a LightOnCommand class, let’s see if  we can put it to use...
This is a command, so we need to implement the Command interface.
Using the command object Okay, let’s make things simple: say we’ve got a remote control with only one button and corresponding slot to hold a device to control:
Here’s just a bit of  code to test out the simple remote control.
Let’s take a look and we’ll point out how the pieces match the Command Pattern diagram:
All we do is take the current command bound to the slot and call its execute() method.
Here, create a command and pass the Receiver to it.
The Command Pattern encapsulates a request as an object, thereby letting you parameterize other objects with different requests, queue or log requests, and support undoable operations.
You’ve done your time in the Objectville Diner, you’ve partly implemented the remote control API, and in the process you’ve got a fairly good picture of  how the classes and objects interact in the Command Pattern.
Now we’re going to deﬁne the  Command Pattern and nail down all the details.
We know that a command object encapsulates a request by binding together a set of  actions on a speciﬁc receiver.
To achieve this, it packages the actions and the receiver up into an object that exposes just one method, execute()
When called, execute() causes the actions to be invoked on the receiver.
From the outside, no other objects really know what actions get performed on what receiver; they just know that if  they call the execute() method, their request will be serviced.
We’ve also seen a couple examples of  parameterizing an object with a command.
Back at the diner, the Waitress was parameterized with multiple orders throughout the day.
In the simple remote control, we ﬁrst loaded the button slot with a “light on” command and then later replaced it with a “garage door open” command.
Like the Waitress, your remote slot didn’t care what command object it had, as long as it implemented the Command interface.
What we haven’t encountered yet is using commands to implement queues and logs and support undo operations.
Don’t worry, those are pretty straightforward extensions of  the basic Command Pattern and we will get to them soon.
We can also easily support what’s known as the Meta Command Pattern once we have the basics in place.
The Meta Command Pattern allows you to create macros of  commands so that you can execute multiple commands at once.
The Receiver knows how to perform the work needed to carry out the request.
The Invoker holds a command and at some point asks the command to carry out a request by calling its execute() method.
How does the design of the Command Pattern support the decoupling of the invoker of a request and the receiver of the request?
Sue:  Like we did in the SimpleRemote, we need to provide a way to assign commands to slots.
In our case we have seven slots, each with an “on” and “off ” button.
So we might assign commands to the remote something like this:
Okay, I think I’ve got a good feel for the Command Pattern now.
Great tip Joe,  I think we are going to look.
How does the remote know the living room from the kitchen light?
Sue: Ah, that’s just it, it doesn’t!  The remote doesn’t know anything but how to call execute() on the corresponding command object when a button is pressed.
Mary: Yeah, I sorta got that, but in the implementation, how do we make sure the right objects are turning on and off  the right devices?
Sue: When we create the commands to be loaded into the remote, we create one LightCommand that is bound to the living room light object and another that is bound to the kitchen light object.
Remember, the receiver of  the request gets bound to the command it’s encapsulated in.
So, by the time the button is pressed, no one cares which light is which, the right thing just happens when the execute() method is called.
Let’s implement the remote and I think this will get clearer!
Assigning Commands to slots So we have a plan: We’re going to assign each slot to a command in the  remote control.
When a button is pressed the execute() method is going to be called on the corresponding command, which results in actions being invoked on the receiver (like lights, ceiling fans, stereos)
When the button is pressed, the execute() method is called on the corresponding command.
In the execute() method actions are invoked on the reciever.
In the constructor all we need to do is instantiate and initialize the on and off arrays.
The setCommand() method takes a slot position and an On and Off command to be stored in that slot.
It puts these commands in the on and off arrays for later use.
We’ve overwritten toString() to print out each slot and its corresponding command.
You’ll see us use this when we test the remote control.
We can plug that same code in here and everything works beautifully.
Off  commands are no different; in fact the LightOffCommand looks like this:
The LightOffCommand works exactly the same way as the LightOnCommand, except that we are binding the receiver to a different action: the off() method.
Let’s try something a little more challenging; how about writing on and off commands for the Stereo? Okay, off  is easy, we just bind the Stereo to the off() method in the StereoOffCommand.
Take a look at the rest of  the vendor classes; by now, you can deﬁ nitely knock out the rest of  the Command classes we need for those.
Our job with the remote is pretty much done; all we need to do is run some tests and get some documentation together to describe the API.
Living Room light is on Living Room light is off Kitchen light is on Kitchen light is off Living Room ceiling fan is on high Living Room ceiling fan is off Living Room stereo is on Living Room stereo is set for CD input Living Room Stereo volume set to 11 Living Room stereo is off.
Now that we’ve got all our commands, we can load them into the remote slots.
Here’s where we use our toString() method to print each remote slot and the command that it is assigned to.
All right, we are ready to roll! Now, we step through each slot and push its On and Off button.
Now, let’s check out the execution of our remote control test...
Our commands in action!  Remember, the output from each device comes from the vendor classes.
For instance, when a light object is turned on it prints “Living Room light is on.”
In the remote control, we didn’t want to check to see if  a command was loaded every time we referenced a slot.
So, how do we get around that?  Implement a command that does nothing!
Then, in our RemoteControl constructor, we assign every slot a NoCommand object by default and we know we’ll always have some command to call in each slot.
So in the output of  our test run, you are seeing slots that haven’t been assigned to a command, other than the default NoCommand object which we assigned when we created the RemoteControl.
The NoCommand object is an example of a null object.
A null object is useful when you don’t have a meaningful object to return, and yet you want to remove the responsibility for handling null from the client.
For instance, in our remote control we didn’t have a meaningful object to assign to each slot out of the box, so we provided a NoCommand object that  acts as a surrogate and does nothing when its execute method is called.
You’ll find uses for Null Objects in conjunction with many Design Patterns and sometimes you’ll even see Null Object listed as a Design Pattern.
We are pleased to present you with the following design and application prog.
Our prim ary design goal was to keep the remot.
The following class diagram provides a n overview of our design:
Using the Command Interface,  each ac tion that can be.
Let’s step through adding undo to our commands and to the remote control...
What are we doing? Okay, we need to add functionality to support the undo button on the remote.
It works like this: say the Living Room Light is off  and you press the on button on the remote.
Now if  you press the undo button then the last action will be reversed – in this case the light will turn off.
Before we get into more complex examples, let’s get the light working with the undo button:
When commands support undo, they have an undo() method that mirrors the execute() method.
So, before we can add undo to our commands, we need to add an undo() method to the Command interface:
Now, let’s dive into the Light command and implement the undo() method.
Could this be any easier?  Okay, we aren’t done yet; we need to work a little support into the Remote Control to handle tracking the last button pressed and the undo button press.
Here the undo() method just needs to call the Light’s on() method.
Let’s start with the LightOnCommand: if  the LightOnCommand’s execute() method was called, then the on() method was last called.
We know that undo() needs to do the opposite of  this by calling the off() method.
To add support for the undo button we only have to make a few small changes to the Remote Control class.
Here’s how we’re going to do it:  we’ll add a new instance variable to track the last command invoked; then, whenever the undo button is pressed, we retrieve that command and invoke its undo() method.
Just like the other slots, undo starts off with a NoCommand, so pressing undo before any other button won’t do anything at all.
When a button is pressed, we take the command and first execute it; then we save a reference to it in the undoCommand instance variable.
We do this for both “on” commands and “off” commands.
When the undo button is pressed, we invoke the undo() method of the command stored in undoCommand.
Okay, let’s rework the test harness a bit to test the undo button:
Okay, implementing  undo on the Light was instructive but a little too easy.
Typically, we need to manage a bit of  state to implement undo.
Let’s try something a little more interesting, like the CeilingFan from the vendor classes.
The ceiling fan allows a number of  speeds to be set along with an off  method.
Now let’s tackle adding  undo to the various CeilingFan commands.
To do so, we need to track the last speed setting of  the fan and, if  the undo() method is called, restore the fan to its previous setting.
In execute, before we change the speed of the fan, we need to first record its previous state, just in case we need to undo our actions.
To undo, we set the speed of the fan back to its previous speed.
We’ve got three more ceiling fan commands to write: low, medium, and off.
Time to load up our remote control with the ceiling fan commands.
We’re going to load slot zero’s on button with the medium setting for the fan and slot one with the high setting.
Both corresponding off  buttons will hold the ceiling fan off  command.
And, one more undo; it should go back to medium.
Living Room ceiling fan is on medium Living Room ceiling fan is off.
Living Room ceiling fan is on medium Living Room ceiling fan is on high.
One more undo, and the ceiling fan goes back to medium speed.
Turn the ceiling fan on medium, then turn it off.
Undo the last command, and it goes back to medium.
Okay, let’s ﬁre up the remote, load it with commands, and push some buttons!
Mary’s idea is to make a new kind of Command that can execute other Commands...
Take an array of Commands and store them in the MacroCommand.
When the macro gets executed by the remote, execute those commands one at a time.
What’s the point of having a remote if you can’t push one button and have the lights dimmed, the stereo and TV turned on and set to a DVD and the hot tub ﬁ red up?
Using a macro command Let’s step through how we use a macro command:
First we create the set of  commands we want to go into the macro:
Sharpen your pencil We will also need commands for the off  buttons, write the code to create those here:
Next we create two arrays, one for the On commands and one for the Off  commands, and load them with the corresponding commands:
Then we assign MacroCommand to a button like we always do:
Create all the devices, a light, tv, stereo, and hot tub.
Assign the macro command to a button as we would any command.
All the Commands in the macro are executed when we invoke the on macro...
Finally, we just need to push some buttons and see if  this works.
Q: Do I always need a receiver? Why can’t the command object implement the details of the execute() method?
A: In general, we strive for “dumb” command objects that just invoke an action on a receiver; however, there are many examples of “smart” command objects that implement most, if not all, of the logic needed to carry out a request.
Certainly you can do this; just keep in mind you’ll no longer have the same level of decoupling between the invoker and receiver, nor will you be able to parameterize your commands with receivers.
Q: How can I implement a history of undo operations?  In other words, I want to be able to press the undo button multiple times.
A: Great question!  It’s pretty easy actually; instead of keeping just a reference to the last Command executed, you keep a stack of previous commands.
Then, whenever undo is pressed, your invoker pops the first item off the stack and calls its undo() method.
Q: Could I have just implemented Party Mode as a Command by creating a PartyCommand and putting the calls to execute the other Commands in the PartyCommand’s execute() method?
A: You could; however, you’d essentially be  “hardcoding” the party mode into the PartyCommand.
Why go to the trouble?  With the MacroCommand, you can decide dynamically which Commands you want to go into the PartyCommand, so you have more flexibility using MacroCommands.
In general, the MacroCommand is a more elegant solution and requires less new code.
The only thing our MacroCommand is missing its undo functionality.
When the undo button is pressed after a macro command, all the commands that were invoked in the macro must undo their previous actions.
Here’s the code for MacroCommand; go ahead and implement the undo() method:
Note that the job queue classes are totally decoupled from the objects that are doing the computation.
One minute a thread may be computing a ﬁnancial computation, and the next it may be retrieving something from the network.
The job queue objects don’t care; they just retrieve commands and call execute()
Likewise, as long as you put objects into the queue that implement the Command Pattern, your execute() method will be invoked when a thread is available.
Threads remove commands from the queue one by one and call their execute() method.
Once complete, they go back for a new command object.
How might a web server make use of such a queue?  What other applications can you think of?
Commands give us a way to package a piece of computation (a receiver and a set of  actions) and pass it around as a ﬁrst-class object.
Now, the computation itself may be invoked long after some client application creates the command object.
In fact, it may even be invoked by a different thread.
We can take this scenario and apply it to many useful applications such as schedulers, thread pools and job queues, to name a few.
Imagine a job queue: you add commands to the queue on one end, and on the other end sit a group of  threads.
Threads run the following script: they remove a command from the queue, call its execute() method, wait for the call to ﬁnish, then discard the command object and retrieve a new one.
The semantics of  some applications require that we log all actions and be able to recover after a crash by reinvoking those actions.
The Command Pattern can support these semantics with the addition of  two methods: store() and load()
In Java we could use object serialization to implement these methods, but the normal caveats for using serialization for persistence apply.
How does this work?  As we execute commands, we store a history of  them on disk.
When a crash occurs, we reload the command objects and invoke their execute() methods in batch and in order.
Now, this kind of  logging wouldn’t make sense for a remote control; however, there are many applications that invoke actions on large data structures that can’t be quickly saved each time a change is made.
By using logging, we can save all the operations since the last check point, and if  there is a system failure, apply those operations to our checkpoint.
Take, for example, a  spreadsheet application: we might want to implement our failure recovery by logging the actions on the spreadsheet rather than writing a copy of  the spreadsheet to disk every time a change occurs.
In more advanced applications, these techniques can be extended to apply to sets of  operations in a transactional manner so that all of  the operations complete, or none of  them do.
Tools for your   Design Toolbox Your toolbox is starting to get heavy!  In this chapter we’ve added a pattern that allows us to encapsulate methods into Command objects:  store them, pass them around, and invoke them when you need them.
Time to take a breather and let it all sink in.
It’s another crossword; all of the solution words are from this chapter.
Match the diner objects and methods with the corresponding names from the Command Pattern.
Sharpen your pencil We will also need commands for the off  button.
In this chapter we’re going to attempt such impossible feats as putting a square peg in a round hole.
Remember the Decorator Pattern?  We wrapped objects to give them new.
Now we’re going to wrap some objects with a different purpose: to make their.
Why would we do that?  So we can adapt a design expecting one interface to a class that implements a different interface.
Do you think the readers are really getting the impression we’re watching a horse race rather than.
You know what the adapter does: it sits in between the plug of  your laptop and the European AC outlet; its job is to adapt the European outlet so that you can plug your laptop into it and receive power.
Or look at it this way: the adapter changes the interface of  the outlet into one that your laptop expects.
Some AC adapters are simple – they only change the shape of  the outlet so that it matches your plug, and they pass the AC current straight through – but other adapters are more complex internally and may need to step the power up or down to match your devices’ needs.
Okay, that’s the real world, what about object oriented adapters? Well, our OO adapters play the same role as their real world counterparts: they take an interface and adapt it to one that a client is expecting.
Adapters all around us You’ll have no trouble understanding what an OO adapter is because the real world is full of them.
How’s this for an example: Have you ever needed to use a US-made laptop in a European country? Then you’ve probably needed an AC power adapter...
Say you’ve got an existing software system that you need to work a new vendor class library into, but the new vendor designed their interfaces differently than the last vendor:
Okay, you don’t want to solve the problem by changing your existing code (and you can’t change the vendor’s code)
So what do you do?  Well, you can write a class that adapts the new vendor interface into the one you’re expecting.
The adapter acts as the middleman by receiving requests from the client and converting them into requests that make sense on the vendor classes.
If it walks like a duck and quacks like a duck, then it must might be a duck turkey wrapped with a duck adapter...
Remember our ducks from Chapter 1?  Let’s review a slightly simpliﬁed version of the Duck interfaces and classes:
Now it’s time to meet the newest fowl on the block:
Turkeys can fly, although they can only fly short distances.
Now, let’s say you’re short on Duck objects and you’d like to use some Turkey objects in their place.
Obviously we can’t use the turkeys outright because they have a different interface.
Code Up Close First, you need to implement the interface of the type you’re adapting to.
Next, we need to get a reference to the object that we are adapting; here we do that through the constructor.
Now we need to implement all the methods in the interface; the quack() translation between classes is easy: just call the gobble() method.
Even though both interfaces have a fly() method, Turkeys fly in short spurts - they can’t do long-distance flying like ducks.
To map between a Duck’s fly() method and a Turkey’s, we need to call the Turkey’s fly() method five times to make up for it.
Gobble gobble I’m ﬂying a short distance I’m ﬂying a short distance I’m ﬂying a short distance I’m ﬂying a short distance I’m ﬂying a short distance.
Now we just need some code to test drive our adapter:
Now let’s test the duck by calling the testDuck() method, which expects a Duck object.
Then, let’s test the Turkey: make it gobble, make it fly.
Here’s our testDuck() method; it gets a duck and calls its quack() and fly() methods.
The Adapter implements the target interface and holds an instance of the Adaptee.
Now that we have an idea of  what an Adapter is, let’s step back and look at all the pieces again.
The client makes a request to the adapter by calling a method on it using the target interface.
The adapter translates the request into one or more calls on the adaptee using the adaptee interface.
The client receives the results of the call and never knows there is an adapter doing the translation.
Sharpen your pencil Let’s say we also need an Adapter that converts a Duck to a Turkey.
How did you handle the ﬂy method (after all we know ducks ﬂy longer than turkeys)?  Check the answers at the end of the chapter for our solution.
Q: How much “adapting” does an adapter need to do?  It seems like if I need to implement a large target interface, I could have a LOT of work on my hands.
The job of implementing an adapter really is proportional to the size of the interface you need to support as your target interface.
You could rework all your client-side calls to the interface, which would result in a lot of investigative work and code changes.
Or, you can cleanly provide one class that encapsulates all the changes in one class.
Q: Does an adapter always wrap one and only one class?
A: The Adapter Pattern’s role is to convert one interface into another.
While most examples of the adapter pattern show an adapter wrapping one adaptee, we both know the world is often a bit more messy.
So, you may well have situations where an adapter holds two or more adaptees that are needed to implement the target interface.
This relates to another pattern called the Facade Pattern; people often confuse the two.
Remind us to revisit this point when we talk about facades later in this chapter.
Q: What if I have old and new parts of my system, the old parts expect the old vendor interface, but we’ve already written the new parts to use the new vendor interface?  It is going to get confusing using an adapter here and the unwrapped interface there.
Wouldn’t I be better off just writing my older code and forgetting the adapter?
One thing you can do is create a Two Way Adapter that supports both interfaces.
To create a Two Way Adapter, just implement both interfaces involved, so the adapter can act as an old interface or a new interface.
The Adapter Pattern converts the interface of  a class into another interface the clients expect.
Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.
Enough ducks, turkeys and AC power adapters; let’s get real and look at the ofﬁ cial deﬁ nition of  the Adapter Pattern:
Now, we know this pattern allows us to use a client with an incompatible interface by creating an Adapter that does the conversion.
This acts to decouple the client from the implemented interface, and if  we expect the interface to change over time, the adapter encapsulates that change so that the client doesn’t have to be modiﬁ ed each time it needs to operate against a different interface.
We’ve taken a look at the runtime behavior of  the pattern; let’s take a look at its class diagram as well:
The Adapter Pattern is full of  good OO design principles: check out the use of  object composition to wrap the adaptee with an altered interface.
This approach has the added advantage that we can use an adapter with any subclass of  the adaptee.
Also check out how the pattern binds the client to an  interface, not an implementation; we could use several adapters, each converting a different backend set of  classes.
Or, we could add new implementations after the fact, as long as they adhere to the Target interface.
Now despite having deﬁ ned the pattern, we haven’t told you the whole story yet.
There are actually two kinds of  adapters:   object adapters and class adapters.
This chapter has covered object adapters and the class diagram on the previous page is a diagram of  an object adapter.
So what’s a class adapter and why haven’t we told you about it?  Because you need multiple inheritance to implement it, which isn’t possible in Java.
But, that doesn’t mean you might not encounter a need for class adapters down the road when using your favorite multiple inheritance language!  Let’s look at the class diagram for multiple inheritance.
Look familiar?  That’s right – the only difference is that with class adapter we subclass the Target and the Adaptee, while with object adapter we use composition to pass requests to an Adaptee.
Object adapters and class adapters use two different means of adapting the adaptee (composition versus inheritance)
How do these implementation differences affect the ﬂ exibility of the adapter?
Your job is to take the duck and turkey magnets and drag them over the part of  the diagram that describes the role played by that bird, in our earlier example.
Then add your own annotations to describe how it works.
Drag these onto the class diagram, to show which part of the diagram represents the Duck and which represents the Turkey.
The Adapter lets the Turkey respond to requests on a Duck, by extending BOTH classes (Duck and Turkey)
Note: the class adapter uses multiple inheritance, so you can’t do it in Java...
The Turkey class doesn’t have the same interface as the Duck.
The Adapter implements the Duck interface, but when it gets a method call it turns around and delegates the calls to a Turkey.
I can not only adapt an adaptee class, but any of  its subclasses.
That’s true, I do have trouble with that because I am committed to one speciﬁc adaptee class, but I have a huge advantage because I don’t have to reimplement my entire adaptee.
I can also override the behavior of  my adaptee if  I need to because I’m just subclassing.
Using a class adapter there is just one of  me, not an adapter and an adaptee.
In my part of  the world, we like to use composition over inheritance; you may be saving a few lines of  code, but all I’m doing is writing a little code to delegate to the adaptee.
You’re worried about one little object? You might be able to quickly override a method, but any behavior I add to my adapter code works with my adaptee class and all its subclasses.
Hey, come on, cut me a break, I just need to compose with the subclass to make that work.
Yeah, but what if  a subclass of  adaptee adds some new behavior.
If  you’ve been around Java for a while you probably remember that the early collections types (Vector, Stack, Hashtable, and a few others) implement a method elements(), which returns an  Enumeration.
The Enumeration interface allows you to step through the elements of  a collection without knowing the speciﬁ cs of  how they are managed in the collection.
When Sun released their more recent Collections classes they began using an Iterator interface that, like Enumeration, allows you to iterate through a set of  items in a collection, but also adds the ability to remove items.
We are often faced with legacy code that exposes the Enumerator interface, yet we’d like for our new code to use only Iterators.
Let’s take a look at the use of  a simple Adapter in the real world (something more serious than Ducks at least)...
These two methods look easy, they map straight to hasNext() and next() in Iterator.
But what about this method remove() in Iterator?  There’s nothing like that in Enumeration.
Here’s what the classes should look like: we need an adapter that implements the Target interface and that is composed with an adaptee.
The hasNext() and next() methods are going to be straightforward to map from target to adaptee: we just pass them right through.
But what do you do about remove()?  Think about it for a moment (and we’ll deal with it on the next page)
Your new code still gets to use Iterators, even if there’s really an Enumeration underneath.
We’re making the Enumerations in your old code look like Iterators for your new code.
First we’ll look at the two interfaces to ﬁ gure out how the methods map from one to the other.
In other words, we’ll ﬁ gure out what to call on the adaptee when the client invokes a method on the target.
We’re using composition so we stash it in an instance variable.
The Iterator’s hasNext() method is delegated to the Enumeration’s hasMoreElements() method...
There’s no way to implement a fully functioning remove() method on the adapter.
The best we can do is throw a runtime exception.
This is a case where the adapter isn’t perfect; clients will have to watch out for potential exceptions, but as long as the client is careful and the adapter is well documented this is a perfectly reasonable solution.
While Java has gone in the direction of  the Iterator, there is nevertheless a lot of legacy client code that depends on the Enumeration interface, so an Adapter that converts an Iterator to an Enumeration is also quite useful.
Write an Adapter that adapts an Iterator to an Enumeration.
The ArrayList class supports the Iterator interface but doesn’t support Enumerations (well, not yet anyway)
Some AC adapters do more than just change the interface – they add other features like surge protection, indicator lights and other bells and whistles.
If you were going to implement these kinds of features, what pattern would you use?
My job is all about responsibility you know that when a Decorator is involved there’s going to be some new responsibilities or behaviors added to your design.
You guys want all the glory while us adapters are down in the trenches doing the dirty work: converting interfaces.
Our jobs may not be glamorous, but our clients sure do appreciate us making their lives simpler.
Don’t think we get all the glory; sometimes I’m just one decorator that is being wrapped by who knows how many other decorators.
When a method call gets delegated to you, you have no idea how many other decorators have already dealt with it and you don’t know that you’ll ever get noticed for your efforts servicing the request.
Try being an adapter when you’ve got to bring several classes together to provide the interface your client is expecting.
But we have a saying: “an uncoupled client is a happy client.”
That may be true, but don’t think we don’t work hard.
When we have to decorate a big interface, whoa, that can take a lot of  code.
Hey, if  adapters are doing their job, our clients never even know we’re there.
But, the great thing about us adapters is that we allow clients to make use of  new libraries and subsets without changing any code, they just rely on us to do the conversion for them.
Well us decorators do that as well, only we allow new behavior to be added to classes without altering existing code.
I still say that adapters are just fancy decorators – I mean, just like us, you wrap an object.
We always convert the interface of  what we wrap, you never do.
I’d say a decorator is like an adapter; it is just that you don’t change the interface!
Our job in life is to extend the behaviors or responsibilities of  the objects we wrap, we aren’t a simple pass through.
Hey, who are you calling a simple pass through?  Come on down and we’ll see how long you last converting a few interfaces!
We seem to look somewhat similar on paper, but clearly we are miles apart in our intent.
You’ve seen how the Adapter Pattern converts the interface of  a class into one that a client is expecting.
You also know we achieve this in Java by wrapping the object that has an incompatible interface with an object that implements the correct one.
We’re going to look at a pattern now that alters an interface, but for a different reason: to simplify the interface.
It’s aptly named the Facade Pattern because this pattern hides all the complexity of  one or more classes behind a clean, well-lit facade.
Before we dive into the details of  the Facade Pattern, let’s take a look at a growing national obsession: building your own home theater.
You’ve done your research and you’ve assembled a killer system complete with a DVD player, a projection video system, an automated screen, surround sound and even a popcorn popper.
You’ve spent weeks running wire, mounting the projector, making all the connections and ﬁ ne tuning.
Now it’s time to put it all in motion and enjoy a movie...
That’s a lot of classes, a lot of interactions, and a big set of interfaces to learn and use.
Pick out a DVD, relax, and get ready for movie magic.
Oh, there’s just one thing – to watch the movie, you need to perform a few tasks:
Start the popper popping Dim the lights Put the screen down Turn the projector on.
Put the projector on wide-screen mode Turn the sound ampliﬁer on.
Set the ampliﬁer to DVD input Set the ampliﬁer to surround sound Set the ampliﬁer volume to medium (5) Turn the DVD Player on Start the DVD Player playing.
Turn on the amp, set it to DVD , put.
Let’s check out those same tasks in terms of the classes and the method calls needed to perform them:
So what to do?  The complexity of  using your home theater is becoming apparent!
Let’s see how the Facade Pattern can get us out of  this mess so we can enjoy the movie...
A Facade is just what you need:  with the  Facade Pattern you can take a complex subsystem and make it easier to use by implementing a Facade class that provides one, more reasonable interface.
Don’t worry; if  you need the power of  the complex subsystem, it’s still there for you to use, but if  all you need is a straightforward interface, the Facade is there for you.
The Facade class treats the home theater components as a subsystem, and calls on the subsystem to implement its watchMovie() method.
The Facade still leaves the subsystem accessible to be used directly.
If you need the advanced functionality of the subsystem classes, they are available for your use.
Q: If the Facade encapsulates the subsystem classes, how does a client that needs lower-level functionality gain access to them?
A: Facades don’t “encapsulate” the subsystem classes; they merely provide a simplified interface to their functionality.
The subsystem classes still remain available for direct use by clients that need to use more specific interfaces.
This is a nice property of the Facade Pattern: it provides a simplified interface while still exposing the full functionality of the system to those who may need it.
Q: Does the facade add any functionality or does it just pass through each request to the subsystem?
A: A facade is free to add its own “smarts” in addition to making use of the subsystem.
For instance, while our home theater facade doesn’t implement any new behavior, it is smart enough to know that the popcorn popper has to be turned on before it can pop (as well as the details of how to turn on and stage a movie showing)
The pattern certainly allows for any number of facades to be created for a given subsystem.
Q: What is the benefit of the facade other than the fact that I now have a simpler interface?
A: The Facade Pattern also allows you to decouple your client implementation from any one subsystem.
Let’s say for instance that you get a big raise and decide to upgrade your home theater to all new components that have different interfaces.
Q: So the way to tell the difference between the Adapter Pattern and the Facade Pattern is that the adapter wraps one class and the facade may represent many classes?
A: No!  Remember, the Adapter Pattern changes the interface of one or more classes into one interface that a client is expecting.
While most textbook examples show the adapter adapting one class, you may need to adapt many classes to provide the interface a client is coded to.
Likewise, a Facade may provide a simplified interface to a single class with a very complex interface.
The difference between the two is not in terms of how many classes they “wrap,” it is in their intent.
The intent of the Adapter Pattern is to alter an interface so that it matches one a client is expecting.
The intent of the Facade Pattern is to provide a simplified interface to a subsystem.
A facade not only simplifies an interface, it decouples a client from a subsystem of components.
Facades and adapters may wrap multiple classes, but a facade’s intent is to simplify, while an adapter’s is to convert the interface to something different.
Let’s step through the construction of  the HomeTheaterFacade: The ﬁrst step is to use composition so that the facade has access to all the components of  the subsystem:
The facade is passed a reference to each component of the subsystem in its constructor.
The facade then assigns each to the corresponding instance variable.
Implementing the simplified interface Now it’s time to bring the components of  the subsystem together into a uniﬁed interface.
Again, each task is delegated to the appropriate component in the subsystem.
Think about the facades you’ve encountered in the Java API.
Where would you like to have a few new ones?
First you instantiate the Facade with all the components in the subsystem.
Use the simplified interface to first start the movie up, and then shut it down.
Calling the Facade’s watchMovie() does all this work for us...
Here we’re creating the components right in the test drive.
Normally the client is given a facade, it doesn’t have to construct one itself.
The Facade Pattern provides a uniﬁ ed interface to a set of  interfaces in a subsytem.
Facade deﬁ nes a higherlevel interface that makes the subsystem easier to use.
To use the Facade Pattern, we create a class that simpliﬁ es and uniﬁ es a set of  more complex classes that belong to some subsystem.
Unlike a lot of  patterns,  Facade is fairly straightforward; there are no mind bending abstractions to get your head around.
But that doesn’t make it any less powerful: the Facade Pattern allows us to avoid tight coupling between clients and subsystems, and, as you will see shortly, also helps us adhere to a new object oriented principle.
Before we introduce that new principle, let’s take a look at the ofﬁ cial deﬁ nition of  the pattern:
There isn’t a lot here that you don’t already know, but one of  the most important things to remember about a pattern is its intent.
This deﬁ nition tells us loud and clear that the purpose of  the facade it to make a subsystem easier to use through a simpliﬁ ed interface.
That’s it; you’ve got another pattern under your belt!  Now, it’s time for that new OO principle.
Principle of Least Knowledge talk only to your immediate friends.
The Principle of  Least Knowledge guides us to reduce the interactions between objects to just a few close “friends.” The principle is usually stated as:
But what does this mean in real terms?  It means when you are designing a system, for any object, be careful of  the number of  classes it interacts with and also how it comes to interact with those classes.
This principle prevents us from creating designs that have a large number of  classes coupled together so that changes in one part of  the system cascade to other parts.
When you build a lot of  dependencies between many classes, you are building a fragile system that will be costly to maintain and complex for others to understand.
Okay, but how do you keep from doing this? The principle provides some guidelines: take any object;  now from any method in that object, the principle tells us that we should only invoke methods that belong to:
This sounds kind of  stringent doesn’t it? What’s the harm in calling the method of  an object we get back from another call?  Well, if  we were to do that, then we’d be making a request of  another object’s subpart (and increasing the number of  objects we directly know)
In such cases, the principle forces us to ask the object to make the request for us; that way we don’t have to know about its component objects (and we keep our circle of  friends small)
Q: There is another principle called the Law of Demeter; how are they related?
A: The two are one and the same and you’ll encounter these terms being intermixed.
In fact, no principle is a law, all principles should be used when and where they are helpful.
All design involves tradeoffs (abstractions versus speed, space versus time, and so on) and while principles provide guidance, all factors should be taken into account before applying them.
A: Yes; while the principle reduces the dependencies between objects and studies have shown this reduces software maintenance, it is also the case that applying this principle results in more “wrapper” classes being written to handle method calls to other components.
This can result in increased complexity and development time as well as decreased runtime performance.
Here’s a Car class that demonstrates all the ways you can call methods and still adhere to the Principle of  Least Knowledge:
You can call a method on an object passed as a parameter.
You can call a method on an object you create or instantiate.
Here we’re creating a new object, its methods are legal.
Can you think of a common use of Java that violates the Principle of Least Knowledge?
Do either of these classes violate the Principle of Least Knowledge? Why or why not?
The HomeTheaterFacade manages all those subsystem components for the client.
Tools for your   Design Toolbox Your toolbox is starting to get heavy!  In this chapter we’ve added a couple of patterns that allow us to alter interfaces and reduce coupling between clients and the systems they use.between clients and the systems they use.
Sharpen your pencil Do either of these classes violate the Principle of Least Knowledge? For each, why or why not?
Sharpen your pencil Let’s say we also need an adapter that converts a Duck to a Turkey.
We stash a reference to the Duck we are adapting.
We also recreate a random object; take a look at the fly() method to see how it is used.
You’ve seen how to implement an adapter that adapts an Enumeration to an Iterator; now write an adapter that adapts an Iterator to an Enumaration.
We’re on an encapsulation roll; we’ve encapsulated object creation, method invocation, complex interfaces, ducks, pizzas...
We’re even going to learn about a design principle inspired by.
Yeah, he’s a great boss until it comes to getting down in this.
It’s time for some more caffeine Some people can’t live without their coffee; some people can’t live without their tea.
But there’s more; tea and coffee are made in very similar ways.
Let’s play “coding barista” and write some code for creating coffee and tea.
This looks very similar to the one we just implemented in Coffee; the second and forth steps are different, but it’s basically the same recipe.
Notice that these two methods are exactly the same as they are.
Design Puzzle You’ve seen that the Coffee and Tea classes have a fair bit of  code duplication.
Take another look at the Coffee and Tea classes and draw a class diagram showing how you’d redesign the classes to remove redundancy:
It looks like we’ve got a pretty straightforward design exercise on our hands with the Coffee and Tea classes.
Your ﬁ rst cut might have looked something like this:
The prepareRecipe() method differs in each subclass, so it is defined as abstract.
Each subclass overrides the prepareRecipe() method and implements its own recipe.
Did we do a good job on the redesign?  Hmmmm, take another look.
Are we overlooking some other commonality?  What are other ways that Coffee and Tea are similar?
So what else do Coffee and Tea have in common?  Let’s start with the recipes.
Use the hot water to extract the coffee or tea.
So, can we ﬁ nd a way to abstract prepareRecipe() too?  Yes, let’s ﬁ nd out...
The ﬁrst problem we have is that Coffee uses brewCoffeeGrinds() and addSugarAndMilk() methods while Tea uses steepTeaBag() and addLemon() methods.
Let’s step through abstracting prepareRecipe() from each subclass (that is, the Coffee and Tea classes)...
Let’s think through this: steeping and brewing aren’t so different; they’re pretty analogous.
So let’s make a new method name, say, brew(), and we’ll use the same name whether we’re brewing coffee or steeping tea.
Likewise, adding sugar and milk is pretty much the same as adding a lemon: both are adding condiments to the beverage.
Let’s also make up a new method name, addCondiments(), to handle this.
Now we have a new prepareRecipe() method, but we need to ﬁt it into the code.
To do this we are going to start with the CaffeineBeverage superclass:
Remember, we moved these into the CaffeineBeverage class (back in our class diagram)
Finally we need to deal with the Coffee and Tea classes.
They now rely on CaffeineBeverage to handle the recipe, so they just need to handle brewing and condiments:
Sharpen your pencil Draw the new class diagram now that we’ve moved the implementation of prepareRecipe() into the CaffeineBeverage class:
Brew the coffee grindsPour coffee in a cup Add sugar and milk.
What’s that?  Let’s look at the structure of  the CaffeineBeverage class; it contains the actual “template method:”
In the template, each step of the algorithm is represented by a method.
The methods that need to be supplied by a subclass are declared abstract.
The Template Method defines the steps of an algorithm and allows subclasses to provide the implementation for one or more steps.
You’ll see that the template method controls the algorithm; at certain points in the algorithm, it lets the subclass supply the implementation of the steps...
Next we need to brew the tea, which only the subclass knows how to do:
Now we pour the tea in the cup; this is the same for all beverages so it happens in CaffeineBeverage:
Finally, we add the condiments, which are speciﬁ c to each beverage, so the subclass implements this:
The prepareRecipe() method controls the algorithm, no one can change this, and it counts on subclasses to provide some or all of the implementation.
Coffee and Tea are running the show; they control the algorithm.
Code changes to the algorithm require opening the subclasses and making multiple changes.
The algorithm lives in one place and code changes only need to be made there.
The CaffeineBeverage class runs the show; it has the algorithm, and protects it.
Classes are organized in a structure that requires a lot of work to add a new caffeine beverage.
The Template Method version provides a framework that other caffeine beverages can be plugged into.
New caffeine beverages only need to implement a couple of methods.
The CaffeineBeverage class concentrates knowledge about the algorithm and relies on subclasses to provide complete implementations.
Knowledge of the algorithm and how to implement it is distributed over many classes.
The Template Method Pattern deﬁ nes the skeleton of  an algorithm in a method, deferring some steps to subclasses.
Template Method lets subclasses redeﬁ ne certain steps of  an algorithm without changing the algorithm’s structure.
You’ve seen how the Template Method Pattern works in our Tea and Coffee example; now, check out the ofﬁ cial deﬁ nition and nail down all the details:
This pattern is all about creating a template for an algorithm.
What’s a template? As you’ve seen it’s just a method; more speciﬁ cally, it’s a method that deﬁ nes an algorithm as a set of  steps.
One or more of  these steps is deﬁ ned to be abstract and implemented by a subclass.
This ensures the algorithm’s structure stays unchanged, while subclasses provide some part of  the implementation.
It is decoupled from the actual implementation of these operations.
Let’s take a closer look at how the AbstractClass is deﬁned, including the template method and primitive operations.
The template method defines the sequence of steps, each represented by a method.
In this example, two of the primitive operations must be implemented by concrete subclasses.
We also have a concrete operation defined in the abstract class.
Now we’re going to look even closer at the types of  method that can go in the abstract class:
We still have our primitive methods; these are abstract and implemented by concrete subclasses.
We can also have concrete methods that do nothing by default; we call these “hooks.”  Subclasses are free to override these but don’t have to.
We’re going to see how these are useful on the next page.
With a hook, I can override the method, or not.
If I don’t, the abstract class provides a default implementation.A hook is a method that is declared in the.
This gives subclasses the ability to “hook into” the algorithm at various points, if  they wish; a subclass is also free to ignore the hook.
There are several uses of  hooks; let’s take a look at one now.
This is a hook because the subclass can override this method, but doesn’t have to.
To use the hook, we override it in our subclass.
Here, the hook controls whether the CaffeineBeverage evaluates a certain part of  the algorithm; that is, whether it adds a condiment to the beverage.
How do we know whether  the customer wants the condiment?  Just ask !
Get the user’s input on the condiment decision and return true or false.
Here’s the test code where we create a hot tea and a hot coffee.
Boiling water Steeping the tea Pouring into cup Would you like lemon with your tea (y/n)? y Adding Lemon.
Would you like milk and sugar with your coffee (y/n)? n.
Q: When I’m creating a template method, how do I know when to use abstract methods and when to use hooks?
A: Use abstract methods when your subclass MUST provide an implementation of the method or step in the algorithm.
Use hooks when that part of the algorithm is optional.
With hooks, a subclass may choose to implement that hook, but it doesn’t have to.
Q: What are hooks really supposed to be used for?
As we just said, a hook may provide a way for a subclass to implement an optional part.
Another use is to give the subclass a chance to react to some step in the template method that is about to happen, or just happened.
As you’ve seen a hook can also provide a subclass with the ability to make a decision for the abstract class.
Q: Does a subclass have to implement all the abstract methods in the AbstractClass?
A: Yes, each concrete subclass defines the entire set of abstract methods and.
Q: It seems like I should keep my abstract methods small in number, otherwise it will be a big job to implement them in the subclass.
A: That’s a good thing to keep in mind when you write template methods.
Sometimes this can be done by not making the steps of your algorithm too granular.
But it’s obviously a trade off: the less granularity, the less flexibility.
Remember, too, that some steps will be optional; so you can implement these as hooks rather than abstract methods, easing the burden on the subclasses of your abstract class.
Now, I would have thought that functionality like asking the customer could have been used by.
But you have to admit before you thought of  that it was a pretty cool example of  how a hook can be used to conditionally control the ﬂow of  the algorithm in the abstract class.
We’re sure you can think of  many other more realistic scenarios where you could use the template method and hooks in your own code.
We’ve got another design principle for you;  it’s called the Hollywood Principle:
You’ve heard me say it before, and I’ll say it again:
Easy to remember, right? But what has it got to do with OO design?
The Hollywood principle gives us a way to prevent “dependency rot.”  Dependency rot happens when you have high-level components depending on low-level components depending on high-level components depending on sideways components depending on low-level components, and so on.
When rot sets in,  no one can easily understand the way a system is designed.
With the Hollywood Principle, we allow low-level components to hook themselves into a system, but the high-level components determine when they are needed, and how.
In other words, the high-level components give the low-level components a “don’t call us, we’ll call you” treatment.
The connection between the Hollywood Principle and the Template Method Pattern is probably somewhat apparent: when we design with the Template Method Pattern, we’re telling subclasses, “don’t call us, we’ll call you.”  How?  Let’s take another look at our CaffeineBeverage design:
Clients of beverages will depend on the CaffeineBeverage abstraction rather than a concrete Tea or Coffee, which reduces dependencies in the overall system.
Q: How does the Hollywood Principle relate to the Dependency Inversion Principle that we learned a few chapters back?
A: The Dependency Inversion Principle teaches us to avoid the use of concrete classes and instead work as much as possible with abstractions.
The Hollywood Principle is a technique for building frameworks or components so that lower-level components can be hooked.
So, they both have the goal of decoupling, but the Dependency Inversion Principle makes a much stronger and general statement about how to avoid dependencies in design.
The Hollywood Principle gives us a technique for creating designs that allow low-level structures to interoperate while preventing other classes from becoming too dependent on them.
Q: Is a low-level component disallowed from calling a method in a higher-level component?
In fact, a low level component will often end up calling a method defined above it in the inheritance hierarchy purely through inheritance.
But we want to avoid creating explicit circular dependencies between the low-level component and the high-level ones.
Encapsulate interchangeable behaviors and use delegation to decide which behavior to use.
The Template Method Pattern is a very common pattern and you’re going to ﬁnd lots of  it in the wild.
You’ve got to have a keen eye, though, because there are many implementations of  the template methods that don’t quite look like the textbook design of  the pattern.
This pattern shows up so often because it’s a great design tool for creating frameworks, where the framework controls how something gets done, but leaves you (the person using the framework) to specify your own details about what is actually happening at each step of  the framework’s algorithm.
Let’s take a little safari through a few uses in the wild (well, okay, in the Java API)...
What’s something we often need to do with arrays? Sort them!
Recognizing that, the designers of  the Java Arrays class have provided us with a handy  template method for sorting.
We actually have two methods here and they act together to.
This is a concrete method, already defined in the Arrays class.
The mergeSort() method contains the sort algorithm, and relies on an implementation of the compareTo() method to complete the algorithm.
If you’re interested in the nitty gritty of how the sorting happens, you’ll want to check out the Sun source code.
We’ve got an array of Ducks we need to sort.
The compareTo() method compares two objects and returns whether one is less than, greater than, or equal to the other.
Let’s say you have an array of  ducks that you’d like to sort.
How do you do it?  Well, the sort template method in Arrays gives us the algorithm, but you need to tell it how to compare ducks, which you do by implementing the compareTo() method...
An array doesn’t subclass anything, so I don’t get how we’d.
Here’s the deal: the designers of  sort() wanted it to be useful across all arrays, so they had to make sort() a static method that could be used from anywhere.
But that’s okay, it works almost the same as if  it were in a superclass.
Now, here is one more detail: because sort() really isn’t deﬁned in our superclass, the sort() method needs to know that you’ve implemented the compareTo() method, or else you don’t have the piece needed to complete the sort algorithm.
To handle this, the designers made use of  the Comparable interface.
All you have to do is implement this interface, which has one method (surprise): compareTo()
Okay, so you know that if  you want to sort Ducks, you’re going to have to implement this compareTo() method; by doing that you’ll give the Arrays class what it needs to complete the algorithm and sort your ducks.
Notice that we call Arrays’ static method sort, and pass it our Ducks.
We’ll check out how the template method controls the algorithm, and at certain points in the algorithm, how it asks our Ducks to supply the implementation of a step...
Then we call the sort() template method in the Array class and pass it our ducks:
The sort() method (and its helper mergeSort()) control the sort procedure.
To sort an array, you need to compare two items one by one until the entire list is in sorted order.
When it comes to comparing two ducks, the sort method relies on the Duck’s compareTo() method to know how to do this.
The compareTo() method is called on the ﬁ rst duck and passed the duck to be compared to:
If  the Ducks are not in sorted order, they’re swapped with the concrete swap() method in Arrays:
The sort() method controls the algorithm, no class can change this.
The sort method continues comparing and swapping Ducks until the array is in the correct order!
Q: Is this really the Template Method Pattern, or are you trying too hard?
A: The pattern calls for implementing an algorithm and letting subclasses supply the implementation of the steps – and the Arrays sort is clearly not doing that! But, as we know, patterns in the wild aren’t always just like the textbook patterns.
They have to be  modified to fit the context and implementation constraints.
The designers of the Arrays sort() method had a few constraints.
In general, you can’t subclass a Java array and they wanted the sort to be used on all arrays (and each array is a different class)
So they defined a static method and deferred the comparison part of.
So, while it’s not a textbook template method, this implementation is still in the spirit of the Template Method Pattern.
Also, by eliminating the requirement that you have to subclass Arrays to use this algorithm, they’ve made sorting in some ways more flexible and useful.
A: You’re probably thinking that because the Strategy Pattern uses object composition.
But remember, in Strategy, the class that you compose with implements the entire algorithm.
The algorithm that Arrays implements for sort is incomplete; it needs a class to fill in the missing compareTo() method.
Q: Are there other examples of template methods in the Java API?
For example, java.io has a read() method in InputStream that subclasses must implement and is used by the tempate method read(byte b[], int off, int len)
We know that we should favor composition over inheritance, right?  Well, the implementers of the sort() template method decided not to use inheritance and instead to implement sort() as a static method that is composed with a Comparable at runtime.
How is this better?  How is it worse?  How would you approach this problem?  Do Java arrays make this particularly tricky?
Think of another pattern that is a specialization of the template method.
In this specialization, primitive operations are used to create and return objects.
If  you haven’t encountered JFrame, it’s the most basic Swing container and inherits a paint() method.
By default, paint() does nothing because it’s a hook!  By overriding paint(), you can insert yourself  into JFrame’s algorithm for displaying its area of  the screen and have  your own graphic output incorporated into the JFrame.
Here’s an embarrassingly simple example of  using a JFrame to override the paint() hook method:
Applets Our ﬁ nal stop on the safari: the  applet.
You probably know an applet is a small program that runs in a web page.
Any applet must subclass Applet, and this class provides several hooks.
The start hook allows the applet to do something when the applet is just about to be displayed on the web page.
And the destroy hook is used when the applet is going to be destroyed, say, when the browser pane is closed.
We could try to display something here, but what would be the point?
Concrete applets make extensive use of hooks to supply their own behaviors.
Because these methods are implemented as hooks, the applet isn’t required to implement them.
Hey Strategy, what are you doing in my chapter?  I ﬁgured I’d get stuck with someone boring like Factory Method.
Nope, it’s me, although be careful – you and Factory Method are related, aren’t you?
I was just kidding!  But seriously, what are you doing here?  We haven’t heard from you in eight chapters!
You might want to remind the reader what you’re all about, since it’s been so long.
I don’t know, since Chapter 1, people have been stopping me in the street saying, “Aren’t you that pattern...”  So I think they know who I am.
But for your sake: I deﬁne a family of algorithms and make them interchangeable.
Since each algorithm is encapsulated, the client can use different algorithms easily.
Hey, that does sound a lot like what I do.
But my intent’s a little different from yours; my job is to deﬁne the outline of  an algorithm,  but let my subclasses do some of  the work.
That way, I can have different implementations of  an algorithm’s individual steps, but keep control over the algorithm’s structure.
Seems like you have to give up control of  your algorithms.
I offer clients a choice of  algorithm implementation through object composition.
I’d heard you were on the ﬁnal draft of  your chapter and I thought I’d swing by to see how it was going.
We have a lot in common, so I thought I might be able to help...
You might be a little more efﬁcient (just a little) and require fewer objects.
And you might also be a little less complicated in comparison to my delegation model,  but I’m more ﬂexible because I use object composition.
With me, clients can change their algorithms at runtime simply by using a different strategy object.
Come on, they didn’t choose me for Chapter 1 for nothing!
But you have to depend on methods implemented in your superclass, which are part of  your algorithm.
I don’t depend on anyone; I can do the entire algorithm myself !
Thanks for stopping by, but I’ve got to get the rest of  this chapter done.
I’ll let you work, but let me know if  you need my special techniques anyway, I’m always glad to help.
But I have more control over my algorithm and I don’t duplicate code.
In fact, if  every part of  my algorithm is the same except for, say, one line, then my classes are much more efﬁcient than yours.
All my duplicated code gets put into the superclass, so all the subclasses can share it.
Yeah, well, I’m real happy for ya, but don’t forget I’m the most used pattern around.
Why?  Because I provide a fundamental method for code reuse that allows subclasses to specify behavior.
I’m sure you can see that this is perfect for creating frameworks.
With Template Method you can reuse code like a pro while keeping control of your algorithms.
Encapsulate interchangable behaviors and use delegation to decide which behavior to use.
Sharpen your pencil Draw the new class diagram now that we’ve moved prepareRecipe() into the CaffeineBeverage class:
There are lots of  ways to stuff  objects into a collection.
Put them in an Array, a Stack, a List, a Hashtable, take your pick.
But at some point your client is going to want to iterate over those objects, and.
Well, you don’t have to risk your career; you’re going.
And if that’s not enough, you’re also going to learn a thing or two about object.
That’s great news!  Now we can get those delicious pancake breakfasts at the Pancake House and those yummy lunches at the Diner all in one place.
ArrayList to hold his menu items, and I used an Array.
A hot dog, with saurkraut, relish, onions,         topped with cheeseSteamed Veggies and Brown Rice                           3.99 A medley of steamed vegetables over brown rice.
Wafﬂ es                                                                                   3.59 Wafﬂ es, with your choice of blueberries         or strawberries.
A MenuItem consists of a name, a description, a flag to indicate if the item is vegetarian, and a price.
You pass all these values into the constructor to initialize the MenuItem.
At least Lou and Mel agree on the implementation of  the MenuItems.
Let’s check out the items on each menu, and also take a look at the implementation.
Now let’s take a look at what Lou and Mel are arguing about.
They both have lots of  time and code invested in the way they store their menu items in a menu, and lots of  other code that depends on it.
Lou has a bunch of other menu co de that depends.
The getMenuItems() method returns the list o f menu items.
Mel takes a different approach; he’s u sing an Array so he.
Like Lou, Mel creates his menu items in the constructor, using the addItem() helper method.
Like Lou, Mel has a bunch of code that depends on the implementation of his menu being an Array.
Mel specifically wants to keep his menu under a certain size (presumably so he doesn’t have to remember too many recipes)
To see why having two different menu representations complicates things, let’s try implementing a client that uses the two menus.
Imagine you have been hired by the new company formed by the merger of  the Diner and the Pancake House to create a Java-enabled waitress (this is Objectville, after all)
The spec for the Java-enabled waitress speciﬁ es that she can print a custom menu for customers on demand, and even tell you if  a menu item is vegetarian without having to ask the cook – now that’s an innovation!
Let’s check out the spec, and then step through what it might take to implement her...
To print all the items on each menu, you’ll need to call the getMenuItem() method on the PancakeHouseMenu and the DinerMenu to retrieve their respective menu items.
Now, to print out the items from the PancakeHouseMenu, we’ll loop through the items on the breakfastItems ArrayList.
And to print out the Diner items we’ll loop through the Array.
Implementing every other method in the Waitress is going to be a variation of this theme.
We’re always going to need to get both menus and use two loops to iterate through their items.
If  another restaurant with a different implementation is acquired then we’ll have three loops.
The implementation is showing through, breakfast items are in an ArrayList, lunch items are in an Array.
Let’s start by stepping through how we’d implement the printMenu() method:
We are coding to the PancakeHouseMenu and DinerMenu concrete implementations, not to an interface.
The Waitress doesn’t implement the Java Waitress API and so she isn’t adhering to a standard.
If  we decided to switch from using DinerMenu to another type of  menu that implemented its list of  menu items with a Hashtable, we’d have to modify a lot of  code in the Waitress.
The Waitress needs to know how each menu represents its internal collection of menu items; this violates encapsulation.
We have duplicate code: the printMenu() method needs two separate loops to iterate over the two different kinds of menus.
And if  we added a third menu, we’d have yet another loop.
The implementation isn’t based on MXML (Menu XML) and so isn’t as interoperable as it should be.
Based on our implementation of  printMenu(), which of  the following apply?
Mel and Lou are putting us in a difﬁcult position.
They don’t want to change their implementations because it would mean rewriting a lot of  code that is in each respective menu class.
But if  one of  them doesn’t give in, then we’re going to have the job of  implementing a Waitress that is going to be hard to maintain and extend.
It would really be nice if  we could ﬁnd a way to allow them to implement the same interface for their menus (they’re already close, except for the return type of  the getMenuItems() method)
That way we can minimize the concrete references in the Waitress code and also hopefully get rid of  the multiple loops required to iterate over both menus.
Sound good?  Well, how are we going to do that?
If  we’ve learned one thing in this book, it’s encapsulate what varies.
It’s obvious what is changing here: the iteration caused by different collections of  objects being returned from the menus.
But can we encapsulate this?  Let’s work through the idea...
To iterate through the breakfast items we use the size() and get() methods on the ArrayList:
And to iterate through the lunch items we use the Array length ﬁeld and the array subscript notation on the MenuItem Array.
Now what if we create an object, let’s call it an Iterator, that encapsulates the way we iterate through a collection of objects? Let’s try this on the ArrayList.
We ask the breakfastMenu for an iterator of its MenuItems.
Meet the  Iterator Pattern Well, it looks like our plan of  encapsulating iteration just might actually work; and as you’ve probably already guessed, it is a Design Pattern called the Iterator Pattern.
The ﬁ rst thing you need to know about the Iterator Pattern is that it relies on an interface called Iterator.
The next() method returns the next object in the aggregate.
Now, once we have this interface, we can implement Iterators for any kind of  collection of  objects: arrays, lists, hashtables, ...pick your favorite collection of  objects.
Let’s say we wanted to implement the Iterator for the Array used in the DinerMenu.
Let’s go ahead and implement this Iterator and hook it into the DinerMenu to see how this works...
To add an Iterator to the DinerMenu we ﬁrst need to deﬁne the Iterator Interface:
And now we need to implement a concrete Iterator that works for the Diner menu:
The constructor takes the array of menu items we are going to iterate over.
The next() method returns the next item in the array and increments the position.
The hasNext() method checks to see if we’ve seen all the elements of the array and returns true if there are more to iterate through.
Because the diner chef went ahead and allocated a max sized array, we need to check not only if we are at the end of the array, but also if the next item is null, which indicates there are no more items.
Time to work it into the DinerMenu; all we need to do is add one method to create a DinerMenuIterator and return it to the client:
It creates a DinerMenuIterator from the menuItems array and returns it to the client.
The overloaded printMenu() method uses the Iterator to step through the menu items and print them.
Use the item to get name, price and description and print them.
Now we need to integrate the iterator code into the Waitress.
We should be able to get rid of  some of  the redundancy in the process.
Integration is pretty straightforward: ﬁrst we create a printMenu() method that takes an Iterator, then we use the createIterator() method on each menu to retrieve the Iterator and pass it to the new method.
Then we create a Waitress and pass her the menus.
Let’s write some test drive code and see how the Waitress works...
And then the lunch menu, all with the same iteration code.
What have we done so far? Woohoo!  No code changes other than adding the.
The Waitress will be much easier to maintain and extend down the road.
Let’s go through exactly what we did and think about the consequences:
The Menus are not well encapsulated; we can see the Diner is using an Array and the Pancake House an ArrayList.
The Waitress is bound to concrete classes (MenuItem[] and ArrayList)
All we need is a loop that polymorphically handles any collection of items as long as it implements Iterator.
The Waitress has no idea how the Menus hold their collection of menu items.
The Waitress is bound to two different concrete Menu classes, despite their interfaces being almost identical.
The Menu interfaces are now exactly the same and, uh oh, we still don’t have a common interface, which means the Waitress is still bound to two concrete Menu classes.
Before we clean things up, let’s get a bird’s eye view of  our current design.
Note that the iterator give us a way to step through the elements of an aggregate without forcing the aggregate to clutter its own interface with a bunch of methods to support traversal of its elements.
It also allows the implementation of the iterator to live outside of the aggregate; in other words, we’ve encapsulated the interation.
We’re now using a common Iterator interface and we’ve implemented two concrete classes.
Okay, we know the interfaces of  PancakeHouseMenu and DinerMenu are exactly the same and yet we haven’t deﬁ ned a common interface for them.
So, we’re going to do that and clean up the Waitress a little more.
You may be wondering why we’re not using the Java Iterator interface – we did that so you could see how to build an iterator from scratch.
Now that we’ve done that, we’re going to switch to using the Java Iterator interface, because we’ll get a lot of  leverage by implementing that instead of  our home grown Iterator interface.
Except we have an additional method that allows us to remove the last item returned by the next() method from the aggregate.
Q: What if I don’t want to provide the ability to remove something from the underlying collection of objects?
But, obviously you do need to provide the method because it’s part of the Iterator interface.
If you’re not going to allow remove() in your iterator you’llwant to throw.
The Iterator API documentation specifies that this exception may be thrown from remove() and any client that is a good citizen will check for this exception when calling the remove() method.
Q: How does remove() behave under multiple threads that may be using different iterators over the same collection of objects?
A: The behavior of the remove() is unspecified if the collection changes while you are iterating over it.
So you should be careful in designing your own multithreaded code when accessing a collection concurrently.
Not only does java.util have its own Iterator interface, but ArrayList has an iterator() method that returns an iterator.
In other words, we never needed to implement our own iterator for ArrayList.
However, we’ll still need our implementation for the DinerMenu because it relies on an Array, which doesn’t support the iterator() method (or any other way to create an array iterator)
Instead of creating our own iterator now, we just call the iterator() method on the menuItems ArrayList.
Here, because the chef is using a fixed sized Array, we just shift all the elements up one when remove() is called.
We just need to give the Menus a common interface and rework the Waitress a little.
The Menu interface is quite simple: we might want to add a few more methods to it eventually, like addItem(), but for now we will let the chefs control their menus by keeping that method out of  the public interface:
This is a simple interface that just lets clients get an iterator for the items in the menu.
Now we need to add an implements Menu to both the PancakeHouseMenu and the DinerMenu class deﬁnitions and update the Waitress:
We need to replace the concrete Menu classes with the Menu Interface.
Waitress can refer to each menu object using the interface rather than the concrete class.
So, we’re reducing the dependency between the Waitress and the  concrete classes by “programming to an interface, not an implementation.”
The new Menu interface has one method, createIterator(), that is implemented by PancakeHouseMenu and DinerMenu.
Each menu class assumes the responsibility of  creating a concrete Iterator that is appropriate for its internal implementation of  the menu items.
Now, Waitress only needs to be concerned with Menus and Iterators.
PancakeHouseMenu and DinerMenu now implement the Menu interface, which means they need to implement the new createIterator() method.
DinerMenu returns an DinerMenuIterator from its createIterator() method because that’s the kind of iterator required to iterate over its Array of menu items.
Each concrete Menu is responsible for creating the appropriate concrete Iterator class.
This solves the problem of the Waitress depending on the implementation of the MenuItems.
The Iterator Pattern provides a way to access the elements of  an aggregate object sequentially without exposing its underlying representation.
You’ve already seen how to implement the Iterator Pattern with your very own iterator.
You’ve also seen how Java supports iterators in some of  its collection oriented classes (the ArrayList)
Now it’s time to check out the ofﬁcial deﬁnition of  the pattern:
This makes a lot of  sense: the pattern gives you a way to step through the elements of  an aggregate without having to know how things are represented under the covers.
But the effect of  using iterators in your design is just as important: once you have a uniform way of  accessing the elements of  all your aggregate objects, you can write polymorphic code that works with any of  these aggregates – just like the printMenu() method, which doesn’t care if  the menu items are held in an Array or ArrayList (or anything else that can create an Iterator), as long as it can get hold of  an Iterator.
The other important impact on your design is that the Iterator Pattern takes the responsibility of  traversing elements and gives that responsibility to the iterator object, not the aggregate object.
This not only keeps the aggregate interface and implementation simpler, it removes the responsibility for iteration from the aggregate and keeps the aggregate focused on the things it should be focused on (managing a collection of objects), not on iteration.
Let’s check out the class diagram to put all the pieces in context...
The Iterator Pattern allows traversal of the elements of an aggregate without exposing the underlying implementation.
It also places the task of traversal on the iterator object, not on the aggregate, which simplifies the aggregate interface and implementation, and places the responsibility where it should be.
The  ConcreteAggregate has a collection of objects and implements the method that returns an Iterator for its collection.
Each ConcreteAggregate is responsible for instantiating a ConcreteIterator that can iterate over its collection of objects.
The Iterator interface provides the interface that all iterators must implement, and a set of methods for traversing over elements of a collection.
If you don’t want to use Java’s Iterator interface, you can always create your own.
Having a common interface for your aggregates is handy for your client; it decouples your client from the implementation of your collection of objects.
The class diagram for the Iterator Pattern looks very similar to another Pattern you’ve studied; can you think of what it is?  Hint:  A subclass decides which object to create.
The ConcreteIterator is responsible for managing the current position of the iteration.
Q: I’ve seen other books show the Iterator class diagram with the methods first(), next(), isDone() and currentItem()
A: Those are the “classic” method names that have been used.
What are they?  Which kind did we implement in the example?
A: We implemented an external iterator, which means that the client controls the iteration by calling next() to get the next element.
In that case, because it’s the iterator that’s stepping through the elements, you have to tell the iterator what to do with those elements as it goes through them.
That means you need a way to pass an operation to an iterator.
Internal iterators are less flexible that external iterators because the client doesn’t have control of the iteration.
Q: Could I implement an Iterator that can go backwards as well as forwards?
In that case, you’d probably want to add two methods, one to get to the previous element, and one to tell you when you’re at the beginning of the collection of elements.
Java’s Collection Framework provides another type of iterator interface called ListIterator.
This iterator adds previous() and a few other methods to the standard Iterator interface.
It is supported by any Collection that implements the List interface.
Q: Who defines the ordering of the iteration in a collection like Hashtable, which are inherently unordered?
The underlying collections may be unordered as in a hashtable or in a bag; they may even contain duplicates.
So ordering is related to both the properties of the underlying collection and to the implementation.
In general, you should make no assumptions about ordering unless the Collection documentation indicates otherwise.
Q: You said we can write “polymorphic code” using an iterator; can you explain that more?
A: When we write methods that take Iterators as parameters, we are using polymorphic iteration.
That means we are creating code that can iterate over any.
We don’t care about how the collection is implemented, we can still write code to iterate over it.
If you have a common Iterator interface, it will certainly make it easier for you to mix and match your own aggregates with Java aggregates like ArrayList and Vector.
But remember, if you need to add functionality to your Iterator interface for your aggregates, you can always extend the Iterator interface.
Enumeration has two methods, hasMoreElements(), corresponding to hasNext(), and nextElement(), corresponding to next()
However, you’ll probably want to use Iterator over Enumeration as more Java classes support it.
If you need to convert from one to another, review the Adapter Chapter again where you implemented the adapter for Enumeration and Iterator.
What if we allowed our aggregates to implement their internal collections and related operations AND the iteration methods? Well, we already know that would expand the number of methods in the aggregate, but so what? Why is that so bad?
Well, to see why, you ﬁ rst need to recognize that when we allow a class to not only take care of  its own business (managing some kind of  aggregate) but also take on more responsibilities (like iteration) then we’ve given the class two reasons to change.
Two?  Yup, two: it can change if  the collection changes in some way, and it can change if  the way we iterate changes.
So once again our friend CHANGE is at the center of  another design principle:
We know we want to avoid change in a class like the plague – modifying code provides all sorts of  opportunities for problems to creep in.
Having two ways to change increases the probability the class will change in the future, and when it does, it’s going to affect two aspects of  your design.
The solution? The principle guides us to assign each responsibility to one class, and only one class.
That’s right, it’s as easy as that, and then again it’s not: separating responsibility in design is one of  the most difﬁ cult things to do.
Our brains are just too good at seeing a set of  behaviors and grouping them together even when there are actually two or more responsibilities.
The only way to succeed is to be diligent in examining your designs and to watch out for signals that a class is changing in more than one way as your system grows.
Every responsibility of a class is an area of potential change.
More than one responsibility means more than one area of change.
This principle guides us to keep each class to a single responsibility.
Cohesion is a term you’ll hear used as a measure of how closely a class or a module supports a single purpose or responsibility.
We say that a module or class has high cohesion.
Cohesion is a more general concept than the Single Responsibility Principle, but the two are closely related.
Classes that adhere to the principle tend to have high cohesion and are more maintainable than classes that take on multiple responsibilities and have low cohesion.
Examine these classes and determine which ones have multiple responsibilities.
Sharpen your pencil Before looking at the next page, quickly jot down the three things we have to do to this code to ﬁt it into our framework:
CafeMenu implements the Menu interface, so the Waitress can use.
Just like before, we can get rid of getItems() so we don’t.
Hashtable is a little more complex than the ArrayList because it supports both keys and values, but we can still get an Iterator for the values (which are the MenuItems)
That was easy; how about modifying the Waitress to support our new Menu? Now that the Waitress expects Iterators, that should be easy too.
Let’s update our test drive to make sure this all works.
Now, when we print we should see all three menus.
Array doesn’t have a built in Iterator so we built our own.
We wanted to give the Waitress an easy way to iterate over menu items...
So we gave the Waitress an Iterator for each kind of group of objects she needed to iterate over...
Now she doesn’t have to worry about which implementation we used; she always uses the same interface - Iterator - to iterate over menu items.
By giving her an Iterator we have decoupled her from the implementation of the menu items, so we can easily add new Menus if we want.
Which is better for her, because now she can use the same code to iterate over any group of objects.
And it’s better for us because the implementation details aren’t exposed.
Making an Iterator for the Hashtable values was easy; when you call.
And if they don’t support Iterator, that’s ok, because now you know how to build your own.
Java gives you a lot of “collection” classes that allow you to store and retrieve groups of objects.
We’ve been using a couple of  classes that are part of  the Java Collections Framework.
This “framework” is just a set of  classes and interfaces, including ArrayList, which we’ve been using, and many others like Vector, LinkedList, Stack, and PriorityQueue.
The nice thing about Collections and Iterator is that each Collection object knows how to create its own Iterator.
Calling iterator() on an ArrayList returns a concrete Iterator made for ArrayLists, but.
With this method, you can get an Iterator for any class that implements the Collection interface.
Other handy methods include size(), to get the number of elements, and toArray() to turn your collection into an array.
Hashtable is one of a few classes that indirectly supports Iterator.
As you saw when  we implemented the CafeMenu, you could get an Iterator from it, but only by ﬁ rst retrieving its Collection called values.
If you think about it, this makes sense: the Hashtable holds two sets of objects: keys and values.
If we want to iterate over its values, we ﬁ rst need to retrieve them from the Hashtable, and then obtain the iterator.
Java 5 includes a new form of  the for statement, called for/in, that lets you iterate over a collection or an array without creating an iterator explicitly.
To use for/in, you use a for statement that looks like:
Check this out, in Java 5 they’ve added support for iterating.
You need to use Java 5’s new generics feature to ensure for/ in type safety.
Make sure you read up on the details before using generics and for/in.
The Chefs have decided that they want to be able to alternate their lunch menu items; in other words, they will offer some items on Monday, Wednesday, Friday and Sunday, and other items on Tuesday, Thursday, and Saturday.
Someone already wrote the code for a new “Alternating” DinerMenu Iterator so that it alternates the menu items, but they scrambled it up and put it on the fridge in the Diner as a joke.
Can you put it back together?  Some of the curly braces fell on the ﬂ oor and they were too small to pick up, so feel free to add as many of those as you need.
The Waitress still needs to make three calls to printMenu(), one for each menu.
Can you think of a way to combine the menus so that only one call needs to be made?  Or perhaps so that one Iterator is passed to the Waitress to iterate over all the menus?
Is the Waitress ready for prime time? The Waitress has come a long way, but you’ve gotta admit those three calls to printMenu() are looking kind of  ugly.
Let’s be real, every time we add a new menu we are going to have to open up the Waitress implementation and add more code.
We have done a great job of  decoupling the menu implementation and extracting the iteration into an iterator.
But we still are handling the menus with separate, independent objects – we need a way to manage them together.
Everytime we add or remove a menu we’re going to have to open this code up for changes.
This isn’t so bad, all we need to do is package.
The code in the Waitress is going to be simple and it will handle any number of.
And we iterate through the menus, passing each menu’s iterator to the overloaded printMenu() method.
This looks pretty good, although we’ve lost the names of  the menus, but we could add the names to each menu.
Okay, now what?  Now we have to support not only multiple menus, but menus within menus.
It would be nice if  we could just make the dessert menu an element of  the DinerMenu collection, but that won’t work as it is now implemented.
Here’s our Arraylist that holds the menus of each restaurant.
We need for Diner Menu to hold a submenu, but we can’t actually assign a menu to a MenuItem array because the types are different, so this isn’t going to work.
The time has come to make an executive decision to rework the chef ’s implementation into something that is general enough to work over all the menus (and now sub menus)
That’s right, we’re going to tell the chefs that the time as come for us to reimplement their menus.
The reality is that we’ve reached a level of  complexity such that if  we don’t rework the design now, we’re never going to have a design that can accommodate further acquisitions or submenus.
So, what is it we really need out of  our new design?
For instance, we might need to iterate over only the Diner’s dessert menu, or we might need to iterate over the Diner’s entire menu, including the dessert submenu.
How would you handle this new wrinkle to our design requirements?  Think about it before turning the page.
We also need to be able to traverse more flexibly, for instance over one menu.
That’s right, we’re going to introduce another pattern to solve this problem.
We didn’t give up on Iterator – it will still be part of  our solution – however, the problem of  managing menus has taken on a new dimension that Iterator doesn’t solve.
So, we’re going to step back and solve it with the Composite Pattern.
We’re not going to beat around the bush on this pattern, we’re going to go ahead and roll out the ofﬁcial deﬁnition now:
The Composite Pattern allows you to compose objects into tree structures to represent part-whole hierarchies.
Composite lets clients treat individual objects and compositions of  objects uniformly.
The Composite Pattern allows us to build structures of objects in the form of trees that contain both compositions of objects and individual objects as nodes.
Using a composite structure, we can apply the same operations over both composites and individual objects.
In other words, in most cases we can ignore the differences between compositions of objects and individual objects.
The Component may implement a default behavior for add(), remove(), getChild() and its operations.
A Leaf defines the behavior for the elements in the composition.
It does this by implementing the operations the Composite supports.
Note that the Leaf also inherits methods like add(), remove() and getChild(), which don’t necessarily make a lot of sense for a leaf node.
A composite holds a set of children, those children may be other composites or leaf elements.
When you organize data in this way you end up with a tree structure (actually an upside down tree structure) with a composite at the root and branches of composites growing up to leaf nodes.
We’re going to re-implement the menus with a new solution: the Composite Pattern.
So don’t look for some magical transformation from an iterator to a composite.
You’ll soon see that we can use iterators in a couple of ways in the composite implementation.
So, how do we apply the Composite Pattern to our menus?  To start with, we need to create a component interface; this acts as the common interface for both menus and menu items and allows us to treat them uniformly.
In other words we can call the same method on menus or menu items.
Now, it may not make sense to call some of  the methods on a menu item or a menu, but we can deal with that, and we will in just a moment.
But for now, let’s take a look at a sketch of  how the menus are going to ﬁ t into a Composite Pattern structure:
We’ve used an abstract class here because we want to provide default implementations for these methods.
We have some of the same methods you’ll remember from our previous versions of MenuItem and Menu, and we’ve added print(), add(), remove() and getChild()
Okay, we’re going to start with the MenuComponent abstract class; remember, the role of  the menu component is to provide an interface for the leaf  nodes and the composite nodes.
Now you might be asking, “Isn’t the MenuComponent playing two roles?”  It might well be and we’ll come back to that point.
However, for now we’re going to provide a default implementation of  the methods so that if  the MenuItem (the leaf) or the Menu (the composite) doesn’t want to implement some of  the methods (like getChild() for a leaf  node) they can fall back on some basic behavior:
We’ve grouped together the “composite” methods - that is, methods to add, remove and get MenuComponents.
That way, if MenuItem or Menu doesn’t support an operation, they don’t have to do anything, they can just inherit the default implementation.
All components must implement the MenuComponent interface; however, because leaves and nodes have different roles we can’t always deﬁne a default implementation for each method that makes sense.
Sometimes the best you can do is throw a runtime exception.
I’m glad we’re going in this direction, I’m thinking this is.
Remember, this is the leaf  class in the Composite diagram and it implements the behavior of  the elements of  the composite.
This is pretty much like our old menu item implementation.
Here’s our getter methods - just like our previous implementation.
Now that we have the MenuItem, we just need the composite class, which we’re calling Menu.
Remember, the composite class can hold MenuItems or other Menus.
There’s a couple of  methods from MenuComponent this class doesn’t implement: getPrice() and isVegetarian(), because those don’t make a lot of  sense for a Menu.
This is different than our old implementation: we’re going to give each Menu a name and a description.
Before, we just relied on having different classes for each menu.
Here are the getter methods for getting the name and description.
Notice, we aren’t overriding getPrice() or isVegetarian() because those methods don’t make sense for a Menu (although you could argue that isVegetarian() might make sense)
We use it to iterate through all the Menu’s components...
Since both Menus and MenuItems implement print(), we just call print() and the rest is up to them.
Because menu is a composite and contains both Menu Items and other Menus, its print() method should print everything it contains.
If  it didn’t we’d have to iterate through the entire composite and print each item ourselves.
That kind of  defeats the purpose of  having a composite structure.
As you’re going to see, implementing print() correctly is easy because we can rely on each component to be able to print itself.
All we need to do is ch ange the print() metho.
NOTE: If, during this iteration, we encounter another Menu object, its print() method will start another iteration, and so on.
Wait a sec, I don’t understand the implementation of print()
It’s about time we took this code for a test drive, but we need to update the Waitress code before we do – after all she’s the main client of  this code:
All she has to do to print the entire menu hierarchy - all the menus, and all the menu items - is call print() on the top level menu.
Okay, one last thing before we write our test drive.
Let’s get an idea of  what the menu composite is going to look like at runtime:
Unlike our previous version, we’re going to handle all the menu creation in the test drive.
We could ask each chef  to give us his new menu, but let’s get it all tested ﬁrst.
We’re using the Composite add() method to add each menu to the top level menu, allMenus.
Once we’ve constructed our entire menu hierarchy, we hand the whole thing to the Waitress, and as you’ve seen, it’s easy as apple pie for her to print it out.
The new dessert menu is printed when we are printing all the Diner menu components.
We could say that the Composite Pattern takes the Single Responsibility design principle and trades it for transparency.
What’s transparency?  Well, by allowing the Component interface to contain the child management operations and the leaf  operations, a client can treat both composites and leaf  nodes uniformly; so whether an element is a composite or leaf  node becomes transparent to the client.
Now given we have both types of  operations in the Component class, we lose a bit of  safety because a client might try to do something inappropriate or meaningless on an element (like try to add a menu to a menu item)
This is a design decision; we could take the design in the other direction and separate out the responsibilities into interfaces.
This would make our design safe, in the sense that  any inappropriate calls on elements would be caught at compile time or runtime, but we’d lose transparency and our code would have to use conditionals and the instanceof operator.
So, to return to your question, this is a classic case of  tradeoff.
We are guided by design principles, but we always need to observe the effect they have on our designs.
Sometimes we purposely do things in a way that seems to violate the principle.
In some cases, however, this is a matter of  perspective; for instance, it might seem incorrect to have child management operations in the leaf  nodes (like add(), remove() and getChild()), but then again you can always shift your perspective and see a leaf  as a node with zero children.
Flashback to   Iterator We promised you a few pages back that we’d show you how to use Iterator with a Composite.
You know that we are already using Iterator in our internal implementation of  the print() method, but we can also allow the Waitress to iterate over an entire composite if  she needs to, for instance, if  she wants to go through the entire menu and pull out vegetarian items.
To implement a Composite iterator, let’s add a createIterator() method in every component.
This means that each Menu and MenuItem will need to implement this method.
It also means that calling createIterator() on a composite should apply to all children of the composite.
Now we need to implement this method in the Menu and MenuItem classes: Here we’re using a new iterator called CompositeIterator.
It’s got the job of  iterating over the MenuItems in the component, and of  making sure all the child Menus (and child child Menus, and so on) are included.
Watch out, this isn’t a lot of  code, but it can be a little mind bending.
Just repeat to yourself  as you go through it “recursion is my friend, recursion is my friend.”
The iterator of the top level composite we’re going to iterate over is passed in.
Okay, when the client wants to get the next element we first make sure there is one by calling hasNext()...
If there is a next element, we get the current iterator off the stack and get its next element.
If that element is a menu, we have another composite that needs to be included in the iteration, so we throw it on the stack.
To see if there is a next element, we check to see if the stack is empty; if so, there isn’t.
Otherwise, we get the iterator off the top of the stack and see if it has a next element.
If it doesn’t we pop it off the stack and call hasNext() recursively.
Otherwise there is a next element and we return true.
When we wrote the print() method in the MenuComponent class we used an iterator to step through each item in the component and if that item was a Menu (rather than a MenuItem), then we recursively called the print() method to handle it.
In other words, the MenuComponent handled the iteration itself, internally.
With this code we are implementing an external iterator so there is a lot more to keep track of.
For starters, an external iterator must maintain its position in the iteration so that an outside client can drive the iteration by calling hasNext() and next()
But in this case, our code also needs to maintain that position over a composite, recursive structure.
That’s why we use stacks to maintain our position as we move up and down the composite hierarchy.
Then pretend you are the CompositeIterator, and your job is to handle calls to hasNext() and next()
Trace the way the CompositeIterator traverses the structure as this code is executed:
The Null Iterator Okay, now what is this Null Iterator all about?  Think about it this way: a MenuItem has nothing to iterate over, right?  So how do we handle the implementation of  its createIterator() method?  Well, we have two choices:
Return an iterator that always returns false when hasNext() is called.
We could return null from createIterator(), but then we’d need conditional code in the client to see if  null was returned or not.
We can still return an iterator, but the client doesn’t have to worry about whether or not null is ever returned.
In effect, we’re creating an iterator that is a “no op”
This is the laziest Iterator you’ve ever seen, at every step of the way it punts.
Most importantly when hasNext() is called we always return false.
Now we’ve got a way to iterate over every item of  the Menu.
Let’s take that and give our Waitress a method that can tell us exactly which items are vegetarian.
We implemented isVegetarian() on the Menus to always throw an exception.
If that happens we catch the exception, but continue with our iteration.
The Vegetarian Menu consists of the vegetarian items from every menu.
Whooo! It’s been quite a development effort to get our code to this point.
Now we’ve got a general menu structure that should last the growing Diner empire for some time.
Now it’s time to sit back and order up some veggie food:
In general we agree; try/catch is meant for error handling, not program logic.
What are our other options?   We could have checked the runtime type of  the menu component with instanceof  to make sure it’s a MenuItem before making the call to isVegetarian()
But in the process we’d lose transparency because we wouldn’t be treating Menus and MenuItems uniformly.
We could also change isVegetarian() in the Menus so that it returns false.
This provides a simple solution and we keep our transparency.
In our solution we are going for clarity: we really want to communicate that this is an unsupported operation on the Menu (which is different than saying isVegetarian() is false)
It also allows for someone to come along and actually implement a reasonable isVegetarian() method for Menu and have it work with the existing code.
If the menu component doesn’t support the operation, we just throw away the exception and ignore it.
Why don’t you tell us a little about yourself, Composite?
I’m the pattern to use when you have collections of  objects with whole-part relationships and you want to be able to treat those objects uniformly.
Composite:  Imagine a graphical user interface; there you’ll often ﬁnd a top level component like a Frame or a Panel, containing other components, like menus, text panes, scrollbars and buttons.
So your GUI consists of  several parts, but when you display it, you generally think of  it as a whole.
You tell the top level component to display, and count on that component to display all its parts.
We call the components that contain other components, composite objects, and components that don’t contain other components, leaf  objects.
HeadFirst:  Is that what you mean by treating the objects uniformly?  Having common methods you can call on composites and leaves?
I can tell a composite object to display or a leaf  object to display and they will do the right thing.
The composite object will display by telling all its components to display.
HeadFirst:  That implies that every object has the same interface.
What if  you have objects in your composite that do different things?
Composite:  Well, in order for the composite to work transparently to the client, you must implement the same interface for all objects in the composite, otherwise, the client has to worry about which interface each object is implementing, which kind of  defeats the purpose.
Obviously that means that at times you’ll have objects for which some of  the method calls don’t make sense.
Composite:  Well there’s a couple of  ways to handle it; sometimes you can just do nothing, or return null or false – whatever makes sense in your application.
Other times you’ll want to be more proactive and throw an exception.
Of  course, then the client has to be willing to do a little work and make sure that the method call didn’t do something unexpected.
HeadFirst:  But if  the client doesn’t know which kind of  object they’re dealing with, how would they ever know which calls to make without checking the type?
Composite:  If  you’re a little creative you can structure your methods so that the default implementations do something that does make sense.
For instance, if  the client is calling getChild(), on the composite this makes sense.
And it makes sense on a leaf  too, if  you think of the leaf  as an object with no children.
But, I’ve heard some clients are so worried about this issue, that they require separate interfaces for different objects so they aren’t allowed to make nonsensical method calls.
It’s a much safer version of  the Composite Pattern, but it requires the client to check the type of  every object before making a call so the object can be cast correctly.
HeadFirst:  Tell us a little more about how these composite and leaf  objects are structured.
Composite:  Usually it’s a tree structure, some kind of hierarchy.
The root is the top level composite, and all its children are either composites or leaf  nodes.
HeadFirst:  Do children ever point back up to their parents?
Composite:  Yes, a component can have a pointer to a parent to make traversal of  the structure easier.
And, if you have a reference to a child, and you need to delete it, you’ll need to get the parent to remove the child.
HeadFirst:  There’s really quite a lot to consider in your implementation.
Are there other issues we should think about when implementing the Composite Pattern?
What if  you have a composite that needs to keep its children in a particular order?  Then you’ll need a more sophisticated management scheme for adding and removing children, and you’ll have to be careful about how you traverse the hierarchy.
Sometimes, if  the composite structure is complex or expensive to traverse, it’s helpful to implement caching of  the composite nodes.
For instance, if  you are constantly traversing a composite and all its children to compute some result, you could implement a cache that stores the result temporarily to save traversals.
HeadFirst:  Well, there’s a lot more to the Composite Patterns than I ever would have guessed.
Before we wrap this up, one more question: What do you consider your greatest strength?
Composite:  I think I’d deﬁnitely have to say simplifying life for my clients.
My clients don’t have to worry about whether they’re dealing with a composite object or a leaf  object, so they don’t have to write if statements everywhere to make sure they’re calling the right methods on the right objects.
Often, they can make one method call and execute an operation over an entire structure.
There’s no doubt you’re a useful pattern to have around for collecting and managing objects.
Thanks so much for joining us and come back soon for another Patterns Exposed.
Provides a way to traverse a collection of objects without exposing the collection’s implementation.
Allows a group of objects to be notiﬁed when some state changes.
Encapsulates interchangeable behaviors and uses delegation to decide which one to uses.
Tools for your   Design Toolbox Two new patterns for your toolbox – two great ways to deal with collections of objects.
You need to balance transparency and safety with your needs.
We are coding to the PancakeHouseMenu and DinerMenu concrete implementations, not to an interface.
The Waitress doesn’t implement the Java Waitress API and so isn’t adhering to a standard.
If  we decided to switch from using DinerMenu to another type of  menu that implemented its list of  menu items with a Hashtable, we’d have to modify a lot of  code in the Waitress.
The Waitress needs to know how each menu represents its internal collection of menu items is implemented, this violates encapsulation.
We have duplicate code: the printMenu() method needs two separate loop implementations to iterate over the two different kinds of  menus.
And if  we added a third menu, we might have to add yet another loop.
The implementation isn’t based on MXML (Menu XML) and so isn’t as interoperable as it should be.
Based on our implementation of  printMenu(), which of  the following apply?
Sharpen your pencil Before turning the page, quickly jot down the three things we have to do to this code to ﬁt it into our framework:
Provides a way to traverse a collection of objects without exposing the collection’s implementation.
Allows a group of objects to be notiﬁed when some state changes.
Encapsulates interchangeable behaviors and uses delegation to decide which one to uses.
A little known fact: the Strategy and State Patterns were twins separated at birth.
As you know, the Strategy Pattern went on to create a wildly successful business around interchangeable algorithms.
The State of Things I thought things in Objectville were going to be so easy, but now every time I turn around there’s.
I should have been going to Betty’s Wednesday night patterns group all.
Today people are building Java into real devices, like gumball machines.
That’s right, gumball machines have gone high tech; the major manufacturers have found that by putting CPUs into their machines, they can increase sales, monitor inventory over the network and measure customer satisfaction more accurately.
But these manufacturers are gumball machine experts, not software developers, and they’ve asked for your help:
Here’s the way we think the gu mball machine controller needs.
We’re hoping you can imp lement this in Java for us!  We.
Frank:  Slow down, you two, it’s been too long since I studied state diagrams.
All states are just different conﬁgurations of  the machine that behave in a certain way and need some.
See, to go to another state, you need to do something like put a quarter in the machine.
Joe: That just means that if  the gumball machine is in the “No Quarter” state and you put a quarter in, it will change to the “Has Quarter” state.
Frank:  Oh, I see!  And if  I’m in the “Has Quarter” state, I can turn the crank and change to the “Gumball Sold” state, or eject the quarter and change back to the “No Quarter” state.
We’ve obviously got four states, and I think we also have four actions: “inserts quarter,” “ejects quarter,” “turns crank” and “dispense.”   But...
So we actually have ﬁve transitions from one state to another.
Anne:  That test for zero or more gumballs also implies we’ve got to keep track of  the number of  gumballs too.
Any time the machine gives you a gumball, it might be the last one, and if  it is, we need to transition to the “Out of Gumballs” state.
Joe:  Also, don’t forget that you could do nonsensical things, like try to eject the quarter when the gumball machine is in the “No Quarter” state, or insert two quarters.
Frank:  Oh, I didn’t think of  that; we’ll have to take care of  those too.
Joe:  For every possible action we’ll just have to check to see which state we’re in and act appropriately.
We can do this!  Let’s start mapping the state diagram to code...
How are we going to get from that state diagram to actual code?  Here’s a quick introduction to implementing state machines:
Next, create an instance variable to hold the current state, and deﬁne values for each of  the states:2
Now we gather up all the actions that can happen in the system:3
Dispense is more of an internal action the machine invokes on itself.
Now we create a class that acts as the state machine.
For each action, we create a method that uses conditional statements to determine what behavior is appropriate in each state.
For instance, for the insert quarter action, we might write a method like this:
Here we’re talking about a common technique: modeling state within an object.
With that quick review, let’s go implement the Gumball Machine!
We have a second instance variable that keeps track of the number of gumballs in the machine.
We know we’re going to have an instance variable that holds the current state.
From there, we just need to handle all the actions, behaviors and state transitions that can happen.
For actions, we need to implement inserting a quarter, removing a quarter, turning the crank and dispensing a gumball; we also have the empty gumball condition to implement as well.
Now, if the customer tries to remove the quarte r...
If the customer just turned the crank, we can’t give a refund; he already has the gumball!
Otherwise, if there isn’t one we can’t give it back.
Change the state to SOLD and call the machine’s dispense() method.
You can’t eject if the machine is sold out, it doesn’t accept quarters!
None of these should ever happen, but if they do, we give ‘em an error, not a gumball.
That feels like a nice solid design using a well-thought out methodology doesn’t it?  Let’s do a little in-house testing before we hand it off  to Mighty Gumball to be loaded into their actual gumball machines.
Turn the crank; we should get our gumball Throw a quarter in...
Turn the crank; we should get our gumball Ask for a quarter back we didn’t put in.
You inserted a quarter Quarter returned You turned but there’s no quarter.
A gumball comes rolling out the slot You inserted a quarter You turned...
A gumball comes rolling out the slot You haven’t inserted a quarter.
You inserted a quarter You can’t insert another quarter You turned...
A gumball comes rolling out the slot You inserted a quarter You turned...
A gumball comes rolling out the slot Oops, out of gumballs! You can’t insert a quarter, the machine is sold out You turned, but there are no gumballs.
In fact, things have gone so smoothly they’d like to take things to the next level...
We think that by turning “gumball buying” into a game we.
We’re going to put one of these stickers on every machine.
We’re so glad we’ve got Java in the machines because this is.
In this contest, 10% of the time the Sold state leads to two balls being released, not one.
Check your answer with ours (at the end of the chapter) to make sure we agree before you go further...
Just because you’ve written your gumball machine using a well-thought out methodology doesn’t mean it’s going to be easy to extend.
In fact, when you go back and look at your code and think about what you’ll have to do to modify it, well...
First, you’d have to add a new W INNER state.
This code certainly isn’t adhering to the Open Closed Principle.
State transitions aren’t explicit; they are buried in the middle of  a bunch of conditional statements.
Further additions are likely to cause bugs in working code.
The rate of bugs is just going to make us look.
Joe:  You’re right about that!  We need to refactor this code so that it’s easy to maintain and modify.
Anne: We really should try to localize the behavior for each state so that if we make changes to one state, we don’t run the risk of  messing up the other code.
Joe:  Right; in other words, follow that ol’ “encapsulate what varies” principle.
Joe:  If  we put each state’s behavior in its own class, then every state just implements its own actions.
And maybe the Gumball Machine can just delegate to the state object that represents the current state.
Well, I’m not 100% sure how this is going to work, but I think we’re on to something.
Joe:  I wonder if  this will this make it easier to add new states?
We’ll still have to change code, but the changes will be much more limited in scope because adding a new state will mean we just have to add a new class and maybe change a few transitions here and there.
First, we’re going to deﬁne a State interface that contains a method for every action in the Gumball Machine.
Then we’re going to implement a State class for every state of the machine.
These classes will be responsible for the behavior of the machine when it is in the corresponding state.
Finally, we’re going to get rid of all of our conditional code and instead delegate to the state class to do the work for us.
It looks like we’ve got a new plan: instead of  maintaining our existing code, we’re going to rework it to encapsulate state objects in their own classes and then delegate to the current state when an action occurs.
We’re following our design principles here, so we should end up with a design that is easier to maintain down the road.
Not only are we following design principles, as you’ll see, we’re actually implementing the State Pattern.
But we’ll get to all the ofﬁcial State Pattern stuff  after we rework our code...
First let’s create an interface for State, which all our states implement:
Then take each state in our design and  encapsulate it in a class that implements the State interface.
Sharpen your pencil To implement our states, we ﬁ rst need  to specify the behavior of the classes when each action is called.
Annotate the diagram below with the behavior of each action in each class; we’ve already ﬁ lled in a few for you.
Tell the customer, “Please wait, we’re already giving you a gumball.”
Go ahead and fill this out even though we’re implementing it later.
Time to implement a state: we know what behaviors we want; we just need to get it down in code.
We’re going to closely follow the state machine code we wrote, but this time everything is broken out into different classes.
We get passed a reference to the Gumball Machine through the constructor.
We’re just going to stash this in an instance variable.
You can’t get money back if you never gave it to us!
And, you can’t get a gumball if you don’t pay us.
Before we finish the State classes, we’re going to rework the Gumball Machine – that way you can see how it all fits together.
We’ll start with the state-related instance variables and switch the code from using integers to using state objects:
All the State objects are created and assigned in the constructor.
The count instance variable holds the count of gumballs – initially the machine is empty.
If there are more than 0 gumballs we set the state to the NoQuarterState.
Note that we don’t need an action method for dispense() in GumballMachine because it’s just an internal action; a user can’t ask the machine to dispense directly.
But we do call dispense() on the State object from the turnCrank() method.
The machine supports a releaseBall() helper method that releases the ball and decrements the count instance variable.
This method allows other objects (like our State objects) to transition the machine to a different state.
Implementing more states Now that you’re starting to get a feel for how the Gumball Machine and the states ﬁt together, let’s implement the HasQuarterState and the SoldState classes...
When the crank is turned we transition the machine to the SoldState state by calling its setState() method and passing it the SoldState object.
The SoldState object is retrieved by the getSoldState() getter method (there is one of these getter methods for each state)
If the crank is turned and not successful (say the customer didn’t insert a quarter ﬁrst), we call dispense anyway, even though it’s unnecessary.
Sharpen your pencil We have one remaining class we haven’t implemented: SoldOutState.
Why don’t you implement it? To do this, carefully think through how the Gumball Machine should behave in each situation.
For starters, you now have a Gumball Machine implementation that is structurally quite different from your ﬁ rst version, and yet functionally it is exactly the same.
Now let’s look a little more at the functional aspect of  what we did:
Let’s take a look at what we’ve done so far...
The current state of the machine is always one of these class instances.
In this case the turnCrank() method is being called when the machine is in the HasQuarter state, so as a result  the machine transitions to the Sold state.
Trace the steps of the Gumball Machine starting with the NoQuarter state.
Also annotate the diagram with actions and  output of the machine.
For this exercise you can assume there are plenty of gumballs in the machine.
The State Pattern allows an object to alter its behavior when its internal state changes.
Yes, it’s true, we just implemented the State Pattern!  So now, let’s take a look at what it’s all about:
The ﬁ rst part of  this description makes a lot of  sense, right?  Because the pattern encapsulates state into separate classes and delegates to the object representing the current state, we know that behavior changes along with the internal state.
The Gumball Machine provides a good example: when the gumball machine is in the NoQuarterState and you insert a quarter, you get different behavior (the machine accepts the quarter) than if  you insert a quarter when it’s in the HasQuarterState (the machine rejects the quarter)
What about the second part of  the deﬁ nition?  What does it mean for an object to “appear to change its class?”  Think about it from the perspective of  a client: if  an object you’re using can completely change its behavior, then it appears to you that the object is actually instantiated from another class.
In reality, however, you know that we are using composition to give the appearance of  a class change by simply referencing different state objects.
Okay, now it’s time to check out the State Pattern class diagram:
Whenever the request() is made on the Context it is delegated to the state to handle.
The State interface defines a common interface for all concrete states;  the states all implement the same interface, so they are interchangeable.
You’ve got a good eye!  Yes, the class diagrams are essentially the same, but the two patterns differ in their intent.
With the State Pattern, we have a set of  behaviors encapsulated in state objects; at any time the context is delegating to one of  those states.
Over time, the current state changes across the set of  state objects to reﬂect the internal state of  the context, so the context’s behavior changes over time as well.
The client usually knows very little, if  anything, about the state objects.
With Strategy, the client usually speciﬁes the strategy object that the context is composed with.
Now, while the pattern provides the ﬂexibility to change the strategy object at runtime, often there is a strategy object that is most appropriate for a context object.
For instance, in Chapter 1, some of  our ducks were conﬁgured to ﬂy with typical ﬂying behavior (like mallard ducks), while others were conﬁgured with a ﬂy behavior that kept them grounded (like rubber ducks and decoy ducks)
In general, think of  the Strategy Pattern as a ﬂexible alternative to subclassing;  if  you use inheritance to deﬁne the behavior of  a class, then you’re stuck with that behavior even if  you need to change it.
With Strategy you can change the behavior by composing with a different object.
Think of  the State Pattern as an alternative to putting lots of conditionals in your context; by encapsulating the behaviors within state objects, you can simply change the state object in context to change its behavior.
Q: In the GumballMachine, the states decide what the next state should be.
Do the ConcreteStates always decide what state to go to next?
The alternative is to let the Context decide on the flow of state transitions.
As a general guideline, when the state transitions are fixed they are appropriate for putting in the Context; however, when the transitions are more dynamic, they are typically placed in the state classes themselves (for instance, in the GumballMachine the choice of the transition to NoQuarter or SoldOut depended on the runtime count of gumballs)
The disadvantage of having state transitions in the state classes is that we create dependencies between the state classes.
In our implementation of the GumballMachine we tried to minimize this by using getter methods on the Context, rather than hardcoding explicit concrete state classes.
Notice that by making this decision, you are making a decision as to which classes are closed for modification – the Context or the state classes – as the system evolves.
The states are used by the Context to represent its internal state and behavior, so all requests to the states come from the Context.
It is the Context’s job to oversee its state, and you don’t usually want a client changing the state of a Context without that Context’s knowledge.
Q: If I have lots of instances of the Context in my application, is it possible to share the state objects across them?
A: Yes, absolutely, and in fact this is a very common scenario.
The only requirement is that your state objects do not keep their own internal state; otherwise, you’d need a.
To share your states, you’ll typically assign each state to a static instance variable.
If your state needs to make use of methods or instance variables in your Context, you’ll also have to give it a reference to the Context in each handler() method.
Q: It seems like using the State Pattern always increases the number of classes in our designs.
Look how many more classes our GumballMachine had than the original design!
A: You’re right, by encapsulating state behavior into separate state classes, you’ll always end up with more classes in your design.
Unless your code is some “one off” implementation you’re going to throw away (yeah, right), consider building it with the additional classes and you’ll probably thank yourself down the road.
Note that often what is important is the number of classes that you expose to your clients, and there are ways to hide these extra classes from your clients (say, by declaring them package visible)
Also, consider the alternative: if you have an application that has a lot of state and you decide not to use separate objects, you’ll instead end up with very large, monolithic conditional statements.
By using objects, you make states explicit and reduce the effort needed to understand and maintain your code.
Q: The State Pattern class diagram shows that State is an abstract class.
But didn’t you use an interface in the implementation of the gumball machine’s state?
Given we had no common functionality to put into an abstract class, we went with an interface.
In your own implementation, you might want to consider an abstract class.
Doing so has the benefit of allowing you to add methods to the abstract class later, without breaking the concrete state implementations.
We’ve got a game to implement; but now that we’ve got the State Pattern implemented, it should be a breeze.
First, we need to add a state to the GumballMachine class:
Now let’s implement the WinnerState class itself, it’s remarkably similar to the SoldState class:
As long as we have a second gumball we release it.
We’ve just got one more change to make: we need to implement the random chance game and add a transition to the WinnerState.
We’re going to add both to the HasQuarterState since that is where the customer turns the crank:
Wow, that was pretty simple to implement!  We just added a new state to the GumballMachine and then implemented it.
All we had to do from there was to implement our chance game and transition to the correct state.
It looks like our new code strategy is paying off...
If they won, and there’s enough gumballs left for them to get two, we go to the WinnerState; otherwise, we go to the SoldState (just like we always did)
The CEO of  Mighty Gumball has dropped by for a demo of  your new gumball game code.
Let’s hope those states are all in order!  We’ll keep the demo short and sweet (the short attention span of CEOs is well documented), but hopefully long enough so that we’ll win at least once.
Once, again, start with a gumball machine with 5 gumballs.
We want to get a winning state, so we just keep pumping in those quarters and turning the crank.
We print out the state of the gumball machine every so often...
YOU’RE A WINNER! You get two gumballs for your quarter A gumball comes rolling out the slot...
YOU’RE A WINNER! You get two gumballs for your quarter A gumball comes rolling out the slot...
Q: Why do we need the WinnerState?  Couldn’t we just have the SoldState dispense two gumballs?
SoldState and WinnerState are almost identical, except that WinnerState dispenses two gumballs instead of one.
You certainly could put the code to dispense two gumballs into the SoldState.
The downside is, of course, that now you’ve got TWO states represented in one State class: the state in which you’re a winner, and the state in which you’re not.
So you are sacrificing clarity in your State class to reduce code duplication.
Another thing to consider is the principle you learned in the previous chapter: One class, One responsibility.
By putting the WinnerState responsibility into the SoldState, you’ve just given the SoldState TWO responsibilities.
What happens when the promotion ends?  Or the stakes of the contest change?  So, it’s a tradeoff and comes down to a design decision.
Our sales are already going through the roof with the new game.
You know, we also make soda machines, and I was thinking we could put one of.
Yes, the CEO of  Mighty Gumball probably needs a sanity check, but that’s not what we’re talking about here.
Let’s think through some aspects of  the GumballMachine that we might want to shore up before we ship the gold version:
How would we do it?  We could make State into an abstract class and build in some default behavior for the methods; after all, error messages like, “You already inserted a quarter,” aren’t going to be seen by the customer.
So all “error response” behavior could be generic and inherited from the abstract State class.
While the machine operates correctly and doesn’t dispense unless it’s in the right state, we could easily ﬁx this by having turnCrank() return a boolean, or by introducing exceptions.
What problems might this cause?  Would we want to move that logic into the Gumball Machine?  What would be the advantages and disadvantages of  that?
What changes would this require to the GumballMachine and the States?
I was just over giving the Template Method guys a hand – they needed me to help them ﬁnish off  their chapter.
Same as always – helping classes to exhibit different behaviors in different states.
I don’t know, you always sound like you’ve just copied what I do and you’re using different words to describe it.
Think about it: I allow objects to incorporate different behaviors or algorithms through composition and delegation.
I admit that what we do is deﬁnitely related, but my intent is totally different than yours.
And, the way I teach my clients to use composition and delegation is totally different.
Well if  you spent a little more time thinking about something other than yourself, you might.
Anyway, think about how you work: you have a class you’re instantiating and you usually give it a strategy object that implements some behavior.
Like, in Chapter 1 you were handing out quack behaviors, right?  Real ducks got a real quack, rubber ducks got a quack that squeaked.
Okay, when my Context objects get created, I may tell them the state to start in, but then they change their own state over time.
Hey, come on, I can change behavior at runtime too; that’s what composition is all about!
Sure you can, but the way I work is built around discrete states;  my Context objects change state over time according to some well deﬁned state transitions.
In other words, changing behavior is built in to my scheme – it’s how I work!
Well, I admit, I don’t encourage my objects to have a well-deﬁned set of  transitions between states.
In fact, I typically like to control what strategy my objects are using.
Look, we’ve already said we’re alike in structure, but what we do is quite different in intent.
Face it, the world has uses for both of  us.
I mean, how many people are actually going to read this far? Are you kidding?  This is a Head First book and.
There’s one transition we forg ot to put in the original spec...
You did such a good job on the rest of the gumball machine w.
You’ve done some amazing work! I’ve got some more ideas that.
Shhhhh!  I’ll let you in on these ideas in the next chapter.
Encapsulate interchangeable behaviors and use delegation to decide which behavior to use.
Encapsulate state-based behavior and delegate behavior to the current state.
Tools for your   Design Toolbox It’s the end of another chapter; you’ve got enough patterns here to breeze through any job interview!
This code certainly isn’t adhering to the Open Closed Principle!
State transitions aren’t explicit; they are buried in the middle of  a bunch of conditional code.
Further additions are likely to cause bugs in working code.
Sharpen your pencil We have one remaining class we haven’t implemented: SoldOutState.
Why don’t you implement it? To do this, carefully think through how the Gumball Machine should behave in each situation.
Sharpen your pencil To implement the states, we ﬁ rst need to deﬁ ne what the behavior will be when the corresponding action is called.
Annotate the diagram below with the behavior of each action in each class; we’ve already ﬁ lled in a few for you.
Tell the customer “please wait, we’re already giving you a gumball” Tell the customer “sorry, you already turned the crank”
Tell the customer “turning twice doesn’t get you another gumball”
Tell the customer “please wait, we’re already giving you a gumball” Tell the customer “sorry, you already turned the crank”
Tell the customer “turning twice doesn’t get you another gumball”
Here the machine gives out a gumball by calling the internal dispense() action.
Encapsulate interchangeable behaviors and use delegation to decide which behavior to use.
Encapsulate state-based behavior and delegate behavior to the current state.
Sharpen your pencil We need you to write the reﬁll() method for the Gumball machine.
It has one argument, the number of  gumballs you’re adding to the machine, and should update the gumball machine count and reset the machine’s state.
As you’re going to see, there are lots of ways in which proxies stand in for the.
Proxies have been known to haul entire method calls over the Internet for.
With you as my Proxy, I’ll be able to triple the amount of lunch money I can extract from friends!
If  you remember, we’ve already got methods in the gumball machine code for getting the count of  gumballs (getCount()),  and getting the current state of  the machine (getState())
All we need to do is create a report that can be printed out and sent back to the CEO.
Hmmm, we should probably add a location ﬁeld to each gumball machine as well; that way the CEO can keep the machines straight.
Can you ﬁnd a way to get me a report of inventory and machine state?
Now let’s create another class, GumballMonitor, that retrieves the machine’s location, inventory of  gumballs and the current machine state and prints them in a nice little report:
The monitor takes the machine in its constructor and assigns it to the machine instance variable.
Our report method just prints a report with location, inventory and the machine’s state.
Let’s start by adding support to the GumballMachine class so that it can handle locations:
The location is passed into the constructor and stored in the instance variable.
The CEO is going to be thrilled and amazed by our development skills.
Now we just need to instantiate a GumballMonitor and give it a machine to monitor:
Don’t forget to give the constructor a location and count...
When we need a report on the machine, we call the report() method.
Pass in a location and initial # of gumballs on the command line.
The monitor output looks great, but I guess I wasn’t clear.
Well, that will teach us to gather some requirements before we jump in and code.
Think about it: we’ve already got the monitor code written, right?  We give the GumballMonitor a reference to a machine and it gives us a report.
The problem is that monitor runs in the same JVM as the gumball machine and the CEO wants to sit at his desk and remotely monitor the machines!  So what if  we left our GumballMonitor class as is, but handed it a proxy to a remote object?
In this case, the proxy acts just like it is a Gumball Machine object, but behind the scenes it is communicating over the network to talk to the real, remote GumballMachine.
Joe:  And this proxy pretends it’s the real object, but it’s really just communicating over the net to the real object.
Joe:  It sounds like something that is easier said than done.
Frank:  Perhaps, but I don’t think it’ll be that bad.
We have to make sure that the gumball machine can act as a service and accept requests over the network; we also need to give our monitor a way to get a reference to a proxy object, but we’ve got some great tools already built into Java to help us.
Don’t worry guys, I’ve been brushing up on my design.
All we need is a remote proxy and we’ll be ready to go.
A remote proxy acts as a local representative to a remote object.
What’s a “remote object?”  It’s an object that lives in the heap of  a different Java Virtual Machine (or more generally, a remote object that is running in a different address space)
What’s a “local representative?” It’s an object that you can call local methods on and have them forwarded on to the remote object.
Your client object acts like it’s making remote method calls.
But what it’s really doing is calling methods on a heaplocal ‘proxy’ object that handles all the low-level details of network communication.
Before going further, think about how you’d design a system to enable remote method invocation.
How would you make it easy on the developer so that she has to write as little code as possible? How would you make the remote invocation look seamless?
Should making remote calls be totally transparent?  Is that a good idea?  What might be a problem with that approach?
Hold on now, we aren’t going to write that code.
All we have to do is retroﬁt our code so that it.
Then I presume when the call is complete, the result gets sent back over the.
But it seems to me this code is going to be very.
Adding a remote proxy to the Gumball Machine monitoring code On paper this looks good, but how do we create a proxy that knows how to invoke a method on an object that lives in another JVM?
Well, you can’t get a reference to something on another heap, right? In other words, you can’t say:
Whatever the variable d is referencing must be in the same heap space as the code running the statement.
So how do we approach this?  Well, that’s where Java’s Remote Method Invocation comes in...
You may have encountered RMI in Head First Java; if  not, we’re going to take a slight detour and come up to speed on RMI before adding the proxy support to the Gumball Machine code.
If you’re new to RMI, take the detour that runs over the next few pages; otherwise, you might want to just quickly thumb through the detour as a review.
First, we’re going to take the RMI Detour and check RMI out.
Even if you are familiar with RMI, you might want to follow along and check out the scenery.
Then we’re going to take our GumballMachine and make it a remote service that provides a set of methods calls that can be invoked remotely.
Then, we going to create a proxy that can talk to a remote GumballMachine, again using RMI, and put the monitoring system back together so that the CEO can monitor any number of remote machines.
Let’s say we want to design a system that allows us to call a local object that forwards each request to a remote object.
How would we design it?  We’d need a couple of  helper objects that actually do the communicating for us.
The helpers make it possible for the client to act as though it’s calling a method on a local object (which in fact, it is)
The client calls a method on the client helper, as if  the client helper were the actual service.
The client helper then takes care of  forwarding that request for us.
In other words, the client object thinks it’s calling a method on the remote service, because the client helper is pretending to be the service object.
Pretending to be the thing with the method the client wants to call.
Although the client helper acts like it (because it has the same method that the service is advertising), the client helper doesn’t have any of  the actual method logic the client is expecting.
On the server side, the service helper receives the request from the client helper (through a Socket connection), unpacks the information about the call, and then invokes the real method on the real service object.
It’s coming from the service helper, not a remote client.
The service helper gets the return value from the service, packs it up, and ships it back (over a Socket’s output stream) to the client helper.
The client helper unpacks the information and returns the value to the client object.
Service helper gets the request from the client helper, unpacks it, and calls the method on the Real Service.
How the method call happens 1 Client object calls doBigThing() on the client helper object.
Service helper unpacks the information from the client helper, ﬁnds out which method to call (and on which object) and invokes the real method on the real service object.
The method is invoked on the service object, which returns some result to the service helper.
Service helper packages up information returned from the call and ships it back over the network to the client helper.
Client helper unpackages the returned values and returns them to the client object.
Okay, you’ve got the gist of  how remote methods work; now you just need to understand how to use RMI to enable remote method invocation.
What RMI does for you is build the client and service helper objects, right down to creating a client helper object with the same methods as the remote service.
The nice thing about RMI is that you don’t have to write any of  the networking or I/O code yourself.
With your client, you call remote methods (i.e., the ones the Real Service has) just like normal method calls on objects running in the client’s own local JVM.
There is one difference between RMI calls and local (normal) method calls.
Remember that even though to the client it looks like the method call is local, the client helper sends the method call across the network.
And what do we know about networking and I/O methods?
They’re risky!  They can fail! And so, they throw exceptions all over the place.
As a result, the client does have to acknowledge the risk.
Now let’s go through all the steps needed to make an object into a service that can accept remote calls and also the steps needed to allow a client to make remote calls.
You might want to make sure your seat belt is fastened; there are a lot of steps and a few bumps and curves – but nothing to be too worried about.
Newer versions of Java don’t require an explicit skeleton object, but something on the server side is still handling skeleton behavior.
This is an overview of  the ﬁ ve steps for making the remote service.
In other words, the steps needed to take an ordinary object and supercharge it so it can be called by a remote client.
For now, let’s get the steps down and then we’ll explain each one in detail.
The remote interface deﬁ nes the methods that a client can call remotely.
It’s what the client will use as the class type for your service.
It has the real implementation of  the remote methods deﬁ ned in the remote interface.
You don’t have to create these classes or ever look at the source code that generates them.
It’s all handled automatically when you run the rmic tool that ships with your Java development kit.
The rmiregistry is like the white pages of  a phone book.
It’s where the client goes to get the proxy (the client stub/helper object)
You have to get the service object up and running.
Your service implementation class instantiates an instance of  the service and registers it with the RMI registry.
Remote is a ‘marker’ interface, which means it has no methods.
It has special meaning for RMI, though, so you must follow this rule.
The remote interface is the one the client uses as the type for the service.
In other words, the client invokes methods on something that implements the remote interface.
That something is the stub, of  course, and since the stub is doing networking and I/O, all kinds of  Bad Things can happen.
The client has to acknowledge the risks by handling or declaring the remote exceptions.
If the methods in an interface declare exceptions, any code calling methods on a reference of  that type (the interface type) must handle or declare the exceptions.
Arguments and return values of  a remote method must be either primitive or Serializable.
Any argument to a remote method has to be packaged up and shipped across the network, and that’s done through Serialization.
If  you use primitives, Strings, and the majority of  types in the API (including arrays and collections), you’ll be ﬁne.
If  you are passing around your own types, just be sure that you make your classes implement Serializable.
Declaring RemoteException on every method forces the client to pay attention and acknowledge that things might not work.
This return value is gonna be shipped over the wire from the server back to the client, so it must be Serializable.
That’s how args and return values get packaged up and sent.
Check out Head First Java if you need to refresh your memory on Serializable.
Your service has to implement the remote interface—the one with the methods your client is going to call.
In order to work as a remote service object, your object needs some functionality related to ‘being remote’
The only way to deal with this is to declare a constructor for your remote implementation, just so that you have a place to declare the RemoteException.
Remember,  when a class is instantiated, its superclass constructor is always called.
If  your superclass constructor throws an exception, you have no choice but to declare that your constructor also throws an exception.
Now that you’ve got a remote service, you have to make it available to remote clients.
You do this by instantiating it and putting it into the RMI registry (which must be running or this line of  code fails)
When you register the implementation object, the RMI system actually puts the stub in the registry, since that’s what the client really needs.
The compiler will make sure that you’ve implemented all the methods from the interface you implement.
Run rmic on the remote implementation class (not the remote interface)
The rmic tool, which comes with the Java software development kit, takes a service implementation and creates two new classes, the stub and the skeleton.
There are other options with rmic, including not generating skeletons, seeing what the source code for these classes looked like, and even using IIOP as the protocol.
The way we’re doing it here is the way you’ll usually do it.
Remember, rmic must be able to see your implementation class, so you’ll probably run rmic from the directory where your remote implementation is located.
We’re deliberately not using packages here, to make it simpler.
Be sure you start it from a directory that has access to your classes.
The simplest way is to start it from your ‘classes’ directory.
This might be from a main() method in your remote implementation class, or from a separate launcher class.
In this simple example, we put the starter code in the implementation class, in a main method that instantiates the object and registers it with RMI registry.
You have to implement all the interface methods, of course.
But notice that you do NOT have to declare the RemoteException.
Make the remote object, then ‘bind’ it to the rmiregistery using the static Naming.rebind()
The name you register it under is the name clients will use to look it up in the RMI registry.
The client has to get the stub object (our proxy), since that’s the thing the client will call methods on.
The client does a ‘lookup’, like going to the white pages of  a phone book, and essentially says, “Here’s a name, and I’d like the stub that goes with that name.”
Let’s take a look at the code we need to lookup and retrieve a stub object.
The client always uses the remote interface as the type of the service.
In fact, the client never needs to know the actual class name of your remote service.
You have to cast it to the interface, since the lookup method returns type Object.
The host name or IP address where the service is running.
This must be the name that the service was registered under.
You MUST have the stub class (that rmic generated for you) on the client or the stub won’t be deserialized.
Client invokes a method on the stub, as if the stub IS the real service.
Somehow, some way, the client must have the stub class (that you generated earlier using rmic) at the time the client does the lookup, or else the stub won’t be deserialized on the client and the whole thing blows up.
The client also needs classes for any serialized objects returned by method calls to the remote object.
In a simple system, you can simply hand-deliver the these classes to the client.
There’s a much cooler way, although it’s beyond the scope of this book.
But just in case you’re interested, the cooler way is called “dynamic class downloading”
With dynamic class downloading, Serialized objects (like the stub) are “stamped”with a URL that tells the RMI system on the client where to ﬁnd the class ﬁle for that object.
Then, in the process of deserializing an object, if RMI can’t ﬁnd the class locally, it uses that URL to do an HTTP Get to retrieve the class ﬁle.
So you’d need a simple web server to serve up class ﬁles, and you’d also need to change some security parameters on the client.
There are a few other tricky issues with dynamic class downloading, but that’s the overview.
For the stub object speciﬁcally, there’s another way the client can get the class.
We’ll brieﬂy talk about this near the end of the chapter.
The Naming class (for doing the rmiregistry lookup) is in the java.rmi package.
The top three things programmers do wrong with RMI are:
Don’t forget, the client uses the remote interface to call methods on the stub.
The client JVM needs the stub class, but the client never refers to the stub class in code.
The client always uses the remote interface, as though the remote interface WERE the actual remote object.
Server needs both the Stub and Skeleton classes, as well as the service and the remote interface.
It needs the stub class because remember, the stub is substituted for the real service when the real service is bound to the RMI registry.
The skeleton accepts the remote calls and makes everything work on the service side.
Back to our GumballMachine remote proxy Okay, now that you have the RMI basics down, you’ve got the tools you need to implement the gumball machine remote proxy.
Let’s take a look at how the GumballMachine ﬁts into this framework:
Getting the GumballMachine ready to be a remote service The ﬁrst step in converting our code to use the remote proxy is to enable the GumballMachine to service remote requests from clients.
In other words, we’re going to make it into a service.
This will provide a set of  methods that can be called remotely.
Make sure all the return types in the interface are serializable.
This is the remote interface.Don’t forg et to import java.rmi.*
We have one return type that isn’t Serializable: the State class.
Actually, we’re not done with Serializable yet; we have one problem with State.
As you may remember, each State object maintains a reference to a gumball machine so that it can call the gumball machine’s methods and change its state.
We don’t want the entire gumball machine serialized and transferred with the State object.
We’ve already implemented our GumballMachine, but we need to make sure it can act as a service and handle requests coming from over the network.
As you’ve already seen in the RMI detour, this is quite simple, all we need to do is add a couple of  things...
Now we just need to ﬁre it up so it can receive requests.
First, we need to make sure we register it with the RMI registry so that clients can locate it.
We’re going to add a little code to the test drive that will take care of  this for us:
First we need to add a try/catch block around the gumball instantiation because our constructor can now throw exceptions.
We also add the call to Naming.rebind, which publishes the GumballMachine stub under the name gumballmachine.
This gets the GumballMachine up and running and registers it with the RMI registry.
Remember the GumballMonitor?  We wanted to reuse it without having to rewrite it to work over a network.
Well, we’re pretty much going to do that, but we do need to make a few changes.
We also need to catch any remote exceptions that might happen as we try to invoke methods that are ultimately happening over the network.
Writing the Monitor test drive Now we’ve got all the pieces we need.
We just need to write some code so the CEO can monitor a bunch of  gumball machines:
We create an array of locations, one for each machine.
Now we need to get a proxy to each remote machine.
On each machine, run rmiregistry in the background or from a separate terminal window...
Remember, Naming.lookup() is a static method in the RMI package that takes a location and service name and looks it up in the rmiregistry at that location.
This returns a proxy to the remote Gumball Machine (or throws an exception if one can’t be located)
Okay, it’s time to put all this work together and give another demo.
First let’s make sure a few gumball machines are running the new code:
And now let’s put the monitor in the hands of the CEO.
The monitor iterates over each remote machine and calls its getLocation(), getCount() and getState() methods.
This is amazing; it’s going to revolutionize my business and blow away the.
By invoking methods on the proxy, a remote call is made across the wire and a String, an integer and a State object are returned.
Because we are using a proxy, the GumballMonitor doesn’t know, or care, that calls are remote (other than having to worry about remote exceptions)
This worked great! But I want to make sure I.
The CEO runs the monitor, which ﬁrst grabs the proxies to the remote gumball machines and then calls getState() on each one (along with getCount() and getLocation())
The skeleton receives the request and then forwards it to the gumball machine.
GumballMachine returns the state to the skeleton, which serializes it and transfers it back over the wire to the proxy.
The proxy deserializes it and returns it as an object to the monitor.
Likewise, the GumballMachine implements another interface and may throw a remote exception in its constructor, but other than that, the code hasn’t changed.
We also have a small bit of code to register and locate stubs using the RMI registry.
But no matter what, if we were writing something to work over the Internet, we’d need some kind of locator service.
Well, we’ve seen how the Proxy Pattern provides a surrogate or placeholder for another object.
We’ve also described the proxy as a “representative” for another object.
But what about a proxy controlling access?  That sounds a little strange.
In the case of  the gumball machine, just think of  the proxy controlling access to the remote object.
The proxy needed to control access because our client, the monitor, didn’t know how to talk to a remote object.
So in some sense the remote proxy controlled access so that it could handle the network details for us.
As we just discussed, there are many variations of the Proxy Pattern, and the variations typically revolve around the way the proxy “controls access.”  We’re going to talk more about this later, but for now here are a few ways proxies control access:
Now that you’ve got the gist of  the general pattern, check out the class diagram...
The Proxy Pattern provides a surrogate or placeholder for another object to control access to it.
We’ve already put a lot of  pages behind us in this chapter; as you can see, explaining the Remote Proxy is quite involved.
Despite that, you’ll see that the deﬁnition and class diagram for the Proxy Pattern is actually fairly straightforward.
Note that Remote Proxy is one implementation of  the general Proxy Pattern; there are actually quite a few variations of  the pattern, and we’ll talk about them later.
For now, let’s get the details of  the general pattern down.
Use the Proxy Pattern to create a representative object that controls access to another object, which may be remote, expensive to create or in need of securing.
The RealSubject is usually the object that does most of the real work; the Proxy controls access to it.
The Proxy often instantiates or handles the creation of the RealSubject.
First we have a  Subject, which provides an interface for the RealSubject and the Proxy.
By implementing the same interface, the Proxy can be substituted for the RealSubject anywhere it occurs.
The RealSubject is the object that does the real work.
It’s the object that the Proxy represents and controls access to.
In some cases, the Proxy may be responsible for creating and destroying the RealSubject.
Because the Proxy and RealSubject implement the same interface (Subject), the Proxy can be substituted anywhere the subject can be used.
The Proxy also controls access to the RealSubject; this control may be needed if  the Subject is running on a remote machine, if  the Subject is expensive to create in some way or if  access to the subject needs to be protected in some way.
Now that you understand the general pattern, let’s look at some other ways of  using proxy beyond the Remote Proxy...
Get ready for Virtual Proxy Okay, so far you’ve seen the deﬁnition of  the Proxy Pattern and you’ve taken a look at one speciﬁc example: the Remote Proxy.
Now we’re going to take a look at a different type of  proxy, the Virtual Proxy.
As you’ll discover, the Proxy Pattern can manifest itself  in many forms, yet all the forms follow roughly the general proxy design.
Why so many forms?  Because the proxy pattern can be applied to a lot of  different use cases.
With Remote Proxy, the proxy acts as a local representative for an object that lives in a different JVM.
A method call on the proxy results in the call being transferred over the wire, invoked remotely, and the result being returned back to the proxy and then to the Client.
Virtual Proxy Virtual Proxy acts as a representative for an object that may be expensive to create.
The Virtual Proxy often defers the creation of the object until it is needed; the Virtual Proxy also acts as a surrogate for the object before and while it is being created.
After that, the proxy delegates requests directly to the RealSubject.
The proxy may handle the request, or if the RealSubject has been created, delegate the calls to the  RealSubject.
While the CD cover is loading, the proxy displays a message.
Displaying  CD covers Let’s say you want to write an application that displays your favorite compact disc covers.
You might create a menu of  the CD titles and then retrieve the images from an online service like Amazon.com.
If  you’re using Swing, you might create an Icon and ask it to load the image from the network.
The only problem is, depending on the network load and the bandwidth of  your connection, retrieving a CD cover might take a little time, so your application should display something while you are waiting for the image to load.
We also don’t want to hang up the entire application while it’s waiting on the image.
Once the image is loaded, the message should go away and you should see the image.
An easy way to achieve this is through a virtual proxy.
The virtual proxy can stand in place of  the icon, manage the background loading,  and before the image is fully retrieved from the network, display “Loading CD cover, please wait...”
Once the image is loaded, the proxy delegates the display to the Icon.
This is our proxy, which first displays a message and then when the image is loaded, delegates to ImageIcon to display the image.
This is the Swing Icon interface used to display images in a user interface.
Before writing the code for the CD Cover Viewer, let’s look at the class diagram.
You’ll see this looks just like our Remote Proxy class diagram, but here the proxy is used to hide an object that is expensive to create (because we need to retrieve the data for the Icon over the network) as opposed to an object that actually lives somewhere else on the network.
ImageProxy ﬁ rst creates an ImageIcon and starts loading it from a network URL.
While the bytes of the image are being retrieved, ImageProxy displays  “Loading CD cover, please wait...”
When the image is fully loaded, ImageProxy delegates all method calls to the image icon, including paintIcon(), getWidth() and getHeight()
If the user requests a new image, we’ll create a new proxy and start the process over.
We pass the URL of the image into the constructor.
This is the image we need to display once it’s loaded!
The imageIcon is the REAL icon that we eventually want to display when it’s loaded.
We return a default width and height until the imageIcon is loaded; then we turn it over to the imageIcon.
This code paints the icon on the screen (by delegating to the imageIcon)
However, if we don’t have a fully created ImageIcon, then we create one.
This method is called when it’s time to paint the icon on the screen.
If we’ve got an icon already, we go ahead and tell it to paint itself.
Its constructor will not return until the image is loaded.
If we aren’t already trying to retr ieve the image...
When we have the image, we tell Swing that we need to be repainted.
So, the next time the display is painted after the ImageIcon is instantiated, the paintIcon method will paint the image, not the loading message.
The ImageProxy class appears to have two states that are controlled by conditional statements.
Can you think of another pattern that might clean up this code?  How would you redesign ImageProxy?
Here we create an image proxy and set it to an initial URL.
Whenever you choose a selection from the CD menu, you’ll get a new image proxy.
Okay, it’s time to test out this fancy new virtual proxy.
We don’t go through all that code in gory detail here, but you can always grab the source code and have a look, or check it out at the end of the chapter where we list all the source code for the Virtual Proxy.
Next we wrap our proxy in a component so it can be added to the frame.
The component will take care of the proxy’s width, height and similar details.Finally we add the proxy to the frame.
Use the menu to load different CD covers; watch the proxy display “loading” until the image has arrived.
Notice that the proxy is handling the loading without hanging up the Swing window.
The paintIcon() method is called and  ImageProxy ﬁ res off a thread to retrieve the image and create the ImageIcon.
At some point the image is returned and the ImageIcon fully instantiated.
After the ImageIcon is created, the next time paintIcon() is called, the proxy delegates to the ImageIcon.
A: You’ll ﬁnd a lot of variants of the Proxy Pattern in the real world; what they all have in common is that they intercept a method invocation that the client is making on the subject.
This level of indirection allows us to do many things, including dispatching requests to a remote subject, providing a representative for an expensive object as it is created, or, as you’ll see, providing some level of protection that can determine which clients should be calling which methods.
That’s just the beginning; the general Proxy Pattern can be applied in many different ways, and we’ll cover some of the other ways at the end of the chapter.
I mean, we are basically wrapping one object with another and then delegating the calls to the ImageIcon.
A: Sometimes Proxy and Decorator look very similar, but their purposes are different: a decorator adds behavior to a class, while a proxy controls access to it.
You might say, “Isn’t the loading message adding behavior?”  In some.
How does it control access?  Well,  think about it this way: the proxy is decoupling the client from the ImageIcon.
If they were coupled the client would have to wait until each image is retrieved before it could paint it entire interface.
The proxy controls access to the ImageIcon so that before it is fully created, the proxy provides another on screen representation.
One common technique is to provide a factory that instantiates and returns the subject.
Because this happens in a factory method we can then wrap the subject with a proxy before returning it.
The client never knows or cares that it’s using a proxy instead of the real thing.
Q: I noticed in the ImageProxy example, you always create a new ImageIcon to get the image, even if the image has already been retrieved.
Could you implement something similar to the ImageProxy that caches past retrievals?
A: You are talking about a specialized form of a Virtual Proxy called a Caching Proxy.
A caching proxy maintains a cache of previous created objects and when a request is made it returns  cached object, if possible.
We’re going to look this and at several other variants of the Proxy Pattern at the end of the chapter.
Q: I see how Decorator and Proxy relate, but what about Adapter?  An adapter seems very similar as well.
A: Both Proxy and Adapter sit in front of other objects and forward requests to them.
Remember that Adapter changes the interface of the objects it adapts, while the Proxy implements the same interface.
There is one additional similarity that relates to the Protection Proxy.
A Protection Proxy may allow or disallow a client access to particular methods in an object based on the role of the client.
In this way a Protection Proxy may only provide a partial interface to a client, which is quite similar to some Adapters.
We are going to take a look at Protection Proxy in a few pages.
I presume you’re here because people sometimes get us confused?
Well, I think the reason people get us confused is that you go around pretending to be an entirely different pattern, when in fact, you’re just a Decorator in disguise.
I really don’t think you should be copying all my ideas.
My job is so much more important than yours it’s just not even funny.
You can call it “representation” but if  it looks like a duck and walks like a duck...
I mean, just look at  your Virtual Proxy; it’s just another way of  adding behavior to do something while some big expensive object is loading, and your Remote Proxy is a way of  talking to remote objects so your clients don’t have to bother with that themselves.
Clients use me as a surrogate of  a Real Subject, because I can protect them from unwanted access, or keep their GUIs from hanging up while they’re waiting for big objects to load, or hide the fact that their Subjects are running on remote machines.
That’s the most important thing about objects - what they do!
I implement the same interface as the objects I wrap; so do you.
Okay, but we all know remote proxies are kinda weird.
While sometimes we informally say a proxy wraps its Subject, that’s not really an accurate term.
When the client ﬁrst uses me as a proxy the subject doesn’t even exist!  So what am I wrapping there?
Hey, after this conversation I’m convinced you’re just a dumb proxy!
Dumb proxy? I’d like to see you recursively wrap an object with 10 decorators and keep your head straight at the same time.
Uh huh, and the next thing you’ll be saying is that you actually get to create objects.
I never knew decorators were so dumb!  Of course I sometimes create objects, how do you think a virtual proxy gets its subject! Okay, you just pointed out a big difference between us: we both know decorators only add window dressing; they never get to instantiate anything.
Very seldom will you ever see a proxy get into wrapping a subject multiple times; in fact, if you’re wrapping something 10 times, you better go back reexamine your design.
Just like a proxy, acting all real when in fact you.
Using the Java API’s Proxy to create a protection proxy.
Java’s got its own proxy support right in the   java.lang.reﬂ ect package.
With this package, Java lets you create a proxy class on the ﬂ y that implements one or more interfaces and forwards method invocations to a class that you specify.
Because the actual proxy class is created at runtime, we refer to this Java  technology as a dynamic proxy.
We’re going to use Java’s dynamic proxy to create our next proxy implementation (a protection proxy), but before we do that, let’s quickly look at a class diagram that shows how dynamic proxies are put together.
Like most things in the real world, it differs slightly from the classic deﬁ nition of  the pattern:
The Proxy is generated by Java and implements the entire Subject interface.
Because Java creates the Proxy class for you, you need a way to tell the Proxy class what to do.
You can’t put that code into the Proxy class like we did before, because you’re not implementing one directly.
So, if you can’t put this code in the Proxy class, where do you put it?  In an InvocationHandler.
The job of  the InvocationHandler is to respond to any method calls on the proxy.
Think of  the InvocationHandler as the object the Proxy asks to do all the real work after it’s received the method calls.
Okay, let’s step through how to use the dynamic proxy...
Every town needs a matchmaking service, right?  You’ve risen to the task and implemented a dating service for Objectville.
You’ve also tried to be innovative by including a “Hot or Not” feature in the service where participants can rate each other – you ﬁgure this keeps your customers engaged and looking through possible matches; it also makes things a lot more fun.
Your service revolves around a Person bean that allows you to set and get information about a person:
Here we can get information about the person’s name, gender, interests and HotOrNot rating (1-10)
We can also set the same information through the respective method calls.
And here’s all the setter methods, which set the corresponding instance variable.
I also noticed that a lot of people are bumping up their HotOrNot scores by giving.
You shouldn’t be able to change someone else’s interests or give.
While we suspect other factors may be keeping Elroy from getting dates, he is right: you shouldn’t be able to vote for yourself  or to change another customer’s data.
The way our PersonBean is deﬁned, any client can call any of  the methods.
This is a perfect example of  where we might be able to use a Protection Proxy.
What’s a Protection Proxy?  It’s a proxy that controls access to an object based on access rights.
For instance, if  we had an employee object, a protection proxy might allow the employee to call certain methods on the object, a manager to call additional methods (like setSalary()), and a human resources employee to call any method on the object.
In our dating service we want to make sure that a customer can set his own information while preventing others from altering it.
We also want to allow just the opposite with the HotOrNot ratings: we want the other customers to be able to set the rating, but not that particular customer.
We also have a number of  getter methods in the PersonBean, and because none of  these return private information, any customer should be able to call them.
Five minute drama: protecting subjects The Internet bubble seems a distant memory; those were the days when all you needed to do to ﬁnd a better, higher-paying job was to walk across the street.
I’d like to make an offer, can we get her on.
We think we can meet her current salary plus 15%
Big Picture: creating a  Dynamic Proxy for the PersonBean We have a couple of  problems to ﬁ x: customers shouldn’t be changing their own HotOrNot rating and customers shouldn’t be able to change other customers’ personal information.
To ﬁ x these problems we’re going to create two proxies: one for accessing your own PersonBean object and one for accessing another customer’s PersonBean object.
That way, the proxies can control what requests can be made in each circumstance.
As you’ll see Java will take care of  creating the actual proxy class and object, we just need to supply a handler that knows what to do when a method is called on it.
We need to write a little bit of  code to generate the proxy class and instantiate it.
When we need to use a PersonBean object, either it’s the object of  the customer himself (in that case, will call him the “owner”), or it’s another user of  the service that the customer is checking out (in that case we’ll call him “nonowner”)
In either case, we create the appropriate proxy for the PersonBean.
To create these proxies we’re going to use the Java API’s dynamic proxy that you saw a few pages back.
Java will create two proxies for us; all we need to do is supply the handlers that know what to do when a method is invoked on the proxy.
We know we need to write two invocation handlers, one for the owner and one for the non-owner.
But what are invocation handlers?  Here’s the way to think about them: when a method call is made on the proxy, the proxy forwards that call to your invocation handler, but not by calling the invocation handler’s corresponding method.
So, what does it call?  Have a look at the InvocationHandler interface:
There’s only one method, invoke(), and no matter what methods get called on the proxy, the invoke() method is what gets called on the handler.
The proxy then turns around and calls invoke() on the InvocationHandler.
The handler decides what it should do with the request and possibly forwards it on to the RealSubject.
How does the handler decide? We’ll ﬁ nd out next.
Here’s how we invoke the method on the Real Subject.
When invoke() is called by the proxy, how do you know what to do with the call? Typically, you’ll examine the method that was called on the proxy and make decisions based on the method’s name and possibly its arguments.
We’re passed the Real Subject in the constructor and we keep a reference to it.
Here’s the invoke method that gets called every time a method is invoked on the proxy.
If the method is a getter, we go ahead and invoke it on the real subject.
Because we are the owner any other set method is fine and we go ahead and invoke it on the real subject.
If any other method is called, we’re just going to return null rather than take a chance.
This will happen if the real subject throws an exception.
Now, all we have left is to dynamically create the proxy class and instantiate the proxy object.
Let’s start by writing a method that takes a PersonBean and knows how to create an owner proxy for it.
Step two: creating the Proxy class and instantiating the Proxy object.
Now this is some mighty ugly code, so let’s step through it carefully.
To create a proxy we use the static newProxyInstance method on the Proxy class...
We pass the real subject into the constructor of the invocation handler.
If you look back two pages you’ll see this is how the handler gets access to the real subject.
Sharpen your pencil While it is a little complicated, there isn’t much to creating a dynamic proxy.
Take it further: can you write one method getProxy() that takes a handler and a person and returns a proxy that uses that handler?
Let’s give the matchmaking service a test run and see how it controls access to the setter methods based on the proxy that is used.
Main just creates the test drive and calls its drive() method to get things going.
The constructor initializes our DB of people in the matchmaking service.
Our Owner proxy allows getting and setting, except for the HotOrNot rating.
Our NonOwner proxy allows getting only, but also allows calls to set the HotOrNot rating.
Q: So what exactly is the “dynamic” aspect of dynamic proxies?  Is it that I’m instantiating the proxy and setting it to a handler at runtime?
A: No, the proxy is dynamic because its class is created at runtime.
Think about it: before your code runs there is no proxy class; it is created on demand from the set of interfaces you pass it.
Q: My InvocationHandler seems like a very strange proxy, it doesn’t implement any of the methods of the class it’s proxying.
Q: Is there any way to tell if a class is a Proxy class?
Calling this method with a class will return true if the class is a dynamic proxy class.
Other than that, the proxy class will act like any other class that implements a particular set of interfaces.
First, it is worth pointing out that we always pass newProxyInstance() an array of interfaces – only interfaces are allowed, no classes.
The major restrictions are that all non-public interfaces need to be from the same package.
You also can’t have interfaces with clashing method names (that is, two interfaces with a method with the same signature)
There are a few other minor nuances as well, so at some point you should take a look at the ﬁne print on dynamic proxies in the javadoc.
Q: Why are you using skeletons? I thought we got rid of those back in Java 1.2
A: You’re right; we don’t need to actually generate skeletons.
As of Java 1.2, the RMI runtime can dispatch the client calls directly to the remote service using reﬂection.
But we like to show the skeleton, because conceptually it helps you to understand that there is something under the covers that’s making that communication between the client stub and the remote service happen.
Q: I heard that in Java 5, I don’t even need to generate stubs anymore either.
In Java 5, RMI and Dynamic Proxy got together and now stubs are generated dynamically using Dynamic Proxy.
So, now you don’t have to use rmic at all; everything you need to get a client talking to a remote object is handled for you behind the scenes.
Wraps another object and provides a different interface to it.
You now know about the remote, virtual and protection proxies, but out in the wild you’re going to see lots of  mutations of  this pattern.
Over here in the Proxy corner of  the zoo we’ve got a nice collection of  wild proxy patterns that we’ve captured for your study.
Our job isn’t done; we are sure you’re going to see more variations of this pattern in the real world, so give us a hand in cataloging more proxies.
It can also allow multiple clients to share the results to reduce computation or network latency.
Habitat: often seen in web server proxies as well as content management and publishing systems.
Synchronization Proxy provides safe access to a subject from multiple.
This is sometimes called the Facade Proxy for obvious reasons.
Copy-On-Write Proxy controls the copying of an object by deferring the copying of an.
Seen hanging around JavaSpaces, where it controls synchronized access to an underlying set of objects in a distributed environment.
Field Notes: please add your observations of other proxies in the wild here:
Why not unwind by doing a crossword puzzle before it ends?
Tools for your   Design Toolbox Your design toolbox is almost full; you’re prepared for almost any design problem that comes your way.
There are a number of ways it can manage that access.
Our ImageProxy class appears to have two states that are controlled by conditional statements.
Can you think of another pattern that might clean up this code?  How would you redesign ImageProxy?
Then put the code from the if  statements into their respective states.
Start in the ImageNotLoaded state and then transition to the ImageLoaded state once the ImageIcon had been retrieved.
Sharpen your pencil While it is a little complicated, there isn’t much to creating a dynamic proxy.
Get ready to take your pattern skills to the next level;  it’s time.
Working together One of  the best ways to use patterns is to get them out of  the house so they can interact with other patterns.
The more you use patterns the more you’re going to see them showing up together in your designs.
We have a special name for a set of  patterns that work together in a design that can be applied over many problems: a compound pattern.
That’s right, we are now talking about patterns made of  patterns!
You’ll ﬁnd a lot of  compound patterns in use in the real world.
Now that you’ve got patterns in your brain, you’ll see that they are really just patterns working together, and that makes them easier to understand.
We’re going to start this chapter by revisiting our friendly ducks in the SimUDuck duck simulator.
It’s only ﬁtting that the ducks should be here when we combine patterns; after all, they’ve been with us throughout the entire book and they’ve been good sports about taking part in lots of  patterns.
The ducks are going to help you understand how patterns can work together in the same solution.
But just because we’ve combined some patterns doesn’t mean we have a solution that qualiﬁes as a compound pattern.
For that, it has to be a general purpose solution that can be applied to many problems.
So, in the second half  of  the chapter we’ll visit a real compound pattern: that’s right, Mr.
If  you haven’t heard of him, you will, and you’ll ﬁnd this compound pattern is one of  the most powerful patterns in your design toolbox.
Patterns are often used together and combined within the same design solution.
A compound pattern combines two or more patterns into a solution that solves a recurring or general problem.
Duck reunion As you’ve already heard, we’re going to get to work with the ducks again.
This time the ducks are going to show you how patterns can coexist and even cooperate within the same solution.
We’re going to rebuild our duck simulator from scratch and give it some interesting capabilities by using a bunch of  patterns.
This time around, the Ducks are going to implement a Quackable interface.
That way we’ll know what things in the simulator can quack() – like Mallard Ducks, Redhead Ducks, Duck Calls, and we might even see the Rubber Duck sneak back in.
What good is an interface without some classes to implement it?  Time to create some concrete ducks (but not the “lawn art” kind, if you know what we mean)
Here we let polymorphism do its magic: no matter what kind of Quackable gets passed in, the simulate() method asks it to quack.
Remember last time?   We had duck calls (those things hunters use, they are deﬁnitely quackable) and rubber ducks.
This wouldn’t be much fun if we didn’t add other kinds of Ducks too.
Let’s cook up a simulator that creates a few ducks and makes sure their quackers are working...
Okay, we’ve got our ducks; now all we need is a simulator.
Here we overload the simulate method to simulate just one duck.
Here’s a Goose class that has been hanging around the simulator.
It looks like everything is working; so far, so good.
Let’s say we wanted to be able to use a Goose anywhere we’d want to use a Duck.
What pattern would allow Geese to easily intermingle with Ducks?
The constructor takes the goose we are going to adapt.
When quack is called, the call is delegated to the goose’s honk() method.
Since geese aren’t quackers (they’re honkers), we can use an adapter to adapt a goose to a duck.
All we need to do is create a Goose, wrap it in an adapter that implements Quackable, and we should be good to go.
Now geese should be able to play in the simulator, too.
There’s the goose! Now the Goose can quack with the rest of the Ducks.
This time when we run the simulator, the list of objects passed to the simulate() method includes a Goose wrapped in a duck adapter.
One thing Quackologists have always wanted to study is the total number of quacks made by a ﬂock of ducks.
How can we add the ability to count duck quacks without having to change the duck classes?
We’re going to make those Quackologists happy and give them some quack counts.
How? Let’s create a decorator that gives the ducks some new behavior (the behavior of counting) by wrapping them with a decorator object.
We won’t have to change the Duck code at all.
We’ve got an instance variable to hold on to the quacker we’re decorating.
And we’re counting ALL quacks, so we’ll use a static variable to keep track.
We get the reference to the Quackable we’re decorating in the constructor.
When quack() is called, we delegate the call to the Quackable we’re decorating...
This static method just returns the number of quacks that have occurred in all Quackables.
We need to update the simulator to create decorated ducks.
Now, we must wrap each Quackable object we instantiate in a QuackCounter decorator.
If we don’t, we’ll have ducks running around making uncounted quacks.
Each time we create a Quackable, we wrap it with a new decorator.
The park ranger told us he didn’t want to count geese honks, so we don’t decorate it.
We need a factory to produce ducks! Okay, we need some quality control to make sure our ducks get wrapped.
We’re going to build an entire factory just to produce them.
The factory should produce a family of products that consists of different types of ducks, so we’re going to use the Abstract Factory Pattern.
He’s right, that’s the problem with wrapping objects: you have to make sure they get wrapped or they don’t get the decorated behavior.
Why don’t we take the creation of  ducks and localize it in one place; in other words, let’s take the duck creation and decorating and encapsulate it.
Let’s start by creating a factory that creates ducks without decorators, just to get the hang of the factory:
Each method wraps the Quackable with the quack counting decorator.
The simulator will never know the difference; it just gets back a Quackable.
But now our rangers can be sure that all quacks are being counted.
Remember how Abstract Factory works?  We create a polymorphic method that takes a factory and uses it to create objects.
By passing in different factories, we get to use different product families in the method.
We’re going to alter the simulate() method so that it takes a factory and uses it to create ducks.
Sharpen your pencil We’re still directly instantiating Geese by relying on concrete classes.
Can you write an Abstract Factory for Geese?  How should it handle creating “goose ducks”?
It’s getting a little difﬁcult to manage all these different ducks separately.
Is there any way you can help us manage ducks as a whole, and.
Here’s another good question from Ranger Brewer: Why are we managing ducks individually?
What we need is a way to talk about collections of ducks and even sub-collections of  ducks (to deal with the family request from Ranger Brewer)
It would also be nice if  we could apply operations across the whole set of  ducks.
Let’s create a ﬂock of ducks (well, actually a ﬂock of Quackables)
Remember the Composite Pattern that allows us to treat a collection of objects in the same way as individual objects?  What better composite than a ﬂock of Quackables!
We’re using an ArrayList inside each Flock to hold the Quackables that belong to the Flock.
Now for the quack() method - after a ll, the Flock is a Quackable too.
The quack() method in Flock needs to w ork over the entire Flock.
Code Up Close Did you notice that we tried to sneak a Design Pattern by you without mentioning it?
Our composite is ready; we just need some code to round up the ducks into the composite structure.
First we create a Flock, and load it up with Quackables.
Then we add the Flock of mallards to the main flock.
Nothing needs to change here, a Flock is a Quackable!
You might remember that in the Composite Pattern chapter the composites (the Menus) and the leaf nodes (the MenuItems) had the same exact set of methods, including the add() method.
Because they had the same set of methods, we could call methods on MenuItems that didn’t really make sense (like trying to add something to a MenuItem by calling add())
The benefit of this was that the distinction between leaves and composites was transparent: the client didn’t have to know whether it was dealing with a leaf or a composite; it just called the same methods on both.
Here, we’ve decided to keep the composite’s child maintenance methods separate from the leaf nodes: that is, only Flocks have the add() method.
We know it doesn’t make sense to try to add something to a Duck, and in this implementation, you can’t.
So this design is safer – you can’t call methods that don’t make sense on components – but it’s less transparent.
Now the client has to know that a Quackable is a Flock in order to add Quackables to it.
As always, there are trade-offs when you do OO design and you need to consider them as you create your own composites.
We could also have a method for removing observers, but we’ll keep the implementation simple here and leave that out.
The Composite is working great! Thanks!  Now we have the.
Can you give us a way to keep track of individual.
It sounds like the Quackologist would like to observe individual duck behavior.
That leads us right to a pattern made for observing the behavior of  objects: the Observer Pattern.
Any object implementing the Observer interface can listen to quacks.
Now we need to make sure all Quackables implement this interface...
Now, we need to make sure all the concrete classes that implement Quackable can handle being a QuackObservable.
We could approach this by implementing registration and notiﬁcation in each and every class (like we did in Chapter 2)
But we’re going to do it a little differently this time: we’re going to encapsulate the registration and notiﬁcation code in another class, call it Observable, and compose it with a QuackObservable.
That way we only write the real code once and the QuackObservable just needs enough code to delegate to the helper class Observable.
We just need to plug it int o a class and.
Now let’s see how a Quackable class uses this helper...
Observable must implement QuackObservable because these are the same method calls that are going to be delegated to it.
All we need to do is make sure the Quackable classes are composed with an Observable and that they know how to delegate to it.
Here’s the implementation of MallardDuck; the other ducks are the same.
In the constructor, we create an Observable and pass it a reference to the MallardDuck object.
When we quack, we need to let the observers know about it.
Sharpen your pencil We haven’t changed the implementation of one Quackable, the QuackCounter decorator.
We’re almost there!  We just need to work on the Observer side of the pattern.
We’ve implemented everything we need for the Observables; now we need some Observers.
The Observer interface just has one method, update(), which is passed the QuackObservable that is quacking.
The Quackologist is simple; it just has one method, update(), which prints out the Quackable that just quacked.
Sharpen your pencil What if a Quackologist wants to observe an entire ﬂock?  What does that mean anyway?  Think about it like this: if we observe a composite, then we’re observing everything in the composite.
So, when you register with a ﬂock, the ﬂock composite makes sure you get registered with all its children (sorry, all its little quackers), which may include other ﬂocks.
Go ahead and write the Flock observer code before we go any further...
Let’s give it a try and see how it works!
Five, no, six patterns have come together to create this amazing Duck Simulator.
Honk Quackologist: Goose pretending to be a Duck just quacked.
A: No, this was just a set of patterns working together.
A compound pattern is a set of a few patterns that are combined to solve a general problem.
Q: So the real beauty of Design Patterns is that I can take a problem, and start applying patterns to it until I have a solution.
We went through this exercise with Ducks to show you how patterns can work together.
You’d never actually want to approach a design like we just did.
In fact, there may be solutions to parts of the duck simulator for which some of these patterns were big time overkill.
Sometimes just using good OO design principles can solve a problem well enough on its own.
We’re going to talk more about this in the next chapter, but you only want to apply patterns when and where they make sense.
You never want to start out with the intention of using patterns just for the sake of it.
You should consider the design of the DuckSimulator to be forced and artificial.
But hey, it was fun and gave us a good idea of how several patterns can fit into a solution.
A goose came along and wanted to act like a Quackable too.
So we used the Adapter Pattern to adapt the goose to a Quackable.
Now, you can call quack() on a goose wrapped in the adapter and it will honk!
So we used the Decorator Pattern to add a QuackCounter decorator that keeps track of the number of times quack() is called, and then delegates the quack to the Quackable it’s wrapping.
But the Quackologists were worried they’d forget to add the QuackCounter decorator.
So we used the Abstract Factory Pattern to create ducks for them.
Now, whenever they want a duck, they ask the factory for one, and it hands back a decorated duck.
And don’t forget, they can also use another duck factory if they want an un-decorated duck.
We had management problems keeping track of all those ducks and geese and quackables.
So we used the Composite Pattern to group quackables into Flocks.
The pattern also allows the quackologist to create sub-Flocks to manage duck families.
We used the Iterator Pattern in our implementation by using java.util’s iterator in ArrayList.
The Quackologists also wanted to be notiﬁed when any quackable quacked.
The Quackologists can even use the Observer Pattern with their composites.
We only implemented one kind of Observer for the Quackables - the Quackologist.
But any class that implements the Observer interface can observe ducks...
If a class implements Observer, that means it can observe Quackables, and will be notified whenever a Quackable quacks.
We’ve packed a lot of  patterns into one small duck simulator!  Here’s the big picture of  what we did:
Quackable is the interface that all classes that have quacking behavior implement.
Each Quackable has an instance of Observable to keep track of their observers and notify them when the Quackable quacks.
Model on the one side, View on the other, the Controller’s in between.
Model View, you can model all the models that pose for GQ.
View objects tend to be controls used to display and edit.
Cocoa’s got a lot of those, well written to its credit.
The user can interact with it, it can hold most anything.
That string could be a phone number or the works of Aristotle.
They often use hardcoding which can be foreboding for reusability.
But now you can connect each model key that you select to any view property.
I think you’ll be finding less code in your source tree.
Yeah I know I was elated by the stuff they’ve automated.
Don’t just read!  After all this is a Head First book...
Tell you what, after you ﬁnish reading this chapter, go back and listen to the song again.
It sounds like you’ve had a bad run in with MVC before? Most of  us have.
You’ve probably had other developers tell you it’s changed their lives and could possibly create world peace.
It’s a powerful compound pattern, for sure, and while we can’t claim it will create world peace, it will save you hours of  writing code once you know it.
But ﬁrst you have to learn it, right?  Well, there’s going to be a big difference this time around because now you know patterns!
Learning MVC from the top down is difﬁcult; not many developers succeed.
Here’s the secret to learning MVC: it’s just a few patterns put together.
When you approach learning MVC by looking at the patterns, all of  the sudden it starts to make sense.
You can use its interface to add new songs, manage playlists and rename tracks.
The player takes care of  maintaining a little database of  all your songs along with their associated names and data.
It also takes care of playing the songs and, as it does, the user interface is constantly updated with the current song title, the running time, and so on.
Takes user input and ﬁgures out what it means to the model.
The model holds all the data, state and application logic.
The model is oblivious to the view and controller, although it provides an interface to manipulate and retrieve its state and it can send notiﬁcations of state changes to observers.
The view usually gets the state and data it needs to display directly from the model.
The MP3 Player description gives us a high level view of  MVC, but it really doesn’t help you understand the nitty gritty of  how the compound pattern works, how you’d build one yourself, or why it’s such a good thing.
Let’s start by stepping through the relationships among the model, view and controller, and then we’ll take second look from the perspective of  Design Patterns.
When you do something to the view (like click the Play button) then the view tells the controller what you did.
If you click on a button, it’s the controller’s job to ﬁgure out what that means and how the model should be manipulated based on that action.
When the controller receives an action from the view, it may need to tell the view to change as a result.
For example, the controller could enable or disable certain buttons or menu items in the interface.
When something changes in the model, based either on some action you took (like clicking a button) or some other internal change (like the next song in the playlist has started), the model notiﬁes the view that its state has changed.
The model notiﬁes the view when its state has changed.
The view gets the state it displays directly from the model.
For instance, when the model notiﬁes the view that a new song has started playing, the view requests the song name from the model and displays it.
The view might also ask the model for state as the result of the controller requesting some change in the view.
Q: Does the controller ever become an observer of the model?
In some designs the controller registers with the model and is notified of changes.
This can be the case when something in the  model directly affects the user interface controls.
For instance, certain states in the model may dictate that some interface items be enabled or disabled.
If so, it is really controller’s job to ask the view to update its display accordingly.
Q: All the controller does is take user input from the view and send it to the model, correct? Why have it at all if that is all it does? Why not just have the code in the view itself? In most cases isn’t the controller just calling a method on the model?
A: The controller does more than just “send it to the model”, the controller is responsible for interpreting the input and manipulating the model based on that input.
But your real question is probably “why can’t I just do that in the view code?”
You could; however, you don’t want to for two reasons: First, you’ll complicate your view code because it now has two responsibilities: managing the user interface and dealing with logic of how to control the model.
If you want to reuse the view with another model, forget it.
The controller separates the logic of control from the view and decouples the view from the model.
By keeping the view and controller loosely coupled, you are building a more flexible and extensible design, one that can more easily accommodate change down the road.
Looking at MVC through patterns-colored glasses We’ve already told you the best path to learning the MVC is to see it for what it is: a set of  patterns working together in the same design.
As you might have guessed the model uses Observer to keep the views and controllers updated on the latest state changes.
The view and the controller, on the other hand, implement the Strategy Pattern.
The controller is the behavior of  the view, and it can be easily exchanged with another controller if  you want different behavior.
The view itself  also uses a pattern internally to manage the windows, buttons and other components of  the display: the Composite Pattern.
The display consists of a nested set of windows, panels, buttons, text labels and so on.
Each display component is a composite (like a window) or a leaf (like a button)
When the controller tells the view to update, it only has to tell the top view component, and Composite takes care of the rest.
The model implements the Observer Pattern to keep interested objects updated when state changes occur.
Using the Observer Pattern keeps the model completely independent of the views and controllers.
It allows us to use different views with the same model, or even use multiple views at once.
The view and controller implement the classic Strategy Pattern: the view is an object that is configured with a strategy.
The view is concerned only with the visual aspects of the application, and delegates to the controller for any decisions about the interface behavior.
Using the Strategy Pattern also keeps the view decoupled from the model because it is the controller that is responsible for interacting with the model to carry out user requests.
All these observers will be notified whenever state changes in the model.
We can swap in another behavior for the view by changing the controller.
The view only worries about presentation, the controller worries about translating user input to actions on the model.
You’ll ﬁnish off  your set with a mellow 80 BPM ambient mix.
How are you going to do that?  You have to control the beat and you’re going to build the tool to get you there.
You can enter a specific BPM and click the Set button to set a specific beats per minute, or you can use the increase and decrease buttons for fine tuning.
A display shows the current BPMs and is automatically set whenever the BPM changes.
Meet the Java DJ View Let’s start with the view of  the tool.
The view allows you to create a driving drum beat and tune its beats per minute...
You can’t see the model, but you can hear it.
The model sits underneath everything else, managing the beat and driving the speakers with MIDI.
You use the Stop button to shut down the beat generation.
It takes your input, like selecting “Start” from the DJ Control menu, and turns it into an action on the model to start the beat generation.
The controller takes input from the user and figures out how to translate that into requests on the model.
It implements the logic to start and stop the beat, set the beats per minute (BPM), and generate the sound.
Here’s a few more ways to control the DJ View...
The model also allows us to obtain its current state through the getBPM() method.
This should look familiar, these methods allow objects to register as observers for state changes.
We’ve split this into two kinds of observers: observers that want to be notified on every beat, and observers that just want to be notified with the beats per minute change.
Okay,  you know the model is responsible for maintaining all the data, state and any application logic.
So what’s the BeatModel got in it?  Its main job is managing the beat, so it has state that maintains the current beats per minute and lots of  code that generates MIDI events to create the beat that we hear.
It also exposes an interface that lets the controller manipulate the beat and lets the view and controller obtain the model’s state.
Also, don’t forget that the model uses the Observer Pattern, so we also need some methods to let objects register as observers and send out notiﬁcations.
The getBPM() method returns the current BPMs, or 0 if the generator is off.
Let’s check out the BeatModelInterface before looking at the implementation:
Now let’s have a look at the concrete BeatModel class: We implement the BeatModeIInterface.
The bpm instance variable holds the frequency of beats - by default, 90 BPM.
This method does setup on the sequencer and sets up the beat tracks for us.
The on() method starts the sequencer and sets the BPMs to the default: 90 BPM.
And off() shuts it down by setting BPMs to 0 and stopping the sequencer.
The setBPM() method is the way the controller manipulates the beat.
The getBPM() method just returns the bpm insta nce variable, which.
The beatEvent() method, which is not in the Beat ModelInterface, is.
The View Now the fun starts; we get to hook up a view and visualize the BeatModel!
The ﬁrst thing to notice about the view is that we’ve implemented it so that it is displayed in two separate windows.
One window contains the current BPM and the pulse; the other contains the interface controls.
Why?  We wanted to emphasize the difference between the interface that contains the view of the model and the rest of  the interface that contains the set of  user controls.
Let’s take a closer look at the two parts of  the view:
The model is implemented using the Observer Pattern, so it just notiﬁes any view registered as an observer when its state changes.
The view uses the model’s API to get access to the state.
We’ve implemented one type of view, can you think of other views that could make use of the notiﬁcations and state in the BeatModel?
This is the part of the view that you use to change the beat.
This view passes everything you do on to the controller.
Implementing the View The two parts of  the view – the view of  the model, and the view with the user interface controls – are displayed in two windows, but live together in one Java class.
We’ll ﬁrst show you just the code that creates the view of  the model, which displays the current BPM and the beat bar.
Then we’ll come back on the next page and show you just the code that creates the user interface controls, which displays the BPM text entry ﬁeld, and the buttons.
DJView is an observer for both real-time beats and BPM c hanges.
The view holds a reference to both the model and the controller.
The controller is only used by the control interface, which we’ll go over in a sec...
We also register as a BeatObserver and a BPMObserver of the model.
The updateBPM() method is called when a state change occurs in the model.
When that happens we update the display with the current BPM.
We can get this value by requesting it directly from the model.
Likewise, the updateBeat() method is called when the model starts a new beat.
When that happens, we need to pulse our “beat bar.”  We do this by setting it to its maximum value (100) and letting it handle the animation of the pulse.
Now, we’ll look at the code for the user interface controls part of  the view.
This view lets you control the model by telling the controller what to do, which in turn, tells the model what to do.
Remember, this code is in the same class ﬁle as the other view code.
All these methods allow the start and stop items in the menu to be enabled and disabled.
We’ll see that the controller uses these to change the interface.
This method creates all the controls and places them in the interface.
When the stop or start items are chosen, the corresponding methods are called on the controller.
If the Set button is clicked then it is passed on to the controller along with the new bpm.
Likewise, if the increase or decrease buttons are clicked, this information is passed on to the controller.
Now for the Controller It’s time to write the missing piece: the controller.
Remember the controller is the strategy that we plug into the view to give it some smarts.
Because we are implementing the Strategy Pattern, we need to start with an interface for any Strategy that might be plugged into the DJ View.
Here are all the methods the view can call on the controller.
You can stop and start the beat generation and change the BPM.
This interface is “richer” than the BeatModel interface because you can adjust the BPMs with increase and decrease.
You’ve seen that the view and controller together make use of the Strategy Pattern.
Can you draw a class diagram of the two that represents this pattern?
The controller is the creamy stuff in the middle of the MVC oreo cookie, so it is the object that gets to hold on to the view and the model and glues it all together.
The controller is passed the model in the constructor and then creates the view.
Likewise, when you choose Stop from the menu, the controller turns the model off and alters the user interface so that the stop menu item is disabled and the start menu item is enabled.
NOTE: the controller is making the intelligent decisions for the view.
The view just knows how to turn menu items on and off; it doesn’t know the situations in which it should disable them.
If the increase button is clicked, the controller gets the current BPM from the model, adds one, and then sets a new BPM.
Same thing here, only we subtract one from the current BPM.
Finally, if the user interface is used to set an arbitrary BPM, the controller instructs the model to set its BPM.
We’ve got everything we need: a model, a view, and a controller.
Now it’s time to put them all together into a MVC!  We’re going to see and hear how well they work together.
All we need is a little code to get things started; it won’t take much:
Remember, the controller creates the view, so we don’t have to do that.
Start the beat generation with the Start menu item; notice the controller disables the item afterwards.
Use the text entry along with the increase and decrease buttons to change the BPM.
Notice how the view display reﬂects the changes despite the fact that it has no logical link to the controls.
Notice how the beat bar always keeps up with the beat since it’s an observer of the model.
Put on your favorite song and see if you can beat match the beat by using the increase and decrease controls.
Notice how the controller disables the Stop menu item and enables the Start menu item.
Exploring  Strategy Let’s take the Strategy Pattern just a little further to get a better feel for how it is used in MVC.
We’re going to see another friendly pattern pop up too – a pattern you’ll often see hanging around the MVC trio: the Adapter Pattern.
Think for a second about what the DJ View does: it displays a beat rate and a pulse.
Does that sound like something else? How about a heartbeat?  It just so happens we happen to have a heart monitor class; here’s the class diagram:
It certainly would be nice to reuse our current view with the HeartModel, but we need a controller that works with this model.
Also, the interface of the HeatModel doesn’t match what the view expects because it has a getHeartRate() method rather than a getBPM()
How would you design a set of classes to allow the view to be reused with the new model?
Adapting the Model For starters, we’re going to need to adapt the HeartModel to a BeatModel.
If  we don’t, the view won’t be able to work with the model, because the view only knows how to getBPM(), and the equivalent heart model method is getHeartRate()
How are we going to do this?  We’re going to use the Adapter Pattern, of  course! It turns out that this is a common technique when working with the MVC: use an adapter to adapt a model to work with existing controllers and views.
Here’s the code to adapt a HeartModel to a BeatModel:
We need to implement the target interface, in this case, BeatModelInterface.
With our HeartAdapter in hand we should be ready to create a controller and get the view running with the HeartModel.
Like before, the controller creates the view and gets everything glued together.
And that’s it!  Now it’s time for some test code...
All we need to do is create the controller and pass it a.
Finally, the HeartController disables the menu items as they aren’t needed.
Notice that the display works great with a heart! The beat bar looks just like a pulse.
Because the HeartModel also supports BPM and Beat Observers we can get beat updates just like with the DJ beats.
As the heartbeat has natural variation, notice the display is updated with the new beats per minute.
Each time we get a BPM update the adapter is doing its job of translating getBPM() calls to getHeartRate() calls.
The Start and Stop menu items are not enabled because the controller disabled them.
The other buttons still work but have no effect because the controller implements no ops for them.
The view could be changed to support the disabling of these items.
It wasn’t long after the Web was spun that developers started adapting the MVC to ﬁ t the browser/server model.
The prevailing adaptation is known simply as “Model 2” and uses a combination of  servlet and JSP technology to achieve the same separation of  model, view and controller that we see in conventional GUIs.
This typically involves sending along some form data, like your username and password.
You make an HTTP request, which is received by a servlet.
The servlet plays the role of the controller and processes your request, most likely making requests on the model (usually a database)
The result of processing the request is usually bundled up in the form of a JavaBean.
The JSP’s only job is to generate the page representing the view of model (      which it obtains via the JavaBean) along with any controls needed for further actions.
A page is returned to the browser, where it is displayed as the view.
The user submits further requests, which are processed in the same fashion.
The view returns a page to the browser via HTTP.
The beneﬁts of  the separation of  the view, model and controller are pretty clear to you now.
But you need to know the “rest of  the story” with Model 2 – that it saved many web shops from sinking into chaos.
How? Well, Model 2 not only provides a separation of  components in terms of design, it also provides a separation in production responsibilities.
Let’s face it, in the old days, anyone with access to your JSPs could get in and write any Java code they wanted, right?  And that included a lot of  people who didn’t know a jar ﬁle from a jar of  peanut butter.
The reality is that most web producers know about content and HTML, not software.
You don’t even want to know what life was like before.
You didn’t think we’d try to skip out without moving that great BeatModel over to the Web did you?  Just think, you can control your entire DJ session through a web page on your cellular phone.
So now you can get out of  that DJ booth and get down in the crowd.
Well, actually, we don’t have to ﬁ x the model, it’s ﬁ ne just like it is!
We need a simple servlet that can receive our HTTP requests and perform a few operations on the model.
All it needs to do is stop, start and change the beats per minute.
It’s going to receive a JavaBean from the controller that will tell it everything it needs to display.
Setting up your Servlet environment Showing you how to set up your servlet environment is a little bit off topic for a book on Design Patterns, at least if you don’t want the book to weigh more than you do!
Fire up your web browser and head straight to http://jakarta.apache.org/tomcat/ for the Apache Jakarta Project’s Tomcat Servlet Container.
You’ll find everything you need there to get you up and running.
Step one: the model Remember that in MVC, the model doesn’t know anything about the views or controllers.
All it knows is that it may have observers it needs to notify.
It also provides an interface the views and controllers can use to get and set its state.
Now all we need to do is adapt it to work in the web environment, but, given that it doesn’t depend on any outside classes, there is really no work to be done.
We can use our BeatModel off  the shelf  without changes.
So, let’s be productive and move on to step two!
Remember, the servlet is going to act as our controller; it will receive Web browser input in a HTTP request and translate it into actions that can be applied to the model.
Then, given the way the Web works, we need to return a view to the browser.
To do this we’ll pass control to the view, which takes the form of  a JSP.
Here’s the outline of  the servlet; on the next page, we’ll look at the full implementation.
Here’s the init method; this is called when the servlet is first created.
Here’s the implementation of  the doGet() method from the page before:
We can’t manipulate the model without a reference to it.
If we get a set command, then we get the value of the set, and tell the model.
If we get an on or off command, we tell the model to start or stop.
All we need to do is ask the view to take over and create an HTML view.
Following the Model 2 definition, we pass the JSP a bean with the model state in it.
In this case, we pass it the actual model, since it happens to be a bean.
Here we use the model bean to extract the BPM property.
Now we generate the view, which prints out the current beats per minute.
We have a text entry for entering a BPM along with increase/decrease and on/off buttons.
All we need is a view and we’ve got our browser-based beat generator ready to go! In Model 2, the view is just a JSP.
All the JSP knows about is the bean it receives from the controller.
In our case, that bean is just the model and the JSP is only going to use its BPM property to extract the current beats per minute.
With that data in hand, it creates the view and also the user interface controls.
It’s time to start your web browser, hit the DJView Servlet and give the system a spin...
Now you should see the beats per minute at the default setting: 90 BPM.
You should also hear a beat on the machine the server is running on.
Enter a speciﬁ c beat, say, 120, and click the “set” button.
The page should refresh with a beats per minute of 120 (and you should hear the beat increase)
Now play with the increase/decrease buttons to adjust the beat up and down.
After implementing the DJ Control for the Web using Model 2, you might be wondering where the patterns went.
We have a view created in HTML from a JSP  but the view is no longer a listener of  the model.
We have a controller that’s a servlet that receives HTTP requests, but are we still using the Strategy Pattern?  And what about Composite?  We have a view that is made from HTML and displayed in a web browser.
The view is no longer an observer of the model in the classic sense; that is, it doesn’t register with the model to receive state change notiﬁ cations.
However, the view does receive the equivalent of notiﬁ cations indirectly from the controller when the model has been changed.
The controller even passes the view a bean that allows the view to retrieve the model’s state.
If you think about the browser model, the view only needs an update of state information when an HTTP response is returned to the browser; notiﬁ cations at any other time would be pointless.
Only when a page is being created and returned does it make sense to create the view and incorporate the model’s state.
Composite Like our Swing GUI, the view is ultimately made up of a nested set of graphical components.
In this case, they are rendered by a web browser from an HTML description, however underneath there is an object system that most likely forms a composite.
Strategy In Model 2, the Strategy object is still the controller servlet; however, it’s not directly composed with the view in the classic manner.
That said, it is an object that implements behavior for the view, and we can swap it out for another controller if we want different behavior.
The controller still provides the view behavior, even if it isn’t composed with the view using object composition.
Q: It seems like you are really hand waving the fact that the Composite Pattern is really in MVC.
Today GUI packages, like Swing, have become so sophisticated that we hardly notice the internal structure and the use of composite in the building and update of the display.
It’s even harder to see when we have Web browsers that can take markup language and convert it into a user interface.
Back when MVC was first discovered, creating GUIs required a lot more manual intervention and the pattern was more obviously part of the MVC.
It is the smarts that translates the actions from the view to actions on the model.
The model takes those actions and implements the application logic to decide what to do in response to those actions.
The controller might have to do a little work to determine what method calls to make on the model, but that’s not considered the “application logic.”  The application logic is the code that manages and manipulates your data and it lives in your model.
Q: I’ve always found the word “model” hard to wrap my head around.
I now get that it’s the guts of the application, but why was such a vague, hard-to-understand word used to describe this aspect of the MVC?
A: When MVC was named they needed a word that began with a “M” or otherwise they couldn’t have called it MVC.
But seriously, we agree with you, everyone scratches their head and wonders what a model is.
But then everyone comes to the realization that they can’t think of a better word either.
Q: You’ve talked a lot about the state of the model.
Does this mean it has the State Pattern in it?
But certainly some models do use the State Pattern to manage their internal states.
Q: I’ve seen descriptions of the MVC where the controller is described as a “mediator” between the view and the model.
A: We haven’t covered the Mediator Pattern (although you’ll find a summary of the pattern in the appendix), so we won’t go into too much detail here, but the intent of the mediator is to encapsulate how objects interact and promote loose coupling by keeping two objects from referring to each other explicitly.
So, to some degree, the controller can be seen as a mediator, since the view never sets state directly on the model, but rather always goes through the controller.
Remember, however, that the view does have a reference to the model to access its state.
If the controller were truly a mediator, the view would have to go through the controller to get the state of the model as well.
Q: Does the view always have to ask the model for its state?  Couldn’t we use the push model and send the model’s state with the update notification?
A: Yes, the model could certainly send its state with the notification, and in fact, if you look again at the JSP/HTML view, that’s exactly what we’re doing.
We’re sending the entire model in a bean, which the view uses to access the state it needs using the bean properties.
We could do something similar with the BeatModel by sending just the state that the view is interested in.
If you remember the Observer Pattern chapter, however, you’ll also remember that there’s a couple of disadvantages to this.
If you don’t go back and have a second look.
Q: If I have more than one view, do I always need more than one controller?
A: Typically, you need one controller per view at runtime; however, the same controller class can easily manage many views.
Q: The view is not supposed to manipulate the model, however I noticed in your implementation that the view has full access to the methods that change the model’s state.
A: You are correct; we gave the view full access to the model’s set of methods.
We did this to keep things simple, but there may be circumstances where you want to give the view access to only part of your model’s API.
There’s a great design pattern that allows you to adapt an interface to only provide a subset.
Tools for your   Design Toolbox You could impress anyone with your design toolbox.
Wow, look at all those principles, patterns and now, compound patterns!
The view can use different implementations of the controller to get different behavior.
When we change Quackable to extend QuackObservable, we have to change every class that implements Quackable, including QuackCounter:
It’s this duck that really needs to handle the observable methods.
Notice that we just delegate both calls to the duck that we’re decorating.
Sharpen your pencil What if our Quackologist wants to observe an entire ﬂock?  What does that mean anyway?  Think about it like this: if we observe a composite, then we’re observing everything in the composite.
So, when you register with a ﬂock, the ﬂock composite makes sure you get registered with all its children, which may include other ﬂocks.
We iterate through all the Quackables in the Flock and delegate the call to each Quackable.
If the Quackable is another Flock, it will do the same.
Each Quackable does its own notification, so Flock doesn’t have to worry about it.
This happens when Flock delegates quack() to each Quackable in the Flock.
You’ve seen that the View and Controller together make use of the Strategy Pattern.
Can you draw a class diagram of the two that shows this pattern?
We can plug in different controllers to provide different behaviors for the view.
The behavior it delegates is how to control the model based on user input.
Sharpen your pencil We’re still directly instantiating Geese by relying on concrete classes.
Can you write an Abstract Factory for Geese?  How should it handle creating “goose ducks?”
You could add a createGooseDuck() method to the existing Duck Factories.
Or, you could create a completely separate Factory for creating families of Geese.
It shows all the MIDI code to generate the sound, and all the Swing components to create the view.
Ahhhh, now you’re ready for a bright new world filled with Design Patterns.
But, before you go opening all those new doors of opportunity, we need to cover a few details that you’ll encounter out in the real world – that’s right, things get.
A Pattern is a solution to a problem in a context.
We bet you’ve got a pretty good idea of  what a pattern is after reading this book.
But we’ve never really given a deﬁnition for a Design Pattern.
Well, you might be a bit surprised by the deﬁnition that is in common use:
That’s not the most revealing deﬁnition is it? But don’t worry, we’re going to step through each of  these parts, context, problem and solution:
The context is the situation in which the pattern applies.
The problem refers to the goal you are trying to achieve in this context, but it also refers to any constraints that occur in the context.
The solution is what you’re after: a general design that anyone can apply which resolves the goal and set of  constraints.
This is one of  those deﬁnitions that takes a while to sink in, but take it one step at a time.
Here’s a little mnemonic you can repeat to yourself  to remember it:
Now, this seems like a lot of  work just to ﬁgure out what a Design Pattern is.
After all, you already know that a Design Pattern gives you a solution to a common recurring design problem.
What is all this formality getting you? Well, you’re going to see that by having a formal way of  describing patterns we can create a catalog of  patterns, which has all kinds of  beneﬁts.
You need to step through the objects without exposing the collection’s implementation.
You might be right; let’s think about this a bit...
Solution: Break the window, get in the car, start the engine and drive to work.
We have all the components of  the deﬁnition: we have a problem, which includes the goal of  getting to work, and the constraints of  time, distance and probably some other factors.
We also have a context in which the keys to the car are inaccessible.
And we have a solution that gets us to the keys and resolves both the time and distance constraints.
Is this a pattern?  If not, how did it fail?  Could we fail the same way when deﬁning an OO Design Pattern?
Q: Am I going to see pattern descriptions that are stated as a problem, a context and a solution?
A: Pattern descriptions, which you’ll typically find in pattern catalogs, are usually a bit more revealing than that.
We’re going to look at pattern catalogs in detail in just a minute; they describe a lot more about a pattern’s intent and motivation and where it might apply, along with the solution design and the consequences (good and bad) of using it.
Q: Is it okay to slightly alter a pattern’s structure to fit my design? Or am I going to have to go by the strict definition?
Like design principles, patterns are not meant to be laws or rules; they are guidelines that you can alter to fit your needs.
As you’ve seen, a lot of real-world examples don’t fit the classic pattern designs.
However, when you adapt patterns, it never hurts to document how your pattern differs from the classic design – that way, other developers can quickly recognize the patterns you’re using and any differences between your pattern and the classic pattern.
We’ll talk a little more about this book in a few pages.
Many other patterns catalogs are starting to be published in various domain areas such as enterprise software, concurrent systems and business systems.
Looking more closely at the Design Pattern definition Our example does seem to match the Design Pattern deﬁnition, but it isn’t a true pattern.
Why? For starters, we know that a pattern needs to apply to a recurring problem.
While an absent-minded person might lock his keys in the car often, breaking the car window doesn’t qualify as a solution that can be applied over and over (or at least isn’t likely to if  we balance the goal with another constraint: cost)
It also fails in a couple of  other ways: ﬁrst, it isn’t easy to take this description, hand it to someone and have him apply it to his own unique problem.
Second, we’ve violated an important but simple aspect of  a pattern: we haven’t even given it a name!  Without a name, the pattern doesn’t become part of  a vocabulary that can be shared with other developers.
Luckily, patterns are not described and documented as a simple problem, context and solution; we have much better ways of  describing patterns and collecting them together into patterns catalogs.
Next time someone tells you a pattern is a solution to a problem in a context, just nod and smile.
Patterns gurus have a term for these: they call them.
Why? Well, we’re sure they have their own reasons, but if.
Likewise, the forces in the pattern definition shape and control the solution.
This “force” terminology can be quite confusing when you first see it in pattern discussions, but.
Don’t let the lingo get in your way and may the force be with you!
I’ve just been learning patterns by reading a few articles here and there.
Jim: Sure, each pattern catalog takes a set of  patterns and describes each in detail along with its relationship to the other patterns.
Joe: Are you saying there is more than one patterns catalog?
Jim:  Of  course; there are catalogs for fundamental Design Patterns and there are also catalogs on domain speciﬁc patterns, like EJB patterns.
Jim:  This is the classic GoF catalog; it contains 23 fundamental Design Patterns.
The Gang of  Four are the guys that put together the ﬁrst patterns catalog.
For each pattern there is a description that follows a template and spells out a lot of  details of  the pattern.
Jim: Hold on Frank; actually, the name is really important.
When we have a name for a pattern, it gives us a way to talk about the pattern; you know, that whole shared vocabulary thing.
Jim: Well, like I was saying, every pattern follows a template.
For each pattern we have a name and a few sections that tell us more about the pattern.
For instance, there is an Intent section that describes what the pattern is, kind of  like a deﬁnition.
Then there are Motivation and Applicability sections that describe when and where the pattern might be used.
Jim: There are several sections that describe the class design along with all the classes that make it up and what their roles are.
There is also a section that describes how to implement the pattern and often sample code to show you how.
There are also examples of  where the pattern has been used in real systems as well as what I think is one of  the most useful sections: how the pattern relates to other patterns.
Frank: Oh, you mean they tell you things like how state and strategy differ?
Joe:  So Jim, how are you actually using the catalog?  When you have a problem, do you go ﬁshing in the catalog for a solution?
Jim: I try to get familiar with all the patterns and their relationships ﬁrst.
Then, when I need a pattern, I have some idea of  what it is.
I go back and look at the Motivation and Applicability sections to make sure I’ve got it right.
I review that to make sure there won’t be some unintended effect on my design.
So once you know the pattern is right, how do you approach working it into your design and implementing it?
I ﬁrst read over the Structure section to review the diagram and then over the Participants section to make sure I understand each classes’ role.
From there I work it into my design, making any alterations I need to make it ﬁt.
Then I review the Implementation and Sample code sections to make sure I know about any good implementation techniques or gotchas I might encounter.
Joe:  I can see how a catalog is really going to accelerate my use of  patterns!
The structure provides a diagram illustrating the relationships among the classes that participate in the pattern.
Collaborations tells us how the participants work together in the pattern.
The consequences describe the effects that using this pattern may have: good and bad.
The name is a vital part of a pattern - without a good name, a pattern can’t become part of the vocabulary that you share with other developers.
The intent describes what the pattern does in a short statement.
You can also think of this as the pattern’s definition (just like we’ve been using in this book)
The motivation gives you a concrete scenario that describes the problem and how the solution solves the problem.
The applicability describes situations in which the pattern can be applied.
Implementation provides techniques you need to use when implementing this pattern, and issues you should watch out for.
Sample code provides code fragments that might help with your implementation.
Known uses describes examples of this pattern found in real systems.
Related patterns describes the relationship between this pattern and others.
Q: Is it possible to create your own Design Patterns?  Or is that something you have to be a “patterns guru” to do?
So, anyone can discover a Design Pattern and then author its description; however, it’s not easy and doesn’t happen quickly, nor often.
You should first think about why you’d want to – the majority of people don’t author patterns; they just use them.
However, you might work in a specialized domain for which you think new patterns would be helpful, or you might have come across a solution to what you think is a recurring problem, or you may just want to get involved in the patterns community and contribute to the growing body of work.
A: Like any discipline, the more you know the better.
Studying existing patterns, what they do and how they relate to other patterns is crucial.
Not only does it make you familiar with how patterns are crafted, it prevents you from reinventing the wheel.
From there you’ll want to start writing your patterns on paper, so you can communicate them to other developers; we’re going to talk more about how to communicate your patterns in a bit.
If you’re really interested, you’ll want to read the section that follows these Q&As.
Q: How do I know when I really have a pattern?
A: That’s a very good question: you don’t have a pattern until others have used it and found it to work.
In general, you don’t have a pattern until it passes the “Rule of Three.”  This rule states that a pattern can be called a pattern only if it has been applied in a real-world solution at least three times.
To the tune of “So you wanna be a Rock’n Roll Star.”
Use one of the existing pattern templates to define your pattern.
A lot of thought has gone into these templates and other pattern users will recognize the format.
You need to be well versed in the existing patterns before you can create a new one.
Most patterns that appear to be new, are, in fact, just variants of  existing patterns.
By studying patterns, you become better at recognizing them, and you learn to relate them to other patterns.
Your experience – the problems you’ve encountered, and the solutions you’ve used – are where ideas for patterns are born.
So take some time to reﬂect on your experiences and comb them for novel designs that recur.
Remember that most designs are variations on existing patterns and not new patterns.
And when you do ﬁnd what looks like a new pattern, its applicability may be too narrow to qualify as a real pattern.
Get your ideas down on paper in a way others can understand.
Locating new patterns isn’t of  much use if  others can’t make use of  your ﬁnd; you need to document your pattern candidates so that others can read, understand, and apply them to their own solution and then supply you with feedback.
Luckily, you don’t need to invent your own method of  documenting your patterns.
As you’ve already seen with the GoF template, a lot of thought has already gone into how to describe patterns and their characteristics.
Have others try your patterns; then reﬁne and reﬁne some more.
Don’t expect to get your pattern right the ﬁrst time.
Think of  your pattern as a work in progress that will improve over time.
Have other developers review your candidate pattern, try it out, and give you feedback.
Your description will never be perfect, but at some point it should be solid enough that other developers can read and understand it.
Remember, unless your pattern has been successfully applied in three real-world solutions, it can’t qualify as a pattern.
That’s another good reason to get your pattern into the hands of  others so they can try it, give feedback, and allow you to converge on a working pattern.
Wraps an object and provides a different interface to it.
Encapsulates interchangeable behaviors and uses delegation to decide which one to use.
Encapsulates state-based behaviors and uses delegation to switch between behaviors.
Provides a way to traverse a collection of objects without exposing its implementation.
Allows a client to create families of objects without specifying their concrete classes.
Organizing Design Patterns As the number of  discovered Design Patterns grows, it makes sense to partition them into classiﬁ cations so that we can organize them, narrow our searches to a subset of  all Design Patterns, and make comparisons within a group of  patterns.
In most catalogs you’ll ﬁ nd patterns grouped into one of  a few classiﬁ cation schemes.
The most well-known scheme was used by the ﬁ rst pattern catalog and partitions patterns into three distinct categories based on their purposes: Creational, Behavioral and Structural.
Any pattern that is a Behavioral Pattern is concerned with how classes and objects interact and distribute responsibility.
Structural patterns let you compose classes or objects into larger structures.
Creational patterns involve object instantiation and all provide a way to decouple a client from the objects it needs to instantiate.
Read each category description and see if you  can corral these patterns into their correct categories.
This is a toughy!  But give it your best shot and then check out the answers on the next page.
Any pattern that is a Behavioral Pattern is concerned with how classes and objects interact and distribute responsibility.
Structural patterns let you compose classes or objects into larger structures.
We’ve got a few patterns (in grey) that you haven’t seen yet.
You’ll find an overview of the these patterns in the appendix.
Creational patterns involve object instantiation and all provide a way to decouple a client from the objects it needs to instantiate.
Solution: Pattern Categories Here’s the grouping of  patterns into categories.
You probably found the exercise difﬁcult, because many of  the patterns seem like they could ﬁt into more than one category.
Don’t worry, everyone has trouble ﬁguring out the right categories for the patterns.
Class patterns describe how relationships between classes are deﬁned via inheritance.
Patterns are often classiﬁed by a second attribute: whether or not the pattern deals with classes or objects:
Object patterns describe relationships between objects and are primarily deﬁned by composition.
Relationships in object patterns are typically created at runtime and.
Some other schemes start with the three categories and then add subcategories, like “Decoupling Patterns.” You’ll want to be familiar with the most common schemes for organizing patterns, but also feel free to create your own, if it helps you to understand the patterns better.
Q: Does organizing patterns into categories really help you remember them?
A: It certainly gives you a framework for the sake of comparison.
But many people are confused by the creational, structural and behavioral categories; often a pattern seems to fit into more than one category.
The most important thing is to know the patterns and the relationships among them.
Q: Why is the Decorator Pattern in the structural category?  I would have thought of that as a behavioral pattern; after all it adds behavior!
A: Yes, lots of developers say that! Here’s the thinking behind the Gang of Four classification: structural patterns describe how classes and objects are composed to create new structures or new functionality.
The Decorator Pattern allows you to compose objects by wrapping one object with another to provide new functionality.
So the focus is on how you compose the objects dynamically to gain functionality, rather than on the communication and interconnection between objects, which is the purpose of behavioral patterns.
But remember, the intent of these patterns is different, and that’s often the key to understanding which category a pattern belongs to.
Student: Yes, I’ve just learned about pattern classiﬁcation and I’m confused.
Student: After learning much about patterns, I’ve just been told that each pattern ﬁts into one of three classiﬁcations: structural, behavioral or creational.
Master: Grasshopper, whenever we have a large collection of anything, we naturally ﬁnd categories to ﬁt those things into.
It helps us to think of the items at a more abstract level.
Take automobiles; there are many different  models of automobiles and we naturally put them into categories like economy cars, sports cars, SUVs, trucks and luxury car categories.
Master: Grasshopper, you look shocked, does this not make sense?
Student: Master, it makes a lot of sense, but I am shocked you know so much about cars!
Master: Grasshopper, I can’t relate everything to lotus ﬂowers or rice bowls.
Master: Once you have classiﬁcations or categories you can easily talk about the different groupings: “If you’re doing the mountain drive from Silicon Valley to Santa Cruz, a sports car with good handling is the best option.”  Or, “With the worsening oil situation you really want to buy a economy car, they’re more fuel-efﬁcient.”
Student: So by having categories we can talk about a set of patterns as a group.
We might know we need a creational pattern, without knowing exactly which one, but we can still talk about creational patterns.
Master: Yes, and it also gives us a way to compare a member to the rest of the category, for example, “the Mini really is the most stylish compact car around”, or to narrow our search, “I need a fuel efﬁcient car.”
Student: I see, so I might say that the Adapter pattern is the best structural pattern for changing an object’s interface.
Student: So categories give us a way to think about the way groups of patterns relate and how patterns within a group relate to one another.
They also give us a way to extrapolate to new patterns.
But why are there three categories and not four, or ﬁve?
Master: Ah, like stars in the night sky, there are as many categories as you want to see.
Three is a convenient number and a number that  many people have decided makes for a nice grouping of patterns.
Okay, all that stuff  is important and knowledge is power.
But, let’s face it, if  you understand the academic stuff  and don’t have the experience and practice using patterns, then it’s not going to make much difference in your life.
Here’s a quick guide to help you start to think in patterns.
What do we mean by that?  We mean being able to look at a design and see where patterns naturally ﬁt and where they don’t.
Keep it simple (KISS) First of  all, when you design, solve things in the simplest way possible.
Other developers will appreciate and admire the simplicity of  your design.
That said, sometimes the best way to keep your design simple and ﬂexible is to use a pattern.
Design Patterns aren’t a magic bullet; in fact they’re not even a bullet! Patterns, as you know, are general solutions to recurring problems.
Patterns also have the beneﬁt of  being well tested by lots of  developers.
So, when you see a need for one, you can sleep well knowing many developers have been there before and solved the problem using similar techniques.
You can’t plug one in, compile and then take an early lunch.
To use patterns, you also need to think through the consequences on the rest of  your design.
If  a simpler solution might work, give that consideration before you commit to using a pattern.
Knowing when a pattern applies is where your experience and knowledge come in.
Once you’re sure a simple solution will not meet your needs, you should consider the problem along with the set of  constraints under which the solution will  need to operate — these will help you match your problem to a pattern.
If you’ve got a good knowledge of  patterns, you may know of  a pattern that is a good match.
Otherwise, survey patterns that look like they might solve the problem.
The intent and applicability sections of  the patterns catalogs are particularly useful for this.
Once you’ve found a pattern that appears to be a good match, make sure it has a set of  consequences you can live with and study its effect on the rest of  your design.
There is one situation in which you’ll want to use a pattern even if  a simpler solution would work: when you expect aspects of  your system to vary.
As we’ve seen, identifying areas of  change in your design is usually a good sign that a pattern is needed.
Just make sure you are adding patterns to deal with practical change that is likely to happen, not hypothetical change that may happen.
Design time isn’t the only time you want to consider introducing patterns, you’ll also want to do so at refactoring time.
Refactoring time is Patterns time! Refactoring is the process of  making changes to your code to improve the way it is organized.
The goal is to improve its structure, not change its behavior.
This is a great time to reexamine your design to see if  it might be better structured with patterns.
For instance, code that is full of  conditional statements might signal the need for the State pattern.
Or, it may be time to clean up concrete dependencies with a Factory.
Entire books have been written on the topic of  refactoring with patterns, and as your skills grow, you’ll want to study this area more.
Don’t be afraid to remove a Design Pattern from your design.
No one ever talks about when to remove a pattern.
You’d think it was blasphemy!  Nah, we’re all adults here; we can take it.
So when do you remove a pattern?  When your system has become complex and the ﬂexibility you planned for isn’t needed.
In other words, when a simpler solution without the pattern would be better.
If you don’t need it now, don’t do it now.
Design Patterns are powerful, and it’s easy to see all kinds of  ways they can be used in your current designs.
Developers naturally love to create beautiful architectures that are ready to take on change from any direction.
If  you have a practical need to support change in a design today, go ahead and employ a pattern to handle that change.
However, if  the reason is only hypothetical, don’t add the pattern, it is only going to add complexity to your system, and you might never need it!
Use patterns when there is a natural need for them.
Student: I’m going to Disneyland!  And, then I’m going to start creating lots of code with patterns!
Student: What do you mean, Master?  Now that I’ve learned design patterns shouldn’t I be using them in all my designs to achieve maximum power, ﬂexibility and manageability?
Master: No; patterns are a tool, and a tool that should only be used when needed.
You’ve also spent a lot of time learning design principles.
Always start from your principles and create the simplest code you can that does the job.
However, if you see the need for a pattern emerge, then use it.
Master: That should not be your goal when beginning a design.
Student: If patterns are so great, why should I be so careful about using them?
Master: Patterns can introduce complexity, and we never want complexity where it is not needed.
But patterns are powerful when used where they are needed.
As you already know, patterns are proven design experience that can be used to avoid common mistakes.
They’re also a shared vocabulary for communicating our design to others.
Student: Well, when do we know it’s okay to introduce design patterns?
Master: Introduce a pattern when you are sure it’s necessary to solve a problem in your design, or when you are quite sure that it is needed to deal with a future change in the requirements of your application.
Student: I guess my learning is going to continue even though I already understand a lot of patterns.
Master: Yes, grasshopper; learning to manage the complexity and change in software is a life long pursuit.
But now that you know a good set of patterns, the time has come to apply them where needed in your design and to continue learning more patterns.
Student: Wait a minute, you mean I don’t know them ALL?
Master: Grasshopper, you’ve learned the fundamental patterns; you’re going to ﬁnd there are many more, including patterns that just apply to particular domains such as concurrent systems and enterprise systems.
But now that you know the basics, you’re in good shape to learn them!
This is good: the beginner gets lots of experience with and practice using patterns.
The beginner also thinks, “The more patterns I use, the better the design.” The beginner will learn this is not so, that all designs should be as simple as possible.
Complexity and patterns should only be used where they are needed for practical extensibility.
As learning progresses, the Intermediate mind starts to see where patterns are needed and where they aren’t.
The intermediate mind still tries to fit too many square patterns into round holes, but also begins to see that  patterns can be adapted to fit situations where the canonical pattern doesn’t fit.
The Zen mind is able to see patterns where they fit naturally.
The Zen mind is not obsessed with using patterns; rather it looks for simple solutions that best solve the problem.
The Zen mind thinks in terms of the object principles and their trade-offs.
When a need for a pattern naturally arises, the Zen mind applies it knowing well that it may require adaptation.
The Zen mind also sees relationships to similar patterns and understands the subtleties of  differences in the intent of related patterns.
The Zen mind is also a Beginner mind — it doesn’t let all that pattern knowledge overly influence design decisions.
WARNING: Overuse of design patterns can lead to code that is downright over-engineered.
Always go with the simplest solution that does the job and introduce patterns where the need emerges.
But we want you to be a good OO designer even more.
When a design solution calls for a pattern, you get the beneﬁts of  using a solution that has been time tested by lots of  developers.
You’re also using a solution that is well documented and that other developers are going to recognize (you know, that whole shared vocabulary thing)
However, when you use Design Patterns, there can also be a downside.
Design Patterns often introduce additional classes and objects, and so they can increase the complexity of  your designs.
Design Patterns can also add more layers to your design, which adds not only complexity, but also inefﬁciency.
Also, using a Design Pattern can sometimes be outright overkill.
Many times you can fall back on your design principles and ﬁnd a much simpler solution to solve the same problem.
When a Design Pattern is the right tool for the job, the advantages are many.
Wait a minute; I’ve read this entire book and now you’re telling me NOT to use.
It keeps track of all the objects listening to it and anytime a new piece of data comes along.
What’s cool is that the listeners can join the broadcast at any time or they can even remove themselves.
And the broadcast class itself doesn’t know anything about the listeners, any object can register that.
We’ve spent so much time in this book discussing OO nuts and bolts that it’s easy to forget the human side of  Design Patterns – they don’t just help load your brain with solutions, they also give you a shared vocabulary with other developers.
Don’t underestimate the power of  a shared vocabulary, it’s one of the biggest beneﬁts of  Design Patterns.
Just think, something has changed since the last time we talked about shared vocabularies; you’ve now started to build up quite a vocabulary of  your own! Not to mention, you have also learned a full set of  OO design principles from which you can easily understand the motivation and workings of  any new patterns you encounter.
Now that you’ve got the Design Pattern basics down, it’s time for you to go out and spread the word to others.
Why? Because when your fellow developers know patterns and use a shared vocabulary as well, it leads to better designs, better communication and, best of  all, it’ll save you a lot of time that you can spend on cooler things.
Discussing designs from the perspective of Design Patterns and OO principles  keeps your team from getting bogged down in implementation details and prevent many misunderstandings.
With other developers:  Use patterns in your discussions with other developers.
This helps other developers learn about new patterns and builds a community.
The best part about sharing what you’ve learned is that great feeling when someone else “gets it!”
In architecture documentation:  When you write architectural documentation, using patterns will reduce the amount of documentation you need to write and gives the reader a clearer picture of the design.
In code comments and naming conventions:  When you’re writing code, clearly identify the patterns you’re using in comments.
Also, choose class and methods names that reveal any patterns underneath.
Other developers who have to read your code will thank you for allowing them to quickly understand your implementation.
Many developers have heard about patterns but don’t have a good understanding of what they are.
Volunteer to give a brown-bag lunch on patterns or a talk at your local user group.
Cruisin’ Objectville with the Gang of Four You won’t ﬁnd the Jets or Sharks hanging around Objectville,  but you will ﬁnd the Gang of  Four.
As you’ve probably noticed, you can’t get far in the World of  Patterns without running into them.
Put simply, “the GoF,” which includes Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides, is the group of  guys who put together the ﬁrst patterns catalog and in the process, started an entire movement in the software ﬁeld!
How did they get that name?  No one knows for sure; it’s just a name that stuck.
But think about it: if  you’re going to have a.
The GoF launched the software patterns movement, but many others.
If you can come up with a simpler solution without using a.
Now that you’re on top of  Design Patterns and ready to dig deeper, we’ve got three deﬁ nitive texts that you need to add to your bookshelf...
In fact, this book is the basis for the set of  patterns we used in Head First Design Patterns.
You won’t ﬁ nd this book to be the last word on Design Patterns – the ﬁ eld has grown substantially since its publication – but it is the ﬁ rst and most deﬁ nitive.
Picking up a copy of  Design Patterns is a great way to start exploring patterns after Head First.
Patterns didn’t start with the GoF; they started with Christopher Alexander, a Professor of  Architecture at Berkeley – that’s right, Alexander is an architect, not a computer scientist.
Alexander invented patterns for building living architectures (like houses, towns and cities)
The next time you’re in the mood for some deep, engaging reading, pick up The Timeless Way of Building and A Pattern Language.
You’ll see the true beginnings of  Design Patterns and recognize the direct analogies between creating “living architecture” and ﬂ exible, extensible software.
So grab a cup of  Starbuzz Coffee, sit back, and enjoy...
Christopher Alexander invented patterns, which inspired applying similar solutions to software.
The  Portland Patterns Repository, run by Ward Cunningham, is a WIKI devoted to all things related to patterns.
You’ll ﬁ nd threads of  discussion on every topic you can think of  related to patterns and OO systems.
The   Hillside Group fosters common programming and design practices and provides a central resource for patterns work.
The site includes information on many patterns-related resources such as articles, books, mailing lists and tools.
You’re going to ﬁ nd there is a vibrant, friendly community of  patterns users and writers out there and they’re glad to have you join them.
And if  you’d like to get some face-to-face time with the patterns community, be sure to check out the many patterns related conferences and workshops.
Architectural Patterns are used to create the living, vibrant architecture of buildings, towns, and cities.
Habitat: found in buildings you like to live in, look at and visit.
As you’ve just seen, patterns didn’t start with software; they started with the architecture of  buildings and towns.
In fact, the patterns concept can be applied in many different domains.
Take a walk around the Patterns Zoo to see a few...
Domain-Speciﬁc Patterns are patterns that concern problems in speciﬁc domains, like concurrent systems or real-time systems.
Field notes: please add your observations of pattern domains here:
Annihilating evil with Anti-Patterns The Universe just wouldn’t be complete if  we had patterns and no anti-patterns, now would it?
If  a Design Pattern gives you a general solution to a recurring problem in a particular context, then what does an anti-pattern give you? An anti-pattern always.
By documenting antipatterns we help others to recognize bad solutions before they implement them.
Like patterns, there are many types of anti-patterns including development, OO, organizational, and domain specific anti-patterns.
An Anti-Pattern tells you how to go from a problem to a BAD solution.
You’re probably asking yourself, “Why on earth would anyone waste their time documenting bad solutions?”
Think about it like this: if  there is a recurring bad solution to a common problem, then by documenting it we can prevent other developers from making the same mistake.
After all, avoiding bad solutions can be just as valuable as ﬁnding good ones!
An anti-pattern tells you why a bad solution is attractive.
Let’s face it, no one would choose a bad solution if there wasn’t something about it that seemed attractive up front.
One of  the biggest jobs of  the anti-pattern is to alert you to the seductive aspect of  the solution.
An anti-pattern tells you why that solution in the long term is bad.
In order to understand why it’s an anti-pattern, you’ve got to understand how it’s going to have a negative effect down the road.
The anti-pattern describes where you’ll get into trouble using the solution.
An anti-pattern suggests other patterns that are applicable which may provide good solutions.
To be truly helpful an anti-pattern needs to point you in the right direction; it should suggest other possibilities that may lead to good solutions.
Problem: You need to choose technologies for your development and you believe that exactly one technology must dominate the architecture.
Context: You need to develop some new system or piece of software that doesn’t fit well with the technology that the development team is familiar with.
The development team is committed to the technology they know.
It is easy to plan and estimate for development using the familiar technology.
The technology is applied obsessively to many problems, including places where it is clearly inappropriate.
Refactored Solution: Expanding the knowledge of developers through education, training, and book study groups that expose developers to new solutions.
Web companies keep using and maintaining their internal homegrown caching systems when open source alternatives are in use.
The problem and context, just like a Design Pattern description.
Just like a Design Pattern, an anti-pattern has a name so we can create a shared vocabulary.
Tools for your   Design Toolbox You’ve reached that point where you’ve outgrown us.
Now’s the time to go out in the world and explore patterns on your own...
This is one of the most powerful benefits of using patterns.
Having read this book, you now know most of it.
The time has come for you to go out and discover more  patterns on your own.
There are many domain-specific patterns we haven’t even mentioned and there are also some foundational ones we didn’t cover.
Appendix, we’ll give you a heads up on some more foundational patterns you’ll probably want to have a look at.
Wraps an object and provides a different interface to it.
Encapsulates interchangeable behaviors and uses delegation to decide which one to use.
Encapsulates state-based behaviors and uses delegation to switch between behaviors.
Provides a way to traverse a collection of objects without exposing its implementation.
Allows a client to create families of objects without specifying their concrete classes.
Software ﬁ rst came out, developers have applied these patterns thousands.
The patterns we summarize in this appendix are full-ﬂ edged, cardcarrying, ofﬁ cial GoF patterns, but aren’t always used as often as the patterns.
But these patterns are awesome in their own right, and.
Our goal in this appendix is to give you a high level idea of what these patterns.
Bridge Use the   Bridge Pattern to vary not only your implementations, but also your abstractions.
Imagine you’re going to revolutionize “extreme lounging.” You’re writing the code for a new ergonomic and user-friendly remote control for TVs.
You already know that you’ve got to use good OO techniques because while the remote is based on the same abstraction, there will be lots of implementations – one for each model of  TV.
You know that the remote’s user interface won’t be right the ﬁ rst time.
In fact, you expect that the product will be reﬁ ned many times as usability data is collected on the remote control.
So your dilemma is that the remotes are going to change and the TVs are going to change.
You’ve already abstracted the user interface so that you can vary the implementation over the many TVs your customers will own.
But you are also going to need to vary the  abstraction because it is going to change over time as the remote is improved based on the user feedback.
So how are you going to create an OO design that allows you to vary the implementation and the abstraction?
Why use the Bridge Pattern? The Bridge Pattern allows you to vary the implementation and the abstraction by placing the two in separate class hierarchies.
Concrete subclasses are implemented in terms of the abstraction, not the implementation.
Now you have two hierarchies, one for the remotes and a separate one for platform speciﬁ c TV implementations.
The bridge allows you to vary either side of  the two hierarchies independently.
Builder Use the Builder Pattern to encapsulate the construction of a product and allow it to be constructed in steps.
You’ve just been asked to build a vacation planner for Patternsland, a new theme park just outside of  Objectville.
Park guests can choose a hotel and various types of admission tickets, make restaurant reservations, and even book special events.
To create a vacation planner, you need to be able to create structures like this:
Each guest’s planner can vary in the number of  days and types of  activities it includes.
For instance, a local resident might not need a hotel, but wants to make dinner and special event reservations.
Another guest might be ﬂying into Objectville and needs a hotel, dinner reservations, and admission tickets.
So, you need a ﬂexible data structure that can represent guest planners and all their variations; you also need to follow a sequence of  potentially complex steps to create the planner.
How can you provide a way to create the complex structure without mixing it with the steps for creating it?
Why use the Builder Pattern? Remember Iterator?  We encapsulated the iteration into a separate object and hid the internal representation of  the collection from the client.
It’s the same idea here: we encapsulate the creation of  the trip planner in an object (let’s call it a builder), and have our client ask the builder to construct the trip planner structure for it.
The client uses an abstract interface to build the planner.
Chain of Responsibility Use the Chain of  Responsibility Pattern when you want to give more than one object a chance to handle a request.
Mighty Gumball has been getting more email than they can handle since the release of  the Java-powered Gumball Machine.
All fan mail needs to go straight to the CEO, all complaints go to the legal department and all requests for new machines go to business development.
Mighty Gumball has already written some AI detectors that can tell if  an email is spam, fan mail, a complaint, or a request, but they need you to create a design that can use the detectors to handle incoming email.
How to use the Chain of Responsibility Pattern With the Chain of  Responsibility Pattern, you create a chain of  objects that examine a request.
Each object in turn examines the request and handles it, or passes it on to the next object in the chain.
As email is received, it is passed to the ﬁ rst handler: the SpamHandler.
If  the SpamHandler can’t handle the request, it is passed on to the FanHandler.
Email is not handled if it falls off the end of the chain - although, you can always implement a catch-all handler.
Flyweight Use the   Flyweight Pattern when one instance of  a class can be used to provide many “virtual instances.”
You want to add trees as objects in your hot new landscape design application.
In your application, trees don’t really do very much; they have an X-Y location, and they can draw themselves dynamically, depending on how old they are.
The thing is, a user might want to have lots and lots of  trees in one of  their home landscape designs.
You’ve just landed your “reference account.”  That key client you’ve been pitching for months.
They’re going to buy 1,000 seats of  your application, and they’re using your software to do the landscape design for huge planned communities.
After using your software for a week, your client is complaining that when they create large groves of  trees, the app starts getting sluggish...
Why use the Flyweight Pattern? What if, instead of  having thousands of  Tree objects, you could redesign your system so that you’ve got only one instance of  Tree, and a client object that maintains the state of  ALL your trees? That’s the Flyweight!
Interpreter Use the Interpreter Pattern to build an interpreter for a language.
Remember the Duck Pond Simulator? You have a hunch it would also make a great educational tool for children to learn programming.
Using the simulator, each child gets to control one duck with a simple language.
You’ve got a grammar; now all you need is a way to represent and interpret sentences in the grammar so that the students can see the effects of  their programming on the simulated ducks.
Now, remembering how to create grammars from one of  your old introductory programming classes, you write out the grammar:
A while statement is just a conditional variable and an expression.
A sequence is a set of expressions separated by semicolons.
In these cases a parser/compiler generator may be more appropriate.
How to implement an interpreter When you need to implement a simple language, the Interpreter Pattern deﬁ nes a class-based representation for its grammar along with an  interpreter to interpret its sentences.
To represent the language, you use a class to represent each rule in the language.
To interpret the language, call the interpret() method on each expression type.
This method is passed a context – which contains the input stream of  the program we’re parsing – and matches the input and evaluates it.
Mediator Use the   Mediator Pattern to centralize complex communications and control between related objects.
Bob has a Java-enabled auto-house, thanks to the good folks at HouseOfTheFuture.
All of  his appliances are designed to make his life easier.
When Bob stops hitting the snooze button, his alarm clock tells the coffee maker to start brewing.
Even though life is good for Bob, he and other clients are always asking for lots of  new features: No coffee on the weekends...
Turn off  the sprinkler 15 minutes before a shower is scheduled...
With a Mediator added to the system, all of  the appliance objects can be greatly simpliﬁ ed:
Before adding the Mediator, all of  the appliance objects needed to know about each other...
With the Mediator in place, the appliance objects are all completely decoupled from each other.
The Mediator contains all of  the control logic for the entire system.
When an existing appliance needs a new rule, or a new appliance is added to the system, you’ll know that all of  the necessary logic will be added to the Mediator.
Memento Use the Memento Pattern when you need to be able to return an object to one of  its previous states; for instance, if  your user requests an “undo.”
Your interactive role playing game is hugely successful, and has created a legion of  addicts, all trying to get to the fabled “level 13.”  As users progress to more challenging game levels, the odds of  encountering a game-ending situation increase.
Fans who have spent days progressing to an advanced level are understandably miffed when their character gets snuffed, and they have to start all over.
Just be careful how you go about saving the game state.
Keeping the single responsibility principle in mind, it’s also a good idea to keep the state that you’re saving separate from the key object.
This separate object that holds the state is known as the Memento object.
Your interactive role playing game has an insatiable appetite for monsters.
As your heros make their journey through a dynamically created landscape, they encounter an endless chain of  foes that must be subdued.
You’d like the monster’s characteristics to evolve with the changing landscape.
It doesn’t make a lot of  sense for bird-like monsters to follow your characters into underseas realms.
Finally, you’d like to allow advanced players to create their own custom monsters.
Prototype Use the Prototype Pattern when creating an instance of  a given class is either expensive or complicated.
It would be a lot cleaner if we could decouple the code that handles the details of creating the monsters from the code that actually needs to.
Yikes! Just the act of creating all of these different kinds of monster instances is getting.
Putting all sorts of state detail in the constructors doesn’t seem to be very cohesive.
It would be great if there was a single place where all of the instantiation details could be.
Prototype to the rescue The Prototype Pattern allows you to make new instances by copying existing instances.
In Java this typically means using the clone() method, or de-serialization when you need deep copies.
A key aspect of  this pattern is that the client code can make new instances without knowing which speciﬁ c class is being instantiated.
The registry finds the appropriate monster, makes a clone of it, and returns the clone.
Visitor Use the Visitor Pattern when you want to add capabilities to a composite of  objects and encapsulation is not important.
Customers who frequent the Objectville Diner and Objectville Pancake House have recently become more health conscious.
They are asking for nutritional information before ordering their meals.
Because both establishments are so willing to create special orders, some customers are even asking for nutritional information on a per ingredient basis.
The Visitor drops by The Visitor must visit each element of  the Composite; that functionality is in a Traverser object.
The Visitor is guided by the Traverser to gather state from all of  the objects in the Composite.
Once state has been gathered, the Client can have the Visitor perform various operations on the state.
When new functionality is required, only the Visitor must be enhanced.
All these composite classes have to do is add a getState() method (and not worry about exposing themselves)
The Client asks the Visitor to get information from the Composite structure...
New methods can be added to the Visitor without affecting the Composite.
Kathy and Bert created the look & feel of the Head First series.
Interior design and production all happened exclusively on Apple Macintoshes–at Head First we’re all.
Corporation, Zero 7 and Neil Finn (in all his incarnations) along with a heck of a lot of acid trance and.
Our world class researchers are working day and night in a mad race to.
Never before has a research team with such noble and daunting goals been.
Currently, we are focusing our collective energy and brain power on.
You’re fortunate to be holding one of our ﬁrst protoypes in your hands.
And next time you’re in Objectville, drop by and take one of our behind.
But you won’t just be a spectator; we also encourage you to.
Now that you’ve applied the Head First approach to Design Patterns, why not apply it to the rest of your life?
Search Safari! The premier electronic reference library for programmers and IT professionals.
Sign up today and get your first 14 days free.
Our books are available at most retail and online bookstores.
Why register your books? Once you’ve registered your O’Reilly books you can:
Win O’Reilly books, T-shirts or discount coupons in our monthly drawing.
Get email notification of new editions of the O’Reilly books you own.
Sign up to get topic-specific email announcements of new books and conferences, special offers, and O’Reilly Network technology newsletters at:
It’s easy to customize your free elists subscription so you’ll get exactly the O’Reilly news you want.
Our web site contains a library of comprehensive product information (including book excerpts and tables of contents), downloadable software, background articles, interviews with technology leaders, links to relevant sites, book cover art, and more.
For a list of our distributors outside of North America check out:
Our books are available at most retail and online bookstores.
