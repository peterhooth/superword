Beyond the engaging style that drags you forward from know-nothing into exalted Java warrior status, Head First Java covers a huge amount of practical matters that other texts leave as the dreaded “exercise for the reader...”  It’s clever, wry, hip and practical—there aren’t a lot of textbooks that can make that claim and live up to it while also teaching you about object serialization and network launch protocols.
Kathy and Bert’s ‘Head First Java’ transforms the printed page into the closest thing to a GUI you’ve ever seen.
This is one book that makes learning a complex computer language fun.
I hope that there are more authors who are willing to break out of the same old mold of ‘traditional’ writing styles.
In typical O’Reilly fashion, they’ve taken a scientiﬁc and well considered approach.
If anyone in the world is familiar with the concept of ‘Head First,’ it would be me.
Seriously though - this book absolutely blows away every other software book I’ve ever read...
Congratulations to the Head First EJB team for a ﬁrst class job!
My ﬁrst reaction was to roll on the ﬂoor laughing.
Just the right tone for the geeked-out, casual-cool guru coder in all of us.
Be watching for more books in the Head First series.
Wouldn’t it be dreamy if there was a Java book.
O’Reilly Media books may be purchased for educational, business, or sales promotional use.
Java and all Java-based trademarks and logos are trademarks or registered trademarks of Sun Microsystems, Inc., in the United States and other countries.
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and O’Reilly Media, Inc.
While every precaution has been taken in the preparation of this book, the publisher and the authors assume no responsibility for errors or omissions, or for damages resulting from the use of the information contained herein.
Kathy has been interested in learning theory since her days as a game designer (she wrote games for Virgin, MGM, and Amblin’)
More recently, she’s been a master trainer for Sun Microsystems, teaching Sun’s Java instructors how to teach the latest Java technologies, and a lead developer of several of Sun’s Java programmer and developer certiﬁ cation exams.
Together with Bert Bates, she has been actively using the concepts in Head First Java to teach hundreds of trainers, developers and even non-programmers.
She is also the founder of one of the largest Java community websites in the world, javaranch.com, and the Creating Passionate Users blog.
In her spare time she enjoys her new Icelandic horse, skiing, running, and the speed of light.
Bert is a software developer and architect, but a decade-long stint in artiﬁ cial intelligence drove his interest in learning theory and technologybased training.
Recently, he’s been a member of the development team for several of Sun’s Java Certiﬁ cation exams.
One of his all-time favorite projects was building a full rail system simulation for Union Paciﬁ c Railroad.
Bert is a hopelessly addicted Go player, and has been working on a Go program for way too long.
He’s a fair guitar player, now trying his hand at banjo, and likes to spend time skiing, running, and trying to train (or learn from) his Icelandic horse Andi.
Bert co-authored the same books as Kathy, and is hard at work on the next batch of books (check the blog for updates)
You can sometimes catch him on the IGS Go server (under the login jackStraw)
Although Kathy and Bert try to answer as much email as they can, the volume of mail and their travel schedule makes that difficult.
The best (quickest) way to get technical help with the book is at the very active Java beginners forum at javaranch.com.
Here you are trying to learn something, while here your brain is doing you a favor by making sure the learning doesn’t stick.
A Trip to ObjectvilleI was told there would be objects.
In Chapter 1, we put all of our code in the main() method.
From its humble release to the public as the (wimpy) version 1.02,  Java seduced programmers with its friendly syntax, object-oriented.
Know Your VariablesVariables come in two flavors: primitive and reference.
There’s gotta be more to life than integers, Strings, and arrays.
What if you have a PetOwner object with a Dog instance variable? Or a Car with an Engine? In this chapter we’ll unwrap.
We know that objects have state and behavior, represented by instance variables and  methods.
Now we’ll look at how state and behavior are related.
You dabbled with variables, played with a few objects, and wrote a little code.
And turn a String into an int, yeah, that would be cool.
And why don’t we learn it all by building something real, to see what it’s like to write (and test) a program from scratch.
Using the Java LibraryJava ships with hundreds of  pre-built classes.
You don’t have to reinvent the wheel if you know how to find what you need from the Java library, commonly known as the Java API.
If you’re going to write code, you might as well write only the parts that are custom for your application.
Good to know there’s an ArrayList in the java.util package.
Better Living in ObjectvillePlan your programs with the future in mind.
What if you could write code that someone else could extend, easily? What if you could write code that was flexible, for those pesky last-minute spec changes? When you get on the Polymorphism Plan, you’ll.
We need to go beyond simple inheritance to flexibility you can get only by designing and coding to interfaces.
Roses are red, violets are blue.Square IS-A Shape, the reverse isn’t true.Roses are red, violets are dear.Beer IS-A Drink, but not all drinks are beer.OK, your turn.
Make one that shows the oneway-ness of the IS-A relationship.
Life and Death of an ObjectObjects are born and objects die.
We’ll look at how objects are created, where they live, and how to.
The Java API has methods for absolute value, rounding, min/max, etc.
But what about formatting? You might want numbers to print exactly two decimal points, or with commas in all the right places.
And you might want to print and manipulate dates, too.
And what about parsing a String into a number? Or turning a number into a String? We’ll start by learning what it means for a variable or method to be static.
Static variables are shared by all instances of a class.
No matter how good a programmer you are, you can’t control everything.
When you write a risky method, you need code to handle the bad things that might happen.
Even if you believe that for the rest of your life you’ll write only server-side code, sooner or later you’ll need to write tools, and you’ll.
We’ll spend two chapters on GUIs, and learn more language.
Swing code looks easy, but then compile it, run it, look at it and think, “hey, that’s not supposed to go there.” The thing that makes it easy to code is the thing that makes it hard to control—the Layout Manager.
But with a little work, you can get layout managers to submit to your will.
In this chapter, we’ll work on our Swing and learn more about widgets.
Behavior lives in the class, but state lives within each individual object.
Or, you can do it the easy OO way—you simply.
Things in the north and south get their preferred height.
All the low-level networking details are taken care of by classes in the java.net library.
One of Java’s best features is that sending and receiving data over a network is really just I/O with a slightly different.
You told everyone you know that if you never saw a line of code again, that’d be fine.
But in the end, you’ve created a work of art.
The thing actually runs! But now what? In these final.
Some of the coolest things in Java are easier than you think.
Framework has a data structure that should work for virtually anything you’ll ever need.
Want to keep a list that you can easily keep adding to? Want to find something by.
Distributed ComputingBeing remote doesn’t have to be a bad thing.
Sure, things are easier when all the parts of your application are in one place, in one heap, with one JVM to rule them all.
We can’t send you out into the world just yet.
We have a few more things for you, but this is the end of the book.
All the code for the full client-server chat beat box.
I can’t believe they put that in a Java programming book!
Are you afraid to try something different? Would you rather have a root canal than mix stripes with plaid? Do you believe than a technical book can’t be serious if there’s a picture of a duck in the memory management section?
If you can answer “yes” to any one of these:
Are you a kick-butt C++ programmer looking for a reference book?
Do you prefer stimulating dinner party conversation to dry, dull, technical lectures?
Head First Java is a book designed for learning, not an encyclopedia of Java facts.
It was built that way, and it helps you stay alive.
So what does your brain do with all the routine, ordinary, normal things you encounter? Everything it can to stop them from interfering with the brain’s real job—recording things that matter.
It doesn’t bother saving the boring things; they never make it past the “this is obviously not important” ﬁlter.
How does your brain know what’s important? Suppose you’re out for a day hike and a tiger jumps in front of you, what happens inside your head?
Or trying to learn some tough technical topic your boss thinks will take a week, ten days at the most.
It’s trying to make sure that this obviously non-important content doesn’t clutter up scarce resources.
Resources that are better spent storing the really big things.
And there’s no simple way to tell your brain, “Hey brain, thank you very much, but no matter how dull this book is, and how little I’m registering on the emotional richter scale right now, I really do want you to keep this stuff around.”
So what does it take to le arn something? First, yo.
A reader has to be motiv ated, engaged, curious, a.
And for that, you need ch allenges, exercises, and t.
We think of a “Head First Ja va” reader as a learner.
If you really want to learn, and you want to learn more quickly and more deeply, pay attention to how you pay attention.
Most of us did not take courses on metacognition or learning theory when we were growing up.
We were expected to learn, but rarely taught to learn.
But we assume that if you’re holding this book, you want to learn Java.
And you probably don’t want to spend a lot of time.
To get the most from this book, or any book or learning experience, take responsibility for your brain.
The trick is to get your brain to see the new material you’re learning as Really Important.
Otherwise, you’re in for a constant battle, with your brain doing its best to keep the new content from sticking.
So just how DO you get your brain to treat Java like it was a hungry tiger?
There’s the slow, tedious way, or the faster, more effective way.
You obviously know that you are able to learn and remember even the dullest of topics, if you keep pounding on the same thing.
With enough repetition, your brain says, “This doesn’t feel important to him, but he keeps looking at the same thing over and over and over, so I suppose it must be.”
The faster way is to do anything that increases brain activity, especially different types of brain activity.
The things on the previous page are a big part of the solution, and they’re all things that have been proven to help your brain work in your favor.
For example, studies show that putting words within the pictures they describe (as opposed to somewhere else in the page, like a caption or in the body text) causes your brain to try to makes sense of how the words and picture relate, and this causes more neurons to ﬁre.
More neurons ﬁring = more chances for your brain to get that this is something worth paying attention to, and possibly recording.
A conversational style helps because people tend to pay more attention when they perceive that they’re in a conversation, since they’re expected to follow along and hold up their end.
The amazing thing is, your brain doesn’t necessarily care that the “conversation” is between you and a book! On the other hand, if the writing style is formal and dry, your brain perceives it the same way you experience being lectured to while sitting in a roomful of passive attendees.
We used pictures, because your brain is tuned for visuals, not text.
As far as your brain’s concerned, a picture really is worth 1024 words.
And when text and pictures work together, we embedded the text in the pictures because your brain works more effectively when the text is within the thing the text refers to, as opposed to in a caption or buried in the text somewhere.
We used repetition, saying the same thing in different ways and with different media types, and multiple senses, to increase the chance that the content gets coded coded into more than one area of your brain.
We used concepts and pictures in unexpected ways because your brain is tuned for novelty, and we used pictures and ideas with at least some emotional content, because your brain is tuned to pay attention to the biochemistry of emotions.
That which causes you to feel something is more likely to be remembered, even if that feeling is nothing more than a little humor, surprise, or interest.
We used a personalized, conversational style, because your brain is tuned to pay more attention when it believes you’re in a conversation than if it thinks you’re passively listening to a presentation.
We included more than 50 exercises , because your brain is tuned to learn and remember more when you do things than when you read about things.
We used multiple learning styles, because you might prefer step-by-step procedures, while someone else wants to understand the big picture ﬁrst, while someone else just wants to see a code example.
But regardless of your own learning preference, everyone beneﬁts from seeing the same content represented in multiple ways.
We include content for both sides of your brain, because the more of your brain you engage, the more likely you are to learn and remember, and the longer you can stay focused.
Since working one side of the brain often means giving the other side a chance to rest, you can be more productive at learning for a longer period of time.
And we included stories and exercises that present more than one point of view, because your brain is tuned to learn more deeply when it’s forced to make evaluations and judgements.
We included challenges, with exercises, and by asking questions that don’t always have a straight answer, because your brain is tuned to learn and remember when it has to work at something (just as you can’t get your body in shape by watching people at the gym)
But we did our best to make sure that when you’re working hard, it’s on the right things.
That you’re not spending one extra dendrite processing a hard-tounderstand example, or parsing difﬁcult, jargon-laden, or extremely terse text.
We assume that if you’re going for a PhD in Java, this won’t be your only book.
These tips are a starting point; Listen to your brain and ﬁgure out what works for you and what doesn’t.
Here’s what YOU can do to bend your brain into submission.
The more you understand, the less you have to memorize.
When the book asks you a question, don’t just skip to the answer.
The more deeply you force your brain to think, the better chance you have of learning and remembering.
We put them in, but if we did them for you, that would be like having someone else do your workouts for you.
There’s plenty of evidence that physical activity while learning can increase the learning.
They’re not optional side-bars—they’re part of the core content! Sometimes the questions are more useful than the answers.
It’ll help your brain feel something, and keeps your learning from being too connected to a particular place.
Part of the learning (especially the transfer to long-term memory) happens after you put the book down.
Your brain needs time on its own, to do more processing.
If you put in something new during that processing-time, some of what you just learned will be lost.
Your brain works best in a nice bath of ﬂuid.
Dehydration (which can happen before you ever feel thirsty) decreases cognitive function.
If you’re trying to understand something, or increase your chance of remembering it later, say it out loud.
Better still, try to explain it out loud to someone else.
You’ll learn more quickly, and you might uncover ideas you hadn’t known were there when you were reading about it.
If you ﬁnd yourself starting to skim the surface or forget what you just read, it’s time for a break.
Once you go past a certain point, you won’t learn faster by trying to shove more in, and you might even hurt the process.
Then you can experiment with changing and improving the code (or breaking it, which is sometimes the best way to ﬁgure out what’s really happening)
For long examples or Ready-bake code, you can download the source ﬁles from headﬁrstjava.com.
Feel something! Your brain needs to know that this matters.
Groaning over a bad joke is still better than feeling nothing at all.
You do not need any other development tool, such as an Integrated Development Environment (IDE)
We strongly recommend that you not use anything but a basic text editor until you complete this book (and especially not until after chapter 16)
An IDE can protect you from some of the details that really matter, so you’re much better off learning from the command-line and then, once you really understand what’s happening, move to a tool that automates some of the process.
If you’re on Linux, Windows, or Solaris, you can get it for free from java.sun.com (Sun’s website for Java developers)
It usually takes no more than two clicks from the main page to get to the J2SE downloads page.
The SDK includes everything you need to compile and run Java.
It’s part of OS X, and you don’t have to do anything else.
If you’re on an earlier version of OS X, you have an earlier version of Java that will work for 95% of the code in this book.
You can also access the API docs online, without downloading them, but that’s a pain.
Virtually any text editor will do (vi, emacs, pico), including the GUI ones that come with most operating systems.
Tha bin directory is the one you need a PATH to, so that when you type: % javac at the command-line, your terminal will know how to find the javac compiler.
Note: if you have trouble with you installation, we recommend you go to javaranch.com, and join the Java-Beginning forum! Actually, you should do that whether you have trouble or not.
We deliberately stripped out everything that might get in the way of learning whatever it is we’re working on at that point in the book.
And the ﬁ rst time through, you need to begin at the beginning, because the book makes assumptions about what you’ve already seen and learned.
If we’d used pure UML, you’d be seeing something that looks like Java, but with syntax that’s just plain wrong.
So we use a simpliﬁ ed version of UML that doesn’t conﬂ ict with Java syntax.
If you don’t already know UML, you won’t have to worry about learning Java and UML at the same time.
We don’t worry about organizing and packaging your own code until the end of the book.
In this book, you can get on with the business of learning Java, without stressing over some of the organizational or administrative details of developing Java programs.
You will, in the real world, need to know—and use—these details, so we cover them in depth.
But we save them for the end of the book (chapter 17)
Answers for both are at the end of each chapter.
One thing you need to know about the puzzles—they’re puzzles.
The exercises are here to help you practice what you’ve learned, and you should do them all.
The puzzles are a different story, and some of them are quite challenging in a puzzle way.
These puzzles are meant for puzzlers, and you probably already know if you are one.
If you’re not sure, we suggest you give some of them a try, but whatever happens, don’t be discouraged if you can’t solve a puzzle or if you simply can’t be bothered to take the time to work them out.
For some of them, there is no right answer, and for the others, part of the learning experience for the Sharpen activities is for you to decide if and when your answers are right.
The code examples are as lean as possible It’s frustrating to wade through 200 lines of code looking for the two lines you need to understand.
Most examples in this book are shown within the smallest possible context, so that the part you’re trying to learn is clear and simple.
So don’t expect the code to be robust, or even complete.
That’s your assignment for after you ﬁ nish the book.
The book examples are written speciﬁ cally for learning, and aren’t always fully-functional.
Activities marked with the Exercise (running shoe) logo are mandatory! Don’t skip them if you’re serious about learning Java.
He has worked as a software engineer with SRI International (Menlo Park, CA) and as a principal engineer in the Software Engineering Laboratory of EPFL.
Valentin is the co-founder and CTO of Condris Technologies, a company specializing in the development of software architecture solutions.
His research and development interests include aspect-oriented technologies, design and architectural patterns, web services, and software architecture.
Besides taking care of his wife, gardening, reading, and doing some sport, Valentin moderates the SCBCD and SCDJWS forums at Javaranch.com.
He has also had the opportunity to serve as a co-author for Whizlabs SCBCD Exam Simulator.
We’re still in shock from seeing him in a tie.
Does anyone really believe that? See the two people on this page? If you ﬁ nd technical problems, it’s probably their fault.
Our biggest thanks to Mike Loukides at O’Reilly, for taking a chance on this, and helping to shape the Head First concept into a book (and series)
As this second edition goes to print there are now ﬁ ve Head First books, and he’s been with  us all the way.
To Tim O’Reilly, for his willingness to launch into something completely new and different.
Thanks to the clever Kyle Hart for ﬁ guring out how Head First ﬁ ts into the world, and for launching the series.
Our top honors and thanks go to the director of our javaranch tech review team, Johannes de Jong.
This is your ﬁ fth time around with us on a Head First book, and we’re thrilled you’re still speaking to us.
Jeff Cumps is on his third book with us now and relentless about ﬁ nding areas where we needed to be more clear or correct.
And we think you give the clearest explanations on javaranch.
You’ll probably notice we stole one or two of them.
Jason Menard saved our technical butts on more than a few details, and Thomas Paul, as always, gave us expert feedback and found the subtle Java issues the rest of us missed.
Jane Griscti has her Java chops (and knows a thing or two about writing) and it was great to have her helping on the new edition along with long-time javarancher Barry Gaunt.
Marilyn de Queiroz gave us excellent help on both editions of the book.
Special thanks to a few of the Head Firsters who’ve been helping us from the beginning: Angelo Celeste, Mikalai Zaikin, and Thomas Duff (twduff.com)
And thanks to our terriﬁ c agent, David Rogelberg of StudioB (but seriously, what about the movie rights?)
Just when you thought there wouldn’t be any more acknowledgements*
More Java technical experts who helped out on the ﬁrst edition (in pseudo-random order):
The large number of acknowledgements is because we’re testing the theory that everyone mentioned in a book acknowledgement will buy at least one copy, probably more, what with relatives and everything.
If you’d like to be in the acknowledgement of our next book, and you have a large family, write to us.
Some of us had to walk ﬁ ve miles in the snow, uphill both ways (barefoot), to.
But you, why, you get to ride the sleeker, faster, much.
Come on, the water’s great! We’ll dive right in and.
Use an established protocol (in this case, the Java language)
The goal is to write one application (in this example, an interactive party invitation) and have it work on whatever device your friends have.
The compiler checks for errors and won’t let you compile until it’s satisﬁ ed that everything will run correctly.
The  compiler creates a new document, coded into Java bytecode.
Your friends don’t have a physical  Java Machine, but they all have a virtual Java machine (implemented in software) running inside their electronic gadgets.
Compile the Party.java ﬁ le by running javac (the compiler application)
If you don’t have  errors, you’ll get a second document named Party.class.
The compiler-generated Party.class ﬁ le is made up of bytecodes.
Run the program by starting the Java Virtual Machine (JVM) with the Party.class ﬁ le.
The JVM translates the bytecode into something the underlying platform understands, and runs your program.
You’ll type a source code ﬁ le, compile it using the javac compiler, then run the compiled bytecode on a Java virtual machine.
Try to guess what each line of code is doing...
We have no idea what will happen with the next release...
If Java resembles a language you’ve used in the past, some of this will be simple.
A   source code ﬁ le (with the .java extension) holds one class deﬁ nition.
The class represents a piece of your program, although a very tiny application might need just a single class.
The class must go within a pair of curly braces.
In the Dog class, the bark method will hold instructions for how the Dog should bark.
Your methods must be declared inside a class (in other words, within the curly braces of the class)
Within the curly braces of a method, write your instructions for how that method should be performed.
Method code is basically a set of statements, and for now you can think of a method kind of like a function or procedure.
Anatomy of a class When the JVM starts running, it looks for the class you give it at the command line.
Then it starts looking for a specially-written method that looks exactly like:
This method must be given an array of Strings, and the array will be called ‘args’
Writing a class with a main In Java, everything goes in a class.
You’ll type your source code ﬁ le (with a .java extension), then compile it into a new class ﬁ le (with a .class extension)
When you run your program, you’re really running a class.
In chapter 2, we go  deeper into the whole class thing, but for now, all you need to think is, how do I write Java code so that it will run?  And it all begins with main()
No matter how big your program is (in other words, no matter how many classes your program uses), there’s got to be a main() method to get the ball rolling.
Once you’re inside main (or any method), the fun begins.
You can say all the normal things that you say in most programming languages to make the computer do something.
Variables are declared with a name and a type (you’ll learn about all the  Java types in chapter 3)
Classes and methods must be defined within a pair of curly braces.
Java has three standard looping  constructs: while, do-while, and for.
You’ll get the full     loop scoop later in the book, but not for awhile, so let’s do while for now.
The syntax (not to mention logic) is so simple you’re probably asleep already.
As long as some condition is true, you do everything inside the loop block.
The loop block is bounded by a pair of curly braces, so whatever you want to repeat needs to be inside that block.
In Java, a conditional test is an expression that results in a boolean value —in other words, something that is either true or false.
If you say something like, “While iceCreamInTheTub is true, keep scooping”, you have a clear boolean test.
There either is ice cream in the tub or there isn’t.
But if you were to say, “While Bob keep scooping”, you don’t have a real test.
To make that work, you’d have to change it to something like, “While Bob is snoring...” or “While Bob is not wearing plaid...”
Simple boolean tests You can do a simple boolean test by checking the value of a variable, using a comparison operator including:
Notice the difference between the assignment operator (a single equals sign) and the equals operator (two equals signs)
Lots of programmers accidentally type = when they want ==
Q: Why does everything have to be in a class?
It’s not like the old days when you had steamdriven compilers and wrote one monolithic source file with a pile of procedures.
In chapter 2 you’ll learn that a class is a blueprint for an object, and that nearly everything in Java is an object.
Q: Do I have to put a main in every class I write?
A Java program might use dozens of classes (even hundreds), but you might only have one with a main methodthe one that starts the program running.
You might write test classes, though, that have main methods for testing your other classes.
Q: In my other language I can do a boolean test on an integer.
A boolean and an integer are not compatible types in Java.
Since the result of a conditional test must be a boolean, the only variable you can directly test (without using a comparison operator) is a boolean.
Conditional branching In Java, an if test is basically the same as the boolean test in a while loop – except instead of saying, “while there’s still beer...”, you’ll say, “if there’s still beer...”
Regardless of whether it’s true, though, the line that prints, “This runs no matter what” will run.
So depending on the value of x, either one statement or two will print out.
But we can add an else to the condition, so that we can say something like, “If there’s still beer, keep coding, else (otherwise) get more beer, and then continue on...”
If you want each thing you print out to be on its own line, use println.
If you want everything to stick together on one line, use print.
Coding a Serious Business Application Let’s put all your new Java skills to good use with something practical.
We need a class with a main(), an int and a String variable, a while loop, and an if test.
A little more polish, and you’ll be building that business backend in no time.
But before you look at the code on this page, think for a moment about how you would code that classic children’s favorite, “99 bottles of beer.”
It compiles and runs, but the output isn’t 100% perfect.
See if you can spot the flaw , and fix it.
Bob’s alarm clock rings at 8:30 Monday morning, just like every other weekday.
But Bob had a wild weekend, and reaches for the SNOOZE button.
And that’s when the action starts, and the Java-enabled appliances come to life.
Finally, the alarm clock sends a message to Sam’s (Sam is the dog) wireless collar, with the too-familiar signal that.
Stick with a sensible solution using Java, Ethernet, and Jini technology.
Beware of  imitations using other so-called “plug and play” (which actually means “plug and play with it for the next three days trying to get it to work”) or “portable” platforms.
Bob’s sister Betty tried one of those others, and the results were, well, not very appealing, or safe.
While there are versions of Java running in devices including PDAs, cell phones (especially cell phones), pagers, rings, smart cards, and more –you might not find a Java toaster or dog collar.
But even if you can’t find a Java-enabled version of your favorite gadget, you can still run it as if it were a Java device by controlling it through some other interface (say, your laptop) that is running Java.
OK, so the beer song wasn’t really a serious business application.
Still need something practical to show the boss? Check out the Phrase-O-Matic code.
So the hyphens you see on this page are real, and you can type them, but don’t hit the return key until AFTER you’ve closed a String.
In a nutshell, the program makes three lists of words, then randomly picks one word from each of the three lists, and prints out the result.
Don’t worry if you don’t understand exactly what’s happening in each line.
For gosh sakes, you’ve got the whole book ahead of you, so relax.
This is just a quick look from a 30,000 foot outside-the-box targeted leveraged paradigm.
The ﬁrst step is to create three  String arrays – the containers that will hold all the words.
Declaring and creating an array is easy;  here’s a small one:
Each word is in quotes (as all good Strings must be) and separated by commas.
For each of the three lists (arrays), the goal is to pick a random word, so we have to know how many words are in each list.
Quite handily, a Java array is more than happy to tell you its length.
Java ships out-of-the-box, off-the-shelf, shrinkwrapped, and core competent with a set of math methods (for now, think of them as functions)
It’s the same as if we had any ﬂoating point number that we wanted to convert to an integer:
Now we get to build the phrase, by picking a word from each of the three lists, and smooshing them together (also inserting spaces between words)
We use the “+” operator, which concatenates (we prefer the more technical ‘smooshes’) the String objects together.
To get an element from an array, you give the array the index  number (position) of the thing you want using:
String s = pets[0]; // s is now the String “Fido”
You can print it out and use it for wall paper, kindling, lining the bird cage whatever, but the ﬁle doesn’t do anything unless I’m there to run it.
And that’s another thing, the compiler has no sense of humor.
Then again, if you had to spend all day checking nit-picky little syntax violations...
A programmer could just write bytecode by hand, and I’d take it.
But you still didn’t answer my question, what do you actually do?
Excuse me, but without me, what exactly would you run? There’s a reason Java was designed to use a bytecode compiler, for your information.
Java’s had a challenging enough time convincing people that it’s ﬁnally fast and powerful enough for most jobs.
Excuse me, but that’s quite an ignorant (not to mention arrogant) perspective.
A programmer writing bytecode by hand is like doing your word processing by writing raw postscript.
And I would appreciate it if you would not refer to me as “buddy.”
Tonight’s Talk: The compiler and the JVM battle over the question, “Who’s more important?”
But what about security? Look at all the security stuff I do, and you’re like, what, checking for semicolons? Oooohhh big security risk! Thank goodness for you!
I have to do that same stuff too, though,  just to make sure nobody snuck in after you and changed the bytecode before running it.
Remember that Java is a strongly-typed language, and that means I can’t allow variables to hold data of the wrong type.
This is a crucial safety feature, and I’m able to stop the vast majority of violations before they ever get to you.
And yes, there are some datatype exceptions that can emerge at runtime, but some of those have to be allowed to support one of Java’s other important features—dynamic binding.
At runtime, a Java program can include new objects that weren’t even known to the original programmer, so I have to allow a certain amount of ﬂexibility.
But my job is to stop anything that would never—could never—succeed at runtime.
Usually I can tell when something won’t work, for example, if a programmer accidentally tried to use a Button object as a Socket connection, I would detect that and thus protect him from causing harm at runtime.
Excuse me, but I am the ﬁrst line of defense, as they say.
The datatype violations I previously described could wreak havoc in a program if they were allowed to manifest.
I am also the one who prevents access violations, such as code trying to invoke a private method, or change a method that – for security reasons – must never be changed.
I stop people from touching code they’re not meant to see, including code trying to access another class’ critical data.
It would take hours, perhaps days even, to describe the signiﬁcance of my work.
Of course, but as I indicated previously, if I didn’t prevent what amounts to perhaps 99% of the potential problems, you would grind to a halt.
And it looks like we’re out of time, so we’ll have to revisit this in a later chat.
Exercise Code Magnets A working Java program is all scrambled up on the fridge.
Can you rearrange the code snippets to make a working Java program that produces the output listed below? Some of the curly braces fell on the floor and they were too small to  pick up, so feel free to add as many of those as you need!
Each of the Java files on this page represents a complete source file.
Your job is to play compiler and determine whether each of these.
Just to keep you awake,  we also threw in a few (non-Java) words from the high-tech world.
Your challenge is to match the candidate block of code (on the left), with the output that you’d see if the block were inserted.
Not all the lines of output will be used, and some of the lines of output might be used more than once.
Draw lines connecting the candidate blocks of code with their matching command-line output.
Pool Puzzle Your job is to take code snippets from the.
You may not use the same snippet more than once, and you won’t need to use all the snippets.
Note:  Each snippet from the pool can be used only once!
In chapter 1, we put all of our code in the main() method.
Larry, sitting in his cube, thought to himself, “What are the things this program has to do? What procedures do we need?”
And he answered himself , “rotate and playSound.” So off he went to build the procedures.
After all, what is a program if not a pile of procedures?
Of course, there were other objects he thought of like the User, the Sound, and the Clicking event.
But he already had a library of code for those pieces, so he focused on building Shapes.
Read on to see how Brad and Larry built their programs, and for the answer to your burning question, “So, who got the Aeron?”
At Brad’s laptop at the cafe Brad wrote a class for each of the three shapes.
In Larry’s cube As he had done a gazillion times before, Larry set about writing his Important Procedures.
OK, technically you were ﬁ rst, Larry,” said the Manager, “but we have to add just one tiny thing to the program.
And that if you wanted to change his mind, you’d have to pry it from his cold, dead, carpal-tunnelled hands.
He could almost feel the rolled steel of the Aeron beneath his...
Back in Larry’s cube The rotate procedure would still work; the code used a lookup table to match a shapeNum to an actual shape graphic.
It turned out not to be such a big deal, but it still made him queasy to touch previously-tested code.
Of all people, he should know that no matter what the project manager says, the spec always changes.
At Brad’s laptop at the beach Brad smiled, sipped his margarita, and wrote one new class.
Sometimes the thing he loved most about OO was that he didn’t have to touch code he’d already tested and delivered.
But the smirk on Larry’s face melted when the Really Annoying Project Manager said (with that tone of disappointment), “Oh, no, that’s not how the amoeba is supposed to rotate...”
Turns out, both programmers had written their rotate code like this:
But the amoeba shape was supposed to rotate around a point on one end, like a clock hand.
Back in Larry’s cube He ﬁ gured he better add rotation point arguments to the rotate procedure.
At Brad’s laptop on his lawn chair at the Telluride Bluegrass Festival Without missing a beat, Brad modiﬁ ed the rotate method, but only in the Amoeba class.
He never touched the tested, working, compiled code for the other parts of   the program.
To give the Amoeba a rotation point, he added an attribute that all Amoebas would have.
He modiﬁ ed, tested, and delivered (wirelessly) the revised program during a single Bela Fleck set.
So, Brad the OO guy got the chair, right? Not so fast.
And, since he was sure that if he got the chair he’d also get Lucy in accounting, he had to turn this thing around.
LARRY:  You’ve got duplicated code! The rotate procedure is in all four Shape things.
BRAD:  Oh, I guess you didn’t see the ﬁnal design.
So I abstracted out the common features and put them into a new class called Shape.
Then I linked the other four shape classes to the new Shape class, in a relationship called inheritance.
I looked at what all four classes have in common.
You can read this as, “Square inherits from Shape”, “Circle inherits from Shape”, and so on.
I removed rotate() and playSound() from the other shapes, so now there’s only one copy to maintain.
The Shape class is called the superclass of the other four classes.
In other words, if the Shape class has the functionality, then the subclasses automatically get that same functionality.
What about the Amoeba rotate()? LARRY:  Wasn’t that the whole problem here — that the amoeba shape had a completely different rotate and playSound procedure?
How can amoeba do something different if it “inherits” its functionality from the Shape class?
The Amoeba class overrides the methods of the   Shape class.
Then at runtime, the JVM knows exactly which rotate() method to run when someone tells the Amoeba to rotate.
I made the Amoeba class override the rotate() method of the superclass Shape.
Overriding just means that a subclass redefines one of its inherited methods when it needs to change or extend the behavior of that method.
LARRY:  How do you “tell” an Amoeba to do something? Don’t you have to call the procedure, sorry—method, and then tell it which thing to rotate?
When it’s time for, say, the triangle to rotate, the program code invokes (calls) the rotate() method on the triangle object.
The rest of the program really doesn’t know or care how the triangle does it.
And when you need to add something new to the program, you just write a new class for the new object type, so the new objects will have their own behavior.
Don’t you worry your little programmer head about how I do it.
I made the Amoeba class override the rotate() and playSound() methods of the superclass Shape.
Overriding just means that a subclass redefines one of its inherited methods when it needs to change or extend the behavior of that method.
Speaking (and hearing) activates a different part of your brain.
What do you like about OO? Time to pump some neurons.
You just read a story bout a procedural programmer going head-to-head with an OO programmer.
You got a quick overview of some key OO concepts including classes, methods, and attributes.
We’ll spend the rest of the chapter looking at classes and objects (  we’ll return to inheritance and overriding in later chapters)
Based on what you’ve seen so far (and what you may know from a previous OO language you’ve worked with), take a moment to think about these questions:
What are the fundamental things you need to think about when you design a Java class?  What are the questions you need to ask yourself? If you could design a checklist to use when you’re designing a class, what would be on the checklist?
Things an object knows about itself are called instance variables.
They represent an object’s state (the data), and can have unique values for each object of that type.
When you design a class, you think about the data an object will need to know about itself, and you also design the methods that operate on that data.
It’s common for an object to have methods that read or write the values of the instance variables.
For example, Alarm objects have an instance variable to hold the alarmTime, and two methods for getting and setting the alarmTime.
So objects have instance variables and methods, but those instance variables and methods are designed as part of the class.
Sharpen your pencil Fill in what a television object might need to know and do.
It tells the virtual machine how to make an object of that particular type.
Each object made from that class can have its own values for the instance variables of that class.
For example, you might use the Button class to make dozens of different buttons, and each button might have its own color, size, shape, label, and so on.
The methods of the class are the things you do to a particular card; getName( ), changeName( ), setName( ) could all be methods for class Rolodex.
An object is like one entry in your address book.
Making your first object So what does it take to create and use an object? You need two classes.
The tester class is where you put the main method, and in that main() method you create and access objects of your new class type.
The tester class has only one job: to try out the methods and variables of your new object class type.
From this point forward in the book, you’ll see two classes in many of our examples.
For example, if we make a Bungee class, we’ll need a BungeeTestDrive class as well.
This will all be made stunningly clear by the following examples.
If you already have some OO savvy, you’ll know we’re not using encapsulation.
The MovieTestDrive class also invokes (calls) a method on one of the objects.
Fill in the chart to the right with the values the three objects  have at the end of main()
Quick! Get out of main! As long as you’re in main(), you’re not really in Objectville.
It’s ﬁ ne for a test program to run within the main method, but in a true OO application, you need objects talking to other objects, as opposed to a static main() method creating and testing objects.
In this case, talking means objects calling methods on one another.
On the previous page, and in chapter 4 , we look at using a main() method from a separate TestDrive class to create and test the methods and variables of another class.
As a ‘sneak preview’, though, of how a real Java application might behave, here’s a little example.
Because we’re still at the earliest stages of learning Java, we’re working with a small toolkit, so you’ll ﬁ nd this program a little clunky and inefﬁ cient.
You might want to think about what you could do to improve it, and in later chapters that’s exactly what we’ll do.
Don’t worry if some of the code is confusing; the key point of this example is that objects talk to objects.
The GameLauncher class is where the application starts; it has the main() method.
In the main() method, a GuessGame object is created, and its startGame() method is called.
The GuessGame object’s startGame() method is where the entire game plays out.
It  creates three players, then “thinks” of a random number (the target for the players to guess)
It then asks each player to guess, checks the result, and either prints out information about the winning player(s) or asks them to guess again.
GuessGame has three instance variables for the three Player objects.
If a player is right, then set that player’s variable to be true (remember, we set it false by default)
Output (it will be different each time you run it)
Java takes out the Garbage Each time an object is created in Java, it goes into an area of.
When you create an object,    Java allocates memory space on the heap according to how much that particular object needs.
An object with, say, 15 instance variables, will probably need more space than an object with only two instance variables.
But what happens when you need to reclaim that space? How do you get an object out of the heap when you’re done with it? Java manages that memory for you! When the JVM can ‘see’ that an object can never be used again, that object becomes eligible for garbage collection.
And if you’re running low on memory, the Garbage Collector will run, throw out the unreachable objects, and free up the space, so that the space can be reused.
In later chapters you’ll learn more about how this works.
A: There isn’t a concept of ‘global’ variables and methods in a Java OO program.
In practical use, however, there are times when you want a method (or a constant) to be available to any code running in any part of your program.
Think of the random() method in the Phrase-O-Matic app; it’s a method that should be   callable from anywhere.
Any code, in any class of your application, can access a public static method.
And if you mark a variable as public, static, and ﬁ nal – you have essentially made a globally-available constant.
Q: Then how is this objectoriented if you can still make global functions and global data?
A: First of all, everything in Java goes in a class.
So the constant for pi and the method for random(), although both public and static, are defined within the Math class.
And you must keep in mind that these static (global-like) things are the exception rather than the rule in Java.
They represent a very special case, where you don’t have multiple instances/objects.
Q: What is a Java program? What do you actually deliver?
A: A Java program is a pile of classes (or at least one class)
In a Java application, one of the classes must have a main method, used to start-up the program.
So as a programmer, you write one or more classes.
If the end-user doesn’t have a JVM, then you’ll also need to include that with your application’s classes, so that they can run your program.
There are a number of installer programs that let you bundle your classes with a variety of JVM’s (say, for different platforms), and put it all on a CD-ROM.
Q: What if I have a hundred classes? Or a thousand? Isn’t that a big pain to deliver all those individual ﬁ les? Can I bundle them into one Application Thing?
A: Yes, it would be a big pain to deliver a huge bunch of individual files to your end-users, but you won’t have to.
You can put all of your application files into a Java Archive – a .jar file that’s based on the pkzip format.
In the jar file, you can include a simple text file formatted as something called a manifest, that defines which class in that jar holds the main() method that should run.
Each of the Java files on this page represents a complete source file.
A Java program is all scrambled up on the fridge.
Can you reconstruct the code snippets to make a working Java program that produces the output listed below?  Some of the curly braces fell on the floor and they were too small to pick up, so feel free to add as  many of those as you need.
Pool Puzzle Your job is to take code snippets from.
You may use the same snippet more than once, and you won’t need to use all the snippets.
Note:  Each snippet from the pool can be used more than once!
My instance variable values can be different from my buddy’s values.
A bunch of Java components, in full costume, are playing a party game, “Who am I?”  They give you a clue, and you try to guess who they are, based on what they say.
If they happen to say something that could be true for more than one of them,  choose all for whom that sentence can apply.
Fill in the blanks next to the sentence with the names of one or more attendees.
My instance variable values can be different from my buddy’s values.
Note: both classes and objects are said to have state and behavior.
They’re deﬁned in the class, but the object is also said to ‘have’ them.
So far you’ve used variables in two places—as object state (instance variables), and as local variables.
You’ve seen variables declared as simple primitive integer values (type int)
What if you have a PetOwner object with a Dog.
It won’t let you do something bizarre and dangerous like stuff a Giraffe reference into a Rabbit variable—what happens when someone tries to ask the so-called Rabbit to hop()?  And it won’t let you put a ﬂoating point number into an integer variable, unless you acknowledge to the compiler that you know you might lose precision (like, everything after the decimal point)
For all this type-safety to work, you must declare the type of your variable.
Is it an integer? a Dog? A single character? Variables come in two ﬂavors: primitive and object reference.
Primitives hold fundamental values (think: simple bit patterns) including integers, booleans, and ﬂoating point numbers.
We’ll look at primitives ﬁrst and then move on to what an object reference really means.
But regardless of the type, you must follow two declaration rules:
Besides a type, a variable needs a name, so that you can use that name in code.
Note:  When you see a statement like:  “an object of type X”, think of type and class as synonyms.
Coffee cups, tea cups, giant cups that hold lots and lots of beer, those big cups the popcorn comes in at the movies, cups with curvy, sexy handles, and cups with metallic trim that you learned can never, ever go in the microwave.
In this chapter, we’re going to look ﬁrst at the variables (cups) that hold primitives, then a little later we’ll look at cups that hold references to objects.
Stay with us here on the whole cup analogy—as simple as it is right now, it’ll give us a common way to look at things when the discussion gets more complex.
Primitives are like the cups they have at the coffeehouse.
If you’ve been to a Starbucks, you know what we’re talking about here.
You might see the cups displayed on the counter, so you can order appropriately:
And in Java, primitives come in different sizes, and those sizes have names.
The four containers here are for the four integer primitives in Java.
Each cup holds a value, so for Java primitives, rather than saying, “I’d like a tall french roast”, you say to the compiler, “I’d like an int variable with the number 90 please.” Except for one tiny difference...
So it’s actually, “I’d like an int please, with the value of 2486, and name the variable height.” Each primitive variable has a ﬁxed number of bits (cup size)
The sizes for the six numeric primitives in Java are shown below:
You can’t put a large value into a small cup.
The compiler tries to help prevent this if it can tell from your code that something’s not going to ﬁt in the container (variable/cup) you’re using.
For example, you can’t pour an int-full of stuff into a byte-sized container, as follows:
You know that, and we know that, but all the compiler cares about is that you’re trying to put a big thing into a small thing, and there’s the possibility of spilling.
Don’t expect the compiler to know what the value of x is, even if  you happen to be able to see it literally in your code.
You can assign a value to a variable in one of several ways including:
The compiler won’t let you put a value from a large cup into a small one.
But what about the other way—pouring a small cup into a big one? No problem.
Based on what you know about the size and type of the primitive variables, see if you can figure out which of these are legal and which aren’t.
We haven’t covered all the rules yet, so on some of these you’ll have to use your best judgment.
Tip: The compiler always errs on the side of safety.
From the following list, Circle the statements that would be legal if these lines were in a single method:
Back away from that keyword! You know you need a name and a type for your variables.
But what can you use as names? The rules are simple.
You can name a class, method, or variable according to the following rules (the real rules are slightly more ﬂ exible, but these will keep you safe):
After the ﬁ rst character, you can use numbers as well.
It can be anything you like, subject to those two rules, just so long as it isn’t one of Java’s reserved words.
You’ve already seen some reserved words when we looked at writing our ﬁ rst main class:
But there are a lot more we haven’t discussed yet.
Even if you don’t need to know what they mean, you still need to know you can’t use ‘em yourself.
To make room for these in your head, you’d probably have to lose something else.
Don’t worry, by the end of the book you’ll have most of them down cold.
Java’s keywords and other reserved words (in no useful order)
If you use these for names, the compiler will be very, very upset.
No matter what you hear, do not, I repeat, do not let me ingest.
Controlling your Dog object You know how to declare a primitive variable and assign it a value.
But now what about non-primitive variables? In other words, what about objects?
There is actually no such thing as an object variable.
It doesn’t hold the object itself, but it holds something like a pointer.
Except, in Java we don’t really know what is inside a reference variable.
We do know that whatever it is, it represents one and only one object.
And the JVM knows how to use the reference to get to the object.
There aren’t giant expandable cups that can grow to the size of any object.
Although a primitive variable is full of bits representing the actual value of the variable, an object reference variable is full of bits representing a way to get to the object.
The Dog object itself does not go into the variable!
Unless you’re cozy with someone on the JVM’s development team, you don’t know how a reference is represented.
There are pointers in there somewhere, but you can’t access them.
OK, if you insist, you might as well just imagine it to be a 64-bit value.
But when you’re talking about memory allocation issues, your Big Concern should be about how many objects (as opposed to object references) you’re creating, and how big they (the objects) really are.
Q:So, does that mean that all object references are the same size, regardless of the size of the actual objects to which they refer?
All references for a given JVM will be the same size regardless of the objects they reference, but each JVM might have a different way of representing references, so references on one JVM may be smaller or larger than references on another JVM.
Q:Can I do arithmetic on a reference variable, increment it, you know – C stuff?
HeadFirst: So, tell us, what’s life like for an object reference?
I’m a remote control and I can be programmed to control different objects.
HeadFirst: Do you mean different objects even while you’re running? Like, can you refer to a Dog and then ﬁve minutes later refer to a Car?
If  I’m a Dog remote control then I’ll never be able to point (oops – my bad, we’re not supposed to say point) I mean refer to anything but a Dog.
HeadFirst: Does that mean you can refer to only one Dog?
I can be referring to one Dog, and then ﬁve minutes later I can refer to some other Dog.
As long as it’s a Dog, I can be redirected (like reprogramming your remote to a different TV) to it.
Reference: I don’t think you want to get into this now, but I’ll just give you the short version – if  I’m marked as ﬁnal, then once I am assigned a Dog, I can never be reprogrammed to anything else but that one and only Dog.
In other words, no other object can be assigned to me.
HeadFirst: You’re right, we don’t want to talk about that now.
OK, so unless you’re ﬁnal, then you can refer to one Dog and then refer to a different Dog later.
Can you ever refer to nothing at all? Is it possible to not be programmed to anything?
Reference: Yes, but it disturbs me to talk about it.
Reference: Because it means I’m null, and that’s upsetting to me.
I’m still a remote control, but it’s like you brought home a new universal remote control and you don’t have a TV.
They can press my buttons all day long, but nothing good happens.
If  I am the only reference to a particular object, and then I’m set to null (deprogrammed), it means that now nobody can get to that object I had been referring to.
Reference: You have to ask? Here I’ve developed a relationship with this object, an intimate connection, and then the tie is suddenly, cruelly, severed.
And I will never see that object again, because now it’s eligible for [producer, cue tragic music] garbage collection.
Why, why can’t I be a primitive? I hate being a reference.
The two Book objects are now living on the heap.
Rather than creating a new, third Book object, assign the value of variable c to variable d.
But what does this mean? It’s like saying, “Take the bits in c, make a copy of them, and stick that copy into d.”
The c and d variables hold two different copies of the same value.
The bits inside variable b are copied, and that new copy is stuffed into variable c.
The two book objects are now living on the heap.
The bits inside variable c are copied, and that new copy is stuffed into variable b.
Object 1 is abandoned and eligible for Garbage Collection (GC)
The first object that b referenced, Object 1, has no more references.
This makes c a null reference, meaning it doesn’t refer to anything.
But it’s still a reference variable, and another Book object can still be assigned to it.
Object 2 still has an active reference (b), and as long as it does, the object is not eligible for GC.
Arrays are objects too The Java standard library includes lots of sophisticated data structures including maps, trees, and sets (see Appendix B), but arrays are great when you just want a quick, ordered, efﬁcient list of things.
Arrays give you fast random access by letting you use an index position to get to any element in the array.
In other words, one of the eight primitive variable types (think: Large Furry Dog) or a.
Anything you would put in a variable of that type can be assigned to an array element of that type.
So in an array of type int  (int[]), each element can hold an int.
So in a Dog array, each element can hold a remote control to a Dog.
Of course, we still have to make the Dog objects...
Be sure to notice one key thing in the picture above – the array is an object, even though it’s an array of primitives.
Arrays are always objects, whether they’re declared to hold primitives or object references.
But you can have an array object that’s declared to hold primitive values.
In other words, the array object can have elements which are primitives, but the array itself is never a primitive.
Regardless of what the array holds, the array itself is always an object!
An array variable is a remote control to an array object.
Create a new int array with a length of 7, and assign it to the previouslydeclared int[] variable nums.
Remember, elements in an int array are just int variables.
Notice that the array itself is an object, even though the 7 elements are primitives.
Create new Dog objects, and assign them to the array elements.
Remember, elements in a Dog array are just Dog reference variables.
What’s missing? Dogs! We  have an array of Dog references, but no actual Dog objects!
What code would make pets[3] refer to one of the two existing Dog objects?
StringWe created a Dog object and used the dot operator on the reference variable ﬁ do to access the name variable.*
We can use the ﬁ do reference to get the dog to bark() or eat() or chaseCat()
What happens if the Dog is in a Dog array? We know we can access the Dog’s instance variables and methods using the dot operator, but on what?
When the Dog is in an array, we don’t have an actual variable name (like ﬁ do)
Instead we use array notation and push the remote control button (dot operator) on an object at a particular index (position) in the array:
Yes we know we’re not demonstrating encapsulation here, but we’re trying to keep it simple.
For example, you ca n’t put a Cat into a D.
There is no such thing as a primitive array, only an array that holds primitives.
Each of the Java files on this page represents a complete source file.
Your job is to play compiler and determine whether each of these files.
A working Java program is all scrambled up on the fridge.
Can you reconstruct the code snippets to make a working Java program that produces the output listed below? Some of the curly braces fell on the floor and they were too small to pick up, so feel free to add as many of those  as you need!
Pool Puzzle Your job is to take code snippets from.
You may use the same snippet more than once, and you won’t need to use all the snippets.
Bonus Question! For extra bonus points, use snippets from the pool to fill in the missing output (above)
When ‘// do stuff ’ is reached, some objects and some reference variables will have been created.
Your task is to determine which of the reference variables refer to which objects.
Not all the reference variables will be used, and some objects might be referred to more than once.
Draw lines connecting the reference variables with their matching objects.
Use a pencil so you can draw and then erase reference links (the arrows going from a reference remote control to an object)
Tawny strolled into the programmers’ bullpen like she owned the place.
She knew that all the programmers would still be hard at work, and she wanted help.
She needed a new method added to the pivotal class that was to be loaded into the client’s new top-secret Java-enabled cell phone.
Heap space in the cell phone’s memory was as tight as Tawny’s top, and everyone knew it.
The normally raucous buzz in the bullpen fell to silence as Tawny eased her way to the white board.
She sketched a quick overview of the new method’s functionality and slowly scanned the room.
Whoever creates the most memory efﬁcient version of this method is coming with me to the client’s launch party on Maui tomorrow...
The next morning Tawny glided into the bullpen wearing her short Aloha dress.
Bob went ﬁrst; as he began to sketch his design on the white board Tawny said, “Let’s get to the point Bob, show me how you handled updating the list of contact objects.”  Bob quickly drew a code fragment on the board:
Kent was next, already imagining coconut cocktails with Tawny, “Bob,” he said, “your solution’s a bit kludgy don’t you think?” Kent smirked, “Take a look at this baby”:
Why did Tawny choose Bob’s method over Kent’s, when Kent’s used less memory?
Tawny could see that Kent’s method had a serious ﬂ aw.
It’s true that he didn’t use as many reference variables as Bob, but there was no way to access any but the last of the Contact objects that his method created.
With each trip through the loop, he was assigning a new object to the one reference variable, so the previously referenced object was abandoned on the heap – unreachable.
Without access to nine of the ten objects created, Kent’s method was useless.
The software was a huge success and the client gave Tawny and Bob an extra week in Hawaii.
We’d like to tell you that by finishing this book you too will get stuff like that.
We know that objects have state and behavior, represented by instance variables and methods.
Dog A can have a name “Fido” and a weight of 70 pounds.
And if the Dog class has a method makeNoise(), well, don’t you think a 70-pound dog barks a.
Fortunately, that’s the whole point of an object—it has behavior that acts on its state.
When you write a class, you’re describing how the JVM should make an object of that type.
You already know that every object of that type can have different instance variable values.
Can every object of that type have different method behavior? Well...
Every instance of a particular class has the same methods, but the methods can behave differently based on the value of the instance variables.
The Song class has two instance variables, title and artist.
The play() method plays a song, but the instance you call play() on will play the song represented by the value of the title instance variable for that instance.
So, if you call the play() method on one instance you’ll hear the song “Politik”, while another instance plays “Darkstar”
Remember: a class describes what an object knows and what an object does.
Calling play() on this instance will cause “My Way” to play.
The size affects the bark A small Dog’s bark is different from a big Dog’s bark.
The Dog class has an instance variable size, that the bark() method uses to decide what kind of bark    sound to make.
You can send things to a method Just as you expect from any programming language, you can pass values into your methods.
You might, for example, want to tell a Dog object how many times to bark by calling:
Depending on your programming background and personal  preferences, you might use the term arguments or perhaps parameters for the values passed into a method.
Although there are formal computer science distinctions that people who wear lab coats and who will almost certainly not read this book, make, we have bigger ﬁ sh to fry in this book.
An argument (a value like 2, “Foo”, or a reference to a Dog) lands face-down into a...
And a parameter is nothing more than a local variable.
A variable with a type and a name,   that can be used inside the body of the method.
But here’s the important part: If a method takes a parameter, you must pass it something.
And that something must be a value of the appropriate type.
Call the bark method on the Dog refer-ence, and pass in the value 3 (as the argument to the method)
The bits representing the int value 3 are delivered into the bark method.
The bits land in the numOfBarks parameter (an int-sized variable)
Use the numOfBarks parameter as a variable in the method code.
Every method is declared with a return type, but until now we’ve made all of our methods with a void return type, which means they don’t give anything back.
But we can declare a method to give a speciﬁc type of value back to the caller, such as:
Whatever you say you’ll give back, you better give back!
The compiler won’t let you return the wrong type of thing.
The arguments you pass land in the same order you passed them.
First argument lands in the first parameter, second argument in the second parameter, and so on.
You can send more than one thing to a method Methods can have multiple parameters.
Separate them with commas when you declare them, and separate the arguments with commas when you pass them.
Most importantly, if a method has parameters, you must pass arguments of the right type and order.
Calling a t wo-parameter method, and sending it t wo arguments.
You can pass variables into a method, as long as the variable type matches the parameter type.
The bit pattern for 7 goes into the variable named x.
Call the go() method, passing the variable x as the argument.
The bits in x are copied, and the copy lands in z.
The value of x doesn’t change! The argument passed to the z parameter was only a copy of x.
The method can’t change the bits that were in the calling variable x.
Q:What happens if the argument you want to pass is an object instead of a primitive?
A:You’ll learn more about this in later chapters, but you already know the answer.
And remember, you don’t stuff objects into variables; the variable is a remote control—a reference to an object.
So if you pass a reference to an object into a method, you’re passing a copy of the remote control.
Stay tuned, though, we’ll have lots more to say about this.
Q:Can a method declare multiple return values? Or is there some way to return more than one value?
Stuff those ints into the array, and pass it on back.
It’s a little more involved to return multiple values with different types; we’ll be talking about that in a later chapter when we talk about ArrayList.
Q:Do I have to return the exact type I declared? A:You can return anything that can be implicitly promoted to that type.
So, you can pass a byte where an int is expected.
The caller won’t care, because the byte fits just fine into the int the caller will use for assigning the result.
You must  use an explicit cast when the declared type is smaller than what you’re trying to return.
Q:Do I have to do something with the return value of a method? Can I just ignore it?
You might want to call a method with a non-void return type, even though you don’t care about the return value.
In this case, you’re calling the method for the work it does inside the method, rather than for what the method gives returns.
In Java, you don’t have to assign or use the return value.
There are other things you can pass as arguments, but we’re not there yet.
A void return type means the method doesn’t return anything.
You can’t return a Giraffe when the return type is declared as a Rabbit.
You can’t pass a Giraffe into a method that takes a Rabbit.
Cool things you can do with parameters and return types Now that we’ve seen how parameters and return types work, it’s time to put them to good use: Getters and Setters.
If you’re into being all formal about it, you might prefer to call them Accessors and Mutators.
Besides, Getters and Setters ﬁ ts the Java naming convention, so that’s what we’ll call them.
Getters and Setters let you, well, get and set things.
A Getter’s sole purpose in life is to send back, as a return value, the value of whatever it is that particular Getter is supposed to be Getting.
And by now, it’s probably no surprise that a Setter lives and breathes for the chance to take an argument value and use it to set the value of an instance variable.
Until this most important moment, we’ve been committing one of the worst OO faux pas (and we’re not talking minor violation like showing up without the ‘B’ in BYOB)
Here we are, just humming along without a care in the world leaving our data out there for anyone to see and even touch.
You may have already experienced that vaguely unsettling feeling that comes with leaving your instance variables exposed.
Think about this idea of using our remote control to make a direct change to the Cat object’s size instance variable.
In the hands of the wrong person, a reference variable (remote control) is quite a dangerous weapon.
We need to build setter methods for all the instance variables, and ﬁnd a way to force other code to call the setters rather than access the data directly.
We put in checks to guarantee a minimum cat height.
Hide the data Yes it is that simple to go from an implementation that’s just begging for bad data to one that protects your data and protects your right to modify your implementation later.
OK, so how exactly do you hide the data? With the public and private access modiﬁers.
You’re familiar with public–we use it with every main method.
Here’s an encapsulation starter rule of thumb (all standard disclaimers about rules of thumb are in effect): mark your instance variables private and provide public getters and setters for access control.
When you have more design and coding savvy in Java, you will probably do things a little differently, but for now, this approach will keep you safe.
Object: OK, you know that dream where you’re giving a talk to 500 people when you suddenly realize– you’re naked?
It’s right up there with the one about the Pilates machine and...
But other than being a little exposed, is there any danger?
Object: Is there any danger? Is there any danger? [starts laughing] Hey, did all you other instances hear that, “Is there any danger?” he asks? [falls on the ﬂoor laughing]
HeadFirst: What’s funny about that? Seems like a reasonable question.
Object: Encapsulation puts a force-ﬁeld around my instance variables, so nobody can set them to, let’s say, something inappropriate.
Most instance variable values are coded with certain assumptions about the boundaries of  the values.
Like, think of  all the things that would break if  negative numbers were allowed.
Object: By forcing other code to go through setter methods.
That way, the setter method can validate the parameter and decide if  it’s do-able.
Maybe the method will reject it and do nothing, or maybe it’ll throw an Exception (like if  it’s a null social security number for a credit card application), or maybe the method will round the parameter sent in to the nearest acceptable value.
The point is, you can do whatever you want in the setter method, whereas you can’t do anything if  your instance variables are public.
HeadFirst: But sometimes I see setter methods that simply set the value without checking anything.
If  you have an instance variable that doesn’t have a boundary, doesn’t that setter method create unnecessary overhead? A performance  hit?
Object: The point to setters (and getters, too) is that you can change your mind later, without breaking anybody else’s code! Imagine if  half  the people in your company used your class with public instance variables, and one day you suddenly realized, “Oops– there’s something I didn’t plan for with that value, I’m going to have to switch to a setter method.” You break everyone’s code.
The cool thing about encapsulation is that you get to change your mind.
The performance gain from using variables directly is so miniscule and would rarely—if  ever— be worth it.
Any place where a particular value can be used, a method call that returns that type can be used.
Create two new Dog objects, and assign them to the ﬁrst two array elements.
Declare and create a Dog array, to hold 7 Dog references.
Let’s try calling methods on Dog objects in an array.
You already know that a variable declaration needs at least a name and a type:
And you know that you can initialize (assign a value) to the variable at the same time:
But when you don’t initialize an instance variable, what happens when you call a getter method? In other words, what is the value of an instance variable before you initialize it?
Instance variables are declared inside a class but not within a method.
Local variables do NOT get a default value! The compiler complains if you try to use a local variable before the variable is initialized.
Q: What about method parameters? How do the rules about local variables apply to them?
A: Method parameters are virtually the same as local variables—they’re declared inside the method (well, technically they’re declared in the argument list of the method rather than within the body of the method, but they’re still local variables as opposed to instance variables)
But method parameters will never be uninitialized, so you’ll never get a compiler error telling you that a parameter variable might not have been initialized.
But that’s because the compiler will give you an error if you try to invoke a method without sending arguments that the method needs.
So parameters are ALWAYS initialized, because the compiler guarantees that methods are always called with arguments that match the parameters declared for the method, and the arguments are assigned (automatically) to the parameters.
Sometimes you want to know if two primitives are the same.
Sometimes you want to know if two reference variables refer to a single object on the heap.
But sometimes you want to know if two objects are equal.
The idea of equality for objects depends on the type of object.
For example, if two different String objects have the same characters (say, “expeditious”), they are meaningfully equivalent, regardless of whether they are two distinct objects on the heap.
But what about a Dog? Do you want to treat two Dogs as being equal if they happen to have the same size and weight? Probably not.
So whether two different objects should be treated as equal depends on what makes sense for that particular object type.
We’ll explore the notion of object equality again in later chapters (and appendix B), but for now, we need to understand that the == operator is used only to compare the bits in two variables.
The == operator can be used to compare two variables of any kind, and it simply compares the bits.
To see if two references are the same (which means they refer to the same object on the heap) use the == operator.
Remember, the == operator cares only about the pattern of bits in the variable.
The rules are the same whether the variable is a reference or primitive.
So the == operator returns true if two reference variables refer to the same object! In that case, we don’t know what the bit pattern is (because it’s dependent on the JVM, and hidden from us) but we do know that whatever it looks like, it will be the same for two references to a single object.
Use == to compare two primitives, or to see if two references refer to the same object.
Use the equals() method to see if two different objects are equal.
What’s legal? Given the method below, which of the method calls  listed on the right are legal?
Put a checkmark next to the ones that are legal.
Each of the Java files on this page represents a complete source file.
Your job is to play compiler and determine whether each of these files.
If they won’t compile, how would you fix them, and if they do compile, what would be.
A bunch of Java components, in full costume, are playing a party game, “Who am I?”  They give you a clue, and you try to guess who they are, based on what they say.
If they happen to say something that could be true for more than one guy, then write down all for whom that sentence applies.
Fill in the blanks next to the sentence with the names of one or more attendees.
Your challenge is to match the candidate blocks of code (below), with the output that you’d see if the blocks were inserted.
Not all the lines of output will be used, and some of the lines of output might be used more than once.
Draw lines connecting the candidate blocks of code with their matching command-line output.
Pool Puzzle Your job is to take code snippets from the pool and place them into the blank lines.
You may not use the same snippet more than once, and you won’t need to use all the snippets.
Your goal is to make a class that will compile and.
Note:  Each snippet from the pool can be used only once!
When Buchanan jammed his twitch-gun into Jai’s side, Jai froze.
Jai knew that Buchanan was as stupid as he was ugly and he didn’t want to spook the big guy.
Buchanan ordered Jai into his boss’s ofﬁce, but Jai’d done nothing wrong, (lately), so he ﬁgured a little chat with Buchanan’s boss Leveler couldn’t be too bad.
He’d been moving lots of neural-stimmers in the west side lately and he ﬁgured Leveler would be pleased.
Black market stimmers weren’t the best money pump around, but they were pretty harmless.
Most of the stim-junkies he’d seen tapped out after a while and got back to life, maybe just a little less focused than before.
Leveler’s ‘ofﬁce’ was a skungy looking skimmer, but once Buchanan shoved him in, Jai could see that it’d been modiﬁed to provide all the extra speed and armor that a local boss like Leveler could hope for.
Jai winced involuntarily, he’d been a top drawer jack-hacker in his day.
Anytime someone ﬁgured out how to break a street-jack’s security, unwanted attention turned toward Jai.
No way it’s me man”, said Jai, “not worth the downside.
Yeah, yeah”, laughed Leveler, “I’m sure you’re clean on this one, but I’ll be losing big margins until this new jack-hacker is shut.
Trouble is, some stim-junkie’s stayed straight long enough to ﬁgure out how to hack into my WareHousing database.”  “I need a quick thinker like yourself Jai, to take a look at my StimDrop J37NE class; methods, instance variables, the whole enchilada, and ﬁgure out how they’re getting in.
It should..”,  “HEY!”, exclaimed Buchanan, “I don’t want no scum hacker like Jai nosin’ around my code!”  “Easy big guy”, Jai saw his chance, “I’m sure you did a top rate job with your access modi..
Don’t tell me - bit twiddler!”, shouted Buchanan, “I left all of those junkie level methods public, so they could access the drop site data, but I marked all the critical WareHousing methods private.
Buchanan reached for his twitch-gun but Leveler’s stunner was already on Buchanan’s neck, “Let it go Buchanan”, sneered Leveler, “Drop the twitcher and step outside, I think Jai and I have some plans to make”
Will he get out of Leveler’s skimmer with all his bones intact?
Remember Java is pass by value, (which means pass by copy), the variable ‘orig’ is not changed by the go( ) method.
Jai knew that Buchanan wasn’t the sharpest pencil in the box.
When Jai heard Buchanan talk about his code, Buchanan never mentioned his instance variables.
Jai suspected that while Buchanan did in fact handle his methods correctly, he failed to mark his instance variables private.
We dabbled with variables, played with a few objects, and wrote a little code.
We need loops, but what’s with the wimpy while loops? We need for loops.
That’s a heavy-lifting task, so it’ll take two chapters to finish.
Let’s build a Battleship-style game:  “Sink a Dot Com” It’s you against the computer, but unlike the real Battleship game, in this one you don’t place any ships of your own.
Instead, your job is to sink the computer’s ships in the fewest number of guesses.
Goal: Sink all of the computer’s Dot Coms in the fewest number of guesses.
You’re given a rating or level, based on how well you perform.
When that’s complete, the game asks for your ﬁ rst guess.
How you play: We haven’t learned to build a GUI yet, so this version works at the command-line.
In response to your guess, you’ll see a result at the commandline, either “Hit”, “Miss”, or “You sunk Pets.com” (or whatever the lucky Dot Com of the day is)
When you’ve sent all three Dot Coms to that big 404 in the sky, the game ends by printing out your rating.
First, a high-level design We know we’ll need classes and methods, but what should they be? To answer that, we need more information about what the game should do.
First, we need to ﬁgure out the general ﬂow of the game.
Repeat the following until there are no more Dot Coms:
Game places the three Dot Coms onto a virtual grid.
Give the user a rating based on the number of guesses.
Now we have an idea of the kinds of things the program needs to do.
The next step is ﬁguring out what kind of objects we’ll need to do the work.
Remember, think like Brad rather than Larry; focus ﬁrst on the things in the program rather than the procedures.
The “Simple Dot Com Game” a gentler introduction It looks like we’re gonna need at least two classes, a Game class and a DotCom class.
But before we build the full monty Sink a Dot Com game, we’ll start with a stripped-down, simpliﬁ ed version, Simple Dot Com Game.
We’ll build the simple version in this chapter, followed by the deluxe version that we build in the next chapter.
Instead of a 2-D grid, we hide the Dot Com in just a single row.
The goal is the same, though, so the game still needs to make a DotCom instance, assign it a location somewhere in the row, get user input, and when all of the DotCom’s cells have been hit, the game is over.
This simpliﬁ ed version of the game gives us a big head start on building the full game.
If we can get this small one working, we can scale it up to the more complex one later.
In this simple version, the game class has no instance variables, and all the game code is in the main() method.
In other words, when the program is launched and main() begins to run, it will make the one and only DotCom instance, pick a location for it (three consecutive cells on the single virtual seven-cell row), ask the user for a guess, check the guess, and repeat until all three cells have been hit.
In other words, it doesn’t exist anywhere in the program.
As long as both the game and the user know that the DotCom is hidden in three consecutive cells out of a possible seven (starting at zero), the row itself doesn’t have to be represented in code.
You might be tempted to build an array of seven ints and then assign the DotCom to three of the seven elements in the array, but you don’t need to.
All we need is an array that holds just the three cells the DotCom occupies.
Game starts, and creates ONE DotCom and gives it a location on three cells in the single row of seven cells.
Prompt user for a guess, then check to see if it hit any of the DotCom’s three cells.
Game ﬁ nishes when all three cells have been  hit (the numOfHits variable value is 3), and tells the  user how many guesses it took to sink the DotCom.
Developing a Class As a programmer, you probably have a methodology/ process/approach to writing code.
Our sequence is designed to help you see (and learn) what we’re thinking as we work through coding a class.
It isn’t necessarily the way we (or you) write code in the Real World.
In the Real World, of course, you’ll follow the approach your personal preferences, project, or employer dictate.
And when we create a Java class as a “learning experience”, we usually do it like this:
This is where we write real Java code.where we write real Java code.
This bar is displayed on the next set of pages to tell you which part you’re working on.
For example, if you see this picture at the top of a page, it means you’re working on prepcode for the SimpleDotCom class.
How would you decide which class or classes to build ﬁ rst, when you’re writing a program? Assuming that all but the tiniest programs need more than one class (if you’re following good OO principles and not having one class do many different jobs), where do  you start?
You’ll get the idea of how prepcode (our version of pseudocode) works as you read through this example.
It’s sort of half-way between real Java code and a plain English description of the class.
Most prepcode includes three parts: instance variable declarations, method declarations, method logic.
The most important part of prepcode is the method logic, because it deﬁ nes what has to happen, which we later translate into how, when we actually write the method code.
Writing the method implementations let’s write the real method code now, and get this puppy working.
Before we start coding the methods, though, let’s back up and write some code to test the methods.
That’s right, we’re writing the test code before there’s anything to test!
The concept of writing the test code ﬁ rst is one of the practices of Extreme Programming (XP), and it can make it easier (and faster) for you to write your code.
We’re not  necessarily saying you should use XP, but we do like the part about writing tests ﬁ rst.
Extreme Programming(XP) is a newcomer to the software development methodology world.
Considered by many to be “the way programmers really want to work”, XP emerged in the late 90’s and has been adopted by companies ranging from the two-person garage shop to the Ford Motor Company.
The thrust of XP is that the customer gets what he wants, when he wants it, even when the spec changes late in the game.
Don’t put in anything that’s not in the spec (no matter how tempted you are to put in functionality “for the future”)
Refactor (improve the code) whenever and wherever you notice the opportunity.
Program in pairs, and move people around so that everybody knows pretty much everything about the code.
We need to write test code that can make a SimpleDotCom object and run its methods.
For the SimpleDotCom class, we really care about only the checkYourself() method, although we will have to implement the setLocationCells() method in order to get the checkYourself() method to run correctly.
Then ask yourself, “If the checkYourself() method were implemented, what test code could I write that would prove to me the method is working correctly?”
Invoke the checkYourself() method passing it the fake user guess.
Print out the result to see if it’s correct (“passed” or “failed”)
Test code for the SimpleDotCom classthere are no Dumb Questions.
Q:Maybe I’m missing something here, but how exactly do you run a test on something that doesn’t yet exist!?
We never said you start by running the test; you start by writing the test.
Why not wait until the code is written, and then whip out the test code?
A:The act of thinking through (and writing) the test code helps clarify your thoughts about what the method itself needs to do.
As soon as your implementation code is done, you already have test code just waiting to validate it.
Besides, you know if you don’t do it now, you’ll never do it.
Ideally, write a little test code, then write only the implementation code you need in order to pass that test.
Then write a little more test code and write only the new implementation code needed to pass that new test.
At each test iteration, you run all the previously-written tests, so that you always prove that your latest code additions don’t break previously-tested code.
Sharpen your pencil In the next couple of pages we implement the SimpleDotCom class, and then later we return to the test class.
Looking at our test code above, what else should be added? What are we not testing in this code, that we should be testing for? Write your ideas (or lines of code) below:
There isn’t a perfect mapping from prepcode to javacode; you’ll see a few adjustments.
The prepcode gave us a much better idea of what the code needs to do, and now we have to ﬁ nd the Java code that can do the how.
In the back of your mind, be thinking about parts of this code you might want (or need) to improve.
The numbers         are for things (syntax and language features) you haven’t seen yet.
Just the new stuff The things we haven’t seen before are on this page.
Stop worrying! The rest of the details are at the end of the chapter.
A method in the Integer class that knows how to “parse” a String into the int it        represents.
Declare a variable that will hold one element from the array.
If you try to parse something like “two” or “blurp”, the code  will blow up at runtime.
By blow up, we actually mean throw an exception, but we don’t talk about exceptions until the Exceptions chapter.
Q:In the beginning of the book, there was an example of a for loop that was really different from this one—are there two different styles of for loops?
A:Yes! From the first version of Java there has been a single kind of for loop (explained later in this chapter) that looks like this:
You can use this format for any kind of loop you need.
You can always use the plain old for loop to iterate over an array, but the enhanced for loop makes it easier.
What should we see when we run this code? The test code makes a SimpleDotCom object and gives it a location at 2,3,4
Then it sends a fake user guess of “2” into the checkYouself() method.
If the code is working correctly, we should see the result print out:
Sharpen your pencil We built the test class, and the SimpleDotCom class.
Given the code on the opposite page, and the spec for the actual game, write in your ideas for prepcode for the game class.
We’ve given you a few lines  here and there to get you started.
The actual game code is on the next page, so don’t turn the page until you do this exercise!
Make a location for it (three consecutive cells on a single row of seven virtual cells)
Prepcode for the SimpleDotComGame class Everything happens in main() There are some things you’ll have to take on faith.
For example, we have one line of prepcode that says, “GET user input from command-line”
Let me tell you, that’s a little more than we want to implement from scratch right now.
And that means you get to ask some other class/object to do something for you, without worrying about how it does it.
When you write prepcode, you should assume that somehow you’ll be able to do whatever you need to do, so you can put all your brainpower into working out the logic.
Give each side of your brain a break by switching sides at regular intervals.
When you shift to one side, the other side gets to rest and recover.
Left-brain activities include things like step-by-step sequences, logical problem-solving, and analysis, while the right-brain kicks in for metaphors, creative problem-solving, pattern-matching, and visualizing.
Just as you did with the SimpleDotCom class, be thinking about parts of this code you might want (or need) to improve.
The numbered things         are for stuff we want to point out.
Oh, if you’re wondering why we skipped the test code phase for this class, we don’t need a test class for the game.
It has only one method, so what would you do in your test code? Make a separate class that would call main() on this class? We didn’t bother.
This is just a quick look to keep you going; more details on the GameHelper class are at the end of this chapter.
In this case, the cast lops off the   fractional part of the double.
We declare an int variable to hold the random number we get back.
An instance we made earlier, of a class that we built to help with the game.
It’s called GameHelper and you haven’t seen it yet (you will)
A method of the GameHelper class that asks the user for commandline input, reads it in after the user hits RETURN, and gives back the result as a String.
This method takes a String argument that it uses to prompt the user at the command-line.
Whatever you pass in here gets displayed in the terminal just before the method starts looking for user input.
All that’s left is the helper class— the one with the getUserInput() method.
The code to get commandline input is more than we want to explain right now.
It opens up way too many topics best left for later.
I pre-cooked some code so you don’t have to make.
Just copy* the code below and compile it into a class named GameHelper.
Drop all three classes (SimpleDotCom, SimpleDotComGame, GameHelper) into the same directory,  and make it your working directory.
Whenever you see the  logo, you’re seeing code that you have to type as-is and take on faith.
Let’s play Here’s what happens when we run it and enter the numbers 1,2,3,4,5,6
Stay tuned for the next chapter, where we answer these questions and more...
And in the meantime, see if you can come up with ideas for what went wrong and how to fix it.
Use this part to declare and initialize a variable to use within the loop body.
You can actually initialize more than one variable here, but we’ll get to that later in the book.
Whatever’s in there, it must resolve to a boolean value (you know, true or false)
In this part, put one or more things you want to happen with each trip through the loop.
Keep in mind that this stuff happens at the end of each loop.
More about for loops We’ve covered all the game code for this chapter (but we’ll pick it up again to ﬁnish the deluxe version of the game in the next chapter)
We didn’t want to interrupt your work with some of the details and background info, so we put it back here.
We’ll start with the details of for loops, and if you’re a C++ programmer, you can just skim these last few pages...
The shortcut for adding or subtracting 1 from a variable.
The placement of the operator (either before or after the variable) can affect the result.
Putting the operator before the variable (for example, ++x), means, “ﬁ rst, increment x by 1, and then use this new value of x.” This only matters when the ++x is part of some larger expression rather than just in a single statement.
But putting the ++ after the x give you a different result:
A while loop has only the boolean test; it doesn’t have a built-in  initialization or iteration      expression.
A while loop is good when you don’t know how many times to loop and just want to keep going while some condition is true.
The elements in the array MUST be compatible with the declared variable type.
What it means in plain English:  “For each element in nameArray, assign the element to the ‘name’ variable, and run the body of the loop.”
Create a String variable called name and set it to null.
Run the body of the loop (the code block bounded by curly braces)
Use this part to declare and initialize a variable to use within the loop body.
With each iteration of the loop, this variable will hold a different element from the collection.
The type of this variable must be compatible with the elements in the array! For example, you can’t declare an int iteration variable to use with a String[] array.
This must be a reference to an array or other collection.
Again, don’t worry about the other non-array kinds of collections yet—you’ll see them in the next chapter.
The enhanced for loop Beginning with Java 5.0 (Tiger), the Java language has a second kind of for loop called the enhanced for, that makes it easier to iterate over all the elements in an array or other kinds of collections (you’ll learn about other collections in the next chapter)
That’s really all that the enhanced for gives you—a simpler way to walk through all the elements in the collection, but since it’s the most common use of a for loop, it was worth adding it to the language.
We’ll revisit the enhanced for loop in the next chapter, when we talk about collections that aren’t arrays.
A long is bigger than an int and the compiler can’t be sure where that long has been.
It might have been out drinking with the other longs, and taking on really big values.
To force the compiler to jam the value of a bigger primitive variable into a smaller one, you can use the cast operator.
Putting in the cast tells the compiler to take the value of y, chop it down to int size, and set x equal to whatever is left.
If the value of y was bigger than the maximum value of x, then what’s left will be a weird (but calculable*) number:
Still, the point is that the compiler lets you do it.
And let’s say you have a floating point number, and you just want to get at the whole number (int) part of it:
And don’t even think about casting anything to a boolean or vice versa—just walk away.
It involves sign bits, binary, ‘two’s complement’ and other geekery, all of which are discussed at the beginning of appendix B.
The user types his guess at the commandline, when the game prompts him.
But the cell locations are simply ints in an array, and you can’t compare an int     to a String.
Trying to compile that makes the compiler laugh and mock you:
Built into the Java class library is a class called Integer (that’s right, an Integer class, not the int primitive), and one of its jobs is to take Strings that represent numbers and convert them into actual numbers.
The Java file on this page represents a complete source file.
Your job is to play JVM and determine what would be.
A working Java program is all scrambled up on the fridge.
Can you reconstruct the code snippets to make a working Java program that produces the output listed below?  Some of the curly braces fell on the floor and they were too small to pick up, so feel  free to add as many of those as you need!
JavaCross How does a crossword puzzle help you learn Java?  Well, all of the words are Java related.
In addition, the clues provide metaphors, puns, and the like.
These mental twists and turns burn alternate routes to Java knowledge, right into your brain!
Your challenge is to match the candidate block of code (on the left), with the output that you’d see if the block were inserted.
Not all the lines of output will be used, and some of the lines of output might be used more than once.
Draw lines connecting the candidate blocks of code with their matching command-line output.
You don’t have to reinvent the wheel if you know how to find what you need in the Java library, known as.
If you’re going to write code, you might as well.
The Ready-bake Java we use in this book is code you.
All you need to do is learn to use it.
In our last chapter, we lef t you with the cliff-hanger.
Here’s what happens when we run it and enter the numbers 1,2,3,4,5,6
In the current version, once you get a hit, you can simply repeat that hit two more times for the kill!
Compare the user guess to this element (cell), in the array.we got a hit!
Get out of the loop, no need to test the other cells.
Display the result for the user (“miss”, unless it was changed to “hit” or “kill”)
We counted a hit every time the user guessed a cell location, even if that location had already been hit!
We need a way to know that when a user makes a hit, he hasn’t previously hit that cell.
If he has, then we don’t want to count it as a hit.
A ‘true’ in a particular index in the array means that the cell location at that same index in the OTHER array (locationCells) has been hit.
We need a way to know whether a cell has already been hit.
Let’s run through some possibilities, but ﬁrst, we’ll look at what we know so far...
We have a virtual row of 7 cells, and a DotCom will occupy three consecutive cells somewhere in that row.
We could make a second array, and each time the user makes a hit, we store that hit in the second array, and then check that array each time we get a hit, to see if that cell has been hit before.
The virtual row, with the 3 cell locations for the DotCom object.
The DotCom has an instance variable—an int array—that holds that DotCom object’s cell locations.
The array instance variable that holds the DotCom’s cell locations.
This array holds three values representing the ‘state’ of each cell in the DotCom’s location cells array.
We could just keep the one original array, but change the value of any hit cells to -1
That way, we only have ONE array to check and manipulate.
Option one is too clunky Option one seems like more work than you’d expect.
It would work, but there’s got to be something better...
Option two is a little less clunky than option one, but it’s not very efﬁcient.
Option two is a little better, but still pretty clunky.
Life would be good if only we could change it to:
We delete each cell location as it gets hit, and then modify the array to be smaller.
Except arrays can’t change their size, so we have to make a new array and copy the remaining cells from the old array into the new smaller array.
When cell ‘5’ is hit, we make a new, smaller array with only the remain-ing cell locations, and assign it to the original locationCells reference.
Option three would be much better if the array could shrink, so that we wouldn’t have to make a new smaller array, copy the remaining values in, and reassign the reference.
If only I could ﬁnd an array that could shrink when you remove.
And one that you didn’t have to loop through to check each element, but instead you could just ask it if it contains what you’re looking for.
And it would let you get things out of it, without having to know.
As if by magic, there really is such a thing.
The Java Standard Edition (which is what you have unless you’re working on the Micro Edition for small devices and believe me, you’d know) ships with hundreds of pre-built classes.
Just like our Ready-Bake code except that these built-in classes are already compiled.
You can use it in your code as if you wrote it yourself.
Note: the add(Object elem) method actually looks a little stranger than the one we’ve shown here...
For now, just think of it as an add() method that takes the object you want to add.
The ArrayList grows again to hold the second Egg object.
Fill in the rest of the table below by looking at the ArrayList code on the left and putting in what you think the code might be if it were using a regular array instead.
We don’t expect you to get all of them exactly right, so just make your best guess.
Q:So ArrayList is cool, but how would I know it exists?
A:The question is really, “How do I know what’s in the API?”  and that’s the key to your success as a Java programmer.
Not to mention your key to being as lazy as possible while still managing to build software.
You might be amazed at how much time you can save when somebody else has already done most of the heavy lifting, and all you have to do is step in and create the fun part.
The long answer is at the end of this chapter, where you’ll learn how to do that.
By the time you’ve finished this book, you’ll have a good grasp of the language, and the rest of your learning curve really is about knowing how to get from a problem to a solution, with you writing the least amount of code.
If you can be patient for a few more pages, we start talking about it at the end of this chapter.
ArrayList: In their dreams! I am an object thank you very much.
They live on the heap right there with all the other objects.
ArrayList: Sure arrays go on the heap, duh, but an array is still a wanna-be ArrayList.
Objects have state and behavior, right? We’re clear on that.
But have you actually tried calling a method on an array?
HeadFirst: Now that you mention it, can’t say I have.
But what method would I call, anyway? I only care about calling methods on the stuff  I put in the array, not the array itself.
And I can use array syntax when I want to put things in and take things out of  the array.
ArrayList: Is that so? You mean to tell me you actually removed something from an array? (Sheesh, where do they train you guys? McJava’s?)
HeadFirst: Of  course I take something out of  the array.
ArrayList: Allright, I’ll try to speak slowly so you can follow along.
You were not, I repeat not, removing that Dog from the array.
All you did was make a copy of  the reference to the Dog and assign it to another Dog variable.
No I didn’t actually remove the Dog object from the array.
But I can just set its reference to null, I guess.
ArrayList: But I’m a ﬁrst-class object, so I have methods and I can actually, you know, do things like remove the Dog’s reference from myself, not just set it to null.
And I can change my size, dynamically (look it up)
HeadFirst: Gee, hate to bring this up, but the rumor is that you’re nothing more than a gloriﬁed but less-efﬁcient array.
That in fact you’re just a wrapper for an array, adding extra methods for things like resizing that I would have had to write myself.
And while we’re at it, you can’t even hold primitives! Isn’t that a big limitation?
ArrayList: I can’t believe you buy into that urban legend.
I will admit that there are a few extremely rare situations where an array might be just a tad, I repeat, tad bit faster for certain things.
But is it worth the miniscule performance gain to give up all this power.
And as for the primitives, of  course you can put a primtive in an ArrayList, as long as it’s wrapped in a primitive wrapper class (you’ll see a lot more on that in chapter 10)
And as of  Java 5.0, that wrapping (and unwrapping when you take the primitive out again) happens automatically.
And allright, I’ll acknowledge that yes, if  you’re using an ArrayList of  primitives, it probably is faster with an array, because of  all the wrapping and unwrapping, but still...
Notice how with ArrayList, you’re working with an object of type ArrayList, so you’re just invoking regular old methods on a regular old object, using the regular old dot operator.
With an array, you use special array syntax (like myList[0] = foo) that you won’t use anywhere else except with arrays.
Even though an array is an object, it lives in its own special world and you can’t invoke any methods on it, although you can access its one and only instance variable, length.
A plain old array has to know its size at the time it’s created.
But for ArrayList, you just make an object of type ArrayList.
It never needs to know how big it should be, because it grows and shrinks as objects are added or removed.
To put an object in a regular array, you must assign it to a speciﬁc location.
An index from 0 to one less than the length of the array.
With ArrayList, you can specify an index using the add(anInt, anObject) method, or you can just keep saying add(anObject) and the ArrayList will keep growing to make room for the new thing.
Arrays use array syntax that’s not used anywhere else in Java.
But ArrayLists are plain old Java objects, so they have no special syntax.
No size required (although you can give it a size if you want to)
We just said that unlike arrays, ArrayLists have no special syntax.
Prior to Java 5.0, there was no way to declare the type of things that would go in the ArrayList, so to the compiler, all ArrayLists were simply heterogenous collections of objects.
But now, using the <typeGoesHere> syntax, we can declare and create an ArrayList that knows (and restricts) the types of objects it can hold.
We’ll look at the details of parameterized types in ArrayLists in the Collections chapter, so for now, don’t think too much about the angle bracket <> syntax you see when we use ArrayLists.
Just know that it’s a way to force the compiler to allow only a speciﬁc type of object (the type in angle brackets) in the ArrayList.
We counted each guess as a hit, without checking whether that cell had already been hit.
Ignore this line for now; we talk about it at the end of the chapter.
Find out if the us er guess is in the.
If index is greater than or equal to zero, the user guess is definitely in the list, so remove it.
Let’s build the REAL game: “Sink a Dot Com” We’ve been working on the ‘simple’ version, but now let’s build the real one.
Goal: Sink all of the computer’s Dot Coms in the fewest number of guesses.
You’re given a rating level based on how well you perform.
When that’s complete, the game asks for your ﬁ rst guess.
How you play: We haven’t learned to build a GUI yet, so this version works at the command-line.
In response to your guess, you’ll see a result at the command-line, either “hit”, “miss”, or “You sunk Pets.com” (or whatever the lucky Dot Com of the day is)
When you’ve sent all three Dot Coms to that big 404 in the sky, the game ends by printing out your rating.
What needs to change? We have three classes that need to change: the DotCom class (which is now called DotCom instead of SimpleDotCom), the game class (DotComBust) and the game helper class (which we won’t worry about now)
Put the DotComs on a grid rather than just a single row, and do it for all three DotComs.
This step is now way more complex than before, if we’re going to place the DotComs randomly.
Since we’re not here to mess with the math, we put the algorithm for giving the DotComs a location into the GameHelper (Ready-bake) class.
Check each user guess with all three DotComs, instead of just one.
Keep playing the game (i.e accepting user guesses and checking them with the remaining DotComs) until there are no more live DotComs.
But that’s not what we want for the real game.
Makes DotComs, gets  user input, plays until all DotComs are dead.
DotComs know their name, location, and how to check a user guess for a match.
It knows how to accept user command-line input, and make DotCom locations.
Call a setter method on each DotCom instance, so that the DotCom can assign the name to its name instance variable.
The DotComBust (game) object instantiates an instance of GameHelper, the object that will help the game do its work.
The DotComBust object instantiates an ArrayList that will hold the 3 DotCom objects.
The DotComBust object creates three DotCom objects (and puts them in the ArrayList)
The DotComBust object asks the helper object for a location for a DotCom (does this 3 times, one for each DotCom)
Each DotCom object puts his own three location cells in an ArrayList.
The DotComBust object asks the helper object for a user guess (the helper prompts the user and gets input from the command-line)
The DotComBust object loops through the list of DotComs, and asks each one to check the user guess for a match.
The DotComBust class has three main jobs: set up the game, play the game until the DotComs are dead, and end the game.
Although we could map those three jobs directly into three methods, we split the middle job (play the game) into two methods, to keep the granularity smaller.
Smaller methods (meaning smaller chunks of functionality) help us test, debug, and modify the code more easily.
Sharpen your pencil How should we go from prep code to the final code? First we start with test code, and then test and build up our methods bit by bit.
We won’t keep showing you test code in this book, so now it’s up to you to think about what  you’d need to know to test these.
And which method do you test and write first? See if you can work out some prep code for a set of tests.
Prep code or even bullet points are good enough for this exercise, but if you want to try to write the real test code (in Java), knock yourself out.
Match the annotations at the bottom of each page with the numbers in the code.
Write the number in the slot in front of the corresponding annotation.
You’ll use each annotation just once, and you’ll need all of the annotations.
Ask the helper for a DotCom location (an ArrayList of Strings)
Call the setter method on this DotCom to give it the location you just got from the helper.
Using the isEmpty( ) method to see if all of the locations have been guessed.
Super Powerful Boolean Expressions So far, when we’ve used boolean expressions for our loops or if tests, they’ve been pretty simple.
We will be using more powerful boolean expressions in some of the Ready-Bake code you’re about to see, and even though we know you wouldn’t peek, we thought this would be a good time to discuss how to energize your expressions.
Let’s say that of the ten camera brands available, you have some logic that applies to only a few of the list:
If you want to get really technical, you might wonder about the precedence of these operators.
Instead of becoming an expert in the arcane world of precedence, we recommend that you use parentheses to make your code clear.
So if the JVM sees that the left side of a && expression is false, it stops right there!  Doesn’t even bother to look at the right side.
Similarly, with ||, the expression will be true if either side is true, so if the JVM sees that the left side is true, it declares the entire statement to be true and doesn’t bother to check the right side.
Why is this great?  Let’s say that you have a reference variable and you’re not sure whether it’s been assigned to an object.
Besides the user input method (that prompts the user and reads input from the command-line), the helper’s Big Service is to create the cell locations for the DotComs.
If we were you, we’d just back away slowly from this code, except to type it in and compile it.
We tried to keep it fairly small to you wouldn’t have to type so much, but that means it isn’t the most readable code.
And remember, you won’t be able to compile the DotComBust game class until you have this class.
To use a class in the API, you have to know which package the class is in.
Every class in the Java library belongs to a package.
The package has a name, like javax.swing (a package that holds some of the Swing GUI classes you’ll learn about soon)
ArrayList is in the package called java.util, which surprise surprise, holds a pile of utility classes.
You’ll learn a lot more about packages in chapter 16, including how to put your own classes into your own packages.
For now though, we’re just looking to use some of the classes that come with Java.
Using a class from the API, in your own code, is simple.
You just treat the class as though you wrote it yourself...
With one big difference: somewhere in your code you have to indicate the full name of the library class you want to use, and that means package name + class name.
Even if you didn’t know it, you’ve already been using classes from a package.
You made it all the way through the DotComBust game, thanks to the help of ArrayList.
And now, as promised, it’s time to learn how to fool around in the Java library.
You have to know the full name* of the class you want to use in your code.
ArrayList is not the full name of ArrayList, just as ‘Kathy’ isn’t a full name (unless it’s like Madonna or Cher, but we won’t go there)
You have to tell Java which ArrayList you want to use.
Put an import statement at the top of your source code ﬁle: A.
Q: Why does there have to be a full name? Is that the only purpose of a package?
First, they help the overall organization of a project or library.
Second, packages give you a namescoping, to help prevent collisions if you and 12 other programmers in your company all decide to make a class with the same name.
If you have a class named Set and someone else (including the Java API) has a class named Set, you need some way to tell the JVM which Set class you’re trying to use.
Third, packages provide a level of security, because you can restrict the code you write so that only other classes in the same package can access it.
How does a full name really help? What’s to prevent two people from giving a class the same package name?
A:Java has a naming convention that usually prevents this from happening, as long as developers adhere to it.
There was always java.lang, of course — the one you don’t have to import.
And there was  java.net, java.io, java.util (although there was no such thing as ArrayList way back then), and a few others, including the java.awt package that held GUI-related classes.
Looming on the horizon, though, were other packages not included in the standard library.
These classes were known as extensions, and came in two main flavors: standard, and not standard.
Standard extensions were those that Sun considered official, as opposed to experimental, early access, or beta packages that might or might not ever see the light of day.
Standard extensions, by convention, all began with an ‘x’ appended to the regular java package starter.
The mother of all standard extensions was the Swing library.
It included several packages, all of which began with javax.swing.
Trouble was lurking beneath the surface, however, because when packages get promoted, well of COURSE they have to start with java, not javax.
Everyone KNOWS that packages in the standard library don’t have that “x”, and that only extensions have the “x”
So, just (and we mean just) before version 1.2 went final, Sun changed the package names and deleted the “x” (among other changes)
Books were printed and in stores featuring Swing code with the new names.
Except the 20,000 or so screaming developers who realized that with that simple name change came disaster! All of their Swing-using code had to be changed! The horror!  Think of all those import statements that started with javax...
And in the final hour, desperate, as their hopes grew thin, the developers convinced Sun to “screw the convention, save our code”
So when you see a package in the library that begins with javax, you know it started life as an extension, and then got a promotion.
It grows when objects are added, and it shrinks when objects are removed.
Example: ArrayList<Button> means the ArrayList will be able to hold only objects of type Button (or subclasses of Button as you’ll learn in the next couple of chapters)
Roses are red, apples are ripe, if you don’t importyou’ll just have to type.
You must tell Java the full name of every class you use, unless that class is in the java.lang package.
An import statement for the class or package at the top of your source code is the easy way.
Otherwise, you have to type the full name of the class, everywhere you use it!
One more time, in the unlikely event that you don’t already have this down:
Q: Does import make my class bigger? Does it actually compile the imported class or package into my code?
A: Perhaps you’re a C programmer? An import is not       the same as an include.
Repeat after me: “an import statement saves you from typing.” That’s really it.
You don’t have to worry about your code becoming bloated, or slower, from too many imports.
An import is simply the way you give Java the full name of a class.
A: Remember, you get the java.lang package sort of “preimported” for free.
Because the classes in java.lang are so fundamental, you don’t have to use the full name.
Q:  Do I have to put my own classes into packages? How do I do that? Can I do that?
A: In the real world (which you should try to avoid), yes, you will want to put your classes into packages.
For now, we won’t put our code examples in a package.
Good to know there’s an ArrayList in the java.util package.
Once you ﬁ nd a class, how do you know what it can do?
Flipping through a reference book is the best way to ﬁ nd out what’s in the Java library.
You can easily stumble on a class that looks useful, just by browsing pages.
Scroll through the packages and select one (click it) to restrict the list in the lower frame to only classes from that package.
Java comes with a fabulous set of online docs called, strangely, the Java API.
If you have a high-speed internet connection, or tons of patience, you can also browse them at java.sun.com.
Trust us, you probably want these on your hard drive.
The API docs are the best reference for getting more details about a class and its methods.
Let’s say you were browsing through the reference book and found a class called Calendar, in java.util.
The book tells you a little about it, enough to know that this is indeed what you want to use, but you still need to know more about the methods.
The reference book, for example, tells you what the methods take, as arguments, and what they return.
In the reference book, you’ll ﬁ nd the method indexOf(), that we used in the DotCom class.
But if all you knew is that there is a method called indexOf() that takes an object and returns the index (an int) of that object, you still need to know one crucial thing: what happens if the object is not in the ArrayList? Looking at the method signature alone won’t tell you how that works.
But the API docs will (most of the time, anyway)
The API docs tell you that the indexOf() method returns a -1 if the object parameter is not in the ArrayList.
That’s how we knew we could use it both as a way to check if an object is even in the ArrayList, and to get its index at the same time, if the object was there.
But without the API docs, we might have thought that the  indexOf() method would blow up if the object wasn’t in the ArrayList.
Can you reconstruct the code snippets to make a working Java program that produces the output listed below? NOTE: To do this exercise, you need one NEW piece of info—if you look in the API for ArrayList, you’ll find a second add method that takes two arguments:
It lets you specify to the ArrayList where to put the object you’re adding.
How does this crossword puzzle help you learn Java?  Well, all of the words are Java related (except one red herring)
Write your OWN set of clues! Look at each word, and try to write your own clues.
Try making them easier, or harder, or more technical than the ones we have.
If there were a way to write Java code such that you could take more vacations, how much would it be worth to you? What.
For just three easy payments of 60 minutes time, you.
When you get on the Polymorphism Plan, you’ll learn the 5 steps to better class.
Start today, and we’ll throw in an extra level of abstraction!
Remember way back in chapter 2, when Larry (procedural guy) and Brad (OO guy) were vying for the Aeron chair? Let’s look at a few pieces of that story to review the basics of inheritance.
LARRY:  You’ve got duplicated code! The rotate procedure is in all four Shape things.
BRAD:  Oh, I guess you didn’t see the ﬁnal design.
So I abstracted out the common features and put them into a new class called Shape.
Then I linked the other four shape classes to the new Shape class, in a relationship called inheritance.
I looked at what all four classes have in common.
You can read this as, “Square inherits from Shape”, “Circle inherits from Shape”, and so on.
I removed rotate() and playSound() from the other shapes, so now there’s only one copy to maintain.
The Shape class is called the superclass of the other four classes.
In other words, if the Shape class has the functionality, then the subclasses automatically get that same functionality.
What about the Amoeba rotate()? LARRY:  Wasn’t that the whole problem here — that the amoeba shape had a completely different rotate and playSound procedure?
How can amoeba do something different if it inherits its functionality from the Shape class?
The Amoeba class overrides the methods of the Shape class.
Then at runtime, the JVM knows exactly which rotate() method to run when someone tells the Amoeba to rotate.
I made the Amoeba class override the rotate() method of the superclass Shape.
Overriding just means that a subclass redefines one of its inherited methods when it needs to change or extend the behavior of that method.
How would you represent a house cat and a tiger, in an inheritance structure.
Is a domestic cat a specialized version of a tiger? Which would be the subclass and which would be the superclass? Or are they both subclasses to some other class?
How would you design an inheritance structure? What methods would be overridden?
I made the Amoeba class override the rotate() and playSound() methods of the superclass Shape.
Overriding just means that a subclass redefines one of its inherited methods when it needs to change or extend the behavior of that method.
Understanding Inheritance When you design with inheritance, you put common code in a class and then tell other more specific classes that the common (more abstract) class is their superclass.
When one class inherits from another, the subclass inherits from the superclass.
In Java, we say that the subclass extends the superclass.
An inheritance relationship means that the subclass inherits the members of the superclass.
When we say “members of a class” we mean the instance variables and methods.
But the PantherMan subclass can add new methods and instance variables of its own, and it can override the methods it inherits from the superclass SuperHero.
FriedEggMan doesn’t need any behavior that’s unique, so he doesn’t override any methods.
PantherMan, though, has specific requirements for his suit and special powers, so useSpecialPower() and putOnSuit() are both overridden in the PantherMan class.
Instance variables are not overridden because they don’t need to be.
They don’t define any special behavior, so a subclass can give an inherited instance variable any value it chooses.
PantherMan can set his inherited tights to purple, while FriedEggMan sets his to white.
What do these six types have in common? This helps you to abstract out behaviors.
How are these types related? This helps you to deﬁne the inheritance tree relationships (step 4-5)
Let’s design the inheritance tree for an Animal simulation program Imagine you’re asked to design a simulation program that lets the user throw a bunch of different animals into an environment to see what happens.
We don’t have to code the thing now, we’re mostly interested in the design.
We’ve been given a list of some of the animals that will be in the program, but not all.
We know that each animal will be represented by an object, and that the objects will move around in the environment, doing whatever it is that each particular type is programmed to do.
And we want other programmers to be able to add new kinds of animals to the program at any time.
First we have to ﬁgure out the common, abstract characteristics that all animals have, and build those characteristics into a class that all animal classes can extend.
These objects are all animals, so we’ll make a common superclass called Animal.
We’ll put in methods and instance variables that all animals might need.
Design a class that represents the common state and behavior.
Right now, there can be only two values: meat or grass.
It changes depending on when (and how much) the animal eats.
Assume that we all agree on one thing: the instance variables will work for all Animal types.
A lion will have his own value for picture, food (we’re thinking meat), hunger, boundaries, and location.
A hippo will have different values for his instance variables, but he’ll still have the same variables that the other Animal types have.
Which methods should we override? Does a lion make the same noise as a dog? Does a cat eat like a hippo? Maybe in your version, but in ours, eating and making noise are Animal-typespeciﬁ c.
We can’t ﬁ gure out how to code those methods in such a way that they’d work for any animal.
We could write the makeNoise() method, for example, so that all it does is play a sound ﬁ le deﬁ ned in an instance variable for that type, but that’s not very specialized.
So just as with the Amoeba overriding the Shape class rotate() method, to get more amoeba-speciﬁ c (in other words, unique) behavior, we’ll have to do the same for our Animal subclasses.
Looking at the Animal class, we decide that eat() and makeNoise() should be overridden by the individual subclasses.
Decide if a subclass needs behaviors (method implementations) that are speciﬁ c to that particular subclass type.
We look at our classes and see that Wolf and Dog might have some behavior in common, and the same goes for Lion, Tiger, and Cat.
Look for more opportunities to use abstraction, by ﬁ nding two or more subclasses that might need common behavior.
We have each subclass override the makeNoise() and eat() methods, so that there’s no mistaking a Dog bark from a Cat meow (quite insulting to both parties)
We have to look at the subclasses of Animal, and see if two or more can be grouped together in some way, and given code that’s common to only that new group.
Since animals already have an organizational hierarchy (the whole kingdom, genus, phylum thing), we can use the level that makes the most sense for class design.
We’ll use the biological “families” to organize the animals by making a Feline class and a Canine class.
We decide that Canines could use a common roam() method, because they tend to move in packs.
We also see that Felines could use a common roam() method, because they tend to avoid others of their own kind.
We’ll let Hippo continue to use its inherited roam() methodthe generic one it gets from Animal.
So we’re done with the design for now; we’ll come back to it later in the chapter.
Which method is called? The Wolf class has four methods.
One inherited from Animal, one inherited from Canine (which is actually an overridden version of a method in class Animal), and two overridden in the Wolf class.
When you create a Wolf object and assign it to a variable, you can use the dot operator on that reference variable to invoke all four methods.
When you call a method on an object reference, you’re calling the most speciﬁ c version of the method for that object type.
Canine is lower than Animal, and Wolf is lower than Canine, so invoking a method on a reference to a Wolf object means the JVM starts looking ﬁ rst in the Wolf class.
If the JVM doesn’t ﬁ nd a version of the method in the Wolf class, it starts walking back up the inheritance hierarchy until it ﬁ nds a match.
Q: You said that the JVM starts walking up the inheritance tree, starting at the class type you invoked the method on (like the Wolf example on the previous page)
But what happens if the JVM doesn’t ever ﬁnd a match?
A: Good question! But you don’t have to worry about that.
The compiler guarantees that a particular method is callable for a specific reference type, but it doesn’t say (or care) from which class that method actually comes from at runtime.
With the Wolf example, the compiler checks for a sleep() method, but doesn’t care that sleep() is actually defined in (and inherited from) class Animal.
Remember that if a class inherits a method, it has the method.
Where the inherited method is defined (in other words, in which superclass it is defined) makes no difference to the compiler.
But at runtime, the JVM will always pick the right one.
And the right one means, the most specific version for that particular object.
Using IS-A and HAS-A Remember that when one class inherits from another, we say that the subclass extends the superclass.
When you want to know if one thing should extend another, apply the IS-A test.
To know if you’ve designed your types correctly, ask, “Does it make sense to say type X IS-A type Y?”  If it doesn’t, you know there’s something wrong with the design, so if we apply the IS      -A test, Tub IS-A Bathroom is deﬁ nitely false.
What if we reverse it to Bathroom extends Tub?  That still doesn’t work, Bathroom IS-A Tub doesn’t work.
Does it make sense to say “Bathroom HAS-A Tub”?  If yes, then it means that Bathroom has a Tub instance variable.
In other words, Bathroom has a reference to a Tub, but Bathroom does not extend Tub and vice-versa.
The relationship between my Tub and my Bathroom is HAS-A.
But wait! There’s more! The IS-A test works anywhere in the inheritance tree.
If your inheritance tree is well-designed, the IS-A test should make sense when you ask any subclass if it IS-A any of its supertypes.
With an inheritance tree like the one shown here, you’re always allowed to say “Wolf extends Animal” or “Wolf IS-A Animal”
It makes no difference if Animal is the superclass of the superclass of Wolf.
In fact, as long as Animal is somewhere in the inheritance hierarchy above Wolf,  Wolf IS-A Animal will always be true.
The structure of the Animal inheritance tree says to the world:
It makes no difference if Wolf overrides some of the methods in Animal or Canine.
As far as the world (of other code) is concerned, a Wolf can do those four methods.
How he does them, or in which class they’re overridden makes no difference.
A Wolf can makeNoise(), eat(), sleep(), and roam() because a Wolf extends from class Animal.
Put a check next to the relationships that make sense.
How do you know if you’ve got your inheritance right? There’s obviously more to it than what we’ve covered so far, but we’ll look at a lot more OO issues in the next chapter (where we eventually reﬁ ne and improve on some of the design work we did in this chapter)
For now, though, a good guideline is to use the IS-A test.
If “X IS-A Y” makes sense, both classes (X and Y) should probably live in the same inheritance hierarchy.
Keep in mind that the inheritance IS-A relationship works in only one direction! Triangle IS-A Shape makes sense, so you can have Triangle extend Shape.
But the reverse—Shape IS-A Triangle—does not make sense, so Shape should not extend Triangle.
Remember that the IS-A relationship implies that if X IS-A Y, then X can do anything a Y can do (and possibly more)
Access levels control who sees what, and are crucial to having well-designed, robust Java code.
When a subclass inherits a member, it is as if the subclass defined the member itself.
In the Shape example, Square inherited the rotate() and playSound() methods and to the outside world (other code) the Square class simply has a rotate() and playSound() method.
The members of a class include the variables and methods defined in the class plus anything inherited from a superclass.
Who gets the Porsche, who gets the porcelain? (how to know what a subclass can inherit from it’s superclass)
Members include instance variables and methods, although later in this book we’ll look at other inherited members.
A superclass can choose whether or not it wants a subclass to inherit a particular member by the level of access the particular member is given.
There are four access levels that we’ll cover in this book.
Moving from most restrictive to least, the four access levels are:
A:A superclass won’t necessarily know about any of its subclasses.
You might write a class and much later someone else comes along and extends it.
But even if the superclass creator does know about (and wants to use) a subclass version of a method, there’s no sort of reverse or backwards inheritance.
Think about it, children inherit from parents, not the other way around.
Q: In a subclass, what if I want to use BOTH the superclass version and my overriding subclass version of a method?  In other words,  I don’t want to completely replace the superclass version, I just want to add more stuff to it.
A:You can do this! And it’s an important design feature.
Think of the word “extends” as meaning, “I want to extend the functionality of the superclass”
You can design your superclass methods in such a way that they contain method implementations that will work for any subclass, even though the subclasses may still need to ‘append’ more code.
In your subclass overriding method, you can call the superclass version using the keyword super.
It’s like saying, “first go run the superclass version, then come back and finish with my own code...”
Note: get more details about default and protected in chapter 16 (deployment) and appendix B.
Although some of the reasons behind these rules won’t be revealed until later in this book, for now, simply knowing a few rules will help you build a better inheritance design.
Example: Willow is a more speciﬁc type of Tree, so Willow extends Tree makes sense.
Example: Square, Circle, and Triangle all need to rotate and play sound, so putting that functionality in a superclass Shape might make sense, and makes for easier maintenance and extensibility.
Be aware, however, that while inheritance is one of the key features of object-oriented programming, it’s not necessarily the best way to achieve behavior reuse.
It’ll get you started, and often it’s the right design choice, but design patterns will help you see other more subtle and ﬂexible options.
If you don’t know about design patterns, a good follow-on to this book would be Head First Design Patterns.
For example, imagine you wrote special printing code in the Alarm class and now you need printing code in the Piano class, so you have Piano extend Alarm so that Piano inherits the printing code.
That makes no sense! A Piano is not a more speciﬁc type of Alarm.
So the printing code should be in a Printer class, that all printable objects can take advantage of via a HAS-A relationship.
Always ask yourself if the subclass IS-A more speciﬁc type of the superclass.
So what does all this inheritance really buy you? You get a lot of OO mileage by designing with inheritance.
You can get rid of duplicate code by abstracting out the behavior common to a group of classes, and sticking that code in a superclass.
That way, when you need to modify it, you have only one place to update, and the change is magically reﬂected in all the classes that inherit that behavior.
Well, there’s no magic involved, but it is pretty simple: make the change and compile the class again.
Just deliver the newly-changed superclass, and all classes that extend it will automatically use the new version.
A Java program is nothing but a pile of classes, so the subclasses don’t have to be recompiled in order to use the new version of the superclass.
As long as the superclass doesn’t break anything for the subclass, everything’s ﬁne.
We’ll discuss what the word ‘break’ means in this context, later in the book.
For now, think of it as modifying something in the superclass that the subclass is depending on, like a particular method’s arguments or return type, or method name, etc.
Put common code in one place, and let the subclasses inherit that code from a superclass.
You deﬁne a common protocol for a group of classes.
Inheritance lets you guarantee that all classes grouped under a certain supertype have all the methods that the supertype has.* In other words, you define a common protocol for a set of classes related through inheritance.
Class Animal establishes a common protocol for all Animal subtypes:
When we say “all the methods” we mean “all the inheritable methods”, which for now actually means, “all the public methods”, although later we’ll refine that definition a bit more.
And remember, when we say any Animal, we mean Animal and any class that extends from Animal.
Which again means, any class that has Animal somewhere above it in the inheritance hierarchy.
When you deﬁ ne a supertype for a group of classes, any subclass of that supertype can be substituted where the supertype is expected.
Because   you get to refer to a subclass object using a  reference declared as the supertype.
Code that’s not just easier to develop, but also much, much easier to extend, in ways you never imagined at the time you originally wrote your code.
That means you can take that tropical vacation while your co-workers update the program, and your co-workers might not even need your source code.
We don’t know about you, but personally, we ﬁ nd the whole tropical vacation thing particularly motivating.
To see how polymorphism works, we have to step back and look at the way we normally declare a reference and create an object...
The important point is that the reference type AND the object type are the same.
The reference variable type is declared as Dog, and the object is created as new Dog()
But with polymorphism, the reference and the object can be different.
The reference variable type is declared as Animal, but the object is created as new Dog()
With polymorphism, the reference type can be a superclass of the actual object type.
But wait! There’s more! You can have polymorphic arguments and return types.
The Animal parameter can take ANY Animal type as the argument.
And when the Vet is done giving the shot, it tells the Animal to makeNoise(), and whatever Animal is really out there on the heap, that’s whose makeNoise() method will run.
Because that also means I can write my code, go on vacation, and someone else can add new.
With polymorphism, you can write code that doesn’t have to change when you introduce new subclass types into the program.
Remember that Vet class? If you write that Vet class using.
Why is polymorphism guaranteed to work this way? Why is it always safe to assume that any subclass type will have the methods you think you’re calling on the superclass type (the superclass reference type you’re using the dot operator on)?
Q: Are there any practical limits on the levels of subclassing? How deep can you go?
A: If you look in the Java API, you’ll see that most inheritance hierarchies are wide but not deep.
Most are no more than one or two levels deep, although there are exceptions (especially in the GUI classes)
You’ll come to realize that it usually makes more sense to keep your inheritance trees shallow, but there isn’t a hard limit (well, not one that you’d ever run into)
That’s one cool feature of OO, and sometimes it saves you from having to rewrite the class from scratch, or track down the programmer who hid the source code.
Q: Can you extend any class? Or is it like class members where if the class is private you can’t inherit it...
A: There’s no such thing as a private class, except in a very special case called an inner class, that we haven’t looked at yet.
But there are three things that can prevent a class from being subclassed.
Even though a class can’t be marked private, a class can be non-public (what you get if you don’t declare the class as public)
A non-public class can be subclassed only by classes in the same package as the class.
Classes in a different package won’t be able to subclass (or even use, for that matter) the non-public class.
The second thing that stops a class from being subclassed is the keyword modifier ﬁnal.
A final class means that it’s the end of the inheritance line.
The third issue is that if a class has only private constructors (we’ll look at constructors in chapter 9), it can’t be subclassed.
Q: Why would you ever want to make a ﬁnal class? What advantage would there be in preventing a class from being subclassed?
But if you need security — the security of knowing that the methods will always work the way that you wrote them (because they can’t be overridden),  a final class will give you that.
A lot of classes in the Java API are final for that reason.
The String class, for example, is final because, well, imagine the havoc if somebody came along and changed the way Strings behave!
Q: Can you make a method ﬁnal, without making the whole class ﬁnal?
A: If you want to protect a specific method from being overridden, mark the method with the ﬁnalmodifier.
Mark the whole class as final if you want to guarantee that none of the methods in that class will ever be overridden.
When you override a method from a superclass, you’re agreeing to fulﬁ ll the contract.
The contract that says, for example, “I take no arguments and I return a boolean.” In other words, the arguments and return types of your overriding method must look to the outside world exactly like the overridden method in the superclass.
If polymorphism is going to work, the   Toaster’s version of the overridden method from Appliance has to work at runtime.
Remember, the compiler looks at the reference type to decide whether you can call a particular method on that reference.
With an Appliance reference to a Toaster, the compiler cares only if class Appliance has the method you’re invoking on an Appliance reference.
But at runtime, the JVM looks not at the reference type (Appliance) but at the actual Toaster object on the heap.
So if the compiler has already approved the method call, the only way it can work is if the overriding method has the same arguments and return types.
Otherwise, someone with an Appliance reference will call turnOn() as a noarg method, even though there’s a version in Toaster that takes an int.
Which one is called at runtime? The one in Appliance.
In other words, the turnOn(int level) method in Toaster is not an override!
Arguments must be the same, and return types must be compatible.
The contract of superclass deﬁ nes how other code can use a method.
Whatever the superclass takes as an argument, the subclass overriding the method must use that same argument.
And whatever the superclass declares as a return type, the overriding method must declare either the same type, or a subclass type.
Remember, a subclass object is guaranteed to be able to do anything its superclass declares, so it’s safe to return a subclass where the superclass is expected.
That means the access level must be the same, or friendlier.
That means you can’t, for example, override a public method and make it private.
What a shock that would be to the code invoking what it thinks (at compile time) is a public method, if suddenly at runtime the JVM slammed the door shut because the overriding version called at runtime is private!
So far we’ve learned about two access levels: private and public.
The other two are in the deployment chapter (Release your Code) and appendix B.
There’s also another rule about overriding related to exception handling, but we’ll wait until the chapter on exceptions (Risky Behavior) to cover that.
This is actually a legal overLOAD, but not an overRIDE.
Method overloading is nothing more than having two methods with the same name but different argument lists.
Overloading lets you make multiple versions of a method, with different argument lists, for convenience to the callers.
For example, if you have a method that takes only an int, the calling code has to convert, say, a double into an int before calling your method.
But if you overloaded the method with another version that takes a double, then you’ve made things easier for the caller.
You’ll see more of this when we look into constructors in the object lifecycle chapter.
Since an overloading method isn’t trying to fulﬁll the polymorphism contract deﬁned by its superclass, overloaded methods have much more ﬂexibility.
You’re free to change the return types in overloaded methods, as long as the argument lists are different.
If only the return type is different, it’s not a valid overload—the compiler will assume you’re trying to override the method.
And even that won’t be legal unless the return type is a subtype of the return type declared in the superclass.
To overload a method, you MUST change the argument list, although you can change the return type to anything.
You’re free to overload a method with a method that’s more restrictive.
It doesn’t matter, since the new method isn’t obligated to fulﬁll the contract of the overloaded method.
An overloaded method is just a different method that happens to have the same method name.
An overloaded method is NOT the same as an overridden method.
One block of the program is missing!  Your challenge is to match the candidate block of code (on the left), with the output that you’d see if the block were inserted.
Not all the lines of output will be used, and some of the lines of output might be used more than once.
Draw lines connecting the candidate blocks of code with their matching command-line output.
Pool Puzzle Your job is to take code snippets from the pool and place them into.
You may use the same snippet more than once, and you might not need to use all the snippets.
Your goal is to make a set of classes that will compile and run together as a program.
Don’t be fooled – this one’s harder than it looks.
Set 2 will not compile because of Vampire’s return type (int)
The Vampire’s frighten() method (B) is not a legal override OR overload of Monster’s frighten() method.
Changing ONLY the return type is not enough to make a valid overload, and since an int is not compatible with a boolean,  the method is not a valid override.
Remember, if you change ONLY the return type, it must be to a return type that is compatible with the superclass version’s return type, and then it’s an override.
Remember, class Vampire did not override class Monster’s frighten() method.
The frighten() method in Vampire’s set 4 takes a byte, not an int.
To exploit polymorphism, we need interfaces (and not the GUI kind)
We need to go beyond simple inheritance to a level of flexibility and.
What’s an abstract class? It’s a class that can’t be instantiated.
Did we forget about something when we designed this? The class structure isn’t too bad.
We’ve designed it so that duplicate code is kept to a minimum, and we’ve overridden the methods that we think should have subclass-speciﬁ c implementations.
We’ve made it nice and ﬂ exible from a polymorphic perspective, because we can design Animal-using programs with Animal arguments (and array declarations), so that any Animal subtype—including those we never imagined at the time we wrote our code—can be passed in and used at runtime.
We’ve put the common protocol for all Animals (the four methods that we want the world to know all Animals have) in the Animal superclass, and we’re ready to start making new Lions and Tigers and Hippos.
It makes sense to create a Wolf object or a Hippo object or a Tiger object, but what exactly is an Animal object? What shape is it? What color, size, number of legs...
But how do we deal with this? We need an Animal class, for inheritance and polymorphism.
But we want programmers to instantiate only the less abstract subclasses of class Animal, not Animal itself.
We want Tiger objects and Lion objects, not Animal objects.
Fortunately, there’s a simple way to prevent a class from ever being instantiated.
In other words, to stop anyone from saying “new” on that type.
By marking the class as abstract, the compiler will stop any code, anywhere, from ever creating an instance of that type.
You can still use that abstract type as a reference type.
In fact,that’s a big part of why you have that       abstract class in  the ﬁ rst place (to use it as a polymorphic argument or return type, or to make a polymorphic array)
When you’re designing your class inheritance structure, you have to decide which classes are abstract and which are concrete.
Concrete classes are those that are speciﬁ c enough to be instantiated.
A concrete class just means that it’s OK to make objects of that type.
Making a class abstract is easy—put the keyword abstract before the class declaration:
The compiler won’t let you instantiate an abstract class An abstract class means that nobody can ever make a new instance of that class.
You can still use that abstract class as a declared reference type, for the purpose of polymorphism, but you don’t have to worry about somebody making objects of that type.
An abstract class has virtually* no use, no value, no purpose in life, unless it is extended.
With an abstract class, the guys doing the work at runtime are instances of a subclass of your abstract class.
There is an exception to this—an abstract class can have static members (see chapter 10)
Concrete A class that’s not abstract is called a concrete class.
Flip through the Java API and you’ll ﬁ nd a lot of abstract classes, especially in the GUI library.
What does a GUI Component look like? The Component class is the superclass of GUI-related classes for things like buttons, text areas, scrollbars, dialog boxes, you name it.
You don’t make an instance of a generic Component and put it on the screen, you make a JButton.
In other words, you instantiate only a concrete subclass of Component, but never Component itself.
Abstract methods Besides classes, you can mark methods abstract, too.
An abstract class means the class must be extended; an abstract method means the method must be overridden.
You might decide that some (or all) behaviors in an abstract class don’t make any sense unless they’re implemented by a more speciﬁc subclass.
In other words, you can’t think of any generic method implementation that could possibly be useful for subclasses.
An abstract method has no body! Because you’ve already decided there isn’t any code that would make sense in the abstract method, you won’t put in a method body.
So no curly braces— just end the declaration with a semicolon.
If you declare an abstract method, you MUST mark the class abstract as well.
You can’t have an abstract method in a non-abstract class.
If you put even a single abstract method in a class, you have to make the class abstract.
But you can mix both abstract and nonabstract methods in the abstract class.
Q: What is the point of an abstract method? I thought the whole point of an abstract class was to have common code that could be inherited by subclasses.
A: Inheritable method implementations (in other words, methods with actual bodies) are A Good Thing to put in a superclass.
And in an abstract class, it often doesn’t make sense, because you can’t come up with any generic code that subclasses would find useful.
The point of an abstract method is that even though you haven’t put in any actual method code, you’ve still defined part of the protocol for a group of subtypes (subclasses)
A: Polymorphism! Remember, what you want is the ability to use a superclass type (often abstract) as a method argument, return type, or array type.
That way, you get to add new subtypes (like a new Animal subclass) to your program without having to rewrite (or add) new methods to deal with those new types.
Imagine how you’d have to change the Vet class, if it didn’t use Animal as its argument type for methods.
You’d have to have a separate method for every single Animal subclass! One that takes a Lion, one that takes a Wolf, one that takes a...
So with an abstract method, you’re saying, “All subtypes of this type have THIS method.” for the benefit of polymorphism.
Abstract methods don’t have a body; they exist solely for polymorphism.
That means the ﬁrst concrete class in the inheritance tree must implement all abstract methods.
You can, however, pass the buck by being abstract yourself.
If both Animal and Canine are abstract, for example, and both have abstract methods, class Canine does not have to implement the abstract methods from Animal.
But as soon as we get to the ﬁrst concrete subclass, like Dog, that subclass must implement all of the abstract methods from both Animal and Canine.
But remember that an abstract class can have both abstract and non-abstract methods, so Canine, for example, could implement an abstract method from Animal, so that Dog didn’t have to.
But if Canine says nothing about the abstract methods from Animal, Dog has to implement all of Animal’s abstract methods.
Implementing an abstract method is just like overriding a method.
When we say “you must implement the abstract method”, that means you must provide a body.
That means you must create a non-abstract method in your class with the same method signature (name and arguments) and a return type that is compatible with the declared return type of the abstract method.
What you put in that method is up to you.
All Java cares about is that the method is there, in your concrete subclass.
Joe ﬁnally implemented all his abstract methods! Now everything is working just the way we planned...
Sharpen your pencil Let’s put all this abstract rhetoric into some concrete use.
Your job is to imagine applications where the listed class might be concrete,  and applications where the listed class might be abstract.
We took a shot at the ﬁrst few to get you going.
For example, class Tree would be abstract in a tree nursery program, where differences between an Oak and an Aspen matter.
But in a golf simulation program,  Tree might be a concrete class (perhaps a subclass of Obstacle), because the program doesn’t care about or distinguish between different types of trees.
There’s no one right answer; it depends on your design.
Polymorphism in action Let’s say that we want to write our own kind of list class, one that will hold Dog objects, but pretend for a moment that we don’t know about the ArrayList class.
For the ﬁ rst pass, we’ll give it just an add() method.
When we reach the limit of 5 Dog objects, you can still call the add() method but it won’t do anything.
If we’re not at the limit, the add() method puts the Dog in the array at the next available index   position, then increments that next available index (nextIndex)
Make a single class, DogAndCatList, that keeps two different arrays as instance variables and has two different add() methods: addCat(Cat c) and addDog(Dog d)
Make heterogeneous AnimalList class, that takes any kind of Animal subclass (since we know that if the spec changed to add Cats, sooner or later we’ll have some other kind of animal added as well)
We like this option best, so let’s change our class to make it more generic, to take Animals instead of just Dogs.
We want to change the type of the array, along with the add() method argument, to something above Animal.
But how can we do it? We don’t have a superclass for Animal.
Remember those methods of ArrayList? Look how the remove, contains, and indexOf method all use an object of type...
Class Object is the mother of all classes; it’s the superclass of everything.
What about non-Animals? Why not make a class generic enough to take anything?
Even if you take advantage of polymorphism, you still have to create a class with methods that take and   return your polymorphic type.
Without a common superclass for everything in Java, there’d be no way for the developers of Java to create classes with methods that could take your custom types...
So you were making subclasses of class Object from the very beginning and you didn’t even know it.
Every class you write extends Object, without your ever having to say it.
But you can think of it as though a class you write looks like this:
No problem, then the compiler will just make Animal extend Object.
Any class that doesn’t explicitly extend another class, implicitly extends Object.
So, since Dog extends Canine, it doesn’t directly extend Object (although it does extend it indirectly), and the same is true for Canine, but Animal does directly extend Object.
If you were Java, what behavior would you want every object to have? Hmmmm...
Oh, here’s a good one—a method that prints out a String message for that object.
And what do you know? As if by magic, class Object does indeed have methods for those four things.
That’s not all, though, but these are the ones we really care about.
YourClassHere Every class you write inherits all the methods of class Object.
The classes you’ve written inherited methods you didn’t even     know you had.
Object is a non-abstract class because it’s got method implementation code that all classes can inherit and use out-of-the-box, without having to override the methods.
But some of them are marked ﬁnal, which means you can’t override them.
You’re encouraged (strongly) to override hashCode(), equals(), and toString() in your own classes, and you’ll learn how to do that a little later in the book.
But some of the methods, like getClass(), do things that must work in a specific, guaranteed way.
Q: If ArrayList methods are generic enough to use Object, then what does it mean to say ArrayList<DotCom>? I thought I was restricting the ArrayList to hold only DotCom objects?
In other words, an ArrayList restricted to anything that’s an Object, which means any object in Java, instantiated from any class type! We’ll cover the details of this new <type> syntax later in the book.
Q: OK, back to class Object being non-abstract (so I guess that means it’s concrete), HOW can you let somebody make an Object object? Isn’t that just as weird as making an Animal object?
A: Good question! Why is it acceptable to  make a new Object instance? Because sometimes you just want a generic object to use as, well, as an object.
By far, the most common use of an instance of type Object is for thread synchronization (which you’ll learn about in chapter 15)
For now, just stick that on the back burner and assume that you will rarely make objects of type Object, even though you can.
Q: So is it fair to say that the main purpose for type Object is so that you can use it for a polymorphic argument and return type?  Like in ArrayList?
A: The Object class serves two main purposes: to act as a polymorphic type for methods that need to work on any class that you or anyone else makes, and to provide real method code that all objects in Java need at runtime (and putting them in class Object means all other classes inherit them)
Some of the most important methods in Object are related to threads, and we’ll see those later in the book.
Q: If it’s so good to use polymorphic types, why don’t you just make ALL your methods take and return type Object?
For one thing, you would defeat the whole point of  ‘type-safety’, one of Java’s greatest protection mechanisms for your code.
With type-safety, Java guarantees that you won’t ask the wrong object to do something you meant to ask of another object type.
Like, ask a Ferrari (which you think is a Toaster) to cook itself.
But the truth is, you don’t have to worry about that fiery Ferrari scenario, even if you do use Object references for everything.
Because when objects are referred to by an Object reference type, Java thinks it’s referring to an instance of type Object.
And that means the only methods you’re allowed to call on that object are the ones declared in class Object! So if you were to say:
Because Java is a strongly-typed language, the compiler checks to make sure that you’re calling a method on an object that’s actually capable of responding.
In other words, you can call a method on an object reference only if the class of the reference type actually has the method.
We’ll cover this in much greater detail a little later, so don’t worry if the picture isn’t crystal clear.
Before you run off and start using type Object for all your ultra-ﬂ exible argument and return types, you need to consider a little issue of using type Object as a reference.
And keep in mind that we’re not talking about making instances of type Object; we’re talking about making instances of some other type, but using a reference of type Object.
When you put an object into an ArrayList<Dog>,  it goes in as a Dog, and comes out as a Dog:
But what happens when you declare it as   ArrayList<Object>? If you want to make an ArrayList that will literally take any kind of Object, you declare it like this:
But what happens when you try to get the Dog object and assign it to a Dog reference?
Everything comes out of an ArrayList<Object> as a reference of type Object, regardless of what the actual object is, or what the reference type was when you added the object to the list.
Objects come out of an ArrayList<Object> acting like they’re generic instances of class Object.
The Compiler cannot assume the object that comes out is of any type other than Object.
Assign the Dog from the li st to a new Dog reference.
Think of it as though the get() method declares a D.
NO!! Won’t compile!! When you use ArrayList<Object>, the get() method returns type Object.
The Compiler knows only that the object inherits from Object (somewhere in its inheritance tree) but it doesn’t know it’s a Dog !!
But they come OUT as though they were of type Object.
The problem with having everything treated polymorphically as an Object is that the objects appear to lose (but not permanently) their true essence.
Let’s see what happens when we pass a Dog to a method that returns a reference to the same Dog object, but declares the return type as type Object rather than Dog.
The compiler doesn’t know that the thing returned from the method is actually a Dog, so it won’t let you assign it to a Dog reference.
This works (although it may not be very useful, as you’ll see in a moment) because you can assign ANYTHING to a reference of type Object, since every class passes the IS-A test for Object.
Every object in Java is an instance of type Object, because every class in Java has Object at the top of its inheritance tree.
We’re returning a refer ence to the same Dog, b.
So now we know that when an object is referenced by a variable declared as type Object, it can’t be assigned to a variable declared with the actual object’s type.
And we know that this can happen when a return type or argument is declared as type Object, as would be the case, for example, when the object is put into an ArrayList of type Object using ArrayList<Object>
Can’t do this!! The Object class has no idea what it means to bark()
Even though YOU know it’s really a Dog at that index, the compiler doesn’t..
When you get an object reference from an ArrayList<Object> (or any method that declares Object as the return type), it comes back as a polymorphic reference type of Object.
So you have an Object reference to (in this case) a Dog instance.
The compiler decides whether you can call a method based on the reference type, not the actual object type.
Even if you know the object is capable (“...but it really is a Dog, honest...”), the compiler sees it only as a generic Object.
For all the compiler knows, you put a Button object out there.
Or some other thing that really doesn’t know how to bark.
The compiler checks the class of the reference type—not the object type—to see if you can call a method using that reference.
The method you’re calling on a reference MUST be in the class of that reference type.
The “o” reference was declared as type Object, so you can call methods only if those methods are in class Object..
An object contains everything it inherits from each of its superclasses.
That means every object—regardless of its actual class type—is also an instance of class Object.That means any object in Java can be treated not just as a Dog, Button, or Snowboard, but also as an Object.
When you say new Snowboard(), you get a single object on the heap—a Snowboard object—but that Snowboard wraps itself around an inner core representing the Object (capital “O”) portion of itself.
But it contains both the Snowboard class parts of itself and the Object class parts of itself.
Snowboard inherits methods from superclass Object, and adds four more.
The Object reference can see only the Object parts of the Snowboard object.
The Snowboard remote control (reference) has more buttons than an Object remote control.
The Snowboard remote can see the full Snowboardness of the Snowboard object.
It can access all the methods in Snowboard, including both the inherited Object methods and the methods from class Snowboard.
If a reference is like a remote control, the remote control takes on more and more buttons as you move down the inheritance tree.
A remote control (reference) of type Object has only a few buttons—the buttons for the exposed methods of class Object.
But a remote control of type Snowboard includes all the buttons from class Object, plus any new buttons (for new methods) of class Snowboard.
The more speciﬁc the class, the more buttons it may have.
Of course that’s not always true; a subclass might not add any new methods, but simply override the methods of its superclass.
The key point is that even if the object is of type Snowboard, an Object reference to the Snowboard object can’t see the Snowboard-speciﬁc methods.
You can treat a Snowboard as a Snowboard or as an Object.
When you put an object in an ArrayList<Object>, you can treat it only as an Object, regardless of the type it was when you put it in.
When you get a reference from an ArrayList<Object>, the reference is always of type Object.
ArrayList<Object> and it can’t do any Dog things? There’s gotta be a.
It’s really still a Dog object, but if you want to call Dog-speciﬁc methods, you need a reference declared as type Dog.
If you’re sure* the object is really a Dog, you can make a new Dog reference to it by copying the Object reference, and forcing that copy to go into a Dog reference variable, using a cast  (Dog)
You can use the new Dog reference to call Dog methods.
If you’re not sure it’s a Dog, you can use the instanceof operator to check.
Because if you’re wrong when you do the cast, you’ll get a ClassCastException at runtime and come to a grinding halt.
Cast the so-called ‘Object’ (but we know he’s actually a Dog) to type Dog, so that you can treat him like the Dog he really is.
When you write a class, you almost always expose some of the methods to code outside the class.
To expose a method means you make a method accessible, usually by marking it public.
Imagine this scenario: you’re writing code for a small business accounting program.
The good reuser that you are, you found an Account class that appears to meet your needs perfectly, according to its documentation, anyway.
Each account instance represents an individual customer’s account with the store.
So there you are minding your own business invoking the credit() and debit() methods on an account object when you realize you need to get a balance on an account.
Forget the documentation, the class does not have that method.
But that won’t happen to you, because everytime you use the dot operator on a reference (a.doStuff()), the compiler looks at the reference type (the type ‘a’ was declared to be) and checks that class to guarantee the class has the method, and that the method does indeed take the argument you’re passing and return the kind of value you’re expecting to get back.
Just remember that the compiler checks the class of the reference variable, not the class of the actual object at the other end of the reference.
Think of the public methods in your class as your contract, your promise to the outside world about the things you can do.
So now you’ve seen how much Java cares about the methods in the class of the reference variable.
You can call a method on an object only if the class of the reference variable has that method.
Your Dog class isn’t the only contract that deﬁnes who you are.
Remember, you inherit accessible (which usually means public) methods from all of your superclasses.
According to the IS-A test, you are each of those things—Canine, Animal, and Object.
But what if the person who designed your class had in mind the Animal simulation program, and now he wants to use you (class Dog) for a Science Fair Tutorial on Animal objects.
But what if later he wants to use you for a PetShop program? You don’t have any Pet behaviors.
No problem, right? Just add some more methods to the Dog class.
You won’t be breaking anyone else’s code by adding methods, since you aren’t touching the existing methods that someone else’s code might be calling on Dog objects.
Can you see any drawbacks to that approach (adding Pet methods to the Dog class)?
Think about what YOU would do if YOU were the Dog class programmer and needed to modify the Dog so that it could do Pet things, too.
We know that simply adding new Pet behaviors (methods) to the Dog class will work, and won’t break anyone else’s code.
It has more than just Dogs!  And what if someone wants to use your Dog class for a program that has wild Dogs? What do you think your options might be, and without worrying about how Java handles things, just try to imagine how you’d like to solve the problem of modifying some of your Animal classes to include Pet behaviors.
Stop right now and think about it, before you look at the next page where we begin to reveal everything.
On the next few pages, we’re going to walk through some possibilities.
We’re not yet worried about whether Java can actually do what we come up with.
We’ll cross that bridge once we have a   good idea of some of the tradeoffs.
Let’s explore some design options for reusing some of our existing classes in a PetShop program.
We take the easy path, and put pet methods in class Animal.
We won’t have to touch the existing Animal subclasses at all, and any Animal subclasses created in the future will also get to take advantage of inheriting those methods.
That way, class Animal can be used as the polymorphic type in any program that wants to treat the Animals as pets.
Also, we almost certainly WILL have to touch the pet classes like Dog and Cat, because (in our house, anyway) Dogs and Cats tend to implement pet behaviors VERY differently.
We start with Option One, putting the pet methods in class Animal, but we make the methods abstract, forcing the Animal subclasses to override them.
That would give us all the beneﬁ ts of Option One, but without the drawback of having non-pet Animals running around with pet methods (like beFriendly())
All Animal classes would have the method (because it’s in class Animal), but because it’s abstract the non-pet Animal classes won’t inherit any functionality.
All classes MUST override the methods, but they can make the methods “do-nothings”
Because the pet methods in the Animal class are all abstract, the concrete Animal subclasses are forced to implement all of them.
Remember, all abstract methods MUST be implemented by the ﬁ rst concrete subclass down the inheritance tree.
What a waste of time! You have to sit there and type in each and every pet method into each and every concrete nonpet class, and all future subclasses as well.
And while this does solve the problem of non-pets actually DOING pet things (as they would if they inherited pet functionality from class Animal), the contract is bad.
Every non-pet class would be announcing to the world that it, too, has those pet methods, even though the methods wouldn’t actually DO anything when called.
It just seems wrong to stuff everything into class Animal that more than one Animal type might need, UNLESS it applies to ALL Animal subclasses.
Put the pet methods ONLY in the classes where they belong.
No more worries about Hippos greeting you at the door or licking your face.
The methods are where they belong, and ONLY where they belong.
Dogs can implement the methods and Cats can implement the methods, but nobody else has to know about them.
First off, you’d have to agree to a protocol, and all programmers of pet Animal classes now and in the future would have to KNOW about the protocol.
By protocol, we mean the exact methods that we’ve decided all pets should have.
But what if one of the programmers gets it just a tiny bit wrong? Like, a method takes a String when it was supposed to take an int? Or they named it doFriendly() instead of beFriendly()? Since it isn’t in a contract, the compiler has no way to check you to see if you’ve implemented the methods correctly.
Someone could easily come along to use the pet Animal classes and ﬁ nd that not all of them work quite right.
And second, you don’t get to use polymorphism for the pet methods.
Every class that needs to use pet behaviors would have to know about each and every class! In other words, you can’t use Animal as the polymorphic type now, because the compiler won’t let you call a Pet method on an Animal reference (even if it’s really a Dog object) because class Animal doesn’t have the method.
It looks like we need TWO superclasses at the top.
It’s called “multiple inheritance” and it can be a Really Bad Thing.
That is, if it were possible to do in Java.
But it isn’t, because multiple inheritance has a problem known as The Deadly Diamond of    Death.
Which burn() method runs when you call burn() on the ComboDrive?
A language that allows the Deadly Diamond of Death can lead to some ugly complexities, because you have to have special rules to deal with the potential ambiguities.
And extra rules means extra work for you both in learning those rules and watching out for those “special cases”
Java is supposed to be simple, with consistent rules that don’t blow up under some scenarios.
So Java (unlike C++) protects you from having to think about the Deadly Diamond of Death.
But that brings us back to the original problem! How do we handle the Animal/Pet thing?
A Java interface is like a 100% pure abstract class.
Not a GUI interface, not the generic use of the word interface as in, “That’s the public interface for the Button class API,” but the Java keyword interface.
A Java interface solves your multiple inheritance problem by giving you much of the polymorphic beneﬁ ts of multiple inheritance without the pain and suffering from the Deadly Diamond of Death (DDD)
The way in which interfaces side-step the DDD is surprisingly simple: make all the methods abstract! That way, the subclass must implement the methods (remember, abstract methods must be implemented by the ﬁ rst concrete subclass), so at runtime the JVM isn’t confused about which of the   two inherited versions it’s supposed to call.
You SAID you are a Pet, so you MUST implement the Pet methods.
If all the methods are abstract, what does an interface really buy you?
Interfaces are the ultimate in flexibility, because if you use interfaces instead of concrete subclasses (or even abstract superclass types) as arguments and return.
And think about it—with an interface, a class doesn’t have to come from just one inheritance tree.
A class can extend one class, and implement an interface.
But another class might implement the same interface, yet come from a completely different inheritance tree! So you get to treat an object by the role it plays, rather than by the class type from which it was instantiated.
In fact, if you wrote your code to use interfaces, you wouldn’t even have to give anyone a superclass that they had.
You could just give them the interface and say, “Here,’ I don’t care what kind of class inheritance structure you come from, just implement this interface and you’ll be good to go.”
The fact that you can’t put in implementation code turns out not to be a problem for most good designs, because most interface methods wouldn’t make sense if implemented in a generic way.
In other words, most interface methods would need to be overridden even if the methods weren’t forced to be abstract.
Classes from different inheritance trees can implement the same interface.
Class RoboDog doesn’t come from the Animal inheritance tree, but it still gets to be a Pet!
When you use a class as a polymorphic type (like an array of type Animal or a method that takes a Canine argument), the objects you can stick in that type must be from the same inheritance tree.
But not just anywhere in the inheritance tree; the objects must be from a class that is a subclass of the polymorphic type.
An argument of type Canine can accept a Wolf and a Dog, but not a Cat or a Hippo.
But when you use an interface as a polymorphic type (like an array of Pets), the objects can be from anywhere in the inheritance tree.
The only requirement is that the objects are from a class that implements the interface.
Allowing classes in different inheritance trees to implement a common interface is crucial in the Java API.
Do you want an object to be able to save its state to a ﬁ le? Implement the Serializable interface.
You’ll learn more about Serializable and Runnable in later chapters, but for now, remember that classes from any place in the inheritance tree might need to implement those interfaces.
Nearly any class might want to be saveable or runnable.
But a Dog IS-A Pet through interface implementation, and the Dog might implement other interfaces as well.
How do you know whether to make a class, a subclass, an abstract  class, or an interface?
Make a class that doesn’t extend anything (other than Object) when your new class doesn’t pass the IS-A test for any other type.
Make a subclass (in other words, extend a class) only when you need to make a more speciﬁ c version of a class and need to override or add new behaviors.
Use an abstract class when you want to deﬁ ne a template for a group of subclasses, and you have at least some implementation code that all subclasses could use.
Make the class abstract when you want to guarantee that nobody can make objects of that type.
Use an interface when you want to deﬁ ne a role that other classes can play, regardless of where those classes are in the inheritance tree.
Q: What if you make a concrete subclass and you need to override a method, but you want the behavior in the superclass version of the method? In other words, what if you don’t need to replace the method with an override, but you just want to add to it with some additional speciﬁc code.
One area of good OO design looks at how to design concrete code that’s meant to be overridden.
In other words, you write method code in, say, an abstract class, that does work that’s generic enough to support typical concrete implementations.
But, the concrete code isn’t enough to handle all of the subclass-specific work.
So the subclass overrides the method and extends it by adding the rest of the code.
The keyword super lets you invoke a superclass version of an overridden method, from within the subclass.
The super keyword is really a reference to the superclass portion of an object.
A reference to the subclass object (BuzzwordReport) will always call the subclass version of an overridden method.
When you don’t want a class to be instantiated (in other words, you don’t want anyone to make a new object of that class type) mark the class with the abstract keyword.
An abstract class can have both abstract and non-abstract methods.
If a class has even one abstract method, the class must be marked abstract.
An abstract method has no body, and the declaration ends with a semicolon (no curly braces)
All abstract methods must be implemented in the first concrete subclass in the inheritance tree.
Methods can be declared with Object arguments and/or return types.
You can call methods on an object only if the methods are in the class (or interface) used as the reference variable type, regardless of the actual object type.
All objects come out of an ArrayList<Object> as type Object (meaning, they can be referenced only by an Object reference variable, unless you use a cast)
Multiple inheritance is not allowed in Java, because of the problems associated with the “Deadly Diamond of Death”
Create an interface using the interface keyword instead of the word class.
Implement an interface using the keyword implements  Example: Dog implements Pet $ Your class can implement multiple interfaces.
A class that implements an interface must implement all the methods of the interface, since all interface methods are implicitly public and abstract.
To invoke the superclass version of a method from a subclass that’s overridden the.
What’s the special trick going on when you say ArrayList<Dog>?
In fact it is a special trick that ArrayList<Dog> gives back Dogs without you having to do any cast, since it looks like ArrayList methods don’t know anything about Dogs, or any type besides Object.
The short answer is that the compiler puts in the cast for you! When you say ArrayList<Dog>, there is no special class that has methods to take and return Dog objects, but instead the <Dog> is a signal to the compiler that you want the compiler to let you put ONLY Dog objects in and to stop you if you try to add any other type to the list.
And since the compiler stops you from adding anything but Dogs to the ArrayList, the compiler also knows that its safe to cast anything that comes out of that ArrayList do a Dog reference.
In other words, using ArrayList<Dog> saves you from having to cast the Dog you get back.
But there’s a lot  more to this story, and we’ll get into all the details in the Collections chapter.
On the left you’ll ﬁnd sets of class and interface declarations.
Your job is to draw the associated class diagrams on the right.
Use a dashed line for “implements” and a solid line for “extends”
On the left you’ll ﬁ nd sets of class diagrams.
Your job is to turn these into valid Java declarations.
We did number 1 for you (and it was a tough one)
Your job is to take code snippets from the pool and place them into the blank lines in the code and output.
You may use the same snippet more than once, and you won’t need to use all the snippets.
Your goal is to make a set of classes that will compile and run and produce the output listed.
Note:  Each snippet from the pool can be used more than once!
That means we’ll talk about the heap, the stack, scope, constructors, super constructors, null.
Warning: this chapter contains material about object death that some.
I said “Joe! Stay with me Joe!” But it was...
The Stack and the Heap: where things live Before we can understand what really happens when you create an object, we have to step back a bit.
We need to learn more about where everything lives (and for how long) in Java.
That means we need to learn more about the Stack and the Heap.
In Java, we (programmers) care about two areas of memory—the one where objects live (the heap), and the one where method invocations and local variables live (the stack)
When a JVM starts up, it gets a chunk of memory from the underlying OS, and uses it to run your Java program.
How much memory, and whether or not you can tweak it, is dependent on which version of the JVM (and on which platform) you’re.
But usually you won’t have anything to say about it.
And with good programming, you probably won’t care (more on that a little later)
And where a variable lives depends on what kind of variable it is.
The two kinds of variables whose lives we care about now are instance variables and local variables.
Local variables are also known as stack variables, which is a big clue for where they live.
Methods are stacked When you call a method, the method lands on the top of a call stack.
That new thing that’s actually pushed onto the stack is the stack frame, and it holds the state of the method including which line of code is executing, and the values of all local variables.
A method stays on the stack until the method hits its closing curly brace (which means the method’s done)
If method foo() calls method bar(), method bar() is stacked on top of method foo()
Code from another class calls doStuff(), and doStuff() goes into a stack frame at the top of the stack.The boolean variable named ‘b’ goes on the doStuff() stack frame.
Execution goes back to the go() method, and picks up at the line following the call to crazy()
The code on the left is a snippet (we don’t care what the rest of the class looks like) with three methods.
The ﬁrst method (doStuff()) calls the second method (go()), and the second method calls the third (crazy())
Each method declares one local variable within the body of the method, and method go() also declares a parameter variable (which means go() has two local variables)
The method on the top of the stack is always the currentlyexecuting method.
What about local variables that are objects? Remember, a non-primitive variable holds a reference to an object, not the object itself.
If the local variable is a reference to an object, only the variable (the reference/remote control) goes on the stack.
Java has two areas of memory we care about: the Stack and the Heap.
Instance variables are variables declared inside a class but outside any method.
Local variables are variables declared inside a method or method parameter.
All local variables live on the stack, in the frame corresponding to the method where the.
Object reference variables work just like primi-tive variables—if the reference is declared as a local variable, it goes on the stack.
All objects live in the heap, regardless of whether the reference is a local or instance variable.
Q:  One more time, WHY are we learning the whole stack/heap thing? How does this help me? Do I really need to learn about it?
A: Knowing the fundamentals of the Java Stack and Heap is crucial if you want to understand variable scope, object creation issues, memory management, threads, and exception handling.
We cover threads and exception handling in later chapters but the others you’ll learn in this one.
You do not need to know anything about how the Stack and Heap are implemented in any particular JVM and/or platform.
Everything you need to know about the Stack and Heap is on this page and the previous one.
If you nail these pages, all the other topics that depend on your knowing this stuff will go much, much, much easier.
Once again, some day you will SO thank us for shoving Stacks and Heaps down your throat.
If local variables live on the stack, where do instance variables live? When you say new CellPhone(), Java has to make space on the Heap for that CellPhone.
But how much space? Enough for the object, which means enough to house all of the object’s instance variables.
That’s right, instance variables live on the Heap, inside the object they belong to.
Remember that the values of an object’s instance variables live inside the object.
If the instance variables are all primitives, Java makes space for the instance variables based on the primitive type.
But what if the instance variables are objects? What if CellPhone HAS-A Antenna? In other words, CellPhone has a reference variable of type Antenna.
When the new object has instance variables that are object references rather than primitives, the real question is: does the object need space for all of the objects it holds references to? The answer is, not exactly.
No matter what, Java has to make space for the instance variable values.
But remember that a reference variable value is not the whole object, but merely a remote control to the object.
Well then when does the Antenna object get space on the Heap? First we have to ﬁnd out when the Antenna object itself is created.
If the instance variable is declared but no object is assigned to it, then only the space for the reference variable (the remote control) is created.
No actual Antenna object is made on the heap unless or until the reference variable is assigned a new Antenna object.
Object with one non-primitive instance variablea reference to an Antenna object, but no actual Antenna object This is what you get if you declare the variable but don’t initialize it with an actual Antenna object.
Object with one non-primitive instance variable, and the Antenna variable is assigned a new Antenna object.
The miracle of object creation Now that you know where variables and objects live, we can dive into the mysterious world of object creation.
Remember the three steps of object declaration and assignment: declare a reference variable, create an object, and assign the object to the reference.
But until now, step two—where a miracle occurs and the new object is “born”—has remained a Big Mystery.
Review the 3 steps of object declaration, creation and assignment:
Are we calling a method named Duck()? Because it sure looks like it.
A constructor does look and feel a lot like a method, but it’s not a method.
It’s got the code that runs when you say new.
In other words, the code that runs when you instantiate an object.
The only way to invoke a constructor is with the keyword new followed by the class name.
The JVM ﬁnds that class and invokes the constructor in that class.
OK, technically this isn’t the only way to invoke a constructor.
But it’s the only way to do it from outside a constructor.
You can call a constructor from within another constructor, with restrictions, but we’ll get into all that later in the chapter.
You can write a constructor for your class (we’re about to do that), but if you don’t, the compiler writes one for you!
Where’s the return type? If this were a method, you’d need a return type between “public” and “Duck()”
Notice something missing? How is this different from a method?
A constructor has the code that runs when you instantiate an object.
In other words, the code that runs when you say new on a class type.
Every class you create has a constructor, even if you don’t write it yourself.
Construct a Duck The key feature of a constructor is that it runs before the object can be assigned to a reference.
That means you get a chance to step in and do things to get the object ready for use.
In other words, before anyone can use the remote control for an object, the object has a chance to help construct itself.
In our Duck constructor, we’re not doing anything useful, but it still demonstrates the sequence of events.
The constructor gives you a chance to step into the middle of  new.
Increment a counter to track how many objects of this class type have been made.
Initializing the state of a new Duck Most people use constructors to initialize the state of an object.
In other words, to make and assign values to the object’s instance variables.
That’s all well and good when the Duck class developer knows how big the Duck object should be.
But what if we want the programmer who is using Duck to decide how big a particular Duck should be?
Imagine the Duck has a size instance variable, and you want the programmer using your Duck class to set the size of the new Duck.
Well, you could add a setSize() setter method to the class.
But that leaves the Duck temporarily without a size*, and forces the Duck user to write two statements—one to create the Duck, and one to call the setSize() method.
The code below uses a setter method to set the initial size of the new Duck.
The Duck is alive at this point in the code, but without a size!* And then you’re relying on the Duck-user to KNOW that Duck creation is a two-part process: one to call the constructor and one to call the setter.
Q:  Why do you need to write a constructor if the compiler writes one for you?
A: If you need code to help initialize your object and get it ready for use, you’ll have to write your own constructor.
You might, for example, be dependent on input from the user before you can finish making the object ready.
There’s another reason you might have to write a constructor, even if you don’t need any constructor code yourself.
It has to do with your superclass constructor, and we’ll talk about that in a few minutes.
Q:  How can you tell a constructor from a method? Can you also have a method that’s the same name as the class?
A: Java lets you declare a method with the same name as your class.
The thing that separates a method from a constructor is the return type.
Methods must have a return type, but constructors cannot have a return type.
Q:  Are constructors inherited? If you don’t provide a constructor but your superclass does, do you get the superclass constructor instead of the default?
Using the constructor to initialize important Duck state* If an object shouldn’t be used until one or more parts of its state (instance variables) have been initialized, don’t let anyone get ahold of a Duck object until you’re ﬁ nished initializing! It’s usually way too risky to let someone makeand get a reference to—a new Duck object that isn’t quite ready for use until that someone turns around and calls the setSize() method.
How will the Duck-user even know that he’s required to call the setter method after making the new Duck?
The best place to put initialization code is in the constructor.
And all you need to do is make a constructor with arguments.
Let the user make a new Duck and set the Duck’s size all in.
Not to imply that not all Duck state is not unimportant.
Make it easy to make a Duck Be sure you have a no-arg constructor.
What happens if the Duck constructor takes an argument? Think about it.
On the previous page, there’s only one Duck constructor—and it takes an int argument for the size of the Duck.
That might not be a big problem, but it does make it harder for a programmer to create a new Duck object, especially if the programmer doesn’t know what the size of a Duck should be.
Wouldn’t it be helpful to have a default size for a Duck, so that if the user doesn’t know an appropriate size, he can still make a Duck that works?
Imagine that you want Duck users to have TWO options for making a Duck—one where they supply the Duck size (as the constructor argument) and one where they don’t specify a size and thus get your default Duck size.
You can’t do this cleanly with just a single constructor.
Remember, if a method (or constructor—same rules) has a parameter, you must pass an appropriate argument when you invoke that method or constructor.
You can’t just say, “If someone doesn’t pass anything to the constructor, then use the default size”, because they won’t even be able to compile without sending an int argument to the constructor call.
But that means the programmer making a new Duck object has to know that passing a “0” is the protocol for getting the default Duck size.
If you don’t want zero-sized Duck objects, put validation code in the constructor to prevent it.
The point is, it might not always be possible to distinguish between a genuine “I want zero for the size” constructor argument and a “I’m sending zero so you’ll give me the default size, whatever that is” constructor argument.
To make a Duck when you do not know the size:
You really want TWO ways to make a new Duck:
If you have more than one constructor in a class, it means you have overloaded constructors.
You might think that if you write only a constructor with arguments, the compiler will see that you don’t have a no-arg constructor, and stick one in for you.
The compiler gets involved with constructormaking only if you don’t say anything at all about constructors.
If you write a constructor that takes arguments, and you still want a no-arg constructor, you’ll have to build the no-arg constructor yourself!
As soon as you provide a constructor, ANY kind of constructor, the compiler backs off and says, “OK Buddy, looks like you’re in charge of constructors now.”
If you have more than one constructor in a class, the constructors MUST have different argument lists.
The argument list includes the order and types of the arguments.
As long as they’re different, you can have more than one constructor.
You can do this with methods as well, but we’ll get to that in another chapter.
Doesn’t the compiler always make a no-arg constructor for you?
If you cannot afford a constructor, one will be provided for you by the.
Instance variables live within the object they belong to, on the Heap.
If the instance variable is a reference to an object, both the reference and the object it refers to are on the Heap.
A constructor is the code that runs when you say new on a class type.
A constructor must have the same name as the class, and must not have a return type.
If you don’t put a constructor in your class, the compiler will put in a default constructor.
If you put a constructor—any constructor—in your class, the compiler will not build the default constructor.
If you want a no-arg constructor, and you’ve already put in a constructor with arguments, you’ll have to build the no-arg constructor yourself.
Always provide a no-arg constructor if you can, to make it easy for programmers to make a working object.
Overloaded constructors means you have more than one constructor in your class.
You cannot have two constructors with the same argument lists.
Instance variables are assigned a default value, even when you don’t explicitly assign one.
The default values are 0/0.0/false for primitives, and null for references.
Four different constructors means four different ways to make a new mushroom.
Overloaded constructors means you have more than one constructor in your class.
To compile, each constructor must have a different argument list!
The class below is legal because all four constructors have different argument lists.
If you had two constructors that took only an int, for example, the class wouldn’t compile.
You can have two constructors that have identical types, as long as the order is different.
A constructor that takes a String followed by an int, is not the same as one that takes an int followed by a String.
Q:   Earlier you said that it’s good to have a no-argument constructor so that if people call the no-arg constructor, we can supply default values for the “missing” arguments.
But aren’t there times when it’s impossible to come up with defaults? Are there times when you should not have a no-arg constructor in your class?
There are times when a no-arg constructor doesn’t make sense.
You’ll see this in the Java API—some classes don’t have a no-arg constructor.
Color objects are used to, for example, set or change the color of a screen font or GUI button.
If you make a Color object, you must specify the color in some way.
We’ll get into using Color later, in the Swing chapters.
Otherwise, what would you get? The Java API programmers could have decided that if you call a no-arg Color constructor you’ll get a lovely shade of mauve.
If you try to make a Color without supplying an argument:
The compiler freaks out because it can’t find a matching noarg constructor in the Color class.
Sharpen your pencil Match the new Duck() call with the constructor that runs when that Duck is instantiated.
When you make a Dog, should the Canine constructor run too?
If the superclass is abstract, should it even have a constructor?
We’ll look at this on the next few pages, so stop now and think about the implications of constructors and superclasses.
A constructor is the code that runs when somebody says new on a class type.
A constructor must have the same name as the class, and no return type.
If you don’t put a constructor in your class, the compiler puts in a default constructor.
You can have more than one constructor in your class, as long as the argument lists are different.
Having more than one constructor in a class means you have overloaded constructors.
Doing all the Brain Barbells has been shown to produce a 42% increase in neuron size.
Constructors can be public, private, or default (which means no access modifier at all)
We’ll look more at default access in chapter 16 and appendix B.
Q:   How could a private constructor ever be useful? Nobody could ever call it, so nobody could ever make a new object!
Marking something private doesn’t mean nobody can access it, it just means that nobody outside the class can access it.
Remember from the last chapter, the part where we looked at the Snowboard object wrapping around an inner core representing the Object portion of the Snowboard class? The Big Point there was that every object holds not just its own declared instance variables, but also everything from its superclasses (which, at a minimum, means class Object, since every class extends Object)
So when an object is created (because somebody said new; there is no other way to create an object other than someone, somewhere saying new on the class type), the object gets space for all the instance variables, from all the way up the inheritance tree.
When an object is created, it’s almost as though multiple objects materialize—the object being new’d and one object per  each superclass.
Conceptually, though, it’s much better to think of it like the picture below, where the object being created has layers of itself representing each superclass.
But it contains both the Snowboard parts of itself and the Object parts of itself.
All instance variables from both classes have to be here.
Snowboard also has instance variables of its own, so to make a Snowboard object we need space for the instance variables of both classes.
Those instance variables are created when any subclass is instantiated.
All the constructors in an object’s inheritance tree must run when you make a new object.
That means every superclass has a constructor (because every class has a constructor), and each constructor up the hierarchy runs at the time an object of a subclass is created.
Although you can never say new on an abstract class, an abstract class is still a superclass, so its constructor runs when someone makes an instance of a concrete subclass.
The super constructors run to build out the superclass parts of the object.
Remember, a subclass might inherit methods that depend on superclass state (in other words, the value of instance variables in the superclass)
For an object to be fullyformed, all the superclass parts of itself must be fully-formed, and that’s why the super constructor must run.
All instance variables from every class in the inheritance tree have to be declared and initialized.
Even if Animal has instance variables that Hippo doesn’t inherit (if the variables are private, for example), the Hippo still depends on the Animal methods that use those variables.
When a constructor runs, it immediately calls its superclass constructor, all the way up the chain until you get to the class Object constructor.
On the next few pages, you’ll learn how superclass constructors are called, and how you can call them yourself.
You’ll also learn what to do if your superclass constructor has arguments!
If you want to make a Hippo, you must also make the Animal and Object parts of the Hippo.
Code from another class says new Hippo()and the Hippo() constructor goes into a stack frame at the top of the stack.
Hippo() invokes the superclass constructor which pushes the Animal() constructor  onto the top of the stack.
Object() completes, and its stack frame is popped off the stack.
Execution goes back to the Animal() constructor, and picks up at the line following Animal’s call to its superclass constructor.
Animal() invokes the superclass constructor which pushes the Object() constructor  onto the top of the stack, since Object is the superclass of Animal.
Making a Hippo means making the Animal and Object parts too...
What’s the real output? Given the code on the left, what prints out when you run TestHippo? A or B?
The Hippo() constructor is invoked first, but it’s the Animal constructor that finishes first.
And how is it that we’ve gotten away without doing it?
You might think that somewhere in, say, a Duck constructor, if Duck extends Animal you’d call Animal()
The only way to call a super constructor is by calling super()
A call to super() in your constructor puts the superclass constructor on the top of the Stack.
And what do you think that superclass constructor does? Calls its superclass constructor.
And so it goes until the Object constructor is on the top of the Stack.
Once Object() ﬁnishes, it’s popped off the Stack and the next thing down the Stack (the subclass constructor that called Object()) is now on top.
That constructor ﬁnishes and so it goes until the original constructor is on the top of the Stack, where it can now ﬁnish.
Our good friend the compiler puts in a call to super() if you don’t.
So the compiler gets involved in constructor-making in two ways:
The compiler will put a call to super() in each of your overloaded constructors.* The compiler-supplied call looks like:
The compilerinserted call to super() is always a no-arg call.
If the superclass has overloaded constructors, only the no-arg one is called.
If you do provide a constructor but you do not put in the call to super()
Unless the constructor calls another overloaded constructor (you’ll see that in a few pages)
Can the child exist before the parents? If you think of a superclass as the parent to the subclass child, you can ﬁgure out which has to exist ﬁrst.
The superclass parts of an object have to be fully-formed (completely built) before the subclass parts can be constructed.
Remember, the subclass object might depend on things it inherits from the superclass, so it’s important that those inherited things be ﬁnished.
Look at the Stack series on page 248 again, and you can see that while the Hippo constructor is the ﬁrst to be invoked (it’s the ﬁrst thing on the Stack), it’s the last one to complete! Each subclass constructor immediately invokes its own superclass constructor, until the Object constructor is on the top of the Stack.
Then Object’s constructor completes and we bounce back down the Stack to Animal’s constructor.
Only after Animal’s constructor completes do we ﬁnally come back down to ﬁnish the rest of the Hippo constructor.
The call to super() must be the ﬁrst statement in each constructor!*
There’s no way I could have been born before my parents.
These are OK because the programmer ex-plicitly coded the call to super(), as the first statement.
These are OK because the compiler will put a call to super() in as the first statement.
BAD!! This won’t compile! You can’t explicitly put the call to super() below anything else.
Superclass constructors with arguments What if the superclass constructor has arguments? Can you pass something in to the super() call? Of course.
If you couldn’t, you’d never be able to extend a class that didn’t have a no-arg constructor.
There’s a getName() method in class Animal that returns the value of the name instance variable.
The instance variable is marked private, but the subclass (in this case, Hippo) inherits the getName() method.
So here’s the problem: Hippo has a getName() method (through inheritance), but does not have the name instance variable.
Hippo has to depend on the Animal part of himself to keep the name instance variable, and return it when someone calls getName() on a Hippo object.
The constructor that takes the name and assigns it the name instance variable.
Make a Hippo, passing the name “Buffy” to the Hippo constructor.
You want whichever constructor is ﬁ rst invoked to call The Real Constructor and let The Real Constructor ﬁ nish the job of construction.
In other words, just imagine   that the keyword this is a reference to the current object.
You can say this() only within a constructor, and it must be the ﬁ rst statement in the constructor!
But that’s a problem, isn’t it? Earlier we said that super() must be the ﬁ rst statement in the constructor.
Every constructor can have a call to super() or this(), but never both!
This is The Real Constructor that does The Real Work of initializing the object (including the call to super())
Mini.java:16: call to super must be first statement in constructor.
Won’t work!! Can’t have super() and this() in the same constructor, because they each must be the first statement!
Some of the constructors in the SonOfBoo class will not.
The superclass parts of an object must be fullyformed before the new subclass object can.
Now we know how an object is born, but how long does an object live ? An object’s life depends entirely on the life of references referring to it.
If the reference is considered “alive”, the object is still alive on the Heap.
If the reference dies (and we’ll look at what that means in just a moment), the object will die.
So if an object’s life depends on the reference variable’s life, how long does a variable live? That depends on whether the variable is a local variable or an instance variable.
The code below shows the life of a local variable.
In the example, the variable is a primitive, but variable lifetime is the same whether it’s a primitive or reference variable.
A local variable lives only within the method that declared the variable.
Variable ‘s’ can be used only within the read() method.
In other words, the variable is in scope only within its own method.
No other code in the class (or any other class) can see ‘s’
An instance variable lives as long as the object does.
If the object is still alive, so are its instance variables.
Variable ‘s’ (this time a method parameter) is in scope only within the setSize() method.
But instance variable size is scoped to the life of the object as opposed to the life of the method.
The variable ‘s’ is alive, but in scope only within the.
The other three variables are alive but out of scope.
Variable ‘b’ is still alive but out of scope (until go() completes)
A local variable is alive as long as its Stack frame is on the Stack.
A local variable is in scope only within the method in which the variable was declared.
When its own method calls another, the variable is alive, but not in scope until its method resumes.
You can use a variable only when it is in scope.
As long as method doStuff() is on the Stack, for example, the ‘b’ variable keeps its value.
But the ‘b’ variable can be used only while doStuff()’s Stack frame is at the top.
In other words, you can use a local variable only while that local variable’s method is actually running (as opposed to waiting for higher Stack frames to complete)
A reference variable can be used only when it’s in scope, which means you can’t use an object’s remote control unless you’ve got a reference variable that’s in scope.
If a reference variable goes out of scope but is still alive, the object it refers to is still alive on the Heap.
If that was the only live reference to the object, the object is now abandoned on the Heap.
The reference variable     disintegrated with the Stack frame, so the abandoned object is now, ofﬁ cially, toast.
The trick is to know the point at which an object becomes eligible for garbage collection.
Once an object is eligible for garbage collection (GC), you don’t have to worry about reclaiming the memory that object was using.
If your program gets low on memory, GC will destroy some or all of the eligible objects, to keep you from running out of RAM.
You can still run out of memory, but not before all eligible objects have been hauled off to the dump.
Your job is to make sure that you abandon objects (i.e, make them eligible for GC) when you’re done with them, so that the garbage collector has something to reclaim.
If you hang on to objects, GC can’t help you and you run the risk of your program dying a painful out-of-memory death.
An object’s life has  no value, no meaning, no point, unless somebody has a reference to it.
If you can’t get to it, you can’t ask it to do anything and it’s just a big fat waste of bits.
But if an object is unreachable, the Garbage Collector will ﬁ gure that out.
An object becomes eligible for GC when its last live reference disappears.
The object is created on the Heap, and the reference is alive and in scope.
Its frame disintegrates, so ‘d’ is now dead and gone.
The ‘d’ variable went away when the barf() Stack frame was blown off the stack, so the Duck is abandoned.
Duck will live as long as the ReRef o bject.
Duck will live as long as the ReRef o bject.
Instance Variable I’d like to go ﬁrst, because I tend to be more important to a program than a local variable.
I’m there to support an object, usually throughout the object’s entire life.
After all, what’s an object without state? And what is state? Values kept in instance variables.
No, don’t get me wrong, I do understand your role in a method, it’s just that your life is so short.
What are you doing while the other methods are running and you’re waiting for your frame to be the top of the Stack again?
I appreciate your point of view, and I certainly appreciate the value of object state and all, but I don’t want folks to be misled.
To use your phrase, “After all, what’s an object without behavior?” And what is behavior? Algorithms in methods.
And you can bet your bits there’ll be some local variables in there to make those algorithms work.
Within the local-variable community, the phrase “temporary variable” is considered derogatory.
Anyway, it’s true that we don’t have a long life, and it’s not a particularly good life either.
First, we’re shoved into a Stack frame with all the other local variables.
And then, if the method we’re part of calls another method, another frame is pushed on top of us.
Sometimes we have to wait forever for all the other methods on top of the Stack to complete so that our method can run again.
It’s like being in stasis—that thing they do to people in science ﬁction movies when they have to travel long distances.
As long as our frame is still there, we’re safe and the value we hold is secure, but it’s a mixed blessing when our.
Tonight’s Talk: An instance variable and a local variable discuss life and death (with remarkable civility)
I mean, when that method hits its ending curly brace, the frame is literally blown off the Stack! Now that’s gotta hurt.
I have to admit life can be pretty luxurious on the Heap.
A lot of us feel guilty, especially around the holidays.
OK, hypothetically, yes, if I’m an instance variable of the Collar and the Collar gets GC’d, then the Collar’s instance variables would indeed be tossed out like so many pizza boxes.
On the one hand, we get to be active again.
On the other hand, the clock starts ticking again on our short lives.
The more time our method spends running, the closer we get to the end of the method.
In computer science they use the term popped as in “the frame was popped off the Stack”
That makes it sound fun, or maybe like an extreme sport.
So why don’t we talk about you? I know what my little Stack frame looks like, but where do you live?
But you don’t always live as long as the object who declared you, right? Say there’s a Dog object with a Collar instance variable.
Imagine you’re an instance variable of the Collar object, maybe a reference to a Buckle or something, sitting there all happy inside the Collar object who’s all happy inside the Dog object.
And you believed it? That’s what they say to keep us motivated and productive.
But aren’t you forgetting something else? What if you’re an instance variable inside an object, and that object is referenced only by a local variable? If I’m the only reference to the object you’re in, when I go, you’re coming with me.
So I say we forget about all this and go get drunk while we still can.
Which of the lines of code on the right, if added to the class on the left at point A, would cause exactly one additional object to be eligible for the.
Your challenge is to find the object that is  ‘most popular’, i.e.
Then list how many total references there are for that object, and what they are!  We’ll start by pointing out one of the new objects, and its reference variable.
What did Tom suspect?  How could he guess the power readings errors, and what few lines of code could you add to help debug this program?
It probably wasn’t too hard to ﬁgure out that the Honey object ﬁrst referred to by the honeyPot variable is by far the most ‘popular’ object in this class.
But maybe it was a little trickier to see that all of the variables that point from the code to the Honey object refer to the same object!   There are a total of 12 active references to this object right before the main( ) method completes.
The k.kh variable is valid for a while, but k gets nulled at the end.
Since r.k still refers to the Kit object,  r.k.kh (although never explicity declared), refers to the object!
No - this line attempts to access a variable that is out of scope.
Since all the Bot classes create SimUnits, writing a constructor for the SimUnit class, that printed out a line everytime a SimUnit was created, would have quickly highlighted the problem!
But there’s more to working with numbers than just doing primitive arithmetic.
You might want to get the absolute value of a number, or round a number, or find.
You might want your numbers to print with exactly two decimal.
And what about working with dates? You might want to print dates in a variety of ways, or even.
Methods in the Math class don’t use any instance variable values.
And because the methods are ‘static’, you don’t need to have an instance of Math.
But think about this: what if you have a method whose behavior doesn’t depend on an instance variable value.
Take the round() method in the Math class, for example.
It does the same thing every time—rounds a ﬂoating point number(the argument to the method) to the nearest integer.
In other words, the method acts on the argument, but is never affected by an instance variable state.
The only value that changes the way the round() method runs is the argument passed to the method!
Doesn’t it seem like a waste of perfectly good heap space to make an instance of class Math simply to run the round() method? And what about other Math methods like min(), which takes two numerical primitives and returns the smaller of the two.
Or abs(), which returns the absolute value of a number.
In fact the Math class doesn’t have any instance variables.
So there’s nothing to be gained by making an instance of class Math.
This error shows that the Math constructor is marked private! That means you can NEVER say ‘new’ on the Math class to make a new Math object.
If you try to make an instance of class Math:
These methods never use instance variables, so their behavior doesn’t need to know about a specific object.
The difference between regular (non-static) and static methods Java is object-oriented, but once in a while you have a special case, typically a utility method (like the Math methods), where there is no need to have an instance of the class.
The keyword static lets a method run without any instance of the class.
Calling play() on this reference will cause “My Way” to play.
What it means to have a class with static methods.
Often (although not always), a class with static methods is not meant to be instantiated.
In other words, it’s impossible to instantiate an abstract class.
But you can restrict other code from instantiating a non-abstract class by marking the constructor private.
Remember, a method marked private means that only code from within the class can invoke the method.
A constructor marked private means essentially the same thing—only code from within the class can invoke the constructor.
That’s how it works with the Math class, for example.
The constructor is private, you cannot make a new instance of Math.
The compiler knows that your code doesn’t have access to that private constructor.
This does not mean that a class with one or more static methods should never be instantiated.
In fact, every class you put a main() method in is a class with a static method in it!
Typically, you make a main() method so that you can launch or test another class, nearly always by instantiating a class in main, and then invoking a method on that new instance.
So you’re free to combine static and non-static methods in a class, although even a single non-static method means there must be some way to make an instance of the class.
The only ways to get a new object are through ‘new’ or deserialization (or something called the Java Reﬂ ection API that we don’t go into)
But exactly who says new can be an interesting question, and one we’ll look at a little later in this chapter.
Static methods can’t use non-static (instance) variables! Static methods run without knowing about any particular instance of the static method’s class.
And as you saw on the previous pages, there might not even be any instances of that class.
Since a static method is called using the class (Math.random()) as opposed to an instance reference (t2.play()), a static method can’t refer to any instance variables of the class.
The static method doesn’t know which instance’s variable value to use.
If you try to use an instance variable from inside a static method, the compiler thinks, “I don’t know   which object’s instance variable you’re talking about!” If you have ten Duck objects on the heap, a static method doesn’t know about any of them.
No, I’m pretty sure they’re talking about MY size variable.
Duck.java:6: non-static variable size cannot be referenced from a static context.
If there’s a Duck on the heap somewhere, we don’t know about it.
Static methods can’t use non-static methods, either! What do non-static methods do? They usually use instance variable state to affect the behavior of the method.
A getName() method returns the value of the name variable.
Whose name? The object used to invoke the getName() method.
Duck.java:6: non-static method getSize() cannot be referenced from a static context.
Q: What if you try to call a non-static method from a static method, but the non-static method doesn’t use any instance variables.
The compiler knows that whether you do or do not use instance variables in a non-static method, you can.
Q: I could swear I’ve seen code that calls a static method using a reference variable instead of the class name.
A: You can do that, but as your mother always told you, “Just because it’s legal doesn’t mean it’s good.” Although it works to call a static method using any instance of the class, it makes for misleading (lessreadable) code.
This code is legal, but the compiler just resolves it back to the real class anyway (“OK,  d is of type Duck, and main() is static, so I’ll call the static main() in class Duck”)
In other words, using d to invoke main() doesn’t imply that main() will have any special knowledge of the object that d is referencing.
It’s just an alternate way to invoke a static method, but the method is still static!
Each Duck object has its own size variable, but there’s only one copy of the duckCount variable—the one in the class.
Static variable: value is the same for ALL instances of the class Imagine you wanted to count how many Duck instances are being created while your program is running.
How would you do it? Maybe an instance variable that you increment in the constructor?
No, that wouldn’t work because duckCount is an instance variable, and starts at 0 for each Duck.
You could try calling a method in some other class, but that’s kludgey.
You need a class that’s got only a single copy of the variable, and all instances share that one copy.
That’s what a static variable gives you: a value shared by all instances of a class.
In other words, one value per class, instead of one value per instance.
Earlier in this chapter, we saw that a private constructor means that the class can’t be instantiated from code running outside the class.
In other words, only code from within the class can make a new instance of a class with a private constructor.
What if you want to write a class in such a way that only ONE instance of it can be created,  and anyone who wants to use an instance of the class will always use that one, single instance?
All instances of the same class share a single copy of the static variables.
Initializing a static variable Static variables are initialized when a class is loaded.
A class is loaded because the JVM decides it’s time to load it.
Typically, the JVM loads a class because somebody’s trying to make a new instance of the class, for the ﬁrst time, or use a static method or variable of the class.
As a programmer, you also have the option of telling the JVM to load a class, but you’re not likely to need to do that.
In nearly all cases, you’re better off letting the JVM decide when to load the class.
Static variables in a class are initialized before any object of that class can be created.
Static variables in a class are initialized before any static method of the class runs.
If you don’t explicitly initialize a static variable (by assigning it a value at the time you declare it), it gets a default value, so int variables are initialized to zero, which means we didn’t need to explicitly say “playerCount = 0”
Declaring, but not initializing, a static variable means the static variable will get the default value for that variable type, in exactly the same way that instance variables are given default values when declared.
All static variables in a class are initialized before any object of that class can be created.
The playerCount is initialized when th e class is loaded.
We explicitly initialized it to 0, but w e don’t need.
Static variables get default values just like instan ce variables.
In other words, the value of the static ﬁnal variable will stay the same as long as the class is loaded.
The variable is marked public so that any code can access it.
The variable is marked static so that you don’t need an instance of class Math (which, remember, you’re not allowed to create)
The variable is marked ﬁnal because PI doesn’t change (as far as Java is concerned)
There is no other way to designate a variable as a constant, but there is a naming convention that helps you to recognize one.
If you don’t give a value to a ﬁnal variable in one of those two places:
A f inal variable means you can’t change its value.
A f inal method means you can’t override the method.
You can use the keyword ﬁnal to modify nonstatic variables too, including instance variables, local variables, and even method parameters.
In each case, it means the same thing: the value can’t be changed.
But you can also use ﬁnal to stop someone from overriding a method or making a subclass.
A non-static method in a class can always call a static method in the class or access a static variable of the class.
Q: Why would I want to make a class ﬁnal? Doesn’t that defeat the whole purpose of OO?
A typical reason for making a class final is for security.
You can’t, for example, make a subclass of the String class.
Imagine the havoc if someone extended the String class and substituted their own String subclass objects, polymorphically, where String objects are expected.
If you need to count on a particular implementation of the methods in a class, make the class final.
Q: Isn’t it redundant to have to mark the methods ﬁnal if the class is ﬁnal?
A: If the class is final, you don’t need to mark the methods final.
Think about it—if a class is final it can never be subclassed, so none of the methods can ever be overridden.
On the other hand, if you do want to allow others to extend your class, and you want them to be able to override some, but not all, of the methods, then don’t mark the class final but go in and selectively mark specific methods as final.
A final method means that a subclass can’t override that particular method.
There is only one copy of a static variable in a class, rather than one copy per each individual instance for instance variables.
What’s Legal? Given everything you’ve just learned about static and ﬁnal, which of these would compile?
Math methods Now that we know how static methods work, let’s look at some static methods in class Math.
Check your API for the rest including sqrt(), tan(), ceil(), ﬂoor(), and asin()
Math.abs() Returns a double that is the absolute value of the argument.
The method is overloaded, so if you pass it an int it returns an int.
Math.round() Returns an int or a long (depending on whether the argument is a ﬂoat or a double) rounded to the nearest integer value.
Remember, floating point literals are assumed to be doubles unless you add the ‘f’
Returns a value that is the minimum of the two arguments.
The method is overloaded to take ints, longs, ﬂoats, or doubles.
Math.max() Returns a value that is the maximum of the two arguments.
The method is overloaded to take ints, longs, ﬂoats, or doubles.
Wrapping a primitive Sometimes you want to treat a primitive like an object.
For example, in all versions of Java prior to 5.0, you cannot put a primitive directly into a collection like ArrayList or HashMap:
When you need to treat a primitive like an object, wrap it.
If you’re using any version of Java before 5.0, you’ll do this when you need to store a primitive value inside a collection like ArrayList or HashMap.
This won’t work unless you’re using Jav a 5.0 or.
There’s a wrapper class for every primitive type, and since the wrapper classes are in the  java.
You can recognize wrapper classes because each one is named after the primitive type it wraps, but with the ﬁrst letter capitalized to follow the class naming convention.
Oh yeah, for reasons absolutely nobody on the planet is certain of, the API designers decided not to map the names exactly from primitive type to class type.
Watch out! The names aren’t mapped exactly to the primitive.
Note: the picture at the top is a chocolate in a foil wrapper.
Get it? Wrapper? Some people think it looks like a baked potato, but that works too.
In all versions of Java prior to 5.0, primitives were primitives and object references were object references, and they were NEVER treated interchangeably.
It was always up to you, the programmer, to do the wrapping and unwrapping.
There was no way to pass a primitive to a method expecting an object reference, and no way to assign the result of a method returning an object reference directly to a primitive variable—even when the returned reference is to an Integer and the primitive variable is an int.
There was simply no relationship between an Integer and an int, other than the fact that Integer has an instance variable of type int (to hold the primitive the Integer wraps)
You mean I can’t just make an ArrayList of ints??? I.
You can’t add the p rimitive ‘3’ to the l.
Finally you can get the primitive out of the Integer.
Just add it! Although there is NOT a method in ArrayList for add(int), the compiler does all the wrapping (boxing) for you.
In other words, there really IS an Integer object stored in the ArrayList, but you get to “pretend” that the ArrayList takes ints.
You can add both ints and Integers to an ArrayList<Integer>
And the compiler automatically unwraps (unboxes) the Integer object so you can assign the int value directly to a primitive without having to call the intValue() method on the Integer object.
Autoboxing: blurring the line between primitive and object The autoboxing feature added to Java 5.0 does the conversion from primitive to wrapper object automatically!
Let’s see what happens when we want to make an ArrayList to hold ints.
Q: Why not declare an ArrayList<int> if you want to hold ints?
Remember, the rule for generic types is that you can specify only class or interface types, not primitives.
But as you can see from the code above, it doesn’t really matter, since the compiler lets you put ints into the ArrayList<Integer>
In fact, there’s really no way to prevent you from putting primitives into an ArrayList where the type of the list is the type of that primitive’s wrapper, if you’re using a Java 5.0-compliant compiler, since autoboxing will happen automatically.
Autoboxing works almost everywhere Autoboxing lets you do more than just the obvious wrapping and unwrapping to use primitives in a collection...
If a method takes a wrapper type, you can pass a reference to a wrapper or a primitive of the matching type.
And of course the reverse is true—if a method takes a primitive, you can pass in either a compatible primitive or a reference to a wrapper of that primitive type.
If a method declares a primitive return type, you can return either a compatible primitive or a reference to the wrapper of that primitive type.
And if a method declares a wrapper return type, you can return either a reference to the wrapper type or a primitive of the matching type.
This is probably the strangest one—yes, you can now use a wrapper type as an operand in operations where the primitive type is expected.
That means you can apply, say, the increment operator against a reference to an Integer object!
The language wasn’t modiﬁed to make the operators work on objects; the compiler simply converts the object to its primitive type before the operation.
You can assign either a wrapper or primitive to a variable declared as a matching wrapper or primitive.
For example, a primitive int variable can be assigned to an Integer reference variable, and vice-versa—a reference to an Integer object can be assigned to a variable declared as an int primitive.
Will this code compile? Will it run? If it runs, what will it do?
Take your time and think about this one; it brings up an implication of autoboxing that we didn’t talk about.
You’ll have to go to your compiler to find the answers.
Yes, we’re forcing you to experiment, for your own good of course.
But wait! There’s more! Wrappers have static utility methods too! Besides acting like a normal class, the wrappers have a bunch of really useful static methods.
The parse methods take a String and give you back a primitive value.
This compiles just fine, but at runtime it blows up.
It’s a runtime exception, so you don’t have to handle or declare it.
The easiest is to simply concatenate the number to an existing String.
Another way to do it using a static method in class Double.
Where’s my printf like I have in C? Is number formatting part of the I/O classes?
Number formatting In Java, formatting numbers and dates doesn’t have to be coupled with I/O.
One of the most typical ways to display numbers to a user is through a GUI.
You put Strings into a scrolling text area, or maybe a table.
If formatting was built only into print statements, you’d never be able to format a number into a nice String to display in a GUI.
Before Java 5.0, most formatting was handled through classes in the java.text package that we won’t even look at in this version of the book, now that things have changed.
In Java 5.0, the Java team added more powerful and ﬂexible formatting through a Formatter class in java.util.
But you don’t need to create and call methods on the Formatter class yourself, because Java 5.0 added convenience methods to some of the I/O classes (including printf()) and the String class.
So it’s a simple matter of calling a static String.format() method and passing it the thing you want formatted along with formatting instructions.
Of course, you do have to know how to supply the formatting instructions, and that takes a little effort unless you’re familiar with the printf() function in C/C++
Fortunately, even if you don’t know printf() you can simply follow recipes for the most basic things (that we’re showing in this chapter)
But you will want to learn how to format if you want to mix and match to get anything you want.
We’ll start here with a basic example, then look at how it works.
The formatting instructions for how to format the second argument (which in this case is an int value)
Remember, there are only two arguments to this method here—the first comma is INSIDE the String literal, so it isn’t separating arguments to the format method.
At the most basic level, formatting consists of two main parts (there is more, but we’ll start with this to keep it cleaner):
You use special format specifiers that describe how the argument should be formatted.
Although there can be more than one argument, we’ll start with just one.
For example, if your formatting instructions specify a floating point number, you can’t pass in a Dog or even a String that looks like a floating point number.
On the next page we’ll look in more detail at what the syntax “%, d” actually means, but for starters, any time you see the percent sign (%) in a format String (which is always the ﬁrst argument to a format() method), think of it as representing a variable, and the variable is the other argument to the method.
The rest of the characters after the percent sign describe the formatting instructions for the argument.
The percent (%) says, “insert argument here” (and format it using these instructions)
The ﬁrst argument to a format() method is called the format String, and it can actually include characters that you just want printed as-is, without extra formatting.
When you see the % sign, though, think of the percent sign as a variable that represents the other argument to the method.
Format specifiers for the second argument to the method (the number)
More characters to include in the String after the second argument is formatted and inserted.
The “%” sign tells the formatter to insert the other method argument (the second argument to format(), the number) here, AND format it using the.
Then the rest of the format String, “bugs to ﬁx”, is added to the ﬁnal output.
Notice we lost some of the numbers after the decimal point.
The format String uses its own little language syntax You obviously can’t put just anything after the “%” sign.
The syntax for what goes after the percent sign follows very speciﬁc rules, and describes how to format the argument that gets inserted at that point in the result (formatted) String.
The real question is really, “How do I know what to put after the percent sign to get it to do what I want?” And that includes knowing the symbols (like “d” for decimal and “f” for ﬂoating point) as well as the order in which the instructions must be placed following the percent sign.
For example, if you put the comma after the “d” like this: “%d,” instead of “%,d” it won’t work!
Or will it? What do you think this will do:
But how does it even KNOW where the instructions end and the.
After the type indicator, the formatter assumes the next set of characters are meant to be part of the output String, until or unless it hits another percent (%) sign.
For now, let’s look at the syntax for the format speciﬁers—the things that go after the percent (%) sign and describe how the argument should be formatted.
A format speciﬁer can have up to ﬁve different parts (not including the “%”)
Everything in brackets [ ] below is optional, so only the percent (%) and the type are required.
But the order is also mandatory, so any parts you DO use must go in this order.
This defines the MINIMUM number of characters that will be used.
If the number is longer than the width, it’ll still be used in full, but if it’s less than the width, it’ll be padded with zeroes.
In other words, it sets the number of decimal  places.
There’s no “argument number” specified in this format String, but all the other pieces are there.
The only required specifier is for TYPE Although type is the only required speciﬁer, remember that if you do put in anything else, type must always come last! There are more than a dozen different type modiﬁers (not including dates and times; they have their own set), but most of the time you’ll probably use %d (decimal) or %f (ﬂoating point)
And typically you’ll combine %f with a precision indicator to set the number of decimal places you want in your output.
The argument must be compatible with an int, so that means only byte, short, int, and char (or their wrapper types)
The argument must be of a ﬂoating point type, so that means only a ﬂoat or double (primitive or wrapper) as well as something called BigDecimal (which we don’t look at in this book)
A 42.25 would not work! It would be the same as trying to directly assign a double to an int variable.
The argument must be a byte, short, int, long (including both primitive and wrapper types), and BigInteger.
You must include a type in your format instructions, and if you specify things besides type, the type must always come last.
Most of the time, you’ll probably format numbers using either “d” for decimal or “f” for f loating point.
The argument must be a byte, short, char, or int (including both primitive and wrapper types)
What happens if I have more than one argument? Imagine you want a String that looks like this:
What do you do? You simply add two arguments after the format String (ﬁrst argument), so that means your call to format() will have three arguments instead of two.
And inside that ﬁrst argument (the format String), you’ll have two different format speciﬁers (two things that start with “%”)
The ﬁrst format speciﬁer will insert the second argument to the  method, and the second format speciﬁer will insert the third argument to the method.
In other words, the variable insertions in the format String use the order in which the other arguments are passed into the format() method.
When you have more than one argument, they’re inserted using the order in which you pass them to the format() method.
As you’ll see when we get to date formatting, you might actually want to apply different formatting speciﬁers to the same argument.
That’s probably hard to imagine until you see how date formatting (as opposed to the number formating we’ve been doing) works.
Just know that in a minute, you’ll see how to be more speciﬁc about which format speciﬁers are applied to which arguments.
We added commas to both variables, and restricted the floating point number (the second variable) to two decimal places.
Just how many arguments can I pass? I mean, how many overloaded format() methods are IN the String class? So, what happens if I want to pass, say, ten different arguments to be formatted for a single output String?
Yes, there is something strange (or at least new and different) going on, and no there are not a bunch of overloaded format() methods to take a different number of possible arguments.
In order to support this new formatting (printf-like) API in Java, the language needed another new feature—variable argument lists (called varargs for short)
We’ll talk about varargs only in the appendix because outside of formatting, you probably won’t use them much in a welldesigned system.
Nothing special there, you say? Well, imagine that all you have to start with is a variable of type Date—A Java class that can represent a timestamp, and now you want to take that object (as opposed to a number) and send it through the formatter.
The main difference between number and date formatting is that date formats use a two-character type that starts with “t” (as opposed to the single character “f” or “d”, for example)
The examples below should give you a good idea of how it works:
Day of the week, month and day   %tA  %tB  %td.
Same as above, but without duplicating the arguments  %tA  %tB  %td.
There isn’t a single format speciﬁer that will do exactly what we want, so we have to combine three of them for day of the week (%tA), month (%tB), and day of the month (%td)
But that means we have to pass the Date object in three times, one for each part of the format that we want.
In other words, the %tA will give us just the day of the week, but then we have to do it again to get just the month and again for the day.of the month.
The angle-bracket “<” is just another flag in the specifier that tells the formatter to “use the previous argument again.” So it saves you from repeating the arguments, and instead you format the same argument three different ways.
You can think of this as kind of like calling three different getter  methods on the Date object, to get three different pieces of data from it.
Working with Dates You need to do more with dates than just get today’s date.
You need your programs to adjust dates, ﬁnd elapsed times, prioritize schedules, heck, make schedules.
The good news is that the Java API is rich with classes that can help you manipulate dates.
Moving backward and forward in time Let’s say your company’s work schedule is Monday through Friday.
You’ve been assigned the task of ﬁguring out the last work day in each calendar month this year...
Earlier we used java.util.Date to ﬁnd today’s date, so it seems logical that this class would be a good place to start looking for some handy date manipulation capabilities, but when you check out the API you’ll ﬁnd that most of Date’s methods have been deprecated!
The Date class is still great for getting a “time stamp”—an object that represents the current date and time, so use it when you want to say, “give me NOW”
The designers of the Calendar API wanted to think globally, literally.
The basic idea is that when you want to work with dates, you ask for a Calendar (through a static method of the Calendar class that you’ll see on the next page), and the JVM hands you back an instance of a concrete subclass of Calendar.
Calendar is actually an abstract class, so you’re always working with a concrete subclass.
More interesting, though, is that the kind of calendar you get back will be appropriate for your locale.
Much of the world uses the Gregorian calendar, but if you’re in an area that doesn’t use a Gregorian calendar you can get Java libraries to handle other calendars such as Buddhist, or Islamic or Japanese.
For the most part, though, you don’t even have to think about the kind of Calendar subclass you’re using, and instead focus only on the methods of the Calendar class.
Getting an object that extends Calendar How in the world do you get an “instance” of an abstract class? Well you don’t of course, this won’t work:
You can’t get an instance of Calendar, but you can can get an instance of a concrete Calendar subclass.
Obviously you can’t get an instance of Calendar, because Calendar is abstract.
But you’re still free to call static methods on Calendar, since static methods are called on the class, rather than on a particular instance.
So you call the static getInstance() on Calendar and it gives you back...
Something that extends Calendar (which means it can be polymorphically assigned to Calendar) and which—by contract—can respond to the methods of class Calendar.
This syntax should look familiar at this point - we’re invoking a static method.
Working with Calendar objects There are several key concepts you’ll need to understand in order to work with Calendar objects:
For instance, you can get and set a Calendar’s year or month.
Add 35 days to the date, which should move us into February.
This “rolls” the date ahead 35 days, but DOES NOT change the month !
We’re not incrementing here, just doing a “set” of the date.
Add an hour’s worth of millis, then update the time.
This output confirms how millis, add, roll, and set work.
Highlights of the Calendar API We just worked through using a few of the ﬁ elds and methods in the Calendar class.
This is a big API, so we’re showing only a few of the most common ﬁ elds and methods that you’ll use.
Once you get a few of these it should be pretty easy to bend the rest of the this API to your will.
A common variety of set to set a comp lete time.
If you hate to type, you might just like this feature.
The downside to static imports is that - if you’re not careful - using them can make your code a lot harder to read.
The basic idea is that whenever you’re using a static class, a static variable, or an enum (more on those later), you can import them, and save yourself some typing.
For example, if you have two different classes with an “add()” method, how will you and the compiler know which one to use?
Use Carefully: static imports can make your code confusing to read.
Instance Variable I don’t even know why we’re doing this.
And how many of those are there? I think the whole API must have, what, four? And it’s not like anybody ever uses them.
OK, so there are a few in the Swing library, but everybody knows Swing is just a special case.
Ok, but besides a few GUI things, give me an example of just one static variable that anyone would actually use.
When was the last time you looked at the API? It’s frickin’ loaded with statics! It even has entire classes dedicated to holding constant values.
There’s a class called SwingConstants, for example, that’s just full of them.
It might be a special case, but it’s a really important one! And what about the Color class? What a pain if you had to remember the RGB values to make the standard colors? But the color class already has constants deﬁned for blue, purple, white, red, etc.
How’s System.out for starters? The out in System.out is a static variable of the System class.
You personally don’t make a new instance of the System, you just ask the System class for its out variable.
And here’s something that probably never crossed your narrow mind—let’s face it, static variables are more efﬁcient.
Tonight’s Talk: An instance variable takes cheap shots at a static variable.
Static variables are about as un-OO as it gets!! Gee why not just go take a giant backwards step and do some procedural programming while we’re at it.
You’re like a global variable, and any programmer worth his PDA knows that’s usually a Bad Thing.
Yeah you live in a class, but they don’t call it Class-Oriented programming.
Something to help the old-timers make the leap to java.
Well, OK, every once in a while sure, it makes sense to use a static, but let me tell you, abuse of static variables (and methods) is the mark of an immature OO programmer.
A designer should be thinking about object state, not class state.
Static methods are the worst things of all, because it usually means the programmer is thinking procedurally instead of about objects doing things based on their unique object state.
I live in a class! That’s pretty OO you know, a CLASS.
I’m not just sitting out there in space somewhere; I’m a natural part of the state of an object; the only difference is that I’m shared by all instances of a class.
And even the ones that aren’t crucial sure are handy.
Why do you say that? And what’s wrong with static methods?
Sure, I know that objects should be the focus of an OO design, but just because there are some clueless programmers out there...
There’s a time and place for statics, and when you need one, nothing else beats it.
Your job is to play compiler and determine whether this file will compile.
If it won’t compile, how would you fix it, and if it does compile, what would be its output?
Your job is to decide whether each of the following statements is true or false.
To use the Math class, the ﬁrst step is to make an instance of it.
Static methods don’t have access to instance variable state of the ‘this’ object.
It is good practice to call a static method using a reference variable.
Static variables could be used to count the instances of a class.
MAX_SIZE would be a good name for a static ﬁnal variable.
A static initializer block runs before a class’s constructor runs.
If a class is marked ﬁnal, all of its methods must be marked ﬁnal.
A ﬁnal method can only be overridden if its class is extended.
A wrapper is used when you want to treat a primitive like an object.
This one might actually be useful! In addition to what you’ve learned in the last few pages about manipulating dates, you’ll need a little more information...
Your job is to reconstruct the code  snippets to make a working Java program that produces the output listed below (plus more full moon dates)
You might not need all of the magnets, and add all the curly braces you need.
Oh, by the way, your output will be different if you don’t live in the mountain time zone.
StaticSuper is a constructor, and must have ( ) in its signature.
Notice that as the output below demonstrates, the static blocks for both classes run before either of the constructors run.
You might discover that a few of the dates produced by this program are off by a day.
This astronomical stuff is a little tricky, and if we made it perfect, it would be too complex to make an exercise here.
Hint: one problem you might try to solve is based on differences in time zones.
No matter how good a programmer you are, you can’t control everything.
When you write a risky method, you need code to handle the bad things that might happen.
But how do you know when a method is risky? And where do you put the code to handle the.
Because in this chapter, we’re going to build something that uses the risky JavaSound.
Let’s make a Music Machine Over the next three chapters, we’ll build a few different sound applications, including a BeatBox Drum Machine.
In fact, before the book is done, we’ll have a multi-player version so you can send your drum loops to another player, kind of like a chat room.
You’re going to write the whole thing, although you can choose to use Ready-bake code for the GUI parts.
OK, so not every IT department is looking for a new BeatBox server, but we’re doing this to learn more about Java.
Building a BeatBox is just a way to have fun while we’re learning Java.
At any time, you can “capture” one of your own patterns by sending it to the BeatBox server (which means any other players can listen to it)
You can also load any of the incoming patterns by clicking on the message that goes with it.
You make a beatbox loop (a 16-beat drum pattern) by putting checkmarks in the boxes.
Obviously we’ve got a few things to learn before the whole program is ﬁnished, including how to build a Swing GUI, how to connect to another machine via networking, and a little I/O so we can send something to the other machine.
For now, you can forget the GUI, forget the networking and the I/O, and focus only on getting some MIDI-generated sound to come out of your computer.
And don’t worry if you don’t know a thing about MIDI, or a thing about reading or making music.
The JavaSound API JavaSound is a collection of classes and interfaces added to Java starting with version 1.3
These aren’t special add-ons; they’re part of the standard J2SE class library.
But for our BeatBox app, you can think of MIDI as a kind of sheet music that you feed into some device you can think of like a high-tech ‘player piano’
In other words, MIDI data doesn’t actually include any sound, but it does include the instructions that a MIDI-reading instrument can play back.
For the actual sound, we need an instrument (a MIDI device) that can read and play a MIDI ﬁle.
But the device is usually more like an entire band or orchestra of instruments.
And that instrument might be a physical device, like the electronic keyboard synthesizers the rock musicians play, or it could even be an instrument built entirely in software, living in your computer.
For our BeatBox, we use only the built-in, software-only instrument that you get with Java.
It’s called a synthesizer (some folks refer to it as a software synth) because it creates sound.
The device might be a synthesizer keyboard or some other kind of instrument.
So a MIDI file isn’t like sheet music for just one musician in the band -- it can hold the parts for ALL the musicians playing a particular song.
First we need a Sequencer Before we can get any sound to play, we need a Sequencer object.
The sequencer is the object that takes all the MIDI data and sends it to the right instruments.
A sequencer can do a lot of different things, but in this book, we’re using it strictly as a playback device.
Like a CD-player on your stereo, but with a few added features.
So let’s start by making sure we can make (or get) a Sequencer object.
This code won’t compile! The compiler says there’s an ‘unreported exception’  that must be caught or declared.
Let’s say you want to call a method in a class that you didn’t write.
That method does something risky, something that might not work at runtime.
You need to know that the method you’re calling is risky.
What happens when a method you want to call (probably in a class you didn’t write) is risky?
You then write code that can handle the failure if it does happen.
A method has to declare the exceptions it might throw.
This part tells you WHEN you might get that exception -- in this case, because of resource restrictions (which could just means the sequencer is already being used)
Java’s exception-handling mechanism is a clean, well-lighted way to handle “exceptional situations” that pop up at runtime; it lets you put all your error-handling code in one easy-to-read place.
If you know you might get an exception when you call a particular method, you can be prepared for—possibly even recover from—the problem that  caused the exception.
So, how do you know if a method throws an exception?  You ﬁ nd a throws clause in the risky method’s declaration.
So it must  ‘declare’ the risk you take when you call it.
The compiler needs to know that YOU know you’re calling a risky method.
If you wrap the risky code in something called a try/catch, the compiler will relax.
A try/catch block tells the compiler that you know an exceptional thing could happen in the method you’re calling, and that you’re prepared to handle it.
That compiler doesn’t care how you handle it; it cares only that you say you’re taking care of it.
Dear Compiler, I know I’m taking a risk here, but don’t you think it’s worth it? What should I do?
But just in case things don’t work out, be sure to catch any problems before all hell breaks loose.
Which is fortunate, because it would be much harder to remember if exceptions were of type Broccoli.
Remember from your polymorphism chapters that an object of type Exception can be an instance of any subclass of Exception.
Because an Exception is an object, what you catch is an object.
In the following code, the catch argument is declared as type Exception, and the parameter reference variable is ex.
What you write in a catch block depends on the exception that was thrown.
For example, if a server is down you might use the catch block to try another server.
If the ﬁ le isn’t there, you might ask the user for help ﬁ nding it.
If it’s your code that catches the exception, then whose code throws it? You’ll spend much more of your Java coding time handling exceptions than you’ll spend creating and throwing them yourself.
For now, just know that when your code calls a risky method—a method that declares an exception—it’s the risky  method that throws the exception back to you, the caller.
In reality, it might be you who wrote both classes.
When somebody writes code  that could throw an exception, they must declare the exception.
The method that throws has to declare that it might throw the exception.
If you can’t recover from the exception, at LEAST get a stack trace using the printStackTrace() method that all exceptions inherit.
A: The compiler cares about all subclasses of Exception, unless they are a special type, RuntimeException.
Any exception class that extends RuntimeException gets a free pass.
RuntimeExceptions can be thrown anywhere, with or without throws declarations or try/catch blocks.
The compiler doesn’t bother checking whether a method declares that it throws a RuntimeException, or whether the caller acknowledges that they might get that exception at runtime.
A: Most RuntimeExceptions come from a problem in your code logic, rather than a condition that fails at runtime in ways that you cannot predict or prevent.
But you can make sure your code doesn’t index off the end of an array (that’s what the .length attribute is for)
You WANT RuntimeExceptions to happen at development and testing time.
You don’t want to code in a try/catch, for example, and have the overhead that goes with it, to catch something that shouldn’t happen in the first place.
A try/catch is for handling exceptional situations, not flaws in your code.
Use your catch blocks to try to recover from situations you can’t guarantee will succeed.
Or at the very least, print out a message to the user and a stack trace, so somebody can figure out what happened.
Exceptions that are NOT subclasses of RuntimeException are checked for by the compiler.
If you throw an exception in your code you must declare it using the throws keyword in your method declaration.
If you call a method that throws an exception (in other words, a method that declares it throws an exception), you must acknowledge that you’re aware of the exception possibility.
One way to satisfy the compiler is to wrap the call in a try/catch.
There’s a second way we’ll look   at a little later in this chapter.
A RuntimeException does not have to be declared or wrapped in a try/catch (although you’re free to do either or both of those things)
All other exceptions must be acknowledged in your code, according to the rules.
We’ll talk about ducking a little later in this chapter.
Which of these do you think might throw an exception that the compiler would care about? We’re only looking for the things that you can’t control in your code.
When you call a risky method, one of two things can happen.
The risky method either succeeds, and the try block completes, or the risky method throws an exception back to your calling method.
If the try succeeds (doRiskyThing() does not throw an exception)
If the try fails (because doRiskyThing() does throw an exception)
If you try to cook something, you start by turning on the oven.
If the thing you try is a complete failure, you have to turn off the oven.
If the thing you try succeeds, you have to turn off the oven.
You have to turn off the oven no matter what!
No matter what, do NOT let me forget to turn off the.
Finally: for the things you want to do no matter what.
A ﬁnally block is where you put code that must run regardless of an exception.
Without ﬁnally, you have to put the turnOvenOff() in both the try and the catch because you have to turn off the oven no matter what.
A ﬁnally block lets you put all your important cleanup code in one place instead of duplicating it like this:
If the try block fails (an exception), flow control immediately moves to the catch block.
When the finally block completes, the rest of  the method continues on.
If the try block succeeds (no exception), flow control skips over the catch block and moves to the finally block.
When the finally block completes, the rest of  the method continues on.
What do you think the output of this program would be?  What do you think it would be if the third line of the program were changed to:    String test = “yes”; ? Assume ScaryException extends Exception.
When test = “no”:   start try  -  start risky  -  end risky  -  end try  -  ﬁnally  -  end of main.
When test = “yes”:  start try  -  start risky  -  scary exception  -  ﬁnally  -  end of main.
A method can throw multiple exceptions if it darn well needs to.
Did we mention that a method can throw more than one exception?
The compiler will make sure that you’ve handled all the checked exceptions thrown by the method you’re calling.
Stack the catch blocks under the try, one after the other.
Sometimes the order in which you stack the catch blocks matters, but we’ll get to that a little later.
There’s nothing all that special about one, except that it is a thing that can be thrown.
So like all good objects, Exceptions can be referred to polymorphically.
A LingerieException object, for example, could be assigned to a ClothingException reference.
The beneﬁ t for exceptions is that a method doesn’t have to explicitly declare every possible exception it might throw; it can declare a superclass of the exceptions.
Same thing with catch blocks—you don’t have to write a catch for each possible exception as long as the catch (or    catches) you have can handle any exception thrown.
You can DECLARE exceptions using a supertype of the exceptions you throw.
Declaring a ClothingException lets you throw any subclass of ClothingException.
You can CATCH exceptions using a supertype of the exception thrown.
You could write your exception-handling code so that you specify only one catch block, using the supertype Exception in the catch clause, so that you’ll be able to catch any exception that might be thrown.
Just because you CAN catch everything with one big super polymorphic catch, doesn’t always mean you SHOULD.
For example, if your code deals with (or recovers from) a TeeShirtException differently than it handles a LingerieException, write a catch block for each.
But if you treat all other types of ClothingException in the same way, then add a ClothingException catch to handle the rest.
Write a different catch block for each exception that you need to handle uniquely.
The higher up the inheritance tree, the bigger the catch ‘basket’
As you    move down the inheritance tree, toward more and more specialized Exception classes, the catch ‘basket’ is smaller.
The mother of all catch arguments is type Exception; it will catch any exception, including runtime (unchecked) exceptions, so you probably won’t use it outside of testing.
Multiple catch blocks must be ordered from smallest to biggest.
The one with the biggest basket has to be on the bottom.
Catch blocks are not like overloaded methods where the best match is picked.
With catch blocks, the JVM simply starts at the ﬁ rst one and works its way down until it ﬁ nds a catch that’s broad enough (in other words, high enough on the inheritance tree) to handle the exception.
If your ﬁ rst catch block is catch(Exception ex), the compiler knows there’s no point in adding any others—they’ll never be reached.
Siblings can be in any order, because they can’t catch one another’s exceptions.
Your task is to draw two different class diagrams that can accurately reﬂ ect the Exception classes.
In other words, what class inheritance structures would make the try/catch blocks in the sample code legal?
Your task is to create two different legal try / catch structures (similar to the one above left), to accurately represent the class diagram shown on the left.
Assume ALL of these exceptions might be thrown by the method with the try block.
If you don’t want to handle an exception, you can duck it by declaring it.
When you call a risky method, the compiler needs you to acknowledge it.
Most of the time, that means wrapping the risky call in a try/ catch.
But you have another alternative, simply duck it and let the method that called you catch the exception.
It’s easy—all you have to do is declare that you throw the exceptions.
Even though, technically, you aren’t the one doing the throwing, it doesn’t matter.
You’re still the one letting the exception whiz right on      by.
But if you duck an exception, then you don’t have a try/catch, so what happens when the risky method (doLaundry()) does throw the exception?
When a method throws an exception, that method is popped off the stack immediately, and the exception is thrown to the next method down the stack—the caller.
But if the caller is a ducker, then there’s no catch for it so the caller pops off the stack immediately, and the exception is thrown to the next method and so on...
Wrap the risky call in a try/catch This had better be a big enough catch to handle all exceptions that doLaundry( ) might throw.
Or else the compiler will still complain that you’re not catching all of the exceptions.
Declare that YOUR method throws the same exceptions as the risky method you’re calling.
But now this means that whoever calls the foo() method has to follow the Handle or Declare law.
If foo() ducks the exception (by declaring it), and main() calls foo(), then main() has to deal with the exception.
Now that you’ve completely forgotten, we started this chapter with a ﬁrst look at some JavaSound code.
But we can ﬁx that now by wrapping the call in a try/catch.
You cannot have a catch or ﬁnally without a try.
You cannot put code between the try and the catch.
A try MUST be followed by either a catch or a ﬁnally.
A try with only a ﬁnally (no catch) must still declare the exception.
You don’t have to do it yourself, but it’s a lot more fun if you do.
The rest of this chapter is optional; you can use Ready-bake code for all the music apps.
But if you want to learn more about JavaSound, turn the page.
Remember near the beginning of the chapter, we looked at how MIDI data holds the instructions for what should be played (and how it should be played) and we also said that MIDI data doesn’t actually create any sound that you hear.
For sound to come out of the speakers, the MIDI data has to be sent through some kind of MIDI device that takes the MIDI instructions and renders them in sound, either by triggering a hardware instrument or a ‘virtual’ instrument (software synthesizer)
In this book, we’re using only software devices, so here’s how it works in JavaSound:
The Sequencer is the thing that actually causes a song to be played.
The Sequence is the song, the musical piece that the Sequencer will play.
For this book, think of the Sequence as a music CD, but the whole CD plays just one song.
For this book, we only need one Track, so just imagine a a music CD with only one song.
This Track is where all the song data (MIDI information) lives.
The actual music information: notes to play, how long, etc.
A MIDI event is a message that the Sequencer can understand.
A MIDI event might also say something like, “Change the current instrument to Flute.”
Uh, hate to break it to you, but that’s only.
Remember, the Track lives in the Sequence, and the MIDI data lives in the Track.
The only thing you’ll have to care about are the arguments to the setMessage() method, and the arguments to the MidiEvent constructor.
Give the Sequence to the Sequencer (like putting the CD in the CD player)
A MidiEvent is an instruction for part of a song.
A series of MidiEvents is kind of like sheet music, or a player piano roll.
Most of the MidiEvents we care about describe a thing to do and the moment in time to do it.
The moment in time part matters, since timing is everything in music.
And because MidiEvents are so detailed, you have to say at what moment to start playing the note (a NOTE ON event) and at what moment to stop playing the notes (NOTE OFF event)
So you can imagine that ﬁring the “stop playing note G” (NOTE OFF message) before the “start playing Note G” (NOTE ON) message wouldn’t work.
The MIDI instruction actually goes into a Message object; the MidiEvent is a combination of the Message plus the moment in time when that message should ‘ﬁre’
In other words, the Message might say, “Start playing Middle C” while the MidiEvent would say, “Trigger this message at beat 4”
The Message says what to do, and the MidiEvent says when to do it.
The instructions are in the message, but the Midi-Event adds the moment in time when the instruction should be triggered.
A MidiEvent says what to do and when to do it.
In other words, at which beat that thing should happen.
A MIDI message holds the part of the event that says what to do.
The ﬁrst argument of an instruction is always the type of the message.The values you pass to the other three arguments depend on the type of message.
For example, a message of type 144 means “NOTE ON”
But in order to carry out a NOTE ON, the sequencer needs to know a few things.
To make a MIDI message, make a ShortMessage instance and invoke setMessage(), passing in the four arguments for the message.
But remember, the message says only what to do, so you still need to stuff the message into an event that adds when that message should ‘ﬁre’
Think of a channel like a musician in a band.
The ﬁrst argument to setMessage() always represents the message ‘type’, while the other three arguments represent different things depending on the message type.
The last 3 args vary depending on the message type.
This is a NOTE ON message, so the other args are for things the Sequencer needs to know in order to play a note.
The Message says what to do, the MidiEvent says when to do it.
Now that you know what’s in a Midi message, you can start experimenting.
You can change the note that’s played, how long the note is held, add more notes, and even change the instrument.
Change the note off event (not the message) so that it happens at an earlier or later beat.
Add a new message, BEFORE the note-playing message, that sets the instrument in channel 1 to something other than the default piano.
This version still plays just a single note, but you get to use command-line arguments to change the instrument and note.
The ﬁrst int sets the instrument, the second int sets the note to play.
When we’re done, we’ll have a working BeatBox that’s also a Drum Chat Client.
We’ll need to learn about GUIs (including event handling), I/O, networking, and threads.
We’ll learn how to construct and play a lot of MIDI events (instead of just a couple, as we do in the current chapter)
Now we’ll actually build the real BeatBox, GUI and all.
But it’s limited—as soon as you change a pattern, the previous one is lost.
There’s no Save and Restore feature, and it doesn’t communicate with the network.
But you can still use it to work on your drum pattern skills.
You’ve made the perfect pattern, and now you can save it to a ﬁle, and reload it when you want to play it again.
This gets us ready for the ﬁnal version (chapter 15), where instead of writing the pattern to a ﬁle, we send it over a network to the chat server.
Your job is to decide whether each of the following exception-related statements is true or false.
A try block must be followed by a catch and a ﬁnally block.
If you deﬁne a try / catch block, a matching ﬁnally block is optional.
If you write a method that declares that it can throw a compiler-checked exception, you must also wrap the exception throwing code in a try / catch block.
A single try block can have many different catch blocks.
A ﬁnally block will run regardless of whether an exception is thrown.
A try block can exist by itself, without a catch block or a ﬁnally block.
A working Java program is scrambled up on the fridge.
Can you reconstruct all the code snippets to make a working Java program that produces the output listed below?  Some of the curly braces fell on the floor and they were too small to  pick up, so feel free to add as many of those as you need!
False, but if it doesn’t the JVM may shut down.
False, broadest exceptions must be caught by the last catch blocks.
False, if you don’t have a catch block, you must declare.
If you’re building applications that other people are going to use, you need a graphical interface.
Even if you believe that the rest of your natural life will be.
In this chapter, we’ll put a button on the screen, and make it do.
We’ll paint on the screen, we’ll display a jpeg image, and we’ll even.
You don’t add things to the frame directly.Think of the frame as the trim around the window, and you add things to the window pane.
A JFrame is the object that represents a window on the screen.
It’s where you put all the interface things like buttons, checkboxes, text ﬁelds, and so on.
It can have an honest-to-goodness menu bar with menu items.
And it has all the little windowing icons for whatever platform you’re on, for minimizing, maximizing, and closing the window.
The JFrame looks different depending on the platform you’re on.
Once you have a JFrame, you can put things (‘widgets’) in it by adding them to the JFrame.
There are a ton of Swing components you can add; look for them in the javax.swing package.
Most are really simple to use, but some (like JTable) can be a bit more complicated.
Display it (give it a size and make it visible)4
The button ﬁlls all the available space in the frame.
Later we’ll learn to control where (and how big) the button is on the frame.
Let’s see what happens when we run it: %java SimpleGui1
The real question is, “How do I get the button to do something speciﬁ c when the user clicks it?”
A method to be called when the user clicks (the thing you want to happen as a result of the button click)
In other words, a way to know when the user clicks the button!
Q: Will a button look like a Windows button when you run on Windows?
You can choose from a few “look and feels”—classes in the core library that control what the interface looks like.
In most cases you can choose between at least two different looks: the standard Java look and feel, also known as Metal, and the native look and feel for your platform.
The Mac OS X screens in this book use either the OS X Aqua look and feel, or the Metal look and feel.
Q: Can I make a program look like Aqua all the time? Even when it’s running under Windows?
Not all look and feels are available on every platform.
If you want to be safe, you can either explicitly set the look and feel to Metal, so that you know exactly what you get regardless of where the app is running, or don’t specify a look and feel and accept the defaults.
Q: I heard Swing was dog-slow and that nobody uses it.
A: This was true in the past, but isn’t a given anymore.
On weak machines, you might feel the pain of Swing.
But on the newer desktops, and with Java version 1.3 and beyond, you might not even notice the difference between a Swing GUI and a native GUI.
Swing is used heavily today, in all sorts of applications.
Imagine you want the text on the button to change from click me to I’ve been clicked when the user presses the button.
First we can write a method that changes the text of the button (a quick look through the API will show you the method):
But now what? How will we know when this method should run? How will we know when the button is clicked?
In Java, the process of getting and handling a user event is called event-handling.
There are many different event types in Java, although most involve GUI user actions.
An event that says “The user wants the action of this button to happen.” If it’s a “Slow Tempo” button, the user wants the slow-tempo action to occur.
If it’s a Send button on a chat client, the user wants the send-my-message action to happen.
So the most straightforward event is when the user clicked the button, indicating they want an action to occur.
Second, the button needs a way to call us back when a buttonclicked event occurs.
How could you tell a button object that you care about its events? That you’re a concerned listener?
How will the button call you back? Assume that there’s no way for you to tell the button the name of your unique method (changeIt())
So what else can we use to reassure the button that we have a specific method it can call when the event happens? [hint: think Pet]
A listener interface is the bridge between the listener (you) and event source (the button)
An event source (like a button) creates an event object when the.
When you implement a listener interface, you give the button a way to call you back.
ActionListener reference to it (in this case, you are the ActionListener so you pass this).The button needs a way to call you back when the event happens,  so it calls the method in the listener interface.
As an ActionListener, you must implement the interface’s sole method, actionPerformed()
A button is a source of ActionEvents, so it has to know which objects are interested listeners.
When the user clicks the button, the button ‘ﬁres’ the event by calling the actionPerformed() method on each listener in the list.
The button calls this method to let you know an event happened.
It sends you an ActionEvent object as the argument, but we don’t need it.
Register with the button (tell it you want to listen for events)
Deﬁne the event-handling method (implement the actionPerformed() method from the ActionListener interrface)
For most of your stellar Java career, you will not be the source of events.
No matter how much you fancy yourself the center of your social universe.
Which, if you do it sincerely, can improve your social life.
Hey, what about me? I’m a player too, you know! As an event object, I’m the argument.
We just said that most of the time you’ll be the receiver and not the originator of the event (at least in the early days of your brilliant Java career)
Most of the events you might care about are ‘fired’ by classes in the Java API, and all you have to do is be a listener for them.
You might, however, design a program where you need a custom event, say, StockMarketEvent thrown when your stock market watcher app finds something it deems important.
And don’t forget that for every event type there must be a matching listener interface (so you’ll create a StockListener interface with a stockChanged() method)
Q: I don’t see the importance of the event object that’s passed to the event call-back methods.
If somebody calls my mousePressed method, what other info would I need?
A: A lot of the time, for most designs, you don’t need the event object.
It’s nothing more than a little data carrier, to send along more info about the event.
But sometimes you might need to query the event for specific details about the event.
For example, if your mousePressed() method is called, you know the mouse was pressed.
But what if you want to know exactly where the mouse was pressed? In other words, what if you want to know the X and Y screen coordinates for where the mouse was pressed?
Or sometimes you might want to register the same listener with multiple objects.
An onscreen calculator, for example, has 10 numeric keys and since they all do the same thing, you might not want to make a separate listener for every single key.
Instead, you might register a single listener with each of the 10 keys, and when you get an event (because your event call-back method is called) you can call a method on the event object to find out who the real event source was.
Each of these widgets (user interface objects) are the source of one or more events.
Some widgets might be a source of more than one event, and some events can be generated by more than one widget.
How do you KNOW if an object is an event source?
Now that we know a little about how events work (we’ll learn more later), let’s get back to putting stuff on the screen.
We’ll spend a few minutes playing with some fun ways to get graphic, before returning to event handling.
Put widgets on a frame Add buttons, menus, radio buttons, etc.
The javax.swing package has more than a dozen widget types.
Put a JPEG on a widget You can put your own images on a widget.
Draw 2D graphics on a widget Use a graphics object to paint shapes.
You can paint a lot more than boxes and circles; the Java2D API is full of fun, sophisticated graphics methods.
Number of Head First Java books mistakenly bought by coffee house baristas.
If you want to put your own graphics on the screen, your best bet is to make your own paintable widget.
You plop that widget on the frame, just like a button or any other widget, but when it shows up it will have your images on it.
You can even make those images move, in an animation, or make the colors on the screen change every time you click a button.
Make a subclass of JPanel and override one method, paintComponent()
All of your graphics code goes inside the paintComponent() method.
Think of the paintComponent() method as the method called by the system to say,  “Hey widget, time to paint yourself.” If you want to draw a circle, the paintComponent() method will have code for drawing a circle.
When the frame holding your drawing panel is displayed, paintComponent() is called and your circle appears.
If the user iconiﬁes/minimizes the window, the JVM knows the frame needs “repair” when it gets de-iconiﬁed, so it calls paintComponent() again.
Anytime the JVM thinks the display needs refreshing, your paintComponent() method will be called.
One more thing, you never call this method yourself! The argument to this method (a Graphics object) is the actual drawing canvas that gets slapped onto the real display.
You can’t get this by yourself; it must be handed to you by the system.
You’ll see later, however, that you can ask the system to refresh the display (repaint()), which ultimately leads to paintComponent() being called.
You’re telling it what color to paint with and then what shape to paint (with coordinates for where it goes and how big it is)
Let’s look at a few more things you can do in paintComponent()
The most fun, though, is when you start experimenting yourself.
Try playing with the numbers, and check the API for class Graphics (later we’ll see that there’s even more you can do besides what’s in the Graphics class)
The x,y coordinates for where the picture’s top left corner should go.
These numbers are always relative to the widget (in this case your JPanel subclass), not the entire frame.
You can make a color by passing in 3 ints to represent the RGB values.
Which means it could be a subclass of Graphics (because of polymorphism)
Why do you care? Because there are things you can do with a Graphics2D reference that you can’t do with a Graphics reference.
The compiler decides which methods you can call based on the reference type, not the object type.
If you have a Dog object referenced by an Animal reference variable:
Even though you know it’s really a Dog back there.
The compiler looks at ‘a’, sees that it’s of type Animal, and ﬁnds that there’s no remote control button for bark() in the Animal class.
But you can still get the object back to the Dog it really is by saying:
So the bottom line with the Graphics object is this:
But you can cast it with a new Graphics2D variable.
Because life’s too short to paint the circle a solid color when there’s a gradient blend waiting for you.
The argument to paintComponent() is a Graphics object that gives you a surface to draw on, which will end up on the screen.
Let’s hook up an event to a change in our drawing panel.
We’ll make the circle change colors each time you click the button.
But can we paint graphics when we get an event?
Voila! A new color is painted because paintComponent() runs again, ﬁlling the circle with a random color.
The frame is built with the two widgets (your drawing panel and a button)
Then the frame is displayed and it just waits for the user to click.
The user clicks the button and the button creates an event object and calls the listener’s event handler.
We cover GUI layouts in the next chapter, but we’ll do a quickie lesson here to get you going.
By default, a frame has ﬁve regions you can add to.
You can add only one thing to each region of a frame, but don’t panic! That one thing might be a panel that holds three other things including a panel that holds two more things and...
In fact, we were ‘cheating’ when we added a button to the frame using:
This isn’t really the way you’re supposed to do it (the one-arg add method)
The circle changes color each time you click the button.
The custom drawing panel (instance of MyDrawPanel) is in the CENTER region of the frame.
Add the two widgets (but-ton and drawing panel) to the two regions of the frame.
The drawing panel’s paintComponent() method is called every time the user clicks.
The south button will act as it does now, simply calling repaint on the frame.
The second button (which we’ll stick in the east region) will change the text on a label.
Is that even possible? How do you get two events when you have only one actionPerformed() method?
How do you get action events for two different buttons, when each button needs to do something different?
Flaw: You can’t! You can’t implement the same method twice in a Java class.
And even if you could, how would the event source know which of the two methods to call?
Flaw: this does work, but in most cases it’s not very OO.
One event handler doing many different things means that you have a single method doing many different things.
If you need to change how one source is handled, you have to mess with everybody’s event handler.
Sometimes it is a good solution, but usually it hurts maintainability and extensibility.
You could ﬁx it, but you’d have to give each of the listener classes a reference to the main GUI class, so that inside the actionPerformed() methods the listener could use the GUI class reference to access the variables of the GUI class.
And you’d probably need to add a constructor to the listener class so that you can pass the GUI reference to the listener at the time the listener is instantiated.
Won’t work! This class doesn’t have a refere nce to.
How do you get action events for two different buttons, when each button needs to do something different?
Wouldn’t it be wonderful if you could have two different listener classes, but the listener classes could access the instance variables of the main GUI class, almost as if the listener classes belonged to the other class.
Just make sure that the deﬁnition for the inner class is inside the curly braces of the outer class.
An inner class gets a special pass to use the outer class’s stuff.
And the inner class can use those private variables and methods of the outer class as if the variables and members were deﬁned in the inner class.
That’s what’s so handy about inner classes—they have most of the beneﬁts of a normal class, but with special access rights.
An inner class can use all the methods and variables of the outer class, even the private ones.
The inner class gets to use those variables and methods just as if the methods and variables were declared within the inner class.
Remember, when we talk about an inner class accessing something in the outer class, we’re really talking about an instance of the inner class accessing something in an instance of the outer class.
Can any arbitrary instance of the inner class access the methods.
An inner object must be tied to a speciﬁ c outer object on the heap.
An inner class instance must be tied to an outer class instance*
Make an instance of the inner class, by using the instance of the outer class.
An inner object shares a special bond with an outer object.
There’s an exception to this, for a very special case—an inner class deﬁ ned within a static method.
But we’re not going there, and you might go your entire Java life without ever encountering one of these.
If you instantiate an inner class from code within an outer class, the instance of the outer class is the one that the inner object will ‘bond’ with.
For example, if code within a method instantiates the inner class, the inner object will bond to the instance whose method is running.
Code in an outer class can instantiate one of its own inner classes, in exactly the same way it instantiates any other class...
You can instantiate an inner instance from code running outside the outer class, but you have to use a special syntax.
Chances are you’ll go through your entire Java life and never need to make an inner class from outside, but just in case you’re interested...
Inner object: Where do I start? We give you a chance to implement the same interface more than once in a class.
Remember, you can’t implement a method more than once in a normal Java class.
But using inner classes, each inner class can implement the same interface, so you can have all these different implementations of  the very same interface methods.
HeadFirst: Why would you ever want to implement the same method twice?
HeadFirst: So are event handlers the only reason to use inner classes?
Anytime you need a separate class, but still want that class to behave as if  it were part of  another class, an inner class is the best—and sometimes only—way to do it.
If  you want the inner class to behave like it belongs to the outer class, why have a separate class in the ﬁrst place? Why wouldn’t the inner class code just be in the outer class in the ﬁrst place?
Inner object: I just gave you one scenario, where you need more than one implementation of  an interface.
But even when you’re not using interfaces, you might need two different classes because those classes represent two different things.
I thought a big part of OO design is about reuse and maintenance.
You know, the idea that  if  you have two separate classes, they can each be modiﬁed and used independently, as opposed to stufﬁng it all into one class yada yada yada.
But with an inner class, you’re still just working with one real class in the end, right? The enclosing class is the only one that’s reusable and.
In fact, I’ve heard them called “Reuselessuseless over and over again.”
Inner object: Yes it’s true that the inner class is not as reusable, in fact sometimes not reusable at all, because it’s intimately tied to the instance variables and methods of the outer class.
But itHeadFirst: —which only proves my point! If  they’re not reusable, why bother with a separate class? I mean, other than the interface issue, which sounds like a workaround to me.
Inner object: As I was saying, you need to think about IS-A and polymorphism.
Inner object: Because the outer and inner classes might need to pass different IS-A tests!  Let’s start with the polymorphic GUI listener example.
Something that implements a particular listener interface, in this case ActionListener.
Inner object: My point is that polymorphically, you have a method that takes only one particular type.
But—and here’s the big thing—what if  your class needs to be an ISA of  something that’s a class type rather than an interface?
HeadFirst: Wouldn’t you have your class just extend the class you need to be a part of ? Isn’t that the whole point of  how subclassing works? If  B is a subclass of  A, then anywhere an A is expected a B can be used.
Inner object: Yes! Bingo! So now what happens if  you need to pass the IS-A test for two different classes? Classes that aren’t in the same inheritance hierarchy?
You can always implement more than one interface, but you can extend only one class.
You can only be one kind of  IS-A when it comes to class types.
Inner object: Well done! Yes, you can’t be both a Dog and a Button.
But if  you’re a Dog that needs to sometimes be a Button (in order to pass yourself  to methods that take a Button), the Dog class (which extends Animal so it can’t extend Button) can have an inner class that acts on the Dog’s behalf  as a Button, by extending Button, and thus wherever a Button is required the Dog can pass his inner Button instead of  himself.
Inner object: Remember the drawing panel we used, where we made our own subclass of  JPanel? Right now, that class is a separate, non-inner, class.
And that’s ﬁne, because the class doesn’t need special access to the instance variables of  the main GUI.
But what if  it did? What if we’re doing an animation on that panel, and it’s getting its coordinates from the main application (say, based on something the user does elsewhere in the GUI)
In that case, if we make the drawing panel an inner class, the drawing panel class gets to be a subclass of  JPanel, while the outer class is still free to be a subclass of  something else.
HeadFirst: Yes I see! And the drawing panel isn’t reusable enough to be a separate class anyway, since what it’s actually painting is speciﬁc to this one GUI application.
Then we can move on to the nature of the relationship between you and the outer instance.
Inner object: What is it with you people? Not enough sordid gossip in a serious topic like polymorphism?
HeadFirst: Hey, you have no idea how much the public is willing to pay for some good old tabloid dirt.
So, someone creates you and becomes instantly bonded to the outer object, is that right?
And yes, some have compared it to an arranged marriage.
We don’t have a say in which object we’re bonded to.
HeadFirst: What about the outer object? Can it be associated with any other inner objects?
My so-called ‘mate’ can have as many inner objects as it wants.
HeadFirst: Is that like, serial monogamy? Or can it have them all at the same time?
And let’s not forget, it was you extolling the virtues of  “multiple implementations of  the same interface”
So it makes sense that if  the outer class has three buttons, it would need three different inner classes (and thus three different inner class objects) to handle the events.
But we have access to all his private data, so just imagine the damage we could do...
We saw why inner classes are handy for event listeners, because you get to implement the same event-handling method more than once.
But now we’ll look at how useful an inner class is when used as a subclass of something the outer class doesn’t extend.
In other words, when the outer class and inner class are in different inheritance trees!
Our goal is to make a simple animation, where the circle moves across the screen from the upper left down to the lower right.
Repeat the previous step with changing x and y values for as long as the animation is supposed to continue.
Q:Why are we learning about animation here? I doubt if I’m going to be making games.
A:You might not be making games, but you might be creating simulations, where things change over time to show the results of a process.
Or you might be building a visualization tool that, for example, updates a graphic to show how much memory a program is using, or to show you how much traffic is coming through your load-balancing server.
Doesn’t that all sound businesslike? That’s just the “official justification”, of course.
The real reason we’re covering it here is just because it’s a simple way to demonstrate another use of inner classes.
And because we just like animation, and our next Head First book is about J2EE and we know we can’t get animation in that one.
But where do we get the new x and y coordinates?
See if you can design a simple solution to get the ball to animate from the top left of the drawing panel down to the bottom right.
Our answer is on the next page, so don’t turn this page until you’re done! Big Huge Hint: make the drawing panel an inner class.
Another Hint: don’t put any kind of repeat loop in the paintComponent() method.
Slow it down a little (otherwise it will move so quickly you won’t SEE it move)
We forgot to erase what was already there! So we got trails.
To ﬁx it, all we have to do is ﬁll in the entire panel with the background color, before painting the circle each time.
The code below adds two lines at the start of the method: one to set the color to white (the background color of the drawing panel) and the other to ﬁll the entire panel rectangle with that color.
Sharpen your pencil (optional, just for fun) What changes would you make to the x and y coordinates to produce the animations below? (assume the ﬁrst one example moves in 3 pixel increments)
We’ll use Java-generated random graphics that keep time with the music beats.
Along the way we’ll register (and listen for) a new kind of non-GUI event, triggered by the music itself.
Ok, sure, it might work only on people who are really easy to impress, but still...
OK, maybe not a music video, but we will make a program that draws random graphics on the screen with the beat of the music.
In a nutshell, the program listens for the beat of the music and draws a random graphic rectangle with each beat.
So far, we’ve listened for only GUI events, but now we need to listen for a particular kind of MIDI event.
Turns out, listening for a non-GUI event is just like listening for GUI events: you implement a listener interface, register the listener with an event source, then sit back and wait for the event source to call your event-handler method (the method deﬁned in the listener interface)
The simplest way to listen for the beat of the music would be to register and listen for the actual MIDI events, so that whenever the sequencer gets the event, our code will get it too and can draw the graphic.
A bug, actually, that won’t let us listen for the MIDI events we’re making (the ones for NOTE ON)
There is another type of MIDI event we can listen for, called a ControllerEvent.
Our solution is to register for ControllerEvents, and then make sure that for every NOTE ON event, there’s a matching ControllerEvent ﬁred at the same ‘beat’
How do we make sure the ControllerEvent is ﬁred at the same time? We add it to the track just like the other events! In other words, our music sequence goes like this:
Before we dive into the full program, though, let’s make it a little easier to make and add MIDI messages/events since in this program, we’re gonna make a lot of them.
Make a series of MIDI messages/ events to play random notes on a piano (or whatever instrument you choose)
Each time the listener’s event handler method is called, draw a random rectangle on the drawing panel, and call repaint.
Version One: Code that simpliﬁes making and adding MIDI events, since we’ll be making a lot of them.
Version Two: Register and listen for the events, but without graphics.
Right now, making and adding messages and events to a track is tedious.
For each message, we have to make the message instance (in this case, ShortMessage), call setMessage(), make a MidiEvent for the message, and add the event to the track.
In last chapter’s code, we went through each step for every message.
That means eight lines of code just to make a note play and then stop playing! Four lines to add a NOTE ON event, and four lines to add a NOTE OFF event.
Let’s build a static utility method that makes a message and returns a MidiEvent.
There’s no event handling or graphics here, just a sequence of 15 notes that go up the scale.
The point of this code is simply to learn how to use our new makeEvent() method.
The code for the next two versions is much smaller and simpler thanks to this method.
Code that’s different from the previous version is highlighted in gray.
This event will do NOTH-ING! We put it in JUST so that we can get an event each time a note is played.
In other words, its sole purpose is so that something will fire that WE can listen for (we can’t listen for NOTE ON/OFF events)
Note that we’re making this event happen at the SAME tick as the NOTE ON.
So when the NOTE ON event happens, we’ll know about it because OUR event will fire at the same time.
This ﬁnal version builds on version two by adding the GUI parts.
We build a frame, add a drawing panel to it, and each time we get an event, we draw a new rectangle and repaint the screen.
The only other change from version two is that the notes play randomly as opposed to simply moving up the scale.
So when the drawing panel (an inner class) gets the event, it knows how to take care of itself by drawing the rectangle.
Complete code for this version is on the next page.
We set a flag to false, and we’ll set it to true only when we get an event.
We got an event, so we set the flag to true and call repaint()
We have to use a flag because OTHER things might trigger a repaint(), and we want to paint ONLY when there’s a ControllerEvent.
The rest is code to generate a random color and paint a semi-random rectangle.
Sharpen your pencil This is the complete code listing for Version Three.
Try to annotate it yourself, without looking at the previous pages.
A bunch of Java hot-shots, in full costume, are playing the party game “Who am I?”  They give you a clue, and you try to guess who they are, based on what they say.
If they happen to say something that could be true for more than one guy, then write down all for whom that sentence applies.
Fill in the blanks next to the sentence with the names of one or more attendees.
Any of the charming personalities from this chapter just might show up!
You add code to this method but never call it.
An addXxxListener( ) method says an object is an _____
The Java file on this page represents a complete source file.
Your job is to play compiler and determine whether this file will compile.
Pool Puzzle Your job is to take code snippets from the pool and place them into the blank.
You may use the same snippet more than once, and you won’t need to use all the snippets.
Your goal is to make a class that will compile and run.
Note:  Each snippet from the pool can be used more than once!
This program will produce a blue rectangle that will shrink and shrink and disappear into a ﬁeld of white.
The addActionListener( ) method takes a class that implements the ActionListener interface.
Once this code is ﬁxed, it will create a GUI with a button that toggles between A and B when you click it.
You add code to this method but never call it.
When the user actually does something, it’s an ____  event.
An addXxxListener( ) method says an object is an ___  event source.
The ‘g’ in (Graphics g), is really of this class.
Unless you actually care where things end up on the screen.
Layout Manager objects control the size and location of the widgets in a.
They do a ton of work on your behalf, but you won’t always like the results.
In this chapter, we’ll work on our Swing and in addition.
Component is the more correct term for what we’ve been calling a widget.
In Swing, virtually all components are capable of holding other components.
In other words, you can stick just about anything into anything else.
But most of the time, you’ll add user interactive components such as buttons and lists into background components such as frames and panels.
Although it’s possible to put, say, a panel inside a button, that’s pretty weird, and won’t win you any usability awards.
With the exception of JFrame, though, the distinction between interactive components and background components is artiﬁcial.
A JPanel, for example, is usually used as a background for grouping other components, but even a JPanel can be interactive.
Just as with other components, you can register for the JPanel’s events including mouse clicks and keystrokes.
Display it (give it a size and make it visible)4
Panel A’s layout manager controls the size and placement of Panel B.
As a layout manager, I’m in charge of the size.
A layout manager is a Java object associated with a particular component, almost always a background component.
The layout manager controls the components contained within the component the layout manager is associated with.
In other words, if a frame holds a panel, and the panel holds a button, the panel’s layout manager controls the size and placement of the button, while the frame’s layout manager controls the size and placement of the panel.
The button, on the other hand, doesn’t need a layout manager because the button isn’t holding other components.
If a panel holds ﬁve things, even if those ﬁve things each have their own layout managers, the size and location of the ﬁve things in the panel are all controlled by the panel’s layout manager.
If those ﬁve things, in turn, hold other things, then those other things are placed according to the layout manager of the thing holding them.
When we say hold we really mean add as in, a panel holds a button because the button was added to the panel using something like:
Layout managers come in several ﬂavors, and each background component can have its own layout manager.
Layout managers have their own policies to follow when building a layout.
For example, one layout manager might insist that all components in a panel must be the same size, arranged in a grid, while another layout manager might let each component choose its own size, but stack them vertically.
Panel A’s layout manager has NOTHING to say about the three buttons.
The hierarchy of control is only one level—Panel A’s layout manager controls only the things added directly to Panel A, and does not control anything nested within those added components.
In general, the process of laying out a background component looks something like this:
The panel’s layout manager asks each button how big that button prefers to be.
The panel’s layout manager uses its layout policies to decide whether it should respect all, part, or none of the buttons’ preferences.
The frame’s layout manager asks the panel how big the panel prefers to be.
The frame’s layout manager uses its layout policies to decide whether it should respect all, part, or none of the panel’s preferences.
Some layout managers respect the size the component wants to be.
Other layout managers respect only part of the component’s preferred size.
Still other layout managers respect the preference of only the largest of the components being layed out, and the rest of the components in that panel are all made that same size.
In some cases, the work of the layout manager can get very complex, but most of the time you can ﬁgure out what the layout manager will probably do, once you get to know that layout manager’s policies.
BorderLayout A BorderLayout manager divides a background component into ﬁve regions.
You can add only one component per region to a background controlled by a BorderLayout manager.
Components laid out by this manager usually don’t get to have their preferred size.
FlowLayout A FlowLayout manager acts kind of like a word processor, except with components instead of words.
Each component is the size it wants to be, and they’re laid out left to right in the order that they’re added, with “word-wrap” turned on.
So when a component won’t ﬁt horizontally, it drops to the next “line” in the layout.
BoxLayout A BoxLayout manager is like FlowLayout in that each component gets to have its own size, and the components are placed in the order in which they’re added.
But, unlike FlowLayout, a BoxLayout manager can stack the components vertically (or horizontally, but usually we’re just concerned with vertically)
BorderLayout cares about five regions: east, west, north, south, and center.
What are the factors the layout manager has to consider?
Watch what happens when we give the button more characters...
How do we do that? The button is already as wide as it can ever be—as wide as the frame.
But we can try to make it taller by giving it a bigger font.
The center region gets whatever’s left! (except in one special case we’ll look at later)
When you put something in the north or south, it goes all the way across the frame, so the things in the east and west won’t be as tall as they would be if the north and south regions were empty.
FlowLayout cares about the ﬂow of the components: left to right, top to bottom, in the order they were added.
When we add a panel to a frame, the size and placement of the panel is still under the BorderLayout manager’s control.
We’ll start by putting an empty panel in the frame’s east region, and on the next pages we’ll add things to the panel.
Make the panel gray so we can see where it is on the frame.
The panel expanded! And the button got its preferred size in both dimensions, because the panel uses flow layout, and the button is part of the panel (not the frame)
I have a button now, so my layout manager’s gonna have to ﬁgure out how big I need to be...
I need to know how big the panel wants to be...
I need to know how big the button wants to.
What happens if we add TWO buttons to the panel?
The panel expanded to fit both buttons side by side.
If the code above were modiﬁed to the code below, what would the GUI look like?
Draw what you think the GUI would look  like if you ran the code to the left.
It keeps components stacked, even if there’s room to put them side by side.
Unlike FlowLayout, BoxLayout can force a ‘new line’ to make the components wrap to the next line, even if there’s room for them to ﬁt horizontally.
But now you’ll have to change the panel’s layout manager from the default FlowLayout to BoxLayout.
The BoxLayout constructor needs to know the component its laying out (i.e., the panel) and which axis to use (we use Y_AXIS for a vertical stack)
Q: How come you can’t add directly to a frame the way you can to a panel?
A: A JFrame is special because it’s where the rubber meets the road in making something appear on the screen.
While all your Swing components are pure Java, a JFrame has to connect to the underlying OS in order to access the display.
Think of the content pane as a 100% pure Java layer that sits on top of the JFrame.
Or think of it as though JFrame is the window frame and the content pane is the...
Q: Can I change the layout manager of the frame? What if I want the frame to use ﬂow instead of border?
A:The easiest way to do this is to make a panel, build the GUI the way you want in the panel, and then make that panel the frame’s content pane using the code in the previous answer (rather than using the default content pane)
Q: What if I want a different preferred size? Is there a setSize() method for components?
A:Yes, there is a setSize(), but the layout managers will ignore it.
There’s a distinction between the preferred size of the component and the size you want it to be.
The preferred size is based on the size the component actually needs (the component makes that decision for itself )
The layout manager calls the component’s getPreferredSize() method, and that method doesn’t care if you’ve previously called setSize() on the component.
Q:Can’t I just put things where I want them? Can I turn the layout managers off?
On a component by component basis, you can call setLayout(null) and then it’s up to you to hard-code the exact screen locations and dimensions.
In the long run, though, it’s almost always easier to use layout managers.
Depending on the layout manager’s policies, it might respect all, some, or none of the component’s wishes.
Components in the east and west get their preferred width, but not height.
The component in the center gets whatever is left over (unless you use pack())
Like FlowLayout, BoxLayout uses the preferred size of the component in both dimensions.
Playing with Swing components You’ve learned the basics of layout managers, so now let’s try out a few of the most common components: a text ﬁeld, scrolling text area, checkbox, and list.
We won’t show you the whole darn API for each of these, just a few highlights to get you started.
Get an ActionEvent when the user presses return or enter.
You can also register for key events if you really want to hear about it every time the user presses a key.
Put the cursor back in the ﬁeld (so the user can just start typing)
Put the cursor back in the ﬁeld (so the user can just start typing)
Unlike JTextField, JTextArea can have more than one line of text.
It takes a little conﬁguration to make one, because it doesn’t come out of the box with scroll bars or line wrapping.
To make a JTextArea scroll, you have to stick it in a ScrollPane.
A ScrollPane is an object that really loves to scroll, and will take care of the text area’s scrolling needs.
Turn on line wrapping Tell the scroll pane to use only a vertical scrollbar.
Important!! You give the text area to the scroll pane (through the scroll pane constructor), then add the scroll pane to the panel.
You don’t add the text area directly to the panel!
Insert a new line so the words go on a separate line each time the button is clicked.
Listen for an item event (when it’s selected or deselected)
Handle the event (and ﬁnd out whether or not it’s selected)
Q: Aren’t the layout managers just more trouble than they’re worth? If I have to go to all this trouble, I might as well just hardcode the size and coordinates for where everything should go.
A: Getting the exact layout you want from a layout manager can be a challenge.
But think about what the layout manager is really doing for you.
Even the seemingly simple task of figuring out where things should go on the screen can be complex.
For example, the layout manager takes care of keeping your components from overlapping one another.
In other words, it knows how to manage the spacing between components (and between the edge of the frame)
Sure you can do that yourself, but what happens if you want components to be very tightly packed? You might get them placed just right, by hand, but that’s only good for your JVM!
Why? Because the components can be slightly different from platform to platform, especially if they use the underlying platform’s native ‘look and feel’
Subtle things like the bevel of the buttons can be different in such a way that components that line up neatly on one platform suddenly squish together on another.
And we’re still not at the really Big Thing that layout managers do.
Think about what happens when the user resizes the window! Or your GUI is dynamic, where components come and go.
Restrict the user to selecting only ONE thing at a time.
They don’t have to be Strings, but a String representation will appear in the list.
In the Saving Objects chapter, we’ll learn how to save and restore drum patterns.
Finally, in the networking chapter (Make a Connection), we’ll turn the BeatBox into a working chat client.
This is the full code listing for this version of the BeatBox, with buttons for starting, stopping, and changing the tempo.
The code listing is complete, and fullyannotated, but here’s the overview:
Set-up the MIDI system (you’ve done this before) including getting a Sequencer, making a Sequence, and creating a track.
We are using a sequencer method that’s new to Java 5.0, setLoopCount( )
This method allows you to specify how many times you want a sequence to loop.
We’re also using the sequence’s tempo factor to adjust the tempo up or down, and maintain the new tempo from one iteration of the loop to the next.
Once the track is built, we start the sequencer, which keeps playing (because we’re looping it) until the user hits ‘stop’
These are the names of the instruments, as a String array, for building the GUI labels (on each row)
The drum channel is like a piano, except each ‘key’ on the piano is a different drum.
An ‘empty border’ gives us a margin between the edges of the panel and  where the components are placed.
Make the checkboxes, set them to ‘false’ (so they aren’t checked) and add them to the ArrayList AND to the GUI panel.
The usual MIDI set-up stuff for getting the Sequencer, the Sequence, and the Track.
Is the checkbox at this beat selected? If yes, put the key value in this slot in the array (the slot that represents this beat)
Otherwise, the instrument is NOT supposed to play at this beat, so set it to zero.
Do this for each of the BEATS for this row.
We always want to make sure that there IS an event at.
Let’s you specify the number of loop iterations, or in this case, continuous looping.
This makes events for one in strument at a time, for.
So it might get an int[ ] for the Bass.
Otherwise, make an event and add it to the track.
The Tempo Factor scales the sequencer’s tempo by the factor provided.
Five of the six screens below were made from one.
Behavior lives in the class, but state lives within each individual object.
If you’re writing an app that creates charts, you’re gonna need a Save/
If your program needs to save state, you can do it the hard way, interrogating.
If I have to read one more ﬁ le full of.
You could grab a piece of paper and start scribbling it down, but instead you hit the Save button (or choose Save from the File menu)
Then you give it a name, pick a directory, and exhale knowing that your masterpiece won’t go out the window with the blue screen of death.
You have lots of options for how to save the state of your Java program, and what you choose will probably depend on how you plan to use the saved state.
Here are the options we’ll be looking at in this chapter.
Then have your program read the serialized objects from the ﬁ le and inﬂ ate them back into living, breathing, heap-inhabiting objects.
You could grab a piece of paper and start scribbling it down, but.
You could grab a piece of paper and start scribbling it down, but.
If your data will be used by only the Java program that generated it:
Instead of writing characters, for example, you can write your data as bytes.
Or you can write out any kind of Java primitive as a Java primitive—there are methods to write ints, longs, booleans, etc.
But regardless of the method you use, the fundamental I/O techniques are pretty much the same: write some data to something, and usually that something is either a ﬁ le on disk or a stream coming from a network connection.
Reading the data is the same process in reverse: read some data from either a ﬁ le on disk or a network connection.
And of course everything we talk about in this part is for times when you aren’t using an actual database.
Write a ﬁ le, with delimiters that other programs can parse.
For example, a tab-delimited ﬁ le that a spreadsheet or database application can use.
Create a ﬁ le and write three lines of text, one per character, separating the pieces of state with commas:
The serialized file is much harder for humans to read, but it’s much easier (and safer) for your program to restore the three objects from serialization than from reading in the object’s variable values that were saved to a text file.
For example, imagine all the ways in which you could accidentally read back the values in the wrong order.! The type might become “dust” instead of “Elf”, while the Elf becomes a weapon...
Saving State Imagine you have a program, say, a fantasy adventure game, that takes more than one session to complete.
As the game progresses, characters in the game become stronger, weaker, smarter, etc., and gather and use (and lose) weapons.
You don’t want to start from scratch each time you launch the game—it took you forever to get your characters in top shape for a spectacular battle.
So, you need a way to save the state of the characters, and a way to restore the state when you resume the game.
And since you’re also the game programmer, you want the whole save and restore thing to be as easy (and foolproof) as possible.
Write the three serialized character objects to a ﬁ le.
Create a ﬁ le and write three serialized character objects.
The ﬁ le won’t make sense if you try to read it as text:
Don’t bother memorizing all this; we’ll go into more detail later in this chapter.
Closing the stream at the top closes the ones underneath, so the FileOutputStream (and the file) will close automatically.
The Java I/O API has connection streams, that represent connections to destinations and sources such as ﬁ les or network sockets, and chain streams that work only if chained to other streams.
Often, it takes at least two streams hooked together to do something useful—one to represent the connection and   another to call methods on.
FileOutputStream (a connection stream), for example, has methods for writing bytes.
But we don’t want to write bytes! We want to write objects, so we need a higher-level chain stream.
OK, then why not have just a single stream that does exactly what you want? One that lets you write objects but underneath converts them to bytes? Think good OO.
So we make a FileOutputStream that lets us write to a ﬁ le, and we hook an ObjectOutputStream (a chain stream) on the end of it.
The ability to mix and match different combinations of connection and chain streams gives you tremendous ﬂ exibility! If you were forced to use only a single stream class, you’d be at the mercy of the API designers, hoping they’d thought of everything you might ever want to do.
But with chaining, you can patch together your own custom chains.
Objects on the heap have state—the value of the object’s   instance variables.
These values make one instance of a class different from another instance of the same class.
Serialized objects save the values of the instance variables, so that an identical instance (object) can be brought back to life on the heap.
The instance variable values for width and height are saved to the file “foo.ser”, along with a little more info the JVM needs to restore the object (like what its class type is).foo.ser.
Make a FileOutputStream that connects to the file “foo.ser”, then chain an ObjectOutputStream to it, and tell the ObjectOutputStream to write the object.
But what exactly IS an object’s state? What needs to be saved? Now it starts to get interesting.
But what if an object has an instance variable that’s an object reference? What about an object that has ﬁve instance variables that are object references? What if those object instance variables themselves have instance variables?
What part of an object is potentially unique? Imagine what needs to be restored in order to get an object that’s identical to the one that was saved.
It will have a different memory location, of course, but we don’t care about that.
All we care about is that out there on the heap, we’ll get an object that has the same state the object had when it was saved.
The Car object has two instance variables that reference two other objects.
Think of what—and how—you might need to save the Car.
And what happens if an Engine object has a reference to a Carburator? And what’s inside the Tire [] array object?
When an object is serialized, all the objects it refers to from instance variables are also serialized.
And all the objects those objects refer to are serialized.
And all the objects those objects refer to are serialized...
This Kennel object has a reference to a Dog [] array object.
Each Dog object holds a reference to a String and a Collar object.
The String objects have a collection of characters and the Collar objects have an int.
When you save the Kennel, all of this is saved!
All objects referenced by instance variables, starting with the object being serialized.
If you want your class to be serializable, implement Serializable The Serializable interface is known as a marker or tag interface, because the interface doesn’t have any methods to implement.
Its sole purpose is to announce that the class implementing it is, well, serializable.
In other words, objects of that type are saveable through the serialization mechanism.
If any superclass of a class is serializable, the subclass is automatically serializable even if the subclass doesn’t explicitly declare implements Serializable.
Make an ObjectOutputStream chained to the connection stream.Tell it to write the object.
Can you imagine what would happen if some of the object’s state didn’t save correctly?
Either the entire object graph is serialized correctly or serialization fails.
You can’t serialize a Pond object if its Duck instance variable refuses to be serialized (by not implementing Serializable)
When you serialize myPond (a Pond object), its Duck instance variable automatically gets serialized.
Yikes!! Duck is not serializable! It doesn’t implement Serializable, so when you try to serialize a Pond object, it fails because the Pond’s Duck instance variable can’t be saved.
When you try to ru n the main in class.
Mark an instance variable as transient if it can’t (or shouldn’t) be saved.
If you want an instance variable to be skipped by the serialization process, mark the variable with the transient keyword.
If you have an instance variable that can’t be saved because it isn’t serializable, you can mark that variable with the transient keyword and the serialization process will skip right over it.
So why would a variable not be serializable? It could be that the class designer simply forgot to make the class implement Serializable.
Or it might be because the object relies on runtime-speciﬁc information that simply can’t be saved.
Although most things in the Java class libraries are serializable, you can’t save things like network connections, threads, or ﬁle objects.
They’re all dependent on (and speciﬁc to) a particular runtime ‘experience’
In other words, they’re instantiated in a way that’s unique to a particular run of your program, on a particular platform, in a particular JVM.
Once the program shuts down, there’s no way to bring those things back to life in any meaningful way; they have to be created from scratch each time.
Q: If serialization is so important, why isn’t it the default for all classes? Why doesn’t class Object implement Serializable, and then all subclasses will be automatically Serializable.
A: Even though most classes will, and should, implement Serializable, you always have a choice.
And you must make a conscious decision on a class-by-class basis, for each class you design, to ‘enable’ serialization by implementing Serializable.
First of all, if serialization were the default, how would you turn it off? Interfaces indicate functionality, not a lack of functionality, so the model of polymorphism wouldn’t work correctly if you had to say, “implements NonSerializable” to tell the world that you cannot be saved.
Q: Why would I ever write a class that wasn’t serializable?
A: There are very few reasons, but you might, for example, have a security issue where you don’t want a password object stored.
Or you might have an object that makes no sense to save, because its key instance variables are themselves not serializable, so there’s no useful way for you to make your class serializable.
Q: If a class I’m using isn’t serializable, but there’s no good reason (except that the designer just forgot or was stupid), can I subclass the ‘bad’ class and make the subclass serializable?
Which brings up another interesting issue: what does it mean if the superclass is not serializable?
Q: You brought it up: what does it mean to have a serializable subclass of a non-serializable superclass?
A: First we have to look at what happens when a class is deserialized, (we’ll talk about that on the next few pages)
In a nutshell, when an object is deserialized and its superclass is not serializable, the superclass constructor will run just as though a new object of that type were being created.
If there’s no decent reason for a class to not be serializable, making a serializable subclass might be a good solution.
Then what happens to it? We solve the problem of having a non-serializable instance variable by making the instance variable transient, but don’t we NEED that variable when the object is brought back to life? In other words, isn’t the whole point of serialization to preserve an object’s state?
A: Yes, this is an issue, but fortunately there’s a solution.
If you serialize an object, a transient reference instance variable will be brought back.
That means the entire object graph connected to that particular instance variable won’t be saved.
This could be bad, obviously, because you probably need a non-null value for that variable.
When the object is brought back, reinitialize that null instance variable back to some default state.
This works if your deserialized object isn’t dependent on a particular value for that transient variable.
In other words, it might be important that the Dog have a Collar, but perhaps all Collar objects are the same so it doesn’t matter if you give the resurrected Dog a brand new Collar; nobody will know the difference.
If the value of the transient variable does matter (say, if the color and design of the transient Collar are unique for each Dog) then you need to save the key values of the Collar and use them when the Dog is brought back to essentially re-create a brand new Collar that’s identical to the original.
Q: What happens if two objects in the object graph are the same object? Like, if you have two different Cat objects in the Kennel, but both Cats have a reference to the same Owner object.
A: Excellent question! Serialization is smart enough to know when two objects in the graph are the same.
In that case, only one of the objects is saved, and during deserialization, any references to that single object are restored.
Deserialization: restoring an object The whole point of serializing an object is so that you can restore it back to its original state at some later date, in a different ‘run’ of the JVM (which might not even be the same JVM that was running at the time the object was serialized)
Closing the stream at the top closes the ones underneath, so the FileInputStream (and the file) will close automatically.
GameCharacter elf = (GameCharacter) one; GameCharacter troll = (GameCharacter) two; GameCharacter magician = (GameCharacter) three;
Each time you say readObject(), you get the next object in the stream.
So you’ll read them back in the same order in which they were written.
You’ll get a big fat exception if you try to read more objects than you wrote.
What happens during deserialization? When an object is deserialized, the JVM attempts to bring the object back to life by making a new object on the heap that has the same state the serialized object had at the time it was serialized.
Well, except for the transient variables, which come back either null (for object references) or as default primitive values.
The JVM determines (through info stored with the serialized object) the object’s class type.
The JVM attempts to ﬁ nd and load the object’s class.
If the JVM can’t ﬁ nd and/or load the class, the JVM throws an exception and the deserialization fails.
A new object is given space on the heap, but the serialized object’s constructor does NOT run! Obviously, if the constructor ran, it would  restore the state of the object back to its original ‘new’ state, and that’s not what we want.
We want the object to be restored to the state it had when it was serialized, not when it was ﬁ rst created.
If the object has a non-serializable class somewhere up its inheritance tree, the constructor for that non-serializable class will run along with any constructors above that (even if they’re serializable)
Once the constructor chaining begins, you can’t stop it, which means all superclasses, beginning with the ﬁrst non-serializable one, will reinitialize their state.
The object’s instance variables are given the values from the serialized state.
Q:Why doesn’t the class get saved as part of the object? That way you don’t have the problem with whether the class can be found.
And while it might not be such a hardship when you’re using serialization to write objects to a file on a local hard drive, serialization is also used to send objects over a network connection.
If a class was bundled with each serialized (shippable) object, bandwidth would become a much larger problem than it already is.
For objects serialized to ship over a network, though, there actually is a mechanism where the serialized object can be ‘stamped’ with a URL for where its class can be found.
This is used in Java’s Remote Method Invocation (RMI) so that you can send a serialized object as part of, say, a method.
Remember, static means “one per class” not “one per object”
Static variables are not saved, and when an object is deserialized, it will have whatever static variable its class currently has.
Chain streams cannot connect to a source or destination and must be chained to a connection (or other) stream.
To serialize an object to a file, make a FileOuputStream and chain it into an ObjectOutputStream.
You do not need to call methods on the FileOutputStream.
To be serialized, an object must implement the Serializable interface.
If a superclass of the class implements Serializable, the subclass will automatically be serializable even if it does not specifically declare implements Serializable.
When an object is serialized, its entire object graph is serialized.
If any object in the graph is not serializable, an exception will be thrown at runtime, unless the instance variable referring to the object is skipped.
Mark an instance variable with the transient keyword if you want serialization to skip that variable.
The variable will be restored as null (for object references) or default values (for primitives)
During deserialization, the class of all objects in the graph must be available to the JVM.
You read objects in (using readObject()) in the order in which they were originally written.
The return type of readObject() is type Object, so deserialized objects must be cast to their real type.
Static variables are not serialized! It doesn’t make sense to save a static variable value as part of a specific object’s state, since all objects of that type share only a single value—the one in the class.
Writing a String to a Text File Saving objects, through serialization, is the    easiest way to save and restore data between runnings of a Java program.
But sometimes you need to save data to a plain old text ﬁ le.
Imagine your Java program has to write data to a simple text ﬁ le that some other (perhaps nonJava) program needs to read.
You might, for example, have a servlet (Java code running within your web server) that takes form data the user typed into a browser, and writes it to a text ﬁ le that somebody else loads into a spreadsheet for analysis.
What the game character data might look like if you wrote it out as a human-readable text file.
The write() method takes a String Close it when you’re done!
Text File Example: e-Flashcards Remember those ﬂ ashcards you used in school? Where you had a question on one side and the answer on the back? They aren’t much help when you’re trying to understand something, but nothing beats ‘em for raw drill-and-practice and rote memorization.
We’re going to make an electronic   version that has three classes:
QuizCardBuilder, a simple authoring tool for creating and saving a set of e-Flashcards.
QuizCardPlayer, a playback engine that can load a ﬂ ashcard set and play it for the user.
We’ll walk through the code for the builder and the player, and have you make the QuizCard class yourself, using this.
Has a File menu with a “Save” option for saving the current set of cards to a text ﬁ le.
Has a File menu with a “Load” option for loading a set of cards from a text ﬁ le.
Nothing special, although you might want to look at the MenuBar, Menu, and MenuItems code.
We chain a BufferedWriter on to a new FileWriter to make writing more efficient.
Walk through the ArrayList of cards and write them out, one card per line, with the question and an-swer separated by a “/”, and then add a newline character (“\n”)
We add the menu to the menu bar, then tell the frame to use this menu bar.
The java.io.File class The java.io.File class represents a ﬁ le on disk, but doesn’t actually represent the contents of the ﬁ le.
What? Think of a File object as something more like a pathname of a ﬁ le (or even a directory) rather than The Actual File Itself.
The File class does not, for example, have methods for reading and writing.
One VERY useful thing about a File object is that it offers a much safer way to represent a ﬁ le than just using a String ﬁ le name.
For example, most classes that take a String ﬁ le name in their constructor (like FileWriter or FileInputStream) can take a File object instead.
You can  construct a File object, verify that you’ve got a valid path, etc.
A File object represents the name and path of a ﬁ le or directory on disk, for example:
But it does NOT represent, or give you access to, the data in the ﬁ le!
Get the absolute path of a ﬁ le or directory4
Delete a ﬁ le or directory (returns true if successful)
FileWriter (a connection stream that writes characters as opposed to bytes)
When the buffer is full, the Strings are all written to.
The beauty of buffers If there were no buffers, it would be like shopping without a cart.
You’d have to carry each thing out to your car, one soup can or toilet paper roll at a time.
The cool thing about buffers is that they’re much more efﬁ cient than working without them.
You can write to a ﬁ le using FileWriter alone, by calling write(someString), but FileWriter writes each and every thing you pass to the ﬁ le each and every time.
That’s overhead you don’t want or need, since every trip to the disk is a Big Deal compared to manipulating data in memory.
By chaining a BufferedWriter onto a FileWriter, the BufferedWriter will hold all the stuff you write to it until it’s full.
Only when the buffer is full will the FileWriter actually be told to write to the ﬁ le on disk.
If you do want to send data before the buffer is full, you do have control.
Calls to writer.ﬂ ush() say, “send whatever’s in the buffer, now!”
You get     to make far fewer trips when you use a buffer.
Reading from a Text File Reading text from a ﬁ le is simple, but this time we’ll use a File object to represent the ﬁ le, a FileReader to do the actual reading, and a BufferedReader to make the reading more efﬁ cient.
The read happens by reading lines in a while loop, ending the loop when the result of a readLine() is null.
That’s the most common style for reading data (pretty much anything that’s not a Serialized object): read stuff in a while loop (actually a while loop test), terminating when there’s nothing left to read (which we know because the result of whatever read method we’re using is null)
A FileReader is a connection stream for characters, that connects to a text file.
Check the isShowAnswer boolean flag to see if they’re currently viewing a question or an answer, and do the appropriate thing depending on the answer.
Parsing with String split() Imagine you have a ﬂ ashcard like this:
What is blue + yellow?/green What is red + blue?/purple.
When you read the ﬁ le, the  question and answer are smooshed together in one line, separated by a forward slash “/” (because that’s how we wrote the ﬁ le in the QuizCardBuilder code)
The split() method says, “give me a separator, and I’ll break out all the pieces of this String for you and put them in a String array.”
In this example, there are only two tokens: “What is blue + yellow?” and “green”
The split() method takes the “/” and uses it to break apart the String into (in this case) two pieces.
Note: split() is FAR more powerful than what we’re using it for here.
It can do extremely complex parsing with filters, wildcards, etc.
Q:OK, I look in the API and there are about ﬁ ve million classes in the java.io package.
How the heck do you know which ones to use?
The chains don’t have to stop at two levels; you can hook multiple chain streams to one another to get just the right amount of processing you need.
Most of the time, though, you’ll use the same small handful of classes.
If you’re writing text files, BufferedReader and BufferedWriter (chained to FileReader and FileWriter) are probably all you need.
If you’re writing serialized objects, you can use ObjectOutputStream and ObjectInputStream (chained to FileInputStream and FileOutputStream)
In other words, 90% of what you might typically do with Java I/O can use what we’ve already covered.
Q:What about the new I/O nio classes added in 1.4?
A:The java.nio classes bring a big performance improvement and take greater advantage of native capabilities of the machine your program is running on.
One of the key new features of nio is that you have direct control of buffers.
Another new feature is nonblocking I/O, which means your I/O code doesn’t just sit there, waiting, if there’s nothing to read or write.
Some of the existing classes (including FileInputStream and FileOutputStream) take advantage of some of the new features, under the covers.
The nio classes are more complicated to use, however, so unless you really need the new features, you might want to stick with the simpler versions we’ve used here.
Plus, if you’re not careful, nio can lead to a performance loss.
Non-nio I/O is probably right for 90% of what you’ll normally do, especially if you’re just getting started in Java.
But you can ease your way into the nio classes, by using FileInputStream and accessing its channel through the getChannel() method (added to FileInputStream as of version 1.4)
A common approach is to use some kind of character to separate the individual pieces.
A String with one separator will have two tokens, one on each side of the separator.
The chains don’t have to stop at two levels; you can hook.
The chains don’t have to stop at two levels; you can hook.
Version ID: A Big Serialization Gotcha Now you’ve seen that I/O in Java is actually pretty simple, especially if you stick to the most common connection/chain combinations.
Version Control is crucial! If you serialize an object, you must have the class in order to deserialize and use the object.
But what might be less obvious is what happens if you change the class in the meantime? Yikes.
Imagine trying to bring back a Dog object when one of its instance variables (non-transient) has changed from a double to a String.
But that’s not the only change      that might hurt compatibility.
Changing a class (anywhere in the object graph) from Serializable to not Serializable (by removing ‘implements Serializable’ from a class declaration)
Adding new instance variables to the class (existing objects will deserialize with default values for the instance variables they didn’t have when they were serialized)
Changing the access level of an instance variable has no affect on the ability of deserialization to assign a value to the variable.
The JVM says, “you can’t teach an old Dog new code”
Each time an object is serialized, the object (including every object in its graph) is ‘stamped’ with a version ID number for the object’s class.
The ID is called the serialVersionUID, and it’s computed based on information about the class structure.
As an object is being deserialized, if the class has changed since the object was serialized, the class could have a different serialVersionUID, and deserialization will fail! But you can control this.
If you think there is ANY possibility that your class might evolve, put a serial version ID in your class.
When Java tries to deserialize an object, it compares the serialized object’s serialVersionUID with that of the class the JVM is using for deserializing the object.
For example, if a Dog instance was serialized with an ID of, say 23 (in reality a serialVersionUID is much longer), when the JVM deserializes the Dog object it will ﬁrst compare the Dog object serialVersionUID with the Dog class serialVersionUID.
So, the solution is to put a serialVersionUID in your class, and then as the class evolves, the serialVersionUID will remain the same and the JVM will say, “OK, cool, the class is compatible with this serialized object.” even though the class has actually changed.
This works only if you’re careful with your class changes! In other words, you are taking responsibility for any issues that come up when an older object is brought back to life with a newer class.
To get a serialVersionUID for a class, use the serialver tool that ships with your Java development kit.
Use the serialver command-line tool to get the version ID for your class.
Be sure that when you make changes to the class, you take responsibility in your code for the consequences of the changes you made to the class! For example, be sure that your new Dog class can deal with an old Dog being deserialized with default values for instance variables added to the class after the Dog was serialized.
When you think your class might evolve after someone has serialized objects from it...
Let’s make the BeatBox save and restore our favorite pattern.
Remember, in the BeatBox, a drum pattern is nothing more than a bunch of checkboxes.
When it’s time to play the sequence, the code walks through the checkboxes to ﬁgure out which drums sounds are playing at each of the 16 beats.
So to save a pattern, all we need to do is save the state of the checkboxes.
We can make a simple boolean array, holding the state of each of the 256 checkboxes.
An array object is serializable as long as the things in the array are serializable, so we’ll have no trouble saving an array of booleans.
To load a pattern back in, we read the single boolean array object (deserialize it), and restore the checkboxes.
Most of the code you’ve already seen, in the Code Kitchen where we built the BeatBox GUI, so in this chapter, we look at only the save and restore code.
This CodeKitchen gets us ready for the next chapter, where instead of writing the pattern to a ﬁle, we send it over the network to the server.
And instead of loading a pattern in from a ﬁle, we get patterns from the server, each time a participant sends one to the server.
Make a boolean array to hold the state of each checkbox.
Walk through the checkboxList (ArrayList of checkboxes), and get the state of each one, and add it to the boolean array.
It all happens when the user hits the “restore” ‘button.
Now restore the state of each of the checkboxes in the ArrayList of actual JCheckBox objects (checkboxList)
Sharpen your pencil This version has a huge limitation! When you hit the “serializeIt” button, it serializes automatically, to a file named “Checkbox.ser” (which gets created if it doesn’t exist)
But each time you save, you overwrite the previously-saved file.
Improve the save and restore feature, by incorporating a JFileChooser so that you can name and save as many different patterns as you like, and load/restore from any of your previously-saved pattern files.
Which of these do you think are, or should be, serializable? If not, why not? Not meaningful? Security risk? Only works for the current execution of the JVM? Make your best guess, without looking it up in the API.
Your job is to decide whether each of the following I/O-related statements is true or false.
Serialization is appropriate when saving data for non-Java programs to use.
Chain streams can be used on their own or with connection streams.
A single call to writeObject() can cause many objects to be saved.
The transient modiﬁer allows you to make instance variables serializable.
If a superclass is not serializable then the subclass can’t be serializable.
When objects are deserialized, they are read back in last-in, ﬁrst out sequence.
When an object is deserialized, its constructor does not run.
Both serialization and saving to a text ﬁle can throw exceptions.
You can’t force a buffer to send its data before it’s full.
The String split() method includes separators as tokens in the result array.
Any change to a class breaks previously serialized objects of that class.
This one’s tricky, so we promoted it from an Exercise to full Puzzle status.
Serialization is appropriate when saving data for non-Java programs to use.
Chain streams can be usedon their own or with connection streams.
A single call to writeObject() can cause many objects to be saved.
The transient modiﬁer allows you to make instance variables serializable.
If a superclass is not serializable then the subclass can’t be serializable.
When objects are deserialized they are read back in last-in, ﬁrst out sequence.
When an object is deserialized, its constructor does not run.
Both serialization and saving to a text ﬁle can throw exceptions.
You can’t force a buffer to send its data before it’s full.
Both ﬁle readers and ﬁle writers can optionally be buffered.
The String split() method includes separators as tokens in the result array.
Any change to a class breaks previously serialized objects of that class.
Your Java program can reach out and touch a program on another machine.
All the low-level networking details are taken care of by.
One of Java’s big benefits is that sending and receiving data over.
And the BufferedReader could care less if the data came.
Did we just say multithreaded?   Yes, now you will learn the secret of.
You and your team are doing the sound design for each part of the game.
Using a ‘chat’ version of the Beat Box, your team can collaborate—you can send a beat pattern along with your chat message, and everybody in the Beat Box Chat gets it.
So you don’t just get to read the other participants’ messages, you get to load and play a beat pattern simply by clicking the message in the incoming messages area.
In this chapter we’re going to  learn what it takes to make a chat client like this.
We’re even going to learn a little about making a chat server.
Why am I here?   Don’t expect ME to answer that.
Why am I here?   Don’t expect ME to answer that.
Why am I here?   Don’t expect ME to answer that.
The server makes a connection and adds the client to the list of participants.
Why am I here? Don’t expect ME to answer that.
Why am I here? Don’t expect ME to answer that.
The server distributes the message to ALL participants (including the original sender) Server.
Why am I here? Don’t expect ME to answer that.
Message distributed to all participantsWhy am I here?   Don’t expect.
Connecting, Sending, and Receiving The three things we have to learn to get the client working are :
There’s a lot of low-level stuff that has to happen for these things to work.
But we’re lucky, because the Java API networking package (java.net) makes it a piece of cake for programmers.
You’ll see a lot more GUI code than networking and I/O code.
Lurking within the simple chat client is a problem we haven’t faced so far in this book: doing two things at the same time.
Establishing a connection is a one-time operation (that either works or fails)
But after that, a chat participant wants to send outgoing messages and simultaneously receive incoming messages from the other participants (via the server)
Connect1 Client connects to the server by establishing a Socket connection.
Make a network Socket connection To connect to another machine, we need a Socket connection.
What’s a connection? A relationship between two machines, where two pieces of software know about each other.
Most importantly, those two pieces of software know how to communicate with each other.
In other words, how to send bits to each other.
We don’t care about the low-level details, thankfully, because they’re handled at a much lower place in the ‘networking stack’
If you don’t know what the ‘networking stack’ is, don’t worry about it.
It’s just a way of looking at the layers that information (bits) must travel through to get from a Java program running in a JVM on some OS, to physical hardware (ethernet cables, for example), and back again on some other machine.
Somebody has to take care of all the dirty details.
That somebody is a combination of OS-speciﬁc software and the Java networking API.
The part that you have to worry about is high-level—make that very high-level—and shockingly simple.
To make a Socket connection, you need to know two things about the server: who it is, and which port it’s running on.
A Socket connection means the two machines have information about each other, including network location (IP address) and TCP port.
When I need to talk to him, that’s where I’ll send.
A 16-bit number that identifies a specific program on the server.
They represent a logical connection to a particular piece of software running on the server.
You can’t spin your hardware box around and ﬁnd a TCP port.
So they obviously don’t represent a place to plug in physical devices.
Without port numbers, the server would have no way of knowing which application a client wanted to connect to.
And since each application might have its own unique protocol, think of the trouble you’d have without these identiﬁers.
When you write a server program, you’ll include code that tells the program which port number you want it to run on (you’ll see how to do this in Java a little later in this chapter)
And if you’re writing services (server programs) to run on a company network, you should check with the sys-admins to ﬁnd out which ports are already taken.
In any case, if you value your limbs, you won’t assign port numbers with abandon.
In which case you just have to check with your kids.
Well, you might be able to use one of these, but the sys-admin where you work will probably kill you.
A server can have up to 65536 different server apps running, one per port.
The client and the server know the IP address and TCP port number for each other.
Now what? How do you communicate over that connection? In other words, how do you move bits from one to the other? Imagine the kinds of messages your chat client needs to send and receive.
Q: How do you know the port number of the server program you want to talk to?
A: That depends on whether the program is one of the well-known services.
But if the program isn’t one of the well-known services, you need to find out from whoever is deploying the service.
Typically, if someone writes a network service and wants others to write clients for it, they’ll publish the IP address, port number, and protocol for the service.
For example, if you want to write a client for a GO game server, you can visit one of the GO server sites and find information about how to write a client for that particular server.
Q: Can there ever be more than one program running on a single port? In other words, can two applications on the same server have the same port number?
A: No! If you try to bind a program to a port that is already in use, you’ll get a BindException.
To bind a program to a port just means starting up a server application and telling it to run on a particular port.
Again, you’ll learn more about this when we get to the server part of this chapter.
Regular old I/O streams, just like we used in the last chapter.
One of the coolest features in Java is that most of your I/O work won’t care what your high-level chain stream is actually connected to.
In other words, you can use a BufferedReader just like you did when you were writing to a ﬁle, the difference is that the underlying connection stream is connected to a Socket rather than a File!
You can use this when you’re testing your client and server on a single, stand-alone machine.
Make an InputStreamReader chained to the Socket’s low-level (connection) input stream.
All we have to do is ASK the socket for an input stream! It’s a low-level connection stream, but we’re just gonna chain it to something more text-friendly.
We didn’t use PrintWriter in the last chapter, we used BufferedWriter.
We have a choice here, but when you’re writing one String at a time, PrintWriter is the standard choice.
And you’ll recognize the two key methods in PrintWriter, print() and println()! Just like good ol’ System.out.
Make a PrintWriter chained to the Socket’s low-level (connection) output stream.
The Socket gives us a low-level connection stream and we chain it to the PrintWriter by giving it to the PrintWriter constructor.
Before we start building the Chat app, let’s start with something a little smaller.
The Advice Guy is a server program that offers up practical, inspirational tips to get you through those long days of coding.
We’re building a client for The Advice Guy program, which pulls a message from the server each time it connects.
What are you waiting for? Who knows what opportunities you’ve missed without this app.
The DailyAdviceClient Treat yourself to a cold one! You deserve it!
The Advice Guy Connect1 Client connects to the server and gets an input stream from it.
In other words, by the time you call a BufferedWriter method, the writer doesn’t know or care where the characters came from.
This program makes a Socket, makes a BufferedReader (with the help of other streams), and reads a single line from the server application (whatever is running at port 4242)
Sharpen your pencil Test your memory of the streams/classes for reading and writing from a Socket.
What two pieces of information does the client need in order to make a Socket connection with a server?
Which TCP port numbers are reserved for ‘well-known services’ like HTTP and FTP?
Writing a simple server So what’s it take to write a server application? Just a couple of Sockets.
A ServerSocket, which waits for client requests (when a client makes a new Socket()) and a plain old Socket socket to use for communication with the client.
Client knows the IP address and port number (published or given to him by whomever conﬁgures the server app to be on that port)
The accept() method blocks (just sits there) while it’s waiting for a client Socket connection.
When a client ﬁnally tries to connect, the method returns a plain old Socket (on a different port) that knows how to communicate with the client (i.e., knows the client’s IP address and port number)
The Socket is on a different port than the ServerSocket, so that the ServerSocket can go back to waiting for other clients.
DailyAdviceServer code This program makes a ServerSocket and waits for client requests.
Then we close the Socket because we’re done with this client.
It’s used primarily to act as the middle chain between the high-level BufferedReader and the low-level Socket input stream.
Call the print() or println() methods to send Strings to the server.
HeadFirst: Can you tell us the difference between a ServerSocket and a plain old Socket?
Without me, the application is just a piece of  code running inside a JVM with no way for any clients to connect.
HeadFirst: But don’t regular Sockets connect to the outside world? Isn’t that what a socket is for? To connect?
ServerSocket: Yeah but you’re missing the point here—a regular Socket can only request connections, it can’t accept connections.
It can call out, but if  nobody’s at the other end to get the request, the client’s Socket request will fail.
ServerSocket: I’ve been in the spec since the very beginning! Back in version 1.0, when entity beans were considered “optional”
And then in the 2.0 spec, they add MessageDrivenBeans who don’t even do much.
It’s hard for me to be upset about EntityBeans because they work so hard, what with the database and everything, but come on – MessageDrivenBeans don’t do anything except wait for the digital UPS guy to show up with a message.
Half  they time they don’t even do anything except turn around and hand it someone else to do the real work.
So they can run back to their inﬂatable mattress and unbrella drinks.
HeadFirst: If  a pool is such a nice feature, why don’t stateful session beans get one?
ServerSocket: We’re the only bean that can establish a real relationship with a client.
Unlike my cohorts, I can remember things from one method invocation to the next.
I can maintain a conversation with a client, and keep track of  the current state.
So as long as the client wants me, I’m at her service.
You click the little button to put things into your cart, right? Well where do you think they go? Somebody has to keep track of  your cart.
But when you’re done shopping, my life (in this case, as the bean keeping your cart) has no meaning, and I’m cut loose, trying to stay one step ahead of  the garbage collector.
The client knows the IP address and port number of the server, but how is the server able to make a Socket connection with the client (and make input and output streams)?
Think about how / when / where the server gets knowledge about the client.
It can’t accept a request from a client until it has finished with the current client and started the next iteration of the infinite loop (where it sits at the accept() call until a request comes in, at which time it makes a Socket with the new client and starts the process over again)
Q: Let me rephrase the problem: how can you make a server that can handle multiple clients concurrently??? This would never work for a chat server, for instance.
Use separate threads, and give each new client Socket to a new thread.
Writing a Chat Client We’ll write the Chat client application in two stages.
First we’ll make a send-only version that sends messages to the server but doesn’t get to read any of the messages from other participants (an exciting and mysterious twist to the whole chat room concept)
Then we’ll go for the full chat monty and make one that both sends and receives chat messages.
Remember, the writer is chained to the input stream from the Socket, so whenever we do a println(), it goes over the network to the server!
If you want to try this now, type in the Ready-bake chat server code listed at the end of this chapter.
The Server sends a message to all client participants, as soon as the message is received by the server.
When a client sends a message, it doesn’t appear in the incoming message display area until the server sends it to everyone.
Big Question: HOW do you get messages from the server?
Should be easy; when you set up the networking make an input stream as well (probably a BufferedReader)
Bigger Question: WHEN do you get messages from the server? Think about that.
And why 20 seconds? A delay like this affects usability, but as you reduce the delay, you risk hitting your server needlessly.
Option Two: Read something in from the server each time the user sends a message.
Why choose such an arbitrary time to check for messages? What if a user is a lurker and doesn’t send anything?
Cons: How do you do you do two things at the same time? Where would you put this code? You’d need a loop somewhere that was always waiting to read from the server.
But where would that go? Once you launch the GUI, nothing happens until an event is ﬁred by a GUI component.
You know by now that we’re going with option three.
In Java you really CAN walk and chew gum at the same time.
We want something to run  continuously, checking for messages from the server, but without interrupting the user’s ability to interact with the GUI! So while the user is happily typing new messages or scrolling through the incoming messages, we want something behind the scenes to keep reading in new input from the server.
We want everything we did in the SendOnly version (version one) to work the same way, while a new process runs along side that reads information from the server and displays it in the incoming text area.
Unless you have multiple processors on your computer, each new Java thread is not actually a separate process running on the OS.
Java has multiple threading built right into the fabric of the language.
And it’s a snap to make a new thread of execution:
By creating a new Thread object, you’ve launched a separate thread of execution, with its very own call stack.
That thread doesn’t actually do anything, so the thread “dies” virtually the instant it’s born.
In other words, we need the code that you want to have run by a separate thread.
Multiple threading in Java means we have to look at both the thread and the job that’s run by the thread.
And we’ll also have to look at the Thread class in the java.lang package.
Remember, java.lang is the package you get imported for free, implicitly, and it’s where the classes most fundamental to the language live, including String and System.
When you see thread, we’re talking about a separate thread of execution.
When you see Thread, think of the Java naming convention.
What, in Java, starts with a capital letter? Classes and interfaces.
In this case,  Thread is a class in the java.lang package.
A Thread object represents a thread of execution; you’ll create an instance of class Thread each time you want to start up a new  thread of execution.
A thread (lower-case ‘t’) is a separate thread of execution.
Every Java application starts up a main thread—the thread that puts the main() method on the bottom of the stack.
The JVM is responsible for starting the main thread (and other threads, as it chooses, including the garbage collection thread)
As a programmer, you can write code to start other threads of your own.
Thread (capital ‘T’) is a class that represents a thread of execution.
It has methods for starting a thread, joining one thread with another, and putting a thread to sleep.
A Thread is a Java class that represents a thread.
What does it mean to have more than one call stack? With more than one call stack, you get the appearance of having multiple things happen at the same time.
In reality, only a true multiprocessor system can actually do more than one thing at a time, but with Java threads, it can appear that you’re doing several things simultaneously.
In other words, execution can move back and forth between stacks so rapidly that you feel as though all stacks are executing at the same time.
Remember, Java is just a process running on your underlying OS.
So ﬁrst, Java itself has to be ‘the currently executing process’ on the OS.
But once Java gets its turn to execute, exactly what does the JVM run? Which bytecodes execute?  Whatever is on the top of the currently-running stack! And in 100 milliseconds, the currently executing code might switch to a different method on a different stack.
One of the things a thread must do is keep track of which statement (of which method) is currently executing on the thread’s stack.
The main thread is temporarily frozen while the new thread starts running.
The JVM switches between the new thread (user thread A) and the original main thread, until both threads complete.
Runnable is an interface you’ll learn about on the next page.
You’ll write a class that implements the Runnable interface, and that class is where you’ll deﬁne the work that a thread will perform.
In other words, the method that will be run from the thread’s new call stack.
Make a Thread object (the worker) and give it a Runnable (the job)
This tells the new Thread object which method to put on the bottom of the new stack—the Runnable’s run() method.
That’s when you go from having just a Thread instance to having a new thread of execution.
When the new thread starts up, it takes the Runnable object’s run() method and puts it on the bottom of the new thread’s stack.
A job the thread will run when the thread is started.
That job is actually the ﬁrst method that goes on the new thread’s stack, and it must always be a method that looks like this:
How does the thread know which method to put at the bottom of the stack? Because Runnable deﬁnes a contract.
A thread’s job can be deﬁned in any class that implements the Runnable interface.
The thread cares only that you pass the Thread constructor an object of a class that implements Runnable.
When you pass a Runnable to a Thread constructor, you’re really just giving the Thread a way to get to a run() method.
Runnable is to a Thread what a job is to a worker.
A Runnable is the job a thread is supposed to run.
A Runnable holds the method that goes on the bottom of the new thread’s stack: run()
To make a job for your thread, implement the Runnable interface.
Runnable has only one method to implement: public void run() (with no arguments)
This is where  you put the JOB the thread is supposed to run.
This is the method that goes at the bottom of the new stack.
You won’t get a new thread of execution until you call start() on the Thread instance.
A thread is not really a thread until you start it.
Before that, it’s just a Thread instance, like any other object, but it won’t have any real ‘threadness’
In other words, there is a Thread object, but no thread of execution.
When you start the thread, it moves into the runnable state.
This means the thread is ready to run and just waiting for its Big Chance to be selected for execution.
At this point, there is a new call stack for this thread.
This is the state all threads lust after! To be The Chosen One.
You can sometimes inﬂuence that decision, but you cannot force a thread to move from runnable to running.
In the running state, a thread (and ONLY this thread) has an active call stack, and the method on the top of the stack is executing.
Once the thread becomes runnable, it can move back and forth between runnable, running, and an additional state: temporarily not runnable (also known as ‘blocked’)
Sent back to runnable so another thread can have a chance.
Typically, a thread moves back and forth between runnable and running, as the JVM thread scheduler selects a thread to run and then kicks it back out so another thread gets a chance.
The thread scheduler can move a running thread into a blocked state, for a variety of reasons.
For example, the thread might be executing code to read from a Socket input stream, but there isn’t any data to read.
The scheduler will move the thread out of the running state until something becomes available.
Or the executing code might have told the thread to put itself to sleep (sleep())
Or the thread might be waiting because it tried to call a method on an object, and that object was ‘locked’
In that case, the thread can’t continue until the object’s lock is freed by the thread that has it.
All of those conditions (and more) cause a thread to become temporarily not-runnable.
Oh, now it looks like you’re gonna have to sleep.
He might let one thread run to its heart’s content while the other threads ‘starve’
The thread scheduler makes all the decisions about who moves from runnable to running, and about when (and under what circumstances) a thread leaves the running state.
The scheduler decides who runs, and for how long, and where the threads go when the scheduler decides to kick them out of the currently-running state.
There is no API for calling methods on the scheduler.
The bottom line is this: do not base your program’s correctness on the scheduler working in a particular way! The scheduler implementations are different for different JVM’s, and even running the same program on the same machine can give you different results.
One of the worst mistakes new Java programmers make is to test their multi-threaded program on a single machine, and assume the thread scheduler will always work that way, regardless of where the program runs.
That means that you can’t be dependent on, for example, the scheduler making sure all the threads take nice, perfectly fair and equal turns at the running state.
Although highly unlikely today, your program might end up running on a JVM with a scheduler that says, “OK thread ﬁve, you’re up, and as far as I’m concerned, you can stay here until you’re done, when your run() method completes.”
Putting a thread to sleep, even for a few milliseconds, forces the currently-running thread to leave the running state, thus giving another thread a chance to run.
The thread’s sleep() method does come with one guarantee: a sleeping thread will not become the currently-running thread before the the length of its sleep time has expired.
For example, if you tell your thread to sleep for two seconds (2,000 milliseconds), that thread can never become the running thread again until sometime after the two seconds have passed.
The scheduler sends the main thread out of running and back to runnable, so that the new thread can run.
The scheduler lets the new thread run to completion, printing out “top o’ the stack”
The main thread once again becomes the running thread, and prints “back in main”
The scheduler sends the main thread out of running and back to runnable, so that the new thread can run.
The scheduler lets the new thread run for a little while, not long enough for the run() method to complete.
The scheduler selects the main thread to be the running thread again.
The new thread returns to the running state and prints out “top o’ the stack”
A Thread’s job is an instance of something that implements the Runnable interface.
This is the method that goes on the bottom of the new call stack.
In other words, it is the first method to run in the new thread.
The thread is now in the RUNNABLE state, waiting to be chosen to run.
On a single-processor machine, there can be only one currently-running thread.
A thread might be blocked because it’s waiting for data from a stream, or because it has gone to sleep, or because it is waiting for an object’s lock.
You can help influence turn-taking by putting your threads to sleep periodically.
That way, you call the Thread’s no-arg constructor when you make the new thread;
A: Yes, that is another way of making your own thread, but think about it from an OO perspective.
What’s the purpose of subclassing? Remember that we’re talking about two different things here—the Thread and the thread’s job.
From an OO view, those two are very separate activities, and belong in separate classes.
The only time you want to subclass/extend the Thread class, is if you are making a new and more specific type of Thread.
In other words, if you think of the Thread as the worker, don’t extend the Thread class unless you need more specific worker behaviors.
But if all you need is a new job to be run by a Thread/worker, then implement Runnable in a separate, job-specific (not worker-specific) class.
This is a design issue and not a performance or language issue.
It’s perfectly legal to subclass Thread and override the run() method, but it’s rarely a good idea.
Q: Can you reuse a Thread object? Can you give it a new job to do and then restart it by calling start() again?
Once a thread’s run() method has completed, the thread can never be restarted.
In fact, at that point the thread moves into a state we haven’t talked about—dead.
In the dead state, the thread has finished its run() method and can never be restarted.
The Thread object might still be on the heap, as a living object that you can call other methods on (if appropriate), but the Thread object has permanently lost its ‘threadness’
In other words, there is no longer a separate call stack, and the Thread object is no longer a thread.
It’s just an object, at that point, like all other objects.
But, there are design patterns for making a pool of threads that you can keep using to perform different jobs.
But you don’t do it by restarting() a dead thread.
Putting a thread to sleep One of the best ways to help your threads take turns is to put them to sleep periodically.
The thread can’t become the running thread again until after at least two seconds have passed.
Your thread will probably never be interrupted from sleep; the exception is in the API to support a thread communication mechanism that almost nobody uses in the Real World.
But, you still have to obey the handle or declare law, so you need to get used to wrapping your sleep() calls in a try/catch.
Now you know that your thread won’t wake up before the speciﬁed duration, but is it possible that it will wake up some time after the ‘timer’ has expired? Yes and no.
It doesn’t matter, really, because when the thread wakes up, it always goes back to the runnable state! The thread won’t automatically wake up at the designated time and become the currently-running thread.
When a thread wakes up, the thread is once again at the mercy of the thread scheduler.
Now, for applications that don’t require perfect timing, and that have only a few threads, it might appear as though the thread wakes up and resumes running right on schedule (say, after the 2000 milliseconds)
Put your thread to sleep if you want to be sure that other threads get a chance to run.
When the thread wakes up, it always goes back to the runnable state and waits for the thread scheduler to choose it to run again.
Remember our earlier example that kept giving us different results each time we ran it? Look back and study the code and the sample output.
Sometimes main had to wait until the new thread ﬁnished (and printed “top o’ the stack”), while other times the new thread would be sent back to runnable before it was ﬁnished, allowing the main thread to come back in and print out “back in main”
We’ll wait while you work out an answer (there’s more than one answer that would work)
This is what we want—a consistent order of print statements:
You can give your threads a name of your choosing, or you can accept their default names.
But the cool thing about names is that you can use them to tell which thread is running.
Each thread has the same job: run in a loop, printing the currently-running thread’s name with each iteration.
Make two threads, with the same Runnable (the same job--we’ll talk more about the “two threads and one Runnable” in a few pages)
What will happen? Will the threads take turns? Will you see the thread names alternating? How often will they switch? With each iteration? After ﬁve iterations?
You already know the answer: we don’t know! It’s up to the scheduler.
And on your OS, with your particular JVM, on your CPU, you might get very different results.
Running under OS X 10.2 (Jaguar), with ﬁve or fewer iterations, the Alpha thread runs to completion, then the Beta thread runs to completion.
But when you up the loop to 25 or more iterations, things start to wobble.
The Alpha thread might not get to complete all 25 iterations before the scheduler sends it back to runnable to let the Beta thread have a chance.
Alpha thread is running Alpha thread is running Alpha thread is running Beta thread is running Alpha thread is running Beta thread is running Beta thread is running Beta thread is running Beta thread is running Beta thread is running Beta thread is running Beta thread is running Beta thread is running Beta thread is running Beta thread is running Beta thread is running Beta thread is running Beta thread is running Beta thread is running Alpha thread is running.
Part of the output when the loop iterates 25 times.
It all comes down to one potentially deadly scenario: two or more threads have access to a single object’s data.
In other words, methods executing on two different stacks are both calling, say, getters or setters on a single object on the heap.
Two threads, without a care in the world, humming along executing their methods, each thread thinking that he is the One True Thread.
After all, when a thread is not running, and in runnable (or blocked) it’s essentially knocked unconscious.
When it becomes the currently-running thread again, it doesn’t know that it ever stopped.
Wow! Threads are the greatest thing since the MINI Cooper! I can’t think of a single downside to using.
Can this couple be saved? Next, on a very special Dr.Steve Show.
We’ve got a story today that’s centered around the top two reasons why couples split up—ﬁnances and sleep.
Today’s troubled pair, Ryan and Monica, share a bed and a bank account.
But not for long if we can’t ﬁnd a solution.
Ryan and I agreed that neither of us will overdraw the checking account.
So the procedure is, whoever wants to withdraw money must check the balance in the account before making the withdrawal.
But suddenly we’re bouncing checks and getting hit with overdraft fees!
I thought it wasn’t possible, I thought our procedure was safe.
And that’s where I come in, while Ryan’s still asleep, and now I want to withdraw $100
I check the balance, and it’s $100 (because Ryan’s still asleep and hasn’t yet made his withdrawal), so I think, no problem.
But then Ryan wakes up, completes his withdrawal, and we’re suddenly overdrawn! He didn’t even know that he fell asleep, so he just went ahead and completed his transaction without checking the balance again.
Is there a solution? Are they doomed? We can’t stop Ryan from falling asleep, but can we make sure that Monica can’t get her hands on the bank account until after he wakes up?
Take a moment and think about that while we go to a commercial break.
Ryan and Monica: victims of the “two people, one account” problem.
The Ryan and Monica problem, in code The following example shows what can happen when two threads (Ryan and Monica) share a single object (the bank account)
The MonicaAndRyanJob class implements Runnable, and represents the behavior that Ryan and Monica both have—checking the balance and making withdrawals.
But of course, each thread falls asleep in between checking the balance and actually making the withdrawal.
The MonicaAndRyanJob class has an instance variable of type BankAccount., that represents their shared account.
The RyanAndMonicaJob class is the Runnable (the job to do), and since both Monica and Ryan do the same thing (check balance and withdraw money), we need only one instance.
Make two threads with the same Runnable (the RyanAndMonicaJob instance)
Watch both threads execute the run() method (check the balance and make a withdrawal)
Both threads continually check the balance and then make a withdrawal, but only if it’s safe!
In the run() method, do exactly what Ryan and Monica would do—check the balance and, if there’s enough money, make the withdrawal.
Ryan and Monica always fall asleep after they check the balance but before they ﬁ nish the withdrawal.
Instantiate the Runnable (job)Make two threads, giving each thread the same Runnable job.
That means both threads will be accessing the one account instance variable in the Runnable class.
We put in a bunch of print statements so we can see what’s happening as it runs.
The makeWithdrawal() method always checks the balance before making a withdrawal, but still we overdraw the account.
Ryan checks the balance, sees that there’s enough money, and then falls asleep.
She has no idea that Ryan is going to wake up and complete a withdrawal.
Big Problem! In between the time when she checked the balance and made the withdrawal, Ryan woke up and pulled money from the account.
Monica’s check of the account was not valid, because Ryan had already checked and was still in the middle of making a withdrawal.
Monica must be stopped from getting into the account until Ryan wakes up and ﬁnishes his transaction.
There’s a lock associated with the bank account transaction (checking the balance and withdrawing money)
There’s only one key, and it stays with the lock until somebody wants to access the account.
When Ryan wants to access the bank account (to check the balance and withdraw money), he locks the lock and puts the key in his pocket.
Now nobody else can access the account, since the key is gone.
Ryan keeps the key in his pocket until he ﬁnishes the transaction.
He has the only key, so Monica can’t access the account (or the checkbook) until Ryan unlocks the account and returns the key.
Now, even if Ryan falls asleep after he checks the balance, he has a guarantee that the balance will be the same when he wakes up, because he kept the key while he was asleep!
The bank account transaction is unlocked when nobody is using the account.
When Ryan wants to access the account, he secures the lock and takes the key.
When Ryan is ﬁnished, he unlocks the lock and returns the key.
Now the key is available for Monica (or Ryan again) to access the account.
We need the makeWithdrawal ( ) method to run as one atomic thing.
The synchronized keyword means that a thread needs a key in order to access the synchronized code.
To protect your data (like the bank account), synchronize the methods that act on that data.
We need to make sure that once a thread enters the makeWithdrawal() method, it must be allowed to ﬁnish the method before any other thread can enter.
In other words, we need to make sure that once a thread has checked the account balance, that thread has a guarantee that it can wake up and ﬁnish the withdrawal before any other thread can check the account balance!
Use the synchronized keyword to modify a method so that only one thread at a time can access it.
That’s how you protect the bank account! You don’t put a lock on the bank account itself; you lock the method that does the banking transaction.
That way, one thread gets to complete the whole transaction, start to ﬁnish, even if that thread falls asleep in the middle of the method!
So if you don’t lock the back account, then what exactly is locked? Is it the method? The Runnable object? The thread itself?
In code, though, it’s quite simple—just add the synchronized modiﬁer to your method declaration:
Note for you physics-savvy readers: yes, the convention of using the word ‘atomic’ here does not reflect the whole subatomic parcticle thing.
Think Newton, not Einstein, when you hear the word ‘atomic’ in the context of threads or transactions.
If WE were in charge, we’d apply Heisenberg’s Uncertainty Principle to pretty much everything related to threads.
Most of the time, the lock is unlocked, and you can imagine a virtual key sitting with it.
Object locks come into play only when there are synchronized methods.
When an object has one or more synchronized methods, a thread can enter a synchronized method only if the thread can get the key to the object’s lock!
The locks are not per method, they are per object.
If an object has two synchronized methods, it does not simply mean that you can’t have two threads entering the same method.
It means you can’t have two threads entering any of the synchronized methods.
If you have multiple methods that can potentially act on an object’s instance variables, all those methods need to be protected with synchronized.
But remember, you don’t lock the data itself, you synchronize the methods that access that data.
So what happens when a thread is cranking through its call stack (starting with the run() method) and it suddenly hits a synchronized method? The thread recognizes that it needs a key for that object before it can enter the method.
It looks for the key (this is all handled by the JVM; there’s no API in Java for accessing object locks), and if the key is available, the thread grabs the key and enters the method.
From that point forward, the thread hangs on to that key like the thread’s life depends on it.
The thread won’t give up the key until it completes the synchronized method.
So while that thread is holding the key, no other threads can enter any of that object’s synchronized methods, because the one key for that object won’t be available.
Most of the time, the lock is unlocked and nobody cares.
But if an object has synchronized methods, a thread can enter one of the synchronized methods ONLY if the key for the object’s lock is available.
In other words, only if another thread hasn’t already grabbed the one key.
The dreaded “Lost Update” problem Here’s another classic concurrency problem, that comes from the database world.
It’s closely related to the Ryan and Monica story, but we’ll use this example to illustrate a few more points.
The trick to showing this is to force the computer to take two steps to complete the change to the balance.
In the real world, you’d do this particular move in a single statement: balance++;
But by forcing it into two steps, the problem with a non-atomic process will become clear.
So imagine that rather than the trivial “get the balance and then add 1 to the current balance” steps, the two (or more) steps in this method are much more complex, and couldn’t be done in one statement.
In the “Lost Update” problem, we have two threads, both trying to increment the balance.
Thread B runs again, and picks up exactly where it left off!
We lost the last updates that Thread A made! Thread B had previously done a ‘read’ of the value of balance, and when B woke up, it just kept going as if it never missed a beat.
Thread A updated it to 5, but now B came back and stepped on top of the update A made, as if A’s update never happened.
Synchronize it! Synchronizing the increment() method solves the “Lost Update” problem, because it keeps the two steps in the method as one unbreakable unit.
Once a thread enters the method, we have to make sure that all the steps in the method complete (as one atomic process) before any other thread can enter the method.
Q: Sounds like it’s a good idea to synchronize everything, just to be thread-safe.
First, a synchronized method has a certain amount of overhead.
In other words, when code hits a synchronized method, there’s going to be a performance hit (although typically, you’d never notice it) while the matter of “is the key available?” is resolved.
Second, a synchronized method can slow your program down because synchronization restricts concurrency.
In other words, a synchronized method forces other threads to get in line and wait their turn.
This might not be a problem in your code, but you have to consider it.
A good rule of thumb is to synchronize only the bare minimum that should be synchronized.
And in fact, you can synchronize at a granularity that’s even smaller than a method.
We don’t use it in the book, but you can use the synchronized keyword to synchronize at the more finegrained level of one or more statements, rather than at the whole-method level.
Now, only these two method calls are grouped into one atomic unit.
When you use the synchronized keyword WITHIN a method, rather than in a method declaration, you have to provide an argument that is the object whose key the thread needs to get.
Although there are other ways to do it, you will almost always synchronize on the current object (this)
That’s the same object you’d lock if the whole method were synchronized.
The method is synchronized, so get the key for this object Put the value of balance into variable i.
The method is synchronized, so we need to get the key.
Thread A runs again, picking up where it left off (remember, it still has the key)
The method is synchronized, so we need to get the key.
The deadly side of synchronization Be careful when you use synchronized code, because nothing will bring your program to its knees like thread deadlock.
Thread deadlock happens when you have two threads, both of which are holding a key the other thread wants.
There’s no way out of this scenario, so the two threads will simply sit and wait.
If you’re familiar with databases or other application servers, you might recognize the problem; databases often have a locking mechanism somewhat like synchronization.
But a real transaction management system can sometimes deal with deadlock.
It might assume, for example, that deadlock might have occurred when two transactions are taking too long to complete.
But unlike Java, the application server can do a “transaction rollback” that returns the state of the rolled-back transaction to where it was before the transaction (the atomic part) began.
If you ﬁnd yourself writing much multithreaded code, you might want to study “Java Threads” by Scott Oaks and Henry Wong for design tips on avoiding deadlock.
One of the most common tips is to pay attention to the order in which your threads are started.
Thread A enters a synchronized method of object foo, and gets the key.
Thread B enters a synchronized method of object bar, and gets the key.
Thread A wakes up (still holding the foo key) and tries to enter a synchronized method on object bar, but can’t get that key because B has it.
All it takes for deadlock are two objects and two threads.
It might, for example, go right back to the front.
All threads get a default name, but giving them an explicit name can help you keep track of threads, especially if you’re debugging with print statements.
In other words, decide which methods must run to completion before another thread enters the same method on the same object.
Most of the time we don’t care about that lock; locks come into play only when an object has synchronized methods.
If the key is not available (because another thread already has it), the thread goes into a kind of waiting lounge, until the key becomes available.
Once any thread has entered a synchronized method on that object, no thread can enter any other synchronized method on the same object.
This restriction lets you protect your data by synchronizing any method that manipulates the data.
New and improved SimpleChatClient Way back near the beginning of this chapter, we built the SimpleChatClient that could send outgoing messages to the server but couldn’t receive anything.
Remember? That’s how we got onto this whole thread topic in the ﬁrst place, because we needed a way to do two things at once: send messages to the server (interacting with the GUI) while simultaneously reading incoming messages from the server, displaying them in the scrolling text area.
We’re starting a new thread, using a new inner class as the Runnable (job) for the thread.
The thread’s job is to read from the server’s socket stream, displaying any incoming messages in the scrolling text area.
When the user clicks the send button, this method sends the contents of the text field to the server.
The really really simple Chat Server You can use this server code for both versions of the Chat Client.
To keep the code stripped down to the bare essentials, we took out a lot of parts that you’d need to make this a real server.
In other words, it works, but there are at least a hundred ways to break it.
If you want a Really Good Sharpen Your Pencil for after you’ve ﬁ nished this book, come back and make this server code more robust.
Another possible Sharpen Your Pencil, that you could do right now, is to annotate this code yourself.
You’ll understand it much better if you work out what’s happening than if we explained it to you.
Then again, this is Ready-bake code, so you really don’t have to understand it at all.
It’s here just to support the two versions of the Chat Client.
First, launch this server from one terminal, then launch the client from another terminal.
Q: What about protecting static variable state? If you have static methods that change the static variable state, can you still use synchronization?
A: Yes! Remember that static methods run against the class and not against an individual instance of the class.
So you might wonder whose object’s lock would be used on a static method? After all, there might not even be any instances of that class.
Fortunately, just as each object has its own lock, each loaded class has a lock.
That means that if you have three Dog objects on your heap, you have a total of four Dog-related locks.
Three belonging to the three Dog instances, and one belonging to the Dog class itself.
When you synchronize a static method, Java uses the lock of the class itself.
So if you synchronize two static methods in a single class, a thread will need the class lock to enter either of the methods.
Q: What are thread priorities? I’ve heard that’s a way you can control scheduling.
A: Thread priorities might help you influence the scheduler, but they still don’t offer any guarantee.
Thread priorities are numerical values that tell the scheduler (if it cares) how important a thread is to you.
In general, the scheduler will kick a lower priority thread out of the running state if a higher priority thread suddenly becomes runnable.
Q: Why don’t you just synchronize all the getters and setters from the class with the data you’re trying to protect? Like, why couldn’t we have synchronized just the checkBalance() and withdraw() methods from class BankAccount, instead of synchronizing the makeWithdrawal() method from the Runnable’s class?
A: Actually, we should have synchronized those methods, to prevent other threads from accessing those methods in other ways.
We didn’t bother, because our example didn’t have any other code accessing the account.
But synchronizing the getters and setters (or in this case the checkBalance() and withdraw()) isn’t enough.
Remember, the point of synchronization is to make a specific section of code work ATOMICALLY.
In other words, it’s not just the individual methods we care about, it’s methods that require more than one step to complete! Think about it.
If we had not synchronized the makeWithdrawal() method, Ryan would have checked the balance (by calling the synchronized checkBalance()), and then immediately exited the method and returned the key!
Of course he would grab the key again, after he wakes up, so that he can call the synchronized withdraw() method, but this still leaves us with the same problem we had before synchronization! Ryan can check the balance, go to sleep, and Monica can come in and also check the balance before Ryan has a chance to wakes up and completes his withdrawal.
So synchronizing all the access methods is probably a good idea, to prevent other threads from getting in, but you still need to synchronize the methods that have statements that must execute as one atomic unit.
It connects to a simple MusicServer so that you can send and receive beat patterns with other clients.
The code is really long, so the complete listing is actually in Appendix A.
Click one to load the pattern that goes with it, and then click ‘Start’ to play it.
A working Java program is scrambled up on the fridge.
Can you add the code snippets on the next page to the empty classes below, to make a working Java program that produces the output listed?  Some of the curly braces fell on the floor and they were too small to  pick up, so feel free to add as many of those as you need!
Bonus Question:   Why do you think we used the modifiers we did in the Accum class?
Threads from two different classes are updating the same object in a third class, because both threads are accessing a single instance of Accum.
As Sarah joined the on-board development team’s design review meeting , she gazed out the portal at sunrise over the Indian Ocean.
Even though the ship’s conference room was incredibly claustrophobic, the sight of the growing blue and white crescent overtaking night on the planet below ﬁlled Sarah with awe and appreciation.
This morning’s meeting was focused on the control systems for the orbiter’s airlocks.
As the ﬁnal construction phases were nearing their end, the number of spacewalks was.
As you all know”, said Tom, “Each airlock is outﬁtted with space-hardened GUI terminals, both inside and out.
Everyone chuckled as Tom erased the whiteboard, but something didn’t feel right to Sarah and it ﬁnally clicked as Tom began to write the entry sequence pseudocode on the whiteboard.
Why did Sarah stop the meeting?  What did she suspect?
Sarah realized that in order to ensure that the entire exit sequence would run without interruption the.
As the design stood, it would be possible for a returning spacewalker to interrupt the Exit Sequence! The Exit Sequence thread couldn’t be interrupted in the middle of any of the lower level method calls, but it could be interrupted in between those calls.
Framework has a data structure that should work for virtually anything you’ll ever need to do.
Want to keep a list that you can easily keep adding to? Want to find something by name? Want.
Java put things in alphabetical order?  Third grade really sucks.
You have a list of songs in a ﬁ le, where each line represents one song, and the title and artist are separated with a forward slash.
So it should be simple to parse the line, and put all the songs in an ArrayList.
Your boss cares only about the song titles, so for now you can simply make a list that just has the song titles.
But you can see that the list is not in alphabetical order...
You know that with an ArrayList, the elements are kept in the order in which they were inserted into the list, so putting them in an ArrayList won’t take care of alphabetizing them, unless...
Congratulations on your new job—managing the automated jukebox system at Lou’s Diner.
There’s no Java inside the jukebox itself, but each time someone plays a song, the song data is appended to a simple text ﬁ le.
Your job is to manage the data to track song popularity, generate reports, and manipulate the playlists.
You’re not writing the entire app—some of the other software developer/ waiters are involved as well, but you’re responsible for managing and sorting the data inside the Java app.
And since Lou has a thing against databases, this is strictly an in-memory data collection.
All you get is the ﬁ le the jukebox keeps adding to.
You’ve already ﬁ gured out how to read and parse the ﬁ le, and so far you’ve been storing the data in an ArrayList.
The addSong method works just like the QuizCard in the I/O chapter--you break the line (that has both the title and artist) into two pieces (tokens) using the split() method.
We only want the song title, so add only the first token to the SongList (the ArrayList)
The question is, how do we get an object on one machine (which means a different heap/JVM) to call a method on another machine?
But the ArrayList class does NOT have a sort() method! When you look in   ArrayList, there doesn’t seem to be any method related to sorting.
Walking up the inheritance hierarchy didn’t help either—it’s clear that you can’t call a sort method on the ArrayList.
ArrayList has a lot of methods, but there’s nothing here that looks like it would sort...
The question is, how do we get an object on one machine (which means a different heap/JVM) to call a method on another machine?
I wonder if I should be using a TreeSet instead of an ArrayList...
ArrayList is not the only collection Although ArrayList is the one you’ll use most often, there are others for special occasions.
HashMap Let’s you store and access elements as name/value pairs.
LinkedList Designed to give better performance when you insert or delete elements from the middle of the collection.
In practice, an ArrayList is still usually what you want.
HashSet Prevents duplicates in the collection, and given an element, can find that element in the collection quickly.
LinkedHashMap Like a regular HashMap, except it can remember the order in which elements (name/value pairs) were inserted, or it can be configured to remember the order in which elements were last accessed.
If you put all the Strings (the song titles) into a TreeSet instead of an ArrayList, the Strings would automatically land in the right place, alphabetically sorted.
Whenever you printed the list, the elements would always come out in alphabetical order.
And that’s great when you need a set (we’ll talk about sets in a few minutes) or when you know that the list must always stay sorted alphabetically.
On the other hand, if you don’t need the list to stay sorted, TreeSet might be more expensive than you need—every time you insert into a TreeSet, the TreeSet has to take the time to ﬁ gure out where in the tree the new element must go.
With ArrayList, inserts can be blindingly fast because the new element just goes in at the end.
Q: But you CAN add something to an ArrayList at a speciﬁ c index instead of just at the end—there’s an overloaded add() method that takes an int along with the element to add.
So wouldn’t it be slower than inserting at the end?
A: Yes, it’s slower to insert something in an ArrayList somewhere other than at the end.
So using the overloaded add(index, element) method doesn’t work as quickly as calling the add(element)—which puts the added element at the end.
But most of the time you use ArrayLists, you won’t need to put something at a specific index.
Q: I see there’s a LinkedList class, so wouldn’t that be better for doing inserts somewhere in the middle? At least if I remember my Data Structures class from college...
The LinkedList can be quicker when you insert or remove something from the middle, but for most applications, the difference between middle inserts into a LinkedList and ArrayList is usually not enough to care about unless you’re dealing with a huge number of elements.
Thanks to polymorphism, you can pass an ArrayList to a method declared to take List.
But now you need Song objects, not just simple Strings.
Now your boss wants actual Song class instances in the list, not just Strings, so that each Song can have more data.
The new jukebox device outputs more information, so this time the ﬁ le will have four pieces (tokens) instead of just two.
The Song class is really simple, with only one interesting featurethe overridden toString() method.
Remember, the toString() method is deﬁ ned in class Object, so every class in Java inherits the method.
When you print a list, the toString() method will be called on each object.
The new song file holds four attributes instead of just two.
And we want ALL of them in our list, so we need to make a Song class with instance variables for all four song attributes.
The variables are all set in the constructor when the new Song is created.
Create a new Song object using the four tokens (which means the four pieces of info in the song file for this line), then add the Song to the list.
ArrayList is-a List, because ArrayList implements the List interface, so...
And of course you probably already asked yourself, “What would it be sorting on?” How would the sort method even know what made one Song greater or less than another Song? Obviously if you want the song’s title to be the value that determines how the songs are sorted, you’ll need some way to tell the sort method that it needs to use the title and not, say, the beats per minute.
We’ll get into all that a few pages from now, but ﬁrst, let’s ﬁnd out why the compiler won’t even let us pass a Song ArrayList to the sort() method.
Or at least different from anything we’ve seen so far.
That’s because the sort() method (along with other things in the whole collection framework in Java) makes heavy use of generics.
Anytime you see something with angle brackets in Java source code or documentation, it means generics—a feature added to Java 5.0
So it looks like we’ll have to learn how to interpret the documentation before we can ﬁ gure out why we were able to sort String objects in an ArrayList, but not an ArrayList of Song objects.
WTF? I have no idea how to read the method declaration.
It says that sort() takes a List<T>, but what is T? And what is that big thing.
Generics means more   type-safety We’ll just say it right here—virtually all of the code you write that deals with generics will be collection-related code.
Although generics can be used in other ways, the main point of generics is to let you write type-safe collections.
In other words, code that makes the compiler stop you from putting a Dog into a list of Ducks.
Before generics (which means before Java 5.0), the compiler could not care less what you put into a collection, because all collection implementations were declared to hold type Object.
You could put anything in any ArrayList; it was like all ArrayLists were declared as ArrayList<Object>
With generics, you can create type-safe collections where more problems are caught at compile-time instead of runtime.
Without generics, the compiler would happily let you put a Pumpkin into an ArrayList that was supposed to hold only Cat objects.
Objects go IN as a reference to only Fish objects.
Now with generics, you can put only Fish objects in the ArrayList<Fish>, so the objects come out as Fish references.
You don’t have to worry about someone sticking a Volkswagen in there, or that what you get out won’t really be castable to a Fish reference.
When you make an ArrayList, you have to tell it the type of objects you’ll allow in the list, just as you do with plain old arrays.
If you have a method that takes as a parameter, say, an ArrayList of Animal objects, what does that really mean? Can you also pass it an ArrayList of Dog objects? We’ll look at some subtle and tricky polymorphism issues that are very different from the way you write methods that take plain old arrays.
This is actually the same point as #2, but that shows you how important we think it is.
Learning generics Of the dozens of things you could learn about generics, there are really only three that matter to most programmers:
Q: But don’t I also need to learn how to create my OWN generic classes? What if I want to make a class type that lets people instantiating the class decide the type of things that class will use?
Think about it—the API designers made an entire library of collections classes covering most of the data structures you’d need, and virtually the only type of classes that really need to be generic are collection classes.
In other words, classes designed to hold other elements, and you want programmers using it to specify what type those elements are when they declare and instantiate the collection class.
Yes, it is possible that you might want to create generic classes, but that’s the exception, so we won’t cover it here.
But you’ll figure it out from the things we do cover, anyway.
Using generic CLASSES Since ArrayList is our most-used generiﬁed type, we’ll start by looking at its documentation.
They two key areas to look at in a generiﬁed class are:
Understanding ArrayList documentation (Or, what’s the true meaning of “E”?)
ArrayList is a subclass of AbstractList, so whatever type you specify for the ArrayList is automatically used for the type of the AbstractList.
The type (the value of <E>) becomes the type of the List interface as well.Here’s the impor.
The “E” represents the type used to create an instance of ArrayList.
When you see an “E” in the ArrayList documentation, you can do a mental ﬁnd/replace to exchange it for whatever <type> you use to instantiate ArrayList.
So, new ArrayList<Song> means that “E” becomes “Song”, in any method or variable declaration that uses “E”
In other words, the “E” is replaced by the real type (also called the type parameter) that you use when you create the ArrayList.
And that’s why the add() method for ArrayList won’t let you add anything except objects of a reference type that’s compatible with the type of “E”
So if you make an ArrayList<String>, the add() method suddenly becomes add(String o)
If you make the ArrayList of type Dog, suddenly the add() method becomes add(Dog o)
Q: Is “E” the only thing you can put there? Because the docs for sort used “T”....
A: You can use anything that’s a legal Java identifier.
That means anything that you could use for a method or variable name will work as a type parameter.
But the convention is to use a single letter (so that’s what you should use), and a further convention is to use “T” unless you’re specifically writing a collection class, where you’d use “E” to represent the “type of the Element the collection will hold”
Using generic METHODS A generic class means that the class declaration includes a type parameter.
A generic method means that the method declaration uses a type parameter in its signature.
You can use type parameters in a method in several different ways:
When you declare a type parameter for the class, you can simply use that type any place that you’d use a real class or interface type.
The type declared in the method argument is essentially replaced with the type you use when you instantiate the class.
If the class itself doesn’t use a type parameter, you can still specify one for a method, by declaring it in a really unusual (but available) space—before the return type.
This method says that T can be “any type of Animal”
You can use the “E” here ONLY because it’s already been defined as part of the class.
Here we can use <T> because we declared “T” earlier in the method declaration.
If you can take a list of Animal, why don’t you.
And yes, it does appear to violate the point of polymorphism.
For now, remember that we’re only looking at this because we’re still trying to ﬁgure out how to sort() that SongList, and that led us into looking at the API for the sort() method, which had this strange generic type declaration.
For now, all you need to know is that the syntax of the top version is legal, and that it means you can pass in a ArrayList object instantiated as Animal or any Animal subtype.
The sort() method can take only lists of   Comparable objects.
Song is NOT a subtype of Comparable, so you cannot sort() the list of Songs.
This says “Whatever ‘T’ is must be of type Comparable.”
But if you can’t, it just means that the type parameter for Comparable must be of type T or one of T’s supertypes.
You can pass in only a List (or subtype of list, like ArrayList) that uses a parameterized type that “extends Comparable”
So here we are, trying to read the  sort() method docs to ﬁ nd out why it was OK to sort a list of Strings, but not a list of Song objects.
I just checked the docs for String, and String doesn’t EXTEND.
The Java engineers had to give you a way to put a constraint on a parameterized type, so that you can restrict it to, say, only subclasses of Animal.
But you also need to constrain a type to allow only classes that implement a particular interface.
In other words, that works for both extends and implements.
But it really means “is-a”, and works regardless of whether the type on the right is an interface or a class.
It doesn’t matter whether the thing on the right is a class or interface...
In generics, the keyword “extends” really means “is-a”, and works for BOTH classes and interfaces.
A: Adding a new keyword to the language is a REALLY big deal because it risks breaking Java code you wrote in an earlier version.
Think about it—you might be using a variable “is” (which we do use in this book to represent input streams)
And since you’re not allowed to use keywords as identifiers in your code, that means any earlier code that used the keyword before it was a reserved word, would break.
So whenever there’s a chance for the Sun engineers to reuse an existing keyword, as they did here with “extends”, they’ll usually choose that.
And this does break people’s code, however you sometimes have the option of compiling and running a newer version of Java so that it behaves as though it were an older one.
To see if you have a flag available, type javac (for the compiler) or java (for the JVM) at the command-line, without anything else after it, and you should see a list of available options.
You’ll learn more about these flags in the chapter on deployment.
The Song class needs to implement Comparable We can pass the ArrayList<Song> to the sort() method only if the Song class implements Comparable, since that’s the way the sort() method was declared.
A quick check of the API docs shows the Comparable interface is really simple, with only one method to implement:
The big question is: what makes one song less than, equal to, or greater than another song?
You can’t implement the Comparable interface until you make that decision.
Returns: a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the speciﬁ ed object.
It looks like the compareTo() method will be called on one Song object, passing that Song a reference to a different Song.
The Song running the compareTo() method has to ﬁ gure out if the Song it was passed should be sorted higher, lower, or the same in the list.
Your big job now is to decide what makes one song greater than another, and then implement the compareTo() method to reﬂ ect that.
A negative number (any negative number) means the Song you were passed is greater than the Song running the method.
Returning a positive number says that the Song running the method is greater than the Song passed to the compareTo() method.
You might, for example, have two Songs with the same title.
Which brings up a whole different can of worms we’ll look at later...
Write in your idea and pseudo code (or better, REAL code) for implementing the compareTo()  method in a way that will sort() the Song objects by title.
Hint: if you’re on the right track, it should take less than 3 lines of code!
The new, improved, comparable Song class We decided we want to sort by title, so we implement the compareTo() method to compare the title of the Song passed to the method against the title of the song on which the compareTo() method was invoked.
In other words, the song running the method has to decide how its title compares to the title of the method parameter.
Simple! We just pass the work on to the title String objects, since we know Strings have a compareTo()  method.
There’s a new problem—Lou wants two different views of the song list, one by song title and one by artist!
But when you make a collection element comparable (by having it implement Comparable), you get only one chance to implement the compareTo() method.
The horrible way would be to use a ﬂ ag variable in the Song class, and then do an if test in compareTo() and give a different result depending on whether the ﬂ ag is set to use title or artist for the comparison.
But that’s an awful and brittle solution, and there’s something much better.
Something built into the API for just this purpose—when you want to sort the same thing in more than one way.
Sometimes I want it to sort by artist instead of title.
Using a custom Comparator An element in a list can compare itself to another of its own type in only one way, using its compareTo() method.
But a Comparator is external to the element type you’re comparing—it’s a separate class.
So you can make as many of these as you like! Want to compare songs by artist? Make an ArtistComparator.
Then all you need to do is call the overloaded sort() method that takes the List and the Comparator that will help the sort() method put things in order.
The sort() method that takes a Comparator will use the Comparator instead of the element’s own compareTo() method, when it puts the elements in order.
In other words, if your sort() method gets a Comparator, it won’t even call the compareTo() method of the elements in the list.
The sort() method will instead invoke the compare() method on the Comparator.
If you pass a Comparator to the sort() method, the sort order is determined by the Comparator rather than the element’s own compareTo() method.
Invoking the one-argument sort(List o) method means the list element’s compareTo() method determines the order.
So the elements in the list MUST implement the Comparable interface.
Invoking  sort(List o, Comparator c) means the list element’s compareTo() method will NOT be called, and the Comparator’s compare() method will be used instead.
That means the elements in the list do NOT need to implement the Comparable interface.
Q: So does this mean that if you have a class that doesn’t implement Comparable, and you don’t have the source code, you could still put the things in order by creating a Comparator?
The other option (if it’s possible) would be to subclass the element and make the subclass implement Comparable.
A: Do you really believe that everything can be ordered? If you have element types that just don’t lend themselves to any kind of natural ordering, then you’d be misleading other programmers if you implement Comparable.
And you aren’t taking a huge risk by not implementing Comparable, since a programmer can compare anything in any way that he chooses using his own custom Comparator.
Updating the Jukebox to use a Comparator We did three new things in this code:
Created an inner class that implements Comparator (and thus the compare() method that does the work previously done by compareTo())
Called the overloaded sort() method, giving it both the song list and the instance of the Comparator inner class.
Note: we also updated the Song class toString() method to print both the song title and the artist.
It prints title: artist regardless of how the list is sorted.
We’re letting the String variables (for artist) do the actual comparison, since Strings already know how to alphabetize themselves.
Invoke sort(), passing it the list and a reference to the new custom Comparator object.
Note: we’ve made sort-by-title the default sort, by keeping the compareTo() method in Song use the titles.
But another way to design this would be to implement both the title sorting and artist sorting as inner Comparator classes, and not have Song implement Comparable at all.
Reverse Engineer Assume this code exists in a single file.
Your job is to fill in the blanks so the the program will create the output shown.
For each of the questions below, fill in the blank with one of the words from the “possible answers” list, to correctly answer the question.
What must the class of the objects stored in myArrayList implement?                ________________
What method must the class of the objects stored in myArrayList implement?  ________________
Can the class of the objects stored in myArrayList implement Comparable?   ________________
Can the class of the objects stored in myArrayList implement Comparator?   ________________
Must the class of the objects stored in myArrayList implement Comparable?  ________________
Must the class of the objects stored in myArrayList implement Comparator?  ________________
What must the class of the myCompare object implement?                                      ________________
What method must the class of the myCompare object implement?                          __________________
The sorting works great, now we know how to sort on both title (using the Song object’s compareTo() method) and artist (using the Comparator’s compare() method)
But there’s a new problem we didn’t notice with a test sample of the jukebox text ﬁ le—the sorted list contains duplicates.
It appears that the diner jukebox just keeps writing to the ﬁ le regardless of whether the same song has already been played (and thus written) to the text ﬁ le.
The SongListMore.txt jukebox text ﬁ le is a complete record of every song that was played, and might contain the same song multiple times.
The SongListMore text file now has duplicates in it, because the jukebox machine is writing every song played, in order.
Somebody decided to play “Listen” three times in a row, followed by “Circles”, a song that had been played earlier.We can’t change the way the text file is written because sometimes we’re going to need all that information.
You can have more than one element referencing the same object.
You can never have more than one element referencing the same object (or more than one element referencing two objects that are considered equal—we’ll look at what object equality means in a moment)
You can have two keys that reference the same value, but you cannot have duplicate keys.
Although keys are typically String names (so that you can make name/value property lists, for example), a key can be any object.
ArrayList is a List, but it looks like Set is exactly what we need.
The Collection   API (part of it) Notice that the Map interface doesn’t actually extend the Collection interface, but Map is still considered part of the.
Note: this is not the complete collection API; there are other classes and interfaces, but these are the ones we care most about.
So a Map is still referred to as a collection.
We added on to the Jukebox to put the songs in a HashSet.
Note: we left out some of the Jukebox code, but you can copy it from earlier versions.
And to make it easier to read the output, we went back to the earlier version of the Song’s toString() method, so that it prints only the title instead of title and artist.
Here we create a new HashSet parameterized to hold Songs.
We didn’t change getSongs(), so it still puts the songs in an A rrayList.
HashSet has a simple addAll() method that can take another collection and use it to populate the HashSet.
It’s the same as if we added each song one at a time (except much simpler)
The Set didn’t help!! We still have all the duplicates !
What makes two objects equal? First, we have to ask—what makes two Song references duplicates? They must be considered equal.
Is it simply two references to the very same object, or is it two separate objects that both have the same title?
Object equality Two references, two objects on the heap, but the objects are considered meaningfully equivalent.
Two references that refer to the same object on the heap are equal.
If you call the hashCode() method on both references, you’ll get the same result.
If you don’t override the hashCode() method, the default  behavior (remember, you inherited this from class Object) is that each object will get a unique number (most versions of Java assign a hashcode based on the object’s memory address on the heap, so no two objects will have the same hashcode)
If you want to know if two references are really referring to the same object, use the == operator, which (remember) compares the bits in the variables.
If both references point to the same object, the bits will be identical.
If you want to treat two different Song objects as equal (for example if you decided that two Songs are the same if they have matching title variables), you must override both the hashCode() and equals() methods inherited from class Object.
As we said above, if you don’t override hashCode(), the default behavior (from Object) is to give each object a unique hashcode value.
So you must override hashCode() to be sure that two equivalent objects return the same hashcode.
But you must also override equals() so that if you call it on either object, passing in the other object, always returns true.
If two objects foo and bar are equal, foo.equals(bar) must be true, and both foo and bar must return the same value from hashCode()
For a Set to treat two objects as duplicates, you must override the hashCode() and equals() methods inherited from class Object, so that you can make two different objects be viewed as equal.
How a HashSet checks for duplicates: hashCode( ) and equals( ) When you put an object into a Hashset, it uses the object’s hashcode value to determine where to put the object in the Set.
But it also compares the object’s hashcode to the hashcode of all the other objects in the HashSet, and if there’s no matching hashcode, the HashSet assumes that this new object is not a duplicate.
In other words, if the hashcodes are different, the HashSet assumes there’s no way the objects can be equal!
So you must override hashCode() to make sure the objects have the same value.
But two objects with the same hashCode() might not be equal (more on this on the next page), so if the.
HashSet ﬁnds a matching hashcode for two objectsone you’re inserting and one already in the set—the HashSet will then call one of the object’s equals() methods to see if these hashcode-matched objects really are equal.
And if they’re equal, the HashSet knows that the object you’re attempting to add is a duplicate of something in the Set, so the add doesn’t happen.
You don’t get an exception, but the HashSet’s add() method returns a boolean to tell you (if you care) whether the new object was added.
So if the add() method returns false, you know the new object was a duplicate of something already in the set.
I need to know if your hashcode values are the same.
Notice how hashCode() and equals() are using the SAME instance variable.
Now it works! No duplicates when we print out the HashSet.
But we didn’t call sort() again, and when we put the ArrayList into the HashSet, the HashSet didn’t preserve the sort order.
The API docs for class Object state the rules you MUST follow:
If two objects are equal, they MUST have matching hashcodes.
If two objects are equal, calling equals() on either object MUST return true.
If two objects have the same hashcode value, they are NOT required to be equal.
But if they’re equal, they MUST have the same hashcode value.
The default behavior of hashCode() is to generate a unique integer for each object on the heap.
So if you don’t override hashCode() in a class, no two objects of that type can EVER be considered equal.
The default behavior of equals() is to do an == comparison.
In other words, to test whether the two references refer to a single object on the heap.
So if you don’t override equals() in a class, no two objects can EVER be considered equal since references to two different objects will always contain a different bit pattern.
But  a.hashCode() == b.hashCode() does NOT have to mean a.equals(b)
Q: How come hashcodes can be the same even if objects aren’t equal?
A: HashSets use hashcodes to store the elements in a way that makes it much faster to access.
If you try to find an object in an ArrayList by giving the ArrayList a copy of the object (as opposed to an index value), the ArrayList has to start searching from the beginning, looking at each element in the list to see if it matches.
But a HashSet can find an object much more quickly, because it uses the hashcode as a kind of label on the “bucket” where it stored the element.
This isn’t the whole story you get in a computer science class, but it’s enough for you to use HashSets effectively.
In reality, developing a good hashcode algorithm is the subject of many a PhD thesis, and more than we want to cover in this book.
The point is that hashcodes can be the same without necessarily guaranteeing that the objects are equal, because the “hashing algorithm” used in the hashCode() method might happen to return the same value for multiple objects.
And yes, that means that multiple objects would all land in the same bucket in the HashSet (because each bucket represents a single hashcode value), but that’s not the end of the world.
It might mean that the HashSet is just a little less efficient (or that it’s filled with an extremely large number of elements), but if the HashSet finds more than one object in the same hashcode bucket, the HashSet will simply use the equals() method to see if there’s a perfect match.
In other words, hashcode values are sometimes used to narrow down the search, but to find the one exact  match, the HashSet still has to take all the objects in that one bucket (the bucket for all objects with the same hashcode) and then call equals() on them to see if the object it’s looking for is in that bucket.
And if we want the set to stay sorted, we’ve got TreeSet.
TreeSet is similar to HashSet in that it prevents duplicates.
It works just like the sort() method in that if you make a TreeSet using the set’s no-arg constructor, the TreeSet uses each object’s compareTo() method for the sort.
But you have the option of passing a Comparator to the TreeSet constructor, to have the TreeSet use that instead.
The downside to TreeSet is that if you don’t need sorting, you’re still paying for it with a small performance hit.
But you’ll probably ﬁnd that the hit is almost impossible to notice for most apps.
We can add all the songs from the HashSet using addAll()
Or we could have added the songs individually using songSet.add() just the way we added songs to the ArrayList.
If it compiles, what is the result when you run the TestTree class?
If there is a problem (either compile-time or runtime) with this code,  how would you fix it?
TreeSet looks easy, but make sure you really understand what you need to do to use it.
We thought it was so important that we made it an exercise so you’d have to think about it.
TreeSet elements MUST be comparable TreeSet can’t read the programmer’s mind to ﬁgure out how the object’s should be sorted.
The elements in the list must be of a type that implements Comparable.
The Book class on the previous page didn’t implement Comparable, so it wouldn’t work at runtime.
Think about it, the poor TreeSet’s sole purpose in life is to keep your elements sorted, and once again—it had no idea how to sort Book objects! It doesn’t fail at compile-time, because the TreeSet add() method doesn’t take a Comparable type,The TreeSet add()  method takes whatever type you used when you created the TreeSet.
In other words, if you say new TreeSet<Book>() the add() method is essentially add(Book)
And there’s no requirement that the Book class implement Comparable! But it fails at runtime when you add the second element to the set.
That’s the first time the set tries to call one of the object’s compareTo() methods and...
You use the TreeSet’s  overloaded constructor that takes a Comparator.
TreeSet works a lot like the sort() method—you have a choice of using the element’s compareTo() method, assuming the element type implemented the Comparable interface, OR you can use a custom Comparator that knows how to sort the elements in the set.
To use a custom Comparator, you call the TreeSet constructor that takes a Comparator.
To use a TreeSet, one of these things must be true:
We’ve seen Lists and Sets, now we’ll use a   Map Lists and Sets are great, but sometimes a Map is the best collection (not Collection with a capital “C”—remember that Maps are part of Java collections but they don’t implement the Collection interface)
Imagine you want a collection that acts like a property list, where you give it a name and it gives you back the value associated with that name.
Although keys will often be Strings, they can be any Java object (or, through autoboxing, a primitive)
Each element in a Map is actually TWO objects—a key and a value.
HashMap needs TWO type parameters—one for the key and one for the value.
Use put() instead of add(), and now of course it takes two arguments (key, value)
The get() method takes a key, and returns the value (in this case, an Integer)
Finally, back to generics Remember earlier in the chapter we talked about how methods that take arguments with generic types can be...
If things start to feel strange here, just keep going—it takes a few pages to really tell the whole story.
We’ll start with a reminder on how array arguments work, polymorphically, and then look at doing the same thing with generic lists.
Declare and create an Animal array, that holds both dogs and cats.
If a method argument is an array of Animals, it will also take an array of any Animal subtype.
Assuming Dog extends Animal, you are free to call both:
Declare and create a Dog array, that holds only Dogs (the compiler won’t let you put a Cat in)
The crucial point is that the takeAnimals() method can take an Animal[]  or a Dog[], since Dog IS-A Animal.
Polymorphism in action.Remember, we can call ONLY the methods declared in type animal, since the animals parameter is of type Animal array, and we didn’t do any casting.
What would we cast it to? That array might hold both Dogs and Cats.
Using polymorphic arguments and generics So we saw how the whole thing worked with arrays, but will it work the same way when we switch from an array to an ArrayList? Sounds reasonable, doesn’t it?
We made just a few changes to the go() method:
We have to add one at a time since there’s no shortcut syntax like there is for array creation.
This is the same code, except now the “animals” variable refers to an ArrayList instead of array.
The method now takes an ArrayList instead of an array, but everything else is the same.
Remember, that for loop syntax works for both arrays and collections.
But will it work with ArrayList<Dog> ? Because of polymorphism, the compiler let us pass a Dog array to a method with an Animal array argument.
Make a Dog ArrayList and put a couple dogs in.
Will this work now that we changed from an array to an ArrayList?
And I’m supposed to be OK with this? That totally screws my animal simulation where the.
It let you pass an ArrayList<Dog> to a method declared as:
There’s nothing in that method that looks harmful, right? After all, the whole point of polymorphism is that anything an Animal can do (in this case, the eat() method), a Dog can do as well.
So what’s the problem with having the method call eat() on each of the Dog references?
There’s certainly nothing wrong with adding a Cat to an ArrayList<Animal>, and that’s the whole point of having an ArrayList of a supertype like Animal—so that you can put all types of animals in a single Animal ArrayList.
But if you passed a Dog ArrayList—one meant to hold ONLY Dogsto this method that takes an Animal ArrayList, then suddenly you’d end up with a Cat in the Dog list.
The compiler knows that if it lets you pass a Dog ArrayList into the method like that, someone could, at runtime, add a Cat to your Dog list.
So instead, the compiler just won’t let you take the risk.
Array types are checked again at runtime, but collection type checks happen only when you compile.
Let’s say you do add a Cat to an array declared as Dog[] (an array that was passed into a method argument declared as Animal[], which is a perfectly legal assignment for arrays)
Wouldn’t it be dreamy if there were a way to still use polymorphic collection types as method arguments, so that my veterinary program could take Dog lists.
Wildcards to the rescue It looks unusual, but there is a way to create a method argument that can accept an ArrayList of any Animal subtype.
The simplest way is to use a wildcard—added to the Java language explicitly for this reason.
So now you’re wondering, “What’s the difference? Don’t you have the same problem as before? The method above isn’t doing anything dangerous—calling a method any Animal subtype is guaranteed to have—but can’t someone still change this to add a Cat to the animals list, even though it’s really an ArrayList<Dog>? And since it’s not checked again at runtime, how is this any different from declaring it without the wildcard?”
When you use the wildcard <?> in your declaration, the compiler won’t let you do anything that adds to the list!
When you use a wildcard in your method argument, the compiler will STOP you from doing anything that could hurt the list referenced by the method parameter.
You can still invoke methods on the elements in the list, but you cannot add elements to the list.
In other words, you can do things with the list elements, but you can’t put new things in the list.
So you’re safe at runtime, because the compiler won’t let you do anything that might be horrible at runtime.
Remember, the keyword “extends” here means either extends OR implements depending on the type.
So if you want to take an ArrayList of types that implement the Pet interface, you’d declare it as:
Alternate syntax for doing the same thing You probably remember that when we looked at the sort() method, it  used a generic type, but with an unusual format where the type parameter was declared before the return type.
It’s just a different way of declaring the type parameter, but the results are the same:
Q: If they both do the same thing, why would you use one over the other?
A: It all depends on whether you want to use “T” somewhere else.
For example, what if you want the method to have two arguments—both of which are lists of a type that extend Animal? In that case, it’s more efficient to just declare the type parameter once:
Your job is to play compiler and determine which of these statements would compile.
In some cases, you might have to guess, but the point is to come up with a reasonable answer based on what you know so far.
Note:  assume that this code is within a legal class and method.
What method must the class of the objects stored in myArrayList implement?  compareTo( )
What method must the class of the myCompare object implement?                            compare( )
You told everyone you know that if you never saw a line of code again, that’d be fine.
The thing actually runs! But now what? How do you give it to.
We’ll look at local, semi-local, and remote deployment options including executable.
In this chapter, we’ll spend most of our time on organizing.
In the final chapter, we’ll finish with one of the coolest things you can do in Java.
The real question is what to do with those classes when you’re done.
Deploying your application What exactly is a Java application? In other words, once you’re done with development, what is it that you deliver? Chances are, your end-users don’t have a system identical to yours.
So now it’s time to get your program in shape for deployment into The Outside World.
In the next chapter, we’ll look at the more remote deployment options, including RMI and Servlets.
But before we really get into the whole deployment thing, let’s take a step back and look at what happens when you’ve ﬁnished programming your app and you simply want to pull out the class ﬁles to give them to an end-user.
Remote The entire Java application runs on a server system, with the client accessing the system through some non-Java means, probably a web browser.
Combination of local and remote The application is distributed with a client portion running on the user’s local system, connected to a server where other parts of the application are running.
What are the advantages and disadvantages of delivering your Java program as  web-based system where the user interacts with a web browser, and the Java code runs as servlets on the server?
Bob’s happily at work on the ﬁnal pieces of his cool new Java program.
At last, it’s time to deliver the program to the client.
He ﬁgures all he has to do is copy the nine class ﬁles, since the client already has the Java API installed.
He had completely forgotten that the compiler has to generate class ﬁles for all those inner class GUI event listeners he made, and that’s what all the strangelynamed classes are.
Now he has to carefully extract all the class ﬁles he needs.
If he leaves even one of them out, his program won’t work.
Separate source code and class files A single directory with a pile of source code and class ﬁ les is a mess.
It turns out, Bob should have been organizing his ﬁ les from the beginning, keeping the source code and compiled code separate.
In other words, making sure his compiled class ﬁ les didn’t land in the same directory as his source code.
The key is a combination of directory structure organization and the -d compiler option.
But I thought I didn’t have a choice about putting the class ﬁ les in with the source ﬁ les.
There are dozens of ways you can organize your ﬁ les, and your company might have a speciﬁ c way they want you to do it.
We recommend an organizational scheme that’s become almost standard, though.
With this scheme, you create a project directory, and inside that you create a directory called source and a directory called classes.
You start by saving your source code (.java ﬁ les) into the source directory.
Then the trick is to compile your code in such a way that the output (the .class ﬁ les) ends up in the classes directory.
And there’s a nice compiler ﬂ ag, -d, that lets you do that.
By using the -d ﬂ ag, you get to decide which directory the compiled code lands in, rather than accepting the default of class ﬁ les landing in the same directory as the source code.
To compile all the .java ﬁ les in the source directory, use:
It’s based on the pkzip ﬁ le format, and it lets you bundle all your classes so that instead of presenting your client with 28 class ﬁ les, you hand over just a single JAR ﬁ le.
If you’re familiar with the tar command on UNIX, you’ll recognize the jar tool commands.
Note: when we say JAR in all caps, we’re referring to the archive ﬁ le.
When we use lowercase, we’re referring to the jar tool you use to create JAR ﬁ les.
The question is, what does the client do with the JAR? How do you get it to run?
An executable JAR means the end-user doesn’t have to pull the class ﬁ les out before running the program.
The user can run the app while the class ﬁ les are     still in the JAR.
The trick is to create a manifest ﬁ le, that goes in the JAR and holds information about the ﬁ les in the JAR.
To make a JAR executable, the manifest must tell the JVM which class has the main() method!
Make sure all of your class ﬁ les are in the classes directory We’re going to reﬁ ne this in a few pages, but for now, keep all your class ﬁ les sitting in the directory named ‘classes’
Create a manifest.txt ﬁ le that states which class has the main() method Make a text ﬁ le named manifest.txt that has a one line:
Press the return key after typing the MainClass line, or your manifest may not work correctly.
Run the jar tool to create a JAR ﬁ le that contains everything in the classes directory, plus the manifest.
Running (executing) the JAR Java (the JVM) is capable of loading a class from a JAR, and calling the main() method of that class.
In fact, the entire application can stay in the JAR.
Once the ball is rolling (i.e., the main() method starts running), the JVM doesn’t care where your classes come from, as long as it can ﬁ nd them.
And one of the places the JVM looks is within any JAR ﬁ les in the classpath.
If it can   see a JAR, the JVM will look in that JAR when it needs to ﬁ nd and load a class.
The -jar flag tells the JVM you’re giving it a JAR instead of a class.
Depending on how your operating system is conﬁ gured, you might even be able to simply double-click the JAR ﬁ le to launch it.
You can usually make this happen by selecting the JAR and telling the OS to “Open with...” (or whatever the equivalent is on your operating system)
Q: Why can’t I just JAR up an entire directory?
A: The JVM looks inside the JAR and expects to find what it needs right there.
It won’t go digging into other directories, unless the class is part of a package, and even then the JVM looks only in the directories that match the package statement?
A: You can’t put your class files into some arbitrary directory and JAR them up that way.
But if your classes belong to packages, you can JAR up the entire package directory structure.
We’ll explain all this on the next page, so you can relax.
Most 100% local Java apps are deployed as executable JAR files.
Put your classes in packages! So you’ve written some nicely reusable class ﬁ les, and you’ve posted them in your internal development library for other programmers to use.
While basking in the glow of having just delivered some of the (in your humble opinion) best examples of OO ever conceived, you get a phone call.
Two of your classes have the same name as the classes Fred just delivered to the library.
And all hell is breaking loose out there, as naming collisions and ambiguities bring development to its knees.
And all because you didn’t use packages! Well, you did use packages, in the sense of using classes in the Java API that are, of course, in packages.
But you didn’t put your own classes into packages, and in the Real World, that’s Really Bad.
We’re going to modify the organizational structure from the previous pages, just a little, to put classes into a package, and to JAR the entire package.
Pay very close attention to the subtle and picky details.
Even the tiniest deviation can    stop your code from compiling and/or running.
So you’ve written some nicely reusable class ﬁ les, and you’ve.
So you’ve written some nicely reusable class ﬁ les, and you’ve.
Packages prevent class name conflicts Although packages aren’t just for preventing name collisions, that’s a key feature.
You might write a class named Customer and a class named Account and a class named ShoppingCart.
And what do  you know, half of all developers working in enterprise e-commerce have probably written classes with those names.
If part of the point of OO is to write reusable components, developers need to be able to piece together components from a variety of sources, and build something new out of them.
Your components have to be able to ‘play well with others’, including those you didn’t write or even know about.
Remember way back in chapter 6 when we discussed how a package name is like the full name of a class, technically known as the fully-qualiﬁ ed name.
Notice that two of those classes, ArrayList and Socket, both have java as their “ﬁ rst name”
In other words, the ﬁ rst part of their fully-qualiﬁ ed names is “java”
Think of a hierarchy when you think of package structures, and organize your classes accordingly.
What does this picture look like to you? Doesn’t it look a whole lot like a directory hierarchy?
Sun strongly suggests a package naming convention that greatly reduces that risk—prepend every class with your reverse domain name.
Two different guys can be named Bartholomew Simpson, but two different domains cannot be named doh.com.
I was thinking of for my sub-atomic ironing class! Guess I’ll just have to come.
Packages can prevent name conflicts, but only if you choose a package name that’s guaranteed to be unique.
The best way to do that is to preface your packages with your reverse domain name.
It must be the ﬁ rst statement in the source code ﬁ le, above any import statements.
There can be only one package statement per source code ﬁ le, so all classes in a source ﬁ le must be in the same package.
It’s not enough to say your class is in a package, by merely putting a package statement in the code.
Your class isn’t truly in a package until you put the class in a matching directory structure.
It is possible to compile without doing that, but trust us—it’s not worth the other problems you’ll have.
Keep your source code in a directory structure that matches the package structure, and you’ll avoid a ton of painful headaches down the road.
You must put a class into a directory structure that matches the package hierarchy.
Set up a matching directory structure for both the source and classes trees.
To compile all the .java ﬁ les in the com.headﬁ rstjava package, use:
Running your code run your program from the ‘classes’ directory.
Compiling and running with packages When your class is in a package, it’s a little trickier to compile and run.
The main issue is that both the compiler and JVM have to be capable of ﬁ nding your class and all of the other classes it uses.
For the classes in the core API, that’s never a problem.
But for your classes, the solution of compiling from the same directory where the source ﬁ les are simply won’t work (or at least not reliably)
We guarantee, though, that if you follow the structure we describe on this page, you’ll be successful.
There are other ways to do it, but this is the one we’ve found the most reliable and the easiest to stick to.
You MUST give the fully-qualified class name! The JVM will see that, and immediately look inside its current directory (classes) and expect to find a directory named com, where it expects to find a directory named headfirstjava, and in there it expects to find the class.
If the class is in the “com” directory, or even in “classes”, it won’t work!
Q: I tried to cd into the directory where my main class was, but now the JVM says it can’t ﬁ nd my class! But it’s right THERE in the current directory!
A: Once your class is in a package, you can’t call it by its ‘short’ name.
You MUST specify, at the command-line, the fullyqualified name of the class whose main() method you want to run.
But since the fully-qualified name includes the package structure, Java insists that the class be in a matching directory structure.
It will not look for a class named Book, until it has found a directory named “com” with a directory inside named “foo”
Only then will the JVM accept that its found the correct Book class.
If it finds a Book class anywhere else, it assumes the class isn’t in the right structure, even if it is! The JVM won’t for example, look back up the directory tree to say, “Oh, I can see that above us is a directory named com, so this must be the right package...”
The -d flag is even cooler than we said Compiling with the -d ﬂ ag is wonderful because not only does it let you send your compiled class ﬁ les into a directory other than the one where the source ﬁ le is, but it also knows to put the class into the correct directory structure for the package the class is in.
Let’s say that you have a nice directory structure all set up for your source code.
But you haven’t set up a matching directory structure for your classes directory.
Not a problem! Compiling with -d tells the compiler to not just put your classes into the correct directory tree, but to build the directories if they don’t exist.
When your class is in a package, the package directory structure must be inside the JAR! You can’t just pop your classes in the JAR the way we did pre-packages.
And you must be sure that you don’t include any other directories above your package.
Make sure all of your class ﬁ les are within the correct package structure, under the classes directory.
Create a manifest.txt ﬁ le that states which class has the main()   method, and be sure to use the fully-qualiﬁ ed class name! Make a text ﬁ le named manifest.txt that has a single line:
Run the jar tool to create a JAR ﬁ le that contains the package directories plus the manifest.
The only thing you need to include is the ‘com’ directory, and the entire package (and all classes) will go into the JAR.
Why don’t we look inside the JAR and ﬁ nd out? From the command-line, the jar tool can do more than just create and run  a JAR.
Imagine you’ve put the packEx.jar into a directory named Skyler.
The jar tool creates the META-INF directory as well as the MANIFEST.MF ﬁ le.
It also takes the contents of your manifest ﬁ le, and puts it into the MANIFEST.MF ﬁ le.
So, your manifest ﬁ le doesn’t go into the JAR, but the contents of it are put into the ‘real’ manifest (MANIFEST.MF)
Given the package/directory structure in this picture, ﬁ gure out what you should type at the command-line to compile, run, create a JAR, and execute a JAR.
Assume we’re using the standard where the package directory structure starts just below source and classes.
In other words, the source and classes directories are not part of the package.
Q: What happens if you try to run an executable JAR, and the end-user doesn’t have java installed?
A: Nothing will run, since without a JVM, Java code can’t run.
Q: How can I get Java installed on the end-user’s machine?
Ideally, you can create a custom installer and distribute it along with your application.
Several companies offer installer programs ranging from simple to extremely powerful.
An installer program could, for example, detect whether or not the end-user has an appropropriate version of Java installed, and if not, install and configure Java before installing your application.
Another cool thing about some of the installer programs is that you can even make a deployment CD-ROM that includes installers for all major Java platforms, so...
If the user’s running on Solaris, for example, the Solaris version of Java is installed.
If you have the budget, this is by far the easiest way for your end-users to get the right version of Java installed and configured.
Executable JAR ﬁles are nice, but wouldn’t it be dreamy if there were a way to make a rich, standalone client GUI that could be distributed over the Web? So that you wouldn’t have to.
With Java Web Start (JWS), your application is launched for the ﬁ rst time from a Web browser (get it? Web Start?) but it runs as a stand-alone application (well, almost), without the constraints of the browser.
And once it’s downloaded to the end-user’s machine (which happens the ﬁ rst time the user accesses the browser link that starts the download), it stays there.
Java Web Start is, among other things, a small Java program that lives on the client machine and works much like a browser plug-in (the way, say, Adobe Acrobat Reader opens when your browser  gets a .pdf ﬁ le)
This Java program is called the Java Web Start ‘helper app’, and its key purpose is to manage the downloading, updating, and launching (executing) of your JWS apps.
When JWS downloads your application (an executable JAR), it invokes the main() method for your app.
After that, the end-user can launch your application directory from the JWS helper app without having to go back through the Web page link.
There’s still an issue, of course, like how does the end-user get Java and Java Web Start? They need both—Java to run the app, and Java Web Start (a small Java application itself) to handle retrieving and launching the app.
You can set things up so that if your end-users don’t have JWS, they can download it from Sun.
And if they do have JWS, but their version of Java is out-of-date (because you’ve speciﬁ ed in your JWS app that you need a speciﬁ c version of Java), the Java 2 Standard Edition can be downloaded to the end-user machine.
You can serve up a JWS app much like any other type of Web resource such as a plain old HTML page or a JPEG image.
You set up a Web (HTML) page with a link to your JWS application, and you’re in business.
In the end, your JWS application isn’t much more than an executable JAR that end-users can download from the Web.
End-users launch a Java Web Start app by clicking on a link in a Web page.
But once the app downloads, it runs outside the browser, just like any other stand-alone Java application.
In fact, a Java Web Start app is just an executable JAR that’s distributed over the Web.
The client clicks on a Web page link to your JWS application (a .jnlp ﬁle)
The Web server (HTTP) gets the request and sends back a .jnlp ﬁle (this is NOT the JAR)
Java Web Start (a small ‘helper app’ on the client) is started up by the browser.
The JWS helper app reads the .jnlp ﬁle, and asks the server for the MyApp.jar ﬁle.
The .jnlp ﬁle is an XML document that states the name of the application’s executable JAR ﬁle.
Java Web Start gets the JAR and starts the application by calling the speciﬁed main( ) method (just like an executable JAR)
Next time the user wants to run this app, he can open the Java Web Start application and from there launch your app, without even being online.
To make a Java Web Start app, you need to .jnlp (Java Network Launch Protocol) ﬁle that describes your application.
This is the ﬁle the JWS app reads and uses to ﬁnd your JAR and launch the app (by calling the JAR’s main() method)
A .jnlp ﬁle is a simple XML document that has several different things you can put in, but as a minimum, it should look like this:
This is the location of the .jn lp file relative to the.
Be sure to include all of these tags, or your app might.
This means the user can run yo ur program without.
The name of your executable JAR! You might have other JAR files as well, that hold other classes or even sounds and images used by your app.
Steps for making and deploying a Java Web Start app.
Place your JAR and .jnlp ﬁles on your Web server.
This causes the server to send the .jnlp ﬁle with the correct header, so that when the browser receives the .jnlp ﬁle it knows what it is and knows to start the JWS helper app.
It includes tags for specifying the name and location of the JAR, and the name of the class with the main() method.
Look at the sequence of events below, and place them in the order in which they occur in a JWS application.
An applet is downloaded from the Web as part of a Web page rather than simply from a Web page.
In other words, to the browser, the applet is just like a JPEG or any other resource.
The browser uses either a Java plug-in or the browser’s own built-in Java (far less common today) to run the applet.
Applets don’t have the same level of functionality for things such as automatic updating, and they must always be launched from the browser.
With JWS applications, once they’re downloaded from the Web, the user doesn’t even have to be using a browser to relaunch the application locally.
Instead, the user can start up the JWS helper app, and use it to launch the already-downloaded application again.
A: JWS apps have several limitations including being restricted from reading and writing to the user’s hard drive.
Your job is to decide whether each of the following statements is true or false.
The Java compiler has a ﬂag, -d, that lets you decide where your .class ﬁles should go.
A JAR is a standard directory where your .class ﬁles should reside.
When creating a Java Archive you must create a ﬁle called jar.mf.
The supporting ﬁle in a Java Archive declares which class has the main() method.
At the command line, Java Archives are invoked using the -arch ﬂag.
Using your company’s domain name is not recommended when naming packages.
Different classes within a source ﬁle can belong to different packages.
When compiling classes in a package, the -p ﬂag is highly recommended.
When compiling classes in a package, the full name must mirror the directory tree.
Judicious use of the -d ﬂag can help to assure that there are no typos in your class tree.
Extracting a JAR with packages will create a directory called meta-inf.
Extracting a JAR with packages will create a ﬁle called manifest.mf.
The JWS helper app always runs in conjunction with a browser.
A JWS’s main method is speciﬁed in its JAR ﬁle.
Anything in the book is fair game for this one!
The Java compiler has a ﬂ ag, -d, that lets you decide where your .class ﬁ les should go.
A JAR is a standard directory where your .class ﬁ les should reside.
When creating a Java Archive you must create a ﬁ le called jar,mf.
The supporting ﬁ le in a Java Archive declares which class has the main() method.
At the command line, Java Archives are invoked using the -arch ﬂ ag.
Using your company’s domain name is not recommended when naming packages.
Different classes within a source ﬁ le can belong to different packages.
When compiling classes in a package, the -p ﬂ ag is highly recommended.
When compiling classes in a package, the full name must mirror the directory tree.
Judicious use of the -d ﬂ ag can help to assure that there are no typos in your tree.
Extracting a JAR with packages will create a directory called meta-inf.
Extracting a JAR with packages will create a ﬁ le called manifest.mf.
The JWS helper app always runs in conjunction with a browser.
A JWS’s main method is speciﬁ ed in its JAR ﬁ le.
Sure, things are easier when all the parts of your application are in one place, in one heap, with one JVM to rule them all.
Sometimes, part of your app must run on a server, while another part (usually a client) must.
In this chapter, we’ll learn to use Java’s amazingly simple Remote.
We’ll also take a quick peek at Servlets, Enterprise Java.
Beans (EJB) , and Jini, and look at the ways in which EJB and Jini depend on RMI.
No matter how far apart we really are, RMI makes it seem like.
So far in this book, every method we’ve invoked has been on an object running in the same virtual machine as the caller.
In other words, the calling object and the callee (the object we’re invoking the method on) live on the same  heap.
Method calls are always between two objects on the same heap.
In most applications, when one object calls a method on another, both objects are on the same heap.
In other words, both are running within the same JVM.
In the code above, we know that the Foo instance referenced by f and the Bar object referenced by b are both on the same heap, run by the same JVM.
Remember, the JVM is responsible for stufﬁ ng bits into the reference variable that represent how to get to an object on the heap.
The JVM always knows where each object is, and how to get to it.
But the JVM can know about references on only its own heap! You can’t, for example, have a JVM running on one machine knowing about the heap space of a JVM running on a different machine.
In fact, a JVM running on one machine can’t know anything about a different JVM running on the same machine.
It makes no difference if the JVMs are on the same or different physical machines; it matters only that the two JVMs are, well, two different invocations of the JVM.
We know how to get information from one machine to anotherwith Sockets and I/O.
We open a Socket connection to another machine, and get an OutputStream and write some data to it.
But what if we actually want to call a method on something running in another machine...
Think how much nicer it would be to just get a reference to the object on the other machine, and call a method.
What if you want to invoke a method on an object running on another machine?
Little wants to send some data to Big, so that Big can do the heavy computing.
But how can Little get a reference to an object on Big?
The question is, how do we get an object on one machine (which means a different heap/JVM) to call a method on another machine?
The question is, how do we get an object on one machine (which means a different heap/JVM) to call a method on another machine?
Object A, running on Little, wants to call a method on Object B, running on Big.
You can’t get a reference to something on another heap.
Whatever d is referencing must be in the same heap space as the code running the statement.
But imagine you want to design something that will use Sockets and I/O to communicate your intention (a method invocation on an object running on another machine), yet still feel as though you were making a local method call.
In other words, you want to cause a method invocation on a remote object (i.e., an object in a heap somewhere else), but with code that lets you pretend that you’re invoking a method on a local object.
The ease of a plain old everyday method call, but the power of remote method invocation.
But let’s step back and imagine how you would design RMI if you were doing it yourself.
Understanding what you’d have to build yourself will help you learn how RMI works.
The question is, how do we get an object on one machine (which means a different heap/JVM) to call a method on another machine?
The server app is the remote service that has an object with the method that the client wants to invoke.
They’ll handle all the low-level networking and I/O details so your client and service can pretend like they’re in the same heap.
The ‘helpers’ are the objects that actually do the communicating.
They make it possible for the client to act as though its calling a method on a local object.
The client calls a method on the client helper, as if the client helper were the actual service.
The client helper is a proxy for the Real Thing.
In other words, the client object thinks it’s calling a method on the remote service, because the client helper is pretending to be the service object.
Pretending to be the thing with the method the client wants to call!
Although the client helper acts like it (because it has the same method that the service is advertising), the client helper doesn’t have any of the actual method logic the client is expecting.
On the server side, the service helper receives the request from the client helper (through a Socket connection), unpacks the information about the call, and then invokes the real method on the real service object.
It’s coming from the service helper, not a remote client.
The service helper gets the return value from the service, packs it up, and ships it back (over a Socket’s output stream) to the client helper.
The client helper unpacks the information and returns the value to the client object.
Your client object gets to act like it’s making remote method calls.
But what it’s really doing is calling methods on a heap-local ‘proxy’ object that handles all the low-level details of Sockets and streams.
Service helper gets the request from the client helper, unpacks it, and calls the method on the Real Service.
Service helper unpacks the information from the client helper, ﬁnds out which method to call (and on which object) and invokes the real method on the real service object.
In Java, RMI builds the client and service helper objects for you, and it even knows how to make the client helper look like the Real Service.
In other words, RMI knows how to give the client helper object the same methods you want to call on the remote service.
Plus, RMI provides all the runtime infrastructure to make it work, including a lookup service so that the client can ﬁnd and get the client helper (the proxy for the Real Service)
With RMI, you don’t write any of the networking or I/O code yourself.
There is one difference between RMI calls and local (normal) method calls.
Remember that even though to the client it looks like the method call is local, the client helper sends the method call across the network.
And what do we know about networking and I/O methods?
The client has to acknowledge that when it calls a remote method, even though to the client it’s just a local call to the proxy/helper object, the call ultimately involves Sockets and streams.
The client’s original call is local, but the proxy turns it into a remote call.
A remote call just means a method that’s invoked on an object on another JVM.
How the information about that call gets transferred from one JVM to another depends on the protocol used by the helper objects.
With RMI, you have a choice of protocols: JRMP or IIOP.
IIOP, on the other hand, is the protocol for CORBA (Common Object Request Broker Architecture), and lets you make remote calls on things which aren’t necessarily Java objects.
But thankfully, all we care about is Java-to-Java, so we’re sticking with plain old, remarkably easy RMI.
Java RMI gives you the client and service helper objects!
This is an overview of the ﬁ ve steps for making the remote service (that runs on the server)
Don’t worry, each step is explained in detail over the next few pages.
The remote interface deﬁ nes the methods that a client can call remotely.
It’s what the client will use as the polymorphic class type for your service.
It has the real implementation of the remote methods deﬁ ned in the remote interface.
It’s the object that the client wants to call methods on.
You don’t have to create these classes or ever look at the source code that generates them.
It’s all handled automatically when you run the rmic tool that ships with your Java development kit.
The rmiregistry is like the white pages of a phone book.
It’s where the user goes to get the proxy (the client stub/helper object)
You have to get the service object up and running.
Your service implementation class instantiates an instance of the service and registers it with the RMI registry.
Remote is a ‘marker’ interface, which means it has no methods.
It has special meaning for RMI, though, so you must follow this rule.
The remote interface is the one the client uses as the polymorphic type for the service.
In other words, the client invokes methods on something that implements the remote interface.
That something is the stub, of course, and since the stub is doing networking and I/O, all kinds of Bad Things can happen.
The client has to acknowledge    the risks by handling or declaring the remote exceptions.
If the methods in an interface declare exceptions, any code calling methods on a reference of that type (the interface type) must handle or declare the exceptions.
Arguments and return values of a remote method must be either primitive or Serializable.
Any argument to a remote method has to be packaged up and shipped across the network, and that’s done through Serialization.
If you use primitives, Strings, and the majority of types in the API (including arrays and collections), you’ll be ﬁ ne.
If you are passing around your own types, just be sure that you make your classes implement Serializable.
Declaring RemoteException on every method forces the client to pay attention and acknowledge that things might not work.
This return value is gonna be shipped over the wire from the server back to the client, so it must be Serializable.
That’s how args and return values get packaged up and sent.
Your service has to implement the remote interface—the one with the methods your client is going to call.
In order to work as a remote service object, your object needs some functionality related to ‘being remote’
The only way to deal with this is to declare a constructor for your remote implementation, just so that you have a place to declare the RemoteException.
Remember,  when a class is instantiated, its superclass constructor is always called.
If your superclass constructor throws an exception, you have no choice but to declare that your constructor also throws an exception.
The compiler will make sure that you’ve implemented all the methods from the interface you implement.
Run rmic on the remote implementation class (not the remote interface)
The rmic tool, that comes with the Java software development kit, takes a service implementation and creates two new classes, the stub and the skeleton.
It uses a naming convention that is the name of your remote implementation, with either _Stub or.
There are other options with rmic, including not generating skeletons, seeing what the source code for these classes looked like, and even using IIOP as the protocol.
The way we’re doing it here is the way you’ll usually do it.
Remember, rmic must be able to see your implementation class, so you’ll probably run rmic from the directory where your remote implementation is.
We’re deliberately not using packages here, to make it simpler.
Be sure you start it from a     directory that has access to your classes.
The simplest way is to start it from your ‘classes’ directory.
This might be from a main() method in your remote implementation class, or from a separate launcher class.
In this simple example, we put the starter code in the implementation class, in a main method that instantiates the object and registers it with RMI registry.
You have to implement all the interface methods, of course.
But notice that you do NOT have to declare the RemoteException.
Make the remote object, then ‘bind’ it to the rmiregistry using the static Naming,rebind()
The name you register it under is the name clients will need to look it up in the rmi registry.
How does the client get the stub object? The client has to get the stub object, since that’s the thing the client will call methods on.
The client does a ‘lookup’, like going to the white pages of a phone book, and essentially says, “Here’s a name, and I’d like the stub that goes with that name.”
The client always uses the remote implementation as the type of the service.
In fact, the client never needs to know the actual class name of your remote service.
You have to cast it to the interface, since the lookup method returns type Object.
This must be the name that the service was registered under.
You MUST have the stub class (that rmic generated for you) on the client or the stub won’t be deserialized.
Client invokes a method on the stub, as though the stub IS the real service.
How does the client get the stub class? Now we get to the interesting question.
Somehow, someway, the client must have the stub class (that you generated earlier using rmic) at the time the client does the lookup, or else the stub won’t be deserialized on the client and the whole thing blows up.
In a simple system, you can simply hand-deliver the stub class to the client.
There’s a much cooler way, though, although it’s beyond the scope of this book.
But just in case you’re interested, the cooler way is called “dynamic class downloading”
With dynamic class downloading, a stub object (or really any Serialized object) is ‘stamped’ with a URL that tells the RMI system on the client where to ﬁnd the class ﬁle for that object.
Then, in the process of deserializing an object, if RMI can’t ﬁnd the class locally, it uses that URL to do an HTTP Get to retrieve the class ﬁle.
So you’d need a simple Web server to serve up class ﬁles, and you’d also need to change some security parameters on the client.
There are a few other tricky issues with dynamic class downloading, but that’s the overview.
The Naming class (for doing the remiregistry lookup) is in the java.rmi package.
It looks just like a regular old method call! (Except it must acknowledge the RemoteException)
Be sure each machine has the class files it needs.
The top three things programmers do wrong with RMI are:
Don’t forget, the client uses the interface to call methods on the stub.
The client JVM needs the stub class, but the client never refers to the stub class in code.
The client always uses the remote interface, as though the remote interface WERE the actual remote object.
Server needs both the Stub and Skeleton classes, as well as the service and the remote interface.
It needs the stub class because remember, the stub is substituted for the real service, when the real service is bound to the RMI registry.
Look at the sequence of events below, and place them in the order in which they occur in a Java RMI application.
The RMI registry is started The remote service (remote implementation) is instantiated.
This includes registering or looking up a service in the reigstry, and all remote method calls from the client to the stub.
I use it for serious B-to-B, e-commerce backends, running on J2EE.
I just can’t imagine life without our Jinienabled home network.
Me too! How did anyone get by? I just love RMI.
What about Servlets? Servlets are  Java programs that run on (and with) an HTTP web server.
When a client uses a web browser to interact with a web page, a request is sent back to the web server.
If the request needs the help of a Java servlet, the web server runs (or calls, if the servlet is already running) the servlet code.
Servlet code is simply code that runs on the server, to do work as a result of whatever the client requests (for example, save information to a text ﬁ le or database on the server)
If you’re familiar with CGI scripts written in Perl, you know exactly what we’re talking about.
Web developers use CGI scripts or servlets to do everything from sending user-submitted info to a database, to running a web-site’s discussion board.
By far, the most common use of J2EE technology is to mix servlets and EJBs together, where servlets are the client of the EJB.
And in that case, the servlet is using RMI to talk to the EJBs.
Although the way you use RMI with EJB is a little different from the process we just looked at.
Client ﬁ lls out a registration form and clicks ‘submit’
Servlet (Java code) runs, adds data to the database, composes a web page (with custom info) and sends it back to the client where it displays in the browser.
For these examples, we’ll assume that you already have a web server up and running, and that it’s already conﬁ gured to support servlets.
The most important thing is to ﬁ nd out exactly where your servlet class ﬁ les have to be placed in order for your server to ‘see’ them.
If you have a web site hosted by an ISP, the hosting service can tell you where to put your servlets, just as they’ll tell you  where to place your CGI scripts.
Servlets aren’t part of the standard Java libraries; you need the servlets classes packaged into the servlets.jar ﬁ le.
You can download the servlets classes from java.sun.com, or you can get them from your Java-enabled web server (like Apache Tomcat, at the apache.org site)
Without these classes, you won’t be able to compile your servlets.
There are other types of servlets you can make, but most of the time we care only about HttpServlet.
This is completely dependent on your web server (and more speciﬁ cally, on which version of Java Servlets that you’re using)
Your ISP may simply tell you to drop it into a “Servlets” directory on your web site.
But if you’re using, say, the latest version of Tomcat, you’ll have a lot more work to do to get the servlet (and web page) into the right location.
We just happen to have a book on this too.
Most ‘normal’ servlets will extend HttpServlet, then override one or more methods.
This tells the server (and browser) what kind of ‘thing’ is coming back from the server as a reuslt of this servlet running.
Q: What’s a JSP, and how does it relate to servlets?
In the end, the web server turns a JSP into a servlet, but the difference between a servlet and a JSP is what YOU (the developer) actually create.
With a servlet, you write a Java class that contains HTML in the output statements (if you’re sending back an HTML page to the client)
But with a JSP, it’s the opposite—you write an HTML page that contains Java code!
This gives you the ability to have dynamic web pages where you write the page as a normal HTML page, except you embed Java code (and other tags that “trigger” Java code at runtime) that gets processed at runtime.
In other words, part of the page is customized at runtime when the Java code runs.
The main benefit of JSP over regular servlets is that it’s just a lot easier to write the HTML part of a servlet as a JSP page than to write HTML in the torturous print out statements in the servlet’s response.
Imagine a reasonably complex HTML page, and now imagine formatting it within println statements.
But for many applications, it isn’t necessary to use JSPs because the servlet doesn’t need to send a dynamic response, or the HTML is simple enough not to be such a big pain.
And, there are still many web servers out there that support servlets but do not support JSPs, so you’re stuck.
Another benefit of JSPs is that you can separate the work by having the Java developers write the servlets and the web page developers write the JSPs.
In reality, there’s still a Java learning curve (and a tag learning curve) for anyone writing a JSP, so to think that an HTML web page designer can bang out JSPs is not realistic.
But that’s the good news—authoring tools are starting to appear, that help web page designers create JSPs without writing the code from scratch.
Q: Is this all you’re gonna say about servlets? After such a huge thing on RMI?
Servlets and JSPs are not part of the Java language; they’re considered standard extensions.
You can run RMI on any modern JVM, but Servlets and JSPs require a properly configured web server with a servlet “container”
This is our way of saying, “it’s beyond the scope of this book.” But you can read much more in the lovely Head First Servlets & JSP.
For example, if a client submits information in a web page form, the servlet can process the information, add it to a database, and send back a customized, confirmation response page.
The servlet classes are not part of the Java standard libraries, so you need to download the servlets.
If you have a web site hosted by an ISP that supports servlets, the ISP will tell you which directory to place your servlets in.
And Java code can call Java code from other classes.
So a servlet is free to call a method on the Phrase-O-Matic.
All you have to do is drop the Phrase-O-Matic class into the same directory as your servlet, and you’re in business.
Phrase-O-Matic code, servlet-friendly This is a slightly different version from the code in chapter one.
In the original, we ran the entire thing in a main() method, and we had to rerun the program each time to generate a new phrase at the command-line.
In this version, the code simply returns a String (with the phrase) when you invoke the static makePhrase() method.
That way, you can call the method from any other code and get back a String with the randomly-composed phrase.
Please note that these long String[] array assignments are a victim of wordprocessing here—don’t type in the hyphens! Just keep on typing and let your code editor do the wrapping.
Enterprise JavaBeans: RMI on steroids RMI is great for writing and running remote services.
But you wouldn’t run something like an Amazon or eBay on RMI alone.
For a large, deadly serious, enterprise application, you need something more.
You need something that can handle transactions, heavy concurrency issues (like a gazillion people are hitting your server at once to buy those organic dog kibbles), security (not just anyone should hit your payroll database), and data management.
A J2EE server includes both a web server and an Enterprise JavaBeans(EJB) server, so that you can deploy an application that includes both servlets and EJBs.
Like servlets, EJB is way beyond the scope of this book, and there’s no way to show “just a little” EJB example with code, but we will take a quick look at how it works.
For a much more detailed treatment of EJB, we can recommend the lively Head First EJB certiﬁcation study guide.
An EJB server adds a bunch of services that you don’t get with straight RMI.
An EJB server steps into the middle of an RMI call and layers in all of the services.
This is only a small part of the EJB picture!
We think Jini is pretty much the best thing in Java.
If EJB is RMI on steroids (with a bunch of managers), Jini is RMI with wings.
Like the EJB material, we can’t get into any of the Jini details here, but if you know RMI, you’re three-quarters of the way there.
In terms of mindset, it’s time to make a big leap.
Jini uses RMI (although other protocols can be involved), but gives you a few key features including:
With RMI, remember, the client has to know the name and location of the remote service.
The client code for the lookup includes the IP address or hostname of the remote service (because that’s where the RMI registry is running) and the logical name the service was registered under.
But with Jini, the client has to know only one thing: the interface implemented by the service! That’s it.
So how do you ﬁnd things? The trick revolves around Jini lookup services.
Jini lookup services are far more powerful and ﬂexible than the RMI registry.
For one thing, Jini lookup services announce themselves to the network, automatically.
When a lookup service comes online, it sends a message (using IP multicast) out to the network saying, “I’m here, if anyone’s interested.”
Let’s say you (a client) come online after the lookup service has already announced itself, you can send a message to the entire network saying, “Are there any lookup services out there?”
Except that you’re not really interested in the lookup service itself—you’re interested in the services that are registered with the lookup service.
Things like RMI remote services, other serializable Java objects, and even devices such as printers, cameras, and coffeemakers.
And here’s where it gets even more fun: when a service comes online, it will dynamically discover (and register itself with) any Jini lookup services on the network.
When the service registers with the lookup service, the service sends a serialized object to be placed in the lookup service.
That serialized object can be a stub to an RMI remote service, a driver for a networked device, or even the whole service itself that (once you get it from the lookup service) runs locally on your machine.
And instead of registering by name, the service registers by the interface it implements.
Jini lookup service is launched somewhere on the network, and announces itself using IP multicast.
An already-running Jini service on another machine asks to be registered with this newly-announced lookup service.
In other words, it registers as the service interface it implements.
It sends a serialized object to be placed in the lookup service.
It has no idea where (or if) that thing exists, so it asks the lookup service.
The newly-registered service must keep renewing the lease, or the lookup service assumes the service has gone ofﬂine.
The lookup service wants always to present an accurate picture to the rest of the network about which services are available.
The service goes offline (somebody shuts it down), so it fails to renew its lease with the lookup service.
Final Project: the Universal Service browser We’re going to make something that isn’t Jini-enabled, but quite easily could be.
It will give you the ﬂavor and feeling of Jini, but using straight RMI.
In fact the main difference between our application and a Jini application is how the service is discovered.
Instead of the Jini lookup service, which automatically announces itself and lives anywhere on the network, we’re using the RMI registry which must be on the same machine as the remote service, and which does not announce itself automatically.
And instead of our service registering itself automatically with the lookup service, we have to register it in the RMI registry (using Naming.rebind())
But once the client has found the service in the RMI registry, the rest of the application is almost identical to the way we’d do it in Jini.
The main thing missing is the lease that would let us have a self-healing network if any of the services go down.
The universal service browser is like a specialized web browser, except instead of HTML pages, the service browser downloads and displays interactive Java GUIs that we’re calling universal services.
The RMI remote service has a getServiceList() method that sends back this list of services.
Client starts up and does a lookup on the RMI registry for the service called “ServiceServer”, and gets back the stub.
User selects from the list, so client calls the getService() method on the remote service.
The remote service returns a serialized object that is an actual service that will run inside the client browser.
Client calls the getGuiPanel() on the serialized service object it just got from the remote service.
The GUI for that service is displayed inside the browser, and the user can interact with it locally.
At this point, we don’t need the remote service unless/until the user decides to select another service.
A regular old RMI remote interface for the remote service (the remote service has the method for getting the service list and returning a selected service)
It builds a very simple GUI, does a lookup in the RMI registry to get the ServiceServer stub, then calls a remote method on it to get the list of services to display in the GUI list.
Every service that gets shipped over to the client must implement this interface.
This is what makes the whole thing UNIVERSAL!  By implementing this interface, a service can come over even though the client has no idea what the actual class (or classes) are that make up that service.
All the client knows is that whatever comes over, it implements the Service interface, so it MUST have a getGuiPanel() method.
And since getGuiPanel() returns a JPanel, I’ll just slap it into the browser GUI and start interacting with it!
Remember that fabulous little ‘music video’ program from the ﬁ rst GUI Code Kitchen? We’ve turned it into a service, and you can play it over and over and over until your roommates ﬁ nally leave.
Were you born on a Friday? Type in your birthday and ﬁ nd out.
The interface extends Serializable, so that any class implementing the Service interface will automatically be Serializable.
That’s a must, because the services get shipped over the wire from the server, as a result of the client calling getService() on the remote ServiceServer.
Instead of putting ONE object in the collection, you put TWO -- a key object (like a String) and a value object (whatever you want)
Client calls this in order to get a list of services to display in the browser (so the user can select one)
We send an array of type Object (even though it has Strings inside) by making an array of just the KEYS that are in the HashMap.
We won’t send an actual Service object unless the client asks for it by calling getService()
Add the services (an a rray of Objects) to th.
Here’s where we add the actual service to the GUI, after the user has selected one.
We call getService() on the remote server (the stub for ServiceServer) and pass it the String that was displayed in the list (which is the SAME String we originally got from the server when we called getServiceList())
The server returns the actual service (serialized), which is automatically deserialized (thanks to RMI) and we simply call the getGuiPanel() on the service and add the result (a JPanel) to the browser’s mainPanel.
Cast the stub to the remote interface type, so that we can call getServiceList() on it.
Here’s the one important method! The method of the Service interface-- the one the client’s gonna call when this service is selected and loaded.
You can do whatever you want in the getGuiPanel() method, as long as you return a JPanel, so it builds the actual dice-rolling GUI.
Sharpen your pencil Think about ways to improve the DiceService.
One suggestion: using what you learned in the GUI chapters, make the dice graphical.
Use a rectangle, and draw the appropriate number of circles on each one, corresponding to the roll for that particular die.
This is all the music stuff from the Code Kitchen in chapter 12, so we won’t annotate it again here.
Wouldn’t it be dreamy if this were the end of the book? If there were no more bullet points or puzzles.
It connects to a simple MusicServer so that you can send and receive beat patterns with other clients.
Click one to load the pattern that goes with it, and then click ‘Start’ to play it.
Sequencer sequencer; Sequence sequence; Sequence mySequence = null; Track track;
Final BeatBox client program Most of this code is the same as the code from the CodeKitchens in the previous chapters, so we don’t annotate the whole thing again.
When a message comes in, we read (deserialize) the two objects (the message and the ArrayList of Boolean checkbox state values) and add it to the JList component.
This method is called when the user selects something from the list.
We IMMEDIATELY change the pattern to the one they selected.
All the MIDI stuff is exactly the same as it.
What are some of the ways you can improve this program?
Once you select a pattern, whatever current pattern was playing is blown away.
If that was a new pattern you were working on (or a modification of another one), you’re out of luck.
You might want to pop up a dialog box that asks the user if he’d like to save the current pattern.
If you fail to type in a command-line argument, you just get an exception when you run it! Put something in the main method that checks to see if you’ve passed in a command-line argument.
If the user doesn’t supply one, either pick a default or print out a message that says they need to run it again, but this time with an argument for their screen name.
It might be nice to have a feature where you can click a button and it will generate a random pattern for you.
Better yet, have another feature that lets you load in existing ‘foundation’ patterns, like one for jazz, rock, reggae, etc.
You can find existing patterns on the Head First Java web start.
Final BeatBox server program Most of this code is identical to the SimpleChatServer we made in the Networking and Threads chapter.
The only difference, in fact, is that this server receives, and then re-sends, two serialized objects instead of a plain String (although one of the serialized objects happens to be a String)
We covered a lot of ground, and you’re almost finished with this book.
We can’t possibly fit everything you’ll need to know into this relatively small appendix.
You mean, there’s still MORE? Doesn’t this book EVER end?
You might have occasion to turn individual bits on or off.
For instance you might ﬁnd yourself writing code for your new Java enabled toaster, and realize that due to severe memory limitations, certain toaster settings are controlled at the bit level.
The next three operators compare two primitives on a bit by bit basis, and return a result based on comparing these bits.
We’ll use the following example for the next three operators:
Bitwise AND Operator:   & This operator returns a value whose bits are turned on only if both original bits are turned on:
Bitwise OR Operator:   | This operator returns a value whose bits are turned on only if either of the original bits are turned on:
Bitwise XOR (exclusive OR) Operator:  ^ This operator returns a value whose bits are turned on only if exactly one of the original bits are turned on:
The Shift Operators These operators take a single integer primitive and shift (or slide) all of its bits in one direction or another.
If you want to dust off your binary math skills, you might realize that shifting bits left effectively multiplies a number by a power of two, and shifting bits right effectively divides a number by a power of two.
We’ll use the following example for the next three operators:
Ok, ok, we’ve been putting it off, here is the world’s shortest explanation of storing negative numbers, and two’s complement.
Remember, the leftmost bit of an integer number is called the sign bit.
A positive integer number always has its sign bit turned off (0)
Java uses the two’s complement formula to store negative numbers.
Right Shift Operator:   >> This operator shifts all of a number’s bits right by a certain number, and ﬁlls all of the bits on the left side with whatever the original leftmost bit was.
Unsigned Right Shift Operator:   >>> Just like the right shift operator BUT it ALWAYS ﬁlls the leftmost bits with zeros.
Left Shift Operator:   << Just like the unsigned right shift operator, but in the other direction; the rightmost bits are ﬁlled with zeros.
Why do you care that Strings are Immutable? When your Java programs start to get big, you’ll inevitably end up with lots and lots of String objects.
For security purposes, and for the sake of conserving memory (remember your Java programs can run on teeny  Java-enabled cell phones), Strings in Java are immutable.
Whenever you make a new String, the JVM puts it into a special part of memory called the ‘String Pool’ (sounds refreshing doesn’t it?)
If there is already a String in the String Pool with the same value, the JVM doesn’t create a duplicate, it simply refers your reference variable to the existing entry.
The JVM can get away with this because Strings are immutable; one reference variable can’t change a String’s value out from under another reference variable referring to the same String.
The other issue with the String pool is that the Garbage Collector doesn’t go there.
So in our example, unless by coincidence you later happen to make a String called “01234”, for instance, the ﬁ rst nine Strings created in our for loop will just sit around wasting memory.
How does this save memory? Well, if you’re not careful, it doesn’t!  But if you understand how String immutability works, than you can sometimes take advantage of it to save memory.
Why do you care that Wrappers are Immutable? In the Math chapter we talked about the two main uses of the wrapper classes:
Wrapping a primitive so it can pretend to be an object.
It’s important to remember that when you create a wrapper object like:
You can, of course, refer iWrap to a different wrapper object, but then you’ll have two objects.
Once you create a wrapper object, there’s no way to change the value of that object!
Roses are red, violets are blue.Strings are immutable, wrappers are too.
Oh look! A bonus Make it Stick.Right here in the appendix.
We haven’t talked much about how to debug your Java program while you’re developing it.
We believe that you should learn Java at the command line, as we’ve been doing throughout the book.
Once you’re a Java pro, if you decide to use an IDE*, you might have other debugging tools to use.
Then, once the program was working correctly, she’d go through and take all those System.
Add them to your code as you would add println statements.
At runtime, if you do nothing, the assert statements you added to your code will be ignored by the JVM, and won’t slow down your program.
But if you tell the JVM to enable your assertions, they will help you do your debugging, without changing a line of code!
Some folks have complained about having to leave assert statements in their production code, but leaving them in can be really valuable when your code is already deployed in the ﬁeld.
If your client is having trouble, you can instruct the client to run the program with assertions enabled, and have the client send you the output.
If the assertions were stripped out of your deployed code, you’d never have that option.
And there is almost no downside; when assertions are not enabled, they are completely ignored by the JVM, so there’s no performance hit to worry about.
How to make Assertions work Add assertion statements to your code wherever you believe that something must be true.
You can add a little more information to the stack.
The expression after the colon can be any legal Java expression that resolves to a non-null value.
But whatever you do, don’t create assertions that change an object’s state!  If you do, enabling assertions at runtime might change how your program performs.
The compiler will make sure that you don’t try to use.
No problem, x and y ar e both in scope.
Linked Invocations While you did see a little of this in this book, we tried to keep our syntax as clean and readable as possible.
There are, however, many legal shortcuts in Java, that you’ll no doubt be exposed to, especially if you have to read a lot code you didn’t write.
One of the more common constructs you will encounter is known as linked invocations.
What in the world is happening in the second line of code?  Admittedly, this is a contrived example, but you need to learn how to decipher these.
Find the result of the leftmost method call, in this case sb.delete(3,6)
If you look up StringBuffer in the API docs, you’ll see that the delete() method returns a StringBuffer object.
The result of running the delete() method is a StringBuffer object with the value “spr”
The next leftmost method (insert())is called on the newly created StringBuffer object “spr”
The result of that method call (the insert() method), is also a StringBuffer object (although it doesn’t have to be the same type as the previous method return), and so it goes, the returned object is used to call the next method to the right.
In theory, you can link as many methods as you want in a single statement (although it’s rare to see more than three linked methods in a single statement)
Without linking, the second line of code from above would be more readable, and look something like this:
But here’s  a more common, and useful example, that you saw us using, but we thought we’d point it out again here.
This is for when your main() method needs to invoke an instance method of the main class, but you don’t need to keep a reference to the instance of the class.
In other words, the main() needs to create the instance only so that main() can invoke one of the instance’s methods.
In the GUI event-handling section of the book, we started using inner (nested) classes as a solution for implementing listener interfaces.
That’s the most common, practical, and readable form of an inner class—where the class is simply nested within the curly braces of another enclosing class.
And remember, it means you need an instance of the outer class in order to get an instance of the inner class, because the inner class is a member of the outer/enclosing class.
But there are other kinds of inner classes including static and anonymous.
We’re not going into the details here, but we don’t want you to be thrown by strange syntax when you see it in someone’s code.
Because out of virtually anything you can do with the Java language, perhaps nothing produces more bizarre-looking code than anonymous inner classes.
You already know what static means—something tied to the class, not a particular instance.
A static nested class looks just like the non-static classes we used for event listeners, except they’re marked with the keyword static.
Because a static nested class is...static, you don’t use an instance of the outer class.
You just use the name of the class, the same way you invoke static methods or access static variables.
Static nested classes are more like regular non-nested classes in that they don’t enjoy a special relationship with an enclosing outer object.
But because static nested classes are still considered a member of the enclosing/outer class, they still get access to any private members of the outer class...
Since the static nested class isn’t connected to an instance of the outer class, it doesn’t have any special way to access the non-static (instance) variables and methods.
Any Java class that’s deﬁ ned within the scope of another class is known as a nested class.
If it’s inside another class, it’s technically considered a nested class.
But non-static nested classes are often referred to as inner classes, which is what we called them earlier in the book.
The bottom line: all inner classes are nested classes, but not all nested classes are inner classes.
Imagine you’re writing some GUI code, and suddenly realize that you need an instance of a class that implements ActionListener.
But you realize you don’t have an instance of an ActionListener.
Then you realize that you also never wrote a class for that listener.
Create an anonymous inner class and instantiate it, right there, just-in-time.
Literally right where you are at the point you need the listener object.
That’s right, you create the class and the instance in the place where you’d normally be supplying just the instance.
Think about that for a moment—it means you pass the entire class where you’d normally pass only an instance into a method argument!
Access Levels (in order of how restrictive they are, from least to most restrictive)
Most of the time you’ll use only public and private access levels.
Use public for classes, constants (static ﬁnal variables), and methods that you’re.
Use private for virtually all instance variables, and for methods that you don’t want.
But although you might not use the other two (protected and default), you still need to.
Both protected and default access levels are tied to packages.
Default access is simple—it means that only code within the same package can access code with default access.
So a default class, for example (which means a class that isn’t explicitly declared as public) can be accessed by only classes within the same package as the default class.
But what does it really mean to access a class? Code that does not have access to a class is not allowed to even think about the class.
And by think, we mean use the class in code.
For example, if you don’t have access to a class, because of access restriction, you aren’t allowed to instantiate the class or even declare it as a type for a variable, argument, or return value.
You simply can’t type it into your code at all! If you do, the compiler will complain.
Think about the implications—a default class with public methods means the public methods aren’t really public at all.
You can’t access a method if you can’t see the class.
Why would anyone want to restrict access to code within the same package? Typically, packages are designed as a group of classes that work together as a related set.
Protected access is almost identical to default access, with one exception: it allows subclasses to inherit the protected thing, even if those subclasses are outside the package of the superclass they extend.
That’s all protected buys you—the ability to let your subclasses be outside your superclass package, yet still inherit pieces of the class, including methods and constructors.
Many developers ﬁnd very little reason to use protected, but it is used in some designs, and some day you might ﬁnd it to be exactly what you need.
One of the interesting things about protected is that—unlike the other access levels—protected access applies only to inheritance.
As of Java 5.0 you should use the StringBuilder class instead of.
StringBuffer, unless your String manipulations need to be thread-safe, which is not common.
String valueOf(char [])                        // make a String out of a char array.
String valueOf(int i)                             // make a String out of a primitive // other primitives are supported as well.
Note: StringBxxxx refers to either StringBuffer or StringBuilder, as appropriate.
But in Java, such an array would actually be 5 arrays linked together!  In Java, a two dimensional array is simply an array of arrays.
A three dimensional array is an array of arrays of arrays, but we’ll leave that for you to play with.
Each of these four elements is actually a reference variable referring to a (newly created), int array with 2 elements.
To make a one-dimensional reference to one of the sub-arrays:    int[] copy = a2d[1];
Remember that the array itself is an object   (an array holding references to int arrays)
And the number one topic that didn’t quite make it in...
Let’s say that you’re creating a website for your favorite band, and you want to.
The good news about this technique is that it DOES make the code easier to.
The other good news is that you can’t ever change the value of the fake.
When you create an enum, you’re creating a new class, and you’re implicitly extending.
You can declare an enum as its own standalone class, in its own.
Using the enum we just created, we can perform branches in our code using either.
JERRY, instrument: lead guitar, sings: plaintively BOBBY, instrument: rhythm guitar, sings: hoarsely PHIL, instrument: bass, sings: occasionally.
Notice that the basic “sing()” method is only called when the enum value has no constantspecific class body.
It runs once for each declared enum value (in this case it runs three times)
Captain Byte of the Flatland starship “Traverser” had received an urgent, Top Secret transmission.
The message contained 30 heavily encrypted navigational codes that the.
Traverser would need to successfully plot a course home through enemy sectors.
Hackarians, from a neighboring galaxy, had devised a devilish code-scrambling ray that was capable.
The only defense the Traverser crew had against this evil Hackarian ray was.
Captain Byte gave Ensign Smith the following programming instructions to process the critical.
Put the ﬁrst ﬁve codes in an array of type ParsecKey.
Put the last 25 codes in a ﬁve by ﬁve, two.
Pass these two arrays into the plotCourse() method of the.
A few minutes later Ensign Smith returned with the NavSim output.
Once the virus check returned with no viruses detected, I ran the.
Why did the captain conﬁne the Ensign to his quarters?
Captain Byte knew that in Java, multidimensional arrays are actually arrays of arrays.
The ensign had forgotten the reference variables for the ﬁve one.
Don’t you know about the web site? We’ve got answers to some of the.
Top Ten Things that didn’t make it into the rest of the book Index.
