Head First Object-Oriented Analysis and Design is a refreshing look at the subject of  OOA&D.
What sets this book apart is its focus on learning.
There are too many books on the market that spend a lot of time telling you why, but do not actually enable the practitioner to start work on a project.
I strongly believe that the future of  software development practice will focus on the practitioner.
I just finished reading HF OOA&D, and I loved it! The book manages to get across the essentials of object-oriented analysis and design with UML and use cases, and even several lectures on good software design, all in a fast-paced, easy to understand way.
The book does a good job of  capturing that entertaining, visually oriented, ‘Head First’ writing style.
But hidden behind the funny pictures and crazy fonts is a serious, intelligent, extremely well-crafted presentation of  OO Analysis and Design.
This book has a strong opinion of  how to design programs, and communicates it effectively.
I love the way it uses running examples to lead the reader through the various stages of  the design process.
This is a well-designed book that delivers what it promises to its readers: how to analyze, design, and write serious object-oriented software.
Its contents flow effortlessly from using use cases for capturing requirements to analysis, design, implementation, testing, and iteration.
Every step in the development of  object-oriented software is presented in light of  sound software engineering principles.
By starting with simple concepts and examples, the book gently takes the reader from humble beginnings to (by the end of  the book) where the reader should be comfortable creating Ajax-based websites...
If  you know some HTML, a dollop of  CSS, a little JavaScript, and a bit of  PHP, but you’re mystified about what all the Ajax hype is about, this book is for you…You’ll have a blast learning Ajax with Head Rush Ajax.
By the time you’ve reached the end of  the book, all those web technologies that didn’t quite fit together in your head will all snap into place and you’ll have The Ajax Power! You’ll know the secrets behind some of  the most popular web applications on the Internet.
If  you thought Ajax was rocket science, this book is for you.
She’s never done any web design, so she needed a book like Head First HTML with CSS & XHTML to take her from beginning to end.
She now has a list of  web sites she wants to build.
Freeman’s Head First HTML with CSS & XHTML is a most entertaining book for learning how to build a great web page.
It not only covers everything you need to know about HTML, CSS, and XHTML, it also excels in explaining everything in layman’s terms with a lot of  great examples.
From the awesome Head First Java folks, this book uses every conceivable trick to help you understand and remember.
Not just loads of  pictures: pictures of  humans, which tend to interest other humans.
Wouldn’t it be dreamy if there was an analysis and.
O’Reilly Media books may be purchased for educational, business, or sales promotional use.
Many of  the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and O’Reilly Media, Inc., was aware of  a trademark claim, the designations have been printed in caps or initial caps.
While every precaution has been taken in the preparation of  this book, the publisher and the authors assume no responsibility for errors or omissions, or for damages resulting from the use of  the information contained herein.
In other words, if  you use anything in Head First OOA&D to, say, write code that controls an American space shuttle, you’re on your own.
No dogs, rabbits, or woodchucks were harmed in the making of  this book, or Todd and Gina’s dog door.
To all the brilliant people who came up with various ways to gather requirements, analyze software, and design code...
When that became fairly mundane, Brett took on application servers, working on the internals of  the Lutris Enhydra servlet engine and EJB container.
Along the way, Brett got hooked on open source software, and helped found several cool programming tools, like Jakarta Turbine and JDOM.
Gary is a Professor of  Practice (meaning he had a real job before becoming a professor) at Worcester Polytechnic Institute.
He lives in central Massachusetts with his wife, Vikki, and their two dogs, Aloysius and Ignatius.
Feel free to drop him a note and complain or cheer about the book.
Dave West would like to describe himself  as sheik geek.
Unfortunately no one else would describe him in that way.
They would say he is a professional Englishman who likes to talk about software development best practices with the passion and energy of  an evangelical preacher.
Recently Dave has moved to Ivar Jacobson Consulting, where he runs the Americas and can combine his desire to talk about software development and spread the word on rugby and football, and argue that cricket is more exciting than baseball.
Before running the Americas for Ivar Jacobson Consulting, Dave worked for a number of  years at Rational Software (now a part of  IBM)
Dave held many positions at Rational and then IBM, including Product Manager for RUP where he introduced the idea of  process plug-ins and agility to RUP.
Here you are trying to learn something, while here your brain is doing you a favor by making sure the learning doesn’t stick.
Better leave room for more important things, like which wild animals to avoid and whether.
Great Software Begins HereSo how do you really write great software? It’s never easy trying to figure out where to start.
Does the application actually do what it’s supposed to? And what about things like duplicate code—that can’t be good, can it? It’s usually pretty.
How am I supposed to know where to start? I feel like every time I get a new project to work on, everyone’s got a different opinion.
Sometimes I get it right, and sometimes I end up reworking the whole app because I started in the wrong place.
You already know that the first step in writing great software is making sure it does what the customer wants it to.
But how do you figure out what a customer really wants? And how do you make sure that.
A button on the remote control opens the dog door if the door is closed, and closes the dog door if the door is open.
Once the dog door has opened, it should close automatically if the door isn’t already closed.
Todd or Gina presses the button on the remote control.
The dog door and remote are part of the system, or inside the system.
Now ChangeThink you’ve got just what the customer wanted? Not so fast...
So you’ve talked to your customer, gathered requirements, written out your use cases, and delivered a killer application.
Taking Your Software into the Real WorldIt’s time to graduate to real-world applications.
Your application has to do more than work on your own personal development machine, finely tuned and perfectly setup; your apps have to work when real people use them.
This chapter is all about making sure that your software works in a real-world context.
You’ll learn how textual analysis can take that use case you’ve been working on and.
In the real world, there are dogs, cats, rodents, and a host of other problems, all set to screw up your software.
In this context, things go wrong a lot more often.
Once I knew the classes and operations that I needed, I.
No matter how much you like your software right now, it’s probably going to change tomorrow.
And the harder you make it for your software to change, the more difficult it’s going to be to respond to your.
In fact, we’re going to uncover a problem so big that it will.
Are you ready?   You’ve got a ton of tools in your OOA&D toolbox, but how do you use those tools when you have to build something really big? Well, you may not realize it, but.
Requirements and use cases are a good place to start...
This BIG PROBLEM is really just a collection of functionalities, where each.
Bringing Order to ChaosYou have to start somewhere, but you better pick the right somewhere! You know how to break your application up into lots of small problems, but all that means is that you have LOTS of small problems.
Along the way, you’ll learn about the all-important 3 Qs of.
Not a chance in hell of coming in on time.
Originality is OverratedImitation is the sincerest form of  not being stupid.
There’s nothing as satisfying as coming up with a completely new and original solution to a problem that’s been troubling you for days—until you find out someone else solved.
The Software is Still for the CustomerIt’s time to show the customer how much you really care.
Nagging bosses? Worried clients? Stakeholders that keep asking, “Will it be done on time?” No amount of well-designed code will please your customers; you’ve got to.
In this chapter, we learn about two ways to dive deeper into your software’s.
All the properties that were common across units are represented as variables outside of the properties Map.
Each of the new properties gets its own set of methods.
Sam figured that id would get set in the Unit constructor, so no need for a setId() method.
Putting It All TogetherAre we there yet? We’ve been working on lots of individual ways to improve your software, but now it’s time to put it all together.
Yes, with over 550 pages under your belt, there are still things we couldn’t cram in.
Even though these last ten topics don’t deserve more than a mention, we didn’t.
But hey, now you’ve got just a little bit more to talk about.
Open the door Close the doorBe sure you write down things that.
Anti-patterns are the re verse of design patterns: they are common BAD solutions to.
This is how you show a class in a class diagram.
That’s the way that UML lets you represent details about the classes in your application.
It’s always in bold, at the top of the class diagram.
Each one has a name, and then a type after the colon.
This line separates the member variables from the methods of the class.
Each one has a name, and then any parameters the method takes, and then a return type after the colon.
A class diagram makes it really easy to see the big picture: you can easily.
You can even leave out the variables and/or methods if it helps you communicate better.
Intro I can’t believe they put that in an objectoriented analysis and design book!
Do you want to learn, understand, remember, and apply object-oriented analysis and design to real world projects, and write better software in the process?
You also might be okay with just a C++ background.
Are you afraid to try something different?  Would you rather have a root canal than mix stripes with plaid? Do you believe that a technical book can’t be serious if programming concepts are anthropomorphized?
If  you can answer “yes” to any one of  these:
Are you a kick-butt OO designer/developer looking for a reference book?
Do you prefer stimulating dinner party conversation to dry, dull, academic lectures?
It was built that way, and it helps you stay alive.
How does your brain know what’s important? Suppose you’re out for a day hike and a tiger jumps in front of  you, what happens inside your head and body?
This must be important! Don’t forget it! But imagine you’re at home, or in a library.
Or trying to learn some tough technical topic your boss thinks will take a week, ten days at the most.
And there’s no simple way to tell your brain, “Hey brain, thank you very much, but no matter how dull this book is, and how little I’m registering on the emotional Richter scale right now, I really do want you to keep this stuff  around.”
We think of a “Head First” reade r as a learner.
All of this is represented in a single Connection object.
Great software every time? I can hardly imagine what that.
If  you really want to learn, and you want to learn more quickly and more deeply, pay attention to how you pay attention.
Most of  us did not take courses on metacognition or learning theory when we were growing up.
We were expected to learn, but rarely taught to learn.
But we assume that if  you’re holding this book, you really want to learn objectoriented analysis and design.
And you probably don’t want to spend a lot of time.
And since you’re going to develop software, you need to remember what you read.
To get the most from this book, or any book or learning experience, take responsibility for your brain.
The trick is to get your brain to see the new material you’re learning as Really Important.
Otherwise, you’re in for a constant battle, with your brain doing its best to keep the new content from sticking.
So just how DO you get your brain to think objectoriented analysis and design is a hungry tiger? There’s the slow, tedious way, or the faster, more effective way.
You obviously know that you are able to learn and remember even the dullest of  topics if  you keep pounding the same thing into your brain.
With enough repetition, your brain says, “This doesn’t feel important to him, but he keeps looking at the same thing over and over and over, so I suppose it must be.”
A conversational style helps because people tend to pay more attention when they perceive that they’re in a conversation, since they’re expected to follow along and hold up their end.
The amazing thing is, your brain doesn’t necessarily care that the “conversation” is between you and a book! On the other hand, if  the writing style is formal and dry, your brain perceives it the same way you experience being lectured to while sitting in a roomful of  passive attendees.
We used pictures, because your brain is tuned for visuals, not text.
As far as your brain’s concerned, a picture really is worth 1,024 words.
And when text and pictures work together, we embedded the text in the pictures because your brain works more effectively when the text is within the thing the text refers to, as opposed to in a caption or buried in the text somewhere.
We used redundancy, saying the same thing in different ways and with different media types, and multiple senses, to increase the chance that the content gets coded into more than one area of your brain.
We used concepts and pictures in unexpected ways because your brain is tuned for novelty, and we used pictures and ideas with at least some emotional content, because your brain is tuned to pay attention to the biochemistry of  emotions.
That which causes you to feel something is more likely to be remembered, even if  that feeling is nothing more than a little humor, surprise, or interest.
We used a personalized, conversational style, because your brain is tuned to pay more attention when it believes you’re in a conversation than if  it thinks you’re passively listening to a presentation.
We included more than 80 activities, because your brain is tuned to learn and remember more when you do things than when you read about things.
We include content for both sides of  your brain, because the more of  your brain you engage, the more likely you are to learn and remember, and the longer you can stay focused.
Since working one side of  the brain often means giving the other side a chance to rest, you can be more productive at learning for a longer period of  time.
And we included stories and exercises that present more than one point of  view, because your brain is tuned to learn more deeply when it’s forced to make evaluations and judgements.
In stories, examples, pictures, etc., because, well, because you’re a person.
And your brain pays more attention to people than it does to things.
We assume that if  you’re going for a PhD in software design, this won’t be your only book.
Here’s what YOU can do to bend your brain into submission.
The more you understand, the less you have to memorize.
When the book asks you a question, don’t just skip to the answer.
The more deeply you force your brain to think, the better chance you have of learning and remembering.
We put them in, but if  we did them for you, that would be like having someone else do your workouts for you.
There’s plenty of evidence that physical activity while learning can increase the learning.
They’re not optional side-bars—they’re part of  the core content! Don’t skip them.
Part of  the learning (especially the transfer to long-term memory) happens after you put the book down.
Your brain needs time on its own, to do more processing.
If  you put in something new during that processing time, some of  what you just learned will be lost.
If  you’re trying to understand something, or increase your chance of  remembering it later, say it out loud.
Better still, try to explain it out loud to someone else.
You’ll learn more quickly, and you might uncover ideas you hadn’t known were there when you were reading about it.
Feel something! Your brain needs to know that this matters.
Groaning over a bad joke is still better than feeling nothing at all.
It would take an entire book to teach you Java (in fact, that’s exactly what it took: Head First Java)
We chose to focus this book on analysis and design, so the chapters are written with the assumption that you know the basics of  Java.
When intermediate or advanced concepts come up, they’re taught as if  they might be totally new to you, though.
If  you’re completely new to Java, or coming to this book from a C# or C++ background, we strongly recommend you turn to the back of  the book and read Appendix II before going on.
That appendix has some intro material that will help you start this book off  on the right foot.
Java 5.0 introduces a lot of  new features to the Java language, ranging from generics to parameterized types to enumerated types to the foreach looping construct.
The only exception is in Chapter 1, when we needed an enumerated type—and we explained enums in that section in some detail.
If  you’re new to Java 5, you should have no trouble with any of  the code examples.
The exercises and activities are not add-ons; they’re part of  the core content of  the book.
Some of  them are to help with memory, some are for understanding, and some will help you apply what you’ve learned.
The crossword puzzles are the only things you don’t have to do, but they’re good for giving your brain a chance to think about the words and terms you’ve been learning in a different context.
These guys caught mistakes that we missed, let us know when we were moving too fast (or too slow), and even let us know when our jokes sucked.
Several times, they turned chapters around in a matter of  hours...
We continue to be amazed at the insight and expertise that Bert Bates has about cliffs, and that Kathy Sierra has about dog doors.
Bert and Kathy did a ton of  review at the eleventh hour, and we’re thankful they did.
Their help and guidance continues to be the heart of  Head First.
Because I’m doing the typing, I get to step out of  “we” mode for a moment and say thanks to my co-authors, Dave West and Gary Pollice.
Neither of  these guys knew what they were signing up for when they came on board, but I’ve never been so impressed by a couple of  guys willing to explain, defend, and even change their opinions and knowledge about software design, requirements and analysis, and lift shafts.
They were simply incredible, writing up until the very last day, and even got me to relax and laugh until I cried on several occasions.
This book wouldn’t be in your hands if  not for Mary O’Brien.
I think it’s fair to say she fought more battles and paved the way for us to work without interruption more times than any of  us really are aware of.
Most importantly, she made this the single most enjoyable project we’ve worked on in our careers.
Frankly, she kicked our asses a number of  times, and it made all the difference.
She really doesn’t realize how much of  an effect she has on the people she works with, because we don’t tell her enough how much we respect her and value her opinions.
Lou, your work has improved the learning quality of  this book, and we can’t thank you enough for your contributions.
Near the completion of  this book, Laura Baldwin, the CFO of  O’Reilly, encountered some personal tragedy.
It’s hard to know what to say in these situations, especially because Laura has really become the backbone of  O’Reilly in many ways.
Laura, we are thinking and praying for you and your family, and we wish you all the very, very best in the days to come.
We know you’d want nothing more than to see everyone at O’Reilly working harder than ever while you’re away.
This book is certainly a testament to the people at O’Reilly continuing to deliver, and in many of our conversations, your name came up as someone we wanted to support, and not let down in any way.
Your effect on this company is extraordinary, and O’Reilly and the Head First series will all be much better for the day you can return to us in full swing.
So how do you really write great software? It’s never easy trying to figure out where to start.
By the time you’re done with this chapter, you’ll know.
Sue, but since I started using OOA&D, I’m just a new man...
Rock and roll is forever! There’s nothing better than the sound of  a killer guitar in the hands of  a great player, and Rick’s Guitars specializes in finding the perfect instrument for his discerning customers.
Come on in, tell us about what kind of guitar you like, and we’ll find.
Meet Rick, guitar aficionado, and owner of a high-end guitar shop.
Just a few months ago, Rick decided to throw out his paper-based system for keeping track of  guitars, and start using a computer-based system to store his inventory.
He hired a popular programming firm, Down and Dirty Coding, and they’ve already built him an inventory management app.
He’s even had the firm build him a new search tool to help him match up a customer to their dream instrument.
Here’s the application that the programming firm built for Rick...
Here’s the UML class diagram they gave Rick to show him what they did:
Here’s Rick’s entire inventory, as well as a way for him to search for guitars.
This method takes in all of a guitar’s details, creates a Guitar object, and adds it to Rick’s inventory.
This method takes a guitar’s serial number, and returns that guitar’s object.
This is the search method; it takes in a client’s ideal guitar, and returns a guitar from Rick’s inventory that matches up with the client’s specs.
The inventory stores a list of all the guitars that Rick currently has available.
New to Objectville? If you’re new to object oriented programming, haven’t heard of UML before, or aren’t sure about the diagram above, it’s OK! We’ve prepared a special.
Flip to the back of the book, and read Appendix II—we promise you’ll be glad you did.
Then come back here, and this will all make a lot more sense.
Check it out before going on if you’re new to UML or OO programming.
Here what the code for Guitar.java looks like You’ve seen the class diagram for Rick’s application on the last page; now let’s look at what the actual code for Guitar.java and Inventory.java look like.
These are all the properties we saw from the class diagram for the Guitar class.
You can see how the class diagram matches up with the methods in the Guitar class’s code.
Remember, we’ve stripped out the import statements to save some space.
It seems like no matter who the customer is and what they like, Rick’s new search program almost always comes up empty when it looks for good guitar matches.
But Rick knows he has guitars that these customers would like...
I’m sorry, Rick, I guess I’ll just go to that other store.
Erin is looking for a Fender “Strat” guitar, made of Alder.
Look over the last three pages, showing the code for Rick’s app, and the results of running a search.
What problems do you see? What would you change? Write down the FIRST thing you’d do to improve Rick’s app in the blanks below.
Here’s part of the code that sets up Rick’s inventory.
These specs seem to match up perfectly with what Erin asked for...
What’s the FIRST thing you’d change? It’s obvious that Rick’s app has problems, but it’s not so obvious what we should work on first.
Joe’s fairly new to programming, but he’s a big believer in writing objectoriented code.
Frank’s been around for a while and really knows his OO principles and design patterns.
Jill’s got a rep for always delivering exactly what the customer wants.
How am I supposed to know where to start? I feel like every time I get a new project to work.
Great software always does what the customer wants it to.
So there’s not a bunch of duplicate code, and each object pretty much controls its own behavior.
Guitar serialNumber: String price: double spec: GuitarSpec getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): GuitarSpec.
Great software is when you use tried-and-true design patterns and principles.
You’ve kept your objects loosely coupled, and your code open for extension but closed for modification.
This approach is all about making sure the customer is happy with what their app does.
Good OO programmers are always looking for ways to make their code more flexible.
This design-focused approach optimizes code for extension and reuse, and takes advantages of design patterns and proven OO techniques.
You’ve seen what several different types of programmers think great software is...
In fact, all of  the different programmers on page 10 talked about a part of  what makes software great.
The software must do what the customer wants it to do.
Building software that works right is great, but what about when it’s time to add to your code, or reuse it in another application? It’s not enough to just have software that works like the customer wants it to; your software better be able to stand the test of  time.
Second, great software is well-designed, well-coded, and easy to maintain, reuse, and extend.
Win your customers over Customers will think your software is great when it does what it’s supposed to do.
You (and your co-workers) will think your software is great when it’s easy to maintain, reuse, and extend.
Wow, if my code could do all that, then it really would be great.
Make sure your software does what the customer wants it to do.
Make sure the app does what it’s supposed to do FIRST.
This is where getting good requirements and doing some analysis comes in.
Once your software works, you can look for any duplicate code that might have slipped in, and make sure you’re using good OO programming techniques.
Got a good object-oriented app that does what it should? It’s time to apply patterns and principles to make sure your software is ready to use for years to come.
Remember Rick? Remember his lost customers? Let’s put our ideas about how to write great software to the test and see if  they hold up in the real world.
Rick’s got a search tool that isn’t working, and it’s your job to fix the application, and turn it into something great.
Let’s look back at the app and see what’s going on:
Make sure your software does what the customer wants it to do.
Remember, we need to start out by making sure the app actually does what Rick wants...
Here’s our test program that reveals a problem with the search tool.
Don’t worry too much about trying to apply patterns or other OO techniques to your app at this point...
Frank: Sure, that would fix the problem Rick’s having now, but I think there’s probably a better way to make this work than just calling toLowerCase() on a bunch of  strings all over the place.
I mean, all that string comparison seems like a bad idea.
Couldn’t we use constants or maybe some enumerated types for the builders and woods?
Step 1 was supposed to be fixing the app so it does what the customer wants it to do.
I thought we weren’t supposed to worry about design yet.
Frank:  Well, yeah, I get that we’re supposed to focus on the customer.
But we can at least be smart about how we fix things, right? I mean, why create problems we’ll have to come back and fix later on if  we can avoid them from the start?
We don’t want our solution to this problem creating new design problems for us down the road.
But we’re still not going to mess with the other parts of  the application, right?
We can just remove all those strings, and the string comparisons, to avoid this whole case-matching thing.
If  we go with enumerated types, we can ensure that only valid values for the builder, woods, and type of  guitar are accepted.
That’ll make sure that Rick’s clients actually get to look at guitars that match their preferences.
Jill:  And we’ve actually done a little bit of  design at the same time...
If we’re starting with functionality, let’s figure out what’s going on with.
It looks like in Rick’s inventory, he’s got “Fender” with a capital “F,” and the customer’s specs have “fender” all lowercase.
Let’s get a little help from some of our programmer buddies.
Ditching String comparisons The first improvement we can make to Rick’s guitar search tool is getting rid of  all those annoying String comparisons.
And even though you could use a function like toLowerCase() to avoid problems with uppercase and lowercase letters, let’s avoid String comparisons altogether:
These are all Java enums, enumerated types that function sort of like constants.
Enumerated types let you define a type name, like Wood, and then a set of values that are allowed for that type (like COCOBOLO, SITKA, and MAHOGANY)
Then, you refer to a specific value like this: Wood.COCOBOLO.
Each enum takes the place of one of the guitar properties that is standard across all guitars.
One of the big advantages of using enums is that it limits the possible values you can supply to a method...
A: The cool thing about enums is that methods or classes that use them are protected from any values not defined in the enum.
So you can’t misspell or mistype an enum without getting a compiler error.
It’s a great way to get not only type safety, but value safety; you can avoid getting bad data for anything that has a standard range or set of legal values.
We can replace all those String preferences with the new enumerated type values.
It looks like nothing has changed, but with enums, we don’t have to worry about these comparisons getting screwed up by misspellings or case issues.
The only property that we need to worry about case on is the model, since that’s still a String.
The Guitar class uses these enumerated types to represent data, in a way that won’t get screwed up by case issues or errors in spelling.
Now the addGuitar() method takes in several enums, instead of Strings or integer constants.
Even though it looks like nothing’s changed in search(), now we’re using enums to make sure we don’t miss any matches because of spelling or capitalization.
We’ve replaced most of those String properties with enumerated types.
The serial number is still unique, and we left model as a String since there are thousands of different guitar models out there...
We’ve gotten a lot closer to completing step 1 in building great software.
Rick’s problem with searches coming up empty when he’s got a matching guitar in his inventory is a thing of  the past.
Even better, we’ve made Rick’s application less fragile along the way.
It’s not going to break so easily now, because we’ve added both type safety and value safety with these enums.
That means less problems for Rick, and less maintenance for us.
Make sure your software does what the customer wants it to do.
Code that is not fragile is generally referred to as robust code.
Q: So it’s OK to do a little design when I’m working on Step 1, right?
A: Yeah, as long as your focus is still on the customer’s needs.
You want the basic features of your application in place before you start making big design changes.
But while you’re working on functionality, you can certainly use good OO principles and techniques to make sure your application is well designed from the start.
Q: That diagram over on page 18 is a class diagram right? Or is it class diagrams, since it’s more than one class?
A: It is a class diagram, and a single diagram can have multiple classes in it.
In fact, class diagrams can show a lot more detail than you’ve seen so far, and we’ll be adding to them in the next several chapters.
Q: So we’re ready to move on to Step 2, and start applying OO principles, right?
Remember, our first job is to please the customer, and then we really focus on improving our OO design.
It’s time to see how you can satisfy your own customers.
In the blank below, write a short description of the current project you’re working on (you can also use a project you finished recently):
Now, write down the first thing you did when you started working on this project.
Did it have anything to do with making sure your code did what the customer wanted it to?
If you started out focusing on something other than the customer, think about how you might have approached things differently if you knew about the 3 steps to building great software.
What would have been different? Do you think your application would be any better or worse than it is right now?
So I thought this was perfect, but then I realized...
Rick’s happy with your improvements but he really needs the app to return all matching guitars, not just one.
Rick would really like Erin to be able to check out both of these guitars.
Rick’s customers want choices! Rick’s come up with a new requirement for his app: he wants his search tool to return all the guitars that match his client’s specs, not just the first one in his inventory.
Let’s continue with Step 1, and make sure we’ve got the app working right.
Below is the code for the search() method in Rick’s inventory tool, but it’s up to you to fill in the missing pieces.
Use the code magnets at the bottom of the page to return all the matching guitars from Rick’s inventory.
We want search() to be able to return multiple Guitar objects if Rick has more than one guitar that matches his client’s specs.
Let’s keep on with Step 1, and make sure we’ve got the app working right.
Below is the code for the search() method in Rick’s inventory tool, but it’s up to you to fill in the missing pieces.
Use the code magnets at the bottom of the page to return all the matching guitars from Rick’s inventory.
You actually could have used either a LinkedList or an ArrayList here...
Matching guitars get added to the list of options for Rick’s client.
Q: So I’m not done with the first step until the application works like my customer wants it to?
You want to make sure that the application works like it should before you dive into applying design patterns or trying to do any real restructuring of how the application is put together.
A: You’re going to make lots of changes to your software when you’re getting it to work right.
Trying to do too much design before you’ve at least got the basic functionality down can end up being a waste, because a lot of the design will change as you’re adding new pieces of functionality to your classes and methods.
A:  There’s nothing that says you have to follow these steps exactly, but they do provide an easy path to follow to make sure your software does what it’s supposed to, and is well-designed and easy to reuse.
If you’ve got something similar that accomplishes the same goals, that’s great!
Test drive We’ve talked a lot about getting the right requirements from the customer, but now we need to make sure we’ve actually got those requirements handled by our code.
Let’s test things out, and see if  our app is working like Rick wants it to:
Here’s the test program, updated to use the new version of Rick’s search tool.
Everything worked! Erin gets several guitar recommendations, and Rick’s customers are going to start buying guitars again.
You can have it for only $1499.95! ---We have a Fender Stratocastor electric guitar: Alder back and sides, Alder top.
You can have it for only $1549.95! ---This time we get a whole list of guitars that match the client’s specs.
In this new version, we need to iterate over all the choices returned from the search tool.
Make sure your software does what the customer wants it to do.
Back to our steps Now that Rick’s all set with our software, we can begin to use some OO principles and make sure the app is flexible and well-designed.
So this is where we can make sure there’s no duplicate.
Here’s where you take software that works, and make sure the way it’s put together actually makes sense.
Now that the app does what Rick wants, we’re finished up with this step.
Is anything wrong here? What problems might there be with Rick’s search tool?
Looking for problems Let’s dig a little deeper into our search tool, and see if  we can find any problems that some simple OO principles might help improve.
Let’s start by taking a closer look at how the search() method in Inventory works:
Each guitar in Rick’s inventory is compared against the specs in the client’s Guitar object.
The client provides a set of specs for their ideal guitar, in the form of a Guitar object.
Guitar The client doesn’t provide a price or serial number, since those are unique to each particular guitar.
There’s a Guitar object for each guitar in Rick’s inventory, storing the serial number, price, and specs for each instrument.
The search() method is called with the specs from the client, and begins a search on Rick’s inventory.
Analyze the search() method Let’s spend a little time analyzing exactly what goes on in the search() method of  Inventory.java.
Before we look at the code, though, let’s think about what this method should do.
The client can specify only general properties of an instrument.
So they never supply a serial number or a price.
The client provides their guitar preferences.1 Each of  Rick’s clients has some properties that they’re interested in finding in their ideal guitar: the woods used, or the type of guitar, or a particular builder or model.
They provide these preferences to Rick, who feeds them into his inventory search tool.
The search tool looks through Rick’s inventory.2 Once the search tool knows what Rick’s client wants, it starts to loop through each guitar in Rick’s inventory.
Each guitar is compared to the client’s preferences.3 For each guitar in Rick’s inventory, the search tool sees if  that guitar matches the client’s preferences.
If  there’s a match, the matching guitar is added to the list of  choices for the client.
Rick’s client is given a list of matching guitars.4 Finally, the list of  matching guitars is returned to Rick and his client.
The client can make a choice, and Rick can make a sale.
All the general properties, like the top wood and guitar builder, are compared to the client’s preferences.
Use a textual description of the problem you’re trying to solve to make sure that your design lines up with the intended functionality of your application.
In the better-designed areas of Objectville, objects are very particular about their jobs.
Each object is interested in doing its job, and only its job, to the best of its ability.
There’s nothing a well-designed object hates more than being used to do something that really isn’t its true purpose.
Unfortunately, it’s come to our attention that this is exactly what is happening in Rick’s inventory search tool: somewhere, an object is being used to do something that it really shouldn’t be doing.
It’s your job to solve this mystery and figure out how we can get Rick’s application back in line.
To help you figure out what’s gone amiss, here are some helpful tips to start you on your search for the mismatched object type:
Avoid a Duck object that represents a real quacking duck, a yellow plastic duck, and someone dropping their head down to avoid getting hit by a baseball.
If you’ve got an object that is being used with no-value or null properties often, you’ve probably got an object doing more than one job.
If you rarely have values for a certain property, why is that property part of the object? Would there be a better object to use with just a subset of those properties?
What do you think the mismatched object type is? Write your answer in the blank below:
What do you think you should do to fix the problem? What changes would you make?
STOP! Try and solve this mystery before turning the page.
Jill: So what? Using a Guitar object makes it really easy to do comparisons in the search() method.
Joe: It really doesn’t matter what type of  object we’re using there, as long as we can figure out what specific things Rick’s clients are looking for.
Frank:  Yeah, I think we should have a new object that stores just the specs that clients want to send to the search() method.
Then they’re not sending an entire Guitar object, which never seemed to make much sense to me.
Jill: But isn’t that going to create some duplicate code? If  there’s an object for all the client’s specs, and then the Guitar has all its properties, we’ve got two getBuilder() methods, two getBackWood() methods...
Frank: So why don’t we just encapsulate those properties away from Guitar into a new object?
I was with you until you said “encapsulate.” I thought that was when you made all your variables private, so nobody could use them incorrectly.
Frank: Encapsulation is also about breaking your app into logical parts, and then keeping those parts separate.
So just like you keep the data in your classes separate from the rest of  your app’s behavior, we can keep the generic properties of  a guitar separate from the actual Guitar object itself.
Jill:  And then Guitar just has a variable pointing to a new object type that stores all its properties?
Frank: Exactly! So we’ve really encapsulated the guitar properties out of  Guitar, and put them in their own separate object.
You know, Rick’s clients really aren’t providing a Guitar object...
I mean, they don’t actually give him a guitar to compare against his.
Encapsulation allows you to hide the inner workings of your application’s parts, but yet make it clear what each part does.
Below, you’ll see the class diagram for Guitar, and the new GuitarSpec object that Frank, Jill, and Joe have been discussing.
It’s your job to add all the properties and methods that you think you’ll need to GuitarSpec.
Then, cross out anything you don’t need anymore in the Guitar class.
Finally, we’ve left you some space in the Guitar class diagram in case you think you need to add any new properties or methods.
Move anything out of the Guitar object that you think belongs in the new GuitarSpec class.
You can add extra properties and methods to Guitar if you think you need to.
If you get stuck, think about the things that are common between the Guitar object and what a client would supply to the search() method.
Below you’ll see the class diagram for Guitar, and the new GuitarSpec object that Frank, Jill, and Joe have been discussing.
It’s your job to add all the properties and methods that you think you’ll need to GuitarSpec.
See if you made the same changes that we did.
These are the properties that Rick’s clients supply to search(), so we can move them into GuitarSpec.
These two properties are still unique to each Guitar, so they stay.
We also need a reference to a GuitarSpec object for each guitar.
The methods follow the same pattern as the properties: we remove any duplication between the client’s specs and the Guitar object.
We’ve removed duplicated code by moving all the common propertiesand related methods-into an object that we can use for both search requests and guitar details.
Now update your own code With this class diagram, you should be able to add the GuitarSpec class to your application, and update the Guitar class as well.
Go ahead and make any changes you need to Inventory.java so that the search tool compiles, as well.
Q: I understand why we need an object for the client to send specs to search()...
A: Suppose you just used GuitarSpec to hold client specs for sending to the search() method, and you kept the Guitar class just the same as it was.
If Rick started carrying 12-string guitars, and wanted a numStrings property, you’d have to add that property—and code for a getNumStrings() method—to both the GuitarSpec and Guitar classes.
Can you see how this would lead to duplicate code? Instead, we can put all that (potentially) duplicate code into the GuitarSpec class, and then have Guitar objects reference an instance of it to avoid any duplication.
A: The idea behind encapsulation is to protect information in one part of your application from the other parts of your application.
In its simplest form, you can protect the data in your class from the rest of your app by making that data private.
But sometimes the information might be an entire set of properties—like the details about a guitar—or even behavior—like how a particular type of duck flies.
When you break that behavior out from a class, you can change the behavior without the class having to change as well.
So if you changed how properties were stored, you wouldn’t have to change your Guitar class at all, because the properties are encapsulated away from Guitar.
That’s the power of encapsulation: by breaking up the different parts of your app, you can change one part without having to change all the other parts.
In general, you should encapsulate the parts of your app that might vary away from the parts that will stay the same.
Make sure your software does what the customer wants it to do.
This is where you look for big problems, especially related to things like duplicate code or bad class design.
Remember, we’ve got even more design work to do in this step, so before you’re done, your software is really easy to extend and reuse.
Let’s see how we’re coming along on our three steps to great software.
Update the Inventory class Now that we’ve encapsulated away the specifications of  a guitar, we’ll need to make a few other changes to our code.
Now search() takes a GuitarSpec, instead of an entire Guitar object.
This code is almost the same as it was before, except now we’re using information in the GuitarSpec object.
Getting ready for another test drive You’ll need to update the FindGuitarTester class to test out all these new changes:
You can download the current version of  Rick’s search tool at http://www.headfirstlabs.com.
Q: Encapsulation isn’t the only OO principle I can use at this stage, is it?
Other good OO principles that you might want to think about at this stage are inheritance and polymorphism.
Both of these relate to duplicate code and encapsulation though, so starting out by looking for places where you could use encapsulation to better your design is always a good idea.
We’ll talk about a lot more OO programming principles throughout this book (and even see a few sing in Chapter 8), so don’t worry if you are still getting a handle on things at this point.
You’ll learn a lot more about encapsulation, class design, and more before we’re done.
Q: But I don’t really see how this encapsulation makes my code more flexible.
A: Once you’ve gotten your software to work like it’s supposed to, flexibility becomes a big deal.
What if the customer wants to add new properties or features to the app? If you’ve got tons of duplicate code or confusing inheritance structures in your app, making changes is going to be a pain.
By introducing principles like encapsulation and good class design into your code, it’s easier to make these changes, and your application becomes a lot more flexible.
You’ve learned a lot about writing great software, and there’s still more to go! Take a deep breath and think about some of  the terms and principles we’ve covered.
Connect the words on the left to the purposes of  those techniques and principles on the right.
Why DO I Matter?dd dn Without me, you’ll never actually make the customer happy.
No matter how well-designed your application is, I’m the thing that puts a smile on the customer’s face.
I’m all about reuse and making sure you’re not trying to solve a problem that someone else has already figured out.
You use me to keep the parts of your code that stay the same separate from the parts that change; then it’s really easy to make changes to your code without breaking everything.
Use me so that your software can change and grow without constant rework.
You can have it for only $1499.95! ---We have a Fender Stratocastor electric guitar: Alder back and sides, Alder top.
You can have it for only $1549.95! ---Getting back to Rick’s app...
Let’s make sure all our changes haven’t messed up the way Rick’s tool works.
The results aren’t different this time, but the application is better designed, and much more flexible.
Can you think of three specific ways that welldesigned software is easier to change than software that has duplicate code?
Make sure your software does what the customer wants it to do.
Once you’ve applied some basic OO principles, you’re ready to apply some patterns and really focus on reuse.
Design once, design twice Once you’ve taken a first pass over your software and applied some basic OO principles, you’re ready to take another look, and this time make sure your software is not only flexible, but easily reused and extended.
It’s time to really think about reuse, and how easy it is to make.
Let’s make sure Inventory.java is well-designed We’ve already used encapsulation to improve the design of  Rick’s search tool, but there are still some places in our code where we could get rid of  potential problems.
This will make our code easier to extend when Rick comes up with that next new feature he wants in his inventory search tool, and easier to reuse if  we want to take just a few parts of  the app and use them in other contexts.
Now that you’ve made Rick a working search tool, you know he’s gonna call you back when he wants changes made to the tool.
There’s a big problem with the code shown above, and it’s up to you to figure it out.
In the blanks below, write down what you think the problem is, and how you would fix it.
How hard would it be to update my app so I.
Take a look at the class diagram for Rick’s application, and think about what you would need to do to add support for 12-string guitars.
What properties and methods would you need to add, and to what classes? And what code would you need to change to allow Rick’s clients to search for 12-strings?
How many classes did you have to modify to make this change? Do you think Rick’s application is well designed right now?
How easy is it to make this change to Rick’s application?
Guitar serialNumber: String price: double spec: GuitarSpec getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): GuitarSpec.
Get out your pencil, and add notes to the class diagram showing the following things:
Where you’d add a new property, called numStrings, to store the number of strings a guitar has.
Where you’d add a new method, called getNumStrings(), to return the number of strings a guitar has.
What other code you think you’d need to change so that Rick’s clients can specify that they want to try out 12-string guitars.
Finally, in the blanks below, write down any problems with this design that you found when adding support for 12-string guitars.
What’s the advantage of using a numStrings property instead of just adding a boolean property to indicate if a guitar is a 12-string?
Guitar serialNumber: String price: double spec: GuitarSpec getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): GuitarSpec.
Get out your pencil, and add notes to the class diagram showing the following things:
Where you’d add a new property, called numStrings, to store the number of strings a guitar has.
Where you’d add a new method, called getNumStrings(), to return the number of strings a guitar has.
What other code you think you’d need to change so that Rick’s clients can specify that they want to try out 12-string guitars.
Finally, in the blanks below, write down any problems with this design that you found when adding support for 12-string guitars.
We need to add a numStrings property to the GuitarSpec class.
We need a getNumStrings() method in this class to return how many strings a guitar has.
We need to change the constructor of this class, since it takes in all the properties in GuitarSpec, and creates a GuitarSpec object itself.
Another problem: we have to change the search() method here to account for the new property in GuitarSpec.
This class’s addGuitar() method deals with all of a guitar’s properties, too.
Even though you’re adding a property only to the GuitarSpec class, there are two other classes that have to be modified: Guitar and Inventory.
The constructor of  Guitar has to take an additional property now, and the search() method of  Inventory has to do an extra property comparison.
That’s right—we need to encapsulate the guitar specifications and isolate them from the rest of Rick’s guitar search tool.
The classes are all interdependent, and you can’t use one class without using all the others, too.
This constructor creates a GuitarSpec object, so every time the spec changes, this code has to change, too.
Modify Guitar.java so that the properties of  GuitarSpec are encapsulated away from the constructor of  the class.
Change the search() method in Inventory.java to delegate comparing the two GuitarSpec objects to the GuitarSpec class, instead of  handling the comparison directly.
Compare your answers with ours on page 44, and then get ready for another test drive to see if  we’ve finally got this application finished.
Adding a new property to GuitarSpec.java results in changes to the code in Guitar.java and Inventory.java.
The application should be restructured so that adding properties to GuitarSpec doesn’t affect the code in the rest of  the application.
It’s not enough to know what’s wrong with Rick’s app, or even to figure out that we need some more encapsulation.
Now we need to actually figure out how to fix his app so it’s easier to reuse and extend.
All you should have to do here is update your code that creates a sample inventory to use the new Guitar constructor.
A: Delegation is when an object needs to perform a certain task, and instead of doing that task directly, it asks another object to handle the task (or sometimes just a part of the task)
So in the design puzzle, you want the search() method in Inventory to ask GuitarSpec to tell it if two specs are equal, instead of comparing the two GuitarSpec objects directly within the search() method itself.
Q: What’s the point of that? A: Delegation makes your code more reusable.
It also lets each object worry about its own functionality, rather than spreading the code that handles a single object’s behavior all throughout your application One of the most common examples of delegation in Java is the equals() method.
Instead of a method trying to figure out if two objects are equal, it calls equals() on one of the objects and passes in the second object.
Then it just gets back a true or false response from the equals() method.
Q: And what does delegation have to do with code being more reusable?
A:  Delegation lets each object worry about equality (or some other task) on its own.
This means your objects are more independent of each other, or more loosely coupled.
Loosely coupled objects can be taken from one app and easily reused in another, because they’re not tightly tied to other objects’ code.
A:  Loosely coupled is when the objects in your application each have a specific job to do, and they do only that job.
So the functionality of your app is spread out over lots of well-defined objects, which each do a single task really well.
Q: And why is that good? A:  Loosely coupled applications are usually more flexible, and easy to change.
Since each object is pretty independent of the other objects, you can make a change to one object’s behavior without having to change all the rest of your objects.
So adding new features or functionality becomes a lot easier.
The act of one object forwarding an operation to another object, to be performed on.
Adding a new property to GuitarSpec.java results in changes to the code in Guitar.java and Inventory.java.
The application should be refactored so that adding properties to GuitarSpec doesn’t affect the code in the rest of  the application.
It’s not enough to know what’s wrong with Rick’s app, or even to figure out that we need some more encapsulation.
Now we need to actually figure out how to fix his app so we can test it out.
Modify Guitar.java so that the properties of  GuitarSpec are encapsulated away from the constructor of  the class.
Change the search() method in Inventory.java to delegate comparing the two GuitarSpec objects to the GuitarSpec class, instead of  handling the comparison directly.
Just take in a GuitarSpec directly now, instead of creating one in this constructor.
Most of the code from search() has been pulled out, and put into a matches() method in GuitarSpec.java.
Adding properties to GuitarSpec now requires only a change to that class, not Guitar.java or Inventory.java.
One last test drive (and an app ready for reuse) Wow, we’ve done a lot of  work since Rick showed us that first version of  his guitar app.
Let’s see if  the latest version still works for Rick and his clients, and manages to satisfy our own goal of  having a welldesigned, easily maintainable application that we can reuse.
You can have it for only $1549.95! ---This is what you should see when you run FindGuitarTester with your new code.
Congratulations! You’ve turned Rick’s broken inventory search tool into a welldesigned piece of great software.
Erin gets a couple of guitars to choose from, and Rick is back to selling guitars to his elite clientele.
Make sure your software does what the customer wants it to do.
We started out by fixing some of the functionality problems with Rick’s search tool.
We went on to add some more functionality, so that the search returns a list of guitars.
We also encapsulated out the guitar properties, and made sure we could add new properties to the app easily.
We even added delegation so that our objects are less dependent upon each other, and can be reused easily.
What we did Let’s take a quick look back at how we got Rick’s search tool working so well:
Remember our 3 steps? We followed them to turn Rick’s broken search tool into functional, well-designed software.
All this time that we’ve been talking about the three steps you can follow to write great software, we’ve really been talking about OOA&D.
OOA&D is really just an approach to writing software that focuses on making sure your code does what it’s supposed to, and that it’s well designed.
That means your code is flexible, it’s easy to make changes to it, and it’s maintainable and reusable.
Object-Oriented Analysis & Design helps you write great software, every timeWe call.
So what’s the answer? How do you write great software consistently?
You just need a set of  steps to follow that makes sure your software works and is well designed.
It can be as simple as the three steps we used in working on Rick’s app; you just need something that works, and that you can use on all of  your software projects.
OOA&D is about writing great software, not doing a bunch of paperwork!
We can get requirements from the customer to make sure that we build them what they ask for.
Use cases and diagrams are helpful ways to do that, but it’s all about figuring out what the customer wants the app to do.
Nobody is happy when an application that worked yesterday is crashing today.
If  we design our apps well, then they’re going to be robust, and not break every time a customer uses them in unusual ways.
Class and sequence diagrams can help show us design problems, but the point is to write well-designed and robust code.
There’s nothing worse than a customer asking for a simple new feature, and being told it’s going to take two weeks and $25,000 to make it happen.
Using OO techniques like encapsulation, composition, and delegation will make your applications maintainable and extensible.
Ever built something for one customer, and realized you could use something almost exactly the same for another customer? If  you do just a little bit of  analysis on your apps, you can make sure they’re easily reused, by avoiding all sorts of  nasty dependencies and associations that you don’t really need.
Concepts like the Open-Closed Principle (OCP) and the Single Responsibility Principle (SRP) are big time in helping here.
Sometimes just a little refactoring can take a good app and turn it into a nice framework that can be used for all sorts of  different things.
This is where you can begin to move from being a head-down coder and start thinking like a real architect (oh yeah, those guys make a lot more money, too)
This is ALL OOA&D! It’s not about doing silly diagrams...
This is fantastic! I’m selling guitars like crazy with this new.
By the way, I had a few ideas for some new features...
It takes very little for something to go wrong with an application that is fragile.
You can use OO principles like encapsulation and delegation to build applications that are flexible.
Encapsulation is breaking your application into logical parts that have a clear boundary that allows an object to hide its data and methods from other objects.
Delegation is giving another object the responsibility of handling a particular task.
Always begin a project by figuring out what the customer wants.
Once you’ve got the basic functionality of an app in place, work on refining the design so it’s flexible.
With a functional and flexible design, you can employ design patterns to improve your design further, and make your app easier to reuse.
Find the parts of your application that change often, and try and separate them from the parts of your application that don't change.
Building an application that works well but is poorly designed satisfies the customer but will leave you with pain, suffering, and lots of late nights fixing problems.
Object oriented analysis and design (OOA&D) provides a way to produce well-designed applications that satisfy both the customer and the programmer.
Let’s put what you’ve learned to use, and stetch out your left brain a bit.
All of the words to answer the puzzle below are somewhere in this chapter.
You’ve learned a lot about writing great software, and there’s still more to go! Take a deep breath and think about some of  the terms and principles we’ve covered.
Connect the words on the left to the purpose of  those techniques and principles on the right.
Why DO I Matter?dd dn Without me, you’ll never actually make the customer happy.
No matter how well-designed your application is, I’m the thing that puts a smile on the customer’s face.
I’m all about reuse and making sure you’re not trying to solve a problem that someone else has already figured out.
You use me to keep the parts of your code that stay the same separate from the parts that change; then it’s really easy to make changes to your code without breaking everything.
Use me so that your software can change and grow without constant rework.
There’s a big problem with the code shown above, and it’s up to you to figure it out.
In the blanks below, write down what you think the problem is, and how you would fix it.
Every time a new property is added to GuitarSpec, this code is going to have to change.
Think about it: is Inventory really focusing on Rick’s inventory? Or is it focusing on what makes two GuitarSpec objects the same? You want your classes to focus on their jobs, not the jobs of other classes.
Comparing GuitarSpec objects is something GuitarSpec should worry about, not your Inventory class.
You already know that the first step in writing great software is making sure it does what the.
But how do you figure out what a customer really.
Sick of  dog doors that stick when you open them?
You’ve got a new programming gig You’ve just been hired as the lead programmer at a new start-up, Doug’s Dog Doors.
Doug’s got a pretty high-tech door under development, and he’s decided you’re the programmer that can write all the software to make his killer hardware work.
Todd and Gina: your first customer Todd and Gina want more than a “normal” doggie door.
Todd has everything from his plasma TV to his surround sound stereo to his garage door operating off  of  a remote control, and he wants a dog door that responds to the press of a button.
Not satisfied with a little plastic flap letting their dog in and out, they’ve given Doug’s Dog Doors a call...
Every night, Fido barks and barks at the stupid door until we let him go.
I hate getting out of bed, and Todd never even wakes up.
Here’s the new sales insert that’s running in all the Sunday papers this week.
Let’s start with the dog door The first thing we need is a class to represent the dog door.
Let’s call this class DogDoor, and add just a few simple methods:
Assume the DogDoor class will interface with Doug’s custom door hardware.
This returns the state of the door: whether it’s open or closed.
Code Magnets Let’s write another class, Remote, to allow a remote control to operate the dog door.
Todd and Gina can use the remote to open the dog door without having to get out of bed.
You can use these to communicate with a dog door object.
These are the methods you wrote to control the dog door.
This keeps up with whether the door is open or closed.
Go ahead and take your new dog door for a test drive.
How do you think the rodents are getting into Gina’s kitchen? In the blanks below, write down what you think is wrong with the current version of the dog door.
Don’t go to the next page until you’ve written down an answer for this exercise.
There’s nothing wrong with our code! Gina must have forgotten to press the button on the remote again after Fido came.
Todd and Gina didn’t expect to have to close the dog door, so they pressed the button on the remote only once: to let Fido out.
Even worse, in this case, the way they used the door created new problems.
Rats and rabbits started coming into their house through the open door, and you’re taking the blame.
Let’s tackle Todd and Gina’s dog door again, but this time, we’ll do things a little bit differently.
But the door doesn’t work the way Todd and Gina want it to!
Get any additional information we need from Todd and Gina.
Looks like we’re going to spend a lot more time talking with Todd and Gina this time around.
Make sure your software does what the customer wants it to do.
A requirement is a singular need detailing what a particular product or service should be or do.
It is most commonly used in a formal sense in systems engineering or software engineering.
In this case, your system is Todd and Gina’s complete dog door setup (which includes the remote control, by the way)
The dog door system has to “do” lots of things: open, close, let Fido out, keep rodents from getting inside...
So if you leave out a requirement, or even if they forget to mention something to you, the system isn’t working correctly!
A requirement is usually a single thing, and you can test that thing to make sure you’ve actually fulfilled the requirement.
Listen to the customer When it comes to requirements, the best thing you can do is let the customer talk.
And pay attention to what the system needs to do; you can figure out how the system will do those things later.
Fido’s about a foot tall, and we don’t want him having to hurt his back.
Gina: And we want the door to automatically close after a few seconds.
I don’t want to have to wake back up in the middle of the night to close the door.
You: Do you want a single button on the remote, or both an “Open” and “Close” button?
Todd: Well, if  the door always closes automatically, we really don’t need separate “Open” and “Close” buttons, do we? Let’s just stick with a single button on the remote control.
So the button opens the door if  it’s closed, and it can also close the door if  it’s open, just in case the door gets stuck.
Don’t worry about your code at this stage-just make sure you know what the system should do.
Here’s what Todd and Gina say; it’s your job to translate this into requirements for their door.
Here’s your new set of remote control and dog door plans, based on Todd and Gina’s requirements.
There’s just one button, which toggles between opening and closing the door.
Creating a requirements list Now that we know what Todd and Gina want, let’s write down our new set of  requirements.
A button on the remote control opens the dog door if the door is closed, and closes the dog door if the door is open.
Once the dog door has opened, it should close automatically if the door isn’t already closed.
Compare these with Todd and Gina’s comments on page 63...
A special bonus prize In addition to having a list of  things you need to do to complete Todd and Gina’s dog door, now you can show.
We’ll just close the door after a few seconds of being open.
What sorts of things do you think Todd and Gina might not have thought about when it comes to their new dog door? Make a list of any concerns you might have in making sure Todd and Gina are happy with the new door you’re building them.
Is this list really going to help? Todd and Gina completely.
You need to understand how the dog door will be used.
In Todd and Gina’s case, the system is the dog door and the remote control.
A button on the remote control opens the dog door if the door is closed, and closes the dog door if the door is open.
Once the dog door has opened, it should close automatically if the door isn’t already closed.
What does the dog door really need to do? You know what Todd and Gina want the dog door to do, but it’s your job to make sure that the door actually works.
In the process, you may even come across some things that Todd and Gina want, but didn’t think about on their own.
Let’s write down exactly what happens when Fido needs to go outside:
Todd or Gina presses the button on the remote control.
This is a new list, which details what the dog door actually does.
We can use these steps to see if we’re missing any requirements.
When step 8 is complete, Fido’s back inside after doing his business, and Todd and Gina are happy.
Q: So a requirement is just one of the things that a customer wants the application you build for them to do?
A: Actually, a requirement is a lot more than just what the customer wants—although that’s a good place to start.
Begin by finding out what your customer wants and expects, and what they think the system you’re building for them should do.
Remember, most people expect things to work even if problems occur.
So you’ve got to anticipate what might go wrong, and add requirements to take care of those problems as well.
A good set of requirements goes beyond just what your customers tell you, and makes sure that the system works, even in unusual or unexpected circumstances.
Q: And the system for Todd and Gina is just the dog door, right?
A: The system is everything needed to meet a customer’s goals.
In the case of the dog door, the system includes the door, but it also includes the remote control.
And even though they aren’t part of the system, Todd and Gina and Fido are all things you have to at least think about when designing the system.
So there’s a lot more to worry about than just the actual dog door.
Q: I don’t see why I have to figure out how Todd and Gina are going to use the dog door, and what can go wrong.
A:  Do you remember the first step we talked about in writing great software? You’ve got to make sure your app works like the customer wants it to—even if that’s not how you would use the application.
That means you’ve got to really understand what the system has to do, and how your customers are going to use it.
In fact, the only way to ensure you get Todd and Gina a working, successful dog door is to know the system even better than they do, and to understand exactly what it needs to do.
You can then anticipate problems, and hopefully solve them before Todd and Gina ever know something could have gone wrong.
Q: So I should just come up with all sorts of bad things that might happen when Todd and Gina use their door?
The best way to get good requirements is to understand what a system is supposed to do.
If Fido is stuck outside, can Todd and Gina hear him bark to press “Open” on the remote and let him back in?
What if Todd and Gina aren’t home? What if they don’t hear Fido barking?
What if Fido barks because he’s excited, or hungry? Will it be a problem if Todd and Gina open the door and Fido doesn’t need to go outside?
Todd or Gina presses the button on the remote control.
Does Fido always bark when he needs to go outside? What if he just scratches at the door?
But things aren’t always going to go according to plan, so we’ve written down some things that might go wrong along the way.
What happens if the door has automatically closed by the time Fido is finished?
Can you think of other things that could go wrong? That’s great...
Go ahead and write anything else that might happen unexpectedly below, directly on the diagram.
Do we need to think about what happens if the door jams? Or maybe that’s more of a hardware problem?
A button on the remote control opens the dog door if the door is closed, and closes the dog door if the door is open.
Once the dog door has opened, it should close automatically if the door isn’t already closed.
Alternate paths handle system problems Now that you’ve figured out some of  the things that can go wrong, you need to update your list of  things that needs to happen to make the dog door work.
Let’s write down what should happen if  the door closes before Fido gets back inside.
Todd or Gina presses the button on the remote control.
We may need to update these later, but for now, they’re still OK.
All of these new steps handle the problem of the door closing before Fido can get back inside the house.
With some extra steps added, Fido can still get back inside, even though a problem Todd and Gina hadn’t thought about occurred.
If Fido stays outside, there are a few additional steps required to get him back inside.
Hey, I took a course in college on this stuff...
When you wrote down the steps in getting Fido outside to use the bathroom, you were actually writing a use case.
A use case is what people call the steps that a system takes to make something happen.
In Todd and Gina’s case, the “something” that needs to happen is getting Fido outside to do his business, and then back inside.
Todd or Gina presses the button on the remote control.
You’ve actually already written the use case for Todd and Gina’s dog door.
We’re still definitely focusing on what the system needs to “do.” What should happen in order to get Fido outside (and then back into the house)?
The customer goal is the point of the use case: what do all these steps need to make happen? We’re focusing on the customer, remember? The system has to help that customer accomplish their goal.
The dog door and remote are part of the system, or inside the system.
If Todd and Gina decide they want to track how many times Fido uses the dog door, that would be a different goal, so you’d need another, different use case.
A use case is a technique for capturing the potential requirements of a new system or software change.
Each use case provides one or more scenarios that convey how.
The use case ends when the customer goal is complete-that’s Fido back inside, after doing his business, with Todd and Gina still comfortable in bed.
The entire use case describes exactly what the dog door does when Fido needs to go outside.
This is an alternate path, but it’s still about achieving the same goal as the main path, so it’s part of the same use case.
One use case, three parts There are three basic parts to a good use case, and you need all three if  your use case is going to get the job done.
Clear Value Every use case must have a clear value to the system.
If  the use case doesn’t help the customer achieve their goal, then the use case isn’t of  much use.
External Initiator Every use case is started off  by an external initiator, outside of  the system.
Sometimes that initiator is a person, but it could be anything outside of  the system.
The use case must help Todd and Gina deal with Fido.
Use Case Magnets Below is Todd and Gina’s use case, and a magnet for each of the three parts of a good use case (one part, Start and Stop, actually has two magnets)
Your job is to identify where each magnet goes and attach it to the right part of the use case.
Put the Super Buy magnet on the part of the use case that is the clear value to Todd and Gina.
What kicks off the use case? This is usually some action outside of the system.
Put this magnet on the condition in the use case that indicates the process should stop.
The entire use case is of value, because Todd and Gina can stay in bed and still get Fido outside.
Your job was to identify where each magnet goes, and attach it to the right part of the use case.
Q: So a use case is just a list of the steps that a system has to do to work correctly?
But, remember, one of the key points about a use case is that it is focused on accomplishing one particular goal.
If your system does more than one thing—like let Fido outside and track how many times he’s been out in an entire day—then you’ll need more than one use case.
Q: Then my system will have a use case for every goal it accomplishes, right?
A: Exactly! If your system just does one single thing, you’ll probably only need one use case.
If it does ten or fifteen things, then you’re going to have a lot of use cases.
Q: And a use case is what the system does to accomplish a goal?
If you write down what the system needs to do to perform a task, you’ve probably got a use case.
Why didn’t we talk about the Remote class or the DogDoor class?
A:  Use cases are meant to help you understand what a system should do—and often to explain the system to others (like the customer or your boss)
If your use case focuses on specific codelevel details, it’s not going to be useful to anyone but a programmer.
As a general rule, your use cases should use simple, everyday language.
If you’re using lots of programming terms, or technical jargon, your use case is probably getting too detailed to be that useful.
Q: Is a use case the same as a use case diagram?
A:  No, use cases are usually a list of steps (although you can write them differently, something we talk about in the Appendix)
Use case diagrams are a way to show use cases visually, but we’ve already been working on our own diagram of how the system works (check out page 69 for a refresher)
Q: Then how do I turn my use case into actual code?
A:  That’s another step in the process of writing your application.
In fact, we’re going to look at how to take our use case for Todd and Gina and update our code in just a few more pages.
But the purpose of the use case isn’t to detail how you’ll write your code.
You’ll probably still have to do some thinking about how you want to actually put the steps of your use case into action.
Q: If the use case doesn’t help me write my code, then what’s the point? Why spend all this time on use cases?
A: Use cases do help you write your code—they just aren’t specific about programming details.
For instance, if you didn’t write a use case for Todd and Gina, you never would have figured out that Fido might get stuck outside, or realize that the dog door needed to close automatically.
Remember, you’ll never write great software if you can’t deliver an app that does what the customer wants it to do.
Use cases are a tool to help you figure that out—and then you’re ready to write code to actually implement the system your use case describes.
Checking your requirements against your use cases So far, you’ve got an initial set of  requirements and a good solid use case.
But now you need to go back to your requirements and make sure that they’ll cover everything your system has to do.
Once the dog door has opened, it should close automatically if the door isn’t already closed.
Here’s our list of requirements that we got from Todd and Gina...
Is anything missing? Now you need to look over the use case and see if  everything the system needs to do is covered by the requirements.
Your job is to identify the requirement that handles each step of the use case and write that requirement’s number down in the blank next to that step of the use case.
If a step in the use case doesn’t require you to do anything, just write N/A down, for “not applicable”
A button on the remote control opens the dog door if the door is closed, and closes the dog door if the door is open.3
Once the dog door has opened, it should close automatically if the door isn’t already closed.
Did you find any steps in the use case that you don’t think you have a requirement to handle? If you think you need any additional requirements, write what you think you need to add to the requirements list in the blanks below:
Your job was to identify the requirement that handles each step of the use case, and write that requirement’s number down in the blank next to that step of the use case.
You should have written down N/A for a step that didn’t require our system to do anything.
A lot of the things that happen to a system don’t require you to do anything.
You might have put N/A here, since them pushing the button isn’t something that’s you have to handle...
Did you get this one? Fido can’t get outside if the opening isn’t the right size.
The alternate path should have been easy once you figured out the requirements for the main path.
Did you find any steps in the use case that you don’t think you have a requirement to handle? If you think you need any additional requirements, write what you think you need to add to the requirements list down in the blanks below:
No, our requirements cover everything the system needs to do.
We’re ready to actually write code to handle these requirements now, right?
So now can we write some code? With use case and requirements in hand, you’re ready to write code that you know will make Todd and Gina satisfied customers.
Let’s check out our requirements and see exactly what we’re going to have to write code for:
Once the dog door has opened, it should close automatically if the door isn’t already closed.
This is something for Doug and the hardware guys to deal with...
This is what Todd and Gina added when we talked to them...
We love that you thought about Fido getting stuck outside, and took care of.
Automatically closing the door The only requirement left to code is taking care of automatically closing the door after it’s been opened.
Let’s go back to our Remote class and handle that now:
This tells the timer how long to wait before executing the task...
You’ll need these two import statements to use Java’s timing classes.
Create a new Timer so we can schedule the dog door closing.
All the task does is close the door, and then turn off the timer.
Q: What’s all this Timer stuff? Can’t I just use a Java thread to close the door?
A: Sure, there’s nothing wrong with using a Thread to close the dog door.
In fact, that’s all the Timer class does: kick off a background Thread.
But the Timer class makes running a task in the future easy, so it seemed like a good choice for the Remote class.
A: Because we need to call its cancel() method in the TimerTask anonymous class.
If you need to access variables in your anonymous class from the enclosing class (that’s Remote in this case), those variables must be final.
Q: Why are you calling cancel()? Won’t the timer quit automatically after running the TimerTask?
A:  It will, but it turns out that most JVMs take forever before they garbage collect the Timer.
That ends up hanging the program, and your code will run for hours before it actually quits gracefully.
That’s no good, but calling cancel() manually takes care of the problem.
The remote already has code to handle closing the door if it’s open.
This checks the state of the door before opening or closing it.
We need a new simulator! Our old simulator isn’t that useful anymore...
Let’s update our simulator to make it work with the updated Remote class:t.
This is the same as in our earlier version, but pressing the button will open the door and start a timer to close the door.
In the new improved dog door, Gina doesn’t need to press a button to close the door.
Here’s another spot where we can get rid of some code...
Since the door’s on a timer, Fido has plenty of time to get back inside before the door closes.
Gina doesn’t need to open the door to let Fido back in.
The point is that our use case helped us write good requirements, and our requirements made it easy to figure out how to write a working dog door.
That’s a lot more important than how—or even in what language—you write the dog door code.
Q: So the new simulator tests out the main path we figured out, right?
Flip back to page 78 and review what the dog door does...
We want to make sure that Todd and Gina’s new door works just like they want it to.
Q: Why aren’t we testing out that alternate path we found?
Let’s test this version of the door, and then we’ll talk more about that...
Test drive, version 2.0 It’s time to see if  all our hard work is going to pay off.
A few seconds will pass between when the door opens...
But I don’t think we’re ready to show Todd and Gina yet...
Wouldn’t it be great if  things worked just like you expected them to every time? Of  course, in the real world, that almost never happens.
Before we can show the new door off  to Todd and Gina, let’s take a little extra time to make sure the door works when Fido doesn’t come right back inside after doing his business.
How would you change the DogDoorSimulator class to test for Fido staying outside longer?
Can you come up with at least one more alternate path for Todd and Gina’s dog door? Write out the use case and update the requirements list for your new alternate path, too.
Reviewing the alternate path Let’s make sure we understand exactly what happens on the alternate path, and then we can update DogDoorSimulator to test the new path out.
Here’s the original main path diagram from page 68, along with the alternate path we figured out and added to our use case:
This part of the diagram is the main path, where everything goes exactly as planned.
Todd or Gina presses the button on the remote control.
Todd or Gina presses the button on the remote control.
Note that when the door opens here, things continue by returning to the main path.
It’s time to update the simulator, but this time it’s your job to actually write some code.
Your job is to match the code magnets at the bottom of the page to where they belong in the simulator.
If you get stuck, check the diagram on the last page to see what’s going on at each step of the way.
These are methods you can call on a Java thread.
The alternate path returns to the main path right here.
We want the program to pause and let the door close automatically.
Now you’re ready to test out the alternate path of  your use case:
The door opens, and Fido goes outside to do his business.
Fido barks to get back inside, and Gina uses her remote control...
Code Magnets Solution Here’s what we did to complete the simulator.
Make sure you got the same answers that we did.
You should have written in periods, semicolons, and parentheses as you needed them.; ;
Delivering the new dog door Good use cases, requirements, main paths, alternate paths, and a working simulator; we’re definitely on the road to great software.
Let’s take the new dog door to Todd and Gina.
This dog door rocks! We don’t have to get out of bed to let.
Fido out anymore, and the door closes on its own.
Todd and Gina’s nights are uninterrupted now, which makes them satisfied customers.
Fido’s inside, and the rabbits, woodchucks, and mice are outside.
Not only did we turn Todd and Gina into satisfied customers, we made sure their door worked when Fido did something they didn’t expect—like stay outside playing.
Well, in any case, it’s great to have you with us today, Happy Path, and you’re right on time, too.
Happy Path: Well, it’s just part of  who I am.
HeadFirst: And that’s how you got your name? You make people happy by always being on time and never making a mistake?
They call me “Happy Path” because when you’re hanging out with me, everything goes just as you’d hope.
Nothing ever goes wrong when the “Happy Path” is at the wheel.
HeadFirst: I have to admit, I’m still a bit amazed that nothing ever goes wrong around you.
My job is to take care of  things when the sun is shining and things are going just like people expect.
HeadFirst: Do you ever feel like Alternate Path is butting in? I could imagine some tension there...
Next week, we’ll try and catch up with Alternate Path, and get her side of  the story.
Until then, try and stay on the Happy Path, but remember to plan for problems!
Below on the left are some of  the new terms you’ve learned in this chapter.
On the right are descriptions of  what those terms mean and how they’re used.
Your job is to match the term on the left with that term’s purpose on the right.
Kicks off the list of steps described in a use case.
Something a system needs to do to be a success.
This is usually what customers describe when they’re talking about the system.
This is always the first step in the use case.
Without this, a use case isn’t worth anything to anyone.
You’ve got to use the definitions on the right to match to a term, and fill in the missing part of the term.
Below on the left are some of  the new terms you’ve learned in this chapter.
On the right are descriptions of  what those terms mean, and how they’re used.
Your job is to match the term on the left with what that term’s purpose is on the right.
Kicks off the list of steps described in a use case.
Something a system has to do to be a success.
This is usually what customers describe when they’re talking about the system.
This is always the first step in the use case.
Without this, a use case isn’t worth anything to anyone.
Make sure you filled in all the blanks exactly like we did.
Below are three more potential customers that are interested in Doug’s Dog Doors.
For each customer, your job is to write a use case to solve the customer’s problem.
Bitsie is constantly nudging open our back door, or nosing open the kitchen bay windows.
Bruce is constantly barking, so I never know if he really wants out or not.
Doug’s Dog Doors is partnering with the local security company to handle their growing customer base, and requests like this one.
You’ve seen the customers; now let’s look at the use cases.
Kristen’s use case is just two steps: she enters a code, and then the dog door and the windows lock.
Even though this is a dog door, Bitsie actually has no effect on how the system behaves! Tex is constantly tracking.
I want a dog door that automatically closes every time he goes outside, and stays closed until I press a button to let.
Bitsie is constantly nudging open our back door, or nosing open the.
I want a system that locks my dog door and windows behind me every time I enter a code, so Bitsie.
John’s request turns out to be very similar to what Todd and Gina wanted.
Part of gathering good requirements is recognizing when you’ve already built something similar to what a customer wants.
Some of this really wasn’t laid out in what Holly said, but you should have figured it out when you thought through how her system will be used.
Even though John said Tex usually gets muddy, he doesn’t have to get muddy...
We really need more information to write this use case...
Bruce is constantly barking, so I never know if he really wants out or not.
More Use Case Magnets Remember the three parts of a use case? It’s time to put what you’ve learned into action.
On these pages, you’ll find several use cases; your job is to match the use case magnets on the bottom of the page to the correct parts of each use case.
Use these magnets to indicate the clear value of a use case.
This magnet indicates the start condition for a use case.
You can review all of these by flipping back to page 74.Bruce scratches at the dog door to be let out.
Bruce goes to the bathroom, and then scratches at the door again.
If Bruce scratches at the door but stays inside (or stays outside), he can scratch at the door again to re-open it, from inside or outside.
You should be able to follow these alternate use case formats without much trouble.
If you get confused, check out Appendix I for the scoop on alternate use case formats.
Use this magnet for the stop condition of a use case.
How do you know when the use case is finished?
Fido here represents the external initiator of a use case, which kicks things off.
Goal: Tex uses the bathroom and comes back inside, without getting mud inside the house.
Bruce scratches at the dog door to be let out.
Bruce goes to the bathroom, and then scratches at the door again.
If Bruce scratches at the door but stays inside (or stays outside), he can scratch at the door again to re-open it, from inside or outside.
The start condition and external initiator are usually both part of the first step of a use case.
The stop condition is almost always the last step in the use case.
Look closely for the stop condition in this style of use cases; it’s usually not the last sentence if there are any alternate paths.
Bruce can get outside to use the bathroom without Holly having to open and close the dog door (or even listen for Bruce to bark)
The clear value of a use case-in most formatsisn’t stated in the use case, so you’ll need to figure it out on your own.
Goal: Tex uses the bathroom and comes back inside, without getting mud inside the house.
In this use case format, the external initiator is always the primary actor.
Anytime the goal of a use case is explicitly stated, you’ve got your clear value.
Look for the last step in the main path, not the last step of the extensions.
You’ve already seen how use cases help you build a complete requirements list.
Your job is to figure out if the requirements list next to each use case covers everything, or if you need to add in additional requirements.
The keypad must be able to lock the dog door.
Is anything missing or incomplete based on the use case? If so, write in the extra requirements you think the door needs to handle.
The door should be able to open on a command (from #1)
Is anything missing? It’s up to you to make sure Holly is a satisfied customer.
Holly is psyched about life with her new dog door.
In each situation below, the use case describes how the dog door should work-but the requirements aren’t complete.
Here are the things we saw that were missing from the requirement list, based on the ever-helpful use case.
The keypad must be able to lock the dog door and all the windows.
The keypad must be able to unlock the dog door and all the windows in the house.
Kristen wants to be able to lock the doors and windows.
Kristen wouldn’t be too happy if she couldn’t unlock everything, would she?
Be careful! Good use cases make for good requirements, but a bad-or incomplete-use case can result in BAD requirements!
The door should be able to open on a command (from #1)
This is one of the same requirements as for Todd and Gina’s dog door.
Requirements are things your system must do to work correctly.
To make sure you have a good set of requirements, you should develop use cases for your system.
A use case has a single goal, but can have multiple paths to reach that goal.
A good use case has a starting and stopping condition, an external initiator, and clear value to the user.
A use case is simply a story about how your system works.
You will have at least one use case for each goal that your system must accomplish.
After your use cases are complete, you can refine and add to your requirements.
A requirements list that makes all your use cases possible is a good set of requirements.
Your system must work in the real world, not just when everything goes as you expect it to.
When things go wrong, your system must have alternate paths to reach the system’s goals.
In this chapter, you learned several tools for making sure your customers are smiling when you show them the systems you’ve built.
Good requirements ensure your system works like your customers expect.
Make sure your requirements cover all the steps in the use cases for your system.
Use your use cases to find out about things your customers forgot to tell you.
Your use cases will reveal any incomplete or missing requirements that you might have to add to your system.
Here are some of the key tools you learned about in this chapter.
We’ll be adding lots more tools to these other categories* in the coming chapters.
Code Magnets Solutions The DogDoor class is done, so all you need now is to write a class for the remote control.
We’ve started this class below, but it’s your job to finish things up.
Using the code magnets at the bottom of the page, complete the code for the Remote class.
Think you’ve got just what the customer wanted? Not so fast...
So you’ve talked to your customer, gathered requirements, written out your use cases, and delivered a killer application.
They love what you’ve done, really, but it’s not quite good enough.
In the real world, requirements are always changing, and it’s.
What in the world was I thinking? I just found out he doesn’t even like NASCAR.
You: But there must be a problem, right? Is the door not closing quickly enough? Is the button on the remote not functioning?
You: Is Fido not barking to be let out anymore? Oh, have you checked the batteries in the remote?
Todd and Gina: No, we swear, the door is great.
We just have a few ideas about some changes we’d like you to make...
You: But if  everything is working, then what’s the problem?
Tired of  cleaning up your dog’s mistakes? Ready for someone else to let your dog outside? Sick of  dog doors that stick when you open them?
We’re both tired of having to listen for Fido all the time.
Sometimes, we don’t even hear him barking, and he pees inside.
And we’re constantly losing that remote, or leaving it in.
What if the dog door opened automatically when Fido barked at it? Then, we wouldn’t have to do anything to let him.
And now, just because they had some new idea, we have to make more.
Even when requirements change, you’ve got to be ready to update your application and make sure it works like your customers expect.
When your customer has a new need, it’s up to you to change your applications to meet those new needs.
Back to the drawing board Time to get working on fixing up Todd and Gina’s dog door again.
We need to figure out a way to open the door whenever Fido barks.
You’ve just discovered the one constant in software analysis and design.
Doug loves it when this happens, since he gets to charge Todd and Gina for the changes you make.
Okay, what’s the one thing you can always count on in writing software?
No matter where you work, what you’re building, or what language you are programming in, what’s the one true constant that will always be with you?
Write down some reasons that the requirements might change in the applications you currently are working on.
My customer decided that they wanted the application to work differently.
My boss thinks my application would be better as a web application than a desktop app.
If you’ve read Head First Design Patterns, this page might look a bit familiar.
They did such a good job describing change that we decided to just rip off their ideas, and just CHANGE a few things here and there.
If you’ve got good use cases, though, you can usually change your software quickly to adjust to those new requirements.
Update the diagram, and add an alternate path where Fido barks, Doug’s new bark recognizer hears Fido, and the dog door automatically opens.
The remote control should still work, too, so don’t remove anything from the diagram; just add another path where Fido’s barking opens the door.
Todd or Gina presses the button on the remote control.
Todd or Gina presses the button on the remote control.
Doug’s invented hardware to recognize barks, but it’s up to you to figure out how to use his new hardware in the dog door system.
Here’s how we solved Todd and Gina’s problem, and implemented their bark-recognizing dog door.
We need to add a handy-dandy bark recognizer to the dog door.
The bark recognizer sends a request to the door to open.
We also need a couple of alternate steps here, too.
Since these steps are already on an alternate path, we need two substep numbers.
Todd or Gina presses the button on the remote control.
The bark recognizer sends a request to the door to open.
These are listed as substeps, but they really are providing a completely different path through the use case.
These sub-steps provide an additional set of steps that can be followed...
Todd or Gina presses the button on the remote control.
The bark recognizer sends a request to the door to open.
Use cases have to make sense to you If  a use case is confusing to you, you can simply rewrite it.
There are tons of different ways that people write use cases, but the important thing is that it makes sense to you, your team, and the people you have to explain it to.
So let’s rewrite the use case from page 121 so it’s not so confusing.
Todd or Gina presses the button on the remote control.
Todd or Gina presses the button on the remote control.
The bark recognizer sends a request to the door to open.
The bark recognizer sends a request to the door to open.
Now we’ve added a label to tell us that these steps on the left are part of the main path.
We’ve moved the steps that can occur instead of the steps on the main path over here to the right.
When there’s only a single step, we’ll always use that step when we go through the use case.
But they’re still on the left, because they don’t replace steps on the main path.
You can only take one step to work through the use case:either the step on the left, OR the step on the right.
No matter how you work through this use case, you’ll always end up at Step 8 on the main path.
Todd or Gina presses the button on the remote control.
If we can really write the use case however we want, can we make the.
The main path should be what you want to have happen most of  the time.
Since Todd and Gina probably want the bark recognizer to handle Fido more than they want to use the remote, let’s put those steps on the main path:
Now the steps that involve the bark recognizer are on the main path, instead of an alternate path.
Todd and Gina won’t use the remote most of the time, so the steps related to the remote are better as an alternate path.
Start to finish: a single scenario With all the alternate paths in the new use case, there are lots of different ways to get Fido outside to use the bathroom, and then back in again.
Todd or Gina presses the button on the remote control.
You’ll always end up at Step 8, with Fido back inside.
We’re letting Todd and Gina handle opening the door again, on the alternate path.
Let’s take this alternate path, and let Todd and Gina handle opening the door with the remote.
Following the arrows gives you a particular path through the use case.
There are usually several possible scenarios in a single use case.
We’ll take the optional sub-path here, where Fido gets stuck outside.
Most use cases have several different scenarios, but they always share the same user goal.
Q: I understand the main path of a use case, but can you explain what an alternate path is again?
A: An alternate path is one or more steps that a use case has that are optional, or provide alternate ways to work through the use case.
Alternate paths can be additional steps added to the main path, or provide steps that allow you to get to the goal in a totally different way than parts of the main path.
Q: So when Fido goes outside and gets stuck, that’s part of an alternate path, right?
Those are additional steps that the system may go through, and are needed only when Fido gets stuck outside.
Because an alternate path that has additional steps is just a set of steps that can occur as part of another step on the use case’s main path.
Q: So what do you call it when you have two different paths through part of a use case?
A: Well, that’s actually just another kind of alternate path.
When Fido barks, there’s one path that involves Todd and Gina hearing Fido and opening the door, and another path that involves the bark recognizer hearing a bark and opening the door.
But the system is designed for one or the other—either the remote opens the door, or the bark recognizer does—not both.
Q: Can you have more than one alternate path in the same use case?
You can have alternate paths that provide additional steps, and multiple ways to get from the starting condition to the ending condition.
You can even have an alternate path that ends the use case early...
A complete path through a use case, from the first step to the last, is called a scenario.
I mean, you can hardly put together a decent use case without me, but I still seem to get ignored all the time.
HeadFirst: Ignored? But you just said you’re part of  almost every use case.
But even when I’m part of  a use case, I can get skipped over for some other set of  steps.
Alternate Path: Just the other day, I was part of  a use case for buying a CD at this great new online store, Musicology.
HeadFirst: Well, that sounds like a really important job! So what’s the problem?
Alternate Path: Well, yeah, I guess it’s important, but I always get passed over.
It seems like everyone was ordering CDs, but their credit cards were all getting accepted.
Even though I was part of the use case, I wasn’t part of the most common scenarios.
So unless someone’s credit card was rejected, you were never involved.
But you’re still helping the use case, right? Even if  you’re not used all the time, you’re bound to get called on once in a while.
Alternate Path: That’s true; we all do have the same goal.
I just didn’t realize that I could be important to the use case and still hardly ever get noticed.
Of  course, they’re part of  the alternate path for when customers already have an account on the system, so they get used constantly.
We know you’re an important part of  the use case!
How many scenarios are in Todd and Gina’s use case?
How many different ways can you work your way through Todd and Gina’s use case? Remember, sometimes you have to take one of multiple alternate paths, and sometimes you can skip an alternate path altogether.
We’ve written out the steps we followed for the scenario highlighted above to help get you started.
Todd or Gina presses the button on the remote control.
How many scenarios are in Todd and Gina’s use case?
How many different ways can you work your way through Todd and Gina’s use case? Remember, sometimes you have to take one of multiple alternate paths, and sometimes you can skip an alternate path altogether.
These two don’t take the optional alternate path where Fido gets stuck outside.
Todd or Gina presses the button on the remote control.
Now that our use case is finished up, and we’ve figured out all the possible scenarios for using the dog door, we’re ready to write code to handle Todd and Gina’s new requirements.
I think we should recheck our requirements list against the new use case.
If Todd and Gina’s requirements changed, then our requirements list.
Remember, the whole point of  a good use case is to get good requirements.
If your use case changes, that may mean that your requirements change, too.
Let’s review the requirements and see if  we need to add anything to them.
Any time you change your use case, you need to go back and check your requirements.
Once the dog door has opened, it should close automatically if the door isn’t already closed.
The bark recognizer sends a request to the door to open.
The bark recognizer sends a request to the door to open.
Todd or Gina presses the button on the remote control.
Todd or Gina presses the button on the remote control.
Finishing up the requirements list So we need to handle the two new alternate paths by adding a couple extra requirements to our requirements list.
We’ve gone ahead and crossed off  the steps that our requirements already handle, and it looks like we need a few additions to our requirements list:
Once the dog door has opened, it should close automatically if the door isn’t already closed.
A bark recognizer must be able to tell when a dog is barking.
The bark recognizer must open the dog door when it hears barking.
There are really two requirements here: “hearing” dogs bark, and then opening the dog door.
Here are the two new requirements we need to add to our list.
Remember, these steps on the alternate path were part of the use case’s main path in the last chapter...
Now we can start coding the dog door again With new requirements comes new code.
We need some barking, a bark recognizer to listen for barking, and then a dog door to open up:
Remember, Fido is outside the system, so we don’t need an object for him.
We still need to write the code for the bark recognizer.
This is the method in our software that we want to have called every time Doug’s hardware hears a bark.
Just like the bark recognizer, there’s hardware and software in the dog door: the door itself and your code.
Even though we’re still working on getting the software to do what the customer wants, this is a good indication that your design is solid.
Was that a “woof” I heard? We need some software to run when Doug’s hardware “hears” a bark.
Let’s create a BarkRecognizer class, and write a method that we can use to respond to barks:
We’ll store the dog door that this bark recognizer is attached to in this member variable.
The BarkRecognizer needs to know which door it will open.
Every time the hardware hears a bark, it will call this method with the sound of the bark it heard.
All we need to do is output a message letting the system know we heard a bark...
Q: That’s it? It sure seems like the BarkRecognizer doesn’t do very much.
Since the requirements are simple—when a dog barks, open the door—your code is pretty simple, too.
Any time the hardware hears a bark, it calls recognize() in our new BarkRecognizer class, and we open the dog door.
Remember, keep things as simple as you can; there’s no need to add complexity if you don’t need it.
Q: But what happens if a dog other than Fido is barking? Shouldn’t the BarkRecognizer make sure it’s Fido that is barking before opening the dog door?
A: Very interesting question! The BarkRecognizer hears all barks, but we really don’t want it to open the door for just any dog, do we? We may have to come back and fix this later.
Maybe you should think some more about this while we’re testing things out.
I think with this new class, we’ve got everything we need.
Let’s test out the BarkRecognizer and see if we can make.
First, let’s make sure we’ve taken care of Todd and Gina’s new requirements for their door:
For now, we can use the simulator to get a bark to the recognizer, and test the software we wrote.
Once the dog door has opened, it should close automatically if the door isn’t already closed.
A bark recognizer must be able to tell when a dog is barking.
The bark recognizer must open the dog door when it hears barking.
Power up the new dog door Use cases, requirements, and code have all led up to this.
Create the BarkRecognizer, connect it to the door, and let it listen for some barking.
We don’t have real hardware, so we’ll just simulate the hardware hearing a bark.*
Notice that Todd and Gina never press a button on the remote this time around.
The authors of this book sincerely wanted to include hardware that could hear dogs barking...
Here’s where our new BarkRecognizer software gets to go into action.
We test the process when Fido’s outside, just to make sure everything works like it should.
Can you figure out which scenario from the use case we’re testing? Write down the steps this simulator follows (flip back to page 123 to see the use case again):
Run the code and watch the humanless dog door go into action.3
There’s a big problem with our code, and it shows up in the simulator.
Can you figure out what the problem is? What would you do to fix it?
In our new version of the dog door, the door doesn’t automatically close!
In the scenarios where Todd and Gina press the button on the remote control, here’s the code that runs:
When Todd and Gina press the button on the remote, this code also sets up a timer to close the door automatically.
Did you figure out which scenario from the use case we’re testing? Here are the steps from the use case on page 123 that we followed:
Did you figure out what was wrong with our latest version of the dog door?
Remember, this timer waits 5 seconds, and the sends a request to the dog door to close itself.
But in BarkRecognizer, we open the door, and never close it:
BarkRecognizer like you did in the remote control, and get things.
Doug, owner of Doug’s Dog Doors, decides that he knows exactly what you should do.
I don’t want to put the same code in the remote and in the bark recognizer.
Well, closing the door is really something that the door should.
But where should the code that closes the door go?
Since Gina never wants the dog door left open, the dog door should always close automatically.
So we can move the code to close the door automatically into the DogDoor class.
Then, no matter what opens the door, it will always close itself.
Let’s have the dog door close automatically all the time.
Updating the dog door Let’s take the code that closed the door from the Remote class, and put it into our DogDoor code:
Simplifying the remote control You’ll need to take this same code out of  Remote now, since the dog door handles automatically closing itself:
This is the same code that used to be in Remote.java.
A final test drive You’ve made a lot of  changes to Todd and Gina’s dog door since they first called you up.
Make the changes to Remote.java and DogDoor.java so that the door closes itself, compile all your classes again, and run the simulator:
What would happen if Todd and Gina decided they wanted the door to stay open longer? Or to close more quickly? See if you can think of a way to change the DogDoor so that the amount of time that passes before the door automatically closes can be set by the customer.
Sometimes a change in requirements reveals problems with your system that you didn’t even know were there.
Change is constant, and your system should always improve every time you work on it.
You’ve used an important design principle in this chapter related to duplicating code, and the dog door closing itself.
Try and summarize the design principle that you think you’ve learned:
You won’t find an answer to this puzzle in the chapter, but we’re going to come back to this a little later.
Review what you’ve learned on this page, and then get ready to put it all to use in the OOA&D.
Good requirements ensure your system works like your customers expect.
Make sure your requirements cover all the steps in the use cases for your system.
Use your use cases to find out about things your customers forgot to tell you.
Your use cases will reveal any incomplete or missing requirements that you might have to add to your system.
There was just one new requirement principle you learned, but it’s an important one!
When requirements change, your system has to evolve to handle the new requirements.
When your system needs to work in a new or different way, begin by updating your use case.
A scenario is a single path through a use case, from start to finish.
A single use case can have multiple scenarios, as long as each scenario has the same customer goal.
Alternate paths can be steps that occur only some of the time, or provide completely different paths through parts of a use case.
It’s a maintenance nightmare, and usually points to problems in how you’ve designed your system.
Make sure you’ve gotten all the key concepts in this chapter by working this crossword.
Your application has to do more than work on your own personal.
The version of  the dog door you just developed in Chapter 3 is selling like crazy...
But now that you’ve got it installed at my house, it opens up every time the neighbors’
That’s not what I wanted when I bought this thing!
Your software has a context So far, we’ve worked on writing software in a vacuum, and haven’t really thought much about the context that our software is running in.
In other words, we’ve been thinking about our software like this:
But our software has to work in the real world, not just in a perfect world.
That means we have to think about our software in a different context:
The key to making sure things work and that the real world doesn’t screw up your application is analysis: figuring out potential problems, and then solving those problems—before you release your app out into the real world.
In the perfect world, everyone uses our software just like we expect them to.
Everyone is relaxed, and there are no multi-dog neighborhoods here.
In the real world, there are dogs, cats, rodents, and a host of other problems, all set to screw up your software.
In this context, things go wrong a lot more often.
Identify the problem The first step in good analysis is figuring out potential problems.
We already know that there’s a problem when there are multiple dogs in the same neighborhood:
Holly can use her remote control to open the door...
The bark recognizer hears Bruce and opens the door, which is just what Holly wants.
We already have classes for all the parts of the system that we need.
Plan a solution It looks like there’s a change we need to make in what our system does.
Do you know what it is? Below is a part of  the diagram detailing how the dog door system works:
The bark recognizer “hears” a bark 5 Bruce goes outside.
The remote is part of the alternate path in the latest version of the dog door.
The bark recognizer sends a request to the door to open.
It’s your job to figure out how you would fix the dog door.
Write down what you think you need to change, and then mark your changes on the diagram above.
The bark recognizer is part of the main path, and it’s letting in all dogs, not just the owner’s dog.
The bark recognizer “hears” a bark 5 Bruce goes outside.
The bark recognizer sends a request to the door to open.
If it’s Bruce barking, send a request to the door to open.
In step 3, the bark recognizer needs to evaluate the bark it hears and see if it’s Bruce, or some other dog.
If the bark is Bruce’s, the bark recognizer can send an open request to the dog door.
A: No, as long as your solution kept all the dogs except for Bruce from going in and out of the dog door.
That’s what makes talking about software so tricky: there’s usually more than one way to solve a problem, and there’s not always just one “right” solution.
Q: In my solution, I turned step 3 of the original use case into two steps, instead of just replacing the existing step.
Just as there is usually more than one solution to a problem, there is usually more than one way to write that solution in a use case.
If you use more than one step, but have the scenario with other dogs barking handled, then you’ve got a working use case.
Q: So these use cases really aren’t that precise, are they?
If your use case doesn’t detail exactly what your system is supposed to do, then you could miss an important requirement or two and end up with unhappy customers.
But, use cases don’t have to be very formal; in other words, your use case may not look like ours, and ours might not look like anyone else’s.
The important thing is that your use case makes sense to you, and that you can explain it to your co-workers, boss, and customers.
Write your use cases in a way that makes sense to you, your boss, and your customers.
Analysis and your use cases let you show customers, managers, and other developers how your system works in a real world context.
Update your use case Since we’ve changed our dog door diagram, we need to go back to the dog door use case, and update it with the new steps we’ve figured out.
Then, over the next few pages, we’ll figure out what changes we need to make to our code.
If it’s the owner’s dog barking, the bark recognizer sends a request to the door to open.
We’ve removed all the references to specific owners and dogs, so now this use case will work for all of Doug’s customers.
Instead of Todd and Gina, or Holly, let’s just use “The owner.”
Here is the updated step that deals with only allowing the owner’s dog in and out the door.
Don’t we need to store the owner’s dog’s bark in our dog door? Otherwise, we won’t have anything to compare to the bark that our.
Our analysis has made us realize we need to make some changes to our use caseand those changes mean that we need to make some additions to our system, too.
If  we’re comparing a bark from our bark recognizer to the owner’s dog’s bark, then we actually need to store the owner’s dog’s bark somewhere.
We need a new use case to store the owner’s dog’s bark.
You need a use case to store the owner’s dog’s bark; let’s store the sound of the dog in the dog door itself (Doug’s hardware guys tell us that’s no problem for their door technology)
Use the use case template below to write a new use case for this task.
You should need only two steps for this use case, and there aren’t any alternate paths to worry about.
Since this is our second use case, let’s label it according to what it describes.
You need a use case to store the owner’s dog’s bark; let’s store the sound of the dog in the dog door itself (Doug’s hardware guys tell us that’s no problem for their door technology)
Use the use case template below to write a new use case for this task.
We don’t need to know the exact details of this, since it’s a hardware issue.
Q: Do we really need a whole new use case for storing the owner’s dog’s bark?
The user goal for our original use case was to get a dog outside and back in without using the bathroom in the house, and the user goal of this new use case is to store a dog’s bark.
Since those aren’t the same user goal, you need two different use cases.
Q: Is this really the result of good analysis, or just something we should have thought about in the last two chapters?
Sure, we probably should have figured out that we needed to store the owner’s dog’s bark much earlier, but that’s what analysis is really about: making sure that you didn’t forget anything that will help your software work in a real world context.
A: That’s a good question, and it’s one you’re going to have to answer next...
Add any new objects you think you might need for the new dog door.
Add a new method to the DogDoor class that will store a dog’s bark, and another new method to allow other classes to access the bark.
If  you need to make changes to any other classes or methods, write in those changes in the class diagram below.
Add notes to the class diagram to remind you what any tricky attributes or operations are used for, and how they should work.
We used class diagrams back in Chapter 1; they show the basic code-level constructs in your app.
Remember, these are the attributes of your class, which usually match up with the class’s member variables...
Remember, Doug’s hardware sends the sound of the current dog’s bark to this method.
In fact, Randy and Sam, two developers who Doug’s Dog Doors just hired, both have some pretty good ideas.
But there’s more at stake here than just programmer pride—Doug’s offered the programmer with the best design a sparkling new Apple MacBook Pro!
Randy: simple is best, right? Randy doesn’t waste any time with unnecessary code.
Bark sounds are just Strings, so I’ll store a String for.
This handles setting the bark, which was what our new use case focused on.
Other classes can get the owner’s dog’s bark with this method.
Sam: object lover extraordinaire Sam may not be as fast as Randy, but he loves his objects, so he figures that a new class devoted to dog barks is just the ticket:
Sam plans to store the sound of a dog’s Bark as a String in his new Bark class...
Sharpen your pencil Writing code based on a class diagram is a piece of cake.
You’ve already seen that class diagrams give you a lot of information about the attributes and operations of a class.
Your job is to write the code for Sam’s Bark class based on his class diagram.
We’ve written just a bit of the code to help get you started.
Writing code based on a class diagram is a piece of cake.
Your job was to write the code for Sam’s Bark class based on his class diagram.
Just like Randy did, Sam is using a String to store the actual bark sound...
Sam is planning on other classes delegating Bark comparison to the Bark class’s equals() method.
This method makes sure it has another Bark object to compare itself against...
Sam: updating the DogDoor class Since Sam created a new Bark object, he takes a slightly different path than Randy did in updating his version of  the DogDoor class:
Sam’s version of DogDoor stores a Bark object, not just a String sound.
Sam’s get and set operations deal with Bark objects, not Strings.
Comparing barks All that’s left to do is add a comparison of  barks into BarkRecognizer’s recognize() method.
Randy: I’ll just compare two strings When the BarkRecognizer class gets a signal from the hardware that a dog is barking, it also gets the bark, and compares it to what’s stored in the door:
Sam: I’ll delegate bark comparison Sam is using a Bark object, and he lets that object take care of  all the sound comparisons:
The argument sent to recognize() is a String with the dog’s bark.
Sam has the hardware guys make sure he gets sent a Bark object now, not just the String bark sound, like Randy.
Sam’s code lets the bark stored in the DogDoor handle comparisons.
Delegation in Sam’s dog door: an in-depth look Sam is doing something very similar in his Bark and DogDoor classes.
Doug’s hardware hears a dog barking, wraps the sound of the dog’s bark in a new Bark object, and delivers that Bark instance to the recognize() method.
BarkRecognizer gets the owner’s dog’s bark from DogDoor The recognize() method calls getAllowedBark() on the dog door it’s attached to, and retrieves a Bark object representing the owner’s dog’s bark.
Doug’s hardware hears a dog barking, and creates a new Bark object.
The dog door returns the Bark object representing the owner’s dog’s bark.
Can you see if this other Bark that I have matches you? I really don’t know much about what makes Barks the same, but I’ll bet that you do.
It’s up to the Bark object to figure out if two barks are equal.
It really takes one Bark to understand another Bark, you know? So let’s see if we’re really equal.
The power of loosely coupled applications In Chapter 1, we said that delegation helps our applications stay loosely coupled.
That means that your objects are independent of  each other; in other words, changes to one object don’t require you to make a bunch of  changes to other objects.
By delegating comparison of  barks to the Bark object, we abstract the details about what makes two barks the same away from the BarkRecognizer class.
Look again at the code that calls equals() on Bark:
Now suppose that we started storing the sound of  a dog barking as a WAV file in Bark.
We’d need to change the equals() method in the Bark class to do a more advanced comparison of  sounds and account for the WAV files.
But, since the recognize() method delegates bark comparison, no code in BarkRecognizer would have to change.
So with delegation and a loosely coupled application, you can change the implementation of  one object, like Bark, and you won’t have to change all the other objects in your application.
Your objects are shielded from implementation changes in other objects.
The details of how equals() works are shielded away from the recognize() method.
Delegation shields your objects from implementation changes to other objects in your software.
With Randy’s quick solution, and Sam’s more object-oriented one, let’s see how their applications are working out:
Sam’s code uses objects and delegation to get the job done.
Randy AND Sam: It works! Both Randy and Sam ended up with a working dog door that let in only the owner’s dog.
We both got it right? So who won the laptop?
Remember, Randy’s bark is a String, and Sam’s is an object.
Maria won the MacBook Pro! To both Randy and Sam’s surprise, Doug announces that Maria, a junior programmer he got to work for the company as a summer intern, has won the laptop.
My solution worked! That laptop is mine, not some intern’s!
Didn’t you read Head First Java? An object-oriented solution is the way to go...
Maria:  Umm, guys, I don’t mean to interrupt, but I’m not sure either one of  your dog doors really worked.
Maria:  But did you do any analysis on your solution? Does your door truly work in the real world?
Randy:  What are you talking about? Are you some sort of philosophy major? Is this like a “there is no spoon” sort of thing?
That’s, ummm, sort of  how things work in the real world, isn’t it?
Randy and Sam:  I guess we hadn’t thought about that...
Bruce is a complex, sensitive animal that communicates through the subleties of bark-ese, using inflection and enunciation to get his point across.
So what did Maria do differently? Maria started out a lot like Sam did.
She created a Bark object to represent the bark of  a dog.
But Maria went even further: she decided that since a dog might have different barks, the dog door should store multiple Bark objects.
That way, no matter how the owner’s dog barks, it still gets outside:
She decided that the dog door should store more than just one bark, since the owner’s dog can bark in different ways.
Maria knew she’d need delegation via the equals() method, just as Sam did.
And this asterisk means that allowedBarks can hold an unlimited number of Bark objects.
Anytime you see brackets, it indicates the multiplicity of an attribute: how many of a certain type that the attribute can hold.
If it’s the owner’s dog barking, the bark recognizer sends a request to the door to open.
If it’s the owner’s dog barking, the bark recognizer sends a request to the door to open.
How in the world did you know to store multiple barks? I never would have thought about a dog.
Randy’s not thrilled he lost either, but figures Maria might be his ticket to winning the next programming contest.
It’s the dog that is the focus here, not just a specific bark.
We’re focusing on our main use case here, not the new one we developed earlier in this chapter.
Pay attention to the nouns in your use case Maria’s figured out something really important: the nouns in a use case are usually the classes you need to write and focus on in your system.
If it’s the owner’s dog barking, the bark recognizer sends a request to the door to open.
If it’s the owner’s dog barking, the bark recognizer sends a request to the door to open.
Your job is to circle each noun (that’s a person, place, or thing) in the use case below.
Then, in the blanks at the bottom of the page, list all the nouns that you found (just write each one a single time; don’t duplicate any nouns)
Be sure to do this exercise before turning the page!
Write the nouns that you circled in the use case in these blanks.
If it’s the owner’s dog barking, the bark recognizer sends a request to the door to open.
If it’s the owner’s dog barking, the bark recognizer sends a request to the door to open.
Your job was to circle each noun (that’s a person, place, or thing) in the use case below.
Here are all the nouns we circled in the use case.
Sam: But you don’t need a class for some of  those nouns, like “the owner” or “request,” or even “inside.”
Remember, you need classes only for the parts of  the system you have to represent.
Randy:  And you don’t need a class for “the button” because it’s part of  the remote control—and we already do have a class for that.
What does that have to do with the use case?
Looking at the nouns (and verbs) in your use case to figure out classes and methods is called textual analysis.
It’s all about the use case Take a close look at Step 3 in the use case, and see exactly which classes are being used:
If it’s the owner’s dog barking, the bark recognizer sends a request to the door to open.
This request-another noun without a class-is actually represented by the bark recognizer calling the open() method on the dog door.
There is no Bark class here! The classes in use here in Step 3 are BarkRecognizer and DogDoor...
What if I happened to use just a slightly different.
If the owner’s dog’s bark matches the bark heard by the bark recognizer, the dog door should open.
Here’s Step 3 from the use case that Randy wrote for his dog door.
Does it describe a system that works exactly the same as the system on page 170?
If it’s the owner’s dog barking, the bark recognizer sends a request to the door to open.
If the owner’s dog’s bark matches the bark heard by the bark recognizer, the dog door should open.
Here’s our Step 3, from the original use case we wrote bac.
And here’s Step 3 from the use case that Randy came up with for the same dog door.
Focus: owner’s dog Our original Step 3 focuses on the owner’s dog...
So if  the owner’s dog barks with a loud “Rowlf !” one day, but a quiet “ruff ” the next, the system will let the dog in, either way.
That’s because we’re focusing on the dog, not a particular bark.
Focus: owner’s dog’s bark Randy’s use case focuses on the owner’s dog’s bark...
With a poorly written Step 3, only one of Bruce’s barks will get him in and out of the dog door.
A good use case clearly and accurately explains what a system does, in language that’s easily understood.
Q: So you’re telling me as long as I write use cases, all my software will work like it should?
A: Well, use cases are certainly a good start towards writing good software.
Remember, analysis helps you figure out the classes from your use case, and in the next chapter, we’ll spend some time talking about good design principles in writing those classes.
Q: I’ve never used use cases before, and I’ve never had any problems.
Are you saying that I have to write use cases to create good software?
There are plenty of programmers who are good at their jobs, and don’t even know what a use case is.
But if you want your software to satisfy the customer more often, and you want your code to work correctly with less rework, then use cases can really help you nail your requirements down...
Q: It seems like this stuff about nouns and analysis is pretty tricky, and I’m not any good at English grammar.
A: You really don’t need to focus too much on grammar.
Just write your use cases in conversational English (or whatever language you speak and write in)
Then figure out what the “things” are in your use case—those are generally the nouns.
For each noun, think about if you need a class to represent it, and you’ve got a good start on a real-world analysis of your system.
Q: But what if I make a mistake like Randy did, and use a noun in my use case when I shouldn’t?
A: Randy’s mistake—using “bark” as a noun in step 3 of his use case—had nothing to do with Randy’s grammar.
He didn’t think through the use case, and how his system would work in the real world.
Instead of focusing on getting the owner’s dog outside, he was worrying about one specific bark.
When you write your use case, reread it, and make sure that it makes sense to you.
You might even want to let a couple of friends or co-workers read through it, too, and make sure it will work in the real world, not just in a controlled environment.
With a good use case complete, textual analysis is a quick and easy way to figure out the classes in your system.
OK, I see what Randy’s mistake was: he got hung up on a bark, not the owner’s dog.
So what’s the point of all this, if our analysis doesn’t tell.
Textual analysis tells you what to focus on, not just what classes you should create.
Sharpen your pencil Why is there no Dog class? When you picked the nouns out of the use case, one that kept showing up was “the owner’s dog.” But Maria decided not to create a Dog object.
Why not? Below, write down three reasons you think Maria didn’t create a Dog class in her system.
Remember: pay attention to those nouns! Even if  the nouns in your use case don’t get turned into classes in your system, they’re always important to making your system work like it should.
If it’s the owner’s dog barking, the bark recognizer sends a request to the door to open.
The point is that the nouns are what you should focus on.
If you focus on the dog in this step, you’ll figure out that you need to make sure the dog gets in and out of the dog door—whether he has one bark, or multiple barks.
Even though this method gets a single bark, its purpose is to find out which dog barked.
It runs through all the allowed barks in the dog door to see if this bark comes from the owner’s dog.
Pay attention to the nouns in your use case, even when they aren’t classes in your system.
Think about how the classes you do have can support the behavior your use case describes.
It seems like if the nouns in the use case are usually the classes in.
The verbs in your use case are (usually) the methods of the objects in your system.
If it’s the owner’s dog barking, the bark recognizer sends a request to the door to open.
If it’s the owner’s dog barking, the bark recognizer sends a request to the door to open.
The DogDoor class needs to have an open() and close() method to support these verb actions.
Here’s another verb fragment: “presses the button.” Our Remote class has a pressButton() method that matches up perfectly.
Code Magnets It’s time to do some more textual analysis.
Below is the use case for the dog door you’ve been developing.
At the bottom of the page are magnets for most of the classes and methods we’ve got in our system so far.
Your job is to match the class magnets up with the nouns in the use case, and the method magnets up with the verbs in the use case.
See how closely the methods line up with the verbs.
If it’s the owner’s dog barking, the bark recognizer sends a request to the door to open.
There are lots of classes and methods at this point, so take your time.
Code Magnets Solutions It’s time to do some more textual analysis.
Below is the use case for the dog door you’ve been developing.
At the bottom of the page are magnets for most of the classes and methods we’ve got in our system so far.
Your job is to match the class magnets up with the nouns in the use case, and the method magnets up with the verbs in the use case.
See how closely the methods line up with the verbs.
If it’s the owner’s dog barking, the bark recognizer sends a request to the door to open.
The use case still makes a lot of sense with the magnets in place! That’s a good sign that our classes and methods are doing exactly what they’re supposed to so that the system will be a success.
Notice that most of these steps without any magnets are things that occur outside of the system and that the system then reacts to.
Q: So the nouns in the use case turn into classes, and the verbs turn into methods?
So even though “the owner” is a candidate for a class, it doesn’t become a class in the actual system.
In the same way, the verbs are candidates for operations.
For example, one verb phrase is “does his business,” but we just couldn’t bear to write a pee() or poop() method.
We hope you’ll agree that we made the right choice! Still, textual analysis is a really good start to figuring out the classes and methods you’ll need in your system.
Q: It looks like the nouns that are outside the system don’t get turned into classes.
The only common exception is when you have to interact with something outside the system—like when there’s some state or behavior that the system needs to work with on a recurring basis.
In the dog door system, for example, we didn’t need a class for the owner because the Remote class took care of all the owner-related activity.
If we ever needed to track owner state, though—like if the owner was asleep or awake—then we might have to create an Owner class.
When you picked the nouns out of the use case, one that kept showing up was “the owner’s dog.” But Maria decided not to create a Dog object.
Why not? Here are three reasons we think Maria made the right choice.
The dog is external to the system, and you usually don’t need to represent things external to the system.
Even if you had a Dog class, it wouldn’t help the rest of the system.
For example, you can’t really “store” a Dog in the dog door; that doesn’t make any sense.
There are times when you might do this, but usually only when you need to interact with those external things.
You’ll often see classes like User or Manager, but these represent roles in a system, or store credit cards or addresses.
You could have a reference to the Dog class in.
Maria’s definitely got some new stuff going on in her class diagram.
Where did the door attribute on the Remote class go?
Remember, the asterisk means that getAllowedBarks() can return multiple Bark objects.
We’ve written a few notes of  our own to get you started.
The Remote class has a reference to the DogDoor class.
Class diagrams dissected There’s a lot more to a class diagram than boxes and text.
Let’s see how some lines and arrows can add a lot more information to your class diagrams.
It means that one class is associated with another class, by reference, extensio.
This line goes from the source class (Remote) to the target class (DogDoor)
This means that the source class, Remote, has an attribute of type DogDoor, the target class.
That means that barks can store an unlimited number of Bark objects.
When you’re using associations to represent attributes, you usually do not write the attribute that the association represents in the class’s attribute section.
That’s why Remote no longer has a door attribute here.
The name of the attribute in the source class is written here, at the target end of the line.
So the Remote class has an attribute called door, of type DogDoor.
It’s how many of the target type is stored in the attribute of the source class.
In this case, the door attribute stores a single DogDoor.
Based on the class diagram above, what types could you use for the allowedBarks attribute in the DogDoor class? Write your ideas below:
So the position of the classes on the diagram doesn’t matter.
BarkRecognizer has an attribute named door, of type DogDoor, that holds a single reference to a DogDoor object.
The line goes from the class with the reference to the class that is the type being referenced.
The Remote class has a reference to the DogDoor class, using an attribute named door.
Based on the class diagram below, what types could you use for the barks member variable in your DogDoor class? Write your ideas in the blank below:
Notice that this diagram, although positioned very differently, has the same classes and associations as this diagram.
Randy: I may have missed creating a Bark class, but my solution wasn’t that bad, and I didn’t waste a bunch of  my time drawing squares and arrows.
Maria: Haven’t you ever heard that a picture is worth a thousand words? Once I had my class diagram, I had a pretty good idea about how my whole system was going to work.
It was just in my head, not drawn out on paper.
Sam: I think I’m starting to come around on this UML thing, Randy.
I mean, once you’ve got the use case, it’s pretty natural to do some analysis, and turn the nouns into classes.
It seems like you wouldn’t have to spend as much time worrying about what should be a class, and what shouldn’t.
Rewriting code takes a lot more time than rewriting a use case or redrawing a class diagram...
Maria: And you know, if  you ever have to work with anyone else, you’re going to have to explain that system in your head to them somehow, right?
I’ve seen your whiteboard when you’re trying to explain your ideas...
I guess I’m still just not sure why you need all these.
Class diagrams aren’t everything Class diagrams are a great way to get an overview of  your system, and show the parts of  your system to co-workers and other programmers.
But there’s still plenty of  things that they don’t show.
Class diagrams don’t tell you how to code your methods.
Class diagrams are great for modeling the classes you need to create, but they don’t provide all the answers you’ll need in programming your system.
You’ve already seen that the dog door class diagram doesn’t tell us much about matching up return types; what other things do you think are unclear from this diagram that you might need to know to program the dog door?
Add notes to the diagram below about what you might need to figure out in order to program the door.
We’ve added a note about comparing barks to get you started.
This method needs to see if the Bark object it receives matches one of the dog barks stored in the dog door.
So how does recognize() work now? Maria’s figured out that her BarkRecognizer class should be able to compare any bark it receives against multiple allowed barks, but her class diagram doesn’t tell us much about how to actually write the recognize() method.
Here’s the recognize() method of her BarkRecognizer, and how she solved the barking problem:
Maria’s getting a whole list of Bark objects from the dog door.
Maria’s textual analysis helped her figure out that her BarkRecognizer needed to focus on the dog involved, rather than the barking of that dog.
This makes sure we don’t keep looping once we’ve found a match.
This method represents an entire dog: all the barking sounds that the dog can make.
Iterator is a Java object that lets us walk through each item in a list.
Just like in Sam’s code, Maria delegates Bark comparisons to the Bark object.
We cast each item we get from the Iterator to a Bark object.
Add notes to the diagram about what you might need to figure out to program the door.
What type is used to store the multiple Bark objects?
These are just a few of the things we thought of.
Your answers may be totally different, if you thought of other things that the class diagram doesn’t really show.
It’s unclear what any of the constructors for these classes might do...
This method needs to see if the Bark object it receives matches the dog stored in the dog door.
DogDoor open: boolean open() close() isOpen(): boolean getAllowedBarks(): Bark [*]
Do open() and close() just change the door’s state, or do they do something else, too?
Analysis helps you ensure that your software works in the real world context, and not just in a perfect environment.
Use cases are meant to be understood by you, your managers, your customers, and other programmers.
You should write your use cases in whatever format makes them most usable to you and the other people who are looking at them.
A good use case precisely lays out what a system does, but does not indicate how the system accomplishes that task.
Each use case should focus on only one customer goal.
If you have multiple goals, you will need to write mutiple use cases.
Class diagrams give you an easy way to show your system and its code constructs at a 10,000-foot view.
The attributes in a class diagram usually map to the member variables of your classes.
The operations in a class diagram usually represent the methods of your classes.
Class diagrams leave lots of detail out, such as class constructors, some type information, and the purpose of operations on your classes.
Textual analysis helps you translate a use case into code-level classes, attributes, and operations.
The nouns of a use case are candidates for classes in your system, and the verbs are candidates for methods on your system’s classes.
So when do we get to see the final version of Maria’s dog door?
You can download this code from the Head First Labs web site if  you want a jump start.
Start coding! First concentrate on getting all of  your classes to compile, so you can begin testing.
Use the DogDoorSimulator class to see if  things are working like they should.
Keep up the analysis and coding until your test class’s output matches the output shown on the next page.
Once you think you’ve got a working dog door, check your code against ours at the Head First Labs web site.
I’ll bet you expected to find all the code I wrote here, didn’t you? I wish...
All we’ve got to go on are the code fragments from her solution in this chapter, her class diagrams, and what you’ve learned about good analysis, requirements and OO programming.
Here’s the output you want, which proves that the door works for Bruce, but not for other dogs.
Lists all the code-level constructs, along with their attributes and operations.
This is the UML term that usually represents a method in one of your classes.
Helps you figure out the candidates for methods on the objects in your system.
Visually shows that one class has a relation to another class, often through an attribute.
Describes how many of a specific type can be stored in an attribute of a class.
You do this to your use case to figure out what classes you need in your system.
Lists all the code-level constructs, along with their attributes and operations.
This is the UML term that usually represents a method in one of your classes.
Helps you figure out the candidates for methods on the objects in your system.
Visually shows that one class has a relation to another class, usually through an attribute.
Describes how many of a specific type can be stored in an attribute of a class.
You do this to your use case to figure out what classes you need in your system.
No matter how much you like your software right now, it’s probably going to change tomorrow.
In fact, we’re going to uncover a problem so big that.
Your software is the best—I’m selling guitars left and right.
I’ve been getting a lot of business from Nashville, though, and want to start carrying mandolins, too.
Rick’s Guitars is expanding Fresh off  the heels of  selling three guitars to the rock group Augustana, Rick’s guitar business is doing better than ever—and the search tool you built Rick back in Chapter 1 is the cornerstone of  his business.
Let’s put our design to the test We’ve talked a lot about good analysis and design being the key to software that you can reuse and extend...
Let’s figure out how easy it is to restructure his application so that it supports mandolins.
Guitar serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): GuitarSpec.
It’s up to you to add to this diagram so that Rick can start selling mandolins, and your search tool can help him find mandolins that match his clients’ preferences, just like he already can with guitars.
Notice that we can write these properties on either side of the association...
We’ve moved most of the properties out of the class box and used associations instead.
Guitar serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): GuitarSpec.
Here’s what we did first to add support for mandolins (we’ll make some more changes over the next few pages)
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float)
Almost everything in Guitar gets pushed up to Instrument, and gets inherited.
So we can get rid of lots of these properties, as they get moved into the Instrument base class.
In just a sec, we’ll create a MandolinSpec class for mandolin properties, too.
Looks like we’ve got yet more new UML notation going on here...
Did you notice that abstract base class? Take a close look at the new Instrument class that we created:
Instrument is an abstract class: that means that you can’t create an instance of  Instrument.
You have to define subclasses of  Instrument, like we did with Mandolin and Guitar:
We made Instrument abstract because Instrument is just a placeholder for actual instruments like Guitar and Mandolin.
An abstract class defines some basic behavior, but it’s really the subclasses of  the abstract class that add the implementation of  those behaviors.
Instrument is just a generic class that stands in for your actual implementation classes.
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
We took all the attributes and operations that are common to both Guitar and Mandolin, and put them in Instrument.
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
The abstract class defines behavior, and the subclasses implement that behavior.
Guitar and Mandolin implement the operations defined in Instrument in ways specific to a guitar and mandolin.
We’ll need a MandolinSpec class, too Mandolins and guitars are similar, but there are just a few things different about mandolins...
What do you think about this design? Will it do what the customer wants it to do? How flexible is it? Do you think software designed like this will be easy to extend and maintain?
Mandolins can come in several styles, like an “A” style, or an “F” style mandolin.
Just as we used an enumerated type for Wood and Builder, we can create a new type for mandolin styles.
Q: We made Instrument abstract because we abstracted the properties common to Guitar and Mandolin into it, right?
A: No, we made Instrument abstract because in Rick’s system right now, there’s no such thing as an actual “instrument.” All it does is provide a common place to store properties that exist in both the Guitar and Mandolin classes.
But since an instrument currently has no behavior outside of its subclasses, it’s really just defining common attributes and properties that all instruments need to implement.
So while we did abstract out the properties common to both instrument types, that doesn’t necessarily mean that Instrument has to be abstract.
In fact, we might later make Instrument a concrete class, if that starts to make sense in our design...
Q: Couldn’t we do the same thing with GuitarSpec and MandolinSpec? It looks like they share a lot of common attributes and operations, just like Guitar and Mandolin.
A: Good idea! We can create another abstract base class, called InstrumentSpec, and then have GuitarSpec and MandolinSpec inherit from that base class:
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
The differences between the two types of instruments are encapsulated away in the spec classes.
This is a special type of association we’ll look at on the next page.
Now get() returns an Instrument instead of just a Guitar.
We need two search() methods now: one for guitars and one for mandolins.
We’ve moved all the common spec properties into another abstract class.
We need to override matches() in each spec class to handle additional properties specific to each instrument.
InstrumentSpec is associated with all the enumerated types that we used to reference directly in GuitarSpec.
Whenever you find common behavior in two or more places, look to abstract that behavior into a class, and then reuse that behavior in the common classes.
Here’s the principle that led to us creating both the Instrument and InstrumentSpec abstract base classes.
Now the abstract Instrument class is associated with the abstract InstrumentSpec class.
Class diagrams dissected (again) Now that you’ve added abstract classes, subclasses, and a new kind of association, it’s time to upgrade your UML and class diagram skills.
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
Aggregation is a special form of association, and means that one thing is made up (in part) of another thing.
A line with an arrow that isn’t colored in means generalization.
You use a generalization to show that a class (like Mandolin) extends and inherits behavior from a more generalized class (like Instrument)
When the name of a class is in italics, the class is abstract.
Here, we don’t want anyone creating instances of Instrument; it’s just used to provide a common base for specific instrument classes, like Guitar and Mandolin.
Fold this page down so you can refer back to it when you forget some of UML’s notation and symbols.
Q: Are there lots more types of symbols and notations that I’m going to have to keep up with to use UML?
A: There are a lot more symbols and notations in UML, but it’s up to you how many of them you use, let alone memorize.
Many people use just the basics you’ve already learned, and are perfectly happy (as are their customers and managers)
But other folks like to really get into UML, and use every trick in the UML toolbox.
It’s really up to you; as long as you can communicate your design, you’ve used UML the way it’s intended.
Let’s code Rick’s new search tool We can start off  by creating a new class, Instrument, and making it abstract.
Then we put all the properties common to an instrument in this class:
Most of this is pretty simple, and looks a lot like the old Guitar class we had.
Next we need to rework Guitar.java, and create a class for mandolins.
These both extend Instrument to get the common instrument properties, and then define their own constructors with the right type of  spec class:
Mandolin is almost identical to Guitar; it just takes in a MandolinSpec in the constructor, instead of a GuitarSpec.
We used the aggregation form of association because each Instrument is made up of the serialNumber and price member variables, and an InstrumentSpec instance.
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
All each instrument class needs is to extend Instrument, and provide a constructor that takes the right kind of spec object.
Just like Instrument, InstrumentSpec is abstract, and you’ll use subclasses for each instrument type.
This version of matches() does just what you’d expect: compares all properties in this class to another spec instance.
Create an abstract class for instrument specifications With the instruments taken care of, we can move on to the spec classes.
We need to create another abstract class, InstrumentSpec, since so many instruments have common specifications:
With InstrumentSpec coded up, it’s pretty simple to write the GuitarSpec class:
This constructor just adds the guitar-specific properties to what’s already stored in the base InstrumentSpec class.
Only a guitar has a numStrings property; it’s not in the Instrument superclass.
It’s very similar, with the addition of  a member variable to reference the mandolin’s style (like “A” or “F” style), and a slightly different matches() method:
Only mandolins have a Style, so this is not pushed up into the InstrumentSpec base class.
Just like GuitarSpec, MandolinSpec uses its superclass to do basic comparison, and then casts to MandolinSpec and compares the mandolin-specific properties.
Finishing up Rick’s search tool All that’s left is to update the Inventory class to work with multiple instrument types, instead of  just the Guitar class:
The inventory list now holds multiple types of instruments, not just guitars.
By using the Instrument and InstrumentSpec classes, we can turn addGuitar() into a more generic method, and create any kind of instrument.
Since Instrument is abstract, and we can’t instantiate it directly, we have to do some extra work before creating an instrument.
Here’s another spot where using an abstract base class makes our design more flexible.
At this point, you’re ready to try out Rick’s improved app.
See if you can update FindGuitarTester on your own, and see how things are working with these design changes.
Do we really need a subclass for each type of instrument just for that?
Otherwise, how could you tell a mandolin from a guitar? There’s no other way to figure out what type of instrument you’re working with than by checking the type of the class.
Besides, those subclasses allow us to have constructors that ensure that the right type of spec is passed in.
So you can’t create a Guitar, and pass a MandolinSpec into its constructor.
Q: But with Instrument as an abstract class, the addInstrument() method in Inventory.java becomes a real pain!
A:  You’re talking about addInstrument() on page 212, aren’t you? Yes, with Instrument as an abstract class, you do have some extra code to deal with.
But it’s still a fairly small price to pay to ensure that you can’t create an Instrument, which really doesn’t exist in the real world.
Q: Isn’t there some middle ground, though? I mean, even if there’s no such thing as an “instrument” that isn’t a guitar or mandolin or whatever, it still seems like we must have a design problem somewhere.
It does seem like parts of our code would benefit from a concrete Instrument class, while other parts wouldn’t.
Sometimes this means you have to make a decision one way or the other, and just accept the trade-off.
But maybe there’s more going on here that we’re not thinking about...
Q: Why do we have two different versions of search()? Can’t we combine those into a single method that takes an InstrumentSpec?
A:  Since InstrumentSpec is an abstract class, like Instrument, Rick’s clients will have to give either a GuitarSpec or a MandolinSpec to the search() method in Inventory.
And since a spec will match only other specs of the same instrument type, there’s never a case where both mandolins and guitars would be returned in the list of matching instruments.
So even if you consolidated the two search() methods into one, you wouldn’t get any functionality benefit—and even worse, it might look like the method would return both mandolins and guitars (since the return type of search() would be Instrument [*]), even though it never actually would.
Wow, this is really starting to look pretty good! Using those abstract classes.
So now our job is to take Rick’s betterdesigned application, and see if  we can improve it even further...
Remember the three things we talked about that you can do to write great software? Let’s review them to see how well we’ve done on the latest version of Rick’s search tool.
Does the new search tool do what it’s supposed to do?
Have you used solid OO principles, like encapsulation, to avoid duplicate code and make your software easy to extend?
How easy is it to reuse Rick’s application? Do changes to one part of the app force you to make lots of changes in other parts of the app? Is his software loosely coupled?
Great software every time? I can hardly imagine what that.
Remember the three things we talked about that you can do to write great software? Let’s review them to see how well we’ve done on the latest version of Rick’s search tool.
Does the new search tool do what it’s supposed to do?
Have you used solid OO principles, like encapsulation, to avoid duplicate code and make your software easy to extend?
How easy is it to reuse Rick’s application? Do changes to one part of the app force you to make lots of changes in other parts of the app? Is his software loosely coupled?
It finds guitars and mandolins, although not at the same time.
So maybe it just mostly does what it’s supposed to do.
It’s sort of hard to use just parts of Rick’s application.
Everything’s pretty tightly connected, and InstrumentSpec is actually part of Instrument (remember when we talked about aggregation?)
We used encapsulation when we came up with the InstrumentSpec classes, and inheritance when we developed an Instrument and InstrumentSpec abstract superclass.
But it still takes a lot of work to add new instrument types...
It’s OK if you got some different answers and had different ideas than we did on these questions...
I’m loving what you’re doing to my search tool! As long as you’re here, I think.
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
We’ll have to change Inventory again, and add support for the four new instrument types.
One of the best ways to see if software is well-designed is to try and CHANGE it.
If  your software is hard to change, there’s probably something you can improve about the design.
Let’s see how hard it is to add a couple of  new instruments to Rick’s app:
Every time we need to add a new instrument, we have to add another subclass of  Instrument:
BanjoInstrument serialNumber: String price: double spec: InstrumentSpec getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
When you think about how many instruments Rick could end up selling, a class for each instrument type is a little scary.
Then things start to really get nasty when you have to update the Inventory class’s methods to support the new instrument type:
Remember all that instanceof and if/else stuff in addInstrument()? It gets worse with every new instrument type we support.
The search() situation is getting more annoying with every new instrument type.
We need a new version that deals with banjos now.
So what are we supposed to do now? It looks like we’ve definitely still got some work to do to turn Rick’s application into great software that’s truly easy to change and extend.
Now that we’ve applied some of  our OO principles to Rick’s search tool, we’ve been able to locate some issues that we’re going to have to resolve if  we don’t want to spend.
Before you’re ready to really tackle the next phase of Rick’s app, though, there are a few things you need to know about.
So, without further ado, let’s take a quick break from Rick’s software, and tune in to...
Hello, and welcome to OO CATASTROPHE, Objectville’s favorite quiz show.
We’ve got quite an array of OO answers tonight, I hope you’ve.
A: It might not seem like it, but we are working on Rick’s search tool, in a manner of speaking.
We’re going to need some pretty advanced OO techniques to make his application flexible and reusable, and we wanted to give you a chance to get a handle on these principles before you had to start applying them to a pretty complicated problem.
Q: Why are we playing a game show? Shouldn’t we be fixing Rick’s search tool?
A: The questions that match up with the answers in this chapter aren’t easy, but you should be able to reason them all out.
Take your time; it’s important that you come up with these questions on your own if at all possible, and only then turn the page to get a little more information on each question and the OO principle it involves.
Besides, we think you’re getting to be a pretty kick-ass developer, so we have lots of confidence in you.
Q: If these are new OO principles, how am I supposed to figure out what the questions are? That’s asking a lot, isn’t it?
We’ve got some great OO categories today, so let’s get started.
I’ll read off an answer, and it’s your job to come up with the question that matches the.
This code construct has the dual role of defining behavior that applies to multiple types, and also being the preferred.
Anytime you’re writing code that interacts with these classes, you have two choices.
You can write code that interacts directly with a subclass, like FootballPlayer, or you can write code that interacts with the interface, Athlete.
When you run into a choice like this, you should always favor coding to the interface, not the implementation.
Why is this so important? Because it adds flexibility to your app.
That means that your code will work with any subclass of  Athlete, like HockeyPlayer or TennisPlayer, and even subclasses that haven’t even been designed yet (anyone for CricketPlayer?)
Coding to an interface, rather than to an implementation, makes your software easier to extend.
By coding to an interface, your code will work with all of the interface’s subclasses—even ones that haven’t been created yet.
Athlete defines a play() method that all these classes implement in sportspecific ways.
This is how you represent an interface in UML: the <<interface>> word and italicized class name.
But there’s more to encapsulation than just avoiding lots of  copy-and-paste.
Encapsulation also helps you protect your classes from unnecessary changes.
Anytime you have behavior in an application that you think is likely to change, you want to move that behavior away from parts of  your application that probably won’t change very frequently.
In other words, you should always try to encapsulate what varies.
It looks like Painter has two methods that are pretty stable, but that paint() method is going to vary a lot in its implementation.
So let’s encapsulate what varies, and move the implementation of how a painter paints out of  the Painter class.
Here’s a very simple class that does three things: prepares a new easel, cleans brushes, and paints a picture.
Preparing an easel and cleaning brushes are going to stay pretty much the same.
So here’s where all the change could happen in Painter.
We’ve encapsulated what varies-the painting behaviorout of the Painter class.
Now the variance is tucked away into all of these PaintStyle implementation classes.
Notice that we’re coding to an interface here, not an implementation.
Every class should attempt to make sure that it has only one reason to do this, the death of many a badly designed piece.
Software that isn’t well-designed falls apart at the first sign of  change, but great software can change easily.
The easiest way to make your software resilient to change is to make sure each class has only one reason to change.
In other words, you’re minimizing the chances that a class is going to have to change by reducing the number of  things in that class that can cause it to change.
When you see a class that has more than one reason to change, it is probably trying to do too many things.
See if  you can break up the functionality into multiple classes, where each individual class does only one thing—and therefore has only one reason to change.
Automobile start() stop() changeTires(Tire [*]) drive() wash() checkOil() getOil(): int.
They deal with starting and stopping, how tires are changed, how a driver drives the car, washing the car, and even checking and changing the oil.
There are LOTS of things that could cause this class to change.
If a mechanic changes how he checks the oil, or if a driver drives the car differently, or even if a car wash is upgraded, this code will need to change.
It handles starting, stopping, and reporting on its oil attribute.
Driver and CarWash each do just ONE thing, so they won’t have to change nearly as often.
You could probably even break up these two functions if you wanted, and separate the functionality of a Mechanic into two behavior classes.
You’ve been doing pretty well, but now it’s time for FINAL CATASTROPHE.
Below is the class diagram for an application that’s not very flexible.
To show that you really can avoid an OO catastrophe, you need to write down how you’d.
You’ll need to use all the principles we’ve been talking about, so take your time, and.
We can reduce these two order methods to one: orderDessert(), and then return the interface, Dessert.
DessertCounter has more than one reason to change: if the ordering process changes, or if how the Cone and Sundae class adds toppings changes.
Adding a topping should be done to the Dessert classes directly, not here.
We should try and encapsulate what varies, and put all the serving code in one place.
That way, if the serving process changes, we don’t need to change ALL these classes.
A: You’ve seen several times already that when you see a potential for duplicate code, you should look to encapsulate.
In this case, it’s reasonable to assume that serving a Sundae probably isn’t that different from serving a Cone.
So you could create a new class, called DessertService, and put the serve() method in that class.
If serve() changes, you’ve got to update code in only one place: DessertService.
So you’re encapsulating what might vary—the code in the serve() method—and you’re making sure that each class has only a single reason to change.
Q: How did you know to encapsulate the serve() methods out of all those different classes? I missed that.
Topping and IceCream both have a serve() method, and seem to be pretty similar...
It’s been great having you as a contestant, and we’d love to have.
Each class in your application should have only one reason to change.
These three principles are HUGE! Take note of them, as we’ll be using them a lot in the upcoming chapters.
To help stretch your application out, you’re going to do some.
Back to Rick’s search tool Loaded up with some new OO principles, we’re ready to tackle making Rick’s application well-designed and flexible.
Here’s where we left off, and some of  the problems we’ve discovered:
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
There’s a search() method for each and every Instrument subclass.
These have nothing but a constructor, so they’re a real pain...
Just like with Instrument, every new type results in a new subclass of InstrumentSpec.
Guys, I’ve been looking over this class diagram for Rick’s.
Frank: Yeah, it’s a pain, but I don’t see any way to get around it.
We have to let Rick’s clients search for each different type of  instrument somehow.
Jim:  I still don’t see why we can’t have just one search() method that takes in an InstrumentSpec.
Wouldn’t that cut down on all those different versions of  search()?
Joe: Well, it would, but we still don’t have any way to return multiple types of  instruments.
If  the client provides a GuitarSpec, it’s never going to match a BanjoSpec or MandolinSpec.
So the list returned from search() will always have only the type of  instrument that the client’s spec is for.
Jim: Because we can’t instantiate InstrumentSpec, right? It’s an abstract class, so we have to create a MandolinSpec, or a BanjoSpec, or whatever.
I hadn’t thought about that, but you’re right; we really should be focusing on the interface, and not all those implementation classes.
A closer look at the search() method It seems pretty clear that there’s a problem with the way we’re handling searches for Rick’s clients.
We could make InstrumentSpec a concrete class, but would that solve all our problems?
Now we can let Rick’s clients pass in an InstrumentSpec to the search() method.
This version of Inventory requires lots of changes for every new instrument that Rick sells...
We’re coding to the Instrument base type now, not the implementation classes like Guitar and Mandolin.
The benefits of our analysis Let’s take what we’ve figured out about turning InstrumentSpec into a concrete class, and see if  it makes the design of  Inventory any better.
The search() method isn’t the only thing that makes adding new instruments to Rick’s application difficult.
You also have to add a new subclass of Instrument for each new instrument type.
Why is there a need for an Instrument class in Rick’s application?
Feel free to add or remove classes and properties; it’s up to you to decide how you can improve Rick’s design.
GuitarInstrument serialNumber: String price: double spec: InstrumentSpec getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
The search() method isn’t the only thing that makes adding new instruments to Rick’s application difficult.
You also have to add a new subclass of Instrument for each new instrument type.
Why is there a need for an Instrument class in Rick’s application?
Feel free to add or remove classes and properties; it’s up to you how you can improve Rick’s design.
Most instruments have at least a few common properties, like serial number and price.
Instrument stores the common properties, and then each specific instrument type can extend from Instrument.
The serial number, the price, and some set of specifications (even though the details of those specs may be different for different instrument types)
The specifications: each type of instrument has a different set of properties that it can contain.
And since each instrument has a different InstrumentSpec, each has a different constructor.
Did you come up with any ideas for changing Rick’s application?
You didn’t need to write down exactly what we did, but you should be thinking along the same lines here.
GuitarInstrument serialNumber: String price: double spec: InstrumentSpec getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
A closer look at the instrument classes Even though search() is looking better, there are still some real problems with all the instrument subclasses, and the addInstrument() method in Inventory.
Remember, we originally made Instrument abstract because each instrument type was represented by its own subclass:
Instrument serialNumber: String price: double spec: InstrumentSpec getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
Each instrument subclass just adds a constructor specific to that instrument type’s spec class.
But classes are really about behavior! But the reason you usually create a subclass is because the behavior of  the subclass is different than the superclass.
In Rick’s application, is the behavior of  a Guitar different than that of  an Instrument? Does it function differently in his application than a Mandolin or Banjo?
So that leaves only two reasons to have subclasses for each instrument type:
Because the Instrument class represents a concept, and not an actual object, it really should be abstract.
So we have to have subclasses for each instrument type.
These seem like pretty good reasons (well, at least the first one does), but we’re ending up with lots of  extra classes that don’t do much...
This looks like another case where we’re coding to an implementation instead of an interface.
So this isn’t a good reason to keep Instrument abstract.
Remember the second step in writing great software, from back in Chapter 1:
How can we take this step and apply it to the problems we’re finding in Rick’s app?
Since Rick’s app already does what it needs to do (Step 1), we’re ready to try and make his software more flexible.
There’s definitely a problem with Rick’s app, but we’re not sure what it is.
When you don’t know what to do to solve a design problem, just run through the OO principles you know, and see if any of them might help improve your software’s design.
For each principle, check the box if you think it could help us out.
Then, if you checked the box for a principle, it’s up to you to write down how you could use that principle to improve Rick’s search tool design.
There’s definitely a problem with Rick’s app, but we’re not sure what it is.
When you don’t know what to do to solve a design problem, just run through the OO principles you know, and see if any of them might help improve your software’s design.
We’re using inheritance already with the Instrument and InstrumentSpec classes, and their subclasses.
We use polymorphism in the search() method to treat all instruments as instances of Instrument, instead of worrying about whether they’re a Guitar or a Mandolin.
InstrumentSpec abstracts the details about each instruments specifications away from the Instrument class itself, so that we can add new instrument properties without affecting the basic Instrument class.
We’re using encapsulation a lot, but maybe we can use it even more...
Frank:  Exactly! And we know that the properties for each instrument are what varies in the application.
Jim: I thought we’d been over this; that’s why we have all those subclasses of  Instrument, like Guitar and Mandolin.
Frank: What about them? The Instrument class has a reference to an InstrumentSpec, and all the property differences can be handled by those classes.
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
We actually already have the properties encapsulated away from the rest of the application! We just weren’t taking advantage of our good design decision.
Death of a design (decision) One of  the hardest things you will ever do is to let go of  mistakes you made in your own designs.
In Rick’s search tool, it doesn’t make sense to have separate Instrument subclasses for each type of  instrument.
Because it seemed to make sense at the time, and it’s HARD to change something you thought was already working!
It’s easy to rip apart someone else’s code, but you’ve got to learn to look at your own code, and identify problems.
This is also where peer review, having fellow programmers look at your code, can really be a lifesaver.
Don’t worry if  you have to make changes; a betterdesigned application will save you tons of  time in the long run.
Never be afraid to examine your own design decisions, and improve on them, even if it means backtracking.
Keep looking over your designs when you run into problems.
We also probably need a new property in each instrument to let us know what type of  instrument it is:
GuitarInstrument serialNumber: String price: double spec: InstrumentSpec getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
We just cut six classes out of the design, and won’t need any new classes for instruments that Rick decides to start selling!
This can be another enumerated type, like Wood and Builder.
So now adding a new instrument type just means adding a new value to this enumerated type.
We can put values in here like GUITAR, BANJO, MANDOLIN, and so on.
Instrument serialNumber: String price: double spec: InstrumentSpec getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
I hate to butt in, but I’ve been thinking about something.
Frank:  We’ve gone through this already: the properties for each instrument are what vary.
Joe: We already have: we used the InstrumentSpec class for that.
We used InstrumentSpec because those properties were used by both clients and instruments.
So maybe we need to add another layer of  encapsulation.
Jill’s been listening in on the chapter, and has some ideas on how to improve Rick’s app.
What varies in Rick’s app? Write what you think varies in these blanks.
Let’s look at the layer of  encapsulation we already have, and then see how we can add a little more encapsulation to get those properties that vary out of  the InstrumentSpec class.
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
We realized in Chapter 1 that clients and instruments both needed to use these properties, so we created the InstrumentSpec class to abstract them away from the Instrument class.
The problem is that these properties vary across instruments, and so we’re having to add a subclass for each type of instrument.
Since some of  these properties vary, we want to move them out of  the InstrumentSpec class.
We need a way to refer to properties and their values, but not have those properties hardcoded into the InstrumentSpec class.
What type(s) do you think you could use to represent properties and access their values, but not have to change your InstrumentSpec class to support new properties?
By encapsulating what varies, you make your application more flexible, and easier to change.
Getting dynamic with instrument properties What did you come up with on the last page to store properties? We decided that using a Map would be a great way to handle various types of  properties, and still be able to easily add new properties at any time:
We can get rid of all these properties (and the related methods), and just use the properties map for everything.
Even better, now we can dump all those InstrumentSpec subclasses!
We can take any properties that were in these subclasses, and just add them in to the map in InstrumentSpec.
We need this property to tell us what kind of instrument we’re looking at.
What we did: a closer look Anytime you see something that varies, you should look for a way to encapsulate.
In the case of  InstrumentSpec, we realized that the properties of  an instrument vary.
InstrumentSpec is separate from Instrument because Rick’s clients supply an InstrumentSpec to search()
We took all the properties, which vary across instruments and instrument types, and pulled them out of InstrumentSpec.
Now all the properties are represented by name/value pairs in a Map data structure.
When you have a set of properties that vary across your objects, use a collection, like a Map, to store those properties dynamically.
You’ll remove lots of methods from your classes, and avoid having to change your code when new properties are added to your app.
Using the new Instrument and InstrumentSpec classes Let’s take one last look at how our new Instrument and InstrumentSpec classes work in practice.
If  you were accessing a guitar, and wanted to know who built it, here’s how you could do that:
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
We don’t have instrumentspecific subclasses now, so the guitar is represented by an instance of Instrument.
The Instrument has an InstrumentSpec instance associated with it to store instrument properties.
Using a Map for storing properties seems like a good idea, but let’s see how things look once we actually code up a new version of InstrumentSpec.
Your job is to finish off the code below using the magnets at the bottom of the page.
Using a Map for storing properties seems like a good idea, but let’s see how things look once we actually code up a new version of InstrumentSpec.
Be sure you got these two right; otherwise, matches() will always return the wrong result.
Q: So now both Instrument and InstrumentSpec are concrete classes?
Instrument isn’t just a concept anymore; it represents actual instruments in Rick’s inventory.
And InstrumentSpec is what clients use to pass in their specs when they’re searching, and what Instrument uses to store properties for an instrument.
Q: And that’s because we use the Instrument class directly now, right?
A: You got it! Remember, you typically subclass because behavior changes.
In the Instrument subclasses, no behavior was changing; in fact, all we did for each instrument subclass was create a new constructor.
That added a ton of classes, reduced the flexibility of our app, and really didn’t give us any helpful functionality.
Q: I understood getting rid of Guitar and Mandolin, but I’m confused about why we don’t need the different subclasses of InstrumentSpec anymore.
A: It’s OK; that’s one of the trickiest parts of the design of Rick’s application.
Remember, one of the key principles in any OO design is to encapsulate what varies.
So we pulled those properties out of InstrumentSpec, and put them into a Map.
Now, when you add another instrument with a new property, you can just add the new property as a name/value pair in the properties Map.
Q: And with less classes to deal with, our software is more flexible?
There are certainly times where adding classes will make your design more flexible, though.
Remember, adding an InstrumentSpec class helped separate instruments from their properties, and that was good; but in this chapter, we’ve been removing classes, and that’s made it easier to add new instruments to Rick’s software.
Q: I never would have figured out that we didn’t need subclasses for instruments or their specs.
How am I supposed to ever get good at this?
A: The best way to get good at software design is to write software! In Rick’s application, we had to go down some wrong paths—like adding Guitar and Mandolin classes—to figure out what the right thing to do was.
Most good designs come about through bad designs; almost nobody gets it all right the first time.
So just do what makes sense, and then start applying your OO principles and patterns to see if you can make improvements to what you’ve got.
Never be afraid to make mistakes and then change things around.
Finishing up Rick’s app: the InstrumentType enum We’ve almost got ourselves a great piece of  software.
Let’s follow through on our new design ideas, starting with a new enumerated type for each instrument type:
So far, these are the types of instruments that Rick sells.
Let’s update Inventory, too With the changes to Instrument and InstrumentSpec, our Inventory class starts to get much simpler:
Now we’re able to instantiate Instrument directly, since it’s no longer abstract.
We’ve made a ton of changes to Rick’s software, all in the name of “more flexibility.” Let’s see how things look now.
Flip back to the class diagram of Rick’s app on page 234, and recall what things looked like when we started.
Then, below, draw a class diagram for how Rick’s application looks now.
Behold: Rick’s flexible application We’ve made a ton of  changes to Rick’s application...
Look at the class diagram below, though, and see how much simpler Rick’s application is now:
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
Inventory has just one search() method now, and the method can return multiples types of matching instruments.
Instrument isn’t abstract anymore, and we also got rid of all those instrumentspecific subclasses.
We’re using a Map to store all the properties, so we don’t need subclasses for each instrument type.
All of these enumerated types are used by the properties Map in InstrumentSpec.
But does the application actually work? Rick’s software looks a lot better than it did way back at the beginning of  this chapter—and it sure looks better than when we added all those subclasses for banjos and mandolins.
But we’ve still got to make sure his search tool actually works! So let’s update our test class, and check out how searches work with the new version of  Rick’s software:
Since this test client didn’t specify an instrument type, the search could bring back guitars, mandolins, or anything else that Rick sells.
We have to work a little more directly with the Map that InstrumentSpec uses, but it’s easy now to just loop through each instrument’s properties and print them out.
We want to skip over the instrumentType property, since we’ve already handled that before we start looping.
We also need to add some instrume nts to Rick’s.
To see if the new version of Rick’s software works, we need to run a search on more than just guitars.
Below, we’ve listed the instruments Rick currently has, and even written code to add the first guitar to help you get started.
You should write code here to add the other instruments shown above.
Now you’re ready to take Rick’s software for a test drive...
First, you need to figure out what a search based on the current version of FindInstrument should return.
Here’s the set of preferences that Rick’s current client has supplied:
Rick’s client didn’t specify an instrument type, but he wants something from Gibson with a maple back.
Based on those specs, look over the instruments shown on the last page, and write in which guitars, mandolins, and banjos you think Rick’s search tool should return:
Write in the instruments you think that running FindInstrument should return based on Rick’s inventory.
Inventory Roundup Solutions To see if the new version of Rick’s software works, we need to run a search on more than just guitars.
The specs for these two Strats are the same; only the properties in Instrument are different.
This is a bit of a shortcut: we’re just using the same Map over and over.
Banjos don’t have a top wood, so we have to remove this property.
Don’t forget to remove numStrings for the mandolin if you’re reusing the same properties map.
What did I do wrong? A: If your version of Rick’s tool returned different guitars, or output the same guitars but with different properties, then you should be sure you have the same instruments in your inventory as we do.
Q: Is this really a good test since we only have one banjo and one mandolin?
A: That’s a great question, and you’re right, it would be better to have a few more mandolins and banjos to really make sure Rick’s search tool picks only matching mandolins and banjos.
Go ahead and add a few non-matching banjos or mandolins, and try testing out Rick’s search tool with the additional instruments.
Rick’s client ends up with three instruments to choose from: a guitar, a mandolin, and a banjo.
The guitar meets Bryan’s specs because it has a maple back and sides, and is made by Gibson.
That’s great that you’ve got your software working right, but don’t start patting yourself.
Me and my buddies at the bureau of change are here to see.
Let’s add support for dobros and fiddles back into Rick’s application.
We tried to do that earlier, back in the first part of Chapter 5, and it turned into a total mess.
Things should be much easier this time, right? Below is the class diagram for the current version of Rick’s software.
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
Suppose that Rick decided that he wanted to start keeping up with what year an instrument was made in.
How many classes would you need to change to support keeping up with this new information?
Rick also wants to add a new property, neckWood, that tracks what wood is used in the neck of an instrument.
How many classes would you need to change to support this property?
Seeing how easy it is to change your software is one of the best ways to figure out if you really have well-designed software.
Let’s add support for dobros and fiddles back into Rick’s application.
We tried to do that earlier, and it turned into a total mess.
Suppose that Rick decided that he wanted to start keeping up with what year an instrument was made in.
How many classes would you need to change to support keeping up with this new information?
Rick also wants to add a new property, neckWood, that tracks what wood is used in the neck of an instrument.
How many classes would you need to change to support this property?
One: we need to add any new instrument types to the InstrumentType enumerated type.
None! You can just store the year that an instrument was made in the properties Map in InstrumentSpec.
One in the worst case, and maybe none! neckWood is just another property we can store in the InstrumentSpec map...
Cohesion measures the degree of connectivity among the elements of a single module, class, or object.
The higher the cohesion of your software is, the more well-defined and.
A cohesive class does one thing really well and does not try to.
Our Inventory class worries about just Rick’s inventory, not what woods can be used in a guitar, or how to compare two instrument specs.
Instrument doesn’t try to handle searches, or keep up with what woods are available.
Look through the methods of your classes-do they all relate to the name of your class? If you have a method that looks out of place, it might belong in another class.
The more cohesive your classes are, the higher the cohesion of your software.
Cohesion, and one reason for a class to change You may not realize it, but we’ve already talked about cohesion in this book.
Cohesion is really just a measure of  how closely related the functionality of  the classes in an application are.
If  one class is made up of  functionality that’s all related, then it has only one reason to change...
Here are the classes we talked about when we made sure each class had only a single reason to change:
Every class should attempt to make sure that it has only one reason to do this, the death of many a badly designed piece.
This was one of the answers from OO CATASTROPHE! Do you remember what the question was?
Each one is a highly cohesive class, and that makes it easy to change, without changing the other classes.
Can you think of a way to make the Mechanic class more cohesive?
Q: So cohesion is just a fancy word for how easy it is to change my application?
Cohesion focuses on how you’ve constructed each individual class, object, and package of your software.
If each class does just a few things that are all grouped together, then it’s probably a highly cohesive piece of software.
But if you have one class doing all sorts of things that aren’t that closely related, you’ve probably got low cohesion.
A: Exactly! In almost every situation, the more cohesive your software is, the looser the coupling between classes.
In Rick’s application, the Inventory class really worries just about managing inventory—and not about how instruments are compared or what properties are stored in an instrument spec.
Q: But all that means the software will be easier to change, doesn’t it?
But remember the version of Rick’s application that we started with in this chapter? It only supported guitars, and we didn’t even have Instrument or InstrumentSpec classes.
That was pretty cohesive softwareGuitar was very loosely coupled with Inventory.
However, it took a lot of work and redesign to support mandolins.
When you fundamentally change what an application does—like going from selling only one type of instrument to multiple types—you may have to make lots of changes to a design that’s already cohesive and loosely coupled.
So cohesion isn’t always a test of how easy it is to change software; but in cases where you’re not dramatically changing how software works, highly cohesive software is usually easy to change.
Good OO design is when each class and module in your software does one basic thing, and that one thing really well.
As soon as one class starts doing two or three different things, you’re probably moving away from cohesion, and good OO design.
Q: Wouldn’t software that’s cohesive be easier to reuse, as well as change?
High cohesion and loose coupling adds up to software that can easily be extended, or even broken up and reused, because all the objects in the software aren’t interdependent.
Think about it this way: the higher the cohesion in your application, the better defined each object’s job is.
And the better defined an object (and its job) is, the easier it is to pull that object out of one context, and have the object do the same job in another context.
The object is happy to just keep on doing its very specific job, no matter where it’s being used.
Q: And we’ve been making Rick’s application more cohesive throughout his chapter, haven’t we?
But let’s look a little bit closer at that question...
Guitar serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): GuitarSpec.
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
Remember this simple class diagram from way back in Chapter 1? We just had two classes, and they were not well-designed or very cohesive.
The app was really cohesive, even though we had to do some real redesign to add support for mandolins.
Here was our first attempt to add support for multiple instrument types...
Rick’s software, in review So have our changes to Rick’s software resulted in high cohesion? Are our objects loosely coupled? And can we make changes easily? Let’s take a look:
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
This sounds great and all, but how do you know when you’re done? I mean, is there some sort of scale of cohesion, and when I get to a “10” or whatever, it.
Sometimes you just have to stop designing because you run out of  time...
If  your software works, the customer is happy, and you’ve done your best to make sure things are designed well, then it just might be time to move on to the next project.
Spending hours trying to write “perfect software” is a waste of  time; spending lots of  time writing great software and then moving on, is sure to win you more work, big promotions, and loads of  cash and accolades.
Before you ever leave a project, you always want to make sure your software does what it’s supposed to do.
Once you’ve got functionality down, move on to making good design decisions, using solid OO principles to add flexibility.
If you’ve done both of these things, it may just be time to move on...
Tools for your OOA&D Toolbox Wow, you’ve really come a long way since we.
You’ve learned a ton about design, so let’s do a quick.
Good requirements ensure your system works like your customers expect.
Make sure your requirements are complete by developing use cases for your system.
Use your use cases to find out about things your customers forgot to tell you.
Your use cases will reveal any incomplete or missing requirements that you might have.
Use basic OO principles like encapsulation and inheritance to make your software more flexible.
If a design isn’t flexible, then CHANGE IT! Never settle on bad design, even if it’s your bad design that has to change.
Make sure each of your classes is cohesive: each of your classes should focus on doing ONE THING really well.
Always strive for higher cohesion as you move through your software’s design life cycle.
Between OO CATASTROPHE! and this chapter, we’ve added quite a few new OO principles to our toolbox.
We did a ton of design in this chapter, so take a second to review everything we’ve learned.
The goal of good design is highly cohesive, loosely coupled software.
Each class in your application should have only one reason to change.
Are you ready? You’ve got a ton of tools in your OOA&D toolbox, but how do you use those tools.
Look, all this stuff about writing great software sounds terrific, but real applications have a lot more than five or ten classes.
You solve big problems the same way you solve small problems.
Make sure your software does what the customer wants it to do.
Remember these steps to writing great software? They all apply to working with huge, 1000+ class applications just as much as when you’re working with just a couple of classes.
It’s all in how you look at the big problem Think about how you work on big problems, in big software applications.
You usually look at the big picture, but then start working on just one part of the application’s functionality.
The best way to look at a big problem is to see it as lots of individual pieces of functionality.
You can treat each of those pieces as an individual problem to solve, and apply the things you already know.
Once you get one part of  an application working like you want it to, then you can move on to another piece of  functionality within the app.
At each step, though, you’re applying the same basic principles we’ve been talking about for the last 250 pages or so.
This BIG PROBLEM is really just a collection of functionalities, where each piece of functionality is really a smaller problem on its own.
The best way to get good requirements is to understand what a system is supposed to do.
By encapsulating what varies, you make your application more flexible, and easier to change.
You’ve already learned a lot of  things that will help you solve big software problems...
Let’s take a quick look at some of  the things we already know about how to write great (big) software:
The more you encapsulate things, the easier it will be for you to break a large app up into different pieces of functionality.
By coding to an interface, you reduce dependencies between different parts of your application...
If you know what each small piece of your app’s functionality should do, then it’s easy to combine those parts into a big app that does what it’s supposed to do.
In fact, the higher the cohesion of your app, the more independent each piece of functionality is, and the easier it is to work on those pieces one at a time.
Got a big problem? Take a few of these little principles, and call.
So let’s solve a BIG problem! Enough about what you already know; let’s see how we can apply these things to a brand new, really big piece of  software.
Turn the page to learn a bit about Gary, his new game company, and a large software project.
Here’s the big problem we’re going to be working on for the next few chapters.
Gary’s Games provides frameworks that g ame designers can use to.
The game system framework (GSF) will p rovide the core of  all of.
It will be delivered as a lib rary of  classes with a welldefined API that should be usable by all b oard game development.
The GSF will simplify the task of  develop ing a turn-based strategic.
Below are several things that you might start out doing to get going on Gary’s Games.
Check the boxes next to the things you think we should start with.
I’m not interested in one of those fancy, flashy Star Wars.
I want something with strategy, that makes you think! A.
But I’m not sure we really have enough information to figure out the requirements or use cases yet...
But that really doesn’t tell us much about what the system we’re building is.
Requirements and use cases are a good place to start...
That vision statement seemed to have a lot of  information about what Gary wants, but it leaves a lot open to interpretation.
What kind of  board did Gary have in mind? And who’s the customer, really? Game players or game designers? And will all the games be historically based, or do we have to support things like lasers and spaceships? It sounds like there’s a lot more we need to know before we can write a very good set of  requirements.
What is the system like? One way you can find out more about a system is to figure out what the system is like.
In other words, are there some things that you do know about that the system functions or behaves like?
What is the system not like? Another great way to find out what a system should do is to figure out what it’s not like.
This helps you determine what you don’t need to worry about in your system.
We need a lot more information All we’ve got to go on with Gary’s system so far is a vision statement...
So now we’ve got to figure out what the system is supposed to do.
So let’s listen in on one of Gary’s meetings, and see what we can find out...
Customer Conversation We need to listen in a little more on what Gary and his team are planning before we can get started on the game system framework he wants us to build.
And people are getting a little tired of all the fancy graphics in games like Star Wars episode 206 (or whatever the heck they’re up to these days)
Bethany: And we need all sorts of  different time periods.
Susan: Nice idea, Beth! I’ll bet we can let game designers create add-on packs, too, so you could buy a World War II: Allies game, and then buy an add-on for other forces that the core game didn’t include.
We’ve already found some commonality! The system has an interface sort of like this Zork game.
Flexbililty is going to be key if we’re going to support all these variations.
I’ll bet Gary would go for that, if  they’re still creating turn-based games.
Why not clean up on that market as well as the history buffs?
Bob: Do you think we could market this as a system to create everything from online Risk to a modern-day Stratego? Those were both killer strategy board games back in the day...
I’d love to sell our system to people that make those sorts of  games.
Tom: We can let the game designers pick how many tiles on the board, right? They can choose a height and width, or something like that?
And then we should support all different types of  terrains: mountains, rivers, plains, grass...
Susan: ...maybe space or craters or asteroid or something for the space games...
Bob: Even underwater tiles, like seaweed or silt or something, right?
Susan: Do we have to worry about all those movement rules and things that these games usually have?
Tom: I think we have to, don’t we? Don’t most of  these strategy games have all sorts of  complicated rules, like a unit can only move so many tiles because he’s carrying too much weight, or whatever?
We can build a framework for challenging, fun strategy games, and make a ton of  money, too.
Bob: This is starting to sound pretty cool! Let’s get this to Gary and those software guys he’s hired, so they can get started.
So did you get all that? You’re ready to start working on my new.
OK, now we’re starting to get some ideas about actual features of the game system.
Figure out the features You’ve learned a lot about what Gary and his team want the game system framework to do, so let’s take that information and figure out the features of  the system.
Bethany: And we need all sorts of  different time periods.
And then we should support all different types of  terrains: mountains, rivers, plains, grass...
Susan: ...maybe space or craters or asteroid or something for the space games...
Bob: Even underwater tiles, like seaweed or silt or something, right?
But what is a feature, anyway? A feature is just a high-level description of  something a system needs to do.
You usually get features from talking to your customers (or listening in on their conversations, like we just did on the last few pages)
A lot of  times, you can take one feature, and come up with several different requirements that you can use to satisfy that feature.
So figuring out a system’s features is a great way to start to get a handle on your requirements.
Starting with the features of a system is really helpful in big projects-like Gary’s game system-when you don’t have tons of details, and just need to get a handle on where to start.
We need a list of features for Gary’s game system.
You’ve got plenty of information from Gary and his team, and now you know how to turn that information into a set of features.
Your job is to fill in the blanks below with some of the features you think Gary’s game system framework should have.
Get features from the customer, and then figure out the requirements you need to implement those features.
We need a list of features for Gary’s game system.
You’ve got plenty of information from Gary and his team, and now you know how to turn that information into a set of features.
Your job is to fill in the blanks below with some of the features you think Gary’s game system framework should have.
Supports different time periods, including fictional periods like sci-fi and fantasy.
Supports multiple types of troops or units that are game-specific.
Lots of  people use “feature” to mean different things, so it’s not a term you should get too worked up about.
For some people, a feature is a requirement; and you’ll even hear some people say “feature requirement,” which really can get confusing.
Others think of  features as higher-level than requirement, which is how we’ve been talking about them.
So it might take several requirements to satisfy one feature of  a system.
Don’t get hung up on the “difference” between a feature and a requirement.
What’s the big difference between calling something a feature, and.
It’s OK if these aren’t the exact features you got, or if you had more detailed things in this list.
Each game has a board, made up of square tiles, each with a terrain type.
The framework keeps up with whose turn it is and coordinates basic movement.
Q: So there’s no difference between a feature and a requirement?
For some people, a feature is a “big” thing that a system does, like “support different types of terrain.” But to put that feature into place, there are lots of “small” things that the system must do, like “define a base terrain type” and “allow developers to extend the base terrain type” and “allow each tile to contain multiple terrain types.” All of these little things are considered requirements.
So a single feature is satisfied by several requirements, like this:
Q: You said, “some people.” So there are other ways to look at features and requirements?
A lot of other people don’t make such a distinction between a feature and a requirement.
One feature might be “supports different time periods” (which is a pretty big thing), and another might be “allow for water as a type of terrain” (which is a pretty small, specific thing)
In this approach, there’s not really a big difference between what a feature is and what a requirement is.
So these people see things a lot more like this:
There’s no “one right way” to think about features and requirements, especially if you don’t want to waste lots of time arguing over definitions with your programmer buddies.
You’re better off thinking about both features and requirements as the things your system needs to do.
If you want to consider features the “big picture” things, and requirements the “smaller, more detailed” things, that’s OK...
Features are “big things” that lots of requirements combine to satisfy.
In this approach, there’s a lot of overlap in what a feature is, and what a requirement is.
OK, so we’ve got the feature and requirement thing figured out.
Use cases don’t always help you see the big picture.
If we did write use cases for Gary’s game system, who would the actors be?
So what are we supposed to do now? You’ve been telling us we need to know.
Ever hear that a picture is worth a thousand words?
Let’s see if we can show what the system is supposed to do.
Use case diagrams Sometimes you need to know what a system does, but don’t want to get into all the detail that use cases require.
When you’re in a situation like this, a use case diagram could be just what you need:
He acts on the system, which in this case is the game framework.
What’s inside the box is the system; what’s outside uses the system.
Each of these ovals represents a single use case in the system.
Remember, the actor on this system is a game designer, not a game player.
This use case diagram might n ot be the most detailed.
Use cases are much more detailoriented, and don’t help you f igure out the big.
What good does that diagram do us? Do we really need to draw a picture to figure out that game designers are going to.
That use case diagram may seem sort of  vague, but it does help you keep your eye on the fundamental things that your system must do.
Without it, you could easily get so caught up in the details of  how a designer creates a new game that you completely forget that they need to actually deploy that game.
With a use case diagram, you’ll never forget about the big picture.
Use your feature list to make sure your use case diagram is complete.
Once you have your features and a use case diagram, you can make sure you’re building a system that will do everything it needs to.
Take your use case diagram, and make sure that all the use cases you listed will cover all the features you got from the customer.
Then you’ll know that your diagram—the blueprints for your system—is complete, and you can start building the system.
But what about all those features we worked so hard to figure out? They don’t even show up on the.
The framework supports different time periods, including fictional periods like sci-fi and fantasy.
The framework supports multiple types of troops or units that are gamespecific.
The framework supports add-on modules for additional campaigns or battle scenarios.
The framework provides a board made up of square tiles, and each tile has a terrain type.
The framework keeps up with whose turn it is, and coordinates basic movement.
It’s time to match up the game framework’s features to the use cases in your use case diagram.
Place the magnet for each feature on the use case that will handle that feature.
If your use case diagram is complete, then you should be able to attach each feature magnet to a use case on your diagram.
The framework provides a board made up of tiles, each with a terrain type.
The framework keeps up with whose turn it is, and coordinates basic movement.
Here’s our use case diagram, the blueprint for our system.
Each feature should be attached to one of the use cases in the system.
Q: So an actor is a person that uses the system? A: An actor is actually any external entity (it doesn’t have to be a person) that interacts with the system.
So in a cash machine, you’d obviously have a person that uses the system as an actor, but you might also have the bank as an actor, because it deposits money in the system.
If it’s not part of the system but acts on the system, it’s an actor.
Q: What’s the box around everything for? And why are the actors outside of the box?
So you have to code up everything inside the box, but you don’t have to worry about the stuff outside the box.
The actors—the game designers using your framework—are outside of the box because they use your system; they’re not part of it.
Q: And each circle is a use case? A:  Right.
That’s part of why use case diagrams are great for getting a handle on the big picture: they can show you multiple use cases, and how all those use cases work together to do really big tasks.
It also helps you avoid getting into details about a particular requirement too early (like now, when you should be worrying about the overall system design)
A:  UML and use case diagrams do define ways to specify what kinds of relationships exist between use cases.
So you could say that one use case includes another, or that one use case extends another.
However, it’s easy to spend a lot of time arguing over whether a use case extends this use case, or includes that one.
And suddenly, you’re spending your time on how a tile can support mountains or units need to carry a backpack, instead of focusing on the bigger picture.
Q: So use case diagrams are more about a general picture of the system than including lots of little details?
A:  Now you’ve got it! If you’re worrying too much about what to call a use case, or whether you should use a particular relationship between use cases, you’ve lost sight of the big picture.
Use your use case diagrams to get a clear 10,000-foot view of your system, nothing more.
Thanks for all the info, but can we get back to that Feature Magnets exercise?
I’m stuck trying to match one of the features to a use case...
It’s time to match up the game framework’s features to the use cases in your use case diagram.
Were you able to find a use case for each feature in the game framework?
The framework provides a board made up of tiles, each with a terrain type.
The framework keeps up with whose turn it is, and coordinates basic movement.
Almost all of the features have to do with a game designer creating a new game.
You could also have put most of these features on “Modify Existing Game,” since they all can be part of a redesign, too.
Deploying the game is an important piece of the system, even though the customer didn’t mention any features related specifically to it.
There’s probably one feature you had some trouble placing on the use case diagram.
Think about this feature carefully: it’s really not something the game designer directly interacts with or worries about, because the functionality is already taken care of.
So how is this feature related to the system? And what actors are involved? And are we missing some use cases in our diagram?
We know this is a feature, but why doesn’t it have a place in our blueprints?
So what is the point of  the framework? To let game designers build games.
So the game designer is an actor on the system? Yes.
And what does the game designer do with the framework?
Is the game the same as the framework? Well, no, I suppose not.
Why not? The game is complete, and you can actually play it.
All the framework provides is a foundation for the game to be built on.
So the framework is a set of  tools for the game designer?
I mean, the feature I’m stuck on is something the framework handles for each individual game.
But it’s like a lower level, like it just provides some basic services to the game.
The game sort of  sits on top of  the framework.
Actors are people, too (well, not always) It turns out that in addition to the game designer, the game itself  is an actor on the framework you’re building.
Let’s see how we can add a new actor to our use case diagram:
We’ve added a new actor, for the game (which the designer creates, using the framework)
Here are a few of the things that the game uses the framework to do.
These become additional use cases that our system will need to perform to be complete.
Do these new use cases take care of the feature we couldn’t find a place for?
The framework keeps up with whose turn it is, and coordinates basic movement.
The framework provides a board made up of tiles, each with a terrain type.
The framework keeps up with whose turn it is, and coordinates basic movement.
The second part of that last feature, about movement, fits in with the “Move Units” use case...
Who is the actor on “The framework keeps up with whose turn it is?”
What use case would you add to support this partial feature?
Most of the features relate to what the game designer does with the framework.
Here’s our new actor, the game, which also uses the framework during gameplay.
The new use cases associated with the game take care of the feature we had trouble with earlier.
The framework keeps up with whose turn it is, and coordinates basic movement.
The second part of that last feature, about movement, fits in with the “Move Units” use case...
Who is the actor on “The framework keeps up with whose turn it is?”
What use case would you add to support this partial feature?
The framework keeps up with whose turn it is, and coordinates basic movement.
We need a use case for “Take Turn” where the framework handles basic turn duties, and lets the custom game handle the specifics of that process.
The framework provides a board made up of tiles, each with a terrain type.
The “Take Turn” use case lets us know that the game needs to handle turn-based duties.
We also broke up that one feature into two separate features.
The framework supports different time periods, including fictional periods like sci-fi and fantasy.
The framework supports multiple types of troops or units that are gamespecific.
The framework supports add-on modules for additional campaigns or battle scenarios.
The framework provides a board made up of square tiles, and each tile has a terrain type.
So what exactly have we done? You’ve got a list of  features that Gary’s game system framework needs to support, and that tells you all the major pieces of  the system you need to build.
This is a lot like the requirements list you built way back in Chapter 2 for Todd and Gina’s dog door...
Use a feature or requirement list to capture the BIG THINGS that your system needs to do.
Once you’ve got your features and requirements mapped out, you need to get a basic idea of  how the system is going to be put together.
Use cases are often too detailed at this stage, so a use case diagram can help you see what a system is like at 10,000 feet...
Draw a use case diagram to show what your system IS without getting into unnecessary detail.
Jim:  What about class diagrams? We could use those to show what we’re going to code, couldn’t we?
We can talk to the customer about their system, in terms that they understand.
For Gary, that means talking about units, and terrain, and tiles, instead of  classes, objects, and methods.
Domain analysis lets you check your designs, and still speak the customer’s language.
Let’s do a little domain analysis! Let’s  put all these things we’ve figured out about the game system together, in a way that Gary, our customer, will actually understand.
This is a process called domain analysis, and just means that we’re describing a problem using terms the customer will understand.
The process of identifying, collecting, organizing, and representing the relevant information of a.
The framework supports different time periods, including fictional periods like sci-fi and fantasy.
The framework supports multiple types of troops or units that are gamespecific.
The framework supports add-on modules for additional campaigns or battle scenarios.
The framework provides a board made up of square tiles, and each tile has a terrain type.
The framework supports different time periods, including fictional periods like sci-fi and fantasy.
The framework supports multiple types of troops or units that are gamespecific.
The framework supports add-on modules for additional campaigns or battle scenarios.
The framework provides a board made up of square tiles, and each tile has a terrain type.
Very cool! That’s exactly what I want the system to do.
Gary’s thrilled, because he understand what you’re building, and knows it will do what he wants it to do.
What the heck is this? I have no idea if this is what I want.
Gary’s totally lost, because he’s not a programmer! You didn’t speak his language.
These are class and package diagrams, and code-level details about how you’ll build Gary’s game framework.
Now divide and conquer With the customer onboard, and a nice completed set of  blueprints,  you’re ready to start breaking up your big problem into different pieces of  functionality—and then you can use what you’ve learned already to tackle each of those pieces of  functionality, one at a time.
Units We need a way to represent a basic unit, and let the game designers extend that to create game-specific units.
Tiles The framework needs to have a basic tile, and each tile should be able to support terrain types, units, and probably handle battles, too.
Time Periods We may not need to do much here...
Terrain Types Each tile should support at least one terrain type, and game designers should be able to create and use their own custom terrain types, from grass to lakes to asteriod dunes.
Here’s a rough drawing of some of the core parts of the game framework.
We can break the large framework down into several smaller, more manageable, pieces.
The framework supports multiple types of troops or units that are gamespecific.
The framework supports add-on modules for additional campaigns or battle scenarios.
The framework provides a board made up of square tiles, and each tile has a terrain type.
You need to address all the features in the system...
Here’s the game board to remind you of some of the major areas to focus on...
The Big Break-Up It’s time to break up our big problem—Gary’s game framework—into lots of smaller pieces of functionality.
You’ve already seen how we can divide the game and its features into some basic groups of functionality, so you’re already well on your way.
Below are the features and diagrams we’ve been using throughout this chapter to show what Gary’s system needs to do.
You need to look at these, and figure out what modules you want to use to handle all this functionality, and how you want to split the features and requirements up.
Make sure your modules cover everything you think the game framework will need to do!
This would be where classes representing troops, armies, and related functionality would go.
You can add more modules if you need, or use less modules than we’ve provided.
We have BIG problems, and I just can’t handle them.
Game This takes care of troops, armies, and all the units used in a game.
The board module handles the board itself, tiles, terrain, and other classes related to creating the actual board used in each game.
It’s always a good idea to have a Utilities module, to store tools and helper classes that are shared across modules.
We’re using a Game module to store basic classes that can be extended by designers.
These relate to the time period of the game, basic properties of the game, and anything else that sets up the basic structure of each game.
We chose to NOT have a module just for terrain, or tiles, since there would only be one or two classes in those modules.
Here’s where we can handle the turns of each player, basic movement, and anything else related to keeping a game actually going.
This module is sort of the “traffic cop” for the games that designers create.
It’s OK if  your answers don’t match up with ours exactly.
What you do need to worry about is that you’ve covered all the features and use cases with your design, and that it makes sense...
Our Big Break-Up Here’s what we did to handle all the features of Gary’s system, and to break the big problem up into several smaller, more manageable pieces of functionality.
Dude, this game is gonna SUCK! You don’t even have a graphics package...
Don’t forget who your customer really is It might seem like Tony has a good point...
Your job is to write a framework for game designers, not to create actual games.
Every game’s user interface will be different, so it’s up to the game designer to take care of  graphics, not you.
Domain analysis helps you avoid building parts of a system that aren’t your job to build.
Tony may know a lot about what makes for a killer game, but he’s not your customer!
Take a close look at the modules and groupings in the game system framework.
It handles basic turns and figuring out what needs to happen with boards, units, etc.
Game designers can extend this module with their own game-specific controller, but this module is still the basic game controller.
These really don’t fit into the MVC pattern, but they’re still part of the system.
What’s a design pattern? And how do I use one?
But it’s no big deal if  you’re not familiar with design patterns.
You can still work through this book, and get a handle on really solid design.
Then, we’d recommend you pick up Head First Design Patterns, and see how other people have been handling some classic design problems, and learn from them.
Keep going! Design patterns are one of the last steps of design.
Feeling a little bit lost? We’ve done a lot of  things in this chapter, and some of them don’t even seem to be related...
But how does any of this really help us solve BIG problems? Remember, the whole point of  all this was to get a handle on how to deal with really large applicationslike Gary’s game system framework—that involve a lot more than some basic design and programming.
But here’s the big secret: you’ve already done everything you need to handle Gary’s BIG problem.
Gary’s Games provides frameworks that g ame designers can use to.
The game system framework (GSF) will p rovide the core of  all of.
It will be delivered as a lib rary of  classes with a welldefined API that should be usable by all b oard game development.
The GSF will simplify the task of  develop ing a turn-based strategic.
We started out with this rather vague, far-reaching vision statement.
The framework supports different time periods, including fictional periods like sci-fi and fantasy.
The framework supports multiple types of troops or units that are gamespecific.
The framework supports add-on modules for additional campaigns or battle scenarios.
The framework provides a board made up of square tiles, and each tile has a terrain type.
Using domain analysis, we made sure we understand what Gary wanted his system to do.
Once we knew what we were building, we created a use case diagram to help us understand the big picture.
With a blueprint and feature list in hand, we were able to break up Gary’s big app into lots of smaller pieces of individual functionality.
We even took a design pattern that we already understand, and applied it to our system.
We broke the big problem up into smaller pieces of functionality.
We apply design patterns to help us solve the smaller problems.
Look! You already know how to solve these smaller problems, using everything you’ve already learned about analysis and design...
Congratulations! You’ve turned a BIG PROBLEM into a bunch of SMALLER PROBLEMS that you already know how to solve.
Tools for your OOA&D Toolbox You’ve taken on a huge problem, and you’re still standing! Review some of the things you’ve learned.
The best way to look at a big problem is to view it as a collection of smaller problems.
Just like in small projects, start working on big projects by gathering features and requirements.
Features are usually “big” things that a system does, but also can be used interchangeably with the term “requirements.”
Commonality and variability give you points of comparison between a new system and things you already know about.
Use cases are detail-oriented; use case diagrams are focused more on the big picture.
Your use case diagram should account for all the features in your system.
Domain analysis is representing a system in language that the customer will understand.
An actor is anything that interacts with your system, but isn’t part of the system.
Good requirements ensure your system works like your customers expect.
Make sure your requirements are complete by developing use cases for your system.
Use your use cases to find out about things your customers forgot to tell you.
Your use cases will reveal any incomplete or missing requirements that you might have.
Use basic OO principles like encapsulation and inheritance to make your software more flexible.
If a design isn’t flexible, then CHANGE IT! Never settle on bad design, even if it’s your bad design that has to change.
Make sure each of your classes is cohesive: each of your classes should focus on doing ONE THING really well.
Always strive for higher cohesion as you move through your software’s design lifecycle.
Analysis and Design Listen to the customer, and figure out what they want you to build.
Put together a feature list, in language the customer understands.
Make sure your features are what the customer actually wants.
Create blueprints of the system using use case diagrams (and use cases)
Break the big system up into lots of smaller sections.
Apply design patterns to the smaller sections of the system.
Use basic OOA&D principles to design and code each smaller section.
Solving Big Problems We’ve got a whole new category of techniques we learned about in this chapter.
Each class in your application should have only one reason to change.
Below is a puzzle with lots of blank squares; to the right are some clues.
You have to start somewhere, but you better pick the right somewhere! You know how to break your application up into lots of small problems, but all that means is that you have LOTS of small problems.
Feeling a little overwhelmed? So you’ve got lots of  small pieces of  functionality that you know how to take care of...
OK, even if I do know how to handle all these individual pieces, where the heck am I supposed to start? Can.
The framework supports multiple types of troops or units that are gamespecific.
The framework provides a board made up of square tiles, and each tile has a terrain type.
Gary’s Games provides frameworks that game designers can use to create turn-based strategy games.
Unlike arcade-style shoot-’em-up games and games that rely on audio and video features to engage the player, our games will focus on the technical details of  strategy and tactics.
Our framework provides the bookkeeping details to make building a particular game easy, while removing the burden of  coding repetitive tasks from the game design.
The game system framework (GSF) will provide the core of  all of  Gary’s Games.
It will be delivered as a library of  classes with a well-defined API that should be usable by all board game development project teams within the company.
Do you think it matters what you should try to do first? If you do, why? And what would you work on first?
We need an architecture It’s really not enough to just figure out the individual pieces of  a big problem.
You also need to know a little bit about how those pieces fit together, and which ones might be more important than others; that way, you’ll know what you should work on first.
Our use case diagram was the start of this, but it’s still pretty unclear how all the modules interact.
All this is particularly important when you’re working with other programmers...
The framework supports different time periods, including fictional periods like sci-fi and fantasy.
The framework supports multiple types of troops or units that are game-specific.
The framework supports add-on modules for additional campaigns or battle scenarios.
The framework provides a board made up of square tiles, and each tile has a terrain type.
Gary’s Games provides frameworks that game designers can use to create turn-based strategy games.
Unlike arcade-style shoot-em-up games and games that rely on audio and video features to engage the player, our games will focus on the technical details of  strategy and tactics.
Our framework provides the bookkeeping details to make building a particular game easy, while removing the burden of  coding repetitive tasks from the game design.
The game system framework (GSF) will provide the core of  all of  Gary’s Games.
It will be delivered as a library of  classes with a well-defined API that should be usable by all board game development project teams within the company.
Ever get this feeling? You’ve got lots of important diagrams and plans, but everything is just a huge mess.
These lists and patterns should help, but it’s hard to know how it all fits together.
I have no clue what to do with all of this stuff.
All the diagrams and patterns are used to build the customer exactly what they want, all within a flexible, reusable design.
You write great software the same way, whether you’re working on a small project, or a huge one.
Remember this page from the first chapter? These 3 steps apply to building great BIG software, too.
We know that these three steps will help us tackle each of these individual pieces of the game system framework.
Let’s start with functionality The first step is always to make sure an application does what it’s supposed to do.
In small projects, we used a requirements list to write down functionality; in big projects, we’ve been using a feature list to figure those things out:
The framework supports different time periods, including fictional periods like sci-fi and fantasy.
The framework supports multiple types of troops or units that are gamespecific.
The framework supports add-on modules for additional campaigns or battle scenarios.
The framework provides a board made up of square tiles, and each tile has a terrain type.
But which of these are the most important? Even if  we know to start by focusing on functionality, we still need to figure out which pieces are the most important.
Those are the pieces we want to focus on first.
We’ll come back to these other diagrams and patterns later...
Sharpen your pencil What do YOU think are the most important features?
Even though our feature list has only seven things on it, there’s a lot of work in those seven features.
It’s your job to figure out which features you think are the most important, and then in what order you’d work on those things.
The framework supports different time periods, including fictional periods like sci-fi and fantasy.
The framework supports multiple types of troops or units that are gamespecific.
The framework supports add-on modules for additional campaigns or battle scenarios.
The framework provides a board made up of square tiles, and each tile has a terrain type.
You’ve got to handle all of these features, but it’s up to you to figure out the order you should tackle them in.
Write down the 4 things you’d do first, in order, in these blanks.
It’s awfully hard to talk about the relationships between parts of  a system if you don’t have any of  the parts themselves.
So say you wanted to talk about how the Board module interacted with the Units module:
The things in your application that are really important are architecturally significant, and you should focus on them FIRST.
The three Qs of architecture When you’re trying to figure out if  something is architecturally significant, there are three questions you can ask:
Is it part of the essence of the system? Is the feature really core to what a system actually is? Think about it this way: can you imagine the system without that feature? If  not, then you’ve probably found a feature that is part of  the essence of  a system.
What the fuck does it mean? If  you’re not sure what the description of  a particular feature really means, it’s probably pretty important that you pay attention to that feature.
Anytime you’re unsure about what something is, it could take lots of  time, or create problems with the rest of  the system.
How the “heck” do I do it? Another place to focus your attention early on is on features that seem really hard to implement, or are totally new programming tasks for you.
If  you have no idea how you’re going to tackle a particular problem, you better spend some time up front looking at that feature, so it doesn’t create lots of  problems down the road.
The framework supports different time periods, including fictional periods like sci-fi and fantasy.
The framework supports multiple types of troops or units that are game-specific.
The framework provides a board made up of square tiles, and each tile has a terrain type.
To the right, you’ll find the feature list we figured out in the last chapter.
Write down which of the three Qs applies (you can write more than one, if you need to)
To the right, you’ll find the feature list we figured out in the.
The framework supports different time periods, including fictional periods like sci-fi and fantasy.
The framework supports multiple types of troops or units that are game-specific.
The framework provides a board made up of square tiles, and each tile has a terrain type.
We decided that the board was core to the game...
Q: I’m a little confused about what you mean by the “essence” of the system.
A: The essence of a system is what it is at its most basic level.
In other words, if you stripped away all the bells and whistles, all the “neat” things that marketing threw in, and all the cool ideas you had, what would the system really be about? That’s the essence of a system.
When you’re looking at a feature, ask yourself: “If this feature wasn’t implemented, would the system still really be what it’s supposed to be?” If the answer is no, you’ve found yourself an “essence feature.” In Gary’s system, we decided that the game wouldn’t really be a game without a board and some units, and there are some more examples in the Brain Power at the bottom of the page.
Q: If you don’t know what something means, isn’t that a sign that you’ve got bad requirements?
A: No, but it is a sign that you might need to get some additional requirements, or at least some clarification.
In the early stages, you can leave some details out to get a basic sense of a system.
But at this stage, it’s time to fill in some of those details, and that’s what the second Q of architecture is all about.
Q: If I’m working on a new system, I probably won’t know how to do anything on my feature list.
So won’t the 3rd Q of architecture about not knowing how to do something always apply?
For instance, even if you’ve never written code to decide whether a player typed in the letter “q” or the letter “x,” you know how to write a basic if/else statement, and it’s easy to grab keyboard input from a player.
So a feature like getting keyboard input isn’t something you don’t know how to do, even if you’ve never written code specifically for that task before.
But if you had to write a multi-threaded chat server, and you’re new to threads and network programming, then that would be something that you don’t know how to do.
Those are the things to look out for: particularly hard tasks that you’re unsure about how to handle.
Q: Doesn’t this all end up just being  a judgment call, anyway?
But as long as you choose to start working on the things that seem the most important to the system, you’re going to get off to a good start.
What you don’t want to do is see some things that look familiar—perhaps you’ve solved the same problem in another project—and start there.
Start with the core pieces of the system, and the things that look like they might be particularly hard, and you’ll be on the road to success.
The essence of a system is what that system is at its most basic level.
Using the three Qs of  architecture, we’ve started to add some order to all that confusion we started out with:
I know I love a man in uniform, but there are still.
The framework supports multiple types of troops or units that are gamespecific.
The framework provides a board made up of square tiles, and each tile has a terrain type.
Gary’s Games provides frameworks that game designers can use to create turn-based strategy games.
Unlike arcade-style shoot-em-up games and games that rely on audio and video features to engage the player, our games will focus on the technical details of  strategy and tactics.
Our framework provides the bookkeeping details to make building a particular game easy, while removing the burden of  coding repetitive tasks from the game design.
The game system framework (GSF) will provide the core of  all of  Gary’s Games.
It will be delivered as a library of  classes with a well-defined API that should be usable by all board game development project teams within the company.
The framework supports different time periods, including fictional periods like sci-fi and fantasy.
The framework supports multiple types of troops or units that are game-specific.
The framework supports add-on modules for additional campaigns or battle scenarios.
The framework provides a board made up of square tiles, and each tile has a terrain type.
Coordinating movement—what is it, and how do we do it?
Remember all this? Quite a mess when we started out...
But then we focused on making the system do what it is supposed to do.
Finally, we’ve narrowed that down to just a few key features to focus on.
Jim: What in the world are you guys thinking? What good is it starting with anything that isn’t the essence of  the system?
While you’re putting off  the hard tasks, I’m gonna make sure the things that I don’t have any real idea about are taken care of, right away.
So who do you think is right? Do you agree with:
Leave it to a bunch of boys to get into a big argument.
The reason that these features are architecturally significant is that they all introduce RISK to your project.
It doesn’t matter which one you start with—as long as you are working towards reducing the RISKS in succeeding.
Coordinating movement—what is it, and how do we do it?
Jill works with Frank, Jim, and Joe, and is used to breaking up their arguments.
The point here is to REDUCE RISK, not to argue over which key feature you should start with first.
You can start with ANY of these, as long as you’re focused on building what you’re supposed to be building.
Since we don’t know what this means, it could be a ton of work, and that’s a RISK in meeting schedules and deadlines.
If the core features of the system aren’t in place, there’s a serious RISK that the customer won’t like the system.
This is something we’re not sure how to do, so there’s a RISK that we won’t figure it out, or it will take a really long time.
Well, I still think my risk is bigger than yours...
Think about the project you’re working on in your day job right now.
Now write down the first thing you started working on when you started the project:
If you applied those to your project, write down a few features that you think would be architecturally significant:
If you look at those features closely, you’ll probably see that they all have a lot of RISK connected to them.
They’re the things that could cause you lots of problems, or delay you getting your project done.
In the blanks below, write down which of those features you think you should have worked on first, and why.
What risks did it create? What risks could you have reduced by working on it first?
Write methods to add units to a tile based on that tile’s X- and Y-position.
Write a method to return all the units on a tile, given the X- and Y-position of  the tile.
You need a Board base type that game designers can use to create new games.
The board’s height and width are supplied by the game designers for their games.
Additionally, the board can return the tile at a given position, add units to a tile, and return all the units at a given X-Y position.
For Gary’s game system, let’s start out by working on the board module.
Your job is to write a Board interface that game designers can then use and extend to build their own games.
Here are some detailed requirements that we got from Gary and his design team.
HeadFirst:  Hi there, Scenario, we appreciate you taking the time to talk with us today.
Scenario: I’m really happy to be here, especially in a chapter that isn’t just about use cases.
HeadFirst:  Well, yes, to tell the truth, I was rather surprised when I was told we’d be interviewing you.
We’re really focusing on architecture here, and working on features that would reduce risk.
Scenario:  Absolutely! Well, that sounds like a very good way to approach big problems.
HeadFirst:  But I thought you were just a particular path through a use case.
Scenario:  That’s no problem, I can still be a real help.
I mean, look, let’s be honest, lots of developers just don’t ever really take the time to sit down and write out use cases.
Good grief, it took you something like four pages in Chapter 6 to convince people to even use a use case diagram, and that’s much easier to draw than it is to write a use case!
But they’re really helpful, I thought they saved the day with Todd and Gina’s dog door.
Scenario:  Oh, I agree! But in cases where developers just don’t have the time, or a use case is too formal for what’s needed, I can really give you a lot of  the advantages of  a use case, without all the paperwork.
Suppose you wanted to reduce the risks of Gary seeing it, and thinking of  something important you forgot to add to it...
HeadFirst:  Ahh, yes, forgetting an important requirement is always a risk!
Scenario:  Well, you could come up with a simple scenario for how the board would be usedthat’s where I come in—and then make sure the board works with everything in your scenario.
HeadFirst:  Oh, so just little descriptions of  how the board is used?
Scenario:  You’ve got it! Then you run through each description, and make sure your board handles those cases.
It’s not quite as thorough as a use case, but I really can help you make sure you don’t forget any big requirements.
HeadFirst:  This is fantastic! We’ll be right back with more from Scenario.
Write a scenario for the Board interface you just coded.
Reducing risk is the name of the game in this chapter.
You’ve coded a Board interface based on a few requirements we gave you, but it’s your job to figure out if we forgot anything—before Gary sees your work and finds a mistake.
Your job is to take the fragments of a scenario from the bottom of this page, and put them into an order that makes sense on the bulletin board.
The scenario should run through a realistic portion of a game.
When you’re done, see if you left out anything on the Board interface, and if you did, add the missing functionality into your code.
You may not need all the scenario fragments; good luck!
This is the risk we’re trying to reduce or eliminate using a scenario.
This is from Impatient in Idaho: “So you’re saying I don’t need to write use cases, anymore, right? I can just use scenarios?”
HeadFirst:  That’s right, we’ve actually had Happy Path and Alternate Path on our show before.
Scenario:  Well, they’re really just specialized versions of  me, if  you want the truth.
We try not to talk much about our family relationships, we all wanted to make it in this world on our own.
And you really need all of  us to be sure you’ve got a system completely right.
But if  you’re just getting started, and a use case seems like it might be premature, just using me is a good way to get started.
That’s when you’re writing use cases, putting together a requirements list, and using lots of  scenarios to chart out all the paths through a use case.
HeadFirst:  But you also help out in big project architecture, right? That’s why we’re interviewing you now?
Sometimes, you don’t have a complete requirements list and a bunch of  use cases, but you still need to get some basic work done to see how a system is going to work.
That’s what we’ve been doing here: using a scenario to get the basics of  a module or piece of  code down, so you can get the basic building blocks of  your application in place.
I help in gathering requirements, in being sure your use cases are complete, but also in architecture, helping you reduce risk and reduce the chaos and confusion around what a particular module or piece of  code does.
Scenario Scramble Solution Write a scenario for the Board interface you just coded.
This part is really optional, but it shows us that the board will probably need to figure out the terrain of a tile for basic movement requests.
Q: Where did those requirements for the Architecture Puzzle on page 340 come from?
If you think about what Gary’s asked for, a game system framework, and then read back over the customer conversation in Chapter 6, you could probably come up with these requirements on your own.
We did add a few specifics, like being able to add a unit to a specific tile, but that’s really just thinking through the problem.
Q: But why didn’t we write a use case to figure out the requirements?
But remember, we’re not trying to complete the Board module, as much as get the basic pieces in place.
That’s all we need to reduce the risk of completing this piece of Gary’s system.
In fact, if we got into too much detail, we might actually add risk to the project, by working on details that really aren’t important at this stage of things.
Q: Now you’re telling me that use cases add risk? That can’t be right!
A:  No, use cases don’t add risk when used at the right time.
Right now, we’ve come up with some key features that could cause us headaches if we don’t figure them out.
But that doesn’t mean we need to perfect the Board interface; we just need to get an understanding of how it works, so if there are any potential problem spots, we can catch them and avoid problems down the line.
So at this point, the details you’d need to write a good use case are a bit of overkill.
But once we’ve got the key features sketched out, and handled the major risks, we’ll go back to each module and really start to add detail in.
Q: So that’s why we used a scenario, right? To avoid getting into lots of unnecessary detail?
A scenario gives us lots of the advantages of a use case, without forcing us to get into lots of detail that we don’t need to worry about right now.
Did the requirements we used on page 340 cover everything in the completed scenario? If you think something is missing, write it in the blank below, and then add code to Board.java to handle the missing functionality.
Architecture Puzzle Solution For Gary’s game system, let’s start out by working on the Board module.
Below is the interface we wrote to handle what we thought the basic tasks of  a board would be.
Here’s a class we’ll create in a minute, since we need it to finish up Board.
It takes the width and height in, and then calls initialize() to set up the board.
We represented the grid on the board as an array of arrays, using width and height as the dimensions.
Bonus Design Principle: Pull out setup code into its own method, so it doesn’t make the rest of your code so confusing to read.
We decided to let the Tile class handle these operations, and just delegate adding and removing units to that class.
Here’s another place where we delegate to the Tile class.
Since a tile stores the units on it, it’s really the tile’s job to handle retrieving those units.
Dumb Questionsthere are no Q: Doesn’t using an array of arrays limit you to a square board?
A: No, although it does limit you to a board that uses (x, y) coordinates.
For example, you can use (x, y) coordinates in a board made up of hexagon-shaped tiles, if you structure the hexagon tiles correctly.
But for the most part, an array of arrays is more ideally suited to a square-tiled, rectangular board.
Q: So isn’t that limiting? Why not use a graph, or even a Coordinate class, so you’re not tied to (x, y) coordinates and a rectangular board?
A: If you wanted maximum flexibility, that might be a good idea.
For this situation, though, our requirements (back on page 340) actually specified (x, y) coordinates.
So we chose a solution that wasn’t quite as flexible, but certainly was simpler.
Remember, at this stage, we’re trying to reduce risk, not increase it by going with a solution that is a lot more complex than we really need.
The Tile and Unit classes To actually make Board compile and work, we need to create a Tile and Unit class.
There are lots of details to be added later, but we don’t need those details to make Board work right now.
Tile is in the same package as the Board class...
Tile has a list of the units on it at any given time.
Keep the right focus You don’t need to worry about everything that Tile and Unit will eventually need to do.
Your focus is on making Board and its key features work, not on completing Tile or Unit.
That’s why we left Unit so bare, and added only a few methods to Tile.
Focus on one feature at a time to reduce risk in your project.
Don’t get distracted with features that won’t help reduce risk.
Q: If the Tile class handles adding and removing units, and you can get the tile at a coordinate from the Board using getTile(), why add those addUnit() and removeUnit() methods to Board.
Couldn’t you just call getTile(), and then use the Tile to do those things?
A: You could take that approach, and let all the Unit-related operations be handled directly through the Tile object returned from getTile()
We decided to add the Unit-related methods to Board, and have Board be the entry point for game designers.
In fact, you’ll see on the next page that we made Tile’s methods protected, so that only classes in the same package as Tile—like Board—could call addUnit() and removeUnit() directly.
So we’ve really ensured that Board is the object used to work with tiles, units, and eventually terrain.
Q: I still think it would be easy to go ahead and add some more of the methods we know we’ll need to Unit and Tile.
Why not spend a little time on those classes now?
A: You’re not trying to code the entire game system framework at this point; you’re just trying to tackle a few key features, and reduce the major risks to your project.
Spending time writing the Unit class, or fleshing out the Tile class, really isn’t going to help you reduce risk.
Instead, do just enough to get the Board class working, because it’s the Board class that we decided was part of the essence of the system, and where we had a risk of failing if we didn’t get that piece in place.
Once you’ve handled your key features, and reduced or eliminated the big risks to your project, then you’ll have plenty of time to work on other features, like the Unit class.
At this stage, though, you’re trying to avoid spending time on anything that doesn’t help you reduce the risks to your project succeeding.
More order, less chaos Our architecture and key feature list has helped us get the basic Board in place, and make sure we’re capturing the essence of  the system for the customer.
Coordinating movement—what is it, and how do we do it?
We’ve got the basic Board written, so we’ve handled this key feature enough to move on to another.
Even better, we’ve got some basic classes in place, and we can start to think about our next key feature, and how it fits into this structure.
Board width: int height: int tiles: Tile [*][*] getTile(int, int): Tile addUnit(Unit, int, int) removeUnit(Unit, int, int) removeUnits(int, int) getUnits(int, int): List.
Even though Board doesn’t have any variables of type Unit, it’s still associated to Unit because of its methods that take in Unit instances.
There are only three classes in the project, but it’s still a lot more structure than what we had before.
We’ve got a Unit class now, so why don’t we tackle “game-specific units” next? Besides, we can also look at how Board and.
With some basic classes written, we can look at how classes interact, as well as begin to build on what we’ve already done.
I build sci-fi games, big huge space and planet battles.
So I need to be able to have armies with lasers and create lots of.
Our customers are all about air battles, so we don’t even need.
I just want to be able to create a bunch of different types of planes, with.
Now that you’ve heard from several of the game designers who want to use Gary’s game system framework, you should have a good idea of what our second key feature is all about.
Write down in the blanks below your idea of what you need to do to support “game-specific units.”
Now that you’ve heard from several of the game designers who want to use Gary’s game system framework, you should have a good idea of what our second key feature is all about.
Write down in the blanks below your idea of what you need to do to support “game-specific units.”
Each game based on the framework has different types of units, with different attributes and capabilities.
So we need to be able to have properties for a unit that are different for each game, and support multiple data types for those properties.
Commonality revisited We’re starting to learn more about what “game-specific units” means, but we still need to figure out how to actually add support for this feature to our game system framework.
Let’s start by taking a look at the different types of  units the customers mentioned, and figure out what’s common between them.
Here are a few of the game-specific units, and their properties, mentioned on the last couple of pages.
What is common among these different types of units? What basic things can we say that would apply to any game’s units?
It also applies to smaller problems, like the game-specific units.
Here’s our Unit class, which has no properties or methods yet.
Anything that’s common to all types of units needs to be put into this class.
It’s your job to figure out what’s common, and should be a part of the basic Unit class, and what varies, and belongs in the game-specific subclasses of Unit.
Write any properties and methods that you think belong in Unit in the class diagram for that class below, and then add properties and methods that you think belong in the game-specific subclasses to those diagrams.
Which of these properties seem to apply to all types of units? Which only belong in a game-specific Unit subclass?
Tank attack: float experience: float defense: float getAttack(): float setAttack(float) ...etc...
Solution #1: It’s all different! At first glance, you might have come up with a solution that looks something like this:
They all have properties, but the properties are different for each unit.
Tanks had a few properties specific to it, so those get added to the Tank class.
Airplane speed: int gun: Weapon model: String getSpeed(): int setSpeed(int) getGun(): Weapon ...etc...
You might have figured out that a Weapon class is a good idea...
You might have put a weapon property up in Unit, since it sounds like most units will have a weapon.
But what about units with more than one weapon? There are still some problems with this approach.
Commonality is about more than just the names of properties...
It might seem like there’s not anything common across all the units used in different games, but let’s take a step back from focusing on the actual names of  the properties for each unit.
So what is common is that a unit has a type and a set of properties, each of which is a simple name/value pair.
Each unit has a different type: there are tanks, soldiers, planes, spaceships, etc.
Tank attack: float experience: float defense: float getAttack(): float setAttack(float) ...etc...
Solution #2: It’s all the same! At first glance, you might have come up with a solution that looks something like this:
Airplane speed: int gun: Weapon model: String getSpeed(): int setSpeed(int) getGun(): Weapon ...etc...
It supports a unit type, and a Map of name/value properties.
There’s no longer a need for lots of Unit subclasses...
Weapons (even multiple weapons per unit), strength, speed, experience, age, and anything else a game designer might need can all be stored in the properties Map.
Commonality analysis: the path to flexible software Wondering why we spent all that time on commonality analysis? Look back at the first solution on page 358, and then again at the second solution, on the left, and then fill out the table below to see what commonality has really bought us in terms of  our design:
This first row is what we’ve looked at so far: 3 different unit types.
With Solution #1, you always had a Unit base class, and a subclass for each unit type.
With Solution #2, the single Unit class supported all types of units, with any number of different types of properties and attributes.
We identified what was common, and put it in the Unit base class.
With a single welldesigned Unit class, we can support any number of different unit types.
By figuring out how best to design the Unit class, we can get it right the first time...
Not only have we figured out what “game-specific units” means, but we’ve defined the basic Unit class, and now other classes like Board can relate to it without worrying about its design drastically changing in the middle or near the end of the project’s development cycle.
We’ve figured out another key feature, reduced risk to our project even further, and only have one feature left to worry about.
Coordinating movement—what is it, and how do we do it?
We’re focusing on doing just the things that reduce risk.
Remember, the point of  architecture is to reduce risk, and to create order.
There are plenty of  other things to work on in your application, but those are for after you’ve got a handle on how your application will be structured, and have the major risks reduced to the point where they are manageable.
This class diagram is all you need at this point.
It gives you the structure of the Unit class, and answers the question, “What does ‘game-specific units’ mean?”
Q: When we worked on the Board, we did code the Board class, but now you say we shouldn’t code the Unit class.
A: The question you need to be always asking at this stage of a project is, “Will this reduce the risk to my project succeeding?” If the answer is yes, you should go ahead; if it’s no, you probably can leave the task for a later stage of the project.
In the case of the Board, we needed to have a basic understanding of what the game board does, so we went ahead and coded a basic implementation.
But for Unit, a class diagram and understanding its basic functionality was all we really needed to do.
In both cases, we were reducing risk to our project, rather than focusing on coding or not coding a certain class or package.
Q: But couldn’t we have just done a class diagram for Board, like we did for Unit, and stopped there?
A: You probably could have just done a class diagram.
It’s really a judgment call, and as long as you feel you’re focusing on reducing the risk in your project, it’s OK to stop with a class diagram, or take things a level or two deeper.
Q: Is it really good to ask the customer and users of a system about what it should do? Couldn’t they lead us astray, or distract us?
A: It’s usually a good idea to ask the customer, because it is their system that you’re building.
And really, the customer is only going to confuse you, or get you working on the wrong thing, if you’re unsure of what you’re supposed to be working on.
As long as you go into a conversation clear on what your goals are, and you’re listening for something specific, you should be able to filter out anything that might confuse or distract you.
Q: I’m still not sure I would have ever come up with using a Map for storing properties in the Unit class on my own.
A: That’s OK; that’s what tools like commonality and the three Qs of architecture are for.
They help you get to solutions that you might not think of on your own, in a way that works on any type of project.
In the case of the Unit class, the point isn’t that we used a Map to store properties.
It’s that we figured out that all units are basically just a unit type and a set of name/value pairs.
Once we figured that out, the details about how we stored those name/value pairs were a piece of cake.
Q: So there’s really not a lot of code involved in OOA&D, is there?
A: OOA&D is all about code—it’s about writing great software, every time.
But the way you get to good code isn’t always by sitting down and writing it right away.
Sometimes the best way to write great code is to hold off on writing code as long as you can.
Sometimes the best way to write great code is to hold off on writing code as long as you can.
But what would you do next to figure that out? Your job is to outline the next few pages of Head First OOA&D, and figure out how you’d take care of this last key feature.
Hint: check out what we did for the last key feature that we weren’t clear on how to get started.
When you’re not sure what a feature really means, one of the best things you can do is ask the customer.
We did this with the game-specific units, so let’s try the same thing for figuring out what coordinating movement means.
Each unit has a movement property that says how many squares it can move, and the game checks the terrain to see if.
They’re cracking up at yet another air game that lets you fly places you shouldn’t be able to.
Do you know what “coordinating movement” means? Listening to the customers should have given you a pretty good idea of  what the third key feature of  Gary’s game system framework is all about.
Write what you think that feature really means in the blanks below:
Now do some commonality analysis Next you need to try and figure out what’s common about the different movement scenarios that the customers on page 366 have been talking about.
Are there some basic things that apply to all the different types of  movement? If you think that there are, write those common things in the blanks below:
So now what would you do? If  you have an understanding of  what “coordinating movement” means, and you know what things are common across all games, you should have an idea about what you need to do to the game framework to make this feature work.
Write your ideas down in this final set of blanks:
You can use these three basic steps anytime you’re unsure about what a feature means, and how you need to implement that feature in your system.
Is there anything common here? Here’s what we thought we needed to do based on what Gary’s customers were saying about movement:
So what exactly is common among all the different possible movement scenarios? Remember what the customers said?
Units should be able to move from one tile on the board to another.
Movement is based on a calculation or algorithm specific to each game, and sometimes involves the game-specific properties of a unit.
Each unit has a movement property that says how many squares it can move, and the game checks the terrain to see if.
In this case, there’s a check to see if a move is legal, and another check of a unit’s movement property.
What’s common? What’s variable? There’s a check prior to a move to see if the move is legal.
The algorithm to check a move’s legality is different for every game.
A unit’s properties are used to see how far the unit can move.
The number and specific properties used are different for every game.
The factors that affect movement are different for every game.
This is where things like wind speed come into play.
It’s “different for every game” Did you see what kept showing up in our chart? Every time we found some commonality, the variability column had the same words: “different for every game.”
When you find more things that are different about a feature than things that are the same, there may not be a good, generic solution.
OK, it seems like you’ve thought things through, so I’m OK.
Q: How is this really that different from game-specific units?
A: With units, we did find some commonality: every unit had a type, and then name/value properties.
With movement, every single game looked like it would handle things differently.
So it made sense to leave movement to the game designers, rather than come up with a solution that was so generic that it was essentially useless.
Q: But there is some commonality, isn’t there? A movement algorithm, and a check to see if a move is legal, right?
So, in theory, you could write a Movement interface, with a method like move() that took in a MovementAlgorithm and a LegalMoveCheck, or something similar.
And then each game designer could extend MovementAlgorithm and LegalMoveCheck.
If you thought of something like this, nice work! You’re really ahead of the game.
But then ask yourself: what does this really gain? Game designers are going to have to learn your interfaces, and if they don’t have a legality check, they might pass in null for the LegalMoveCheck parameter, and what would the interface for MovementAlgorithm look like, and...
Your job is to reduce risk and complexity, not increase it.
We decided that it would be simpler to let game designers handle movement, and just change the position of units on the board (using methods on Board, which we did take care of for them)
Gary, we’ve thought it through, and we think we should let the game.
In the case of Gary’s system, if there’s no generic solution, it really doesn’t belong as part of the game framework.
Great code is well-designed, and generally functions like it’s supposed to.
But great software not only is welldesigned, it comes in on time and does what the customer really wants it to do.
That’s what architecture is about: reducing the risks of  you delivering your software late, or having it not work like the customer wants it to.
Our key feature list, class diagrams, and those partially done classes all help make sure we’re not just developing great code, but that we’re developing great software.
Absolutely! Remember, great software is more than just great code.
Customers don’t pay you for great code, they pay you for great software.
Reducing risk helps you write great software With all three key features figured out, we’ve got a handle on the major risks to our project succeeding.
Look at how each step we’ve taken in this chapter has reduced the risks to our project:
Coordinating movement—what is it, and how do we do it?
Not a chance in hell of coming in on time.
We knew what we needed to build, but not much else.
We figured out the basic classes for the Board, but wrote just enough code to lower the risk of getting the board wrong for the customer.
Next, we figured out what “game-specific units” meant, and planned how we’d handle that feature with a class diagram.
Finally, we used commonality to realize that handling movement was for the game designer to worry about...
We don’t have a lot of code, but we do have a project that we’re confident we can deliver on time, with the right functionality.
Architecture helps you turn all your diagrams, plans, and feature lists into a well-ordered application.
The features in your system that are most important to the project are architecturally significant.
Focus on features that are the essence of your system, that you’re unsure about the meaning of, or unclear about how to implement first.
Everything you do in the architectural stages of a project should reduce the risks of your project failing.
If you don't need all the detail of a use case, writing a scenario detailing how your software could be used can help you gather requirements quickly.
When you're not sure what a feature is, you should ask the customer, and then try and generalize the answers you get into a good understanding of the feature.
Use commonality analysis to build software solutions that are flexible.
Customers are a lot more interested in software that does what they want, and comes in on time, than they are in code that you think is really cool.
Have you gotten every answer so far? Here’s another set of clues to help you store all this architectural info in your brain for good.
Did the requirements we used on page 340 cover everything in the completed scenario? If you think something is missing, write it in the blank below, and then add code to Board.java to handle the missing functionality.
We added a removeUnit() and removeUnits() method to Board.java to handle this requirement.
There’s nothing as satisfying as coming up with a completely new and original.
Originality is Overrated I must have heard that line a thousand times, but it works.
Design principle roundup So far, we’ve really been concentrating on all the things that you do before you start coding your application.
Gathering requirements, analysis, writing out feature lists, and drawing use case diagrams.
Of  course, at some point you actually are going to have to write some code.
You’ve already seen a few design principles in earlier chapters:
In this chapter, we’re going to look at several more key design principles, and how each one can improve the design and implementation of  your code.
We’ll even see that sometimes you’ll have to choose between two design principles...
Let’s begin by looking at the first of our design principles.
A design principle is a basic tool or technique that can be applied to designing or writing code to make that code more maintainable, flexible, or extensible.
Each class in your application should have only one reason to change.
Using proven OO design principles results in more maintainable, flexible, and extensible software.
The OCP is all about allowing change, but doing it without requiring you to modify existing code.
Suppose you have a class with a particular behavior, and you’ve got that behavior coded up just the way you want it.
Make sure that nobody can change your class’s code, and you’ve made that particular piece of  behavior closed for modification.
In other words, nobody can change the behavior, because you’ve locked it up in a class that you’re sure won’t change.
You really don’t want them messing with your perfect code, which works well in almost every situation...
So you let them subclass your class, and then they can override your method to work like they want it to.
So even though they didn’t mess with your working code, you still left your class open for extension.
Classes should be open for extension, and closed for modification.
You close classes by not allowing anyone to touch your working code.
You open classes by allowing them to be subclassed and extended.
Remember working on Rick’s Stringed Instruments? You probably didn’t realize it, but we were using the OpenClosed Principle when we wrote those InstrumentSpec classes for Rick’s Stringed Instruments, back in Chapter 5:
InstrumentSpec is closed for modification; the matches() method is defined in the base class and doesn’t change.
But it’s open for extension, because all of the subclasses can change the behavior of matches()
The parts of matches() that change across subclasses are encapsulated away from the InstrumentSpec base class.
The OCP, step-by-step Let’s take what we did back in Chapter 5, and look at in terms of  the OCP, one step at a time.
This version of matches() works just fine, and we don’t want anyone messing with it.
In other words, once we’re done coding InstrumentSpec and this version of matches(), they shouldn’t change.
Even though matches() works great for other InstrumentSpec objects, it doesn’t quite do what it should for guitars and mandolins.
So even though matches() is closed for modification, we need a way to extend and change it...
So we extended InstrumentSpec, and overrode matches() to change its behavior.
Really, this is supposed to be some sort of great.
It’s certainly true that inheritance is a simple example of  the open-closed principle, but there’s a lot more to it than just subclassing and overriding a method.
Anytime you write working code, you want to do your best to make sure that code stays working...
But there are going to be times when that code still needs to be changed, maybe for just one or two particular situations.
Rather than just diving into your code and making a bunch of  changes, the OCP lets you extend your working code, without changing that code.
There are lots of  different ways to accomplish this, and while inheritance is often the easiest to implement, it’s certainly not the only option.
In fact, we’ll talk about another great way to achieve this later in the chapter, when we talk about composition.
The OCP is about flexbility, and goes beyond just inheritance.
Q: What’s the big deal about modifying code in a base class, or a class that you’ve already written?
A: Once you have a class that works, and is being used, you really don’t want to make changes to it unless you have to.
But remember, CHANGE is the great constant in software development.
With the OCP, we allow for change through extension, rather than having to go back and modify your existing code.
Subclasses can add and extend the base class’s behavior, without messing around with code that you already know is working and making the customer happy.
You’re finding the behavior that stays the same, and abstracting that behavior away into a base class, and then locking that code up from modification.
But then when you need new or different behavior, your subclasses handle the changes by extending the base class.
That’s where encapsulation comes in: you’re encapsulating what varies (behavior in the subclasses) away from what stays the same (the common behavior in the base class)
Q: So the only way to use the OCP is by extending another class?
A: No, anytime your code is closed for modification but open for extension, you’re using the OCP.
So for example, if you had several private methods in a class, those are closed for modification—no other code can mess with them.
But then you could add several public methods that invoked those private methods in different ways.
You’re extending the behavior of the private methods, without changing them.
Can you find any places where you’ve used the OCP already? If so, write how you used the OCP in the blanks below:
Now think about a place in your project where you should be using the Open-Closed Principle, but you aren’t yet.
Write down in the blanks below what you think you need to do to put the OCP into place in your current project:
This is another principle that looks pretty simple, but turns out to be critical in writing code that’s easy to maintain and reuse.
Avoid duplicate code by abstracting out things that are common and placing those things in a single location.
You’ve seen the DRY principle in action, even if  you didn’t realize it.
We used DRY back in Chapter 2, when Todd and Gina wanted us to close the dog door automatically after it had been opened.
Remember when we had code in the Remote class to automatically close the dog door once it had been opened?
Using DRY, we pull out all this code from Remote and BarkRecognizer, and put it in ONE place: the DogDoor class.
Using DRY, we first need to take the code that’s common between Remote and BarkRecognizer, and put it in a single place.
We figured out back in Chapter 2 the best place for it was in the DogDoor class:
Remove all the code that you put in a single place in Step #1, and then reference the code you abstracted out explicitly if  you need to:
We don’t have to explicitly call the code we abstracted out...
When you’re trying to avoid duplicate code, you’re really trying to make sure that you only implement each feature and requirement in your application one single time.
In the dog door we just looked at, the feature we were trying to implement was automatically closing the door.
But more importantly, we moved the implementation of  this requirement, automatically closing the door, into one place, instead of  two places:
Once the dog door has opened, it should close automatically if the door isn’t already closed.
Q: So DRY isn’t about duplicate code, and avoiding copy-and-paste?
A: DRY is about avoiding duplicate code, but it’s also about doing it in a way that won’t create more problems down the line.
Rather than just tossing code that appears more than once into a single class, you need to make sure each piece of information and behavior in your system has a single, clear place where it exists.
That way, your system always knows exactly where to go when it needs that information or behavior.
Q: If DRY is related to our features and requirements, then shouldn’t we apply it to gathering those features and requirements as well as writing our code?
A: Absolutely, and that’s a great idea! Whether you’re writing requirements, developing use cases, or coding, you want to be sure that you don’t duplicate things in your system.
A requirement should be implemented one time, use cases shouldn’t have overlap, and your code shouldn’t repeat itself.
Q: And this is all to avoid maintenance problems later, right?
But it’s more than just avoiding a need to update code in more than one place.
Remember, DRY is about having a single source for a particular piece of information or behavior.
But that single source has to make sense! You wouldn’t want the bark recognizer to be the single source for closing the dog door, would you? Do you think the dog door should be asking the recognizer to close itself? So DRY is not just removing duplication, it’s also about making good decisions about how to break up your system’s functionality.
Read through the requirements and features list on the right.
We’ve bolded the requirements and features that have been added since you last worked on the dog door.
Look through the new features and requirements, and see if  you see any possible duplication in the new things you’d need to build.
Annotate the requirements and features list indicating what you think has been duplicated.
Rewrite the duplicate requirements at the bottom of  the list so that there is no more duplication.
Todd and Gina have come up with yet more features for their dog door.
It’s your job to make sure the feature list we’ve assembled doesn’t have any duplication issues, and that each feature is handled once and only once in the system you’re designing for them.
Write your own definition for DRY that includes what you’ve learned over the last few pages.
Once the dog door has opened, it should close automatically if the door isn’t already closed.
A bark recognizer must be able to tell when a dog is barking.
The bark recognizer must open the dog door when it hears barking.
The dog door should alert the owner when something inside the house gets too close for the door to open without knocking it over.
The dog door will open during certain hours of the day.
The dog door can be integrated into the house’s overall alarm system to ensure the alarm doesn’t go off when the dog door opens and closes.
The dog door should make a noise if the door cannot open because of a blockage outside.
The dog door will track how many times the dog enters and leaves the inside of the house.
When the dog door closes, the household alarm system re-arms if it was active before the door opened.
Read through the requirements and features list on the right.
We’ve bolded the requirements and features that have been added since you last worked on the dog door.
Look through the new features and requirements, and see if  you see any possible duplication in the new things you’d need to build.
Annotate the requirements and features list indicating what you think has been duplicated.
Rewrite the duplicate requirements at the bottom of  the list so that there is no more duplication.
Todd and Gina have come up with yet more features for their dog door.
It’s your job to make sure the feature list we’ve assembled doesn’t have any duplication issues, and that each feature is handled once and only once in the system you’re designing for them.
Once the dog door has opened, it should close automatically if the door isn’t already closed.
A bark recognizer must be able to tell when a dog is barking.
The bark recognizer must open the dog door when it hears barking.
The dog door should alert the owner when something inside the house gets too close for the door to open without knocking it over.
The dog door will open during certain hours of the day.
The dog door can be integrated into the house’s overall alarm system to ensure the alarm doesn’t go off when the dog door opens and closes.
The dog door should make a noise if the door cannot open because of a blockage outside.
The dog door will track how many times the dog enters and leaves the inside of the house.
When the dog door closes, the household alarm system re-arms if it was active before the door opened.
The door alerts the owner if there is an obstacle inside or outside of the house that stops the door from operating.
When the door opens, the house alarm system will disarm, and when the door closes, the alarm system will re-arm (if the alarm system is turned on)
Principle #3: The Single Responsibility Principle (SRP) The SRP is all about responsibility, and which objects in your system do what.
You want each object that you design to have just one responsibility to focus on—and when something about that responsibility changes, you’ll know exactly where to look to make those changes in your code.
Every object in your system should have a single responsibility, and all the object’s services should be focused on carrying out that single responsibility.
You’ve implemented the Single Responsibility Principle correctly when each of your objects has only one reason to change.
Aren’t both about a class doing the one thing it’s supposed to do?
In good applications, one class does one thing, and does it well, and no other classes share that behavior.
Q: Isn’t having each class do only one thing kind of limiting?
A: It’s not, when you realize that the one thing a class does can be a pretty big thing.
For example, the Board class in Gary’s Games does a lot of different small tasks, but they’re all related to a single big thing: handling the board in a game.
It does that one thing, and that’s all the Board class does, so it’s a great example of using the SRP.
Q: And using SRP will help my classes stay smaller, since they’re only doing one thing, right?
A: Actually, the SRP will often make your classes bigger.
Since you’re not spreading out functionality over a lot of classes—which is what many programmers not familiar with the SRP will do—you’re often putting more things into a class.
But using the SRP will usually result in less classes, and that generally makes your overall application a lot simpler to manage and maintain.
Q: This sounds a lot like cohesion, are they the same thing?
A: Cohesion is actually just another name for the SRP.
If you’re writing highly cohesive software, then that means that you’re correctly applying the SRP.
Spotting multiple responsibilities Most of  the time, you can spot classes that aren’t using the SRP with a simple test:
On a sheet of  paper, write down a bunch of  lines like this: The [blank] [blanks] itself.
You should have a line like this for every method in the class you’re testing for the SRP.
Read each line out loud (you may have to add a letter or word to get it to read normally)
Does what you just said make any sense? Does your class really have the responsibility that the method indicates it does?
If what you’ve just said doesn’t make sense, then you’re probably violating the SRP with that method.
Write the class name in this blank, all the way down the sheet.
Write each method from the class in this blank, one per line.
Automobile start() stop() changeTires(Tire [*]) drive() wash() checkOil() getOil(): int.
Do an SRP analysis on the Automobile class shown below.
Fill out the sheet with the class name methods in Automobile, like we’ve described on the last page.
Then, decide if you think it makes sense for the Automobile class to have each method, and check the right box.
Yes, we realize you can peek back at Chapter 5 and cheat here, but we’re trusting you not to.
Try the exercise on your own first, and only look back at what we did in Chapter 5 if you get stuck.
If what you read doesn’t make sense, then the method on that line is probably violating the SRP.
You may have to add an “s” or a word or two to make the sentence readable.stop[s]
Your job was to do an SRP analysis on the Automobile class shown below.
You should have filled out the sheet with the class name methods in Automobile, and decided if you think it makes sense for the Automobile class to have each method.
It makes sense that the automobile is responsible for starting, and stopping.
An automobile is NOT responsible for changing its own tires, washing itself, or checking its own oil.
You should have thought carefully about this one, and what “get” means.
This is a method that just returns the amount of oil in the automobile...
Cases like this are why SRP analysis is just a guideline.
You still are going to have to make some judgment calls using common sense and your own experience.
Going from multiple responsibilities to a single responsibility Once you’ve done an analysis, you can take all the methods that don’t make sense on a class, and move those methods to classes that do make sense for that particular responsibility.
Automobile start() stop() changeTires(Tire [*]) drive() wash() checkOil() getOil(): int.
We used our analysis to figure out that these four methods really aren’t the responsibility of Automobile.
It’s a driver’s responsibility to drive the car, not the automobile itself.
A mechanic is responsible for changing tires and checking the oil on an automobile.
Now Automobile has only a single responsibility: dealing with its own basic functions.
Q: How does SRP analysis work when a method takes parameters, like wash(Automobile) on the CarWash class?
A: Good question! For your SRP analysis to make any sense, you need to include the parameter of the method in the method blank.
So you would write “The CarWash washes [an] automobile itself.” That method makes sense (with the Automobile parameter), so it would stay on the CarWash class.
Q: But what if CarWash took in an Automobile parameter as part of its constructor, and the method was just wash()? Wouldn’t SRP analysis give you a wrong result?
If a parameter that might cause a method to make sense, like an Automobile for the wash() method on CarWash, is passed into a class’s constructor, your SRP analysis might be misleading.
But that’s why you always need to apply a good amount of your own common sense and knowledge of the system in addition to what you learn from the SRP analysis.
How do you think the Single Responsibility Principle was used in Todd and Gina’s dog door? Write your answer in the blanks below:
Now see if you can find two more instances in the book’s examples so far where we’ve used the SRP to make our design better and more flexible.
You can find the SRP in the dog door, Rick’s instrument inventory searcher, or Gary’s game framework.
Write down each instance you found, and how you think the SRP is being used.
Check off which example application you found the SRP being used in.Write in how.
Here are the SRP sightings we came up with; see if  your answers are similar.
How do you think the Single Responsibility Principle was used in Todd and Gina’s dog door? Write your answer in the blanks below:
Now see if you can find two more instances in the book’s examples so far where we’ve used the SRP to make our design better and more flexible.
You can find the SRP in the dog door, Rick’s instrument inventory searcher, or Gary’s game framework.
Write down each instance you found, and how you think the SRP is being used.
We also made sure that the DogDoor class handled all tasks relating to the operation of the dog door—it has that single responsibility.
We created a matches() method on InstrumentSpec, rather than leaving the code to compare instruments in the search() method of Inventory.
So an InstrumentSpec handles everything related to an instrument’s propertiesthat code isn’t spread out over other classes.
When we used a Map to store properties for all types of units in the Unit class, we were using the SRP.
So instead of having game-specific Units have to deal with their properties, and still have the base Unit class dealing with a different set of properties, we moved all property-related functionality into the nit class.
So handling the properties feature is taken care of in ONE single place—the Unit class.
Here’s what we wrote about how SRP (and DRY) helped us out with the dog door.
Just make sure the SRP was applied in similar ways to the ones we wrote down here, and.
When you inherit from a base class, you must be able to substitute your subclass for that base class without things going terribly wrong.
OK, earlier you convinced me that the OCP is more than just.
Substitute, exchange, it doesn’t rattle me, They all work the same, they use the LSP!
Misusing subclassing: a case study in misusing inheritance Suppose that Gary’s Games has a new client who wants to use their game system framework to create World War II air battles.
They need to take the basic Board base type, and extend it to support a 3-dimensional board to represent the sky.
The game designers subclassed Board and created a new type, 3DBoard.
Board width: int height: int tiles: Tile [*][*] getTile(int, int): Tile addUnit(Unit, int, int) removeUnit(Unit, int, int) removeUnits(int, int) getUnits(int, int): List.
When 3DBoard subclasses Board, it gets all of these methods, in addition to the new methods it defines.
But these are the methods that work with (x,y,z) coordinates...
All of these methods, that are inherited from Board don’t have any meaning in a 3D context.
But look closer, there are lots of  problems that this approach creates:
Board width: int height: int tiles: Tile [*][*] getTile(int, int): Tile addUnit(Unit, int, int) removeUnit(Unit, int, int) removeUnits(int, int) getUnits(int, int): List.
But what does that really mean? Technically, it doesn’t seem to be a problem:
But when you start to actually use that instance of  3DBoard like a Board, things can get confusing very fast:
So even though 3DBoard is a subclass of  Board, it’s not substitutable for Board...
Even worse, it’s not clear what meaning those methods do have!
From the compiler’s point of view, 3DBoard can be used in place of a Board here.
Remember, board here is actually an instance of the subtype, 3DBoard.
Board width: int height: int tiles: Tile [*][*] getTile(int, int): Tile addUnit(Unit, int, int) removeUnit(Unit, int, int) removeUnits(int, int) getUnits(int, int): List.
But what do these methods mean for 3DBoard? They probably don’t mean anything!
Inheritance (and the LSP) indicate that any method on Board should be able to be used on 3DBoard...
Some bit of code calls a method from Board, but on an instance of 3DBoard.
Violating the LSP makes for confusing code It might seem like this isn’t such a big deal, but code that violates LSP can be confusing, and a real nightmare to debug.
Let’s think a bit about someone who comes to use the badly designed 3DBoard for the first time.
They probably start out by checking out the class’s methods:
Even though some of these methods aren’t defined on 3DBoard, they’re all inherited from the base class, Board.
Hmm, I’m not sure which version of getTile() and addUnit() to.
Maybe those methods take an X- and Y-coordinate for the current board...
When you use inheritance, your subclass gets all the methods from its superclass, even if you don’t want those methods.
And if  you’ve used inheritance badly, then you’re going to end up with a lot of  methods that you don’t want, because they probably don’t make sense on your subclass.
So what can you do to avoid this? First, be sure your subclasses can substitute for their base types, which is just following the LSP.
Second, learn about some alternatives to using inheritance in your code...
Solving the 3DBoard problem without using inheritance It’s not enough to just know that inheritance isn’t the answer...
So 3DBoard can use the behavior of Board, without having to extend from it and violate the LSP.
DBoard can store an array of Board objects, and end up with a 3D collection of boards.
The 3DBoard methods use the zpos coordinate to figure out which Board instance in the array to use, and then delegates the (x,y) coords to that Board’s functions.
The 3DBoard class delegates a lot of its functionality to the individual Board instances.
These methods look a lot like the methods in Board, but they need to use the functionality in Board, rather than extend it.
Board width: int height: int tiles: Tile [*][*] getTile(int, int): Tile addUnit(Unit, int, int) removeUnit(Unit, int, int) removeUnits(int, int) getUnits(int, int): List.
Delegate functionality to another class You’ve already seen that delegation is when one class hands off  the task of  doing something to another class.
Delegation was what we used to solve the 3DBoard problem we’ve been looking at, without resorting to inheritance:
Delegation is when you hand over the responsibility for a particular.
DBoard delegates functionality related to specific boards to the Board class.
Board width: int height: int tiles: Tile [*][*] getTile(int, int): Tile addUnit(Unit, int, int) removeUnit(Unit, int, int) removeUnits(int, int) getUnits(int, int): List.
When to use delegation Delegation is best used when you want to use another class’s functionality, as is, without changing that behavior at all.
In the case of  3DBoard, we wanted to use the various methods in the Board class:
Since we don’t want to change the existing behavior, but we do want to use it, we can simply create a delegation relationship between 3DBoard and Board.
DBoard stores multiple instances of  Board objects, and delegates handling each individual board-related task.
If you need to use functionality in another class, but you don’t want to change that functionality, consider using delegation instead of inheritance.
Board width: int height: int tiles: Tile [*][*] getTile(int, int): Tile addUnit(Unit, int, int) removeUnit(Unit, int, int) removeUnits(int, int) getUnits(int, int): List.
Board width: int height: int tiles: Tile [*][*] getTile(int, int): Tile addUnit(Unit, int, int) removeUnit(Unit, int, int) removeUnits(int, int) getUnits(int, int): List.
Now 3DBoard uses the z coordinate to get a Board instance in its array, and then delegates to a method on that Board using the supplied x and y coordinates.
Use composition to assemble behaviors from other classes Sometimes delegation isn’t quite what you need; in delegation, the behavior of  the object you’re delegating behavior to never changes.
DBoard always uses instances of  Board, and the behavior of  the Board methods always stay the same.
But in some cases, you need to have more than one single behavior to choose from.
For example, suppose we wanted to develop a Weapon interface, and then create several implementations of  that interface that all behave differently:
Now we need to use the behavior from these classes in our Unit class.
One of  the properties in our properties Map will be “weapon”, and the value for that property needs to be an implementation of  the Weapon class.
But a Unit might change weapons, so we don’t want to tie the weapon property to a specific implementation of  Weapon; instead, we just want each Unit to be able to reference a Weapon, regardless of  which implementation of  Weapon we want to use.
We don’t want to be stuck with one particular weapon...
When to use composition When we reference a whole family of  behaviors like in the Unit class, we’re using composition.
The Unit’s weapons property is composed of  a particular Weapon implementation’s behavior.
Composition is most powerful when you want to use behavior defined in an interface, and then choose from a variety of  implementations of  that interface, at both compile time and run time.
Composition allows you to use behavior from a family of other classes, and to change.
These subclasses of Weapon are all substitutable for Weapon, so inheritance is a good choice in this case.
A Unit has a Weapon, and uses the functionality of that class.
But we don’t want a bunch of Unit subclasses for each type of weapon, so composition is better than inheritance for the relationship between Unit and Weapon.
Pizza is actually a great example of composition: it’s composed of different ingredients, but you can swap out different ingredients without affecting the overall pizza slice.
There’s one important point we haven’t mentioned so far about composition.
When an object is composed of  other objects, and the owning object is destroyed, the objects that are part of  the composition go away, too.
That’s a little confusing, so let’s take a closer look at what that actually means.
Here’s our Unit class again, which has a composition relationship to the Weapon interface and its implementations:
Suppose we create a new Unit, and assign its weapon property to an instance of  Sword:
What happens if  this Unit is destroyed? Obviously, the pirate variable is trashed, but the instance of  Sword referenced by pirate is also thrown away.
This Sword object does not exist outside of the context of this particular Unit.
In composition, the object composed of other behaviors owns those behaviors.
When the object is destroyed, so are all of its behaviors.
The behaviors in a composition do not exist outside of the composition itself.
Can you think of an example where the ownership aspect of composition would be a negative in your application? When might you want the composed objects to exist outside of the composing class?
InstrumentSpec is used as part of an Instrument, but the spec can also exist outside of an Instrument (like when it’s supplied by a customer for searching)
A line with an open diamond at the end means aggregation.
We were able to avoid all those instrumentspecific subclasses by using aggregation here.
Instrument serialNumber: String price: double getSerialNumber(): String getPrice(): double setPrice(float) getSpec(): InstrumentSpec.
Aggregation is when one class is used as part of another class, but still exists outside of that other class.
The ice cream, bananas, and cherries exist outside of a banana split.
Take away that fancy container, and you’ve still got the individual components.
Aggregation versus composition It’s easy to get confused about when you should use composition, and when you should use aggregation.
The easiest way to figure this out is to ask yourself, Does the object whose behavior I want to use exist outside of  the object that uses its behavior?
If  the object does make sense existing on its own, then you should use aggregation; if  not, then go with composition.
But be careful! Sometimes the slightest change in the usage of  your objects can make all the difference.
Five-Minute Mystery Joel leaned back in his seat, arched his back, and thought again about buying that new Aeron chair once his stock options came in.
Being a game programmer was hard work, and Joel was the last coder in the office yet again.
He pulled up the user guide for Gary’s Game System Framework, and started to think about how he was going to implement the cowboys, one of  the last features he had to deal with.
Joel created Lasso, Revolver, and BrandingIron classes, and made sure they all implemented the.
He even added a Weapon property to his Building class, so the cowboys could hang their gear up at the end of  long days chasing the cows.
Little did Joel know that when he got back into work the next day, Brad would be yelling at him, instead of  congratulating him...
Inheritance is just one option We started out this section talking about the LSP, and the basic idea that subclasses must be substitutable for their base classes.
More importantly, though, now you have several ways to reuse behavior from other classes, beyond inheritance.
Let’s take a quick look back at our options for reusing behavior from other classes, without resorting to subclassing.
Delegate behavior to another class when you don’t want to change the behavior, but it’s.
You can reuse behavior from one or more classes, and in particular from a family of classes, with composition.
When you want the benefits of  composition, but you’re using behavior from an object that does exist outside of  your object, use aggregation.
If you favor delegation, composition, and aggregation over inheritance, your software will usually be more flexible, and easier to maintain, extend, and reuse.
A: No, subclassing and inheritance are key to any good OO programming language.
The LSP is not about subclassing, though; it’s about when to subclass.
If your subclass really is substitutable for its base type, then you’ve probably done a good job using inheritance.
If your subclass is not substitutable for its base type, then you might look at other OO solutions like aggregation or delegation.
Q: But it is OK to use delegation, composition, or aggregation in a class that really shouldn’t extend another class?
In fact, the LSP doesn’t apply at all to aggregate or delegate classes, because those are two great ways to fix an inheritance tree that doesn’t conform to the LSP.
You might even say that good use of the LSP goes hand-in-hand with more delegation, composition, and aggregation.
Q: Do we really need to apply the LSP all the time to figure this out? Isn’t this just writing good OO software?
A:  Lots of times, you don’t need to worry about the formal name of a design principle to write good code.
Q: There were a lot of weird UML symbols in there.
How am I supposed to remember what they all mean?
A: You really don’t need to memorize these symbols at all.
While UML provides specific notation for aggregation and composition, they are all just different forms of association.
So just like we did with delegation, you can use a normal line with an arrow, a normal association, for composition and aggregation.
Q: But won’t that be confusing to developers if they don’t know what type of association should be used?
A: That’s possible, but it also allows for a lot more flexibility.
Suppose that you decide later on that when an army is destroyed, you don’t want the individual units destroyed as well.
So you might change the relationship between army and unit from composition to aggregation.
If you’re using a basic association arrow, you won’t need to change your class diagram at all.
It also gives the developer freedom to come up with their own ideas about how to implement the association.
There’s nothing wrong with using the aggregation and composition symbols, but you shouldn’t get too hung up on it, especially if you’re early on in the development cycle.
You never know what might change later, and flexibility is always better than rigidity in your design.
Who Am I? A bunch of classes involved in OO principles, all in full costume, are playing a party game, “Who Am I?” They give a clue, and you try to guess who they are, based on what they say.
If they happen to say something that could be true for more than one of them, choose all for whom that sentence can apply.
Fill in the blanks next to the sentence with the names of one or more attendees.
My behavior is used as part of another class’s behavior.
I’m not gonna go away, even if other related classes do.
I get my behavior and functionality from my base type.
The Open-Closed Principle keeps your software reusable, but still flexible, by keeping classes open for extension, but closed for modification.
With classes doing one single thing through the Single Responsibility Principle, it’s even easier to apply the OCP to your code.
When you’re trying to determine if a method is the responsibility of a class, ask yourself, Is it this class’s job to do this particular thing? If not, move the method to another class.
Once you have your OO code nearly complete, be sure that you Don’t Repeat Yourself.
You’ll avoid duplicate code, and ensure that each behavior in your code is in a single place.
The Liskov Substitution Principle ensures that you use inheritance correctly, by requiring that subtypes be substitutable for their base types.
When you find code that violates the LSP, consider using delegation, composition, or aggregation to use behavior from other classes without resorting to inheritance.
If you need behavior from another class but don’t need to change or modify that behavior, you can simply delegate to that class to use the desired behavior.
Composition lets you choose a behavior from a family of behaviors, often via several implementations of an interface.
When you use composition, the composing object owns the behaviors it uses, and they stop existing as soon as the composing object does.
Aggregation allows you to use behaviors from another class without limiting the lifetime to those behaviors.
Aggregated behaviors continue to exist even after the aggregating object is destroyed.
Tools for your OOA&D Toolbox We’ve got a lot more OO principles to add to.
Let’s add what we’ve learned to our notes—and remember: these principles are best.
Good requirements ensure your system works like your customers expect.
Make sure your requirements are complete by developing use cases for your system.
Use your use cases to find out about things your customers forgot to tell you.
Your use cases will reveal any incomplete or missing requirements that you might have.
Use basic OO principles like encapsulation and inheritance to make your software more flexible.
If a design isn’t flexible, then CHANGE IT! Never settle on bad design, even if it’s your bad design that has to change.
Make sure each of your classes is cohesive: each of your classes should focus on doing ONE THING really well.
Always strive for higher cohesion as you move through your software’s design lifecycle.
Analysis and Design Listen to the customer, and figure out what they want you to build.
Put together a feature list, in language the customer understands.
Make sure your features are what the customer actually wants.
Create blueprints of the system using use case diagrams (and use cases)
Break the big system up into lots of smaller sections.
Apply design patterns to the smaller sections of the system.
Use basic OOA&D principles to design and code each smaller section.
Each class in your application should have only one reason to change.
Classes should be open for extension, but closed for modification (the OCP)
Avoid duplicate code by abstracting out things that are common and placing them in a single location (the DRY principle)
Every object in your system should have a single responsibility, and all the object’s services should be focused on carrying out that single responsibility (the SRP) Subclasses should be suitable for their base classes (the LSP)
This one is a particularly tough puzzle: almost all the answers are more than one word.
A bunch of classes involved in OO principles, all in full costume, are playing a party game, “Who Am I?” They give a clue, and you try to guess who they are, based on what they say.
If they happen to say something that could be true for more than one of them, choose all for whom that sentence can apply.
Fill in the blanks next to the sentence with the names of one or more attendees.
My behavior is used as part of another class’s behavior.
I’m not gonna go away, even if other related classes do.
I get my behavior and functionality from my base type.
This is a basic delegation definition, but a class that uses composition uses other classes for behavior, also.
A subclass is the only class that changes another class’s behavior.
In aggregation and delegation, object instances are tied together, but not dependent on each other for their existence.
Five-Minute Mystery Solved Joel’s big mistake was revealed in this line:
He even added a Weapon property to his Building class, so the cowboys could hang their gear up at the end of long days chasing the cows.
When Joel decided that cowboys could hang up their weapons, he committed to the Lasso, Revolver, and BrandingIron classes existing outside of  any individual Unit instance.
No cowboy owned the gear; they just used the behavior of  the gear for a time.
Since the Weapon implementations exist outside of  a specific cowboy, Joel should have used aggregation instead of  composition.
Different cowboys could use the same Weapon implementation at different times, and those weapons should stay in existence, even if the cowboy using them was trampled by a mad cow.
It’s time to show the customer how much you really care.
Nagging bosses? Worried clients? Stakeholders that keep asking, “Will it be done on time?” No amount of well-designed code will please.
Oh, Jim! You really do care about what I want, don’t you?
I spent forever wondering what I could give you to show.
Your toolbox is filling up We’ve learned quite a bit so far, and our toolbox of  analysis and design tools is getting pretty full.
We even added some OO programming techniques  in the last chapter:
Good requirements ensure your system works like your customers expect.
Make sure your requirements are complete by developing use cases for your system.
Use your use cases to find out about things your customers forgot to tell you.
Your use cases will reveal any incomplete or missing requirements that you might have.
Use basic OO principles like encapsulation and inheritance to make your software more flexible.
If a design isn’t flexible, then CHANGE IT! Never settle on bad design, even if it’s your bad design that has to change.
Make sure each of your classes is cohesive: each of your classes should focus on doing ONE THING really well.
Always strive for higher cohesion as you move through your software’s design lifecycle.
Listen to the customer, and figure out what they want you to build.
Put together a feature list, in language the customer understands.
Make sure your features are what the customer actually wants.
Create blueprints of the system using use case diagrams (and use cases)
Break the big system up into lots of smaller sections.
Apply design patterns to the smaller sections of the system.
Use basic OOA&D principles to design and code each smaller section.
Classes should be open for extension, but closed for modification (the OCP)
Avoid duplicate code by abstracting out things that are common and placing them in a single location (the DRY principle)
Every object in your system should have a single responsibility, and all the object’s services should be focused on carrying out that single responsibility (the SRP) Subclasses should be suitable for their base classes (the LSP)
Make sure your software does what the customer wants it to do.
We’ve got a whole slew of principles and techniques to gather requirements, analyze and design, and solve all types of software problems.
All the tools and techniques you’ve been learning are terrific...
And most of the time, your customer won’t care about all the OO principles and diagrams you create.
They just want the software to work the way that it’s supposed to.
Gary, from Gary’s Games, is ready to see his game system framework in action.
Joe: Yeah, maybe we shouldn’t have spent all this time on so many diagrams, and all this architecture stuff.
We’ve got nothing to show Gary except a bunch of  ovals with things like “Play Game” written inside them.
Jill: Well, sure, but that’s the only class we’ve written any code for.
Joe: Well, I guess we could write the Unit class pretty easily, since we did that class diagram.
So it wouldn’t take a lot more time to write the code for that class.
And, really, we know how to write all of  these classes.
We can just take each class, or even an entire package, and apply all those OO principles and analysis and design techniques to each chunk of  functionality.
We don’t have time for a bunch more big-picture analysis and design.
Frank: But that’s just the thing, Jill: we don’t need to change what we’re doing, we just need to iterate deeper.
Frank: It just means we keep doing analysis and design, but now on each individual part of  Gary’s game system framework.
Jill: And as we build up the application, we’ll have lots of  pieces working that we can show to Gary, right?
Joe: And we get to use all these tools we’ve got to make sure the software is well-designed, too, right?
Work on the big picture, and then iterate over pieces of the app until it’s complete.
Iterating deeper: two basic choices When it comes to developing software, there is more than one way to iterate into specific parts of  your application.
You’ve got to take on smaller pieces of  functionality, but there are two basic approaches to figuring out which small pieces to work on—and even what a “small piece” means in terms of  your application.
You can choose to focus on specific features of the application.
This approach is all about taking one piece of functionality that the customer wants, and working on that functionality until it’s complete.
You can also choose to focus on specific flows through the application.
This approach takes a complete path through the application, with a clear start and end, and implements that path in your code.
Because requirements come from the customer, both approaches focus on delivering what the customer wants.
Feature driven development When you’re using feature driven development, you work on a single feature at a time, and then iterate, knocking off  features one at a time until you’ve finished up the functionality of  an application.
The framework supports different time periods, including fictional periods like scifi and fantasy.
The framework supports multiple types of troops or units that are game-specific.
The framework supports add-on modules for additional campaigns or battle scenarios.
The framework provides a board made up of square tiles, and each tile has a terrain type.
With feature driven development, you pick a single feature, and the focus is on the feature list of your app.
So we might take feature #1, and work on the Terrain class, as well as the Tile class, to support different types of terrain.
All these other plans and diagrams are used, but your feature list is the focus.
Use case driven development With use case driven development, you work on completing a single scenario through a use case.
Then you take another scenario and work through it, until all of  the use case’s scenarios are complete.
Then you iterate to the next use case, until all your use cases are working.
The framework supports different time periods, including fictional periods like sci-fi and fantasy.
The framework supports add-on modules for additional campaigns or battle scenarios.
The framework provides a board made up of square tiles, and each tile has a terrain type.
Here, you could take the Create Board use case, and figure out all the scenarios for that use case, and write code to handle all of them.
What’s the difference between feature driven and use case driven development?
Works well when you have a lot of different features that don’t interconnect a whole lot.
You’re not going to forget about any features using feature driven development.
You’ll code for all the different ways a user can use your system with use case driven development.
Works well when your app has lots of processes and scenarios rather than individual pieces of functionality.
Allows you to show the customer bigger pieces of functionality at each stage of development.
Works particularly well on systems with lots of disconnected pieces of functionality.
Works particularly well on transactional systems, where the system is largely defined by lengthy, complicated processes.
You’ll be working on pretty major chunks of code at a time, since a single scenario often involves a lot of functionality.
A single feature is often pretty small, and every application has a lot of them.
Welcome to “Name That Approach!” Below are several statements, and each one is about a particular approach to iterating over parts of your system.
Your job is to figure out which approach each statement refers to.
Note that sometimes, a statement might apply to both approaches.
This approach deals with really small pieces of your application at a time.
This approach lets you focus on just a part of your application at a time.
This approach is all about a complete process in your application.
Using this approach, you can always test to see if you’ve completed the part of the application you’re working on.
When you use this approach, your focus is on a diagram, not a list.
Welcome to “Name That Approach!” Below are several statements, and each one is about a particular approach to iterating over parts of your system.
Your job is to figure out which approach each statement refers to.
Note that sometimes, a statement might apply to both approaches.
This approach deals with really small pieces of your application at a time.
This approach lets you focus on just a part of your application at a time.
This approach is all about a complete process in your application.
Using this approach, you can always test to see if you’ve completed the part of the application you’re working on.
When you use this approach, your focus is on a diagram, not a list.
Let’s use feature driven development Since Gary’s losing patience, let’s go with feature driven development.
We can take just a single feature and work it through to completion, and it shouldn’t take as much time as it would to write the code to support an entire use case.
Anytime you’ve got a customer impatient to see results, you should consider feature driven development, and starting with a feature you’ve already done some work on.
If you decided to go with use case driven development, what would you start working on first?
The framework supports different time periods, including fictional periods like scifi and fantasy.
The framework supports multiple types of troops or units that are game-specific.
The framework supports add-on modules for additional campaigns or battle scenarios.
The framework provides a board made up of square tiles, and each tile has a terrain type.
We already have the class diagram for Unit, so let’s write the code for that class, and knock off feature #3
We also know that most of our other features depend on this class, so that makes it an even better candidate to start with.
Analysis of a feature Once you’ve decided on a feature to start with, you’ve got to do some more analysis.
Let’s start with what we had written down on the feature list:
We also have the start of  a class diagram, from Chapter 7:
It looks like we’ve got everything we need to start coding, right? To help us make sure we haven’t forgotten anything, let’s go back to using some textual analysis.
We don’t have a use case to analyze, but we can revisit the vision statement for Gary’s games, and see if  we’re covering everything that Gary wanted his units to do.
Compare the class diagram for Unit with this vision statement.
What else might Gary expect to see when you say, “I’m done with writing code for the units in your framework?”
The framework supports multiple types of troops or units that are game-specific.
This looks like the blueprint for a good Unit class.
Gary’s Games provides frameworks that game designers can use to create turn-based strategy games.
Unlike arcade-style shoot-’em-up games and games that rely on audio and video features to engage the player, our games will focus on the technical details of  strategy and tactics.
Our framework provides the bookkeeping details to make building a particular game easy, while removing the burden of  coding repetitive tasks from the game design.
The game system framework (GSF) will provide the core of  all of Gary’s Games.
It will be delivered as a library of  classes with a welldefined API that should be usable by all board game development project teams within the company.
Each unit should have properties, and game designers can add new properties to unit types in their own games.
Here are the things we came up with that Gary is expecting units in his framework to do:
Units have to be able to move from one tile on a board to another.
Look, I trust you and all, but I need to see something more than scraps of paper to believe your code is.
This makes sense, because the key feature we were focusing on in Chapter 7 was not the entire Unit class, but just game-specific properties of a Unit.
Our class diagram is focused on this particular aspect of the Unit class right now.
These new features are all pulled straight from Gary’s vision statement.
But Gary wants more than a class diagram before he’s convinced you’re getting any work done.
This may be what you need to start coding the Unit class, but it doesn’t do anything to prove to Gary that you’ve got working units in the game system framework.
How about a test? Can’t you come up with a way to show me the unit has.
Your customers are used to seeing computer programs run on a computer.
All those diagrams and lists may help you get on the same page with them in terms of  requirements and what you’re supposed to build, but you’re going to need more than that before they think you’ve built anything useful.
You need to come up with some test scenarios that you can show to your customer, which will prove that your code works, and that it behaves like your customer expects it to.
Your customers want to see something that makes sense to them.
It’s your job to play Gary, and think of two.
Writing test scenarios Test cases don’t have to be very complex; they just provide a way to show your customer that the functionality in your classes is working correctly.
For the properties of  a unit, we can start out with a simple test scenario that creates a new Unit, and adds a property to the unit.
We could just show our customer a running program that displays output like this:
This test, although simple, lets your customer “see” that the code you’re writing really works.
Write the output you want Gary to see in these blanks.
Your job was to think of two more test scenarios that we can use to prove.
Here’s the first test scenario, which tests setting and getting property values.
Scenario #2: Changing property values We decided to test setting, and then changing, the value of a property.
If  the hitPoints property is set, for example, and then set again, getting the value of  hitPoints should return the most recent value for that property:
We always begin by creating a new Unit, so we can test things out.
Next we set the value of hitPoints, and then reset it to a new value.
This is pretty similar-looking to the first scenario, above, but it tests changing a property value, rather than just setting and retrieving a property.
Scenario #3: Getting non-existent property values For our third scenario, we decided to test what would happen when you tried to retrieve the value of  a property that had never been set.
Error conditions like this crop up all the time, and we don’t want our program crashing every time a game designer makes a small typo or mistake in their code.
Next, we set a hitPoints property, which is the normal Unit usage.
Now let’s try and access a property that has no value.
Finally, make sure the Unit still behaves when you ask for a property that does have a value.
This test shows the customer that you’re not just dealing with happy paths...
You should test your software for every possible usage you can think of.
Don’t forget to test for incorrect usage of the software, too.
You’ll catch errors early, and make your customers very happy.
Aren’t we doing things a bit backwards by worrying about tests right now?
In fact, if you know what tests you’re going to use before you write your code, it’s easy to figure out what code you’re going to need to pass those tests.
With the three test scenarios we just developed, it should be pretty simple to write the Unit class, and the tests tell us exactly how our code should behave.
Formally, test driven development focuses on automated tests, and usually involves a testing framework like JUnit.
But the idea of writing test cases, and then writing the code that will pass the test, is the core idea behind test driven development.
Q: So are we using test driven development or feature driven development? I’m confused...
In fact, most good software analysis and design mixes lots of different approaches.
You might start with a use case (use case driven development), and then choose just a small feature in that use case to start working on (which is really a form of feature driven development)
Finally, you might use tests to figure out how to implement that feature (feature driven development)
Q: Why are the tests so simple? I expected something a little fancier.
A: You want to keep your tests simple, and have them test just a small piece of functionality at a time.
If you start testing multiple things at once, it’s hard to tell what might have caused a particular test to fail.
You may need a lot more tests, but keep each one focused on a very specific piece of functionality.
Q: And each test makes sure a single method in the class works correctly, right?
A:  No, each test really focuses on a single piece of functionality.
For example, you can’t test setting a property’s value (which uses setProperty()) without getting that property’s value as well (using getProperty())
Q: Can you explain why you tested getting a property that you didn’t set? Isn’t that testing the wrong way to use the Unit class?
A:  Testing incorrect usage of your software is usually at least as important as testing it when it’s used properly.
Game designers could easily mistype a property name, or write code that expects some other piece of a game to set a property and asks for a property that doesn’t exist.
It’s your job to know what will happen in these situations.
Q: Now that we’ve got our tests planned out, we can finally start coding the Unit class, right?
A: Well, there’s one more bit of design we need to think about first...
Test driven development focuses on getting the behavior of your classes right.
Frank: And game designers can add any new properties they want by just creating new property names, and sticking name/value pairs in the Map with the setProperty() method.
But then, we also added a type property, since all units will have a type.
Frank: You think we need some sort of  ID, don’t you?
Joe: OK, but that still doesn’t mean we need to change our design.
We can just add the ID property into our property Map.
So we’ve got a nice, uniform way to access all those properties, using the getProperty() method.
And since we encapsulate away the details about property names into the properties Map, we could even change from using an ID to a name, or something totally different, and code using the Unit class wouldn’t have to change much...
Jill: But what about commonality? If  ID is really common to all types of  Unit, shouldn’t it be moved out of  the Map, sort of  like we did with the type property?
Here’s the current class diagram for Unit that Frank, Jill, and Joe are discussing.
Before we close the book on dealing with Unit properties, there are a few things you still need to think through.
Below are several properties that different units might have, and two sheets of paper.
Write down on the Commonality sheet the properties that you think all units, regardless of their type, would have; on the Variability sheet, write down properties you think only specific types of units might have.
Anything that you think is generic enough to apply to all units gets written down here.
With the details from your revised commonality analysis on page 442, you (might) need to update the Unit class diagram, shown below.
Make any changes that might improve the design of the Unit class below, and add notes to remind yourself what the purpose of any additions you’ve made are going to be used for.
You can cross out or modify the existing properties of Unit, in addition to adding new stuff.
Change and add to the methods in Unit to match what you figured out in the commonality and variability analysis on the last page.
On page 442, we showed you several properties that different units might have.
Your job was to write down on the Commonality sheet the properties that you think all units, regardless of their type, would have; on the Variability sheet, you should have written down properties you think only specific types of units might have.
We didn’t find a lot of properties that could apply to any type of unit, so our commonality page is pretty thin.
We figured that since these are war games, all units would have at least one weapon, but that some might have more than one.
So a generic “weapons” property seemed a good fit for all unit types.
We also decided that we would never need just a single “weapon” property...
Relax You may have a different idea about what makes a good game.
You might have played different games than we have, and come up with different.
That’s OK—just focus on how and why you made your own decisions.
We’re going to use our choices in the rest of  the chapter, so you should be comfortable with how we made our choices, too.
We moved most of the properties onto the Variability list, since they only apply to certain types of units.
We kept it on Variability, since some object units, like tank or airplane, didn’t map as cleanly to.
Most of these properties applied to either human-like units, or to vehicular units, but not to both.
Q: I didn’t have anything on the Commonality list except for “type”
Analysis and design are all about making choices, and sometimes you’re going to make a different choice than another programmer.
There’s nothing wrong with that, as long as you have good, well thought out reasons for the decision you made.
Q: But won’t different choices at least result in different code and design implementations?
But OOA&D, and software development, aren’t about making a particular decision, since many times there isn’t an exactly “right” or exactly “wrong” choice.
They’re about writing welldesigned software, and that can happen in a lot of different ways.
In fact, even if two programmers made the same decision about commonality and variability in this exercise, it can lead to totally different design decisions when it comes to actually writing your classes.
Let’s assume for a moment that two developers both came up with the answers for commonality and variability shown here, and then tried to revise the Unit class to reflect what they figured out...
I pulled the properties that were common to all units into their.
We met Sam back in Chapter 4, when he was working on the dog door with Maria and Randy.
All the properties that were common across units are represented as variables outside of the properties Map.
Each of the new properties gets its own set of methods.
In this solution, all game designers can directly access the id, name, and weapons properties, instead of  having to use getProperty() and work through the more generic properties Map.
The emphasis is on keeping the common properties of a Unit outside of  the properties Map, and leaving properties that vary inside the properties Map.
Sam figured that id would get set in the Unit constructor, so no need for a setId() method.
Design decisions are always a tradeoff Sam chose to emphasize the things that are common across all types of  Units.
We’re repeating ourselves Now there are two different ways to access properties: through the getId(), getName(), and.
Maintenance is a problem Now you’ve got property names, like id and name, hardcoded into the Unit class.
If  a game designer doesn’t want to use those, or wants to change them, it’s going to be a real hassle, and require changes to the Unit class.
This is usually where encapsulation would help, and that leads us to Randy’s design choice...
When you see the potential for duplicate code, you’ll almost always find maintenance and flexibility issues, as well.
This solution focuses on encapsulating all the properties for a Unit into the properties Map, and providing a standard interface—the getProperty() method—for accessing all properties.
Even properties that apply to all units,  like type and id, are accessed through the properties Map in this solution.
Even if the names of  common properties change, the Unit class can stay the same, since no property names are hardcoded into the class itself.
Randy didn’t add any new properties or methods, and he got rid of the type variable and the getType() method, moving that property into the properties Map.
I encapsulated all the properties of every kind of Unit.
Which developer’s solution do you think is best? Are there times where you think one solution might be the best choice, and other times where the other might work better?
Randy’s solution is more resistant to changes, and uses a lot more encapsulation, but there are tradeoffs with this design, as well.
Here are a few of  the downsides to Randy’s design:
We’re ignoring commonality Randy encapsulated all of  the properties into the properties Map, but now there’s nothing to.
Lots of work at runtime getProperty() returns an Object, and you’re going to have to cast that into the right value type for each different property, all at runtime.
That’s a lot of  casting, and a lot of  extra work that your code has to do at runtime, even for the properties that are common to all Unit types.
Any other unit- or game-specific properties go in this Map.
Q: I thought the other design, that focused on encapsulation, was better.
Both design choices have positives, and either one might work well.
The only thing you cannot do is be unwilling to change your design—whichever one you start with—if it turns out to not work well down the line.
At each stage of iterating through your app, you need to reevaluate your design decisions, and make sure they’re still solid.
Q: So how do I know when I need to change my design? My code won’t just stop working, so what should I look out for?
Lots of design decisions look great at one stage of your development, but then turn out to be a problem as you get deeper into a particular part of your app.
So once you make a decision, stick with it, and iterate deeper into your application.
As long as your design is working, and you’re able to use good OO principles and apply design patterns, you’re in good shape.
If you start running into trouble with a decision, though, don’t ever be afraid to change designs and rework things.
Q: What happens when I can’t decide between a couple of good design choices?
A: You always have to make a choice, even if you’re not 100% sure if it’s the right one.
It’s always better to take your best guess, and see how things work out, rather than spend endless hours debating one choice or another.
That’s called analysis paralysis, and it’s a sure way to not get anything done.
It’s much better to start down one path, even if you’re not totally sure it’s the right one, and get some work done, than to not make a choice at all.
Analyze, design, and then iterate again, working on smaller and smaller parts of your app.
Each time you iterate, reevaluate your design decisions, and don’t be afraid to CHANGE something if it makes sense for your design.
Match your tests to your design We’ve got test scenarios we want to show Gary, and a design for the Unit class.
The last thing we need to do before coding is to make sure our design for Unit will allow us to code a solution that passes all the tests.
We should have methods in this class to allow us to do everything in all of our tests.
Creating a unit is just calling “new Unit()”, so we’re all set there.
We can use setType() and getType() to handle this, since it’s a common property for all Unit types.
Any properties like hitPoints that aren’t common to all units can be set and retrieved using setProperty() and getProperty()
This tests re-setting a value, which just means another call to setProperty(), so we’re covered on this scenario.
Let’s write the Unit class It’s been two chapters in coming, but we’re finally ready to write the code for the Unit class.
We didn’t list the code for these simple getters and setters to save a little space.
We take the ID of the Unit in through the constructor...
We wait until there’s a need for a weapons list to instantiate a new List.
That saves a little bit of memory, especially when there may be thousands of units.
Since properties might not be initialized, there’s an extra check here before looking up a property’s value.
You’ll need a simple Weapon class to make this code compile.
We’ve talked a lot about test cases, but so far, you haven’t seen how to actually write one.
Let’s examine a test case up close, and see exactly what makes up a good test.
Each test case should have an ID and a name.
The names of  your test cases should describe what is being tested.
Test names with nothing but a number at the end aren’t nearly as helpful as names like testProperty() or testCreation()
You should also use a numeric ID, so you can easily list your tests cases out (something we’ll do on the next page)
Each test case should have an output that you expect.
Given your input, what should the program, class, or method output? You’ll compare the actual output of  the program with your expected output, and if  they match, then you’ve got a successful test, and your software works.
Do you need to open a database connection, or create a certain object, or set some values before running your test? If  so, that’s all part of  the starting state of  the test case, and needs to be handled before you run the actual test.
So if you set type to “infantry”, and then call getType(), your exepcted output is “infantry”
We do need to create a new Unit, but that’s about it.
Each test case should have one specific thing that it tests.
Each of  your test cases should be atomic: each should test only one piece of  functionality at time.
This allows you to isolate exactly what piece of  functionality might not be working in your application.
One piece of functionality may involve one method, two methods, or even multiple classes...
Your job is to fill in the table with information for the test cases we’ve laid out in this chapter already.
We’ve even done the first one to help get you started, and filled in a few empty spots on the rest of the tests.
This test sets the “type” property to a value of “infantry.”
Remember, there’s a difference between a common property like type, and unit-specific properties.
The first scenario tests getting and setting the “type” property, as shown here.
Your job was to fill in the table with information for the test cases we’ve laid out in this chapter already.
Did you figure out that you needed to make sure there was no property with a previous value for this test case?
You should have one test case for working with common properties, and one for working with unitspecific ones.
In most of our tests, we want as output exactly what we supplied as input.
The entire point of this test is to not supply a value for a property, and then try and retrieve that property’s value.
Q: How did our three test scenarios turn into four test cases? A:  Because the first test case really tested two things: setting and retrieving a common property, which has its own variable and access method (like getType()), and setting a retrieving a unit- or gamespecific property, which is accessed through getProperty() (like hitPoints)
That’s two pieces of functionality, so two different test cases are required.
Q: And all these tests will let us know that our software works like it should, right?
A:  It’s a good start on that, yes, but remember, we started out writing the tests so that we could prove to the customer that the software we’ve been writing actually will work.
Our test cases let the customer see some code actually running, as well as help us find bugs in our code before we get too far along in our development cycle.
Create a new class called UnitTester.java, and import the Unit class and any related classes into it.
Each test method should take in an instance of  Unit with any starting state already set, and any other parameters you think you’ll need to run the test and compare an input value with an expected output value.
The test method should set the supplied property name and property value on the provided Unit, and then retrieve the expected output property value using the expected output property name.
If  the provided input value and expected output value match, the method should print out “Test passed”; if  they don’t match, the method should print “Test failed”, along with the mismatched values.
Write a main() method that sets up the starting state for each test, and then runs each test.
Gary wants to know that you’re making progress on supporting units in his game system framework, and you want to be sure that the code you’ve written for Unit.java works properly.
Now that you know what test cases are, and have several written up in table form, you’re ready to code a test class to show your customer that your software works, and prove to yourself  that there aren’t any bugs in the code that you’ve written.
Identify what each of  these are, and create a test method for each.
Here’s the class we wrote to test the Unit class.
Each test method has different parameters, since each method is testing different things in the Unit class.
Most tests end with a comparison of the expected output and the actual output.
Properties stored in the Map take Objects as input and output values.
This test is almost identical to test2(), because the starting state takes care of pre-setting the property to another value.
All our main() method needs to do is create a new Unit, and then run through the tests.
Existing Unit object without strength value Existing Unit object with an id of 1000 Existing Unit object.
This test case doesn’t test all common properties; it just tests the type property.
We need to test all three of the other common properties, since each uses its own specific methods.
Prove yourself to the customer With a Unit class and a set of  test cases, you’re ready to show Gary some working code, and prove that you’re on the right track to building his game system framework just the way he wants it.
This is great! You really do know what you’re doing.
I’ll put a check in the mail, and you just keep on with.
Customers that see running code tend to get happy, and keep paying you.
Customers that only see diagrams get impatient and frustrated, so don’t expect much support or cash.
It’s not perfect for me—I don’t need your framework returning null all the time, and my guys having to check for it.
We’ll write our code correctly, so if your framework gets asked for a property that.
She manages a team of top-notch game developers, and they’re interested in using Gary’s game framework.
Let’s change the programming contract for the game system When you’re writing software, you’re also creating a contract between that software and the people that use it.
The contract details how the software will work when certain actions are taken—like requesting a non-existent property on a unit.
When you program by contract, you and your software’s users are agreeing that your software will behave in a certain way.
Want to know more about what this means? Turn the page to find out more...
The decisions we’re making now affect the Unit class and how we handle non-existent properties, so we’re still on this first bit of Unit functionality.
This list might not be initialized, so this could return null if there aren’t any weapons for this unit.
This is the contract for Unit The Unit class assumes that people using it are competent programmers, and that they can handle null return values.
I’m gonna return null if you ask for properties or weapons that don’t exist.
Even though you didn’t know it, this code is defining a contract for what happens when a property doesn’t exist.
Programming by contract is really all about trust When you return null, you’re trusting programmers to be able to deal with null return values.
Programmers are basically saying that they’ve coded things well enough that they won’t ask for non-existent properties or weapons, so their code just doesn’t worry about getting null values back from the Unit class:
I’m gonna return null if you ask for properties or weapons that don’t exist.
Our code will only ask you for properties that exist.
And we can always change the contract if we need to...
Back on page 461, we were asked to stop returning null, and throw an exception instead.
This really isn’t a big change to the contract; it just means that now game designers are going to have big problems if  they ask for non-existent properties or weapons.
You know what? We’re really confident we’re not going to ask you for non-existent properties.
In fact, if we do, just throw an exception, and it will crash the program, and we’ll hunt down the bug.
As long as you know I’m going to start throwing an Exception, we’re good to go.
I’ll just change my code, and we’ll start using this new contract.
But what happens if  you don’t think your code will be used correctly? Or if  you think that certain actions are such a bad idea that you don’t want to let users deal with them in their own way? In these cases, you may want to consider defensive programming.
Suppose you were really worried that game designers using the Unit class, and asking for non-existent properties, were getting null values and not handling them properly.
This version of getProperty() can throw a CHECKED exception, so code using Unit will have to catch this exception.
I’m sure you’re great code and all, but I just don’t trust you.
I could send you null, and you could totally blow up.
So let’s just be safe, and I’ll send you a checked exception that you’ll have to catch, to make sure you don’t get a null value back and do something stupid with it.
Of  course, when programmers use your code, they might not trust you either...
What if they don’t believe that you’ll only return non-null values from getProperty()? Then they’re going to protect their code, and use defensive programming, as well:
Here’s a sample of code that uses the Unit class.
Q: You said on page 463 that we could change the contract to throw an exception, but then you said here that throwing an exception is defensive programming.
A:  It’s really not that important what kind of exception is thrown.
What’s important is how your customers and clients are involved in that decision.
In programming by contract, you work with the client to agree on how you’re going to handle problems; in defensive programming, you make that decision in a way that ensures your code doesn’t crash, regardless of what the client wants to have happen.
When we decided to switch from returning null to throwing an exception, we did that by listening to the client, and agreeing on that particular action as a response to a request for non-existent properties.
And we made the exception a RuntimeException, again because the client didn’t want to add lots of try/catch blocks to their code.
They could have just as easily asked for a checked exception, and we could have agreed—and still been programming by contract.
Compare that to defensive programming, where we’re not really that interested in what the client wants.
In defensive programming, we’re making sure that we aren’t responsible for crashing a program, and we even go out of our way to try and prevent the client from crashing their program.
Tonight’s talk:  Programming by Contract and Defensive Programming duke it out over trust issues with programmers.
It’s nice to sit down with you and meet face to face, we really don’t see each other like this very often.
At some point, you have to just commit to how you’re going to behave, and trust other programmers to use you right.
I trust programmers understand the contract that I provide them.
Well, I could be crossing the street, and slip on some Banana.peel() that hadn’t been garbage collected, or some for loop without a good termination condition could come screaming through the intersection...
Are you kidding me? Have you met most of  the programmers writing the code you’re talking about trusting? They’re too busy watching Lost to worry about checking for bugs in their software.
If  they’d stop gawking at that Kate and her freckles, maybe I wouldn’t have to double-check their work so much.
Contract? Oh, you still think that if  you explain what you’ll do in a certain situation, that a “good” programmer will use you correctly? Boy, what naivete!
Haven’t you heard? Over 50% of  contracts today end in divorce...
I try and help my users, and even protect them from themselves.
Sure, sometimes I’m not the best performer, but I sure keep everyone safe from disaster.
It’s true! Besides, how many times has your code gone up in smoke because of  a lazy programmer who ignored your contract?
Hey, I’ve got a trust issue for you right here...
Look, my contract explicitly states what I have to do, and what people that use me have to do.
Look, if  programmers and users don’t keep their end of  the bargain, I can’t be held responsible for that.
If they violate the contract, they deserve what they get.
But that’s the point! I may not be great for lazy programmers, but I’m terrific for programmers who do check their work.
They get a performance bump, and their code is shorter when they use me.
And that’s what I provide, just without all the trust issues and baggage you bring along...
They’re all a chatty bunch, though, so it’s up to you to listen to what they’re saying, and try and figure out who’s behind the masks.
I prefer to take things one step at a time, until I’ve made it from start to finish.
Well, sure, she said she would call, but how can you really believe anyone anymore?
In fact, I’ve been focusing on all of my own behavior before moving on to anything else.
As long as you’re good with it, so am I.
Who am I to tell you what to do, so long as you know what you can expect from me.
Gary’s clients want Unit to assume they’re using it correctly.
That means that if a non-existent property is being queried, then something has truly gone wrong in the game, and an exception needs to be thrown.
Update Unit.java so that requests for a non-existent property result in an exception being thrown.
Figuring out the type of exception to use is up to you.
Update UnitTester and the test cases that this contract change affects to reflect this new contract.
Re-run UnitTester and make sure Unit.java still passes all of the tests.
Gary’s clients want Unit to assume they’re using it correctly.
That means that if a non-existent property is being queried, then something has truly gone wrong in the game, and an exception needs to be thrown.
The only method in Unit.java that you needed to change was getProperty()
Asking for a property when the properties Map is null is still asking for a non-existent property.
We throw a RuntimeException anytime a property that doesn’t exist is queried.
A:  If you used a checked exception, code that calls getProperty() would have to check for that exception, in try/catch blocks.
That’s not what the client wanted; we agreed to a contract that would let them code without having to catch for any exceptions.
So by using a RuntimeException, no extra worked is required for their client code to use the Unit class.
Q: What about the get methods for other properties, like weapons, name, and id?
A:  id and name are an int and String, respectively, so those aren’t a problem (id is required to create a new Unit, and name will either be null or a String with a value)
The weapons property is a List, so if you call getWeapons() when there aren’t any it’s going to result in a null list being returned.
You could change that method to throw an exception if the weapons list was empty, although that wasn’t specifically asked for by the clients.
We expect asking for a non-existent value to throw a RuntimeException, so we catch it...
Be sure that once an exception is thrown and you print a “passed” message, you exit the test method.
Q: You said that programming by contract resulted in less code, but it seems like we just added a lot of code to Unit.java.
A:  That’s because instead of directly returning null, we throw a new RuntimeException.
But that’s more of a special case here than the rule.
Most of the time, you’ll not have much extra code on the service side, because you’re simply returning objects and values without checking to see if they’re non-null, or within a particular data range.
Q: I still don’t see why we’re switching to programming by contract here.
A:  It’s not a matter of being better or worse; it’s a matter of what your customer wants.
In fact, you’ll rarely decide on your own if you want to do programming by contract or defensive programming.
That’s something that’s usually determined by what your customer wants, and the types of users that will be using the software that you’re writing.
When you are programming by contract, you’re working with client code to agree on how you’ll handle problem situations.
When you’re programming defensively, you’re making sure the client gets a “safe” response, no matter what the client wants to have happen.
It took a while, but we’re finally on to the next piece of functionality in the Unit class.
Moving units We’ve finally finished up unit properties, and can move on to the next item on our list:
Each unit should have properties, and game designers can add new properties to unit types in their own games.
Units have to be able to move from one tile on a board to another.
Haven’t we been here before? This should sound pretty familiar...
Break your apps up into smaller chunks of functionality We’ve been talking a lot about iterating deeper into your application, and at each stage, doing more analysis and design.
So you’re taking each problem, and then breaking it up (either into use cases or features), and then solving a part of  the problem, over and over.
This is what we’ve been doing in this chapter: taking a single feature, and working on that feature until it’s complete.
But once you choose a single feature or use case, you can usually break that feature up into even smaller pieces of behavior.
For example, a unit has properties and we have to deal with unit movement.
So each of  these individual pieces of behavior has to be dealt with.
Just like when you broke your app up and began to iterate, you’ll have to do more analysis and design at each step.
Always make sure your earlier decisions make sense, and change or rework those decisions if  they don’t.
Your decisions can iterate down, too Lots of  times you’ll find that decisions you made earlier save you work down the line.
In Gary’s system, we decided that game designers would deal with movement on their own.
So now that we’re talking about how to handle unit movement, we can take that decision we made earlier, and apply it here.
Since it still seems sensible—there’s no reason to change that decision—we can have game designers worry about handling unit movement, and move on to the next piece of  behavior.
We chose one feature, and focused on it: units in the framework.
Units have to be able to move from one tile on a board to another.
We can check off this next bit of behavior in the Unit class.
Just add a note to your docs for the game designers that movement is up to them.
Create a new class that can group units together, and both add and remove units to the group.
Fill out the table below with test case scenarios that will test your software, and prove to Gary that the grouping of  units works.
Add methods to UnitTester to implement the test scenarios in the table, and make sure all your tests pass.
Solve this puzzle, and you’ve completed the behavior for the Unit feature.
The first step in writing good software is to make sure your application works like the customer expects and wants it to.
Customers don’t usually care about diagrams and lists; they want to see your software actually do something.
Use case driven development focuses on one scenario in a use case in your application at a time.
In use case driven development, you focus on a single scenario at a time, but you also usually code all the scenarios in a single use case before moving on to any other scenarios, in other use cases.
Feature driven development allows you to code a complete feature before moving on to anything else.
You can choose to work on either big or small features in feature-driven development, as long as you take each feature one at a time.
You look at the big picture, and then iterate down to smaller pieces of functionality.
You have to do analysis and design at each step of your development cycle, including when you start working on a new feature or use case.
Tests allow you to make sure your software doesn’t have any bugs, and let you prove to your customer that your software works.
A good test case only tests one specific piece of functionality.
Test cases may involve only one, or several, methods in a single class, or may involve multiple classes.
Test driven development is based on the idea that you write your tests first, and then develop software that passes those tests.
Programming by contract assumes both sides in a transaction understand what actions generate what behavior, and will abide by that contract.
Methods usually return null or unchecked exceptions when errors occur in programming by contract environments.
Defensive programming looks for things to go wrong, and tests extensively to avoid problem situations.
Methods usually return “empty” objects or throw checked exceptions in defensive programming environments.
Feature Puzzle Solutions Gary’s framework needs to support groups of  units, and should also allow groups of  those groups (in as many nestings as the game designer wants to allow)
UnitGroup units: Map addUnit(Unit) removeUnit(int) removeUnit(Unit) getUnit(int): Unit getUnits(): Unit [*]
We decided to use a Map, storing the ID of a unit as the key, and the Unit object itself as the value of an entry.
You create a new UnitGroup by passing in a List of the units to add to the group initially.
By using a Map of units, we can retrieve and remove units by their ID, which is a nice bit of functionality.
Here’s the class diagram for UnitGroup, to give you an ove.
There’s a little bit of work in returning a list of all units, since we store the units in a Map, but we thought it was worth having units stored by ID.
The constructor just adds all the units to its units Map, setting the key of each entry to the ID of each unit.
List of units that matches initial list List of units (none with ID of 100)
We started the IDs higher, so they wouldn’t conflict with the IDs of the test cases we already have.
Here are the test cases for UnitGroup that we came up with.
We like to start with an empty UnitGroup, to make sure the units we’re working with don’t already appear in the UnitGroup.
Tools for your OOA&D Toolbox We learned about several approaches to.
Good requirements ensure your system works like your customers expect.
Make sure your requirements are complete by developing use cases for your system.
Use your use cases to find out about things your customers forgot to tell you.
Your use cases will reveal any incomplete or missing requirements that you might have.
Use basic OO principles like encapsulation and inheritance to make your software more flexible.
If a design isn’t flexible, then CHANGE IT! Never settle on bad design, even if it’s your bad design that has to change.
Make sure each of your classes is cohesive: each of your classes should focus on doing ONE THING really well.
Always strive for higher cohesion as you move through your software’s design lifecycle.
Analysis and Design Listen to the customer, and figure out what they want you to build.
Put together a feature list, in language the customer understands.
Make sure your features are what the customer actually wants.
Create blueprints of the system using use case diagrams (and use cases)
Break the big system up into lots of smaller sections.
Apply design patterns to the smaller sections of the system.
Use basic OOA&D principles to design and code each smaller section.
Each class in your application should have only one reason to change.
Classes should be open for extension, but closed for modification (the OCP) Avoid duplicate code by abstracting out things that are common and placing them in a single location (the DRY principle) Every object in your system should have a single responsibility, and all the object’s services should be focused on carrying out that single responsibility (the SRP) Subclasses should be suitable for their base classes (the LSP)
Development Approaches Use case driven development takes a single use case in your system, and focuses on completing the code to implement that entire use case, including all of its scenarios, before moving on to anything else in the application.
Feature driven development focuses on a single feature, and codes all the behavior of that feature, before moving on to anything else in the application.
Test driven development writes test scenarios for a piece of functionality before writing the code for that functionality.
Good software development usually incorporates all of these development models at different stages of the development cycle.
Programming by contract sets up an agreement about how your software behaves that you and users of your software agree to abide by.
Defensive programming doesn’t trust other software, and does extensive error and data checking to ensure the other software doesn’t give you bad or unsafe information.
Lots of new terms in this chapter, so lots of little square boxes to fill in for this chapter’s crossword.
Review the chapter and see if you can get them all!
Feature Driven Development, Use Case Driven Development, Programming by Contract, and Defensive Programming have all showed up for a masquerade party, but none of them bothered to wear name tags.
They’re all a chatty bunch, though, so it’s up to you to listen to what they’re saying, and try and figure out who’s behind the masks.
I prefer to take things one step at a time, until I’ve made it from start to finish.
Well, sure, she said she would call, but how can you really believe anyone anymore?
In fact, I’ve been focusing on all of my own behavior before moving on to anything else.
As long as you’re good with it, so am I.
Who am I to tell you what to do, so long as you know what you can expect from me.
You might have added Programming by Contract here, since a contract is really a form of requirements.
All of these techniques and tools are really about getting the customer the software that they want.
Are we there yet? We’ve been working on lots of individual ways to improve your software, but now it’s time to.
You may not see it yet, Walter, but I’m going to take all these.
Honey, I think you’re a great programmer, but I just don’t see how you’re going to combine all those little.
Developing software, OOA&D style You’ve got a lot of  new tools, techniques, and ideas about how to develop great software by now...
That’s what this chapter is all about: taking all the individual things you know how to do—like figuring out requirements, writing up use cases, and applying design patterns—and turning it into a reusable process that you can use to tackle even your trickiest software problems, over and over again.
Feature List Figure out what your app is supposed to do at a high level.
Use Case Diagrams Nail down the big processes that your app performs, and any external forces that are involved.
Break Up the Problem Break your application up into modules of functionality, and then decide on an order in which to tackle each of your modules.
Requirements Figure out the individual requirements for each module, and make sure those fit in with the big picture.
Does it seem like you spend a LOT of time worrying about functionality? That’s because you do...
Domain Analysis Figure out how your use cases map to objects in your app, and make sure your customer is on the same page as you are.
Preliminary Design Fill in details about your objects, define relationships between the objects, and apply principles and patterns.
Implementation Write code, test it, and make sure it works.
Do this for each behavior, each feature, each use case, each problem, until you’re done.
Delivery You’re done! Release your software, submit your invoices, and get paid.
Look, I love your pretty arrows and all those labels, but I’m not.
We’ve used parts of that process, but how am I supposed to know using all those steps together.
We’ve used all of  the different parts of this process to work on software projects throughout the book, but we haven’t yet really put it all together.
Let’s build a software project, from start to finish, using this process.
Before we dive into the problem we’re going to be solving in this chapter, you need to make sure you see where all the things you’ve been learning fit in the big OOA&D Project Lifecycle.
You can put more than one magnet on each phase, and there are some magnets you may want to use more than once, so take your time, and good luck.
OOA&D GENERAL’S WARNING: Answers to this exercise do NOT appear on the next page.
Go ahead and work through this chapter, and we’ll come back to these answers at the end of the chapter.
We’ve started a list for the Requirements phase to help you out.
Congratulations! Based on your amazing work for Rick’ s Stringed.
Instruments and Doug’s Dog Doors, we’d like to commi ssion you.
With the recent increase in travel to Objectville, we wan t to.
Objectville’s complete network of subway lines, as well as all the.
The RouteFinder should also be able to take a starting st ation, and a.
We look forward to seeing your design and a working Ro.
To help you get started, we’ve provided a map of Ob.
The problem Here’s the project we’re going to work through in this chapter, from beginning to end:
This page left intentionally blank, so you can cut out the cool Objectville Map on the next page and hang it up on your cubicle wall.
This page left intentionally blank, so you can cut out the cool Objectville Map on the previous page and hang it up on your cubicle wall.
Your job is to take the Statement of Work on page 488, and use it to develop a feature list.
You can refer back to Chapter 6 if you need help on what features are, and what a typical feature list looks like.
You don’t have to use all of these blanks if you don’t think you need them all.
Your job was to take the Statement of Work on page 488, and use it to develop a feature list for the RouteFinder we’re going to build.
We have to be able to represent a subway line, and the stations along that line.
We must be able to load multiple subway lines into the program, including overlapping lines.
We need to be able to figure out a valid path between any two stations on any lines.
We need to be able to print out a route between two stations as a set of directions.
Your answers may not match ours exactly, but they should be pretty close, and cover these same basic four features.
Q: Why aren’t we gathering requirements? I’m still not clear on how a feature is really that different from a requirement, anyway.
Most of the time, though, people say “feature” when they’re talking about BIG things that an application needs to do.
So it might take several requirements to satisfy one feature.
And since features are usually a little bigger-picture than requirements, it’s a good idea to start any new project by writing out a feature list, like we’ve done with the RouteFinder.
Q: Why did you list printing out the route as a separate feature? That’s pretty easy once you’ve got a valid route between two stations, isn’t it?
But the feature list isn’t just a list of hard problems you have to solve—it’s a list of all the things your application has to be able to do.
So even if a feature seems easy or trivial, put it on your feature list anyway.
A “valid route” might be all on one line, or involve several different line.
Now you should really know what you’re supposed to do At this point, you’ve finished up that first phase.
With a feature list in hand, you should have a good understanding of  the things that your app needs to do.
You probably even can begin to think about the structure of  your application, although we’ll spend a lot more time on that in just a bit.
Once you’ve got your feature list down, you should move on to use case diagrams.
Those will help you connect what your app does to how it will be usedand that’s what customers really are interested in.
Your feature lists are all about understanding what your software is supposed to do.
Your use case diagrams let you start thinking about how your software will be used, without getting into a bunch of unnecessary details.
With feature lists in hand, let’s look at how our app is going to be used.
Below, we’ve started a use case diagram for the RouteFinder app.
For this project, there are two actors, and just two use cases (sounds sort of simple, doesn’t it?)
It’s up to you to figure out who (or what) the two actors are, and to label the two use cases.
If you need help, refer back to Chapter 6 for more on use case diagrams.
Once you’ve got your use case diagrams figured out, you need to make sure that your use cases match up with the features you have to deliver to the customer.
Below is the feature list for RouteFinder, as well as magnets for each feature.
Make sure you have each feature covered before turning the page.
We have to be able to represent a subway line, and the stations along that line.
We must be able to load multiple subway lines into the program, including overlapping lines.
We need to be able to figure out a valid path between any two stations on any lines.
We need to be able to print out a route between two stations as a set of directions.
Each one of these magnets should go on one of the use cases over here.
Decide on the structure for the RouteFinder code, and map your use cases back to your feature list.
You were supposed to figure out the actors and use cases for your system, and then make sure those use cases covered all the features we decided RouteFinder had to support.
You might have put down Travel Agent or another name for this actor...
In theory, a travel agent OR a tourist could use this piece of funtionality in the system.
This feature is required functionality for this use case to work, so we attached it here.
Use cases reflect usage, features reflect functionality Let’s look more closely at one of  the feature-use case matches we showed you on the last page:
The “Load network of  subway lines” use case really does not directly use our feature that deals with representing the subway.
Obviously, we have to be able to represent the subway for this use case to work, but it’s a stretch to tie the two together like this.
That’s not a mistake, though; when we’re writing use cases, we’re dealing with just the interactions between actors and a system.
We’re just talking about the ways that your system is used (which is where the term “use case” came from)
Your system must do those things in order for the use cases to actually work, even though the functionality isn’t always an explicit part of any particular use case.
This is something the RouteFinder must do for a use case to work, but it’s not actually an interaction on its own.
A use case may depend upon a feature to function, but the feature may not actually be part of the steps in the use case itself.
The features in your system are what the system does, and are not always reflected in your use cases, which show how the system is used.
Features and use cases work together, but they are not the same thing.
Q: Didn’t you say that I should be able to match up every feature to a use case in my system?
Every feature in your system will be at least a part of addressing one or more uses cases in your use case diagram.
But that doesn’t mean that the use case has to actually directly use that feature.
Lots of times, a feature makes it possible for a use case to function without being directly used by the use case itself.
In our RouteFinder, there would be no way to load a network of subway lines into the system (one of our use cases) without having a representation of a subway in the first place (one of our features)
But the “Load Network” use case doesn’t have any steps that match up directly with that feature...
So the use case indirectly uses the feature, without explicitly referring to it.
Q: So is a use case a requirement, or is a feature a requirement?
A: Both! Use cases are requirements for how people and things (actors) interact with your system, and features are requirements about things that your system must do.
Still, to implement a system’s use cases, you’re going to need the functionality in the system’s features.
That’s why you should always be able to map your features to the use cases that they enable and are used by.
Q: What happens if I find a feature that I can’t match up to a use case, even indirectly?
A:  You should take a hard look at the feature, and make sure it really is a required part of your system.
Your customer—and her customers—only interact with your system through the use cases.
So if a feature doesn’t at least indirectly make a use case possible, you’re customer really isn’t going to see a benefit.
If you think you’ve got a feature that doesn’t really affect how your system is used or performs, talk it over with the customer, but don’t be afraid to cut something if it’s not going to improve your system.
The Big Break-Up We’re starting to pick up some steam.
With use case diagrams in place, you’re ready to break this problem up into some smaller pieces of functionality.
There are several ways to do this in any application, but our goal here is to keep the RouteFinder system very modular.
That means keeping different pieces of functionality separate—each module should have a single responsibility.
Go ahead and break up the RouteFinder system into four different “modules”
Think carefully about the best way to break up your system...
Write the name of what this module does in the blank.
HINT: Remember, you need to handle the system’s functionality, but you also need to prove to the customer that your system works.
With use case diagrams in place, you’re ready to break this problem up into some smaller pieces of functionality.
We added a Testing module, because we need some code that actually proves to our customer that the system works...
The Subway module has all the code that represents stations, connections between those stations, and the entire subway system itself.
It also knows how to get directions from one station to another on its connections and lines.
We could have several different ways to load a subway: from a file, or with user input, or even from a database.
Loading is really separate from the subway representation itself, so it gets its own module.
Printing is a lot like loading: it’s separate from the subway system itself.
This module handles printing the subway to any device or format that we might need.
Check the box next to the OO principles you think we’re using to break up the RouteFinder functionality in this manner.
Now start to iterate Once you’ve broken up your software into several individual pieces of  functionality, you’re ready to start iterating over each piece of functionality, until the application is complete.
At this point, we need to take our big-picture view of  the system, from our use case diagram, and refine that into requirements that we can begin to tackle, one by one.
For this first iteration, let’s take the “Load network of  subway lines” use case, and turn that into a set of  requirements that isn’t so big-picture.
Then we can take care of  that use case, and iterate again, working on the next use case.
Write the steps that RouteFinder needs to take to implement the “Load network of subway lines” use case.
You can use more room, or more steps, if you need them.
Sharpen your pencil We’re taking the first use case from our diagram, and starting with it.
You’ve just uncovered a “secret step” in our process for writing software the OOA&D way:
If  you get stuck writing a use case, there’s nothing wrong with taking a step back, and examining the problem you’re trying to solve a bit.
Then, you can go back to your use case, and have a better chance of getting it written correctly.
You’ll often have to do some extra work between breaking up the problem and writing your use cases.
How am I supposed to write this use case? I’m not totally sure I know what a.
And what about that file that Objectville travel said they were going.
Check the box next to the OO principles you think we used to break up the RouteFinder functionality into separate modules.
By breaking up printing, loading, and representing the subway into three modules, we’re making sure each module has only one reason to change.
We’ve encapsulated printing and loading, which might vary, away from the subway, which should stay the same.
It’s not clear if we’re using delegation yet, although with SRP and encapsulation, we probably will at some point.
We really don’t understand our problem well enough to write better requirements yet.
Here’s the “extra step” that we sometimes need to take.
A closer look at representing a subway Before we can figure out how to load a subway line, there are two things we need to get a good grasp of:
Understanding the information an administrator would have when they’re loading a set of  subway stations and lines.
We’re on Iteration 1, trying to handle the first use case: loading a network of subway lines.
What is a station? A subway system has stations, and connections between those stations, and lines that are groups of  connections.
So let’s begin by figuring out exactly what a station is.
And a connection between two stations? As soon as you start adding several stations, you’ve got to deal with the connections between those stations:
If  you put several connections together, then you’ve got a subway line.
A subway line is a series of stations, each connected one to another.
Let’s take a look at that subway file We’ve got a basic idea now of  what a subway is, so let’s see what kind of  data we’ve got to work with.
Remember, Objectville Travel said they would send us a file with all the stations and lines, so this should give us an idea of  what an administrator will use to load the lines into the subway system.
The file starts out with a list of all the station names.
Since these lines form loops, the first station also appears as the last station, forming a cycle.
You should have enough understanding of what a subway system is, and the format of the Objectville Subway input file, to write this use case now.
You can use more room, or more steps, if you need them.
You should have enough understanding of what a subway system is, and the format of the Objectville Subway input file, to write this use case now.
The first step is the start condition: the loader gets a new file to load from.
Did you get this step? We really don’t want our system to have duplicate stations...
This is really only one possible way to write the use case.
Is your use case the only solution to the puzzle?
By now you realize that there are lots of decisions you have to make to solve any problem, and our use case simply reflects the decisions we made.
We’re going to work with this particular use case throughout the rest of this chapter, so make sure you understand our reasoning behind it, but it’s perfectly OK if you came up with your own use case that solves the same problem of loading a network of subway stations and lines.
Q: I didn’t add any steps about validation to my use case.
A: Validation is something that you should add to your use case if you left it out.
Making sure the stations for a connection actually exist is a lot like not having a dog door automatically close.
It seems innocent enough, until the real world creeps in, and someone misspells a station name.
Suddenly, you have the equivalent of software rodents: a connection that goes to a non-existent station.
So if you left out validation, be sure to add it in to your own use case.
The system repeats steps 2-4 until all stations are added.
The system reads in the name of a line to add.
The system creates a new connection between the two stations, going in both directions, on the current line.
The system repeats steps 7-9 until the line is complete.
The system repeats steps 6-10 until all lines are entered.
Steps like this, which indicate repeating other steps, help make your use cases a little more readable and concise.
Let’s see if our use case works The use case for loading a network is a little tricky, and has several groups of  steps that repeat.
Let’s check the flow of  things against our text file before we go on to analyzing the use case, and starting to design the classes in our system.
The administrator supplies a file like this to the system loader.
The system makes sure this station hasn’t already been entered in.
The system repeats these steps until all the stations are entered.
The system reads in the two stations connected on the line.
The system makes sure both stations actually exist on the subway.
These steps are repeated for each successive pair of stations on the line.
The entire process of adding a line is repeated for each line in the file.
Analysis and Design Puzzle This time, it’s your job to take on two phases of  the OOA&D process at once.
First, you need to perform textual analysis on the use case below, and figure out the nouns that are candidate classes, and the verbs that are candidate operations.
Write the nouns and verbs in the blanks provided below the use case.
The system repeats steps 2-4 until all stations are added.
The system reads in the name of a line to add.
The system repeats steps 7-9 until the line is complete.
The system repeats steps 6-10 until all lines are entered.
Using the candidate nouns and verbs you got from the use case, draw a class diagram below of  what you think the subway system might look like modeled in code.
Use associations and any other UML notation you think will help make your design clear and understandable.
We know that actors are outside the system, so no class needed here.
This is an input to our system, not something we model in our system.
The system repeats steps 2-4 until all stations are added.
The system reads in the name of a line to add.
The system creates a new connection between the two stations, going in both directions, on the current line.
The system repeats steps 7-9 until the line is complete.
The system repeats steps 6-10 until all lines are entered.
Most of these directly map to methods on our classes.
We’ll come back to why we added an equals() and hashCode() method in a minute.
A connection has two stations and the name of the line the connection is a part of.
You should not call these attributes start and stop, or beginning and end, since subways in Objectville go both ways.
Subway has a collection of the stations in the subway, as well as the connections among its stations.
This is the main object we’ll be working with, and we need a method to add stations, and to add connections.
We’re doing design, and heading towards implementation for this iteration.
This class uses all the functionality in Subway to create a subway from a text file of stations and lines.
To use a Line class or not to use a Line class...
But then we decided to not create a Line class.
Instead, we just assigned a line name to each connection:
We made this decision based on one thing: we know how the system is going to be used.
In the original Statement of Work (back on page 488) from Objectville Travel, we were told we needed to represent a subway, and get directions between one station and another.
Once we have those directions, we can simply ask each connection for its line; there doesn’t seem to be a need for an actual Line class.
Lines only exist as String names attached to a particular Connection.
Your design decisions should be based on how your system will be used, as well as good OO principles.
Even if it turns out we need to add a Line class later, that’s no big.
This is a preliminary design, and we can change it if we need to once.
Q: I found the “validates that a station exists” verb, but where does that operation appear on any of the classes in your design?
A: We modeled that operation as hasStation() on the Subway class.
You could have called that operation validate() or validateStation(), but those aren’t as descriptive as hasStation(), and you should always try and make your code as readable as possible.
Q: Could you talk a little more about how you showed those repeated steps in the use case?
A: Lots of times a use case has a set of steps that need to be repeated, but there’s not a standard way to show that in use cases.
So we just made one up! The point of a use case is to provide you with a clear set of steps that detail what your system should do, and we thought the clearest way to show those repeated steps was to write down “Repeat Steps 7-9.”
Q: I’ve been thinking about that subway representation, and it looks a lot like a graph data structure to me.
A: Wow, you must have taken a data structures or algorithms class recently! Yes, you can use a graph to represent the subway.
In that case, each station would be a node, and each connection would be a labeled edge.
Q: So then why aren’t we using a graph structure in this example?
If you already know about graphs and nodes and edges, and you happen to have code for that sort of data structure lying around, then go ahead and use them.
But from our point of view, we’d do more work adapting a graph to our needs than just coming up with a few simple classes for Station and Connection.
Like almost everything else in the design stage, there are several ways to solve a problem, and you need to choose a solution that works well for you.
A: It’s OK; you don’t need to know about graphs in order to understand and solve this particular problem.
It’s nothing to worry about, at least until we come up with a Head First Data Structures book (anyone? anyone?)
Code the Station class We’ve got requirements in the form of  a use case, a class diagram, and we know the Station class will fit into our Subway model.
It’s up to you if you want to break up your modules by package.
We figured there’s going to be a lot of comparisons between stations, so we made sure we defined equals()
In this version, two Station objects are equal if they have the same name.
The Java specification recommends that if two objects are equal, they should have the same hash code.
So if you’re deciding on equality based on a property, it’s a good idea to also override hashCode() and return a hash code based on that same property.
This is particularly important if you’re using your object in a Hashtable or HashMap, which both make heavy use of the hashCode() method.
When you override equals() in Java, you should usually also override hashCode() to ensure correct comparisons.
We base the hash code of a Station on the same property that comparisons are based on: the name of the station.
For a lot more on equals() and hashCode(), check out Chapter 16 of Head First Java.
This ensures, for example, that a station named “AJAX RAPIDS” is considered the same as a station named “Ajax Rapids”
Using the class diagram on the right, complete the Connection class by filling in the blanks with the correct lines of code.
Be sure your class will compile before you turn the page and see our answers.
We’re well into the implementation phase of our first iteration, now.
Using the class diagram on the right, your job was to fill in the blanks and complete the Connection class.
Code the Subway class Next up is the Subway class itself.
With Station and Connection done, and a good class diagram, nothing here should be a surprise:
These will store all the stations, and the connections between those stations.
First, we validate the name, and make sure we don’t already have this station.
If not, we create a new Station instance, and add it to the subway.
Like addStation(), we begin with some validation: this time, we make sure both stations exist in the subway.
Points of interest on the Objectville Subway (class) We threw a couple of  new things into the Subway class; first, you’ll see this line of  code quite a bit:
For example, when we create a new Connection, we have code like this:
But that takes a lot of  time, and there’s a better way.
Remember how we defined an equals() and hashCode() method on our Station class?
These methods allowed us to tell Java that when it compares two Station objects, just see if  their name is the same.
If  the names are equal, even if  the objects don’t refer to the same location in memory, they should be treated as the same.
So instead of  looking for a particular Station object in the Subway class’s list of  station, it’s much easier to just create a new Station and use it.
Because we overrode equals() and hashCode(), we can save search time and complexity in our code.
Your design decisions should always make your implementation better, not more complicated or harder to understand.
Normally, equals() in Java just checks to see if two objects actually are the SAME object...
But that’s NOT what we want to use for comparison of two Station objects.
Our version of equals() tells Java to base equality on the value of the name attribute, instead of a memory location.
These two instances of Station have the same name, but they refer to two different memory locations...
And, our design is improved by being able to compare stations based on their name, rather than their location in memory.
So the time we spent on requirements and getting a good grasp of our system made our design better, which in turn made implementing that design a lot simpler.
That’s the power of OOA&D: you can turn knowledge of your system into a flexible design, and even end up with cleaner code—all because you spent time up front listening to the customer and gathering requirements, rather than diving right into an IDE and typing in source code.
So we could change our Subway class to look more like this:
Jill: But then you’re exposing the internals of  your application!
You don’t have to work with a Station or Connection at all to load up the subway.
You can just call methods on our new Subway class.
Frank:  How is that any different from what we’re suggesting?
Jill:  If  we went with your ideas, people that use the Subway class would have to also work with Station and Connection.
In our version right now, they just work with Strings: the name of  a station, and the name of  a line.
Their code is getting tied in to how we implement the Station and Connection classes, since they’re having to work with those classes directly.
Jill:  Exactly! But with our version, we could change up Connection or Station, and we’d only have to change our Subway class.
Their code would stay the same, since they’re abstracted away from our implementations of  Connection and Station.
Joe and Frank are suggesting taking in objects for these methods, rather than the strings that are the property values for those objects.
Protecting your classes (and your client’s classes, too) Frank, Joe, and Jill are really talking about just one more form of  abstraction.
Right now, only the Subway class interacts with the Station and Connection objects.
You should only expose clients of your code to the classes that they NEED to interact with.
Classes that the clients don’t interact with can be changed with minimal client code being affected.
In this application, we could change how Station and Connection work, and it wouldn’t affect code that only uses our Subway object; they’re protected from changes to our implementation.
The SubwayLoader class We’re almost done with our first iteration, and our first use case.
All that’s left is to code the class that loads a subway based on the test file we got from Objectville Travel, Inc.
We’re working on the Loader module now (see page 502)
Loading stations just involves reading a line, adding that line into the subway as a new station name, and then repeating, until we hit a blank line.
We read the first station, and the station after that...
Let’s see exactly what happens when you call loadFromFile() in SubwayLoader, and give it the text file we got from Objectville Travel.
Your job is to place the magnets from the bottom of this page—which match up to methods on the SubwayLoader and Subway classes—next to the lines in the text file where they’ll be called.
Let’s see exactly what happens when you call loadFromFile() in SubwayLoader, and give it the text file we got from Objectville Travel.
Your job was to place the magnets from the bottom of this page next to the lines in the text file where they’ll be called.
The Loader starts by creating a new Subway object, and then calling loadStations()
Add a method to Subway to check if  a particular connection exists, given the two station names and the line name for that connection.
The system repeats steps 2-4 until all stations are added.
The system reads in the name of a line to add.
The system repeats steps 7-9 until the line is complete.
The system repeats steps 6-10 until all lines are entered.
Add a method to Subway to check if  a particular connection exists, given the two station names and the line name for that connection.
Q: Wouldn’t it be easier to write the hasConnection() method if we used a Line object, like we talked about a few pages ago?
If we had a Line object, we could look up the line using the name passed into hasConnection(), and just iterate over the Connection objects for that line.
So in most cases, hasConnection() would involve less iteration, and return a.
We still decided not to use a Line object, though, because we’ve only added hasConnection() to help us test our classes.
So adding a Line object just to make a test method return faster doesn’t seem like a good idea.
If we find that we need the hasConnection() method in other parts of our app, though, this.
This code simply passes in the text file, and then tests a few stations and connections to see if they got loaded.
You can use any stations and connections you like here.
Run your test program, and verify that we’re really done with Iteration 1.4
It’s time to iterate again Our test proves that we really have finished up our first iteration.
The “Load network of  subway lines” use case is complete, and that means it’s time to iterate again.
Now, we can take on our next use case—“Get directions”—and return to the Requirements phase and work through this use case.
Once an iteration is complete, if there are more use cases or features to implement, you need to take your next feature or use case, and start again at the requirements phase.
Try and write a test case that gets all the stations and connections in the Subway and prints them out, to verify your subway is loading the network correctly.
It’s been a LONG iteration, and you’ve done some great work.
STOP, take a BREAK, and eat a bite or drink some water.
Then, once you’ve caught your breath, turn the page, and let’s knock out that last use case.
What’s left to do? We’ve made a lot of  progress, on both our use cases, and our feature list.
Below is the feature list and use case diagram we developed earlier in the chapter:
We have to be able to represent a subway line, and the stations along that line.
We must be able to load multiple subway lines into the program, including overlapping lines.
We need to be able to figure out a valid path between any two stations on any lines.
We need to be able to print out a route between two stations as a set of directions.
We took care of both of these features in Iteration #1
We’ve also got our first use case taken care of.
This use case is the focus of our second iteration.
This time, your job is to write a use case that allows a travel agent to get directions from one station to another on the Objectville Subway.
Now that we’re ready to take on the next use case, we have to go back to the requirements phase, and work through this use case the same way we did the first one.
So we’ll start by taking our use case title from our use case diagram, “Get directions,” and developing that into a full-blown use case.
You shouldn’t need as many steps to write this use case.
The travel agent gives the system a starting station and a station to travel to.
The system validates that the starting and ending stations both exist on the subway.
The system calculates a route from the starting station to the ending station.
Just like our first use case, you should have added some validation.
This is the big task we have to tackle in this iteration.
Once we have a route, printing should be pretty simple.
Why do we keep jumping back and forth between modules.
These are the two modules we’ll be working with to put this use case into action.
When we started breaking our application up into different modules way back on page 502, we were really talking about the structure of  our application, and how we are going to break up our application.
We have a Subway and Station class in the Subway module, and a SubwayLoader class in the Loader module, and so on.
But when we’re working on use cases, we’re focusing on how the customer uses the system—we looked at the format of  an input file to load lines, and began to focus on the customer’s interaction with your system.
So we’ve really been going back and forth between our code (in the Break Up the Problem step) and our customer (in the Requirements step):
When you’re developing software, there’s going to be a lot of  this back-andforth.
You have to make sure your software does what it’s supposed to, but it’s your code that makes the software actually do something.
This reflects how we’re breaking up the structure of our system’s code.
This step is about our code, and how we break up functionality.
This step is about how the customer uses our software.
It’s your job to balance making sure the customer gets the functionality they want with making sure your code stays flexible and well-designed.
We’ve really been going back and forth between our code, and how our system is used, in both iterations.
Analysis and Design Puzzle It’s time to take on more domain analysis and design for your system.
Take the use case below, figure out the candidate classes and candidate operations, and then update the class diagram on the right with any changes you think you need to make.
Do some of these exercises look familiar? You use the same techniques in each iteration of your development cycle.
The travel agent gives the system a starting station and a station to travel to.
The system validates that the starting and ending stations both exist on the subway.
The system calculates a route from the starting station to the ending station.
We’re taking these two phases on at the same time again.
We know we need a new class to handle printing a route once we get it from the Subway class.
We decided to represent a route as a set of connections (and each connection will tell us the line it’s on)
The system reads in the name of a line to add.
The system creates a new connection between the two stations, going in both directions, on the current line.10
The system repeats steps 6-10 until all lines are entered.
Iteration makes problems easier The class diagram on the last page really isn’t that much different from our class diagram from the first iteration (flip back to page 513 to take a look at that earlier version)
That’s because we did a lot of  work that applies to all our iterations during our first iteration.
Once you’ve completed your first iteration, your successive iterations are often a lot easier, because so much of  what you’ve already done makes those later iterations easier.
We did a LOT of work in our first iteration...
All the work we did on the Subway module laid the groundwork for our second iteration.
We still have plenty of work to do, but not nearly as much as we did in the first iteration.
Most of the Subway module is done, and we’ve even got some tests in place.
To help you out, we’ve included some Ready-bake Code that you can use to get a route between two stations.
Just type it in as its shown here, or you can download a completed version of Subway.java from the Head First Labs web site.
We need a Map to store each station, and a list of all the stations that it connects to.
When we add connections, we need to update our Map of stations, and how they’re connected in the subway’s network.
The value for that station is a List containing all the stations that it connects to (regardless of which line connects the stations)
This method is based on a well-known bit of code called Dijkstra’s algorithm, which figures out the shortest path between two nodes on a graph.
This first part of the code handles the case when the end station is just one connection away from the starting station.
These loops begin to iterate through each set of stations reachable by the starting station, and tries to find the least number of stations possible to connect the starting point and the destination.
We’ve found the path by now boolean keepLooping = true; Station keyStation = end; Station station;
Once we’ve got a path, we just “unwind” the path, and create a List of connections to get from the starting station to the destination station.
It might seem weird that at this stage, we’re giving you the code for getting a route between two stations.
But that’s part of  what makes a good developer: a willingness to look around for existing solutions to hard problems.
Sure, you probably can come up with your own totally original solution to every problem, but why would you want to if  someone has already done the work for you?
Sometimes the best way to get the job done is find someone else who has already done the job for you.
Sometimes the best code for a particular problem has already been written.
Don’t get hung up on writing code yourself if someone already has a working solution.
What does a route look like? The getDirections() method we just added to Subway takes in two Strings: the name of  the starting station, and the name of  the station that a tourist is trying to get to:
Each Connection is one part of  the path between the two stations:
So the entire route returned from getDirections() looks like a series of  Connection objects:
All of this is represented in a single Connection object.
The first station on the first connection is your starting point.
The list goes on until it ends in a connection that has a second station that is the destination.
Printing Puzzle You’re almost done! With a working getDirections() method in Subway, the last feature to implement is printing those directions out.
Your job is to write a class called SubwayPrinter that takes the data structure returned from getDirections(), which is a list of Connection objects, and prints out the directions.
The directions should be printed to an OutputStream, supplied to the constructor of  the SubwayPrinter class when an instance of  the printer class is created.
Here’s the class diagram for SubwayPrinter that you should follow:
You can get the line for this Connection using getConnection.
Print out each station on a line that is passed.
Anytime the line changes, print out the line and station to get off of...
The last thing you should have is a Connection with the destination station as the stopping point.
You might have come up with a slightly different approach to looping through the route List, but your output should match ours exactly for full credit.
This looks at the current connection, and figures out if a line change is required.
If it’s the same line, just print the station name.
All that we need to do now is put everything together.
Below is the SubwayTester class we wrote to load the Objectville Subway system, take in two stations from the command line, and print out directions between those two stations using our new getDirections() method and printer class.
We want two stations passed in on the command line for this test.
We’ve tested this earlier, so we know that loading the subway works fine.
We also validate that the two stations supplied exist on the subway.
With two valid stations, we can get a route between them...
We can’t prove our software works without some test cases and test classes.
Check out Objectville for yourself! It’s time to sit back and enjoy the fruits of  your labor.
Compile all your classes for the Objectville Subway application, and try out SubwayTester with a few different starting and stopping stations.
Now that you’ve written another piece of great software, you’re ready to take this exercise on, and see how we answered it, too.
Go ahead and work this exercise again; did you change where you put any of the magnets after working through this chapter?
Oh, and don’t forget, you can put more than one magnet on each phase, and there are some magnets you may want to use more than once.
Even though each magnet appears only once, you can use each one as many times as you like.
Your job was to try and put the different magnets on the right phase of the OOA&D lifecycle, shown below.
You could put more than one magnet on each phase; how do your answers compare with ours?
Q: It seems like I could put almost every magnet on each phase...
Although there are definitely some basic phases in a good development cycle, you can use most of the things you’ve learned about OOA&D, OO principles, design, analysis, requirements, and everything else at almost every stage of development.
The most effective and successful way to write great software is to have as many tools as you can, and to be able to choose any one (or more) to use at each stage of your development cycle.
The more tools you have, the more ways you’ll have to look at and work on a problem...
Dumb Questionsthere are no OOA&D is about having lots of options.
There is never one right way to solve a problem, so the more options you have, the better chance you’ll find a good solution to every problem.
Iteration #3, anyone? No, we’re not going to launch into any more design problems.
But, you should realize that there is plenty more that you could do to improve the design of  our RouteFinder application.
We thought we’d give you just a few suggestions, in case you’re dying to take another pass through the OOA&D lifecycle.
Make loading more extensible Right now, we’ve just got a single class that handles loading, and it only accepts a Java File as input.
See if  you can come up with a solution that allows you to load a subway from several types of  input sources (try starting with a File and InputStream)
Also make it easy to add new input sources, like a database.
Remember, you want to minimize changes to existing code when you’re adding new functionality, so you may end up with an interface or abstract base class before you’re through.
We can only print subway directions to a file, and the directions are formatted in a particular way.
See if  you can design a flexible Printing module that allows you to print a route to different output sources (like a File, OutputStream, and Writer), in different formats (perhaps a verbose form that matches what we’ve done already, a compact form that only indicates where to changes lines, and an XML form for other programs to use in web services)
Here’s a hint: check out the Strategy pattern in Head First Design Patterns for ideas on how you might make this work.
Yes, it’s a sad day: you’re looking at the last crossword in the book.
Take a deep breath, we’ve crammed this one full of terms to make it last a little longer.
Now take OOA&D for a spin on your own projects!
She’s a real peach, isn’t she? I can’t wait to see how she handles.
We’ve loved having you here in Objectville, and we’re sad to see you go.
But there’s nothing like taking what you’ve learned and putting it to use on your own development projects.
We’re dying to hear how things go, so drop us a line at the Head First Labs web site, http://www.headfirstlabs.com, and let us know how OOA&D is paying off for YOU.
Yes, with over 550 pages under your belt, there are still things we couldn’t cram in.
Besides, once you’re done here, all that’s left is another appendix...
IS-A and HAS-A Lots of  times in OO programming circles, you’ll hear someone talk about the IS-A and HAS-A relationships.
IS-A refers to inheritance Usually, IS-A relates to inheritance, for example: “A Sword ISA Weapon, so Sword should extend Weapon.”
HAS-A refers to composition and aggregation, so you might hear, “A Unit HAS-A Weapon, so a Unit can be composed with a Weapon object.” This is sometimes referred to as a HAS-A relationship.
The problem with IS-A and HAS-A The reason we haven’t covered IS-A and HAS-A much is that they tend to break down in certain situations.
For example, consider the situation where you’re modeling shapes, like Circle, Rectangle, and Diamond.
If  you think about a Square object, you can apply the IS-A relationship: Square IS-A Rectangle.
But remember LSP, and that subtypes should be substitutable for their base types.
The problem here is that when you set the width in setWidth() on Square, the square is going to have to set its height, too, since squares have equal width and height.
So even though Square IS-A Rectangle, it doesn’t behave like a rectangle.
Use inheritance when one object behaves like another, rather than just when the IS-A relationship applies.
Use case formats Even though there’s a pretty standard definition for what a use case is, there’s not a standard way for writing use cases.
Here are just a few of  the different ways you can write up your use cases:
When Todd and Gina hear him barking, they press a button on their remote control.
The button opens up the dog door, and Fido goes outside.
If Fido stays outside too long, then the dog door will shut while he’s still outside.
Fido will bark to be let back inside, and Todd or Gina presses the button on the remote control again.
This opens the dog door, and allows Fido to return back inside.
The steps that the system follows are written out in paragraph form.
Any alternate paths are usually added to the end of the text in casual form, and presented in an “If-then” form.
It’s a simple, step-based format that works well for most situations.
Focusing on interaction This format is a little more focused on separating out what is in a system, and how the actors outside of  the system interact with your software.
Todd or Gina presses the button on the remote control.
Extensions If Fido stays outside and the dog door shuts before he.
Todd or Gina can press the button on the remote again, and he can return inside.
This format focuses on what is external to the system (the actors), and what the system itself does.
In Todd and Gina’s dog door, the system is pretty simple, and usually is just responding to the actions of Todd, Gina, and Fido.
This format doesn’t offer a very convenient way to handle alternate paths, so they’re just added at the bottom of the use case.
Goal: Fido has used the bathroom and is back inside the.
Todd or Gina presses the button on the remote control.
This is similar to the use case format we’ve been using, but adds some extra details.
Everything in the use case is geared towards accomplishing this goal.
Pre-conditions detail any assumptions that the system makes before things get started.
These are the steps from the alternate path, but they’re just listed separately.
Alternate paths are also called extensions, and in this format, are listed below the main path steps.
Anti patterns We’ve talked a lot in this book about design patterns, and described them this way:
But there’s another type of  pattern you should know about, called an anti-pattern:
Anti patterns turn up when you see the same problem get solved the same way, but the solution turns out to be a BAD one.
For example, one common anti pattern is called “Gas Factory”, and refers to designs that are overly complex, and therefore not very maintainable.
So you want to work to avoid the Gas Factory in your own code.
Design patterns are proven solutions to particular types of problems, and help us structure our own applications in ways that are easier to understand, more maintainable, and more flexible.
We’re actually not making this up! At your next serious development meeting, be sure to mention trying to avoid the Gas Factory.
Design patterns help you recognize and implement GOOD solutions to common problems.
Anti patterns are about recognizing and avoiding BAD solutions to common problems.
These cards are used to take a class and figure out what its responsibility should be, and what other classes it collaborates with.
The card has two columns: one for the responsibilities of  the class, and another for other classes that are collaborators, and used to fulfill those responsibilities.
Class:  BarkRecognizer Description: This class is the interface to the bark recognition hardware.
If there are other classes involved is this job, list them in this column.
Open the door Close the doorBe sure you write down things that.
These go hand in hand with your SRP Analysis, as well:
Class:  Automobile Description: This class represents a car and its related functionality.
Any time you see “Gets”, it’s probably not the responsibility of this class to do a certain task.
If you’ve got a class that seems to violate the SRP, you can use a CRC card to sort out which classes should be doing what.
Metrics Sometimes it’s hard to tell how solid your design really is, because design is such a subjective thing.
That’s where metrics can help out: while they don’t provide a complete picture of  your system, they can be helpful in pointing out strengths, weaknesses, and potential problems.
You usually use software tools to take as input your class’s source code, and those tools then generate metrics based on your code and its design.
For example, just counting the number of  lines of  code in your application is almost a total waste of  time.
It’s nothing but a number, and has no context (and also depends a lot on how you’re writing your code, something else we’ll talk about in this appendix)
But if  you count the number of  defects per 1000 lines of  code, then that becomes a useful metric.
You can also use metric to measure things like how well you’re using abstraction in your code.
Good design will use abstract classes and interfaces, so that other classes can program to those interfaces rather than specific implementation classes.
So abstraction keeps one part of  your code independent from changes to other parts of  your code, at least  to the degree that it’s possible in your system.
You can use something called the abstractness metric to measure this:
Packages that have lots of  abstractions will have a higher value for A, and  packages with less abstractions have a lower value for A.
In general, you want to have each package in your software only depend on packages with a higher value for A.
That means that your packages are always depending on packages that are more abstract; the result should be software that can easily respond to change.
Nc is the total number of classes in the same package or module.
Higher numbers mean more abstraction is being used, lower numbers represent less abstraction.
Robert Martin’s book called “Agile Software Development” has a lot more of these OOrelated metrics.
Sequence diagrams When we were working on the dog door for Todd and Gina, we developed several alternate paths (and one alternate path actually had an alternate path itself)
To really get a feel for how your system handles these different paths, it’s helpful to use a UML sequence diagram.
A sequence diagram is just what it sounds like: a visual way to show the things that happen in a particular interaction between an actor and your system.
These boxes with underlined names represent objects in the system.
They represent the life of these objects and actors throughout this particular sequence.
These are notes, and indicate things that are going on in the system that aren’t specifically related to the objects in this diagram.
In OO systems, these messages equate to methods being called on the objects in the sequence.
In that case, the message originates from, and is directed to, the same object.
State diagrams You’ve already seen class diagrams and sequence diagrams.
This diagram describes a part of  your system by showing its various states, and the actions that cause that state to change.
State diagrams really come into play when you have multiple actions and events that are all going on at the same time.
On the right page, we’ve taken just such a situation, and drawn a state diagram for how a game designer might use Gary’s Game System Framework.
If  game designers were going to use the framework, they might write a game that behaves a lot like this state diagram demonstrates.
The end state of the diagram is indicated by a solid circle inside another circle.
This is the name of the transition, and describes what triggers the change of state.
It indicates a condition that must be true for this transition to occur.
There’s a check for victory, and the game ends if the check returns true.
Sometimes a transition is just part of the process, and doesn’t have a special name or condition.
It’s just the “next stage” of the state of the app.
Unit testing In each chapter that we’re worked on an application, we’ve built.
We test each class with a certain set of  input data, or with a particular sequence of  method calls.
While this is a great way to get a sense of  how your application works when used by the customer, it does have some drawbacks:
You have to write a complete program for each usage of the software.
You need to produce some kind of  output, either to the console or a file, to verify the software is working correctly.
You have to manually look over the output of  the test, each time its run, to make sure things are working correctly.
Your tests will eventually test such large pieces of functionality that you’re no longer testing all the smaller features of  your app.
Fortunately, there are testing frameworks that will not only allow you to test very small pieces of  functionality, but will also automate much of  that testing for you.
In Java, the most popular framework is called JUnit (http://www.junit.org), and integrates with lots of the popular Java development environments, like Eclipse.
Q: If the tests we wrote in the main part of the book made sure our software worked at a high level, why do we need more tests? Aren’t those enough to be sure our software works?
A: Most of the tests we wrote really tested a particular scenario, such as opening the door, letting a dog out, having another dog bark, and then letting the owner’s dog back in.
Unit tests, and particular the tests we’re talking about here, are far more granular.
They test each class’s functionality, one piece at a time.
The reason that you need both types of tests is because you’ll never be able to come up with scenarios that test every possible combination of features and functionality in your software.
We’re all human, and we all tend to forget just one or two strange situations now and then.
With tests that exercise each individual piece of functionality in your classes, you can be sure that things will work in any scenario, even if you don’t specifically test that scenario.
It’s a way to make sure each small piece works, and one that lets you assume pretty safely that combining those small pieces will then work, as well.
What a test case looks like A test case has a test method for each and every piece of  functionality in the class that it’s testing.
So for a class like DogDoor, we’d test opening the door, and closing the door.
JUnit would generate a test class that looked something like this:
Test your code in context Notice that instead of  directly testing the DogDoor’s open() and close() methods, this test uses the Remote class, which is how the door would work in the real world.
That ensures that the tests are simulating real usage, even though they are testing just a single piece of functionality at a time.
Instead of  calling the close() method, the test opens the door with the remote, waits beyond the time it should take for the door to close automatically, and then tests to see if  the door is closed.
That’s how the door will be used, so that’s what should be tested.
There’s a method for each piece of functionality in Dog.
This method tests for the door automatically closing, rather than just calling door.close(), which isn’t how the door is usually used.
Coding standards and readable code Reading source code should be a lot like reading a book.
You should be able to tell what’s going on, and even if  you have a few questions, it shouldn’t be too hard to figure out the answers to those questions if  you just keep reading.
Good developers and designers should be willing to spend a little extra time writing readable code, because it improves the ability to maintain and reuse that code.
JavaDoc comments help people reading the code, and also can be used to generate documentation with Java’s javadoc tool.
Method and variable names are descriptive, and easy to decipher.
Any statements that aren’t perfectly clear are commented to clarify.
Even variables used just within a single method are named for readability.
Great software is more than just working code Many developers will tell you that code standards and formatting are a big pain, but take a look at what happens when you don’t spend any time making your code readable:
From a purely functional point of  view, this version of  DogDoor works just as well as the one on the last page.
But by now you should know that great software is more than just working code—it’s code that is maintainable, and can be reused.
The lack of indentation and spacing makes things even harder to understand.
Writing readable code makes that code easier to maintain and reuse, for you and other developers.
Refactoring Refactoring is the process of  modifying the structure of  your code without modifying its behavior.
Refactoring is done to increase the cleanness, flexibility, and extensibility of  your code, and usually is related to a specific improvement in your design.
Most refactorings are fairly simple, and focus on one specific design aspect of  your code.
While there’s nothing particularly wrong with this code, it’s not as maintainable as it could be.
By now, you should know that violates the Single Responsibility Principle.
We really should separate the code that handles eligibility requirements from the code that does disability calculations.
So we can refactor this code to look more like this:
It should be an ongoing process, as code that is left alone tends to become harder and harder to reuse.
Go back to old code, and refactor it to take advantage of  new design techniques you’ve learned.
The programmers who have to maintain and reuse your code will thank you for it.
We’ve taken two responsibilities, and placed them in two separate methods, adhering to the SRP.
Refactoring changes the internal structure of your code WITHOUT affecting your code’s behavior.
Get ready to take a trip to a foreign country.
It’s time to visit Objectville, a land where objects do just what they’re supposed.
Welcome to Objectville Whether this is your first trip to Objectville, or you’ve visited before, there’s no place quite like it.
But things are a little different here, so we’re here to help you get your bearings before you dive into the main part of  the book.
Welcome to Objectville! I picked up a few things I thought you might need to help make you comfortable.
We’ll start with just a little bit of UML, so we can talk about classes easily throughout the book.
Then, we’ll do a quick review of inheritance, just to make sure you’re ready for the more advanced code examples in this book.
Once we’ve got inheritance covered, we’ll take a quick look at polymorphism, too.
So we’ll be using UML, the Unified Modeling Language, which is a language used to communicate just the details about your code and application’s structure that other developers and customers need, without getting details that aren’t necessary.
This is how you show a class in a class diagram.
That’s the way that UML lets you represent details about the classes in your application.
It’s always in bold, at the top of the class diagram.
Each one has a name, and then a type after the colon.
This line separates the member variables from the methods of the class.
Each one has a name, and then any parameters the method takes, and then a return type after the colon.
A class diagram makes it really easy to see the big picture: you can easily.
You can even leave out the variables and/or methods if it helps you communicate better.
Using the class diagram above, see if you can write the basic skeleton for the Airplane class.
Did you find anything that the class diagram leaves out? Write those things in the blanks below:
Using the class diagram on page 577, you were supposed to write the basic skeleton for the Airplane class.
The class diagram didn’t tell us if speed should be public, private, or protected.
There was nothing about a constructor in the class diagram.
You could have written a constructor that took in an initial speed value, and that would be OK, too.
The class diagram didn’t tell us what this method did...
Q: So the class diagram isn’t a very complete representation of a class, is it?
Class diagrams are just a way to communicate the basic details of a class’s variables and methods.
It also makes it easy to talk about code without forcing you to wade through hundreds of lines of Java, or C, or Perl.
Q: I’ve got my own way of drawing classes; what’s wrong with that?
A: There’s nothing wrong with your own notation, but it can make things harder for other people to understand.
By using a standard like UML, we can all speak the same language and be sure we’re talking about the same thing in our diagrams.
Q: So who came up with this UML deal, anyway?
Q: Sounds like a lot of fuss over that simple little class diagram thing.
A:  UML is actually a lot more than that class diagram.
And there’s a lot more to learn about class diagrams, too.
We’ll talk about other things you can show in a class diagram, and other types of diagrams, when we need them later in the book.
Actually, class diagams can provide this information, but in most cases, it’s not needed for clear communication.
Next up: inheritance One of  the fundamental programming topics in Objectville is inheritance.
That’s when one class inherits behavior from another class, and can then change that behavior if  needed.
Let’s look at how inheritance works in Java; it’s similar in other languages, too:
It refers to the class that this class has inherited behavior from.
So here, this calls the constructor of Airplane, Jet’s superclass.
The subclass can add its own variables to the ones that it inherits from Airplane.
The subclass can change the behavior of its superclass, as well as call the superclass’s methods.
But since Jet uses the same version of that method as Airplane, we don’t need to write any code to change that method.
Even though you can’t see it in Jet, it’s perfectly OK to call getSpeed() on Jet.
A subclass can add its own methods to the methods it inherits from its superclass.
Inheritance lets you build classes based on other classes, and avoid duplicating and repeating code.
Pool Puzzle Your job is to take code snippets from.
You may use the same snippet more than once, and you won’t need to use all the snippets.
When one class inherits from another, then polymorphism allows a subclass to stand in for the superclass.
Don’t worry about this notation too much, we’ll talk a lot more about inheritance in class diagrams later on.
Q: What’s so useful about polymorphism? A: You can write code that works on the superclass, like Airplane, but will work with any subclass type, like Jet or Rocket.
Q: I still don’t get how polymorphism makes my code flexible.
A: Well, if you need new functionality, you could write a new subclass of Airplane.
But since your code uses the superclass, your new subclass will work without any changes to the rest of our code! That means your code is flexible and can change easily.
Last but not least: encapsulation Encapsulation is when you hide the implementation of  a class in such a way that it is easy to use and easy to change.
It makes the class act as a black box that provides a service to its users, but does not open up the code so someone can change it or use it the wrong way.
Encapsulation is a key technique in being able to follow the Open-Closed principle.
We made the speed variable public, instead of private, and now all parts of your app can access speed directly.
Now anyone can set the speed directly This change means that the rest of  your app no longer has to call setSpeed() to set the speed of  a plane; the speed variable can be set directly.
So what’s the big deal? Doesn’t seem like much of  a problem, does it? But what happens if you create a Jet and set its speed like this:
Type in, compile, and run the code for FlyTest3.java, shown above.
What did  your output look like? Write the two lines of output in the blanks below:
What do you think happened here? Write down why you think you got the speeds that you did for each instance of Jet:
Finally, summarize what you think the value of encapsulation is:
Since Jet inherits from Airplane, you can use the speed variable from its superclass just like it was a part of Jet.
This is how we set and ac cessed the speed.
The process of enclosing programming elements inside larger, more abstract entities.
Type in, compile, and run the code for FlyTest3.java shown above.
What did  your output look like? Write the two lines of output in the blanks below:
What do you think happened here? Write down why you think you got the speeds that you did for each instance of Jet:
Finally, summarize what you think the value of encapsulation is:
In the Jet class, setSpeed() takes the value supplied, and multiplies it by two before setting the speed of the jet.
When we set the speed variable manually, it didn’t get multiplied by two.
Encapsulation protects data from being set in an improper way.
With encapsulated data, any calculations or checks that the class does on the data are preserved, since the data can’t be accessed directly.
You didn’t have to write down exactly what we did, but you should have gotten something similar.
So encapsulation does more than just hide information; it makes sure the methods you write to work with your data are actually used!
Q: So encapsulation is all about making all your variables private?
A: No, encapsulation is about separating information from other parts of your application that shouldn’t mess with that information.
With member variables, you don’t want the rest of your app directly messing with your data, so you separate that data by making it private.
If the data needs to be updated, you can provide methods that work with the data responsibly, like we did with the Airplane class, using getSpeed() and setSpeed()
Q: So are there other ways to use encapsulation besides with variables?
In fact, in Chapter 1, we’ll be looking at how you can encapsulate a group of properties away from an object, and make sure that the object doesn’t use those properties incorrectly.
Even though we’ll deal with an entire set of properties, it’s still just separating a set of information away from the rest of your application.
Q: So encapsulation is really about protecting your data, right?
A:  Actually, it’s even more than that! Encapsulation can also help you separate behavior from other parts of your application.
So you might put lots of code in a method, and put that method in a class; you’ve separated that behavior from the rest of your application, and the app has to use your new class and method to access that behavior.
It’s the same principles as with data, though: you’re separating out parts of your application to protect them from being used improperly.
Q: Wow, I’m not sure I’m following all of this.
We’ll spend a lot more time on all of these OO principles and concepts, so don’t feel like you need to get everything down perfectly at this point.
Then you can control how each part is used by the rest of your application.
Already gone through everything? Then you’re definitely ready for the rest of this book.
A class diagram gives you an overview of your class, including its methods and variables.
Inheritance is when one class extends another class to reuse or build upon the inherited class’s behavior.
In inheritance, the class being inherited from is called the superclass; the class that is doing the inheritance is called the subclass.
A subclass gets all the behavior of its superclass automatically.
A subclass can override its superclass’s behavior to change how a method works.
Polymorphism allows your applications to be more flexible, and less resistant to change.
Encapsulation is when you separate or hide one part of your code from the rest of your code.
The simplest form of encapsulation is when you make the variables of your classes private, and only expose that data through methods on the class.
You can also encapsulate groups of data, or even behavior, to control how they are accessed.
Take a moment to review the concepts in this appendix, and then you’re ready to step firmly into the world of analysis, design, OO programming, and great software.
Your job was to take code snippets from the pool below, and place them into the blank lines in the code you see on the right.
You may use the same snippet more than once, and you won’t need to use all the snippets.
Your goal was to create a class that will compile, run, and produce the output listed.
SubwayLoader class  524 making sure correctly loads in all stations and.
