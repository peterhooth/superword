If  you have been considering buying a book about mobile development that is cross‑browser and cross‑vendor, you should stop right now and buy Head First Mobile Web.
It’s written by amazingly smart people [who] have great experience on mobile and don’t stop at one platform, but work on all of  them.
Many developers spend days arguing [whether] they should go native or web.
Andrea Trasatti, leader of  the DeviceAtlas project and cocreator of the WURFL repository of  wireless device capability information.
A pragmatic introduction to the chaotic world of  mobile web development as it is today, with a glimpse of  how we can and should approach it for tomorrow.
Stephen Hay, web designer, developer, speaker, and cofounder of  the Mobilism conference.
What sets this book apart is its focus on learning.
Hidden behind the funny pictures and crazy fonts is a serious, intelligent, extremely well‑crafted presentation of  OO analysis and design.
If  you’re a new software developer, Head First Software Development will get you started off  on the right foot.
Visual learners, kinesthetic learners, everyone can learn from this book.
Visual aids make things easier to remember, and the book is written in a very accessible style—very different from most Java manuals.… Head First Java is a valuable book.
I can see the Head First books used in the classroom, whether in high schools or adult ed classes.
Rather than textbook‑style learning, Head First iPhone and iPad Development brings a humorous, engaging, and even enjoyable approach to learning iOS development.
With coverage of  key technologies including core data, and even crucial aspects such as interface design, the content is aptly chosen and top‑notch.
Another nice thing about Head First Java, Second Edition, is that it whets the appetite for more.
With later coverage of  more advanced topics such as Swing and RMI, you just can’t wait to dive into those APIs and code that flawless, 100,000‑line program on java.net that will bring you fame and venturecapital fortune.
There’s also a great deal of  material, and even some best practices, on networking and threads—my own weak spot.
Even if  you already know Java, you may pick up a thing or two.
Of  course it’s not the range of  material that makes Head First Java stand out, it’s the style and approach.
This book is about as far removed from a computer science textbook or technical manual as you can get.
The use of  cartoons, quizzes, fridge magnets (yep, fridge magnets…)
And, in place of  the usual kind of reader exercises, you are asked to pretend to be the compiler and compile the code, or perhaps to piece some code together by filling in the blanks or…you get the picture.… The first edition of  this book was one of  our recommended titles for those new to Java and objects.
This new edition doesn’t disappoint and rightfully steps into the shoes of  its predecessor.
Head First Web Design is your ticket to mastering all of  these complex topics, and understanding what’s really going on in the world of  web design.… If  you have not been baptized by fire in using something as involved as Dreamweaver, then this book will be a great way to learn good web design.
Is it possible to learn real web design from a book format? Head First Web Design is the key to designing user‑friendly sites, from customer requirements to hand‑drawn storyboards to online sites that work well.
What sets this apart from other ‘how to build a website’ books is that it uses the latest research in cognitive science and learning to provide a visual learning experience rich in images and designed for how the brain works and learns best.
I definitely recommend Head First Web Design to all of  my fellow programmers who want to get a grip on the more artistic side of  the business.
Wouldn’t it be dreamy if there were a book to help me learn how to build mobile websites that was more fun than going to the dentist? It’s.
O’Reilly Media books may be purchased for educational, business, or sales promotional use.
Many of  the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and O’Reilly Media, Inc., was aware of  a trademark claim, the designations have been printed in caps or initial caps.
While every precaution has been taken in the preparation of  this book, the publisher and the authors assume no responsibility for errors or omissions, or for damages resulting from the use of  the information contained herein.
No feature phones were harmed in the making of  this book.
To the phenomenal women in my family: my sister, Maggie; Momula, Fran; Aunt Catherine; stepmother, Christie; and above all, to the memory of  my grandmother, Pearl, whose fierce and literate independence inspired generations.
To my parents for buying that Commodore 64 so many years ago; to my lovely wife, Dana, without whose support and understanding this book wouldn’t have happened; and to Katie and Danny—yes, Daddy can play now.
Curiously, Lyza was actually born and raised in Portland, Oregon, the town where everyone wants to be but no one seems to be from.
Lyza started college early and cobbled together a motley education: a BA in Arts and Letters from Portland State University, followed by a master’s program in computer science at the University of Birmingham (UK)
Fascinated by the way mobile technology has changed things, she now spends a lot of  time thinking about the future of  the Web, mobile and otherwise.
Since cofounding Cloud Four, a Portland‑based mobile web agency, in 2007, Lyza has voyaged further into the deep, untrammeled reaches of  Device Land, exploring the foibles and chaos of  mobile browsers and the mobile web.
She has an odd set of  anachronistic hobbies, and it has been said that she takes a fair number of photographs.
We’ll bet you can guess what it is and go visit her there.
He became obsessed with how the world could be a better place if  everyone had access to the world’s information in their pockets.
When his wife, Dana, met him, he had covered the walls of  his apartment with crazy mobile dreams.
To this day, he remains baffled that she married him.
Those mobile dreams hit the hard wall of  realityWAP was crap.
So Jason went to work on the Web until 2007, when the iPhone made it clear the time was right.
He joined forces with the three smartest people he knew and started Cloud Four.
Since cofounding Cloud Four, he has had the good fortune to work on many fantastic projects, including the Obama iPhone App.
He is founder and president of  Mobile Portland, a local nonprofit dedicated to promoting the mobile community in Portland, Oregon.
You can find him blogging at http://cloudfour.com; on his personal site, http://userfirstweb.com; and on Twitter as @grigs.
Here you are trying to learn something, while here your brain is, doing you a favor by making sure the learning doesn’t.
Mobile technology is evolving at bewildering speed, and there’s so much to know!
We’ll start our journey by showing you a way of making websites called.
You’ll be able to adapt websites to look great on a.
It may look like a mobile site, but it’s still a desktop site in mobile clothing.
If we want this site to be greased lightning on.
When we’re done, you’ll have a page that is optimized regardless.
But what happens when a stinky dose of reality sets in? Like.
There aren’t enough hours in the day to test on every device.
You have to draw the line somewhere on what you can support.
Setting the bar for the devices we support doesn’t take care of  a few nagging issues.
How do we find out enough stuff about our users’ mobile browsers to know if they measure up before we deliver content to them? How do.
The mobile web feels like that gifted kid in the class.
You know, kind of fascinating, capable of amazing things, but also a.
We can use progressive enhancement to spruce up the interface in more.
It might be because you need access to something not available in mobile browsers (yet)
We look forward to that shiny future when we have.
The key is to learn to go with the flow.
At least, not if you want to be able to carry.
So take a peek and see what you (still) might be missing out on.
That goes for more than just completing the exercises in this book.
The first step to solving device detection mysteries is a bit of  legwork.
Any decent gumshoe knows we’ve got to gather our clues and interrogate our witnesses.
But it’ll take a bit of coaxing to get the two to spill the whole.
To be the master of  testing native Android apps, you need to be environmentally aware.
You’ll need to turn your computer into a nice little ecosystem where you can herd Android apps to and from virtual (emulated) or.
To make you the shepherd of your Android sheep, we’ll show you how to.
Intro I can’t believe they put that in a mobile.
Note from marketing: this book is for anyone with a credit card.
Do you want to learn, understand, remember, and apply important mobile web concepts so that you can make your mobile web pages more interactive and exciting?
Do you prefer stimulating dinner-party conversation to dry, dull, academic lectures?
Are you already developing mobile web apps or sites and looking for a reference book on mobile web?
Are you afraid to try something different? Would you rather have a root canal than endure the suggestion that there might be more than one true way to build for the Web? Do you believe that a technical book can’t be serious if there’s a walrus-themed pub and an app called the Tartanator in it?
It definitely helps if you’ve already got some scripting chops, too.
We’re not talking rocket science, but you shouldn’t feel visceral panic if you see a JavaScript snippet.
It was built that way, and it helps you stay alive.
So what does your brain do with all the routine, ordinary, normal things you encounter? Everything it can to stop them from interfering with the brain’s real job—recording things that matter.
It doesn’t bother saving the boring things; they never make it past the “this is obviously not important” filter.
How does your brain know what’s important? Suppose you’re out for a day hike and a tiger jumps in front of  you.
Or trying to learn some tough technical topic your boss thinks will take a week, 10 days at the most.
It’s trying to make sure that this obviously nonimportant content doesn’t clutter up scarce resources.
Resources that are better spent storing the really big things.
And there’s no simple way to tell your brain, “Hey brain, thank you very much, but no matter how dull this book is, and how little I’m registering on the emotional Richter scale right now, I really do want you to keep this stuff  around.”
Which would you pay mo re attention to: a stimulat.
I really want to learn this , but I can’t stay awake pa.
We think of a “Head First” r eader as a learner.
If  you really want to learn, and you want to learn more quickly and more deeply, pay attention to how you pay attention.
Most of  us did not take courses on metacognition or learning theory when we were growing up.
We were expected to learn, but rarely taught to learn.
But we assume that if  you’re holding this book, you really want to learn about mobile web development.
And you probably don’t want to spend a lot of  time.
And since you’re going to build more sites and apps in the future, you need to remember what you read.
To get the most from this book, or any book or learning experience, take responsibility for your brain.
The trick is to get your brain to see the new material you’re learning as Really Important.
Otherwise, you’re in for a constant battle, with your brain doing its best to keep the new content from sticking.
So just how do you get your brain to think that mobile web development is a hungry tiger?
There’s the slow, tedious way, or the faster, more effective way.
You obviously know that you are able to learn and remember even the dullest of  topics if  you keep pounding the same thing into your brain.
With enough repetition, your brain says, “This doesn’t feel important to him, but he keeps looking at the same thing over and over and over, so I suppose it must be.”
The faster way is to do anything that increases brain activity, especially different types of  brain activity.
The things on the previous page are a big part of  the solution, and they’re all things that have been proven to help your brain work in your favor.
For example, studies show that putting words within the pictures they describe (as opposed to somewhere else in the page, like a caption or in the body text) causes your brain to try to makes sense of  how the words and picture relate, and this causes more neurons to fire.
More neurons firing = more chances for your brain to get that this is something worth paying attention to, and possibly recording.
A conversational style helps because people tend to pay more attention when they perceive that they’re in a conversation, since they’re expected to follow along and hold up their end.
The amazing thing is, your brain doesn’t necessarily care that the “conversation” is between you and a book! On the other hand, if  the writing style is formal and dry, your brain perceives it the same way you experience being lectured to while sitting in a roomful of  passive attendees.
Here’s what WE did: We used pictures, because your brain is tuned for visuals, not text.
As far as your brain’s concerned, a picture really is worth a thousand words.
And when text and pictures work together, we embedded the text in the pictures because your brain works more effectively when the text is within the thing the text refers to, as opposed to in a caption or buried in the text somewhere.
We used redundancy, saying the same thing in different ways and with different media types, and multiple senses, to increase the chance that the content gets coded into more than one area of  your brain.
We used concepts and pictures in unexpected ways because your brain is tuned for novelty, and we used pictures and ideas with at least some emotional content, because your brain is tuned to pay attention to the biochemistry of  emotions.
That which causes you to feel something is more likely to be remembered, even if  that feeling is nothing more than a little humor, surprise, or interest.
We used a personalized, conversational style, because your brain is tuned to pay more attention when it believes you’re in a conversation than if  it thinks you’re passively listening to a presentation.
We included loads of  activities, because your brain is tuned to learn and remember more when you do things than when you read about things.
We used multiple learning styles, because you might prefer step‑by‑step procedures, while someone else wants to understand the big picture first, and someone else just wants to see an example.
But regardless of  your own learning preference, everyone benefits from seeing the same content represented in multiple ways.
We include content for both sides of  your brain, because the more of  your brain you engage, the more likely you are to learn and remember, and the longer you can stay focused.
Since working one side of  the brain often means giving the other side a chance to rest, you can be more productive at learning for a longer period of  time.
And we included stories and exercises that present more than one point of  view, because your brain is tuned to learn more deeply when it’s forced to make evaluations and judgments.
We included challenges, with exercises, and by asking questions that don’t always have a straight answer, because your brain is tuned to learn and remember when it has to work at something.
Think about it—you can’t get your body in shape just by watching people at the gym.
But we did our best to make sure that when you’re working hard, it’s on the right things.
That you’re not spending one extra dendrite processing a hard‑to‑understand example, or parsing difficult, jargon‑laden, or overly terse text.
In stories, examples, pictures, etc., because, well, you’re a person.
And your brain pays more attention to people than it does to things.
These tips are a starting point; listen to your brain and figure out what works for you and what doesn’t.
Your brain works best in a nice bath of  fluid.
Dehydration (which can happen before you ever feel thirsty) decreases cognitive function.
Create something! Apply this to your daily work; use what you are learning to make decisions on your projects.
Just do something to get some experience beyond the exercises and activities in this book.
All you need is a pencil and a problem to solve…a problem that might benefit from using the tools and techniques you’re studying for the exam.
Feel something! Your brain needs to know that this matters.
Groaning over a bad joke is still better than feeling nothing at all.
If  you find yourself  starting to skim the surface or forget what you just read, it’s time for a break.
Once you go past a certain point, you won’t learn faster by trying to shove more in, and you might even hurt the process.
If  you’re trying to understand something, or increase your chance of  remembering it later, say it out loud.
Better still, try to explain it out loud to someone else.
You’ll learn more quickly, and you might uncover ideas you hadn’t known were there when you were reading about it.
Part of  the learning (especially the transfer to long‑term memory) happens after you put the book down.
Your brain needs time on its own, to do more processing.
If  you put in something new during that processing time, some of  what you just learned will be lost.
They’re not optional sidebars—they’re part of  the core content! Don’t skip them.
We put them in, but if  we did them for you, that would be like having someone else do your workouts for you.
There’s plenty of evidence that physical activity while learning can increase the learning.
The more you understand, the less you have to memorize.
When the book asks you a question, don’t just skip to the answer.
The more deeply you force your brain to think, the better chance you have of learning and remembering.
Here’s what YOU can do to bend your brain into submission.
Read me This is a learning experience, not a reference book.
We deliberately stripped out everything that might get in the way of  learning whatever it is we’re working on at that point in the book.
And the first time through, you need to begin at the beginning, because the book makes assumptions about what you’ve already seen and learned.
If  you don’t know HTML and CSS, pick up a copy of  Head First HTML with CSS & XHTML before starting this book.
We’ll explain some of  the more obscure CSS selectors or HTML elements, but don’t expect to learn about that foundational stuff  here.
We expect you to feel comfy around web scripting code.
We’re not asking you to be a world‑class JavaScript expert or to have done a graduate computer science project using PHP, but you’ll see examples using both languages throughout the book.
If  the merest notion of  a for loop makes you hyperventilate (or if you have no idea what we’re talking about), you might consider tracking down a copy of Head First PHP & MySQL or Head First JavaScript and then heading on back here.
We expect you to know how to track things down.
The mobile web is an enormous topic, and mastering it involves expanding your existing web development skills.
There are too many things to know about the Web for any one person to memorize, whether it’s a detail of  JavaScript syntax or the specifics of  a browser’s support for an HTML5 element attribute.
Part of the toolset of  a good web dev is keeping your Google chops sharp and knowing when and how to hit the Web to look up info about web topics.
It’s a big and beautiful mobile web world out there.
We hope we can give you a shove to start you on your journey, but it’s up to you to keep up your steam.
Seek out the active mobile web community online, read blogs, join mailing lists that are up your alley, and attend related technical events in your area.
The exercises and activities are not add‑ons; they’re part of  the core content of  the book.
Some of  them are to help with memory, some are for understanding, and some will help you apply what you’ve learned.
They’re good for giving your brain a chance to think about the ideas and terms you’ve been learning in a different context.
One distinct difference in a Head First book is that we want you to really get it.
And we want you to finish the book remembering what you’ve learned.
Most reference books don’t have retention and recall as a goal, but this book is about learning, so you’ll see some of  the same concepts come up more than once.
For some of  them, there is no right answer, and for others, part of  the learning experience of  the exercise is for you to decide if  and when your answers are right.
In some of  the Brain Power exercises, you will find hints to point you in the right direction.
Software requirements As for developing any website, you need a text editor, a browser, a web server (it can be locally hosted on your personal computer), and the source code for the chapter examples.
The text editors we recommend for Windows are PSPad, TextPad, or EditPlus (but you can use Notepad if  you have to)
The text editors we recommend for Mac are TextWrangler (or its big brother, BBEdit) or TextMate.
If  you’re on a Linux system, you’ve got plenty of  text editors built in, and we trust you don’t need us to tell you about them.
If  you are going to do web development, you need a web server.
You’ll need to go to Appendix ii, which details installing a web server with PHP.
No, seriously, head there now, follow the instructions, and come back to this page when you’re done.
And for Chapter 8, you’ll need the Android SDK and some related tools.
You guessed it: there are appendixes for those tasks, too.
You’ll also need a browser—no, strike that—as many browsers as possible for testing.
And the more mobile devices with browsers you have on hand, the better (don’t panic; there are many emulators you can use if  you don’t have hardware)
For developing and testing on the desktop, we highly recommend Google’s Chrome browser, which has versions for Mac, Windows, and Linux.
Learning how to use the JavaScript console in Google’s Chrome Dev Tools is well worth the time.
This is homework you need to do on your own.
Last of  all, you’ll need to get the code and resources for the examples in the chapters.
The hf-mw.com site has the starting point of code for all the chapters.
The code and resources for the examples in the chapters are all available at.
Trevor Farlow is an amateur baker, recreational soccer player, and part‑time animal shelter volunteer.
When he’s not walking dogs, scoring goals, or perfecting his New York–style cheesecake, he can be found learning the art of  product ownership in a lean, mean, agile development team at Clearwater Analytics, LLC.
Brad Frost is a mobile web strategist and frontend developer at R/GA in New York City, where he works with large brands on mobile‑related projects.
He runs a resource site called Mobile Web Best Practices (http://mobilewebbestpractices.com) aimed at helping people create great mobile web experiences.
Stephen Hay has been building websites for more than 16 years.
Aside from his client work, which focuses increasingly on multiplatform design and development, he speaks at industry events and has written for publications such as A List Apart and .net Magazine.
He also co‑organizes Mobilism, a highly respected mobile web design and development conference.
Ethan Marcotte is an independent designer/developer who is passionate about beautiful design, elegant code, and the intersection of  the two.
Ethan coined the term Responsive Web Design to describe a new way of  designing for the ever‑changing Web and, if  given the chance, will natter on excitedly about it—he even went so far as to write a book on the topic.
Bryan Rieger is a designer and reluctant developer with a background in theatre design and classical animation.
Bryan has worked across various media including print, broadcast, web, and mobile; and with clients such as Apple, Microsoft, Nokia, and the Symbian Foundation.
A passionate storyteller and incessant tinkerer, Bryan can be found crafting a diverse range of  experiences at Yiibu—a wee design consultancy based in Edinburgh, Scotland.
Stephanie Rieger is a designer, writer, and closet anthropologist with a passion for the many ways people interact with technology.
Stephanie has been designing for mobile since 2004 and now focuses primarily on web strategy, frontend design, and optimization for multiple screens and capabilities.
A compulsive tester and researcher, Stephanie is always keen to discover and share insights on mobile usage, user behavior, and mobility trends from around the world.
Andrea has led both WURFL and DeviceAtlas from their earliest days to success, and during those years built vast experience in device detection and content adaptation.
You can find Andrea on Twitter as @AndreaTrasatti, regularly talking about mobile web and new trends in creating and managing content for mobile.
Thanks to Lou Barr for her unfathomably speedy and masterful design and layout magic.
Our gratitude goes to Karen Shaner and Rachel Monaghan for all the help juggling drafts, reviewers, and details!
Thanks to the rest of  the O’Reilly folks who made us feel so welcomed: Mike Hendrickson, for suggesting this crazy idea in the first place; Brady Forrest, for introducing and championing us; Tim O’Reilly, for being the genuine, smart, and nice guy that he is; and Sara Winge, for her graciousness and overall awesomeness.
Thanks to Bryan Christopher Fox (Other Dev), without whose coding chops, insight, support, and all‑around supergenius this book would not have been possible.
She endured a huge raft of  emails, questions, ramblings, and occasional crankiness.
She stuck with us throughout this book and trusted us to trust our guts.
And thanks to Brian Sawyer for stepping up at the end and taking us over the finish line.
Thank you to my family for all of  their support.
Our parents, Jan, Carol, Mark, and Doanne, were a tremendous help in keeping our sanity as we juggled book writing, family, and moving.
Special thanks to my wife, Dana Grigsby, for making it possible for me to work on a book while we raised a baby and a preschooler and moved into a new house.
Jason and Lyza work with the smartest people ever at Cloud Four.
This book is really a product of  our collective mobile web obsession, and they, more than anyone, championed and endured this effort.
We’re proud and thankful to be part of  this community.
With a subscription, you can read any page and watch any video from our library online.
Access new titles before they are available for print, and get exclusive access to manuscripts in development and post feedback for the authors.
Copy and paste code samples, organize your favorites, download chapters, bookmark key sections, create notes, print out pages, and benefit from tons of  other time‑saving features.
To have full digital access to this book and others on similar topics from O’Reilly and other publishers, sign up for free at http://my.safaribooksonline.com.
Mobile technology is evolving at bewildering speed, and there’s so much to know!
We’ll start our journey by showing you a way of making websites called.
You’ll be able to adapt websites to look great on a.
Get on the mobile bandwagon There’s a pretty good chance you own a mobile phone.
Mobile phones are being used everywhere, from farmers in Nigeria using their mobiles to find which market has the best price for their crops, to half  of  Japan’s top 10 best‑selling novels being consumed and written—yes, written—on mobile phones.
More people use mobile phones than have working toilets or toothbrushes.
The time is now So yeah, mobile is huge, but it’s been big for years.
The iPhone is fantastic, but people use a lot of different phones for a lot of different reasons.
We have no way of  knowing what the the leading phones will be when you read this book.
Three years ago, Android was a mere blip on the radar.
Mobile technology changes quickly, but there are a few things we feel confident about:
And if they don’t, are they really going to browse the Web?
You can probably find a new phone that doesn’t have a web browser in it, but you have to look pretty hard.
Even the most basic phones now come with decent browsers.
Soon the number of  people accessing the Web via mobile phones will surpass those who use a computer.
Already, many people say they use their phones more frequently than their PCs.
Each one has its own specific programming hooks, meaning that if you want to write software for each, you have to start from scratch each time.
Mobile web has its own challenges, but there is no other technology that allows you to create content and apps that reach every platform.
So you’re in the right spot at the right time.
Mobile web is taking off, and you’re ready to ride the rocketship.
Something odd happened on the way to the pub Mike is the proprietor of  The Splendid Walrus, a pub with a clever name and a cult‑like following of  local beer enthusiasts.
Mike always has unusual beers on tap and highlights several of  them on his website.
Before he realized his lifelong dream of  pub ownership, Mike was a web developer.
So he had no trouble putting together a respectable website for The Splendid Walrus himself.
If mobile phone web browsers are so great… Mike built the Splendid Walrus website several years ago, when mobile browsing was still rudimentary and uncommon.
It was made for—and tested in—desktop browsers like Firefox, Internet Explorer, and Safari.
They’re increasingly sophisticated and powerful, and starting to feel like some of  their desktop counterparts.
It didn’t look so hot on a friend’s Android device, either.
But when you’re developing for the mobile web, sometimes it feels this way.
Unlike the handful of  leading desktop browsers, there are hundreds of  different mobile browsers.
But they still pale in comparison to desktop (or laptop) computers in terms of  processing power.
Mobile networks can be flaky and downright poky, and data transfer is not necessarily free or unlimited.
This means we’ll need to think about putting our sweet but enormous, media‑rich, complex sites on a performance‑savvy diet.
On older mobile browsers (or even recent ones on less powerful devices), you can pretty much forget about reliable CSS or JavaScript.
Even the newest browsers lack support for some things, support them in bewilderingly different ways, or have weird bugs.
Just because a mobile browser can render a desktop website with few hiccups doesn’t mean it necessarily should.
People with mobile devices use all sorts of  input devices: fingers, stylus pens, the little nubbins they have on BlackBerry devices.
Typing and filling out forms can be tedious at best.
Squinting at type designed to fit a desktop browser window can give your users headaches and fury.
And just when you think you’re on top of all of them, a new one will pop up in, like, Thailand.
My site looks great in desktop Safari, so why does it.
Here’s how Mike’s iPhone 4 renders the Splendid Walrus website.
Can you spot the problem areas? Mark any problems you see.
The navigation links are all tiny and too small to read or click.
The three-column layout feels tight on this screen resolution, and the text is hard to read.
There is a weird gap on the right edge of the screen.
I want my customers with mobile devices to see a nice site.
We know that Mike makes a big deal out of  using clean, semantic HTML markup and uses CSS to control layout and styling as much as possible.
Jim: And? That’s great and professional, but how does it help us make this better?
When I look at the CSS he’s using for the Splendid Walrus site, I see a lot of widths and sizes defined to fit within a 960‑pixel box.
It looks like he’s designed the site on a 960‑pixel grid, with three main columns.
Also, three columns seems like a lot for a smaller screen.
But I don’t see how we could do that without a lot of  server‑side programming.
I mean, how do we get mobile devices to use completely different CSS?
Jim: How could I forget? It’s all she’s been talking about.
Frank: Well, she says it’s getting a lot of  attention from web developers and it sounds like it involves, at least in part, applying different CSS for different situations, without having to do heavy‑duty programming.
I can’t really remember the details, but maybe we should check it out.
Ugh! What a mess! We’re totally going to have to start from scratch...
Responsive Web Design (RWD) is a set of  techniques championed by web designer Ethan Marcotte.
Sites designed with this approach adapt their layouts according to the environment of  the user’s browser, in large part by doing some nifty things with CSS.
Depending on the current value of  certain browser conditions like window size, device orientation, or aspect ratio, we can apply different CSS in different circumstances.
By rethinking the way we do page layouts, we can make formerly one‑size‑fits‑all column and grid layouts flow more naturally across a continuum of  browser window sizes.
CSS3 media queries Evaluating certain aspects of  the current browser environment to determine which CSS to apply.
Fluid-grid layouts Using relative CSS proportions instead of  absolute sizes for page layout elements.
Fluid images and media Making our images and media scale to fit within the size constraints of  their containers by using some CSS tricks.
The recipe for Responsive Web Design There are three primary techniques for building a responsively designed website:
We can apply different CSS rules based on things like browser window width, aspect ratio, and orientation.
Fluid images and media keep within the bounds of their parent elements, scaling proportionally with the rest of the layout.
We deliver the same HTML and CSS to all devices and browsers.
This is just one example of a responsive design approach.
Different CSS in different places If  you’ve been doing web development for some time (and are CSS‑savvy), you might be friends with CSS media types already.
Another way to use media types to apply CSS selectively is from within a <link> in your HTML document.
The rules between the braces will only apply when the content is rendered on a screen.
You have certain features—your age, your height—and so do media types.
And just like The Splendid Walrus might want to establish a rule that requires the minimum age of  patrons to be 21 before they apply alcohol, we might want to define certain CSS that we only apply to browser window widths within a certain range.
We’re in luck! width, along with color and orientation, is one of  the media features defined in CSS3 for all common media types.
Media features on their own don’t get us very far.
We need a way to ask the browser about the states of  the ones we care about and, well, do something about it.
Referencing the print media type like this is a common approach to creating print stylesheets—that is, CSS styles that only get applied when the content is printed.
The rules in this external stylesheet will only be applied if the content is rendered on a print device (that is, a printer)
Common (and useful) media types include screen, print, and all.
There are other, less common media types like aural, braille, and tv.
CSS3 media queries are logical expressions that evaluate the current values of media features in the user’s browser.
If the media query expression evaluates as TRUE, the contained CSS is applied.
Rather intuitively, it means we want to query about a minimum width.
This means: are we presently rendering content on a screen, AND is the window currently at least 480 pixels wide? Yes? OK! Apply these CSS rules.
Translating CSS media queries: You try it! Match the media query and its meaning.
Apply these styles to all media types when in landscape orientation.
Apply the rules in this external stylesheet to color screens.
Is this being rendered on a printer OR is it being rendered on a screen that is monochrome (black and white)? Yes? Use these styles!
These CSS rules will only get applied if the media query evaluates to TRUE.
Apply these styles to all media types when in landscape orientation.
Apply the rules in this external stylesheet to color screens.
Now I can understand media queries and maybe even write my own.
But what am I doing here? How do I write the CSS for mobile devices?
We’ll only write different CSS for those layout elements that need to be different for mobile.
CSS: How different is different? We have a tool that lets us apply different CSS to different situations.
We do need to write some mobile‑friendly CSS, but we’re not going to have to start from scratch.
Nor are we going to have to have totally different CSS for our mobile devices—we can share a lot of  what’s already there.
Identify layout pieces that need to change to work better on mobile browsers.
Organize our CSS and selectively apply the mobile and desktop CSS using media queries.
This is what we use if we want to look at the same media feature across all media types.
The current structure of the Splendid Walrus site Take a peek at the index.html file for the Splendid Walrus site in the chapter1 directory.
If  you use your imagination and strip out the content, you can see a basic HTML page structure like this:
The current, desktop‑oriented CSS lays out the page like this:
Let’s go look at the CSS that defines the layout and figure out what needs to change to adapt it to be mobile-sized.
There’s a bunch of  CSS at the top of  the file, but we don’t have to worry about that.
We can share the same colors, typography, and styling across both desktop and mobile variants.
What we care about is the structural CSS, near the bottom of  the file.
The header, footer, and navigation elements span the full width.
The header has a background image, so it needs to be 200px high to show all of the image.
The left and right columns are each 240 pixels wide and float.
The main column uses margins to position itself—it doesn’t float.
Analyze the current CSS We’re only interested in the structural part of the CSS file.
We’re not going to have to rewrite all of  the CSS.
We just need to adapt some of the structural layout elements.
In the original, desktop layout, three columns felt “crunched” on a mobile screen.
Make the page and its structural elements fit within 320 pixels.
We need to change the width of the page and the header, navigation, and footer elements.
We need to adapt the navigation link widths to fit the smaller screen.
We need to remove the floats and change the width of the visit and points columns.
The highlighted code will need to be adapted for our mobile version.
We don’t need this rule in our mobile version (but it doesn’t hurt anything)
This is actually fine: we want the navigation links to be at least this tall.
Because nothing is floated in our mobile layout, clears aren’t necessary.
The “columns” on the mobile layout will lay out vertically, not horizontally.
Let’s add some space between columns (vertically) but get rid of the gutter.
We don’t need the margins for positioning anymore (#main will span the full width), and we need to change the width.
We’ll use the same background image for the header, so this can stay the same.
It might seem like we would need to adjust the 200px height here, but we don’t because we’ll use the same image.
This border is to add some visual separation to the columns (now vertical) as they lay out on the page.
Why? Because the CSS rules in question are going to be the same for both layouts (desktop and mobile)
We’ll put the shared CSS outside the media queries so that we don’t have to have the same CSS rules in two places.
And we’re done! These four CSS rules are all the mobile‑specific layout we’ll need.
Now we need to be sure they’ll get used by mobile devices.
And how will we do that? Our old friend Mr.
Media Query to the rescue! We’ll generate a media query shortly to apply this CSS to devices with a browser window of  480 pixels wide or narrower.
Our desktop structural CSS We still need to have good CSS for desktop browsers!
After we remove the common structural CSS rules, here’s what we end up with for the desktop‑specific CSS structure.
We’ll need to use a media query so that only viewports 481 pixels and wider apply this CSS.
Identify layout pieces that need to change to work better on mobile browsers.
Organize our CSS and selectively apply the mobile and desktop CSS using media queries.
What’s next? Let’s check in on our to‑do list for creating structural CSS that works for both desktop and mobile browsers:
Here’s the shared structural CSS that we identified on page 18, factored out and ready to go.
You’re going to need a viewport <meta> tag in the index.html file.
These tags help tell the browser how “zoomed in” to render the content.
We’ll be taking a look at these guys a bit later on, but for now, just take our word for it: you’ll want one of  these.
Here’s how we’ll put together the updated version of  styles.css.
We didn’t make any changes to this part of the CSS.
Test Drive Once you’ve made these changes, load the index.html file in your desktop browser and resize the window to less than 481 pixels wide to see the mobile‑friendly layout.
You’ll be replacing the structural CSS rules near the bottom of  the file.
I thought the mobile CSS we created would fix this.
Jill: Your CSS makes the layout fit on a smaller screen, but it’s still pretty rigid.
I mean, look what happens if  I put my iPhone in landscape orientation.
Am I going to have to write different CSS for every single different possible viewport size?!
Right now, you’re delivering a rigidly sized structure to all browsers whose current window is 480 pixels wide or smaller, no matter what the actual specific browser window width is.
I mean, not all mobile devices have a 320‑pixel‑wide browser window.
Responsive design helps us adapt our layout to different situations.
Instead of dictating the exact size of  elements—that is, using pixel‑based measurements in our structural CSS like we are now—we can use a proportional layout, which adapts much better for different users.
Frank: Proportional? Is that like ems and percentages and stuff  in CSS?
We can use percentages instead of  pixels when we code up our layout.
That way, content stretches and shrinks to fill available space—kind of  like water filling in gaps.
That’s why this kind of  layout is often called a fluid layout.
And, by the way, this will help us fix that wayward image as well.
Frank: So, all of  that work with media queries was wasted time.
Jill: Not at all! Media queries are a big part of  what makes responsive design work.
The next step to move toward a responsive design—one that will work more comfortably on more devices and browsers—is to convert our fixed, pixel-based layout to a proportional, fluid-grid layout.
This photo is wider than 320 pixels, breaking out of the layout.
This is a good start, but there’s a bit of a problem.
If I scroll down on my iPhone, you’ll see that the photo is too big for the page.
I know you’ve been around a while and seen a lot of  action.
But, no offense, there are a few problems with your philosophy.
Your rigidly defined dimensions make you seem brittle and inflexible.
Look at what happens when we look at you in different browser window sizes.
Stuff  is cut off, or there’s a bunch of  blank space.
Maybe that worked in your day, but these days there are simply too many kinds of  browsers and devices.
If you’re willing to let go of  pixel‑perfect layouts—hey, they’re a holdover from the old print days of  yore, anyway—and let your content flow, like water, into the available space in the browser window, you can really adapt for different situations.
What’s that? What’s a young upstart like you know about philosophy?
If  users don’t like it, they should straighten up, get a haircut, and use a standard browser.
What’s wrong with a fixed-width layout, anyway? If  the whole world were full of  browsers whose windows were always the same size, it would be a safe, pretty world in which designers could have pixel‑perfect control over what a website looked like.
But that is mostly an illusion: there is no standard browser window size.
And that’s before you even start thinking about mobile devices.
Sure, the fixed‑grid layout for The Splendid Walrus looks fine at 960 pixels wide.
In a wider window, the entire layout is still only 960 pixels wide, leaving a blank gap of  wasted space at the right side of  the screen.
The layout doesn’t adapt to other window sizes But in a narrower window, look what happens.
The column widths stay the same, which means content gets cut off  and the user has to scroll horizontally.
Fluid‑grid layouts use proportional units (percentages) instead of  pixels for widths.
We’re about to convert both the desktop and mobile CSS from fixed to fluid grids.
Can you think of some ways this might help solve some of the problems Jill found with the site on mobile browsers?
The layout adapts as the window changes size In different window widths, the content flows, like water, to fill the available spaces in the layout.
The left and right columns always take up 25% of  the window, and content is not clipped in narrower windows, nor is there any empty space in wider windows.
Left and right columns are proportional: 25% of the window’s width.
The fluid formula To convert a pixel‑based layout to a proportional, fluid one, use this formula:
A closer look Let’s take a look at what this means, using the Splendid Walrus site’s desktop layout.
We start with a context on which to base our proportions.
In this case, our reference design is 960 pixels wide.
We want our resulting, fluid layout to have the same proportions as the current design does.
The navigation, header, and footer all span the full width of  the page.
That makes the fluid formula very easy to apply indeed!
Convert the pixel‑based layout to a fluid one, using proportional widths instead of  fixed.
Make the default body font size 100% so our page’s fonts can scale up and down proportionally.
There are a number of  things we’ll need to do to address the problems Jill found and move toward a responsive design.
If we’re going to make our layout fluid, we’ll want to be sure our fonts are flexible, too.
To get a proportional measurement, use the fluid formula again:
We can still use the fluid formula to convert the pixel‑based margin sizes to percentages:
Finish converting the structural desktop CSS rules in styles.css to proportional widths.
You’ll want to edit each of the six CSS rules within the media query for window widths of 481 pixels or greater.
Q: Why are there so many decimal places in these numbers? Do we really need all that?
A: We’re demonstrating the purist fluid‑grid approach here, which builds CSS units exactly as the numbers come off the calculator.
You might consider rounding the numbers down to one or two digits past the decimal point.
Another approach is to leave some play in your layout—a percentage or two not accounted for at all.
Your grid won’t be as precise, but you avoid some of the pitfalls of rounding issues and make your arithmetic less rigorous.
A: Vertical layout is a totally different beast than horizontal.
We can’t use the 960px context because the height of the design is never really a known quantity, and vertical layout using percentages is a tricky affair, supported in different (and sometimes poor) ways in different browsers.
So, to convert to a proportional width, we divide the pixel width of an element by the overall layout width, right?
Mike has a new monthly special that he wants to post on the Splendid Walrus site.
Instead of  text and a single image in the main column, as it is now, he wants to display the beer labels of  two very special, limited‑edition stouts—floated next to each other.
It’s tempting to think that the formula for converting these image widths to be fluid would be:
I’m going to start offering some new beer specials, and I want to be able to feature those on the sitecan you adjust the design?
Instead, we set the context in our formula to be the reference width of  the containing element, which in this case is 460 pixels.
Setting image widths as percentages? Turns out, this is on the right track to fixing one of  our other problems with the mobile layout.
Remember that photo that is too big and messes up the page width? We can use a variant of  what we’re doing here to fix that!
This is what you’ll get if you set the width of img.label to be 22.916667%
Fluid images There’s a lot of  power in this little gem of  CSS:
A sad farewell… Most great things don’t come without a bit of  sacrifice.
To use the fluid technique on images and media, we have to forego our old friends: the width and height attributes.
The CSS rule above will override a width attribute but will not affect a height attribute.
That means that, if  we use height and width attributes, we could end up with an image that scales its width but not its height.
End result: a sad‑looking squished image in the wrong aspect ratio.
OK, there are some workarounds for this, and removing these attributes is not awesome.
But we’re going to jettison the height and width attributes for now.
With this quick addition, we help to prevent any image or embedded media object from being wider than its containing element.
Fluid images and media, like fluid grids, scale proportionally within the layout.
In Chapter 2, we’ll talk about techniques to deliver different images to different devices and browsers, saving on otherwise wasted bandwidth and processor power (required to do the actual scaling)
Still, it’s a powerful technique, and one definitely worth having in your arsenal.
Are we there yet? We’re making progress toward a responsive design that adapts to more devices.
But we have a few things left to track down:
We still need to convert the mobile CSS (we did the desktop CSS already)
Spiff up the mobile CSS There are just a few mobile‑specific CSS rules we need to convert to be fluid.
Convert the pixel‑based layout to a fluid one, using proportional widths instead of  fixed.
Make the default body font size 100% so our page’s fonts can scale up and down proportionally.
Hey! Now that we’re proportional here, these two rules are exactly the same as the desktop ones (see page 30)
Might as well put them in the common structural CSS instead of having them in two places.
Let’s take care of  a few remaining details to make our updated version of  the Splendid Walrus site totally responsive.
Set up flexible fonts So far, our layout is adaptive, but the fonts are stodgy and rigid.
Just as percentages are the fluid ying to pixels’ fixed‑width yang, ems are proportional font‑size units.
Mike used ems in his original CSS, so we’ll just add the following rule to the <body> element to be extra thorough:
But what does 100% mean? Here’s a quick‑and‑dirty (and approximate) rule of  thumb:
But recall that we aim to adapt our content to the user’s environment.
If  a user has changed the browser’s font size, 100% is going to represent a different absolute size.
Also keep in mind that fonts on mobile devices are a complex thing, and that in some cases, 1em might equate to a (significantly) different point or pixel size.
The markup for the embedded YouTube is out of  date: YouTube now provides an iframe‑based embedding snippet that will work just fine on an iPhone (and other modern devices)
We need to edit the index.html file and replace the current embed code.
This baseline font‑size reset is the CSS equivalent of  dotting our i’s and crossing our t’s: it’s setting an explicit reference against which the other font sizes in the CSS are defined.
YouTube’s newer embed code determines the appropriate video format to use depending on the browser.
It can supply HTML5 video instead of  Flash for devices—like Mike’s iPhone—that support it.
We simply grabbed this newer snippet from the “embed” section of this video’s YouTube page.
Edit the CSS rules within the media query for lower‑resolution devices.
Identify the structural CSS rules that are common between both mobile and desktop variants now that they are proportional (page 34)
OK! Let’s get all of these changes in place to give The Splendid Walrus a mobile‑friendly site that uses Responsive Web Design techniques.
Save your changes and load the index.html page in any web browser.6
Try resizing your browser window and watching the content adapt.
Remember to be responsible Just like fluid image resizing doesn’t actually reduce the file size of images, neither does fluid media change the size of  the actual media.
It’s up to you to determine whether using video (or other multimedia) on mobile devices is worth the file size and processor oomph required for playback.
I’ve seen ems as units in CSS, but I don’t quite get it.
But the magic comes when you define your font sizes in relation to this.
You can actually use the same fluid formula to generate fluid, em‑based font sizes from fixed font sizes.
A: Mostly tradition and clarity, but ems do tend to work a smidge better across platforms.
It is common web practice to define block element widths in percentages and font sizes in ems.
With some really teeny exceptions, percentages and ems are interchangeable for font sizes.
Q: Is there any other use for CSS media queries beyond the mobile web?
An example: just as mobile devices often represent the lower end of the screen resolution spectrum, some of the newer widescreen monitors and televisions have very high resolution.
Sometimes it makes sense to adapt a layout—say, to add more columns—for these window widths.
Q: What actually caused the weird gap at the right side of the screen in the exercise way back on page 7?
When displaying a web page “zoomed out” (i.e., when it’s acting like a desktop browser), mobile Safari on the iPhone assumes a viewport width of 980 pixels.
It’s tempting to say that there are three, but the situation is a bit more cloudy.
Fortunately, the Media Queries module is one of the more complete and stable.
Q: If CSS3 isn’t all the way “done,” do browsers support it?
Adoption for some of the more complete pieces of CSS3 is becoming widespread, but, as we’ll see a bit later, is far from something that can be assumed in the mobile space.
Q: Why does the right column show up before the main column in the mobile layout?
The mobile layout doesn’t use floats, and as such, the content is displayed in the order it occurs in the HTML.
So little, in fact, that we didn’t even mention it.
But, yes, it absolutely works for including stylesheets based on media types and for media queries, too.
Let’s walk through the resulting CSS file and look at our changes.
This is right near the top of the CSS file.
The photo fits correctly on this Android Nexus S phone, thanks to the fluid images technique.
We’re using the same header background image in our mobile-optimized CSS, even though it’s getting seriously cut off.
Can you think of how to use RWD techniques to use a different image (to save on bandwidth and improve performance)?
The mobile web is not unlike the Wild West—it’s full of surprises and adventure.
The mobile web browser landscape is diverse, and, sometimes, crazy‑making.
Just because we can use the same layout on a mobile device as in a “traditional” browser doesn’t mean we necessarily should.
Responsive Web Design (RWD) is a collection of approaches to make our web content adapt to the user, not the other way around (forcing the user to look at rigidly formatted pages)
It’s also a way of thinking about layout and content.
CSS3 media queries let us apply CSS selectively to different user environments based on the current value of relevant media features.
Media types (e.g., screen, print, projection) have media features (width, color, monochrome, orientation)
It’s these media features we evaluate in our media queries.
When it evaluates to TRUE, the enclosed CSS rules are applied.
A fluid layout is one that uses proportional widths instead of fixed widths such that the content of the page scales and flows naturally across a range of window widths.
Fluid images are a CSS technique that keeps outsized images (or media) from “breaking out” of their parent elements when the parent element width is smaller than that of the image (or media)
The images and media scale down as the parent element scales down.
Using a simple font-size reset on the <body> element and defining font sizes in ems or percentages keeps our type fluid.
Letting go of pixel-perfect layouts and instead designing our content to adapt to different (browser or device) environments.
It may look like a mobile site, but it’s still a desktop site in mobile clothing.
If we want this site to be greased lightning on.
When we’re done, you’ll have a page that is optimized regardless.
Just when you thought it was time to celebrate… Mike called in a panic.
As a reformed web developer, he normally resists the urge to tinker with his site, but he fell off  the wagon and decided to make a few tweaks.
He thinks he broke the Splendid Walrus site and needs help.
Mike added pictures for all of  his new brews to the On Tap Now page.
He didn’t modify the code other than to add pictures, but now the page is loading very slowly on mobile phones.
But in this case, I’m not so sure he did anything wrong.
Jim: That makes sense, but it still seems slower than expected.
Mike says that even on a WiFi network, it is unbearable.
Joe: Hmm…it sounds like we should at least look into it to see if  there is something obvious slowing it down.
Frank: How will we know what’s going on? It could just be the network or any number of  things between the phone and the server.
Joe: I’ve been using a plug‑in for Firefox that gives you a grade on your page performance.
Without them, how do we know what’s really going on?
Jim: The other day, Kim was showing me how you can watch every request that is made on our WiFi network through the network router’s log page.
Could we look at something like that and watch what the phone does?
It is very similar to what Kim showed you, but it is designed for exactly this purpose.
If  we hook up the phone to a proxy server, we can see all of  the web requests that the phone makes.
The YSlow plug-in gives you a grade for performance based on how a web page is constructed.
Speaking of which, we’re going to spend a little time looking at performance.
We’ll get to mobile-first Responsive Web Design soon, and we promise all of this performance stuff is related.
Waitress, will you take my order please? A famous athlete is stricken with food poisoning the night before a big match against his archrival.
The police suspect foul play and have assigned a detective.
The detective quickly starts questioning the best witness: the waitress.
The waitress took the food order, wrote down the request, and handed it to the cook.
After the food was ready, the waitress brought the food out.
Most of  the time when you’re on the Web, you’re talking directly to the cook.
Nothing is between you and the web server for the page you’re visiting.
But if  we have a proxy server act like a waitress, it will record both what was ordered and delivered by the browser.
Now we can be our own detectives and dig into what actually happened.
Can I get a proxy to set up my proxy? If  you do a lot of  mobile work, you may find it worth your while to learn how to set up a proxy server.
It is the best way to see what’s going on between the phone and server.
Unfortunately, setting up a proxy server can be a tad difficult.
Thankfully, some kind souls at Blaze, a mobile performance company, have set up a free service that is the next best thing to installing your own tool.
Your personal computer can act as a proxy server with the right software.
What to do when things aren’t blazing fast Blaze provides Mobitest—a free mobile performance test using real iPhone and Android phones.
You tell it what web page URL you want to test and what device you want to test with.
Mobitest then puts your test request in a queue for that device.
When the phone you requested is available, Blaze tracks all of  the communication between its test phone and the web server so you can see what happened.
There is even a fun feature that records a video of  the page loading so you can see what someone using that phone would see.
Ready for some detective work? It’s time to figure out why the On Tap Now page is slow.
The load time tells you how long the page took to load on this phone during this test.
The page size is the total size of  all resources associated with the page including HTML, CSS, JavaScript, images, fonts, etc.
Not only will the speed of  networks vary, but the phones themselves may also vary in the speed at which they process and display pages.
Don’t let its looks fool you, that’s a BIG page Yikes! The test says the page is approximately 3 megabytes in size.
That would be a pretty big page for a desktop browser.
It takes over 10 seconds to load on a test iPhone.
What is a waterfall chart? I looked at it, and it doesn’t tell me what’s making the page so big.
The chart shows the files that the browser requested from the server to build the web page.
The bars represent the length of  time spent downloading a resource.
The resources are listed in the order in which the browser requested them from the server.
But don’t go chasing the waterfall on the Blaze report page.
It doesn’t have the details we need for our detective work.
We’re going to show you how to find a waterfall that is more useful.
Click to see a larger version of the waterfall chart.
Just because a screen is big doesn’t mean the connection is fast.
There’s gold in ’em HAR hills There is a nugget buried in the Blaze Mobitest results page behind the tiny View HAR file link.
Click that link, and you will go to a new site called the HTTP Archive Viewer and see a more detailed waterfall than the test results page.
This waterfall chart shows us every resource that the browser downloaded in much more detail than the picture of  the waterfall on the Blaze report page.
You’ll find the “View HAR file” link next to the Twitter and Facebook links.
The preview tab contains a waterfall chart for the page we tested.
Do you see any suspicious files being downloaded in the waterfall chart?
It is a file specification that provides a standard way to record what happens when a browser requests a web page from a server.
The HAR waterfall charts show you the files that were downloaded, how the server responded, and the time it took to download.
But before we dig into the waterfall chart itself, let’s take a look at the high‑level statistics.
Click the Show Statistics link on the HAR Viewer page to see a series of  four pie charts.
The chart that matters most to us is the second one, which breaks down the page by type of  file.
Hover your mouse over each file type to see its total file size.
There’s nothing on this page that uses JavaScript, but it’s downloading eight JavaScript files.
We need to figure out why the images and JavaScript are so big.
See the pie charts by clicking Show Statistics on the HAR Viewer page.
Usually GET, but can be POST if it’s a form.
Each line shows a different file requested to build the page.
Hover over it for a pulldown menu with which you can add more information to the chart (e.g., the type of file)
Size of the file downloaded Time required to download the file.
The bar graph shows when the file request started and when the file completely downloaded.
Only a few files can be downloaded at the same time.
Find the drags on page speed Now it’s time to dig into that waterfall chart to find where the big images and JavaScript are coming from.
Review the waterfall chart for the On Tap Now page.
The amount of  communication between the browser and the server can be overwhelming, but don’t worry.
You just need to look for two things: which resources are the largest, and where is the JavaScript coming from?
Click the plus sign to get more details about what the browser asked the server and how the server responded (aka the HTTP headers)
If the file is an image, what is its height and width? Hint: You may need to copy the image URL and open it in a new tab or download the image to find the dimensions.
What does this information tell you about what you might need to do to make the page faster?
Did you find the problems with the page? Let’s review.
What type of file is it? You can determine the type of file by hovering over the filename to see the full URL and extension.
You can also add a column containing the file type so you can scan the list quickly.
Click on the down arrow next to the URL to add the file type column.
What domain is the file coming from? Now we’re getting somewhere.
Check out where this big, 174.8 KB JavaScript file comes from.
At 174.8 KB, this is the largest JavaScript file on the page.
Hover your mouse over the file name to see the full URL.
The browser is downloading JavaScript for a map that isn’t displayed on the mobile view.
Many of the mysterious files are related to Google Maps.
If the file is an image, what is its height and width? Find the images with the largest file size.
Copy the URL and open them in a new window.
Without even looking at the height and width, you can tell that these images are far larger than the size they appear on a small screen.
Same file (121 KB) used for both despite the different sizes at which the image appears.
Where did that Google Maps JavaScript come from? When you view the On Tap Now page on a mobile phone, the page doesn’t contain a map.
Why is that JavaScript downloaded? Let’s open the page in our desktop browser and investigate.
Mike must have set it up so that it only shows up on wider screens.
Older phones may not be able to handle the map’s complex JavaScript, and we’ve seen that the map has a lot of  overhead.
One line to download them all The map is included in the page via an iframe.
The iframe loads all of  the components necessary to make the map.
Extremely long URL abbreviatedThis single iframe causes 47 files to be downloaded!
Mike hid the map with CSS Mike figured out how we used media queries to modify the layout for mobile.
He added in his own CSS rule inside our media query.
The rule Mike added sets the display for the iframe to none.
Unfortunately, while setting the display to none will prevent the map from showing up, it doesn’t prevent it from downloading.
This rule hides the Google Maps iframe by setting the display to none.
What’s with the big pictures? The images on this page need to be put on a diet.
Let’s look at the waterfall to find the biggest images and see why they’re so big.
But that huge file is the header image, and it isn’t.
The taps.jpg image has been hidden from the page in the same way as Google Maps—the display property has been set to none in the CSS.
But, as we saw with the map, setting display:none doesn’t stop the content from downloading.
View the On Tap Now page in a desktop browser to see where the image is used.
So this isn’t a new issue, but when we only had one or two images on the page, it wasn’t noticeable.
But when you put 16 brew labels on one page, suddenly the fluid images are an anchor slowing the page down.
Finding a way to optimize these images is key to making the page faster.
It looks mobile friendly, but it isn’t Jim: Well, that’s a bummer.
Frank: At least we can tell Mike he didn’t break the page.
Joe: Yeah, any of  us could have made the same mistake.
The problems are really bad on this particular page, but I think the same issues exist on every page on the site.
Frank: So what do we do? Build a whole separate site for the mobile version? Ditch Responsive Web Design?
There’s got to be a way to make it work.
Do the image and JavaScript problems have anything in common?
We’ve got big files going to the browser by default and then CSS is being used to try to cover them up.
But it seems that, if  we’re not careful, the large files will still be downloaded by mobile devices.
That’s not the ideal fallback behavior if  something goes wrong.
Joe: What if  we flipped things around and sent the smallest files by default?
Start with the mobile templates first and then add on content for desktop.
Frank: What you’re describing sounds a lot like progressive enhancement.
The only difference now is that we’re starting from mobile and progressively enhancing the document to fit the desktop.
Those with more capable browsers get additional layers of style and interactivity that enhance the experience.
Mobile-first Responsive Web Design Mobile-first Responsive Web Design (RWD) is exactly what the name suggests: RWD techniques that start from a mobile template.
Despite its simplicity, there is a lot of  power that comes from this approach.
Because there is more room, we can add optional content like sidebars.
What is progressive enhancement? Progressive enhancement views web design in a series of layers.
If  you stop right there, you have a document that nearly every browser in the world can read.
After you’ve got the basics out of  the way, you add a presentation layer using CSS and a behavior layer using JavaScript.
You never assume the browser supports those features, but if  it does, visitors get a better experience.
For many years, web developers commonly built things that only worked on the most advanced browsers and tried to make sure the web page degraded gracefully on older browsers.
Benefits of mobile-first design Mobile‑first RWD isn’t that different from progressive enhancement.
Recognizing this fact, many call it content-first design instead because content is the first layer of  progressive enhancement.
Regardless of  what you call it, starting from the most basic document not only reaches the most people, it also has beneficial side effects.
Simply by eating on a smaller plate, you’re likely to eat less food.
And once you’ve got a focused mobile site, you’re better prepared to ask the tough questions like whether or not the things that didn’t make the cut for mobile are really important enough to add back in for desktop.
Semantic markup means HTML tags and attributes that convey the meaning of  the content.
Many web developers use classes in a standard way called microformats to provide more semantic meaning.
Instead, you choose the right semantic tags and attributes for the content of  a page whenever possible.
Let’s turn this web page around Because we’re already using RWD, making our page mobile first won’t take too long.
Here is a short list of  changes we’re going to make.
Make the HTML as simple as possible and swap the order of  the CSS so that the mobile version is first.
Fix CSS background images so that only one file gets downloaded per image.
Supply different source files for <img> tags at different screen resolutions.
Use JavaScript to add Google Maps to the page when the browser can support it and the document is wide enough to accommodate it.
The current structure of the On Tap Now page Open up the ontap.html file for the Splendid Walrus site in the chapter2 directory.
The file looks very similar to the document we built in Chapter 1:
Because we did a good job of  creating a template with semantic markup, the document is clean and simple already.
It looks like our main task to make the content mobile first will be removing the Google map.
Because we’re going to need to reference the code later, let’s use HTML comments to prevent the iframe from being included in the page.
Am I on a new page or not? The On Tap Now page looks so similar to the home page.
We have a problem with the order of the content.
On the home page, it was fine if  the first thing on the mobile view was the Visit Us information.
But if  the Visit Us content repeats on every page, visitors won’t be able to tell that the page has changed without scrolling down.
We need to reorder the content so the On Tap Now info comes before the Visit Us content.
Is the Visit Us content essential on this page? Would it be better to move it to a separate page and link to it? Or maybe leave it out of the mobile page and add it using JavaScript if the page is rendered on a larger screen?
Fix the content floats The change we made to the order of  the content broke the layout in a desktop browser.
The Visit Us section is at the bottom of  the page.
In Chapter 1, we mentioned how putting the right column before the main column was a trick to make it easier to handle floats for layouts.
If  you want a block to float next to something, you need to put it first in the source order.
We’ve been floating the Visit Us content to the left of  the On Tap Now content.
Instead, we need to float the On Tap Now content to the right of  the Visit Us content.
In Chapter 1, we started with a desktop website and made it mobile.
We’re going to turn this around and start from the simplest content and build up to the desktop (and beyond)
Mobile first is a little bit of  a misnomer when it comes to the CSS.
Before we apply any media queries for small screens, we’re going to set all of  the basic styles—for color, type, etc.—and then enhance them.
So we need to make sure they at least get the basic style rules.
Put your CSS house in order CSS files are often like the kitchen junk drawer.
It may start out organized and logical, but over time chaos takes over.
To put mobile‑first media queries in place, you may need to untangle the basic style rules from the layout rules.
Fortunately, the CSS we built in Chapter 1 is already in good shape.
Most of  the basic style rules are already at the beginning of  the file, with the media queries adding the layout and formatting later in the document.
All we need to do is put the mobile media query before the desktop query.
Move the mobile media query block above the desktop media query.
By doing this, we’re making sure the cascading effect of CSS is consistent with our mobile-first progressive enhancement approach.
Load the page in a few desktop and mobile browsers to see how it looks.
Surprise! The page is broken in Internet Explorer Don’t tell us you didn’t see this coming the moment we hinted you might want to test the page in Internet Explorer (IE)
Battling IE is a rite of  passage for web developers.
You’ve probably been scarred enough from previous battles that you knew there was an IE‑sized monkey wrench awaiting us.
Now before you toss the book aside and curse us for teaching something that doesn’t work in the world’s most popular browser, take a deep breath and relax.
Because IE 8 and below don’t support media queries, IE isn’t getting the CSS rules that create columns.
IE9 and above do support media queries, so help is coming.
Internet Explorer’s escape hatch: conditional comments Microsoft has provided a nice tool to help web developers target code specifically to Internet Explorer via conditional comments.
This tests to see if the browser is l ess than (lt) IE 9 and.
The HTML comment opens on the first line, but doesn’t close until “-->” is included on the final line.
Other browsers will see this as a comment and ignore its content.
If the conditions are met, IE will do whatever is in between the opening [if] statement and the closing [endif]
The example shows a link to a CSS file, but it could be anything you would find in an HTML document.
Use conditional comments with a media query You probably noticed that the conditional comment points to layout.css.
We’re going to grab some of  the rules from the current stylesheet.
We’ve called the new file layout.css because it will only be used for browsers that have enough screen real estate that multicolumn layouts make sense.
Create a blank text file called layout.css and copy the desktop rules into it.
Make sure you copy everything between the beginning and end of  the media query, but not the @media rule itself.
After you copy them, remove the rules and the surrounding media query from taps.css.
For browsers that support media queries, we’re going to add a link to the new layout.css file if  the screen size is wide enough.
The 481px value for min-width was copied from the media query we removed from taps.css.
Now we just need to add the conditional comment we created earlier to finish up.
The conditional comment repeats the line above it, ensuring that desktop IE sees our layout.css file.
Check the page in a browser that supports media queries and different versions of  Internet Explorer.
Even our persnickety old friend IE is showing the layout properly now.
Q:With super-fast 4G phones on the horizon, is performance really that big of a deal?
Even 4G phones end up on the EDGE network occasionally (EDGE is an older, slower network)
Studies show that slow sites decrease usage and directly affect the bottom line.
Q:Why am I getting different results from the Blaze Mobitest?
Page download time will change with every test depending on network traffic.
Google Maps code is different for each operating system and may change over time.
The behavior of the phones will also change as new versions of the operating systems are released.
Don’t worry too much about the variations in test results.
What matters is the code and images being downloaded unnecessarily.
Q: By separating the stylesheet into two files, aren’t you making the site load more slowly?
A: It is true that the number of HTTP requests makes a big difference in the download speed.
In this case, we thought it made more sense to separate them so IE could use the same file.
Q: You mentioned that setting up a proxy server might make sense.
A: There are many proxy servers, including some fantastic open source ones.
We happen to be fans of a commercial product called Charles Proxy.
Q: The lack of plug-ins seems like a big deal.
How do you get anything done without Firebug and Web Inspector?
First, a lot of your debugging work can be done in a desktop browser so long as you are careful to test on real devices at some point in the process.
There are also a lot of new tools that attempt to get around the plug‑in limitations.
The Mobile Perf Bookmarklet (http://bit.ly/ mw-perf) includes many performance tools.
Q: It doesn’t seem like much changed when we switched to mobile-first media queries.
A: For this page, there wasn’t a big difference between a desktop‑first CSS file and a mobile‑first one.
With more complex styles, you often want the wider rules to override some, but not all, of the styles set for smaller screens.
Reordering the media queries ensures that the CSS cascading behavior is consistent with the goal of progressively enhancing the page as the screen gets wider.
Q: It seems like the order of content may often be different between desktop and mobile.
A:Ah, you caught that, huh? Yes, this is one of the common challenges for Responsive Web Design.
In the long run, the Flexible Box Module (Flexbox) in CSS3 promises an easy way to reorder content in stylesheets.
Combine Flexbox with media queries, and you can completely reorder pages as needed.
So developers resort to JavaScript to reorder content or combine RWD with device detection (see Chapter 5)
Frankly, content ordering and image handling remain two of the biggest challenges for RWD.
Q: Will the versions of IE that don’t support media queries see the responsive design? Aren’t media queries necessary?
It will still have the fluid grids and flexible images.
But it won’t change based on any of the media query instructions.
If media query support is critical, there is an open source library called Respond.js that fills in support for media queries for older IE versions.
This is a fairly intensive script, so be sure to test extensively if you decide to implement it.
How are we doing? We’ve got the basics in place and our CSS in order.
Play taps for the header image Our waterfall chart showed us that we had one large CSS background image that was being hidden with display:none.
Despite the fact that the image never shows up on the page, the browser still downloads the image.
So let’s make sure the image is only downloaded when it is needed.
How do we do that? By putting it in a media query so it only gets downloaded if  the screen is wider than 480 pixels.
But instead of  creating a whole new media query, put the CSS rules in layout.css, which is already being included in the page via a media query in the <link> tag.
Remember our friend, taps.jpg, which downloads on mobile but never shows up on the page?
Copy these lines from taps.css and add them to the end of layout.css.
Check the On Tap Now page using the Blaze Mobitest to make sure taps.jpg is no longer being downloaded.
You can use http://hf-mw.com/ch2/ex/3/ontap.html if  your copy of  the page is not on a public server.
Make the HTML as simple as possible and swap the order of  the CSS so that the mobile version is first.
Fix CSS background images so that only one file gets downloaded per image.
Supply different source files for <img> tags at different screen resolutions.
Use JavaScript to add Google Maps to the page when the browser can support it and the document is wide enough to accommodate it.
It works on iPhone, but the image is still downloading on Android.
Blaze’s Mobitest says Android is still downloading the image, but it is a false report.
Blaze had to modify its phones to make them work for remote testing.
When you use a stock Android phone, the taps.jpg image will not be downloaded.
Going old school with image optimization Back in the early days of  the Web, web developers spent a lot time worrying about image optimization.
As bandwidth has increased, web developers stopped worrying about eking out every bit of  performance from images.
It looks like we can make the taps.jpg image smaller with some basic web image optimization.
We’re using Photoshop to optimize this photo for the Web, but you can use your favorite web image editor.
Copy the optimized version of taps.jpg from the extras folder into the images folder to replace the original, large file with a smaller version.
Faster connections are never a given, even for destkop computers.
One src to rule them all CSS images are just the beginning of  our image woes.
The <img> tag presents problems for every responsive design because there can only be one value for the src attribute regardless of  screen size.
Despite the need for multiple versions of this image depending on the screen size, HTML only allows one value for the src.
It’s tempting to replace the value of  the src attribute using JavaScript.
Unfortunately, most browsers look ahead at the HTML document and preload images before the JavaScript has been fully evaluated.
This often means one size file downloads before the JavaScript changes the src, resulting in duplicate downloads and causing the browser to reflow the page layout.
A responsive image server to the rescue If  the browser can’t ask the server for the right image, the server will just have to figure it out for itself.
We can use Sencha.io Src to deliver the best‑sized image for every device.
After the slash, add the full URL of the image you want to have resized.
Sencha.io Src will resize the image to fit the size of the device screen.
Update all of the brew label images in the ontap.html document to use Sencha.io Src.
You request an image from an iPhone, it gives you an iPhone‑sized image.
How does Sencha.io Src know what size image to deliver? It uses the browser’s useragent string—an identifier that every browser provides—to look up the device in a big database.
One of  the things these device databases track is the size of  the screen.
Once Sencha.io Src knows the screen size, it goes to work scaling the image to the maximum width of  the device.
It stores the image it created in a cache for 30 minutes so subsequent requests for the image at that size will be even faster.
No great solutions for <img> tags Using Sencha.io Src has drawbacks.
It relies on device detection, which can occasionally get things wrong (as we will discuss in more detail in Chapter 5)
It also requires you to route all your images through a third party.
The reality is that there are currently no great solutions for how to handle different image sources for different screen sizes.
But watch this space closely, because a lot of  people are trying to find a better solution.
One final tweak: optimized beer label images As with the taps.jpg image, we can reduce the file size of  the beer label images by saving them at a slightly lower JPEG quality level.
Copy the optimized images into the brew_images folder, replacing any existing image files.
If you need Sencha.io Src to provide a specific image size, it can do that for you as well.
We should have an efficient, fast, mobile‑optimized web page now.
Select the option to have Blaze run three tests on the phone to get an average.
Compare the total file size and download time of the new page to the original page.
If your pages are not publicly accessible, you can test using http://hf-mw.com/ch2/ex/4/ontap.html.
What’s a user-agent string? We’ll take a closer look in the next chapter.
That’s a blazing-fast mobile web page Our diet plan worked! The On Tap Now page is 87% slimmer than it was before.
Web performance optimization is a growing field with many more ways to make pages faster.
What other performance improvements could we make to this page?
Mike is going to love how fast the site is on a mobile phone now.
Q: Why do browsers download CSS images that are never used?
A: The browser usually can’t know for certain that an image isn’t going to be used.
It could be an image that shows up when some JavaScript or CSS activity triggers it.
The browser downloads the images in advance so people don’t have to wait if an activity suddenly triggers an image to be displayed.
Q: OK, so why don’t they download images that are within media queries?
Browser makers have seen how developers are using media queries and are adjusting browser behavior accordingly.
All of this is fairly new, which is why some browsers still download resources inside a media query that doesn’t apply.
Q: Is it safe to route our images through Sencha.io Src? It makes me nervous.
Any time you integrate a third‑party service into a critical part of your site, you’re going to be impacted if that service goes down.
Sencha has said it is committed to providing this service and that it will remain free.
At the same time, you can be sure that if a tremendously large site started using it, Sencha would need to be compensated or it wouldn’t be able to run the service.
Q: Are there alternatives to Sencha.io Src? Are there solutions to the <img> tag problem that are client side only?
A: There are many different ways to handle <img> tags in responsive designs.
A lot of work is currently underway to find a solution that doesn’t require device detection.
There are compromises with every solution, including the one we’re using for this project.
You can find an extensive review of the techniques at http://bit.ly/rwdimgs2
Q: What about other media? Do video and audio suffer from the same problems?
The HTML5 video and audio formats are a little better because they allow you to define fallback versions of the media in different file formats.
If your browser doesn’t support the first option provided, it will look at the second one.
But while better, this approach does nothing to address network speed or resolution.
Someone using a mobile phone on a wireless network probably doesn’t need an HD‑quality movie.
By contrast, Apple’s QuickTime video offers a movie reference format that delivers movies based on Internet connection speed.
Q: Is it just me, or are there a lot of unknowns and problems related to Responsive Web Design?
As with any new technique, people are still trying to figure out what works and what doesn’t.
That’s why we’re covering a lot of techniques in this book.
It’s likely you’ll need to combine techniques to deliver the best experience for your project.
Despite the challenges, the promise of RWD inspires many people to strive to build more complete solutions.
Sorry, guys! I hate to spring a new requirement on you in the middle of your.
The viewport <meta> tag tells the browser the intended dimensions and scaling (aka zoom level) for a page.
It also contains controls that can prevent users from being able to change the size of  the page.
Can be set in pixels or can be set to “device-width,” which tells the browser to match the viewport to the device resolution.
Sets the initial scale (or zoom level) of the page.
Setting it to 1 means that the document should be displayed at its normal scale.
Declares a limit on how much the page can be scaled up.
The maximum-scale is what is preventing the users from zooming the page.
The right to zoom? It seems like being able to zoom is important for accessibility.
Some web developers have gone so far as to declare that zooming on mobile is a fundamental human right.
We wouldn’t necessarily go that far, but zooming is important, and it should be considered carefully before it is disabled.
As for why designers disable scaling, there are a few reasons.
If  the page is using complex touch gestures, disabling zoom makes it easier for people to swipe successfully.
There is also a bug in iOS that causes the zoom level to change when the device is rotated into landscape mode.
The bug zooms the page in, causing the right side of  the page to get cut off.
Turn zooming back on To turn zooming back on, we need to remove the maximum-scale setting from the viewport <meta> tag.
After you turn zooming back on, rotate an iPhone or iPod Touch to see the iOS zooming bug in action.
When you rotate an iOS device, a bug causes the page to no longer fit in the viewport, cutting off the right side of the content.
Back to our regularly scheduled project With our emergency viewport adventure out of  the way, let’s take a look at our progress.
Our fast mobile page puts us very close to a mobile‑first RWD.
All that’s left to do is add the map back in if  the screen is big enough.
Add the map back using JavaScript The only remaining item is to add the map back if  the browser window is wide enough.
We’ve already seen that, if  we hide and show the map using CSS, the resources for the map will still get downloaded.
So we’re going to need to use JavaScript to add the map when appropriate.
Think of  it as a JavaScript version of  the media queries we know and love.
Grab that Google Maps iframe code that we set aside earlier.
We’re going to need to put that back into the page in order to show the map.
Make the HTML as simple as possible and swap the order of  the CSS so that the mobile version is first.
Fix CSS background images so that only one file gets downloaded per image.
Supply different source files for <img> tags at different screen resolutions.
Use JavaScript to add Google Maps to the page when the browser can support it and the document is wide enough to accommodate it.
The old saying takes on new meaning when it comes to mobile phones.
Because many phones can tell where you are via GPS and other forms of triangulation, using location to provide more relevant content is common.
Mike hid the map on mobile because it was too big.
Now that we’ve seen how many files it downloads, it makes sense to keep the map hidden.
So instead of  embedding a map on narrow screens, let’s link to the map.
To link to the map, we’ll need a <div> that our JavaScript can reference.
Why do you think we need to order it that way?
We’re going to need a contai ner for the JavaScript.
The id on the <p> tag will allow us to insert the iframe above the link for wider screens.
The breakpoint is the width at which the map will be added to the page.
Checks to see if the window viewport is larger than the breakpoint Adds a new iframe.
Build a pseudo-media query in JavaScript Let’s take a look at the JavaScript code we’re going to use to insert the iframe into the page.
These lines add all of the attributes to our new iframe element.
The attributes and their values were copied from the Google Maps iframe snippet.
This final step adds the iframe (mapElement) into the mapcontainer <div> (id) before the paragraph containing the link (maplink)
This variable is for the id of the element we want to add the map to.
We’re using a variable to make the <div> easier to change in the future.
Remove the commented-out iframe code We no longer need the original iframe code, so delete it from the HTML document.
Check the waterfall chart to see if the Google Maps code is downloading.
If your web page isn’t on a public network, you can use http://hf-mw.com/ch2/ex/5/ontap.html to test.
Does the map show up on larger screens? Open the On Tap Now page in your favorite desktop browser.
Does the map show up when the window is wider than 480 pixels?
How does the map fit into the responsive design? Try adjusting the size of your browser window.
Does the map scale like the rest of the design? Are there any problems with the map?
Open ontap.html and find the bottom of the HTML document.
We’re going to add our JavaScript as the very last thing on the page before the closing </body> tag.
Add the JavaScript to the On Tap Now page Now we need to add the JavaScript to the page.
Because the map is a nice‑to‑have feature and not essential, we’re going to make it one of the last things the browser adds to the page.
Putting nonessential JavaScript at the bottom of  the page is a great way to make a page load faster.
The browser will parse all of the HTML and CSS before it gets to the JavaScript.
Our visitors will have a usable page more quickly and won’t be stuck waiting for the map code to load.
How does the map fit into the responsive design? Uh oh.
The map doesn’t scale like the rest of the responsive design.
Not only that, but there are some screen widths where the map overlaps the beer labels.
Check the page using an iPhone on the Blaze Mobitest service.
Make your way to the detailed waterfall chart by clicking the HAR file link on the results page to see all of the files downloaded.
Now what about Android? Blaze says the JavaScript still downloads, but it is another false report.
We mentioned that Blaze had to modify its phones to make them work for remote testing.
You’ll have to take our word for it that the JavaScript works and the map code isn’t downloading on Android, either.
When the browser window narrows, the map overlaps the beer labels.
The map shows up in Chrome, which means our JavaScript is working.
Why isn’t the map scaling like the images on the page?
The iframe code for Google Maps isn’t designed to be fluid.
I bet if we change the iframe to use CSS, we can make it fluid.
Responsive Web Design is so new that widgets like Google Maps are unlikely to be fluid by default.
When companies provide widgets to embed in other web pages, they do everything they can to make sure the widget will work regardless of  the page layout.
That often means hardcoding things like height and width in the HTML itself.
Dealing with poorly built third‑party widgets is a problem for nearly every mobile site.
Responsive designs have an additional requirement that widgets be fluid.
Width and height are fixed, which prevents the map from scaling.
Many of the attributes on this iframe could be moved to CSS.
Ideally, our HTML would only contain the content and markup.
Which CSS properties map to the attributes used in the iframe?
Move iframe attributes to CSS equivalents Let’s move as many of  the iframe’s attributes to CSS as possible and make them fluid while we’re at it.
First, we need to create a list of  attributes we want to move to CSS by identifying which attributes are for presentation and which are content or metadata.
Match styles to attributes Some of  the attributes share the same name with their CSS comrades.
We don’t have to look hard to find the CSS version of width and height.
This says we want to hide any extra content instead of adding scroll bars.
Remove attributes from the JavaScript Now that we’ve got CSS doing the heavy lifting, let’s modify our JavaScript so the presentation attributes aren’t set.
Remove the lines that add the presentation attributes that we identified.
No one should have trouble finding the pub now The map got a little full of  itself, didn’t it? It nearly took over the whole left column.
Soon it will start singing, “I’m the map, I’m the map” to get our attention—unless we tame it.
If  you make the window narrow, you can begin to see why the map might be trying to get our attention.
The map gets squeezed until it turns into a thin, tall strip that is completely unusable.
We still want the map to scale, but we need to set some boundaries on how far it scales in each direction.
Setting the height to 100% makes the map longer than the tallest image on the page.
Let’s keep the map a little more under control by setting the height to 400px.
When the window gets narrow, the map gets so thin that most of  the information cannot be seen.
We need to set a minimum width so that the map doesn’t go beanpole on us.
After adding the two new lines, your #map rule in layout.css should look like this.
The map isn’t doing what we want in any of them.
The map is covering up the beer labels again when the window is narrow.
Moving the iframe presentation attributes into CSS was the first step.
Now we need to take a fresh look at our media queries.
We determined that width based on the width of  popular smartphones.
What we’re seeing with the map is that we need to look at the content of  the page when we make decisions about where to apply media queries.
I thought the whole reason for making the iframe fluid was to get rid of the overlap.
We’ve got everything in CSS now, but the map is still covering up the beer labels when you make the browser window narrow.
There’s a problem with using 480 pixels as our breakpoint for the media query.
And even if  a majority of  them do today, who’s to say that 540 pixels won’t be the most common size in the future?
A better approach is to let your content be the guide on when to make changes to the layout.
We’re not asking you to commune with your content until it starts to speak to you.
But if  you adjust the size of  your browser window until things don’t look right, the content will tell you a lot.
When those things happen, that’s where you need a breakpoint.
Then you can craft a media query to change the presentation at that breakpoint.
We shouldn’t pay so much attention to typical mobile and desktop screen sizes.
When the content breaks the layout, it is telling us to adjust our.
Time to bend and stretch that browser We need to put our content through its paces by making the page as big and as small as we can while watching for when the layout breaks.
But before we do that, we need some way of  knowing how big the screen is when something looks wrong on the page.
The easiest way to do this is to install a bookmarklet that will show you the window size.
A bookmarklet is a little bit of JavaScript stored in a browser bookmark.
Install the bookmarklet in your browser Go to http://bit.ly/window-resize and drag the link labeled Window Size into your bookmarks toolbar to create the bookmarklet.
Resize your browser and watch the numbers change in the upper‑left corner of  the browser window.
Optional: Install an extension There is an extension for Google Chrome that not only will show the window size, but will also resize your window to match common screen resolutions.
The Web Developer Toolkit (http://bit.ly/webdevtoolkit) will display page size in the title bar along with a bunch of  other useful tools.
Load the On Tap Now page in the browser with the Window Size bookmarklet (or a browser extension)
Write down the width of the browser when the layout breaks or the content looks odd.
If we’re going to create a new breakpoint to address this problem, we’ll need to do it before they touch.
As the browser gets wider, the beer labels become ridiculously big.
For our tastes, they start getting too big when the browser is 1,200 pixels wide.
Did you see other problems as you resized the browser? How significant do you think a problem needs to be before it makes sense to address it with an additional media query?
Let’s review some of the trouble spots that show up when you resize the browser.
Breakpoints to the rescue All in all, not too bad.
Just a couple of  small tweaks to the CSS should do it.
Shrink the humongous beer labels There are currently three beer labels in each row.
When the page gets wider, there is room for four beer labels per row.
Create a media query for windows wider than 1,200 pixels that changes the beer labels to four across the page.
This change only happens if the window is bigger than 1,200 pixels.
Setting the width of the list item (li) containing the beer labels to 25% will put four labels on each row.
Going to one column sooner Even if  the beer labels didn’t overlap with the map, the layout is getting very crowded at 640 pixels.
Making this change will convert the layout to a single column and hide the map.
This has the added benefit of  applying the single‑column layout to phones bigger than 480 pixels.
It’s common to make images smaller proportionally as screens get wider.
Our HTML, JavaScript, and CSS all reference 480 pixels, so we’ll need to update all three.
Narrower views go to one column and hide the map.
You can use http://hf-mw.com/ch2/ex/8/ontap.html to run your own speed tests.
Make the HTML as simple as possible and swap the order of  the CSS so that the mobile version is first.
Fix CSS background images so that only one file gets downloaded per image.
Supply different source files for <img> tags at different screen resolutions.
Use JavaScript to add Google Maps to the page when the browser can support it and the document is wide enough to accommodate it.
You guys rock! The page is fast and looks great.
Q: What exactly is a viewport? A: Imagine taking a sheet of cardboard and cutting out a rectangle in the middle of it.
Lay that rectangle over your monitor so you can only see the portion of the web page that shows through the rectangle.
Q: So the viewport <meta> tag tells the browser what size to make the viewport?
If you’ve optimized your page for smaller screens, setting the <meta-viewport> tag lets the browser know to set the viewport accordingly.
Q: What are breakpoints? A: Breakpoints are just a fancy way of describing the resolution at which a designer decides to change the layout of a page.
This is usually done via media queries checking to see if a page is narrower or wider than a certain number of pixels.
A complex responsive design may have multiple breakpoints, including some that make wholesale changes to the layout as well as some minor breakpoints that only make a few targeted tweaks to fix minor layout issues.
Q: I don’t want to prevent people from zooming, but that iOS bug is pretty heinous.
Is there any way to enable zooming and not have a broken page?
Q: Why does the overlap with the map occur in the first place?
A: Because the map is an element that doesn’t scale with the browser window.
When the window is small, the browser can’t scale the map any smaller, so the left column ends up overlapping the right column.
Q: Doesn’t adding a min-width to the map break the responsive design by creating an element that doesn’t scale with the browser window?
It seems like a decent solution here because we’ve modified the media queries to address overlapping content.
Another option would have been to use media queries to adjust the dimensions of the map and proportions of the columns.
Adding media queries to an existing desktop site may make it look good on mobile, but doesn’t mean that it is mobile optimized.
Because most mobile browsers don’t support plug-ins, there are fewer tools to assist mobile web developers.
Using a proxy server or a testing solution like Blaze Mobitest can help you see what is actually getting downloaded by a mobile browser.
Mobile-first Responsive Web Design helps optimize web pages by making sure that smaller resources are downloaded by default.
Mobile‑first RWD is another form of progressive enhancement that uses screen size to determine how to enhance web pages.
Designing for mobile first forces you to focus on what really matters, thus helping you remove cruft from pages.
Internet Explorer 8 and below do not support media queries.
JavaScript can augment media queries by testing for screen size and adding content when appropriate.
Instead of designing breakpoints based on the typical screen resolutions, let the content dictate the resolutions at which you need to modify the layout.
Beautiful, harmonious, responsively designed websites that work for all browsers and devices known to man...was it all.
The vision of  a single, responsive Web is a beautiful one...
But what happens when a stinky dose of reality sets in? Like.
Creature Comforts has agents in the field Creature Comforts International is a worldwide, nonprofit agency that helps treat sick or injured livestock in areas hit by natural disasters and provides support to affected farmers and ranchers.
Until recently, the organization relied on voice communications or the occasional ruggedized laptop for their agents to coordinate personnel and supplies.
Creature Comforts serves a lot of areas where the health and.
How can agents get and share the info they need? Creature Comforts is not a new organization; its roots go back over two decades.
It already has a lot of  internal infrastructure, including a significant “traditional” web presence built on a proprietary content management system (CMS)
An increasing need for mobile web Increasingly, the Creature Comforts staff  is finding that the most reliable—and often only—connectivity in the field is via the local cellular network.
Land‑based Internet connections are hard to find, require more equipment, and restrict mobility.
Creature Comforts needs a mobile website: one that can support a wide array of  devices on a wide array of  connections.
And it would take a huge effort to extract the group’s administrative and content‑publishing processes from its older, proprietary CMS.
We can’t touch the desktop site, at least for now.
Frank: No, but it might require a bit of  compromise.
Creature Comforts’ website is big and complicated, but the only part the group feels it is vital to make mobile‑optimized is its so‑called Comforts Logistics Portal.
This web application lets agents give and receive updates and coordinate scheduling and supply drops.
This part of  the desktop website is relatively contained and has APIs that we can use.
How do we selectively change only part of  the site?
Frank: In this case, I think we’re going to need to develop a separate site for mobile users.
We need to make this work, and work reliably, for a lot of  people scattered around the globe.
A lot of  the staff  members’ devices are donated, older phones, and the mobile connections in some of  the areas they serve are spotty at best.
We need a lean, simple, and functional mobile website that helps these folks get their jobs done.
We simply can’t wrangle their existing desktop stuff  into what we need.
Sometimes it makes sense to create a separate, standalone site for mobile devices.
There is some talk of  APIs and web applications whirling around, but.
Leave the programming up to us—your job is to help us make it look good and work well on the mobile web.
Can’t wait to get in and make the agency’s CMS deliver more mobile-friendly.
Q: What does a content management system (CMS) do? A: A web CMS is a combination of editing, publishing, and rights management tools for creating and managing web content.
Some CMSes are quite full‑featured and provide an environment for developing web applications quickly (sometimes these are called content management frameworks, or CMFs)
CMSes let administrative users, who might not be familiar with HTML markup or web design, create and manage content.
There are CMSes in both the open source and commercial spaces, written in every programming language you can think of.
Larger or specialized organizations sometimes create their own CMS software.
Most CMSes also handle the publishing of content, using templating systems or other mechanisms.
This can make the transition to support mobile devices tricky, as, in many cases, the content is tangled up with presentation layers.
Its CMS, designed several years ago, has only one set of templates.
Retooling the system from the ground up would be too expensive for the organization right now.
Q: Is adapting for mobile devices a problem with every web CMS?
Some are more easily adapted for mobile devices than others.
The problem of mixing content, logic, and presentation is certainly one suffered by many popular CMSes.
The development communities and companies behind many CMSes are actively working on subsequent releases that are optimized for delivering content to different types of clients.
And forward‑thinking folks in the mobile web world are reimagining ways of structuring content—treating content more systematically, like application data, to makes its reuse across multiple platforms more straightforward.
APIs (application programming interfaces) are systematized, clearly defined interfaces created so that different software systems can talk to one another.
An example of a popular API on the Web is the Twitter API.
The Twitter API defines a set of methods that web programmers can use to retrieve and alter data in the Twitter system.
The Creature Comforts web application team coded the part of the website that allows agents and admins to manage people and supplies among the far‑flung teams.
As part of this development, the team created an API that can be used to get and update information for team members and materials.
The API returns structured data that our mobile web dev team can use to build a mobile web version of the Creature Comforts site.
So it will make our mobile optimization a lot easier.
A script on the web server examines the incoming request and attempts to determine whether the client is mobile.
Sometimes it’s necessary to have a separate website for mobile devices and desktop browsers.
Sniff out mobile users To make this setup work—rerouting mobile devices to the mobile‑optimized site—the web server needs to know if  an incoming request comes from a mobile device or not.
We’re going to make a stab at determining whether a user is on a mobile device or not by looking at the User-Agent HTTP header sent by the browser.
There are other techniques, but user‑agent detection is a very common server‑side approach for device detection.
A user-agent string is a piece of text that serves as a sort of ID card for a client application (in our case, web browsers)
Why would the user agent for Chrome on Windows mention Safari? What’s KHTML, and how is it “like” Gecko? Like your appendix or the stumpy leg remnants in whales, some of  this is evolutionary cruft.
The vestigial “Mozilla compatibility flag” (Mozilla/5.0 in the example above) is practically omnipresent to this day, though it doesn’t mean much anymore.
Mentions of  Mozilla, KHTML, Gecko, or WebKit are UAs’ way of  claiming that their layout engines are comparable to or “better” than those.
At the time of  this writing, all WebKit‑based browsers on mobile devices except for Android mention “Safari” in their user‑agent string (Apple originally developed WebKit, basing it on KHTML)
Web browsers—and, yes, that includes mobile browsers—send a User-Agent header as part of  the HTTP request whenever the browser sends a request for a web page or resource.
User‑agent strings have long been used (and misused) by webmasters to identify (and misidentify) browsers.
Way back in the misty history of  the 1990s, so‑called user-agent sniffing was the bane of  millions of  users faced with ubiquitous “This site better viewed in Internet Explorer” (or Mozilla or Netscape or whatever the preferred browser flavor was at the time)
User-agent archaeology The structure of  user‑agent strings today is a curious and sometimes confounding patchwork of  convention, confusion, and trickery.
Full order has never successfully been imposed over how they are written.
Request body (if any) Simplified structure of  an HTTP request.
Let’s take a deeper look at the pieces of  some real‑life user‑agent strings.
Match each snippet, extracted from the user‑agent strings above, to its purpose.
So, if we use user-agent sniffing to figure out which devices are mobile, isn’t that just enforcing the same old bad behavior that created the user-agent mess in the first place?
Utter the term “user‑agent sniffing” loudly in a room full of web developers, and you’ll invariably get some stern looks of disapproval and a couple of  urgent, strangled sounds.
User‑agent sniffing rubs a lot of  developers the wrong way.
In addition, user‑agent spoofing, in which a user (purposely or not) configures his or her browser to send a different UA header, is common.
And there are thousands upon thousands of  unique UAs, with more entering the market every single day.
Detecting mobile browsers by sniffing user agents on the server can definitely seem like an inelegant and inaccurate hack.
But sometimes it’s the best (if  crude) tool for the job.
Can you think of some reasons why user-agent sniffing might be a necessary evil?
User agents don’t all use the same constituent parts, and some are outright peculiar.
There are some basic patterns that most follow, but don’t rely on that too much.
Don’t worry! We have some good tools to account for (most of) this.
What browsers are these? Curious about the example user‑agent strings used for this exercise (on page 100)? Here are the clients they came from, unmasked for you:
Different, huh? As of  OS 6, BlackBerry browsers use the WebKit layout engine, and their UA strings look a lot more like other WebKit browsers.
Q: What about the other parts of useragent strings on page 99 that you didn’t explain? What does en-us mean? What does U mean?
A: The “en‑us” is language information, and means that the browser and its interface elements are localized for English, USstyle.
Q: Is there seriously a different user agent for every build, release, version, platform, device, whim, and vendor out there?
A: Several other kinds of applications that make requests to web servers also send User-Agent headers.
These include, but aren’t limited to, search engines, crawlers, and various Internet bots (both benign and nefarious)
Sometimes web server logs capture user‑agent information about unusual things that are accessing our sites, like a web viewer built into, say, a note‑taking desktop application, or a web bookmarking tool, or a monitoring service that pings a site to make sure it is operational.
A: Why would anyone purposely ask their browser to “lie” for them, you ask?
Two common motivations are privacy and the desire for a specific experience.
Some users don’t want to share information about what browsers they are using.
In other cases, a user might want to try to see web content in a particular way.
A popular example is the “desktop mode” available in several mobile browsers.
By turning this on, users are often (and sometimes unknowingly) causing the browser to send a different User-Agent header, one that looks more like a desktop browser.
Sometimes this is done sanely, and is just fine—Windows Phone 7 desktop mode user agents are relatively easy to spot.
Take a look at the useragent string that one of the Android versions of the mobile browser Skyfire sends when in desktop mode:
If that looks an awful lot like desktop OS X Safari, that’s because that user agent is completely identical to one of the user agents for desktop Safari.
Q: But if someone has gone to the trouble of disguising his mobile browser as a desktop one, shouldn’t we respect his wishes and give him a desktop experience?
A: Though this is a delicate question of philosophy, we tend to lean toward “yes,” and fill in the gaps with responsive design (which will adapt to the environment no matter who or what the browser claims to be, assuming the browser is modern enough to support media queries and the like)
There’s a bit of a gray area in terms of whether users know what they’re doing or not, but, hey, as far as we’re concerned, you should get what.
A: Many mobile devices send UAProf (User‑Agent Profile) headers when making requests, often (but not always) as the x-wap-profile request header.
The UAProf specification gives mobile handset manufacturers a way to provide information about the device.
Usually, a link to the location of the UAProf is provided in the request header.
This sounds pretty good, but unfortunately, not all devices and browsers send UAProf headers.
Additionally, a rather unpleasant percentage of the links to UAProfs are not valid.
And there is inconsistency in the amount and quality of the data in the UAProf files themselves.
Q: OK, so, there are a million billion user agents and UAProfs aren’t all that reliable, yet you claim that there is a sane and reasonable way to do user-agent-based detection?
A:In Chapter 5, we’ll be meeting some organizations and projects whose entire existence is concerned with tracking user agents and building databases of metadata about them and other data sources like UAProfs.
Until then, we’ll keep it simple and use a basic server‑side script to look for user‑agent strings that bear the primary hallmarks of mobile browser user agents.
Straight talk: Most major sites have a separate mobile website The majority of  the world’s biggest websites have a separate mobile site, and a majority of  those use some form of  user‑agent sniffing to route traffic.
If  user‑agent sniffing is so derided, why is this the case? There must be some goodness in the user‑agent approach.
Some things seem more natural on the server side… Redirecting incoming traffic to a mobile site is something that fits naturally on the server side.
If  we’re sending mobile requests off  to a separate site—something that we’ll need to do for Creature Comfortsdecisions are best made before content is sent to the client.
There are a few other HTTP request headers that provide hints to a client’s “mobileness,” but none so ubiquitous as that maddening User-Agent header.
It’s the best option in a pile of  not‑so‑great alternatives.
We can use a simple, freely available script to perform basic mobile device detection.
Wouldn’t such a script need to go on Creature Comforts’
We’ll be able to put a simple redirect script on the agency’s existing web server.
The web team at Creature Comforts will include the mobile detection script at the top of  each page, so that mobile traffic can be redirected.
We want to be sure you have the latest version, so go get it now! Make sure to download the PHP version.
The script is available for many different languages and platforms.
The script might look a bit beastly right now, but we don’t have to do much to tame it.
We’re going to walk you through the basics of  how it works, but, really, all you have to do to get it to work is make a couple of  small changes—and we’ll show you how.
Rename this file redirect.php and save it inside the chapter3 folder.
Both look at the user‑agent string and see if  it matches known mobile values.
You can probably spot some obvious snippets like “hiptop” or “symbian.” But there are some more obscure things in here as well—these regular expressions were developed by people who really know the mobile landscape!
It redirects browsers whose user-agent string matches either of the regular expressions.
If  the browser’s user‑agent string matches either of  the regular expressions, the script sets a Location header with the designated place to redirect mobile traffic.
How does the script work? The script examines the user‑agent string and determines whether it seems mobile—and if  so, it redirects.
Make sure your working environment is seaworthy A few safety checks before we continue! The next sections—and many more in the book—require you to have a working web server that allows you to use PHP.
This can be your own computer, or you can use a hosting provider; we’re not picky.
But if  you haven’t done so yet, go now to Appendix ii and find information about how to get yourself  squared away.
Jim: Hey, Frank, how are you going with getting started on Creature Comforts’ mobile site?
Frank: I thought it might be a bit much to try to handle writing code to work with the agency’s APIs and do the mobile design at the same time, so I’ve whipped up some quick mockups for us to start with.
I used proportional widths, but figured we’re working with older phones that might not understand media queries and other things that make responsive designs work so well.
I took the desktop HTML templates for the current Agent Portal landing page dashboard thingy, simplified the heck out of  them, and refactored the CSS to be mobile‑friendly.
I used some sample data so we don’t have to worry about functionality or APIs or anything for now.
Jim: What about the mobile device detection and redirect script? How are we going to test that?
Frank: Well, you heard that we’ll ultimately put it on Creature Comforts’ server and those folks will call it from every page they serve.
But for now, we’ll want to test it locally to check out how the redirect will behave.
A few tweaks to the mobile redirect script We’ll need to make a few customizations to the redirect script so that we can see it in action.
We’ll want to add a new line to define where the script should redirect if  it sees a mobile user.
Just as there are request headers (like User-Agent), HTTP responses (sent back by the server) also have headers.
Put the contents of the chapter3 folder at the root of your web server.
If  you don’t want to put the files at the document root, no biggie.
Just be sure to update the path in the line that defines $mobile_location.
Make the edits from page 108 in the redirect script.
Open the redirect script again in your text editor (if  it’s not open already)
Add the following line to the very top of  the index.php file:
View the mockup in a mobile browser (emulator or real life).4
The mockup viewed on an iPhone 4—simple, but it works.
The mobile mockups we’ll be using throughout this chapter are just thatmockups.
The data represented is imaginary, and many links aren’t functional.
There’s no need for PHP processing in this file, so we’ll just make it .html.
Test Drive Copy the contents of the chapter3 folder to your web server's document root.
I checked with the team that handles distributing phones to.
I also overnighted you a package of some of the common phones we’re using so you can.
Because it’s made to support a wide range of (often lower-end) phones, Opera Mini acts a bit differently than full-featured smartphone browsers.
Opera Mini, huh? Hotshot browsers like BlackBerry’s WebKit browser and iOS’s Safari get a lot of  glory, but don’t discount Opera Mini! The sister browsers Opera Mini and Opera Mobile are the most popular mobile web browsers in the world.
That accounted for more than half  of  mobile web traffic in India, and over 90% of  mobile web traffic in Nigeria.
Opera Mini is especially popular in places where connectivity is slow, or data is expensive or limited.
This means that when a user goes to a web page in Opera Mini, the request is routed through Opera’s servers, where web pages and resources are compressed and optimized for mobile devices.
This optimization means fewer bytes are ultimately delivered to the device—resulting in a faster (and often cheaper) experience.
It’s also quite popular on feature phones in the US and Europe.
Let’s see how the mobile mockup looks in the Opera Mini 4.2 simulator.
Use the web‑embedded Opera Mini simulator to view the mockup at http://hf-mw.com/ch3/ex/1/
Make some notes about what looks different (or, alas!, broken)
Can you find at least four differences between the way the mockup looks in the Opera Mini simulator versus the iPhone or Android simulator (page 109)?
We’re going to be looking at the mobile mockup in Opera Mini 4.2
Fortunately, Opera has a convenient, web‑based simulator (it’s a Java Applet) that you can use.
It’ll be handy to have these phones on hand for testing.
The mockup looks pretty different in Opera Mini 4.2, huh? Let’s look at some of the places where it differs or is weird.
Because of this, the background image in the header seems kind of silly.
Italic text is not italic, and bold text is not bold.
The status message uses overflow: scroll, which is an absolute no-no on all mobile devices.
We can’t really style any of the heading elements in Opera Mini.
Bonus points if you noticed this on the iPhone or Android already!
The entire page is too wide and disappears off the right side of the screen.
Q: Why do I have to view this example on http://hf-mw.com? Why can’t I use my own copy?
That means that all web traffic goes through an Opera server.
So, the example mockup and other code bits have to be hosted somewhere that Opera’s servers can reach.
If you are doing your work on your own computer, you may well have an IP address that is not visible to the entire Internet (a so‑called internal IP address only visible to the network you are connected to)
If you are doing work on a hosting provider or otherwise have the web pages for Creature Comforts on an externally accessible web server, you can certainly use your own copy.
Not all phones are smartphones…not by a sight In many of  the countries that Creature Comforts works in, seeing a smartphone is a rarity.
This makes India second only to China in total number of  mobile phones.
While smartphones are a rarity in India, mobile phones are more common than toilets!
The UN issued a report comparing the easy access to mobile phones to poor sanitation infrastructure.
Emerging markets aren’t the only places where feature phones outnumber smartphones.
Only recently did the sales of  smartphones exceed feature phones in the United States.
Sometime in 2012, smartphones will finally represent the majority of  phones in America.
When you see reports about the explosive growth of  smartphones, keep in mind that even with that growth, it will take quite some time before all of  those old phones have been replaced.
And, hey, feature phones aren’t all that bad Sure, they cause us heartache with their older, quirkier browsers and often poor connections, but feature phones have made a huge difference in the lives of  many people around the world.
If  you want to see some serious innovation, travel to a country with an emerging market and watch how they use mobile phones for everything from farming to banking.
For many, a phone isn’t a cute, pocket‑size, lesser version of  a modern computer.
What if my users aren’t in India? In the US, everyone uses smartphones.
That’s the DOCTYPE for HTML5, an excellent and exciting choice for robust websites and web apps in this modern world, but not necessarily right if  we want to reach and support the kinds of  mobile devices that the Creature Comforts staff members use.
It’s time to introduce you to our newest friend, XHTML Mobile Profile (XHTML‑MP)
XHTML‑MP is a flavor of  XHTML developed specifically to support mid‑level and feature phones with fair to middling web browsers.
It’s a few years old now—and increasingly overlooked in favor of  its sexier, younger cousin, HTML5—but it’s still useful for projects like the Creature Comforts mobile site.
Let’s convert the mockup page to be an XHTML‑MP document.
And yes, we know we said  “two lines,” but it doesn’t all fit onto the page.
It’s a streamlined version of HTML designed to perform well on a lot of different mobile browsers.
And a lot of mobile browsers are designed to support it.
XHTML-MP is a kind of XML, so we need this XML declaration, too.
Why would we want to use that old thing? All we did was change the DOCTYPE declaration.
Explicitly using XHTML‑MP as our DOCTYPE changed the way the browser behaves!
No longer do we have the content escaping the bounds of  the page.
Instead, the buttons and floats all fit within the page width.
Turns out, Opera Mini takes the HTML5 DOCTYPE as a “hint” that it is supposed to behave a bit more like a desktop browser.
That means layout that has percentage‑based widths—responsive layouts, for example—might not work exactly as we expect.
Hey, look at that! The content fits on the screen now.
Our job is not done here: we can’t just change the DOCTYPE and call it a day.
We also need to make some changes to our code to make it actually XHTML-MP.
Though most mobile browsers won’t choke and die when they encounter an HTML5 document, they might.
And some of  the features supported in HTML5 just plain won’t work on a lot of  older phones.
It reminds us of potential mobile pitfalls and keeps us honest.
If  a feature isn’t supported in XHTML‑MP, there is quite likely a reason.
Using XHTML‑MP and staying within its bounds keeps us from wandering off  into dangerous territory.
Just like mobile‑first RWD keeps us focused on constraints, cleanliness, and the tasks at hand, so too does XHTML‑MP provide a framework within which to create a widely supported mobile website.
What’s a DOCTYPE? A: A DOCTYPE (more formally, a document type declaration) is a short piece of text at the top of SGML and XML documents that informs the client (i.e., browser) which DTD to evaluate the document against.
A:HTML is descended from SGML (Standard Generalized Markup Language), while XHTML is a kind of XML (and thus is more rigidly structured than its “X”‑less kin), so both warrant DOCTYPEs.
Each specification of HTML and XHTML has its own DTD.
Nominally, associating a document with its intended DTD would allow the rendering client to go validate the document against that DTD.
In real‑life web browsers, this doesn’t happen—web browsers never actually go out and validate against DTDs.
Q:So what’s the point of a DOCTYPE, and why do browsers insist on them?
A: Browsers perform a kind of “sniffing” (not too different from our own user‑agent sniffing earlier) on DOCTYPEs.
While they don’t formally validate documents, they use the DOCTYPE as a hint about what “mode” to assume and how to render the content.
Remember the Opera Mini situation, wherein changing the DOCTYPE from HTML5 to XHTML‑MP (or XHTML‑Basic) caused the layout mode to change? That’s a good example of this at work.
Keep your nose clean with XHTML-MP It’s not always a thrill a minute, but using a mobile‑specific DOCTYPE helps us because:
Mobile browsers (especially older ones) are less faulttolerant of poorly formed markup than.
You need to be diligent about validating your markup—bad markup can cause mobile browsers to crash, or, even worse, wretched things like making the phone reboot entirely.
How long until you buy the proverbial farm, or sell it to HTML5?
XHTML-MP 1.2: I’m not dead yet! Some people think I’ve been put out to pasture, but I’m a useful old coot.
GMWD: What kinds of  trouble can you keep me out of ?
I don’t support any frames, not even those fancy‑pants iframes.
That lets you assign digits 0–9 as shortcut keys for those anchors.
This can be very nice on phones that have numeric keypads.
XHTML-MP 1.2: Well, technically that was passed down through generations, from WML through C‑HTML to us.
XHTML-MP 1.2: I’m not dead yet, but those guys sure are.
Wireless Markup Language (WML) is gradually being phased out entirely.
It’s quite different than HTML, and my family replaced it as the preferred mobile markup variant.
C‑HTML (Compact HTML) was used a lot in Japan in days of  yore by DoCoMo.
But what it doesn’t have fills volumes: no tables, no CSS, no images.
It looks like we need to keep it clean and simple for these older browsers.
Jim: Is that going to require us to make other changes?
Frank: It’s cool that the XHTML‑MP DOCTYPE fixed the floated <div>s in Opera Mini, but I’m starting to feel really paranoid about floats on those older browsers.
I know it’s a bit old‑school, but I was thinking of  using tables to lay out the dashboard information.
Jim: I thought HTML tables were relics of  the ’90s, man.
Frank: Usually I avoid them like the plague, but they’re not, like, invalid.
I’m just not convinced that floated, <div>‑based columns are going to work reliably in all of  the mobile browsers we need to support.
Jim: Yeah, tables are kind of  uncool, but I guess we know that they’ll work.
Also…what about all that CSS we already wrote for the mockup?
Frank: I’m feeling a bit overwhelmed by which HTML tags are supported and what kind of  CSS support we can depend on.
I think I’d like to take this one thing at a time.
I want to figure out which HTML elements are valid and supported on these phones, first.
So, I’m going to strip out all the CSS for now and add it back later.
One last thing before you do another round of mockups.
One last curveball OK, there’s something we neglected to tell you.
If  this makes you want to throw up your hands and make very irritated noises, we understand.
You get the target attribute on anchor tags back (not that we’re suggesting that you use that, necessarily)
Bottom line: you don’t lose anything you already had in XHTML‑MP 1.2
There are a whole lot of confusing markup options for mobile devices, but we’ll stick to XHTML‑Basic for the rest of  this chapter.
Sorry we made you go through that, but it was for your own good.
The mobile web markup landscape is complicated, and you should have a sense of  what’s out there.
It’s not too hard: we’ll just need to identify what tags aren’t supported, and avoid them.
And we won’t even worry about CSS styling or layout right now.
By the way, scrolling sucks Not everyone has the luxury of  a touchscreen.
On many phones, the way to navigate through web pages is to use a key or a cursor to scroll through the content.
In many interfaces, each clickable item is highlighted as the users scroll down the page, giving them an opportunity to follow the links.
This lets users use the number keys on their phones to access links quickly.
Access keys let users use their numeric keys as shortcuts!
Delete the CSS <link> tag; we’ll deal with CSS later.
This will make numbers show up next to the links and helps with the next step.
Save the file as index.html—we’re done testing the mobile redirect now, so it’s easier to just use index.html.
A: Yep! You can see this at http://hf-mw.com/ ch3/ex/2a if you are curious.
Q: Isn’t Opera Mini 4.2 pretty archaic? How many people really use that version anymore?
But browsers of its vintage absolutely do exist out there in the woolly wilds of Mobile Web Land.
It’s a good example of the sort of browser with the sort of constraints one runs into on older feature phones in, especially, emerging markets.
Q: But didn’t you just say that smartphones are now outselling these dinosaur feature phones?
There are still vast numbers of existing older smartphones (not really “smart” by our current standards) and feature phones.
Which elements are valid where? Use what we’ve learned and your own intuitive sense to figure out which tags and attributes are OK in which standards.
An element may be OK in more than one standard!
The Opera Mini simulator doesn’t seem to support them, and I don’t have a phone with a hard keyboard.
We promise that they do work on a lot of phones, but you don’t have to take our word for it.
Access keys are actually supported in most major desktop browsers, too.
Get some validation Remember how we told you that it’s important to use valid markup? Let’s not just give that lip service—it’s time to validate the markup in the mockup and make sure it’s up to snuff.
Let’s head over to the invaluable W3C Markup Validator site to check our code.
If  you want to test out the access keys on the mobile markup, you can view index.html in your desktop browser.
Test out the access keys by using the following key combinations:
You can either upload the  index.html file (Validate by File Upload) or copy and paste its contents (Direct Input)
Certain operating system shortcut keys or software configurations could take precedence over these, so your mileage may vary.
Scroll down on the results page to see details about the errors.
Even seasoned pros make little typo‑esque mistakes like this one.
That’s one of  the reasons to use the validator—even if  you’re at the top of  your game.
Both of these errors were caused by a misplaced </a> tag.This isn’t actually an error—it’s the.
How’d you do identifying which tags are valid in which standards?
The CSS‑MP standard was developed with low‑ to mid‑range phones in mind.
Sounds simple in theory Browsers that implement CSS Mobile Profile 2.0 are supposed to support the required properties.
In addition, quite a few CSS properties and values are considered optional in CSS‑MP, meaning browser makers can opt to support them—or not.
Instead of  throwing out a tedious list of  supported and unsupported CSS properties in CSS Mobile Profile, let’s jump in and figure out how to adapt the existing CSS to be CSS‑MP compliant.
We’re going to go on a journey here—a journey that, if everything goes right, will end with a loving marriage between XHTML‑Basic and CSS Mobile Profile.
We’re going to want to start using CSS again, so we need that <link> tag.
The background-image and background-repeat properties are supported in CSS‑MP, but having a big header with a background image wastes a lot of  space.
Device support is iffy; heck, even support for background-color isn’t assured.
These properties to create rounded corners are invalid in CSS-MP, and most of those older browsers don’t support them, anyway.
These rules will need to be updated to reflect that.
Back to index.html: add some classes to the table elements.3
And now back to styles.css: adapt styles to apply to the tabular markup.
We’ll want to get rid of  some properties that no longer make sense, and make a few edits to others.
Hey, hotshot! Apply these classes to the other three rows, too.
In addition, browsers that implement CSS‑MP are only required to implement the “auto” value of overflow; everything else is optional.
Add this new CSS rule (anywhere in the styles.css file)
It’s generally not supported on any platform, and is an interactive ickiness.
The behavior of the overflow property in browsers that implement.
CSS‑MP is varied—the only value that they are required to support is auto.
Notice anything? We’ve lost the list numbering on our <ol>—and those numbers indicated the access keys.
Where’d the numbers go? The numbers are still “there,” but we’ve applied CSS that makes the <li> elements look like buttons that span the full width of  the window.
So the numbers are off  to the left of  the visible content.
Maybe we’ll need to convert the links into a simple list of  links, instead of  the buttony look we have now.
However, when Creature Comforts reviewed this change to the layout…
So we’d need to add a bit of margin back here to get the numbers onto the visible page.
If we swap out the existing CSS for this new CSS…
Hmmm...I’d really prefer it if those utility links looked like buttons and not just links.
Creature Comforts has become attached to the button look and wants it back.
The only way to accomplish this with valid CSS‑MP is to convert the list back to a <ul>, add the numbers to the content itself, and update the CSS style rules.
Don’t forget to add the access key numbers to the text content of  the links, too!
And put the CSS previously used for #tools ol li a here.
It’s a big world, and there are billions (yep) of mobile phones.
Not all of them are bleeding‑edge smartphones, and sometimes you have to make your website or web app work with those phones.
There are real‑life circumstances: older systems, recalcitrant clients, or specific projects that make having a totally separate mobile website necessary.
One of the ways to route mobile traffic to a mobile‑specific website is to use server-side mobile device detection and redirection.
User-agent sniffing is a popular technique for evaluating whether an incoming request is from a mobile browser.
User‑agent sniffing examines the User-Agent header that browsers send as part of each HTTP request.
Some older mobile browsers (and current, lower‑end mobile devices) implement different standards for HTML and CSS.
It is similar to XHTML, but does not support everything that XHTML does.
XHTML‑MP was superseded by XHTML-Basic 1.1, which is almost the same except for a few new supported elements.
It’s important to choose the appropriate DOCTYPE for your mobile web project and pay attention to keeping your markup valid—bad code can make phones behave very badly.
Looks fine on newer smartphones, like this Android Nexus S.
Is there an equivalent mobile flavor of JavaScript for mobile devices?
A: Yes, there is a mobile‑specific JavaScript called ECMAScript Mobile Profile, but you can’t rely on it.
We’ve worked with phones where the JavaScript cannot change anything on the page once it is loaded, which means most of the things you use JavaScript for cannot be done.
So if you’re targeting old phones, you’re probably better off not relying on JavaScript.
It’s kind of on its way out, and we don’t see any reason to use it instead of CSS‑MP.
Q: If you use user-agent sniffing to route mobile traffic, and you misidentify a user’s browser either because she is spoofing her user agent or because you’re just…wrong, couldn’t she end up getting redirected and stuck on the mobile version of the site, unable to escape back to the full site?
A:Well spotted! This is important! In a real‑life situation, you would want to provide an “escape hatch,” often in the form of a link back to the desktop site.
The link on its own isn’t enough—you need to let your redirection script know that the user wants the desktop site.
You can accomplish this by setting a cookie indicating this preference and not redirecting browsers that have that cookie set.
Q: What happens if I just can’t get my site to do what I want in a way that is perfectly valid XHTML-Basic or CSS-MP or whatever? Does the sky fall? Do phones around the world crash?
A: Being successful on the mobile web often means making compromises and trade‑offs.
While writing valid code is something to shoot for, it’s not always 100% feasible.
But knowing the rules before you break them is always a good motto to live by.
Q: Do I have to use XHTML-Basic every time I want to support a lot of mobile browsers? It feels constrained.
A: We have to pull out the classic mobile web answer for this: “it depends.” In Creature Comforts’ case, there were a lot of older, less full‑featured phones we needed to support.
Our goals were to get a server‑side data service to render well on as many feature phones as possible.
Using HTML5 in many cases is a reasonable approach, even on older phones.
But we wanted to show you the kinds of things you need to be aware of when targeting older devices.
Q: You neglected to do so on page 127, but I do want to see an exhaustive list of supported and nonsupported properties in CSS-MP.
A: Hey, you’re in luck: the CSS Mobile Profile 2.0 spec happens to be a rather quick and easy read.
Hey, developer types! How could we support users who want the desktop version instead? Can you think of what would be needed to add a link from the mobile to the desktop site, and what modifications you’d need to make to redirect.php to write and check for a cookie to store the user’s preference?
It’s not cool to strand users on a stripped-down mobile site if they’d prefer to escape to the desktop version.
There aren’t enough hours in the day to test on every device.
You have to draw the line somewhere on what you can support.
How do you know where to draw the line? Every project is a series of  compromises.
Figuring out what matters for your project can seem like magic to people who aren’t in the trenches with you.
You take criteria and priorities, apply some brain power, sprinkle in a little magical inspiration, and you come up with a list of devices that are key to your success.
Step away from the keyboard for a second We’ve tried to keep everything grounded and hands on so far, but we’ve reached that point in the movie where the actor stares off  into space and contemplates a tough problem.
You already have all of  the tools you need to decide where to draw the line.
But you’re not going to find that inspiration at the keyboard, so we’ll take a brief interlude from building stuff  to talk about the abstract stuff  that turns criteria and priorities into a list of  devices you support.
We’re going to help focus your brain a little and then get out of  the way.
The best directors know that all they need to do is give their actors some guidance and let the actors act.
What’s this line we need to draw? Supporting every device ever made is a noble goal.
Testing on every device ever made is a sure‑fire path to losing your mind.
You can hope to support as many people as possible, but to keep your sanity, you’re going to have to know the answer to three questions.
Can you think of some differences between devices you don’t support and those that you can’t support?
What devices do we support? Which devices or types of  devices are you going to test your pages on to make sure they work as intended?
What happens to devices we DON’T support? What can you do to make sure devices that you don’t test on are still able to use your site?
What happens to devices we CAN’T support? What message do you give people whose devices aren’t up to snuff ?
Don’t be a meanie about it If  you can’t support someone’s browser, be nice about it.
He may not have the latest phone in his pocket, but he may have access to a better browser somewhere else.
Besides, no one likes to be told his phone is a jalopy.
Just because you can’t verify that your pages will work in a browser doesn’t mean you should exclude people using that browser.
So why make a distinction between what you don’t support and what you can’t support?
Although you don’t explicitly support a device, that doesn’t mean what you’ve built won’t work on that device.
If  you build your web page using well‑formed, semantic HTML and progressive enhancement, your page will be accessible by many more browsers and devices than you can guarantee that it will work on.
But sometimes a browser is so old and feeble that you simply can’t support it.
For example, if  you’re selling shoes online, you need to use HTTPS to keep credit card information safe.
When that happens, the best thing you can do is tell the person that she can’t buy shoes on her phone.
In many cases, progressive enhancement means you can support hundreds of different browsers.
Starting with basic HTML and progressively enhancing the document should be the starting point for most web pages.
Browsers with advanced features get enhancements like rounded corners and gradients.
However, the minimum requirements for a site or app may be higher than basic HTML can provide.
A video game may require WebGL, a graphics library, for game play.
There is no content if  the browser doesn’t support WebGL—that is, until a couple of  years from now when you can progressively enhance from WebGL to WebGL 2!
As they say, you have to know the rules before you know when to break them.
You should use progressive enhancement from basic HTML unless you have a really good reason why it won’t work.
And even then, a basic HTML document that said, “Sorry, this game requires WebGL support to play” would be a nice starting point upon which to build the game.
WebGL 2 doesn’t exist, but it seems likely, doesn’t it?
I understand not being able to support really old phones that don’t have HTTPS, but I thought if you delivered a basic HTML document and then progressively enhanced it with CSS and JavaScript, it would work everywhere.
Ask questions about your project It might sound like we’re teaching you to suck eggs here, but the first step toward figuring out where to draw the line is to think about your project.
Who is your audience? What functionality is core? What features are optional? What is the best experience?
The sales team needs to show the app to potential customers, but standard issue for salespeople is a BlackBerry 4.5 phone.
How can we show off the app on such an old device.
Hmm...the travel app I’m working on needs to know where someone is to work.
What if that person’s phone doesn’t have GPS? Would zip code be accurate enough?
We’re getting ready to expand into Japan and South Korea.
Do they use the same phones as we do? I heard Japan has a lot of phones not available elsewhere.
Our Funny Cat Video site will be great on mobile, but only if the phone supports video.
Ingredients for your magic mobile potion When you ask questions about your project, you’re starting to suss out the factors that can help you figure out which devices matter.
Who is your audience and what is it likely to use? What are must‑haves versus nice‑to‑have features?
Mix these factors together into a magic potion that tells you what devices you need to support.
Does this browser support cookies? How about HTTPS? Video playback? Do you need ac.
Does your service need to be used online, or do you need to support offline usage?
That video-intensive site will only work well on fast connections.
There are big differences in the phones sold in different parts of the world.
Draw from your cupboard of tools and data What goes into audience usage? Dig into your jar of web analytics to see what your current customers are using.
Expanding to a new geography? Pull out data on the top phones in those countries to see what the cool phone is in Singapore.
Big collections like the Device Anywhere Data Explorer and Browserscope can help answer questions about which devices support which features.
Analytics can be web statistics or other forms of tracking customer usage.
Beware of analytics if your site has a poor mobile experience.
Check out this comprehensive guide to mobile statistics at http://bit.ly/m-stats.
Mo Better Museums is building an app that allo ws.
Time to put your magician’s hat on and work some magic.
For each case study, build a requirements list based on what the app is trying to accomplish and the target audience.
Here’s our list of requirements based on the information in this case study.
Case Study A politician wants an edge in a close election.
She would like an app for volunteers to use when they go door‑to‑door to encourage people to vote.
Volunteers are in short supply, so she would like the app to support whatever phone they happen to own.
Case Study Bowling Boxers is the videogame generation’s version of.
Which requirements are minimum bars, and which can be supported via progressive enhancement?
Mo Better Museums is building an  app that all ows.
Case Study A politician wants an edge in a close election.
She would like an app for volunteers to use when they go door‑to‑door to encourage people to vote.
Volunteers are in short supply, so she would like the app to support whatever phone they happen to own.
Don’t you hate it when someone tells you there is no right answer? Yeah, well, sorry about that.
There are no right answers when it comes to requirements.
So don’t fret if you have a different answer for these case studies.
Your experience may give you a requirement that we’ve missed.
So far, only the latest version of Android partially supports it.
Case Study Bowling Boxers is the videogame generation’s version of.
Must have: fast CPU and GPU, or the game performance will suffer.
If  you were to pull back the curtain on most mobile projects, you’d find that the people who made the site were uncertain about what devices they needed to support.
They made the best guess they could and then iterated on it until they perfected the site.
How do I know my customers have the right stuff?
There are two main methods: server-side device detection and client-side feature detection.
We’re going to look at device-detection databases in the next chapter.
It sounds like you’re ready for this interlude to end and get back to building things.
Now get ready to roll up your sleeves again and dig into the crazy world of  device databases and the bane of  web developers everywhere: user‑agent strings.
By the end of  the next chapter, you’ll be bossing those evil useragent strings around.
Every project draws the line somewhere on which devices it supports.
Knowing where to draw the line is a combination of experience, research, and gut instinct.
There is a difference between devices you don’t support and those you can’t support because they lack critical features that make it impossible to use your site.
Look at your project requirements and your target audience to help decide where to draw the line.
This will make your site work on many more devices than you can officially support.
Unless you know for certain that you cannot support a device, you shouldn’t exclude it.
Give them a chance to prove they’re up to snuff.
You already have all of the tools you need to know where to draw the line.
We looked at feature detection in Chapter 2 when we talked about progressive enhancement.
Uh, when you said you were going to take a.
It is possible to know a little too much about a user, you know...
Setting the bar for the devices we support doesn’t take care of  a few nagging issues.
How do we find out enough stuff about our users’ mobile browsers to know if they measure up before we deliver content to them? How do.
AcedIt! Test Prep hangs its hat on superior customer service.
That’s why AcedIt! wants to create a page on its website specially attuned to its customers who are on the edge.
It’s called the I’m Freaking Out! page, and its goal is simple: connect the customer with an on‑call tutor right away.
Wouldn’t it be cool if a freaked-out user on a mobile browser could see a big red panic button that he could press and place a phone call right away?
The button is for mobile phones only Desktop browsers can’t make phone calls, so the big, red panic button metaphor is kind of  lost there.
Steve only wants the button to show up on mobile phones.
We have an IT guy who usually does the website tweaks, but in this case I think we might need help.
Frank: We might be able to do this with CSS media queries based on the window width of  the browser.
Just because a window is narrow in width doesn’t mean the browser is on an actual mobile phone.
Frank: Right, I guess the panic button would end up showing up on narrow windows and tablets and stuff if  we used a width‑based media query.
Jill: Ideally, we’d have some way of  getting information about the user’s browser and device that is specific enough to give us hints as to whether it’s a mobile phone, not  just a device with low resolution or a narrow screen.
But how do we know someone is on a mobile phone?
Mobile device data sources to the rescue Mobile device databases contain detailed information about the browser, platform, and hardware features of  mobile devices and their browsers.
By querying the data set with a uniquely identifying key—generally a user‑agent string—we can get tons of  attributes about that device and its browser.
Software API helps to find a match in the device database for the current user agent.
A successful match gives us access to all sorts of data about the device.
Information is available about the device’s hardware, platform, and browser.
Armed with this data, you can adapt content based on a device’s characteristics.
Meet WURFL WURFL (Wireless Universal Resource FiLe, usually pronounced “wuhr‑full”) is an open source device database with an enormous amount of  information about the specific capabilities of  mobile devices and their browsers.
Recently, the longtime maintainers of  the WURFL project started a company called ScientiaMobile to provide commercial support for WURFL.
Not all of  WURFL’s capabilities are of  interest to us web developers, but you’ll find some real, useful gems in there.
Go out and try it yourself! The ScientiaMobile explorer lets you interact with Tera‑WURFL data in a web browser.
Visit the See my capabilities section and browse the capabilities it returns for your mobile device and browser.
The explorer is intended to be used on a mobile browser.
If you visit with a desktop browser, a random mobile device will be selected for your capability-viewing pleasure.
You can also visit the explorer in a desktop browser and enter in any user‑agent string you’d like to find capabilities for.
This can be a quick and handy way to look up device capabilities for a known user agent.
A device is not a platform is not a browser.
WURFL’s notion of a device is a combination of all three, and contains information about hardware, OS, and browser.
We’re guilty, too, so keep in mind that our use of the shorthand word device likely carries some of the connotations of browser, hardware, and OS.
You can use this information to adapt your web content accordingly.
There are currently over 500 capabilities that WURFL tracks, grouped into a couple dozen or so categories like css (can this browser support rounded corners? What about background images?) and playback (what kinds of media can this device play?)
Device data is maintained in a large, single XML file that is regularly updated.
The latest version is made available on the project’s Sourceforge page.
There’s more than one flavor of WURFL ScientiaMobile’s explorer is based on a particular implementation of  WURFL (the Database Edition, also known as Tera-WURFL) that keeps WURFL device data in a database instead in a flat XML file.
Tera‑WURFL is intended to be set up as a web service or PHP library that mobile‑oriented websites can query to get device information for user‑agent strings.
There are many different APIs and implementations of WURFL, but all have one thing in common: that big ol’ WURFL XML file with all of  the mobile device data.
The full WURFL experience is a combination of  the WURFL data file (XML), the way the data is stored, and an API to interact with it.
We’ll be using the PHP API There are WURFL APIs for a number of  major programming languages.
Device who? Capabilities what? What does WURFL actually do for me?
WURFL’s developer community is constantly contributing to the data source, meaning it isn’t left to some poor guy alone in a dim cubicle somewhere trying to track down every new device and browser on the market—not just a thankless task, but likely impossible.
WURFL’s various APIs’ algorithms are clever when performing matches on user agents.
It also doesn’t hurt that WURFL has been around a while, has a proven track record, and has been used by (and contributed to) some pretty major web players (ever heard of  Facebook?)
And, of  course, if  WURFL doesn’t meet your needs, there are other device databases such as DeviceAtlas, DetectRight, and MobileAware.
What makes sense for your project depends on your needs, budget, and licensing requirements.
There are thousands and thousands of user agents out there.
How could anybody or any organization track all of them and all of the data about each device?!
The WURFL API is available under the Affero General Public License v3 (AGPL), which is an open source license.
The WURFL XML database has a restricted license that only allows it to be used with the WURFL API.
So, if you can comply with the AGPL restrictions, you don’t have to pay anything.
With AGPL, running the software on a server counts as a distribution, which triggers provisions requiring you to open source any derivative work.
If AGPL doesn’t work for you (and, in many cases, it probably won’t), ScientiaMobile will sell you a commercial license.
Q:If I integrate WURFL with (insert your favorite open source solution here) and build a site on top of it, do I have to open source the whole site?
A:Short answer: buy a commercial license or talk to a lawyer.
Q:Are there other things out there that do what WURFL does?
Q: How does WURFL data get updated? More to the point, how would I get new data as it’s updated?
A large part of the work any device database vendor does is related to validating information provided about new devices.
A: ScientiaMobile picks capabilities based on suggestions from the community.
Q: Where is this WURFL community of which you speak?
WURFL: Clever API code When a WURFL API tries to match an incoming user agent to a known device, it doesn’t just go belly up if that exact user agent isn’t in the data.
As it is totally impossible to track every single user agent out there, the API matchers instead perform some clever tricks when the precise user agent is not recognized.
A tree of devices and their families As the WURFL API analyzes a given user‑agent string, a series of  increasingly generic fallbacks is evaluated, with the goal of  at least slotting the device into the correct family of  related devices.
You can think of  WURFL’s data as a sort of  tree of devices, with the trunk being a generic browser and each branch, twig, and leaf  a more specific device or group of devices.
The API tries to get as far as it can toward the exact leaf, but has the rest of  the tree to fall back on if  it cannot.
Additionally, the WURFL data for a given device only defines the capabilities for that device (or group of  devices) that differ from its parent device or devices.
One way it finds matches is by using matchers optimized for a given family of browsers or devices.
The most recent PHP API has a few dozen handlers to deal with the analysis of user agents.
The API first determines which handler makes the most sense for the given user agent.
User agents with the string “BlackBerry,” for example, are handed off to the BlackBerryHandler.
Each handler is savvy about the kinds of differences that matter for user agents in its family, which cuts down on the amount of super-specific user agents that WURFL data maintainers have to track.
We can build an explore page, too Once you have the WURFL PHP API installed, it requires a pretty small amount of  code to build a page not unlike the ScientiaMobile explorer page.
If ScientiaMobile’s explorer page already lets me get WURFL information about devices, why do I want to go to the trouble of building my own version?
Building the explore page will get your hands dirty with the WURFL API, and it will use data from your own data file.
We’ll build some underpinnings here that we can reuse for other—more functional—tasks.
Also, the ScientiaMobile explorer page is driven by the so‑called Database Edition of  WURFL.
The data is stored and matched slightly differently than the XML file‑PHP API combination we’ll be using.
Bottom line: the data is a bit different in little (but sometimes critical) ways.
Plus, by having your own explore page, you know that you’re getting data from your version of  the data file, not one that is older or newer than the one you have.
By your data, we mean the current set of data you have in the WURFL XML file you downloaded when installing WURFL.
Set up our working environment, files, and configuration for WURFL.
Write a bit of  (boilerplate) PHP code to initialize some WURFL objects so that we can start accessing capability information for the current browser and device.
Build a page and output the data in an HTML table.
We’ll be editing this file and renaming it to remove the .example.
This file holds some code that gets WURFL device information and organizes it.
See the installation appendix if you need help locating the resources or API code directories in your WURFL install.
The configuration file will tell the explore code where to find your WURFL installation.
An explore page: Setting up our environment The first order of  business is to get our directory structure sorted and a configuration file created.
You’ll find a starting point in the explore subfolder of  the chapter5 folder.
By this point, you should have the WURFL PHP API up and running.
You’ll need to know the location of  its installation to create a configuration file (well, one that works, anyway)
We’ll be reusing this config file for the rest of the examples in this chapter.
Set up our working environment, files, and configuration for WURFL.
Write a bit of (boilerplate) PHP code to initialize some WURFL objects so that we can start accessing capability information for the current browser and device.
Build a page and output the data in an HTML table.
Now we can write some code to initialize the WURFL objects and start getting at capabilities…
You’ve got WURFL installed (we sure hope), but now we need to configure it to work in the web page we’re building.
To do that, we’ll want to create a configuration file.
Now we need to create some code that will initialize WURFL stuff and get it all warmed up so that we can plumb its depths for device capabilities.
It’s rather empty to start with, so let’s plop in some WURFL‑y code!
I’m OK with most of this, but I can’t seem to get my.
Those lines instantiate several WURFL objects and populate a device object for us.
Most of  this chunk is boilerplate code that we’ll cut and paste as needed to get WURFL into shape for our use.
If  you’re a whiz with PHP and this innately makes sense to you, kudos, but if  it doesn’t, don’t sweat it too much.
At this point, if things went right, the device capabilities are ready to use.
Translation: We feed it a user-agent string, and it gives us a device object populated with values for the various capabilities.
It’s where we tell WURFL how to build a device object.
In our case, we’re using $user_agent, which currently holds the value of the User-Agent header of the requesting client.
That is, we’re instructing WURFL to take the user‑agent string of the current user’s browser and try to find a match in its data file.
If it’s successful, we’ll have a device object containing the capabilities of the browser and device.
Now that we have a populated WURFL device object, let’s organize the device’s capabilities so that we can display them in an HTML table.
Set up our working environment, files, and configuration for WURFL.
Write a bit of (boilerplate) PHP code to initialize some WURFL objects so that we can start accessing capability information for the current browser and device.
Build a page and output the data in an HTML table.
It’s totally OK if you don’t understand everything this PHP is doing; you can just copy this into the device.php file.
The second job of device.php is to organize the capabilities info so that we can display it later.
We’ll add a chunk of code to the file to organize capabilities by WURFL group.
Drop the following code into device.php and save the file.
The getListOfGroups() method simply returns an array of WURFL group names…
This is how we access the values of individual capabilities.
Iterate over the collected WURFL capability data, which is organized by group.
For each group, generate a <dl> with the names and values of the capabilities in that group.
If there is no value for the current capability, display the string “no value.”
Let’s display the user agent and the id attribute of the device (WURFL’s ID of what this browser or device is)
Set up our working environment, files, and configuration for WURFL.
Write a bit of (boilerplate) PHP code to initialize some WURFL objects so that we can start accessing capability information for the current browser and device.
Build a page and output the data in an HTML table.
A good start! You can see all of  the capabilities of  your desktop browser now, with capabilities organized by group.
We can do this by dropping a quick HTML form into index.php and making a small change to device.php.
Set up our working environment, files, and configuration for WURFL.
Write a bit of (boilerplate) PHP code to initialize some WURFL objects so that we can start accessing capability information for the current browser and device.
Build a page and output the data in an HTML table.
In device.php, we now check to see if there is an incoming form value (in $_POST) for the user agent; otherwise, we default to the current browser’s user agent.
Add a short form that allows the entry of any user-agent string.
A quick one-two punch to improve our explore page A couple of  quick changes, and our explore page will be more useful.
SERVER[‘PHP_SELF’] is shorthand for the currently executing script—that is, the form will post to the current page.
Save all of the changes and load up the index.php file in a web browser.
The first time you load the page, you should see your own browser’s WURFL capabilities.
Enter some mobile browser user agents into the form and explore the resulting capabilities.
Now you can enter any user-agent string and explore the capabilities of the matched device.
A quick way to find your browser’s current UA string: http://whatsmyuseragent.com.
It’s time to figure out how to use WURFL capabilities to determine whether or not we should show that panic button on AcedIt!’s site.
Create a configuration file and add some code to initialize some WURFL objects—that is, get information about the current device and make it ready for us to use.
Ask WURFL about the specfic capability or capabilities we care about.
Add some code to the I’m Freaking Out! page mockup to alter the content delivered to different devices based on the value of  capabilities.
We learned how to do this part in the last exercise!
Copy the config.php file from the explore directory into the panic_button directory.
Even if  this class and instance mumbo‑jumbo is generally Greek to you, getting at those capabilities is not too tricky, and we’ll show you how.
Getting a value for a specific capability looks like this:
Name of the capability we’re asking about as a string.
Note that when you retrieve capability values, you don’t have to worry about what group the capability is in.
Groups are a nice organizational concept, but each capability is uniquely named and can be asked for directly.
You’re not required to use capability groups to interact with WURFL.
We’ll do this in the device.php file in just a sec.
Want to see info about all the WURFL capabilities? Check out http://wurfl.
Is this thing mobile? Now we’ve got our WURFL device all warmed up.
Initialize the device and get the info ready You’ll see that we’ve given you a bit of  a leg up in the panic_button folder.
The device.php file already contains much of  the WURFL boilerplate stuff  you need to get your proverbial house in order.
We’re going to be using a different method to instantiate the device than we did for the explore page.
Translation: Give us device data for the device currently accessing the server.
This method also takes hints from a couple of other HTTP headers besides the user-agent headerbut user-agent is still the main source of clues.
In the PHP API, all capability values are returned as strings.
That means that the seemingly Boolean capability is_wireless_device has three possible values: 'true', 'false', or NULL (NULL means that WURFL doesn’t have a value at all for that capability)
We need to be more explicit, or the value 'false' will evaluate as true, and nonmobile devices will look like mobile ones.
Replace the last line we wrote with the new version:
If you have no idea what that means, that’s OK.
The triple-equals identity operator here means that the value must be exactly the string of ‘true’ to pass, not just any truthy value.
Now, use that value The device.php file gets included in the index.php file, so we can access the code we just wrote.
We want to add the following PHP conditionals to index.php.
The button doesn’t show up on desktop browsers, even with a narrow window.
Interviewer: So, WURFL, what exactly did you bring to the table here?
You can tell right off  if  the browser is mobile!
Interviewer: There are other ways to do that, you know.
WURFL: So, I challenge you to look at the page on an iPod Touch.
WURFL: Doesn’t that seem a bit…well, perhaps not what you intended? When’s the last time you were able to make a phone call from an iPod?
Like I said, you’re not using me to my full potential.
Interviewer: But you have over 500 capabilities! How will I find the right one?
WURFL: You’re complaining because I’m too comprehensive? I can’t win! Fine, I’ll give you a hint: just because the button is showing up on mobile devices doesn’t mean it actually makes a phone call—you haven’t linked it yet, so it’s a pretty image, but not functional.
You might think about that and take another look at my capabilities.
Go look at our explore page and investigate the capabilities for an iPod Touch (where we don’t want the button to show up) versus the capabilities for an Android Nexus S (where we do want the button)
You might also look at a desktop browser for comparison.
Can you spot a capability that will help us make the differentiation between a small or mobile device and an actual phone?
The button shows up on an iPod Touch…where it doesn’t make any sense.
We also need to know how we should link the phone number such that when users click on it, it initiates a phone call.
Making phone calls with links Mobile phone browsers recognize certain URI patterns in links as phone numbers.
When a user clicks on this kind of  link, an alert box prompts her to confirm that she really wishes to place the call.
But to be correct about things, you should use one.
The WURFL bearer capability group has a handsome capability called has_cellular_radio.
We’ll be looking at the value of that capability to evaluate whether the current request is coming from a phone, not just any mobile device.
If you treat this as a Boolean value in PHP, it will evaluate as TRUE.
Q: Don’t mobile phone browsers automatically recognize phone numbers and link them for you?
Most relevant to our present situation: our link was an image, not a phone number.
Also, various phones’ abilities to correctly recognize phone numbers is hit or miss.
Opera Mini has a tendency to think that zip codes with the plus‑4 extension are phone numbers.
Trying to place a phone call to a zip code has curious results, as you’d imagine.
Also recall that we are being quite formal with our phone number formatting (+15035552329)
One might want to display a slightly different string in the link text itself, yet be confident that the link itself will be formatted correctly.
Q: How come there has to be that pop-up confirmation box after a user clicks on a phone call link? Why can’t it just spawn a call directly?
A: This is to protect the user from being tricked.
A visible phone number link might have one number, but the link itself another.
Some poor suckers might end up calling a scammer when they thought they were cancelling their local newspaper subscription.
In our case, we’re not even displaying the phone number, something that is arguably not really a best practice.
We could also use a CSS background image instead of an inline image, have the phone number as the text in the link, and use a big negative margin in CSS to hide the text.
A: Using a large negative left margin (e.g., margin-left: ‑10000px) is a way to get text to go way off to the left and be invisible.
We like to visualize the text somewhere 10,000 pixels to the left, floating in the air somewhere in our office.
A: WURFL has some intelligent data, but it’s not that smart (no one is)
There’s no clear‑cut way to be absolutely certain a user is on a functioning cellular network (versus WiFi or something else) or that there are not other things preventing the actual placement of a phone call.
But, really, this gets us more than most of the way there.
Q: Speaking of Smartypants, you glossed over it pretty quickly, but I actually do want to know more about the WURFL objects and API.…
A: Hey, we heartily encourage you to go look at the PHP classes in the API and see how they work together.
If you’ve installed the API, you’ve got the files already, so hop to it!
No more button on iPod Touch! But still there on iPhone!
To see what an iPod Touch would see, edit the device.php file.
Jim: This could get out of  hand! In a more complex project—or even AcedIt!’s site, if  it adds more mobile bells and whistles—it seems like using scattered, individual WURFL capabilities all over the code would cause a lot of  headache and mess.
It seems like we’d be delivering a slightly different website to every possible combination of  capabilities—a nightmare to think through and test.
Frank: But I don’t want to throw out the whole concept.
Even though I like to try to do feature detection on the client, and we still want to make our stuff  as responsive as possible, it does seem like a device database like WURFL can give us insight into some details that we might not be able to get from other sources.
Jim: But how do we corral all of  this so it doesn’t make us crazy?
Frank: It seems like if  we could group devices logically—instead of  testing capabilities piecemeal—we might be able to keep our sanity.
Remember how we recently spent time thinking through how to evaluate which devices to support by picking and choosing features and drawing the line for phones that don’t make the cut?
Frank: It seems like we could go one step further and create buckets of devices that are within the group of  devices we decide to support.
Herding devices A device class creates a sort of  logical corral into which you can herd devices that have certain things in common.
Just as a rancher might put spotted cattle into one field, giant work horses in another, and little piglets in yet another (can you tell we’ve never been ranchers?), we can sort our devices into virtual cubby‑holes with device classes.
Sort once, then go Once our rancher identifies an animal as belonging to one of  those three groups, he can make further decisions without having to look at the smaller details.
He already knows they’re horses because they’re in the horse corral.
He doesn’t have to tailor feeding to each individual animal (that would be a lot of  horse meals to keep track of)
But, at the same time, he doesn’t feed oats to the piglets.
A device class is an abstract collection of common characteristics that define a group of devices (and their browsers)
You can test what content gets delivered for a given device or browser by using its user agent when intializing the WURFL device.
Device classes As we learned earlier, we can run incoming requests against a device database to get device information.
By grouping the capabilities and values that matter for the site at hand, we can adapt content across an entire device class instead of  chasing down each individual capability’s value.
These device class definitions, converted into code, sort devices into one of  several groups.
Once our devices are sorted, we can take action without having to keep track of  each individual constituent capability.
Code evaluates which device class the device matches based on device data.
In this hypothetical example, devices are sorted into one of four groups.
Expanding a lucrative part of AcedIt!’s business AcedIt! is building a standalone website for the study aids it sells to its students.
It’s realized that flashcards, practice test booklets, reference books, and the like are selling like hotcakes, but the only way to purchase things right now is through a printed catalog.
AcedIt!’s new study‑aid‑specific site will not only allow users to buy any physical product online, but will also introduce online products like flashcards that can be used interactively, right on the site itself.
An early look at what it has in mind It’s early yet.
Logo designs haven’t been finalized, content is still being evaluated, and the design is still in simple‑mockup phase.
AcedIt!’s web folks sent this early mockup of the new site’s home page.
Users can shop online and study now—use interactive products right on the site itself.
These ads are for related services, like paper proofreading and local study groups.
AcedIt!’s devs are building these features using JavaScript and other standard web technologies.
Nice job on that panic button! Do you think you could help us mobile-optimize.
Evaluate the home page wearing mobile-tinted glasses The scope of  the new study aid site is much bigger than the single panic button page.
We risk making ourselves crazy if  we plan development piecemeal, capability by capability.
One way to frame our development approach and make the site work well for different kinds of users is to group the different experiences using device classes.
We look at the task at hand, figure out what things matter, mumble a few incantations, and come out the other side with some general criteria.
Let’s start by reviewing the mockup again and weighing AcedIt!’s priorities against what we know about mobile web characteristics and constraints.
AcedIt! has mentioned that it doesn’t think the ads need to show up for mobile users.
It seems a bit lukewarm on the whole ad part of the site, anyway.We might want to link to.
We’ll want to adjust the layout by reducing the number of columns and tightening up the header.
There’s a lot of complex CSS3 styling that won’t work on all devices.
AcedIt! has made it very clear that the interactive elements on the site are of mega importance.
We need to keep the JavaScript and AJAX (Asynchronous JavaScript and XML) device capabilities in mind.
We only have a rough landing-page mockup for right now.
We can put the content first and the navigation nearer to the bottom for mobile layouts.
A fuller mobile experience By creating a device class that encompasses the requirements for the richer mobile experience, we can design something neat without risking poor support on lesser devices.
By specifying that devices in this class must have a WebKitbased browser, we can use CSS goodies like gradients with relative confidence.
We can also rely on a certain level of  decent JavaScript support.
A simplified experience for simpler phones For narrower screens and less powerful devices, let’s be more streamlined.
And let’s not assume support for all of  the modern browser bells and whistles.
This simpler layout doesn’t provide the link to the online products, but users can still shop in the online store.
This version works fairly well down to about 176 pixels wide, at which point the product images in the store become difficult to see.
Interactive pieces of the site look best on screens at least 320 pixels wide.
Mobile devices need to have the kind of  JavaScript, HTML, and CSS support that is usually found in newer, swankier browsers on smartphones.
Specifically, the AcedIt! devs are targeting mobile devices running WebKit‑based browsers and designing for screen sizes no narrower than 320 pixels.
But that doesn’t mean everyone else should get the cold shoulder.
Smaller, slightly less cutting‑edge phones are still welcome on the site.
They can buy physical products in the online store and visit the other areas of  the site.
They just aren’t cut out for the heavy‑duty interactive experience or the hardcore CSS, for example.
Instead of  delivering to the lowest common denominator or kicking out devices that don’t quite cut it, let’s create two separate flavors of  the site that make sense for each group of  devices.
The landing page  mocked up as it would appear for each device class.
We now have a rough sense of  two mobile device classes we’ll want to construct.
Oh, by the way, tablets AcedIt!’s devs are also working on a tablet‑optimized, super‑nifty, touch‑driven interface for their online products.
It’s not done yet, but they want to be prepared for its eventual launch by being able to identify tablets now.
Where to draw the line It’s important to the AcedIt! folks that their visitors can either shop online or use the online products.
If  visitors can’t do either because of  device constraints, the device and browser they are using are considered unsupported.
The company’s ecommerce software requires cookie support and a bit of  JavaScript support (not nearly as much as the online interactive products)
It is also mandatory that, for security, devices support SSL.
Slightly Confused Web Developer: I’m having trouble getting my head around this device class business.
Device Class: I admit, I am a bit difficult to capture.
If  I were a painting, I’d be an abstract blur.
I’m a concept, a way to think about organizing common things so that we can create just a few flavors of  a site, instead of  a million billion.
SCWD: So, a device class is a set of  WURFL capabilitiesDevice Class: Not so fast.
We’ll be using WURFL here, but there’s no reason you have to.
No reason, in fact, you have to use any device database.
SCWD: This is all starting to feel a bit woo‑woo.
Can you help me understand where the rubber meets the road here?
SCWD: Does that mean we’ll be making a version of  the website for each? That sounds like a big task.
Device Class: No, we only need to focus on the differences.
Device Class: As we know that higher_mobile represents devices with larger screens and capable WebKit‑based browsers, we can be more confident that they have the horsepower to handle some of  the site’s more intensely interactive features.
We know they support a bit of  the ol’ JavaScript, but can give them a dose of  content that is less deluxe.
SCWD: Wait, how do we know that the simpler_mobile devices support JavaScript?
Device Class: We will test for at least a modicum of  JavaScript support.
Devices that don’t have the ability to modify the DOM after page load will be shunted off  into the unsupported device class.
SCWD: So what’s up next to keep this ball rolling?
Device Class: We need to map the right WURFL capabilities and their values to the device classes we want to create.
After we have a logical representation of  the device classes, we’ll create code to do some actual testing and slotting.
Your job is to take the WURFL capabilities and values from the pool and place them into the blank device classes.
You may not use the same item more than once.
Note: each thing from the pool can only be used once!
Q: Why the focus on WebKit-based browsers? Are the devs hating on other, totally decent mobile browsers?
A: WebKit‑based browsers are seen by many mobile web devs as both fairly advanced and consistent.
The problem is, there is a misconception as to just how consistent browsers based on WebKit are.
The sad truth is: there’s still a lot of chaos.
Mobile platform strategist Peter‑Paul Koch spells out the pitfalls of assuming consistency in mobile WebKit browsers in the thorough post “There is no WebKit on Mobile” on his QuirksBlog (http://bit.ly/uWnFLa)
Q: If mobile WebKit isn’t really a “thing,” why are we basing a device class on it?
A: Consistent and reliable or no, WebKit‑based browsers are what the devs have done their development on and testing for.
At this point in the project, it is too late to throw the net wider.
Q: How is testing for the string 'Safari' or 'Android' as the mobile browser name equivalent to.
A:You might recall from Chapter 3 that user‑agent strings are wily creatures.
Apple’s history with respect to WebKit endures in the user‑agent string legacy.
At time of writing, all known mobile variants of WebKit browsers have either “Safari” or “Android” in their browser name (yes, even WebKit browsers on BlackBerries and Nokia phones and whatnot)
Q: If I use device classes in a project, will I always have five?
A: Eh, we just pulled those out of a hat.
We used underscores simply so we can translate the names into code more easily.
Q: Now that we’ve got device classes, I can never test an individual device capability?
In fact, the solution for the panic button problem was very appropriate: we were testing for the value of a very specific capability—a value that might differ among devices in the same device class (an iPhone versus an iPod Touch, for example)
Q: Couldn’t a device match more than one device class?
We need to arrange our device class testing code in order carefully.
The first matched device class will be the device class we assign.
Q: What the heck is the CustomDevice object I keep seeing in the code examples?
A: CustomDevice is simply the name of the class in the WURFL API that represents a device and its characteristics.
Q: Seems like device classes are not just a mobile web thing.
A: Not at all! Content and layout adaptation is a concern that spans the entire Web.
I have some circles with some capabilities and required values in them.
We’re going to start turning these device classes into code.
Let’s get this show on the road Now we need to convert the abstract notion of  what we’re grouping into real code that will detect and slot devices into the appropriate device class.
Write a (PHP) function to test the individual device capabilities we care about in each device class definition.
Translate each device class’s capability requirements into conditional (if/then) statements in code so we can determine which device class the current device should be assigned to.
This is probably starting to feel pretty familiar: we need to set up a configuration file so that WURFL can be initialized.
Write a simple test page (similar to our WURFL explore page) to see how different user agents get sorted into device classes.
We’ll add to this file over the next few pages.
To cut down on busywork, we cobbled this together for you.
A simple test page to enter user agents and see which device class they get slotted into.
We test the current value from the device against the value we are curious about.
We’ll use it when we create the individual tests for each device class.
We wanted to tell you a few things about it before we started taking advantage of  it.
This function returns a TRUE or FALSE (Boolean) result—whether or not the given test passed.
Depending on the comparison operator supplied, the values are compared in different ways.
If $comparison is not one of the recognized comparison operators, we fail.
Write a (PHP) function to test the individual device capabilities we care about in each device class definition.
Translate each device class’s capability requirements into conditional (if/then) statements in code so we can determine which device class the current device should be assigned to.
Write a simple test page (similar to our WURFL explore page) to see how different user agents get sorted into device classes.
We wrote that matching function for you, but now it’s time for you to do a bit of work.
Use the matching function to test capabilities Now we have a function to test capabilities with.
We’ve got these tests sorted! Now it’s time to convert them into grouped nuggets of real PHP code.
Comfortable with PHP code? See if you can plunk in the missing pieces of the code chunk here.
These are the device class tests, grouped and ready to go.
All right! Two out of three! We’re almost done now!
Write a (PHP) function to test the individual device capabilities we care about in each device class definition.
Translate each device class’s capability requirements into conditional (if/then) statements in code so we can determine which device class the current device should be assigned to.
Write a simple test page (similar to our WURFL explore page) to see how different user agents get sorted into device classes.
By default, the page will show you the device class assigned to your current browser.
Enter the user agents here into the form field to see which device class they get assigned to.
This simple test form is coded for you in index.php.
The page displays the device ID and the computed device class for the entered user agent.
Time to pound the last few nails into our device class testing project.
We want a page with a simple form that will take a user agent and spit out which device class it matches.
This is going to be a problem for other devices that have higher resolution but non‑WebKit browsers.
We need to fix this and make sure our device classes don’t have any other logical holes that devices can fall through.
We could create a new device class to handle this combination.1
We could change the higher_mobile device class to allow for other, non‑WebKit browsers.
Why did the user agent for the BlackBerry 9300 (Curve) fail to match any device classes?
We have to decide which seems most ideal for the AcedIt! study aid website.
This Pantech smartphone qualifies as simpler_mobile because of its smaller screen.
This BlackBerry’s browser is old enough (version 4.5) that it doesn’t allow manipulation of the DOM after the page is loaded.
Uh oh! This user agent didn’t qualify for any device classes! Good!
That is, it doesn’t have the kind of JavaScript support required.
Joe: Do we really need to add yet another device class? Seems like a lot to wrangle.
We need to strike a balance between nuance and the number of  device classes we have.
It feels like we already have about the right number.
The problem is that higher‑resolution devices that don’t have WebKit browsers are falling through and not getting assigned to any device classesJoe: Aren’t there actually two problems here? One, we’re not thinking through what experience those devices should get, like you said.
But we also don’t have a fallback, default device class overall.
Seems possible something could go wrong with device detection or there might be something else we’re not thinking of.
I think we need a sort of  safety net device class.
For the first problem, if  we’re not adding a new device class, we need to fill the gap.
The question is: what is more relevant here, device resolution or browser capabilities?
Joe: AcedIt! puts a lot of  focus on the interactive elements of  the site—that suggests browser capabilities matter more.
But at the same time, we were planning on delivering smaller images to those lower‑resolution devices.
How about this for a compromise? We update the device classes such that there isn’t a top‑end resolution restriction on the simpler_mobile class.
That does mean that some higher‑resolution devices get a simpler feel, but if  I recall correctly, the dev team working on the touch‑optimized flashcards is using a framework targeted to WebKit‑based browsers.
Heh, in fact, I think that’s why we were testing for WebKit browsers in our higher_mobile class in the first place.
Wow, I need to get more sleep; my memory is failing me.
Frank: I think we’d do fairly well if  we gave all mobile devices mobile‑optimized images that aren’t any bigger than 320 pixels in any dimension.
Then we can use responsive image techniques to get us through the final mile on the device.
Here are the changes we need to make to our device class tests: Remove this resolution restriction for simpler_mobile.
Yay! The problematic BlackBerry user agent now matches the simpler_mobile device class.
Make something actually happen with device classes Time to take the device classes we’ve cooked up and get cracking.
The goal: deliver different flavors of the landing page mockup to different users based on device classes.
It’s getting a bit late, and we’re all tired: to save you some time, we did a lot of  this for you.
We’re going to walk through how we did it over the next several pages, but we’ll show you where to find the finished code.
Copy the configuration file from the last exercise into the adapt_content folder.
This is the device class testing code we just finished up (already there for you)
This page allows you to enter a user agent so that you can view index.php as different devices.
The HTML and CSS we’re dealing with here is pretty basic: AcedIt! is still in the early phases of  development on the new site, and so we’re working with some pretty barebones mockups.
We’ll treat unsupported devices similarly to desktop browsers…for now, at least We’re going to deliver content to the unsupported device class that is basically the same as the desktop content, but we’ll explicitly eliminate links to the interactive flashcards section of the site and the online store.
The starting point of index.php has all versions of the content (for all device classes) in it.
It’s time to identify which pieces of content will be delivered (or not delivered) to users who fall into our different device classes.
For each number below, find the corresponding markup on the right and fill in the blanks with the appropriate device classe(es)
Do not show these two links for the device class.
Psst…the Study Now section is the interactive JavaScript-based flashcard feature.
Use it to answer the questions on the page at left.
Oh, you thought you were done? At least you’re halfway there!
We removed a bit of the text content to save space here on this page.
It’s probably obvious, but these are just placeholders until the Flash movie and static variant are developed.
Time to look at the markup differences for the different device classes and convert our decisions into code.
This stylesheet has gradients and other fancy-pants stuff, specifically formulated for WebKit browsers.
There are elements common to both mobile device classes in these styles.
Show this version of the navigation for the , device classes.
Do not show these two links for the device class.
This is the desktop-style navigation, near the top of the page.
Show this version of the navigation for the and device classes.
We’re not showing ads on the mobile layouts, and instead of having blog teasers on the page, we’ll provide a link to the blog subpage.
This is the mobile version of the navigation, down at the bottom of the page.
Only give the link to the flashcards to the higher_mobile class.
Hit index.php directly with your desktop browser to see the desktop version of  the mockup.
We tightened up our device class tests on page 200, but can you think of anything other risks we might not be considering?
Always tread with care and come prepared Way back in Chapter 3, we highlighted some pitfalls of  serverside device detection using user agents.
There are some risks that you should keep in mind:
Sometimes the user purposely overrides what user agent gets sent, and sometimes browsers just send weird ones.
This could cause a device database to return inaccurate data.
You might get a generic device ID, or nothing at all.
This is WURFL’s way of  shrugging its shoulders and saying, “hey, I tried, but I just don’t know what this puppy is.”
So what? The values for capabilities for a generic device aren’t meaningful enough to base decisions upon.
That just happens to be the value that our WURFL data file has for generic devices.
When designing a site that uses server‑side detection, take some time to think through how the site will behave if  a generic ID is returned, or if  the device fails to match at all.
This is not an inappropriate device class to assign, but the assignment is kind of  happening via dumb luck.
If you explore the capabilities returned for a bit, you’ll find more differences.
For example, take a look at the display capability group and compare it to the display capability group values for our “generic” device ID above.
Pretty different, huh? It’s smart to get familiar with our flavor of WURFL (the PHP API, file-based variant), and it’s a good idea that we have our own explore page.
The generic values for the display group are very generic—we shouldn’t rely on them.
FAIL--make sure you have a plan for this situation */
Or if the match is nonspecific and has fallen back all the way to the root (generic) device.
The PHP API provides a few methods for determining how specific a match was.
Why can’t I just test for a specific match and be done with it?
Checking for the lack of  a device ID overall feels like good housekeeping.
The desktop browser patch we’re using with WURFL allows us to get basic information about desktop browsers as well as mobile ones.
However, all matches for desktop browsers will return FALSE for isSpecific(), as the data in the patch isn’t considered specific.
By checking the fallback and making sure it’s not root (generic), we can avoid falsely identifying desktop browser matches as failures.
Q: What is this desktop browser patch of which you speak?
A: The default installation of WURFL comes with a patch that will identify, broadly, a set of desktop browsers as well as mobile browsers.
Q: I don’t understand what parts of WURFL are the API parts.
The API is all the code that interacts with it, organizes it, and so on.
A: When someone shares a link or whatnot on Facebook, Facebook often goes and fetches some content from that page, and/or a representative thumbnail‑ish image.
This is the user agent it uses when it does so.
In real life, for real projects, the code would likely be more elegant, more organized, and more powerful.
Q: Excuse me, but if I am not mistaken, the $device variable is global.
It’s a complex concept—and you made it! You even have a content‑adapted web page to prove it.
Device data repositories like WURFL (Wireless Universal Resource FiLe) allow us to get at very detailed information about a whole lot of devices.
We can use a device database to identify a value for a given capability and act upon that value.
WURFL’s PHP API is one of several APIs for interacting with WURFL data.
ScientiaMobile was founded in 2011 by some of the original WURFL maintainers.
The company provides open source and commercial licenses for WURFL.
When working on larger projects, it can be helpful to group relevant capabilities into device classes.
Device classes are abstract groupings of devices based on common capabilities.
By slotting a device into a device class, we can take further action upon it (e.g., delivering adapted content) without having to track individual capabilities constantly.
It’s important to build in default device classes, error checking, and generic device handling into any code that uses a device database for identification.
Like nearly everything on the Web, server‑side device detection is not a 100% bulletproof concept.
Server-side detection and content adaptation can be married with client-side adaptation—the two are not mutually exclusive.
How do I make a choice between server-side detection, which can trip up on bad or mysterious.
It doesn’t have to be one way or the other.
You don’t have to throw RWD out the window when you use server-side device detection.
Some very handsome things can be accomplished with a combination of  the two.
Making the two dance in harmony is part of  what we’ll look at in Chapter 9, as we look to the future.
The terms mean different things to different people—a free‑wheeling semantic party that can be exhilarating or frustrating.
As a web dev, you may already have eager customers beating down your doors asking for HTML5 and web apps specifically.
I’ve heard that you can do all sorts of cool things by using.
It’s an in‑progress standard, an evolution of  the HTML we know and love—the language without which there would be no Web.
HTML5 clarifies and improves upon the two‑decade‑old markup language, adding, especially, support for web apps without putting much backward compatibility at risk.
You can usually look at a website in a browser and have an sense of  whether what you’re looking at feels applike or not.
An emphasis on accomplishing tasks, a layout that fits on a single screen, actions that don’t reload the whole page, interactivity—all have been proposed as criteria for what is an app versus what is a regular ol’ (content‑centric) website.
In short, no one has ever defined the word app in a way that makes everyone happy.
Web apps are hard to define, but they share certain interactive characteristics that are well suited for the strengths of HTML5 and its complementary technologies.
How “traditional” websites typically behave In a traditional website model, a request for an HTML page retrieves all of  the components of  that page—the HTML itself, JavaScript, CSS, images, etc.
Browsers are often good about caching elements, and web servers can be configured to encourage additional caching.
But this model means that each interaction—form submit, link click, whatnotresults in a full‑page load.
The downside to this—especially when it comes to mobile devices with limited concurrent HTTP requests, bandwidth, and processing power—is that it means requesting and downloading assets the browser may already have downloaded before, and encumbers the browser with re‑rendering content and reprocessing code that might not have changed.
Full pages are served again as if the browser and server had never communicated before.
The server returns the page and all the assets needed to load it correctly.
Certain assets (images, data, JS) can be saved locally for later or offline use.
Response content can be inserted into an existing page’s DOM.
A response can be limited to the specific content needed, avoiding the bandwidth and processor costs of a full-page reload.
The first request gets all the various components of the page…
In a more applike model, the client tends to play a bigger role, and fewer assets are bandied around in each request.
Requests for changed content or data can be made asynchronously using AJAX.
These behind‑the‑scenes asynchronous requests pull in specific content or assets without causing a full‑page reload.
Requesting only relevant pieces of  content and not reloading the entire page reduces bandwidth and processing, and improves the sense of  interactivity.
A lot of this interactive feeling is accomplished through asynchronous requests.
Tartans Unlimited is an international organization that’s trying to keep the history and culture surrounding Scottish tartans alive in other parts of  the world.
I have an idea for a web app I want to build.
A collection of tartans: popular “traditional” ones as well as new-world and user-created tartans.
Make it so users can see and explore the tartan patterns right on their phones.
Wouldn’t it be cool if users could create their own tartans?
It would be nice if the app could somehow “link into” our international events database.
A history of Tartans Unlimited.Links to information about the history of tartans.
Jill: Hey guys, I know the requirements are pretty vague.
When I talked to Ewan, I got the sense that there are two main things he wants to accomplish with the site…or app, or whatever.
There’s a chunk of  content pages: info about the organization and education about tartans.
Actually, it seems he wants to call the whole site that, not just one section.
Anyway, it seems like it’s sort of  a combination of  a browsable listing of  tartan patterns to explore and, he hopes, a way for users to create their own tartan patterns using a formFrank: Wow.
That sounds simultaneously bizarre and daunting, but possibly fun as an implementation challenge.
Joe: OK, content pages, Tartanator area…what about this note about an Events page?
Jill: Hold your horses! I’m getting there! We’ve decided to do this project in two rough phases.
For the first phase, we’ll build basic structure for the content pages and implement the tartan listing.
He’d also like us to think about how an interface for users to create their own tartans would look, and maybe prototype the frontend of  that.
Joe: So, like, we’d build the form for creating a tartan, but it doesn’t need to do anything yet?
In phase 2, we’ll make it actually work, and we’ll also come back and work on an Events section.
Frank: OK, sounds like we need to go start building a mobile web app.
Some of the tartans that will be in the Tartanator’s tartan directory.
We need to create basic sections and pages and create an overall structure.
For the first phase, we’ll create a listing of  existing popular tartan patterns.
The tartans section should be a browsing interface that—of  course—looks and feels applike and mobile oriented.
Ultimately, Ewan would like users to be able to construct their own tartans by using an applike mobile interface.
He wants to see what that might look like, so we’ll whip him up a prototype.
So, we’re supposed to build a mobile web app with HTML5 and stuff.
Do I have to build all of this from scratch?
Buy it, it’s great! The best HTML5 Programming book on the market.
We’ll still be using our HTML and CSS chops, but a mobile‑oriented user interface framework can help us get our job done faster.
Framework developers keep on top of  obnoxious or curious browser quirks that could really throw a wrench in things, working around them in the framework’s codebase so that we don’t have to.
Frameworks are powerful mojo, but they also have some drawbacks.
Many are quite hefty, and can bloat your site’s payload by hundreds of kilobytes.
Some only support one or a few major, cutting-edge platforms.
A framework can help us make a website or app look mobile-friendly.
Mobile‑oriented frameworks generally help alter and style HTML elements to look and feel more mobile, often saving us quite a lot of  time.
A framework can help us make a website or app feel mobile.
Frameworks can take the drudgery out of  transitions and effects that make a website or app feel more native, or, at least, consistent.
Depending on the project, you might not want to reinvent at least some of the wheels required for an interactive web app.
Building complex, interactive web apps from scratch—especially mobile web apps—can be a daunting proposition.
A web development framework—that is, a packaged collection of  interactive elements and code tools—can help give us a leg up.
Our choice for the Tartanator: jQuery Mobile To build the Tartanator, we’re going to use the jQuery Mobile framework.
Also, if  you’ve ever used jQuery before, you probably know how intuitive and straightforward it feels.
Here’s where we trot out our tired Wild West metaphor about the mobile web.
There are no simple answers, and pulling off  complex feats on the mobile web often involves the cobbling together of  several implementation approaches.
Seems like we already have a hundred different ways to build stuff for the mobile web.
Do I just forget about all of that stuff and start over with mobile web frameworks?
Q: Are there other mobile frameworks out there? A:And how! There are more every day.
Q: What exactly makes up a mobile web framework? A: It depends on the framework, but most involve a combination of JavaScript, CSS, and image (or other) assets to aid in the styling of the mobile experience.
Some frameworks also include a server‑side component to help generate (as opposed to adapt) content.
What about zepto.js or XUI? A: Zepto.js (very lightweight JavaScript, with jQuery syntax) and XUI (also very compact JS) both fall more on the library side of the line (versus framework)
Frameworks tend to have UI components, while libraries tend to be code—in this case, JavaScript—only.
This is a grey area; the division between library and framework isn’t easy to define.
Q: So, jQuery Mobile is a mobile version of the original jQuery library?
A: Not so fast, hotshot! jQuery Mobile builds on top of jQuery.
You’ll notice that when we start building stuff with jQuery Mobile, the first JavaScript file we include is the core jQuery library.
Q: So, jQuery Mobile is a JavaScript development framework that extends jQuery.
That means it also includes stylesheets, icons, and other pieces of the puzzle.
Q: Do we really need to use a framework? A: Do we need to? Technically? No, not at all! In fact, we encourage you to build applike mobile websites from scratch, if that’s your bag.
However, the nice thing about frameworks, and jQuery Mobile in particular, is that they take care of a lot of obnoxious, platform‑specific quirks and bugs for us.
Their team of devs has laserlike focus on the foibles of different mobile browsers.
Trying to pull off what we need to do for the Tartanator without a framework of any sort would be pretty hairy, not to mention the chaos of extra testing that would be required (as we wouldn’t have that underpinning of tested cross‑platform support)
How is the Tartanator an app instead of a website?
The subtleties of differentiation between app and site are so vague that the answer sometimes seems almost arbitrary.
Ewan has a vision of the Tartanator as a functional, web‑based thing.
His focus is on the ability to find and create tartans, and, also, ultimately, to search for relevant events.
Q: But what if it were a site? I couldn’t use jQuery Mobile then, right?
It doesn’t care whether you call what you’re making with it an app or a site.
Its job is to make things feel usable and not break across various mobile platforms, using a combination of CSS, JavaScript, and HTML5
Don’t panic! HTML5 is modular, and mobile browsers are increasingly supporting more and more pieces.
The website http://www.caniuse.com is a good reference if you’re looking for info about specific feature support in HTML5 and the other major web technologies.
We’ll show you what’s in it in a little bit.
The first stop on the Tartanator adventure is to learn how to build a simple page with jQuery Mobile so that we can start constructing the pages in the project.
Start basic By starting with a super‑simple HTML page, you can see the basics of  jQuery Mobile at work more clearly.
We’ll be meeting these pages in a few, err, pages.
Include jQuery mobile code components Open index.html in your text editor and get ready to plop in some jQuery Mobile.
First things first: include the JavaScript and CSS that will make things go.
Include jQuery Mobile’s CSS: this will style our markup in mobile-friendly ways.
The inclusion of jQuery and jQuery Mobile JavaScript will give our web app its mobile-friendly interactions.
It really is that easy to make a simple jQuery Mobile page.
Add the items to the head and body of the index.html file and save it.
That’s a reliable and fast place to link to the code.
Now that we’ve included the three core files—theme CSS, jQuery Core, and jQuery Mobile itself—we need to make a few adjustments to the HTML markup within the <body>
A data-role of “page” tells jQuery Mobile to treat the contents as a full page.
The data-role of “header” tells jQuery Mobile to style this as a header-like element.
A data-role of “content” means—you guessed it—this is the main content of the page.
We don’t have anything too fancy yet (OK, it’s actually pretty dull), but the landing page does look somewhat “mobile.”
Note how jQuery Mobile adds gradients, sizes, and font treatments, and turns our elements into header‑ and footer‑like chunks.
Our first jQuery Mobile page, as rendered on an iPhone.
And many people now associate that appearance with “looking mobile.”
But beyond Apple‑esque polish, there are some useful things going on here.
Whitespace is increased and font size optimized for small‑screen reading.
Soon, we’ll build forms and be able to see that jQM gives us larger input areas and chunky buttons—big touch targets for our fat fingers.
In our simple page, we used the data-role attribute to inform jQuery Mobile of, well, what role the given element has in our page structure.
Right now things are pretty simple: we have a header, some content, and a footer.
Build more of the Tartanator Now that we have a solid foundation, let’s start building more of  the Tartanator.
Right now we have our landing page, but we need to link it to some other basic pages to move forward with the project.
A simple information page This will be a page to find events, but.
This is the fun part: lots of examples of tartans.
Time to add a navigation‑like list of links to the three subpages.
The text of the list elements should be the names of the subpages: About Us, Find an Event, and Popular Tartans.
We’ll add the actual links in just a bit; for now, just text, OK?
In the past, we developers found some ways to do things like this by kind of hijacking other element attributes like class or title.
But now there is a real, sanctioned way to do this, and jQuery Mobile takes advantage of it.
As we move along, we’ll continue to encounter places where jQuery Mobile uses different data-* attributes to get its job done.
Make it a jQuery Mobile list If  you save your changes and view index.html in a browser, you’ll likely notice that our little list doesn’t look very exciting (or mobile‑ish)
That’s because we haven’t informed jQuery Mobile that we want it to take note of  its existence.
We use the data-role attribute to tell jQuery Mobile to treat this as a list view.
That way, jQuery Mobile will style the list nicely and recognize its existence.
Add the data-role attribute to the <ul> in index.html and view the page in a browser.
What do you think of the way jQuery Mobile styles the list?
Our list: Better, but not quite there By default, jQuery Mobile will treat listviews like page content, filling the full width of  the screen with the <li> elements.
On our landing page, this looks a bit awkward and cramped.
For our purposes, the navigation list is part of  the content, not the entirety of  it.
Add the data-inset attribute to the list in index.html and try viewing the page again.
The list looks great and all, but none of its elements are clickable.
Let’s link up the pages! Time to make the Tartanator more than a one‑page show.
Link to multiple pages with jQuery Mobile Linking to other pages in jQuery Mobile is quite straightforward.
All we have to do is add basic HTML links:
Do this! Add the links to the list in index.html and test them out.
There is no tartan.html file in our main directory yet.
This is how jQuery Mobile reacts when it encounters a broken link.
By adding the links, we automatically get the arrow icons that show users these are clickable links.
Head First: I hear you have something to tell us about what a “page” really is, to you.
Remember how the structure of  one of  my pages uses a <div> with a data-role value of  page?
Head First: Then what is the point of  the rest of the HTML markup? Is it chopped liver?
If  each HTML file is independent, why bother with the <div> with the data-role of  page?
When you first navigate to a page in one of  my sites or applications, that page is loaded just like any old HTML page on the Web.
But once that first page is loaded, I do something different.
When you click on links, I find the page content from the requested HTML document—that is, the stuff  in the <div> with the data-role of page—with AJAX and inject it into the current page’s DOMHead First: But what is the point of  that?
Instead of  requesting and downloading the whole requested page—scripts, images, styles—and reinitializing and rebuilding the DOM from scratch, I only snag the pieces that matter.
That saves on HTTP requests, bandwidth, and processing time and makes the experience feel a bit more natural and native.
Head First: If  content pieces are loaded dynamically, how come I see the URL of  the link I clicked on in the address bar of  my desktop browser?
I always aim to have real URLs for the pages in my apps, even if the pages are really generated dynamically or there are multiple <div> tags with a data-role of page in a single HTML document.
By having a unique and reusable URL for AJAXloaded content chunks, I can make them look and act like full‑blown web pages.
When the browser allows me to (not all browsers do), I even update the displayed URL in the browser’s address bar as I load in new content asynchronously.
Head First: If  I understand correctly, then, I can access each HTML file in my app or site directly, but the content of  those documents can be retrieved independently and dynamically, when linked to, to improve performance and responsiveness?
Head First: Thanks, jQuery Mobile, for a really dynamic chat.
If page content is loaded dynamically with AJAX, what happens to.
Recall that the links in the markup start out as just that: basic HTML links.
It’s jQuery Mobile’s JavaScript that does the magic of  converting the links into dynamic AJAX‑y goodness for browsers that support it.
For browsers that don’t support this, navigation between pages works just like the old‑fashioned Web always has.
Q: If pages are loaded with AJAX, why do I need to create separate pages at all? Can’t I just put all of my app’s content into one page and use jQuery Mobile to show and hide it?
A: You could, but you’d be missing out on jQuery Mobile’s nice notion of progressive enhancement.
You’d be leaving lesser mobile browsers (those that can’t do the snazzy JavaScript) out in the cold.
You’d also have a large, complex file that is difficult to maintain and has a heavy DOM that is tough for lesser phones to handle.
A: Developers can cook up any name they’d like for data-* attributes (well, they have to start with a letter)
The idea is that data-* attributes pertain to the functioning of the website that they appear in—that is, they’re not intended for communicating data to external applications.
Because of that, web developers have relative freedom to generate their own data-* naming conventions.
As we saw on page 230, the text in the page footer is getting truncated on narrow screens.
That’s because jQuery Mobile leaves room for button placement around header elements in headers and footers—but we don’t have any buttons in our footer.
Right now, the footer text is wrapped in an <h4> element.
By removing this header element, we’ll keep jQuery Mobile from leaving room for buttons and, as a side effect, truncating the text.
Add a CSS rule to center the footer text and give it a bit of padding.
Unfortunately, removing the <h4> will also remove the centering and the padding.
We need to account for this in our own CSS.
Also, it has a bit more visual weight than it needs to.
This CSS selector applies to elements with a data-role attribute that has the value “footer.”
Edit index.html again and add a link to the stylesheet.
Save the file and view index.html in a smartphone browser or simulator.
Also, look, it doesn’t always end up at the very bottom of the screen.
The fix to both of these items involves a couple of small changes to the footer <div>
We want to tell jQuery Mobile to use fixed positioning to make the footer stick to the bottom of  the page, and we need to change the theming swatch to make the footer appear less dominant visually.
The footer isn’t always at the bottom of all of the pages; sometimes there is a gap.
Use fixed positioning on the footer so that it always shows up in the same place.
By using the data-position attribute and setting its value to fixed, we tell jQuery Mobile to use fixed positioning on the footer element.
That way it will always stick to the bottom of  the page.
Use a different theme swatch to make the footer appear less dominant.
These five swatches are referenced by the letters a through e.
By default, header and footer elements receive swatch a, which has the most dominant contrast.
Our footer isn’t a particularly important page element, and right now has too much visual weight.
By explictly assigning swatch c, we can make the appearance of  the footer much less in‑your‑face.
You can use the data-theme attribute on any element to override jQuery’s default swatch for that element.
The default color scheme for swatches a through e is defined in jQuery Mobile’s CSS.
That’s it! The footer should look a lot better now.
Try saving your changes and reviewing our improved footer in a mobile browser or simulator.
The release of jQuery Mobile 1.0 includes a new Theme Roller tool that makes theming jQM easier.
We need to create basic sections and pages and create an overall structure.
For the first phase, we’ll create a list of  existing popular tartan patterns.
The tartans section should be a browsing interface that—of  course—looks and feels applike and mobile oriented.
The footer is now positioned correctly and is much less imposing visually.
We’ve got our core content pages—at least the skeletons of them—in place.
Now let’s turn our attention to matters that are more interesting: the tartans themselves.
For phase 1, the Tartanator will allow users to browse a collection of  popular and unusual tartans.
Think of  it kind of  like a quick tartan reference.
Do this! Copy tartans.html from the extras folder to the chapter6 folder (that is, move it up one level)
The tartans directory, which contains the individual tartan HTML pages, should already be in your chapter6 directory.
Let’s check in with our status on phase 1 of  the Tartanator project:
We’ve got our basic layout squared away and created the basics of the main pages.
Get to work on tartans.html The tartans.html file has the beginnings of  a list (<ul>) for the popular tartans.
To get you going, the list contains tartans starting with A and B.
Once you’ve moved the tartans.html file into place, load up the Tartanator on a browser (mobile or otherwise) and take a peek.
You can click on the tartan names to visit the tartan page for that tartan.
Take the list from blah to better The list of  tartans is looking a bit lifeless compared to the tartan information pages themselves.
Good news! jQuery Mobile makes it easy to drop thumbnails into lists so we can have small icons on the list itself  (much snazzier)
The icons are in the tartans/icons directory and have the same name as their HTML counterparts (but with a .png extension)
The first swag at the list of tartans—we did this for you already.
The tartan listing section is a combination of a single HTML page with a list of tartans…
Drop in the rest of the tartans There are a whole bunch more tartans that need to be added to the list (with their nice icons)
Don’t worry, we won’t make you do that much typing.
In the file, you’ll find a snippet of  HTML that is the full <ul> for all of the tartans.
Copy and paste the <ul> into tartans.html, replacing the current HTML list.
Hey, the list’s looking pretty nice, but it seems kind of long.
It’s hard to find a specific tartan name without a.
Turns out, jQuery Mobile has more up its sleeve for us.
More easy‑to‑implement, good bang‑for‑the‑buck improvements to our tartan list coming up!
Now we’ve got an enhanced list—hey, nice icons!—and have included all of the tartans in the current collection.
We can break up the list into sections by using list dividers.
This will help organize the list by grouping tartans by their first letter.
With jQuery Mobile, it’s eerily easy to drop in a filter for a list.
To add a filter for the list, add a data-filter attribute to the <ul> with a value of “true.”
You can visually separate the list by adding <li>s with a data-role of “list-divider.”
Give the <ul> in tartans.html a filter field and list dividers.
Add list dividers for each letter (except those that don’t have any tartans, like Q and X)
Save your work and view the results in a browser.
Q: I notice that when you change pages in a jQuery Mobile web app, there is an animation effect.
A: To make web apps feel more consistent with mobile user interface patterns, jQuery Mobile applies a transition to page changes.
By default, the slide transition will be used, which makes it appear that the new page is sliding in from the right.
To change the transition that is used, you can add a data-transition attribute to the link in question.
But jQuery Mobile strives to have as much cross‑platform support as possible.
You can see a list of the supported devices and browsers and how well they are presently supported at http://jquerymobile.com/gbs.
Q: What happens if a device or browser isn’t supported? Or if JavaScript is turned off?
A: jQuery Mobile’s philosophy is heavily biased toward progressive enhancement.
Why don’t you try it out yourself? Load up the Tartanator in a web browser with disabled JavaScript.
List dividers help break up the long page of tartans.
Typing in this field will (instantly) filter tartans by name.
Quick, mobile-ready widgets like these are one of the hallmarks of mobile UI frameworks like jQuery Mobile.
It’s time to show the early Tartanator work to Ewan.
Before we start into the form, let’s check with the client to make sure our overall approach so far is OK.
Jim: What does “make it look like a native app” even mean?
Frank: It seems like that’s a very subjective thing, doesn’t it? I think what Ewan is looking for is something that feels a bit more “app”‑y.
Frank: I guess like tab bars, navigation elements, button‑y and icon‑y bits.
Jim: But don’t we run the risk of  emulating one platform too much at the expense of  others?
When people say “native,” sometimes they are dangerously close to meaning “make it look like iOS, please.” Each platform has its own UI metaphors.
To make our customer happy, we need to look native, which might well mean alienating, say, our Android and BlackBerry users.
Frank: I think we need to pick and choose some things we could enhance to make the Tartanator feel more like an app without making it look like an iPhone app.
To be fair, jQuery Mobile elements in their default skins look kind of  iOS style.
Jim: So the aim is to make the Tartanator feel more like an app without necessarily feeling platform‑specific native?
I’ll sketch down a few thoughts on some changes we can make to shoot for that goal.
The new goal: make the Tartanator look more applike without necessarily looking platform-specific.
Here are some quick things I think we could do to make the Tartanator feel more like an app.
Recent email from Ewan: content isn’t panning out as well as he’d hoped.
Maybe conflate the landing page and the About Us page into one? Use the landing page as the info page? Convert links on landing page into persistent toolbar with icons.
Do away with the separate About Us page, as content is not forthcoming.
Consider the current landing page the de facto About page for now.
In jQuery Mobile, it’s easy to add a fixed‑position toolbar to either the header or the footer.
To create a more applike feel, let’s put a toolbar in the footer instead of  having the links to the Tartanator’s sections inside a <ul> on the landing page.
Construct a navbar Inside of  a header or footer container—so designated by the data-role attribute—we can put another <div> with a data-role of  navbar.
This tells jQuery Mobile to treat the contents as buttons in a toolbar.
Put buttons in the navbar Instead of  links in a vertically organized list, we’re going to make toolbar buttons to access the main sections of  the Tartanator.
A data-role of navbar triggers jQuery Mobile to make this look like, well, a navbar.
Remember, we’re jettisoning the aboutus.html page in favor of using the index.html page as an About page.
So far, so good, but our toolbar buttons are a bit drab.
Let’s drop some icons in by using the data-icon attribute.
Also, let’s denote which section the user is currently viewing by setting a class of  ui-btn-active on the appropriate link.
This will show up with theming that makes it highlighted, thus appearing active.
They look like buttons, all right, but they could be a bit more fancy.
The data-icon attribute indicates which icon to use in this button.
A list of available default icons can be found in the jQuery Mobile documentation.
For the other pages, you’d want to assign this class to the appropriate anchor tag.
We’ve replaced the footer with a navbar, but we don’t have to discard the tagline entirely.
Let’s make it a kind of  subheader on the landing page (only)
Make the header sticky, too While we’re in there, let’s make the position on the header fixed, too.
That will make the header behave in the same way as the footer: always present at the top of  the screen, even if  the user scrolls.
We just need to tweak the header a bit now…
Convert links on landing page into persistent toolbar with icons.
Do away with the separate About Us page, as content is not forthcoming.
Consider the current landing page the de facto About page for now.
They will always show up at the top and the bottom of the page (respectively), even if the user scrolls.
Make sure to assign the ui-btn-active class to the correct anchor tag, depending on the page.
Add a data-position attribute to the header on each page.
Ewan would like users to be able to construct their own tartans by using an applike mobile interface.
The next step in the project is to create a prototype of  a form that will let users design their own tartans, right from their mobile browsers.
When a tartan is woven, this pattern is repeated both horizontally and vertically.
We need to have a rough idea of  how tartans are put together so that we can build a form to gather the right kinds of  info.
Follow the tartan recipe To weave the tartan, the pattern is followed in order (in our case, we’ll be “weaving” with pixels instead of  wool)
When the last color in the pattern is reached (six stitches of  yellow, in our example), the pattern is followed in reverse (blue, red, blue, green)
When the first color (black) is reached again, the cycle repeats.
The pattern is woven both horizontally and vertically (warp and weft) to create the overall tartan pattern.
To create the Carmichael clan tartan, the pattern looks something like:
Back and forth and back and forth and back and…Pssst…this is the.
Each ingredient in the pattern is a pairing of a color and a size.
As the different colors overlap horizontally and vertically, they create the distinctive pattern.
We need to create form fields that will collect the color and size value for each ingredient in a user’s tartan design.
The first and last colors (black and yellow) don’t repeat.
Create an empty jQuery mobile page to hold the tartan‑building form.
Use the same header and footer, but change the title and header of the page to “Tartan Builder.” Name this file build.php.
Basic info about the tartan being created: its name and an optional description.
Color-size field pairs let users build the ingredient list for their tartan recipes…
Translate tartan patterns to a form Let’s take a look at the form prototype we want to build.
We need fields that allow users to enter in those color‑size pairs that build a tartan recipe.
OK, we have a general idea of the form we want to build.
The form itself  will be a standard HTML5 form: jQuery Mobile will adapt it to make it look and feel more mobile‑friendly.
In Chapter 7, we’ll make the form actually do something, including enhancing its interactivity with JavaScript and spitting out actual tartan images.
For now, we’ll lay the groundwork and create a baseline, no‑frills form that will work in nearly all mobile browsers.
We’ll use a listview <ul> to help with the layout of our form.
These two list-divider <li>s break our form into two sections.
Form structure We’ll want users to name their tartans and, optionally, enter a description.
Then, they can define color‑size combinations to build the pattern itself.
Let’s give our form two main sections: a top section for metadata about the tartan and a main section for defining colors and sizes.
The only difference between the markup we’ll use and what you might be accustomed to is that we’ll take advantage of  the HTML5 placeholder attribute.
We’ll also be careful to use proper, semantic, accessible label elements.
The placeholder attribute lets us add initial, placeholding text in a field—it “goes away” when a user clicks into the field and alters its contents.
Give jQuery Mobile hints about the fields You may notice above that each field is inside an element with a data-role of  fieldcontain.
This data-role gives jQuery Mobile a hint that form fields are within this element, ready to be enhanced.
Lists within lists let the users add colors Each piece of  the tartan pattern is a combination of  a color and a size (width)
For layout, let’s group each of  these compound fields into a single <li>
This PHP for loop will generate 6 of whatever is inside the loop.
Q: Why are we not assigning the data-role of fieldcontain class to this <li>? It has fields in it.
Which kind of element should I be assigning the fieldcontain data-role attribute to?
The fieldcontain data-role tells jQuery Mobile to group the contained field and its label when enhancing the form.
So, each containing element with a data-role of fieldcontain should contain one field (and its label)
Q: Do I need PHP for this part of the project?
A: Yep! As we move into the more functional pieces of the Tartanator, we’ll be using PHP to do the crunching and thinking.
Each set of  color fields will have a color (as a <select>) and a size input.
The classes of  color-input and size-input are for later, when we enhance the form with JavaScript.
Obviously, we want more than just black and white as color options! More on that in a moment.
Recall that we’re inside a PHP loop; this assigns each field a unique ID.
It’d be cool if we could use the HTML color input type, but, alas, it’s not yet supported in many browsers.
The field above renders about like this on modern WebKit-based mobile browsers.
The step attribute should be able to help us here.
This field type has increasingly good support among modern browsers (though certainly not universally)
In supported browsers, it renders as a slider; in unsupported browsers, it degrades to a text field.
The min and max attributes do what they sound like they’d do: define minimum and maximum values for the fields.
The field above renders about like this on modern WebKit-based mobile browsers.
This part goes right after the <select> we just built.
Save build.php and load it up in a mobile browser!
We need to link to the form and back again in an applike way.
Link to the form The build form is considered part of  the Tartans section of  the Tartanator.
We need to give users a way to get to the form from the Tartans landing page (the long list of  existing tartans)
The ui-btn-right class will make the button float right (instead of left, which is the default)
Assign the “b” theming swatch to make the button stand out a bit more.
By adding data-rel="back" to the anchor tag, we tell jQuery Mobile to treat this link as a back link.
When possible, jQuery Mobile will send the user to the last location in her history when she clicks this link.
For nonsupporting browsers, we supply a good default href, which is, in this case, tartans.html.
Add a back link to the header of  the Tartan Builder page.
We need to create basic pages for the site and create an overall structure that looks and feels right on mobile devices.
For the first phase, we’ll create a listing of  existing popular tartan patterns.
The tartans section should be a browsing interface that—of  course—looks and feels applike and mobile oriented.
Ultimately, Ewan would like users to be able to construct their own tartans by using an applike mobile interface.
He wants to see what that might look like, so we’ll whip him up a prototype.
People want apps! The definition of what, exactly, makes a website a web app is fuzzy.
Applike websites tend to feel more interactive than content pages.
Chunks of content and data are often retrieved asynchronously and inserted into an existing DOM, reducing the frequency of full‑page loads.
Building mobile web apps from scratch can be very complex.
We encourage you to try it! But for our purposes, we used a mobile user interface development framework to help us out.
It has a strong relationship with well‑formed HTML5 markup, which makes it relatively straightforward to build mobile interfaces from basic code.
We built the structure for phase 1 of the Tartanator by, among other things, using jQuery Mobile–enhanced listviews, headers, footers, navbars, and form elements.
Making a web app feel more native is always a balancing act, requiring some careful decisions.
We used some HTML5 form element attributes to build our prototype form.
I’m excited about moving on to the next phase of the Tartanator—that’s where the fun stuff really happens.
We are also using the range input type and the placeholder attribute in our form.
A: Unfortunately, at the time of this writing, jQuery Mobile’s range slider widget doesn’t support the step attribute.
Q: Colors as a select list—that doesn’t seem like the most fantastic user experience.
A: When we enhance the form in Chapter 7, we’ll add some JavaScript code that will show the user the color she has selected.
Q: What happens to mobile browsers that don’t support range inputs yet?
A: As long as the browser supports JavaScript and CSS fairly well, jQuery Mobile will convert the range field into a slider widget (actually, it does this for browsers that support range inputs also)
If a browser doesn’t support range inputs and doesn’t have JavaScript support (or it’s disabled), the range field will most likely appear as a standard text input field.
Q: The header and footer blink sometimes, or are slower to load than the other parts of the page.
A: One of the ways jQuery Mobile attempts to emulate a native‑ish experience is by using fixed‑position headers and footers (when you designate them as such, that is)
The way this is actually carried out differs on different platforms.
In a nutshell: although the landscape is improving very fast, fixed positioning (in CSS, position:fixed) has unpleasantly scattered and weird support in mobile browsers.
See? It’s really not too many steps from the HTML and CSS you already know to a mobile‑feeling, applike website!
The mobile web feels like that gifted kid in the class.
You know, kind of fascinating, capable of amazing things, but also a.
We can use progressive enhancement to spruce up the interface in more.
Pull my pigtails again, and you’ll pay! There’s nowhere to hide.
And jQuery Mobile is helping to make our HTML5 form elements look and feel mobile friendly.
It may seem like building phase 1 was full of sound and fury, signifying nothing.
We've got a straightforward structure based on HTML5—now it's time to take it to the next level!
Mobile apps in the real world Mobile web apps that take good advantage of  innately mobile characteristics often have certain aspects in common.
What we like to call super mobile web apps feel like mobile apps for the real world.
They adapt to their users’ disparate devices with the robust use of  progressive enhancement.
When the user doesn’t have a data connection, these apps can function in an offline mode.
And they take advantage of  browser‑accessible geolocation to provide location‑relevant content.
Super Mobile Web Apps knows all about the three features we’ll explore in this chapter to make mobile web apps more “super” and take advantage of its inherent, awesome mobileness.
What will we do to complete Phase 2 and make the Tartanator a super mobile web app?
Then we’ll boil them down into a few core objectives for this phase.
A collection of tartans: popular “traditional” ones as well as new-world and user-created tartans.
Make it so users can see and explore the tartan patterns right on their phones.
Wouldn’t it be cool if users could create their own tartans?
It would be nice if the app could somehow “link into” our international events database.
A history of Tartans Unlimited.Links to information about the history of tartans.
The major objectives for the second phase of the project really fall into two core goals:
Plug in the pieces that let users generate their own tartans.
Now we need to walk the walk and plug in the pieces to make this actually work.
We also need to enhance the existing form to make it more usable for fancier smartphones and add a few bells and whistles.
We’ll need to hook into an existing events data source to let users find nearby tartan-related events.
Tartan even tsA history of Tartans Unlimited.Links to information about the history of tartans.
It would be nice if the app could somehow “link into” our international events database.
Make it so users can see and explore the tartan patterns right on their phones.
A collection of tartans: popular “traditional” ones as well as new-world and user-created tartans.
Wouldn’t it be cool if users could create their own tartans?
Frank: That first big requirement is a doozy, isn’t it? I think it’ll help to break it down into smaller chunks.
Jim: Before we do that—what happened to the outstanding item for the About Us page and historical background?
Frank: Oh, right! The wife of  the guy who writes bios and informational copy for Tartans Unlimited just had a baby.
The new father has found himself  far busier than he expected and isn’t going to be able to help out with the project for a while.
Big surprise, huh? So we’re not on the hook for that one right now.
Let’s talk about getting the pieces in place to allow users to create their own tartan patterns.
Not to brag, but I’ve already got a head start on this one.
I’ve been tinkering with a bit of  JavaScript to enhance the form.
But we also need to drop in server‑side scripts to do the actual workJim: You server‑side guys! Trust me, enhancing the form interface is a really significant improvement.
Jim: Actually, is it OK if  we focus on getting the tartan generation nailed and circle back on the events searching when we’re feeling ready to think about it? I only have room in my brain for so much at one time.
Frank: I guess that’s fine as long as we get cracking on the custom user tartans stuff  right quick.
Enhance the form we built to take advantage of  capabilities of  newer mobile browsers.
Make sure the offline experience for this part of  the app is acceptable.
The devs always get so excited and productive when they get to work on mobile web app projects!
We’ll walk you through the highlights (and you can always spend some time looking at the code), but you don’t have to write it yourself  or anything!
We’re about to make a lot of  nifty enhancements to the Tartanator’s create form—in very short order.
First step to a super mobile web app: enhance the UI for the browsers that support it well.
We can get rid of these space-consuming repeated fields and instead create a single widget.
The form is functional without any JavaScript at all–that's a good thing!
But it's a bit clunky on a newer smartphone browser.
We did the right thing We designed our form for the baseline experience: we’re not leaving anyone out in the cold (well, very few people, anyway)
Take a look at what happens if  you load up the Tartanator build form with no JavaScript at all.
Now let’s enhance It’s functional for everyone, but also kind of ugly and unwieldy for everyone.
While having six color‑size combo fields is OK for a less full‑featured browser, it’s an encumbrance for more sophisticated ones.
Now that we have our baseline ducks in a row, let’s drop in some enhancements that will make the form more of  a pleasure to use with smartphones.
Make a better form Instead of  having six fields—both cluttered and limiting—let’s use a single widget.
This will allow our users to add as many color‑size combos as they like! We can do this by using JavaScript to remove all of  the color‑size fields except for the first set.
A custom widget for the color select field We can override the default select interface in the browser and use one of  jQuery Mobile’s custom select UI widgets.
That way, we can show color swatches for each option.
The custom jQuery Mobile widget we’re going to use pops up like a dialog to display the color options.
Clicking on “Select a Color” pops up this customized field widget.
The jQuery .ready method is kind of like (though not identical to) the browser’s body.onload event—when it fires, it indicates that the DOM is loaded and ready.
Instead, jQM introduces some new page-load-related events, the most important of which are pageinit and pagecreate.
And remember that subsequent pages are often inserted into the first page’s existing DOM—that means that pagecreate and pageinit events can fire multiple times in a single full-page load.
It takes a few minutes for even seasoned JavaScript and jQuery folks to fully grasp the concept.
A widget to manage the list of colors and sizes.
When a user clicks the Add This Color button, the color-size combo is added to the list.
We’ve now removed all but one of  the color‑size field combos.
Using that remaining pair of  fields, we need to be able to generate an arbitrary number of  color‑size combos.
To do this, we add a new button: Add This Color.
We also add hidden form fields to the <li> to contain the color and size.
Clicking on an <li> in the existing color list will remove it and its contents from the list.
Finally, clicking the “Make it!” submit button will generate a tartan pattern with all of  the color‑sizes currently in the list.
When the range input changes value, a function makes sure the stitch count is an even number.
This is our workaround for jQM's lack of support for the step attribute on range input fields.
The button becomes visible once at least one color-size combo has been added to the list.
You don’t have to do anything to get the frontend enhancements to work.
The starting point of  the code in the chapter7 folder already includes the JavaScript enhancements.
Go try it out! See how it feels in a mobile browser.
Also, we haven't “hooked up” the backend yet; clicking this won't do anything yet!
A peek under the hood We promised that you wouldn’t have to write the JavaScript, but it might behoove you to get a loose handle on what it’s doing.
In a nutshell, there are a bunch of  things that happen when the page with the form on it has been fully loaded into the DOM (pagecreate event) and also some stuff  that happens after the jQuery Mobile widgets are finished enhancing things (pageinit event)
Take a few minutes to go hang out with and get to know the updated pieces of the Tartanator app, especially the updated tartanator.js script.
Match each function in the JavaScript enhancement code (tartanator.js) to what it does, and also to the event(s) that trigger it.
Reference the comments in the script and use your noodle to determine what each of  these functions does for us.
Adds a colored CSS border (swatch) to the left side of  each color select option.
Constructs the button to add a color‑size combo and inserts it into the DOM.
Sets the background color of  the select widget to the currently selected color.
Enhance the form we built to take advantage of  capabilities of  newer mobile browsers.
Make sure the offline experience for this part of  the app is acceptable.
Adds a colored CSS border (swatch) to the left side of  each color select option.
Constructs the button to add a color‑size combo and inserts it into the DOM.
Sets the background color of  the select widget to the currently selected color.
We just did a whirlwind tour of  a bunch of  jQuery Mobile–specific JavaScript interface enhancements.
Interface Enhancement: What jQuery Mobile makes possible, quickly, with respect to enhancing the mobile interface is compelling, sure, but I get your drift.
Enhancement: Regardless of  whether you are using a framework, designing for a baseline and then enhancing is a good philosophy.
Enhancement: Let your mind go a bit here…this is broader than JavaScript, too.
We’re talking about starting basic, defining the core experience or content, and then making it better—that is, really taking advantage of  what more powerful mobile browsers can do.
Enhancement: I like to think that my contributions are bigger than rounded corners and gradients.
We’ve taken a somewhat limited and awkward form and made it better for applicable users.
Head First: You’ve overridden the rendering of  a native form element.
The color select field is now using a custom jQuery Mobile widget.
Enhancement: It’s true that messing with native form controls is a bit controversial.
However, in our particular case, the styling necessary to give visual clues to the user—color swatches—wasn’t possible with traditional select fields.
The underlying markup is still semantically appropriate—a <select> element—but we’re tweaking it to make it a more usable experience.
But yes, you are correct in that we should consider native form control overrides carefully.
The starting point for Chapter 7 code has the structure shown here.
Getting the backend pieces plugged in requires a couple of quick steps.
Copy all of  the contents of  the extras/scripts directory into your chapter7 directory.
Using the data posted from the form, generate.php creates several resources.
An XML file representing the tartan pattern is output to tartans/data/
An HTML file for the tartan is created in tartans/
An image of the tartan is output as a PNG.
The two sides of generate.php The way that generate.php ultimately responds after creating the tartan resources depends on how it was requested.
Requested with AJAX For browsers that support AJAX appropriately, the JavaScript in build.php posts the form data to generate.php using XHR (XMLHttpRequest)
If  successful, generate.php responds with the URL of  the newly created HTML file for the tartan.
The content of  this new page is then inserted into the current page’s DOM.
Form posted directly For browsers that don’t support JavaScript and XHR, the form is directly posted in a “traditional” way to generate.php.
After generate.php creates the tartan resources, the browser is redirected to the newly minted tartan page.
The content of the new tartan page is inserted into the DOM of the build page.
In this method, the client is redirected to the new tartan page (a full-page load)
In both methods, the primary job of generate.php is the same: create the new tartan resources.
We’ve made sure to support mobile browsers with and without AJAX support.
Q: Help! Something’s not working right! A: If you are having trouble getting your tartan build form to work, or aren’t seeing any created tartans, here’s a few things to check.
First, make sure that the tartans/ directory exists and that it and all of its subdirectories can be written to by your web server’s user.
Finally, double‑ and triple‑check the <form> tag in build.php for the correct action and method.
Q: How does the tartan list page work? A: The list.php file included in the page looks at the current HTML files in the tartans/ directory to generate its list.
For each, it grabs its associated XML file (in tartans/data/) to get further information, like the pretty display name.
It then outputs an <li> for each tartan, with a link to the tartan’s HTML page.
What the heck is that? A: We chose to store the data representation of tartan patterns as XML for a couple of reasons.
Q: By the way, what is this whole super mobile web app thing you’re talking about? Some kind of standard or initiative or something?
It’s just something we started calling mobile web apps that seem like they take good advantage of the neat things mobile devices and their browsers have to offer.
Go create some tartans! Create half a dozen or so tartans of your own using the form on build.php.
Your creations should appear on the tartans landing page (tartans.php)
Now that users can add tartans, the tartan list as shown on tartans.php is everchanging.
Drop this line into the tartans.php file to include a script that will output <li>s for each currently existing tartan.
But we’re not done yet Now we have to deliver on the third piece of  the tartan‑creation implementation: the tartans need to be available offline.
I want to show a friend the tartan I designed a few minutes ago...but I have dreadful phone service in this building.
A stable—or even existentnetwork connection is something we just can’t take for granted with mobile devices.
We’ve got to do something to make tartans available without an Internet connection.
Two out of three is a great start We’ve taken some good steps toward a super mobile web app.
We’ve enhanced the baseline interface to take advantage of savvier browsers.
Enhance the form we built to take advantage of  capabilities of  newer mobile browsers.
Make sure the offline experience for this part of  the app is acceptable.
Offline is important Part of  giving a good experience to your users is making your websites and apps behave when there isn’t an Internet connection to be had.
For the Tartanator, we need to step back and figure out how we can make things work better for our disconnected users.
Can you think of why it would be difficult for Opera Mini to support application cache?
How do we control what’s available offline? Is that even possible?
We can use something called a cache manifest to define which pieces of our app should be available offline.
Make it manifest Application cache is part of  the HTML5 specification.
It allows for control over which web resources are cached for offline availability through the use of a cache manifest.
A cache manifest is a specific type of  file on a web server that gives instructions about how or whether certain web resources should be cached on a user’s device.
By creating a cache manifest, we can dictate which things are available offline for the Tartanator web app.
Support for appCache is fairly widespread in current browsers, with the notable exceptions of  Internet Explorer 9 and Opera Mini.
Using a cache manifest won’t cause problems for these browsers; they just won’t pay attention to it.
Make sure the manifest is served as the correct type of  file.3
A basic recipe to create a cache manifest There are three general steps to creating and using a cache manifest on a website or app.
The deceptively simple syntax of a cache manifest A simple cache manifest file is quite basic in appearance.
You list the items you want cached under the (technically not required, but definitely good practice) CACHE: heading.
Next, you update your web page(s) by adding a manifest attribute pointing to that file.
You also need to make sure the file is served as the correct Content-type (aka MIME-type)
You can often do this simply with Apache by adding the following to the Apache configuration file or, more likely, an .htaccess file on your website’s filesystem.
This file doesn't have to be named manifest, but the preferred extension is .appcache.
URLs can be relative (like here) or absolute (e.g., http://…)
In theory, cache management using a cache manifest file is straightforward.
List the things you want available offline, add the manifest attribute to the <html> tag of  a page or pages, and let the caching begin!
Don’t start panicking quite yet, but creating a cache manifest and getting it to work the way we really want it to can be a bit confusing and sometimes frustrating.
There are a fair number of  details and gotchas that can trip you up.
It helps to have good tools to help you inspect and debug what’s going on.
Dev tools to the rescue WebKit provides a tool called Web Inspector, which is available in both Chrome and Safari (being WebKit‑based browsers)
You can see great details about appCache information in the Resources tab.
It can be easy to get yourself in a jam working with cache manifests.
Cache manifest behavior can be tough and confusing to debug, and malformed cache manifest files are difficult to find and remove without the right tools.
Also note that appCache isn’t supported by Internet Explorer before version 10, which at the time of this writing is still in developer preview.
It will also help you save your sanity to develop and test on a desktop browser first before moving to a mobile device.
Detail of the Resources tab's info about appCache in Chrome.
It can be a bit painful to try to excise poorly formed appCaches from mobile devices.
I’ve never messed around with .htaccess files, and I don’t even know if I can do that with my current web hosting service.
It’s highly likely that you can use .htaccess files on your hosting provider or local web server.
Add the following line to the top of the file.2
Add a CACHE: section and list the main pages of the site, as well as the JavaScript and CSS files.
The .php extension is needed so that we can execute the PHP code in the file.
Update the <html> tag on index.php, build.php, tartans.php, and findevent.php with a manifest attribute.
Note that we’re also listing the CSS and JavaScript files from jQuery’s content delivery network (CDN)
In addition to relative URLs to resources on your own site…
The HTML tag on the Tartanator pages should now look like this.
A trade-off of using PHP to generate our manifest is that we can't use the preferred .appcache extension.
As I navigate around the Tartanator site, a bunch of  images and icons and stuff  aren’t showing up, even though I’m online.
You should go round them up and add them to the cache manifest.
FWD: So, I need to list every resource on the site or they won’t show up at all?
You need to add the resources that are needed by the HTML files in the cache.
What does it even mean for an HTML file to be in the cache?
But it’s also worth noting that any HTML file that has a manifest attribute on its HTML tag is included in the cache manifest, even if  it’s not explicitly listed there.
Only those pages listed in the manifest or referencing it in a manifest attribute—that is, in the cache—need to have all of their resources added to the cache list.
FWD: OK, so for any page in the cache, if  I neglect to add each and every resource to the CACHE section, any missed resource won’t ever load, even if I’m online.
I gather you’ve learned about the CACHE section, but haven’t heard anything yet about the NETWORK section.
It has a special handydandy wildcard token, *, which means that anything not explicitly listed in the CACHE section should be retrieved from the server.
FWD: Eureka! That sounds like the answer I need here.
If  something is in the NETWORK section, either explicitly or by dint of  the * wildcard, it will always be requested afresh.
Decide what things should really be available offline and list them in the CACHE section.
It sounds like you do need to track down some icons and images, for example.
But for things that really are dynamiclogin screens, API calls, etc.—let the NETWORK wildcard do its work.
Can you think of some parts of the Tartanator web app that we might not want to make available offline? Why?
We need to make the tartan pages and images work offline, so they need to be added to the CACHE section.
But how can I do that when I don’t know.
Changes to any of the resources listed in the manifest’s CACHE section will not be downloaded by browsers unless the cache manifest file itself changes.
Therefore, we could edit styles.css until the cows come home, but browsers won’t see those changes.
Once an item is in the cache, it will only be refreshed if the cache manifest file itself changes.
A common method for managing this is to use a comment line in the manifest file with a version number.
Simply changing this version number will cause browsers to see that the manifest has changed, download it afresh, and check whether any of the resources within it are new or modified.
The PHP code we’ll use to autogenerate a list of current tartan images and HTML files has the happy side effect of causing the manifest file to be updated when new tartans are added.
But, after implementing appCache, we’ll need to increment the version number if and when we change other files.
Feels like a chicken-and-egg problem, huh? Fortunately, we’re using PHP to generate our manifest file, so we can drop in some code to dynamically output a list of  all of  the tartan HTML files and images that currently exist.
Do this!Find the snippet of PHP code to dynamically generate the list of images and HTML files in the chapter7/extras folder.
It’s time to make our cache manifest behave a bit better.
There are some icons and images, used by jQuery Mobile, that we need to add to the CACHE section.
Come to think of it, these are resources that should only be available when the user is online.
The Events page doesn’t do anything yet, but it will.
It’s easy to create cache manifests that are, shall we say, not quite what we intended.
Remedying a wayward appCache is easiest in the Chrome browser.
In Safari, go into Preferences and select the Privacy tab.
You can either Remove All Website Data wholesale, or use the Details button to search for the problematic site and remove its cache.
Don't forget to remove the manifest attribute from the <html> tag on these pages.
Kudos if you caught a bunch of these already in the earlier step!
A single problem with a cache manifest can cause the whole thing not to work.
But you should know that if a single resource in the manifest results in a 404 (not found), the entire manifest will.
Similarly, a single syntax goof can render the whole thing useless.
Use the handy-dandy manifest validator at http://manifest-validator.com/ and keep an eye on your developer tools windows to make sure none of the referenced resources is missing.
Make sure you don't have any blank lines here between the header() line and the CACHE MANIFEST line.
I think it mostly works, but when I add a new tartan, it doesn’t show up on the tartans list page right away.
Even though the cache manifest file has been updated, you have to reload the tartans list page (tartans.php) before you can see the newest stuff.
Say your browser already has a cache manifest file for the site.
Then say you visit the tartans listing page again later after new tartans have been created.
Your browser will notice that the cache manifest file has changed—it’s different from the one the browser already had because the list of  tartan files in it has changed.
Your browser will immediately grab the new manifest file and check for updated or new stuff.
Jim: Then why the heck doesn’t the updated or new stuff  show up right away?
Frank: The browser doesn’t wait around for all of  the resources that are updated or new to download before rendering the page.
Once the browser does finish downloading stuff, the new or updated assets are ready to go, in the browser’s cache, but won’t show up until the page is refreshed.
Jim: So, the only way for folks to see updated things is to reload.
Frank: Well, I think I might have a workaround for this particular situation.
I wrote a tiny little JavaScript toolJim: Always with the JavaScript!
Frank: The part of  the page that’s dynamic is the stuff  that gets output by the PHP file included in it—that is, list.php.
We really only care about updating the contents of  the tartan list <ul>
If  the cache manifest has updated, we know the tartan list should be updated.
Preferably without the user having to reload the entire page.
Let’s take Frank’s little JavaScript library for a spin and see if  it helps us wrap up this complex adventure with appCache.
Include the cache-manager.js script right after the jQuery Mobile script on index.php, build.php, findevent.php, and tartans.php.
Q: If you can use a wildcard in the NETWORK section of a cache manifest, can’t I just use a wildcard in the CACHE section to cache everything on my site and leave it at that?
A: For better or worse, you can’t use wildcards in the CACHE section.
The special wildcard token is only for the NETWORK section, and it’s not really a wildcard.
You can’t combine it with any other text patterns—it is a standalone thing with a specific meaning (which is: unless a given resource on the site is listed in another section explicitly, request it over the network when possible)
Q: What is the point of making it so that pages with a manifest attribute in their HTML tags get cached even if they’re not listed in the manifest?
But the idea is that instead of downloading and caching a bunch or all of the pages on a given site in one go, pages can be added to the cache “lazily”—that is, they get added to the cache when the user visits them first.
Q: What’s this about “all in one go”? A: When a browser gets a new or updated cache manifest file, it immediately starts downloading all of the new resources and/or checking for updates to existing ones.
This is something to consider, seriously, when designing your cache manifests.
Q: Our manifest contains all of the tartan images and HTML files.
Isn’t that an awful lot to download all in one go?
But the files are rather minute: most of the images are under 1 KB and the HTML files are even smaller.
So, the bandwidth hit is small, and, because the resources are being downloaded asynchronously, the impact on the user should be minimal.
Q: Does the browser redownload everything in the manifest every time it’s updated?
The browser will check to see if the resources it already has cached have changed but will not download them again unless they’ve been modified.
Q: All of this is well and good, but what happens if the user’s browser doesn’t support appCache?
A: The site basically behaves like it did before we added a cache manifest.
It works fine, but won’t have a nice offline experience.
A: In addition to the CACHE and NETWORK sections, there is an optional FALLBACK section that allows you to list the offline variants that should be used when an online variant is unavailable—for example, use offline.html instead of login.html.
Q: appCache is nice, but what about localStorage? It feels like only half of the story here.
We mentioned it already, but we’re going to pound it home: any page that has a manifest attribute.
And, no, you can’t get around this by using the NETWORK section or any other trickery.
It was a bit of  a battle, but we now have the Tartanator working offline.
It’s time for some The other chunk of  phase 2 is the building of  a page that lets users search for local tartan‑related events near them.
We want to find events that are close to the user’s current position.
Enhance the form we built to take advantage of  capabilities of  newer mobile browsers.
Make sure the offline experience for this part of  the app is acceptable.
Writing cache manifest files that do what you actually want them to do can be tricky—you did it!
How geolocation works Geolocation from a web browser involves using JavaScript to obtain the device’s current position.
Many modern smartphone browsers implement the World Wide Web Consortium (W3C) Geolocation API, which provides a straightforward interface for getting at geolocation data.
There are a few other contenders in the mix, including the now‑deprecated Google Gears API and some proprietary APIs.
Older phones and even some modern smartphones don’t have geolocation support in the browser at all.
Although the first thing many people think of when they hear the term geolocation is GPS (global positioning system), there are in actuality many additional sources for the location of  a device, including nearby WiFi networks, cell towers, the device’s IP address, RFID (radio frequency identification) tags, and WiFi or Bluetooth MAC (media access controller) addresses.
The name of a JavaScript function to call if a position is obtained.
The name of a JavaScript function to call if an error is encountered.
Handling the info getCurrentPosition gives us When a location is successfully determined, the function that was given as the name of  the success callback will be called and given a position object.
We get at the info we really care about—latitude and longitude—by looking at the latitude and longitude of the coords attribute of  the position object.
Both of these functions simply (and somewhat annoyingly) pop up a JavaScript alert.
Geolocation JavaScript Magnets Place the code magnets in the correct positions in the geolocation JavaScript below.
You can only use each magnet once, but you may end up with a few that you don’t need.
Start in on the Find Events page: The baseline The idea of  the Find Events page is just that: to find events.
We now have a peek into how to find a user’s location with JavaScript in applicable browsers.
But we’ve been taking the approach of  creating a baseline experience first.
What if  a user’s browser doesn’t have JavaScript or geolocation?
Let’s start basic and create an events search form that doesn’t require either of  those things.
Providing a simple list of  US states in a select list will be our baseline default.
Build a simple events search form on findevent.php to use as our baseline.
Add a select input element.The displayed options should show the name of the 50 US states.
The values should be the two‑letter postal abbreviations of the states.
The submit input button should have an id of search_submit.3
A select element with the name and ID of state_filter.
A very simple form for searching for events by state.
The events database only has US-based events…at least for now.
Don't forget to wrap the fields in a <div> with a data-role of fieldcontain (the jQM way)
Give the form a method of GET and an id of search_form.
We'll show you where to find events.php in just a bit.
Find us_states.txt in the extras/events directory to help you along.
Once you’ve constructed this code, put it in a file called geolocation.js in the chapter7/js/ directory.
Geolocation JavaScript Magnets Solution Did you manage to place the magnets in the right position?
Let’s do the fun part: dropping in geolocation for browsers that support it.
Here’s what the form will look like for enabled browsers after our next set of  changes:
Once we spruce up our form, users with browsers that support geolocation will be able to use their current location to find events.
Add a slider-themed on/off switch to let users opt in to using their current location.
Add two hidden fields to hold the value of latitude and longitude from the geolocation.
Update the geolocation.js file, save it, and try out the updated Find Events page.
We've altered it to update the latitude and longitude hidden fields with the user's location data.
On error, slide the use geolocation switch back to the off position and fire its change event (which is bound to toggleLocation above)
If the user just flipped it on, disable the state filter, and disable the submit button (it will be reenabled when the geolocation is complete)
Try it out! Play with the form to get a feel for what the new JavaScript does for us.
Jim: I was just checking out the geolocation piece on some devices.
I know that the BlackBerry OS 5 browser is supposed to have geolocation, but the Use My Location switch isn’t showing up.
I don’t think we have time to chase down all of  the odds and ends and do exhaustive testing on a whole bunch of obscure devices.
What I did find is this open source, drop‑in JavaScript library that handles geolocation across a bunch of  different platforms, W3C‑compliant or no.
Jim: But doesn’t that mean we’d have to go refactor all of  our existing JavaScript?
The API for this library emulates that of  the W3C spec.
All of  the major method and attribute names are the same.
I think we only need to change a few lines and then we can stop worrying quite so much about cross‑platform compatibility.
Jim: Oh, while we’re making edits to the JavaScript…the pop‑up error for geolocation failures is ugly.
I think we should use a jQuery Mobile dialog, like the ones I built for form errors on the tartan‑creation form.
Frank: If  you try to submit the tartan form without a title, or if  you forget a color or size when you add a color‑size combo, a dialog will pop up to alert you to the errors of  your ways.
I’m going to drop in this geolocation library real quick.
You can also visit the project’s home page, if you’re curious about it, at http://bit.ly/sx7JrH.
Update the Find Events page and the geolocation JavaScript to use the cross‑platform geolocation code and show geolocation errors in a pop‑up dialog.
Update findevent.php to include the JavaScript for the new geolocation library.
Using the other pages in the dialogs directory as a guide, create a nicely worded error dialog for geolocation failures.
Next, replace the alert in the onGeoError function with a dialog pop up.
You can find examples of dialog pop ups in the js/tartanator.js file.
Here’s what your onGeoError function should look like after you convert the error from a basic JavaScript alert to a jQuery Mobile dialog.
We trust you also made the HTML page for the dialog itself!
It won’t take much to hook this thing up to some search code and sample data.
Try it out! Head to the Find Events page in your mobile browser of  choice and hit the Use My Location switch.
But this isn’t Head First JavaScript, and we didn’t want to distract you from the main tasks at.
Unless you’re lucky enough to be in the Portland, Oregon, metro area, you probably got this result on your first location‑based search:
That’s because all of  the sample data is local, and the search radius is set to 25 miles.
How’s about you add some of  your own fake events to get this thing to deliver some results?
Add a few events in the sample data that are in your neck of the woods.
Inside is a big PHP array representing fake data for events.
Add a few of your own elements to this array, using an address and lat/long pairs that are within 25 miles of you.
If you feel particularly uncomfortable with PHP, you could try just updating the address and lat/long of a few existing entries.
The latitude, longitude, and state are what is used by the search script to find matches.
Use this tool to get a lat/long pair real quick for any address: http://itouchmap.com/latlong.html.
Unless you’re near Portland, you'll get this result on your first try.
Extra-super extra credit: Can you think of how you would go about adding a range input to allow users to determine the search radius? When should it show up? If you can figure out how to add an input with a name of radius, the backend search script is already configured to use it!
This is looking great, guys! This is what I had in mind when I first envisioned a mobile web app for the Tartanator.
Nice! We’ve successfully integrated several of the features that make a mobile web app feel super: progressive enhancement, offline mode, and location awareness.
Web apps that feel natural and comfortable on mobile devices often share certain characteristics like wellconsidered progressive enhancement, a good offline mode, and location-aware features.
Starting with a baseline is a great way to reach as many users as possible, and thoughtful progressive enhancement for more powerful mobile browsers can make things really shine.
Crafting a relevant offline experience is important: mobile devices can’t be expected to have an always‑available data connection.
We can take advantage of the appCache feature in browsers by creating a cache manifest file to instruct the browser which resources to cache and make available offline.
The construction of cache manifests is straightforward on the surface, but there are a number of gotchas that you have to carefully consider.
In our cache manifest file, we can indicate which resources should be downloaded and cached for offline use (in the CACHE section) as well as those that should be requested afresh when an Internet connection is available (in the NETWORK section)
Geolocation in the browser is supported widely among modern smartphones.
Similarly to how we enhanced the tartan‑creation form for supporting browsers, we also enhanced the Find Events form to integrate geolocation, when it’s available.
Certain mobile browsers, especially on slightly older smartphones, have implementations of geolocation that are not W3C-compliant.
It might be because you need access to something not available in mobile browsers (yet)
We look forward to that shiny future when we have.
We just landed a new sponsor for the big Scottish.
We’re going to run a contest, and I want to add it to the Tartanator!
Scottish airline Loch Air has just agreed to sponsor an all-expenses-paid trip for two to Edinburgh.
As part of  the upcoming Scottish Celebration Expo in two months, Loch Air wants to run a promotional contest along with Tartans Unlimited, Ewan’s organization.
I was thinking we could have a sort of scavenger hunt.
The Tartan Hunt contest will send attendees to seek out tartans hidden at the booths of certain key sponsors.
Players are challenged to find and take a photo of  each listed tartan with their devices’ cameras; found tartans are then checked off  the list of  hidden tartans.
Once a contestant has found all of  the tartans, he or she can show the completed list and be entered to win the trip.
Access to the camera—and some other device features like audio recording, filesystem operations, network status, and contact data—isn’t available for the most part in mobile browsers.
We don’t have access to the device’s camera from mobile browsers.
What are we going to do? Do we have to.
Frank: We obviously don’t have the time or budget to rewrite the Tartanator as a native app for a bunch of  platforms and also add the new features Ewan wants.
Jim: Does that mean we have to walk away from this work? That would be too bad.
Joe: A hybrid application is a native application written with web technologies.
Because it’s native, we can get at device capabilities like the camera, but the code itself  is written with standard web stuff, so we can share the code across several platforms.
Frank: But if  it’s web‑based, and those features aren’t available in the browser, how does that work?
Joe: There are several frameworks and platforms that provide bridges between web apps and native code.
They take our web app, chew on it a bit, and then spit out packaged apps—native ones—for various platforms.
They take care of  the various bits and bobs for us so we can just use the web standards we know.
Jim: Should we convert the Tartanator to one of  these hybrid apps, then?
Joe: I don’t think we have the time to wrap the entire app natively and test it effectively.
Given the timeline, what do you think about suggesting that we create a native app just for the contest?
And we don’t have to risk making hurried changes to the Tartanator web app.
It has a bit of  cachet—attendees show up and can download a special app just for the event and the contest.
Joe, if  you think we can get the hybrid app thing to work on several platforms, let’s float the idea with Ewan.
Many device capabilities, like the camera, are not accessible from mobile browsers.
This is slowly changing for the better, but there are still a number of things we can’t get at from the browser.
How do hybrid apps work? You write your code using standard web technologies like HTML5, CSS, and JavaScript—the same way websites have always been built.
A framework or platform then acts as a bridge, providing a common API for you to use to access features natively on the various device platforms.
It bridges the gap between your JavaScript and the device’s native code (for each platform it supports) and produces apps for various platforms.
The framework bridges the gap between web code and the target OS’s native capabilities…
PhoneGap is an open source HTML5 platform that allows you to create native apps for several mobile operating systems using the hybrid approach that we’ve been talking about.
You write your code like you’re used to, using HTML, CSS, and JavaScript.
PhoneGap provides the bridge between that and native code via a consistent, cross‑platform JavaScript API.
But don’t worry: Adobe has already taken steps to make sure PhoneGap remains open source by giving the rights to PhoneGap to the nonprofit Apache Software Foundation.
The newly minted Apache Cordova project will make sure that the PhoneGap codebase stays open source going forward.
PhoneGap Build PhoneGap Build is a web‑based service that lets you compile in the cloud for several platforms at once.
It takes a bit of  the drudgery out of  the build process by allowing you to skip installing at least some of  the SDKs, plug‑ins, IDEs, and whatnot for each platform you want to support.
Whereas with standard PhoneGap development, you’d do your own compiling and building, with PhoneGap Build you upload a zip file (or pull from a code repository) and it does the rest.
Ewan has agreed to the Tartan Hunt contest companion app idea.
We’re going to show you how to build a hybrid Android app using PhoneGap Build.
If  you don’t have an Android device, not to worry.
We’ll show you how to build and install the app for a real‑life device and for emulated virtual devices.
PhoneGap supports up to seven platforms, but in this chapter we’re going to use PhoneGap Build, which supports Apple iOS, Android, BlackBerry, WebOS, and Symbian.
We chose Android as our example platform for a few reasons.
But, also, building and deploying iOS apps onto devices requires membership in the iOS Developer program ($99/year)
Android also has a freely available SDK that supports emulating many virtual devices across different versions of the Android OS.
With Xcode, the development toolset needed for iOS development, you’re out of  luck if  you don’t have a Mac.
How come we’re singling out Android for this project? What about iOS and other platforms?
You don’t have to be a JavaScript genius to make it through this chapter, but there’s no getting around the fact that today’s web app development involves JavaScript.
To communicate with native functionality such as the camera APIs using PhoneGap, we need to use a client-side technology—and JavaScript is obviously the right guy for this job.
If  you haven’t done it yet, hold everything and visit Appendix iv.
You need to have the right stuff  installed and an understanding of  how to install and uninstall apps on virtual and real devices before moving on to the next parts of  the chapter.
Q: What other tools, products, or services are there for building hybrid apps?
A:Two of the best‑known hybrid development alternatives are Appcelerator Titanium and the forthcoming Sencha Touch 2 product.
See http://phonegap.com/about/features for a list of which of its features are supported on which versions of which platforms.
At the time of this writing, it does not support Windows Phone 7 or Bada.
PhoneGap—or, as it is known going forward, Apache Cordova—is open source and free.
Its free variant allows developers to have one private app and as many public apps as they’d like.
We’ll be using this free service to build the Tartan Hunt app.
PhoneGap Build’s other levels of service increase the number of private apps and project collaborators.
Q: Why did I have to install the Android SDK? A: We won’t be compiling or building the Tartan Hunt AppPhoneGap Build will do that for us—but we still need to be able to install it and test it on an emulator, a device (if you have an Android device), or both.
To do that, we need some of the tools provided by the SDK.
We don’t, however, need to install the Eclipse IDE, which we’d likely need to do if we were developing and building the code ourselves.
Q: Why is it that some things aren’t accessible in the web browser in the first place?
A: There are several reasons that you can’t do anything and everything from the browser on mobile devices.
Giving the browser access to things like the filesystem or the user’s contact list is something that has to be done carefully, with a lot of consideration about how to keep things properly sandboxed.
In addition, some of the proposed standards for these features are new or incomplete, or have multiple variants vying for adoption.
As these things get ironed out, expect to see some bumps along the way with conflicting or inconsistent support in browsers.
But here’s to a standardized, device‑API‑rich future! Let’s try to enjoy the ride!
If you have a device that is not Android but is one of PhoneGap Build’s supported platforms, or if you have an Apple Developer Account, we encourage you to try building and testing the examples in this chapter on your platform.
Our test kitchen has run the Tartan Hunt app successfully on various flavors of Android and iOS.
But you know, it’d be great to know what exactly it is we’re.
How will the app work? The landing page of  our app will display contest instructions and a list of  tartans to find.
Tapping on an item in the list goes to a display with more information about the vendor at whose booth the tartan can be found.
We used a collapsible element so that the instructions can be hidden.
Zip up the current HTML, CSS, and images; build the app; and install it on an Android device or emulator.
Add the ability for players to mark which tartans they’ve spotted.
Add the ability for players to save photos of  the tartans they’ve spotted.
In our completed app, clicking the “I found it!” button will launch the device’s camera, and the player can take a snapshot of  the discovered tartan.
The photo is displayed on the detail page and marked off  as “found” in the list on the landing page.
We already have the basic HTML layout, CSS, and images.
Now we need to make them do something and build a native Android app using PhoneGap Build.
We’re using jQuery Mobile again for this project, so the overall look will be generally consistent with the Tartanator.
We’re already organized for PhoneGap Build The structure of  our starting point is now almost ready to drop into PhoneGap Build.
PhoneGap Build projects have a structure based on the W3C web widget specification.
Web widgets are encapsulated web apps that are meant as standalone client applications.
In their most basic form, they consist of  at least one start file (in our case, index.html) and a configuration file (in XML)
You can add any number of  files that your app will need to the package—things like images and CSS and JavaScript and whatnot.
But we need to create a configuration file to give PhoneGap Build some needed details about our app.
PhoneGap Build will look for a file in our project called config.xml.
Here’s the simplified structure of  the content <div> in index.html.
Remember that a PhoneGap Build project is either built from a zip file or pulled from a code repository.
It doesn’t matter what the resulting file is called, as long as it is a zip archive with a .zip extension.
You can use http://hf-mw.com if you don’t have your own site.
Let’s add icons! These show up on the user’s home screen.
Find the rest in the images directory and add them as well.
But don’t lose your identity! We expect you to use your own name and stuff.
PhoneGap Build will give the right icon to the right devices…
Choose the zip file you created from the chapter8 directory.
After you upload the zip file, PhoneGap Build will queue your app for building.
You should see Download buttons for each platform for which the app was successfully built.
When the build process is done, you’ll see a Download button appear, rather like this.
Earlier versions have somewhat finicky emulators, especially for the camera stuff we’ll do later.
You should now be able to see the Tartan Hunt app in the application screen of your device or emulator.
Ready, aim, fire! The process for installing the app is the same whether you’re deploying it virtually or to a real device.
Open up a terminal window (Mac or Linux) or type cmd in the Start menu’s Search box (Windows) to get a command line, and cd to the directory where you downloaded the Android APK file.
Install on a real device If  you have a real‑life Android device, woot! Connect your Android device to your computer’s USB port.
Don’t forget! Your (real) device must be attached or your emulator fully booted before you run this command.
We talk about this in more detail in Appendix iv.
The landing screen of the app in a version 2.3.3 emulated Android device.
One of the nested list subpages on an Android Nexus One device.
The Tartan Hunt icon is showing up on this Android’s application screen.
The landing page with the instructions collapsed on an emulated Android device.
The landing page on an iOS device—yep, if you have a signing key, it works!
But each tartan I touch seems to take me to a separate page.
Hey, what about BlackBerry? If  you visit your dashboard on PhoneGap Build, you might see something like this:
You’ll also note that it uses the title of  the parent list element (in our case, the vendor’s booth number) as the title of  the nested list’s page.
To make the PhoneGap Build Tartan Hunt app work on BlackBerry OS, you would need to alter jQuery Mobile’s icon filenames and update any reference to them in jQM’s source code.
While this wouldn’t take too long, it does mean “hacking” jQuery Mobile’s core and introduces a maintenance burden.
For purposes of brevity and sanityand because Ewan has expressed diffidence about supporting the BlackBerry platform, we're not going to address this here…
We could rectify the iOS situation by providing a signing key (if we had one)
What’s with the frowny face for BlackBerry? Well, sadly, there’s a problem currently with the combination of  PhoneGap Build, BlackBerry, and any filename with a hyphen in it.
Several of  the jQuery Mobile files we need have hyphens in their filenames.
You need to uninstall the app before you can reinstall it after making changes.
Each time you rebuild the app on PhoneGap Build and need to reinstall it on a device or emulator, you need to uninstall first.
Run this command when the device is attached via USB, or when the emulator you want to uninstall it from is running.
Let’s add a splash screen so that users don’t have to look at a boring blank screen while the app loads.
Update config.xml, zip up chapter8 again, rebuild the app on PhoneGap Build, and reinstall it to see the new splash screen take effect.
Look for the “Update code” button to upload your updated zip file.
Not so tricky, huh? You can use your web dev chops to build native stuff without too much hassle!
Zip up the current HTML, CSS, and images; build the app; and install it on an Android device or emulator.
Add the ability for players to mark which tartans they’ve spotted.
Add the ability for players to save photos of  the tartans they’ve spotted.
Now let’s make it do what it’s supposed to do.
First, we want the app to be able to remember which tartans the user has found.
When players click the “I found it!” button, we need the app to keep a record of  that.
First, let’s build the ability to keep track of which tartans users say they have found.
Then we’ll come back in a bit and enhance the app to prompt users to take a photo.
How am I going to get the app to “remember” which tartans the users.
Fortunately, there’s a way to do this in JavaScript using an HTML5 web standard called localStorage.
It’s already supported in the default mobile browsers of  all of  the platforms we’re targeting with PhoneGap Build.
It’s not supported by BlackBerry before OS 6, but we're not supporting BlackBerry currently.
Here’s the end of the config.xml file, with splash screens added.
The two sizes allow us to have a bigger version for devices with higher resolution.
We can store simple data on the client—in our case, which tartans have been found—without much fuss using the localStorage API in the browser.
What makes localStorage so special? In the past, developers have often relied on HTTP cookies for data that needs to be kept on the client.
Every time the client makes a request to a server, the entire contents of  all cookies for that domain are transferred.
Also, cookies are notoriously convoluted to work with using JavaScript.
Plus, there is some data we might want to stick on the client that the server just doesn’t need to know about (or maybe, as in our case, there is no server)
It gives us methods to set, get, and clear out data—and that’s about it.
Our app has a splash screen now! This is what it looks like on an iPod Touch.
What can localStorage do for us? When a player clicks the “I found it!” button, we can add an entry to localStorage.
And we check for data in localStorage when we want to see which of  the tartans the contestant has already found.
Meet the getter and the setter There are two methods on localStorage that provide most of  its utility.
Then, later, we can ask for that value by using its key: The key for which we’d like the stored data, please!
If a value is found for key, it is assigned to storedValue.
In our case, when a user found, say, the Douglas tartan at a vendor’s booth and indicated this by tapping the “I found it!” button, we could do something like:
Then if  we wanted to check if  he’d already found the Douglas tartan, we could ask localStorage:
Update the display to show which tartans have been found.
Your job is to add the comment magnets above the lines of code they refer to.
You can only use each magnet once, but you might end up with some left over!
Add a click handler for the "I found it!" buttons.
We're turning off the page transitions because they are slow on some Android devices.
You can see that we're adding a button to let the user reset and start the game over.
Hey! We didn’t tell you about the clear() method yet—did you figure it out? It does what it sounds like: clears all keys and their associated values from localStorage.
We only add the click handler for browsers that support localStorage.
Check out what a browser supports We talked a bit about client‑side feature detection way back in Chapter 2, and that’s what we’re doing again here inside of  the initDevice function.
Update the display to // show which tartans // have been found.
We perform some client-side feature detection here to make sure localStorage is supported before adding the click handler and showing the reset button.
Translation: it gets executed when the page’s DOM is done being initialized by jQuery.
By only adding click handlers and the reset button if localStorage is supported, we are in effect setting a minimal bar for supported browsers, Chapter 4 style.
Can you think of why this might be OK? Can you also think why it might not be in some cases?
Client‑side feature detection can be quite simple, like this example, but there are also JavaScript libraries that provide detection for all sorts of  features.
Modernizr (http://modernizr.com) is a widely used example of  such a tool.
But wait…the story isn’t over yet The leftover comment magnets give us a clue about what else we need to do here.
We’re storing found tartans, and providing a way to clear them all out, but the interface doesn’t change.
We need to write some code that updates the display so players can see which tartans they’ve found.
We also did feature detection in Chapter 5 using WURFL device capability data.
Use a function to show which tartans are found Sounds like we need another function in our JavaScript—one that can update the way the page looks depending on which tartans have been found.
We’re going to call our new function refreshTartans because it updates the appearance of  the tartan listings and the detail screens depending on which tartans have been found.
We can use the id attribute of  each of  those lists to determine a key to look for in localStorage.
If  there is a value of  any sort for that key, that tartan has been found and we need to update the interface to reflect that.
Toggle the visibility and classes on some elements to reflect whether they’ve been found or not.
Remember, jQuery Mobile builds on top of jQuery, so we have all of jQuery’s methods available to us.
Add the completed magnets code and the refreshTartans function to scripts/app.js.
See if you can figure out where in the code the three calls to refreshTartans need to go.
We convert that to a Boolean value (true or false) so we can use it with jQuery’s toggle and toggleClass methods.
We need a real Boolean value (not just the string ‘true' or null) to use these methods.
Similarly, toggle will show the <li> element indicated if  it’s passed a Boolean with a true value.
We’re doing something a bit clever here and giving it the opposite of  the current value of  isFound (that’s what !isFound does)
Why, you might ask? Well, we want to hide that <li> if  the tartan’s been found (that is, isFound is true)
That’s the <li> that contains the “I found it!” button.
We don’t need it to show up anymore if  the tartan has been found.
The toggle and toggleClass methods toggle and toggleClass are jQuery methods.
Here are the three places refreshTartans needs to be called in app.js.
Edit app.js to integrate the changes from the last several pages.
Save the file and preview Tartan Hunt’s index.html in a desktop web browser (this should work just fine)
Try clicking on some tartans and their “I found it!” buttons.
You should see found tartans and their detail pages receive some CSS style changes (things will turn green)
If you’re having trouble, use the Web Inspector tool in Chrome or Safari, or the Error Console in Firefox, to review possible JavaScript errors.
You’ll need to replace your app.js with this file if you want to use it.
Go ahead and zip up the contents of the chapter8 directory again and rebuild on PhoneGap Build.
Install again on a device or emulator and try it out!
And if you’re still using Internet Explorer version 7, you’re out of luck there.
Q: Do the keys have to have certain names? A: Both keys and the values you assign to them have to be strings.
Q: How much data can I store? A: The W3C localStorage Specification is sort of adorably vague about this.
Some browsers, like Safari, prompt users to allocate more space if the allotment is used up.
Q: Can other sites or apps access my localStorage data?
Part of the spec is concerned with security and mandates certain things that prevent other origins (very rough translation: other sites) from accessing any localStorage data other than their own.
Q: You said that you can only store strings in localStorage.
But earlier you mentioned that you can use localStorage to store images.
Browser support for data‑URIs (that’s what this is called) is pretty decent, with the big exception of Internet Explorer.
Read more about it in this article by Nicholas Zakas: http://bit.ly/sWe7HS.
Q: Wait a minute! I was just looking at the code again and noticed we're adding a back button on the nested list pages.
That doesn’t make sense for Androids—most Android devices have hardware back buttons already.
The back button doesn’t just feel awkward for Android, it actually closes the PhoneGap Build–generated app! That is not good.
We’ll come back to this in just a bit and fix it.
Q: If localStorage is available in the browser to us, why are we using PhoneGap Build at all? Can’t we just make this a web app?
Chapter 1: Getting Started on the Mobile Web: Responsive Web Design Get on the mobile bandwagon Something odd happened on the way to the pub If mobile phone web browsers are so great… What’s so different about the mobile web? Responsive Web Design An example of a responsively designed site Different CSS in different places CSS media queries The current structure of the Splendid Walrus site Analyze the current CSS What needs to change? Identify the CSS that needs to change Steps to creating the mobile-specific CSS Ta-da! Mobile-specific CSS The rest of our structural CSS Put it together What’s wrong with a fixed‑width layout, anyway? How is fluid better? Go fluid The fluid formula Continue your fluid conversion Context switching What’s wrong with this picture? Fluid images and media Are we there yet? Details, details Remember to be responsible That’s a responsive site! Responsive design is also a state of mind.
Chapter 4: Deciding Whom to Support: What devices should we support? How do you know where to draw the line? Step away from the keyboard for a second Things you don’t support vs.
Chapter 5: Device Databases and Classes: Get with the group A panic button for freaked-out students The button is for mobile phones only Mobile device data sources to the rescue Meet WURFL WURFL and its capabilities WURFL: Clever API code We can build an explore page, too An explore page: Setting up our environment A good start! A quick one-two punch to improve our explore page Put capabilities to work Ask WURFL the right questions Initialize the device and get the info ready Is this thing mobile? Danger, Will Robinson! Make the page a bit smarter with WURFL The panic button: For phones only Herding devices Device classes The picture just got a lot bigger Evaluate the home page wearing mobile-tinted glasses Group requirements into multiple mobile flavors Rounding out our device classes Let’s get this show on the road Get acquainted with the matching function What’s going on in that switch statement? Use the matching function to test capabilities The home stretch Well, let’s see…how’d it go? Fill in the gaps in the device class tests Make something actually happen with device classes Always tread with care and come prepared We need a bigger safety net A stitch in time.
Chapter 8: Build Hybrid Mobile Apps with PhoneGap Tartan Hunt: Going native Opportunity knocks again How do hybrid apps work? Bridge the web-native gap with PhoneGap Get acquainted with PhoneGap Build How will the app work? Keep track of discovered tartans Anatomy of the Tartan Hunt project Download your apps Choose your adventure Nice work, hotshot! Who’s seen what? Store found tartans What can localStorage do for us? Check out what a browser supports Use a function to show which tartans are found The toggle and toggleClass methods You found a tartan, eh? Prove it! Rope in PhoneGap to take pictures PhoneGap is almost ready for its close-up Now we’re ready for the mediaCapture API How will we handle the success? It always looks a bit different in real life It’s just a bit anonymous We nailed it!
Chapter 9: How to Be Future Friendly: Make (some) sense of the chaos Now what? It’s complicated A future-friendly manifesto If you can’t be future proof, be future friendly App today, web page tomorrow It’s a long journey: Here are some guideposts Look toward the future.
Appendix i: Leftovers: The top six things (we didn’t cover) #1
Appendix iii: Install WURFL: Sniffing out devices Who’s got the brains? And who’s got the brawn? Getting the two to work together A bit of filesystem housekeeping Take note!
Appendix iv: Install the Android SDK and Tools: Take care of the environment Let’s download the Android SDK Get the right tools for the job Hit the Install button and go make some coffee Do virtual devices dream of electric sheep? Create a new virtual device Let ’er rip! Apps on, apps off Find the right PATH.
