For our Servlet/JSP classes, we bought more than ten books, without finding any one really satisfying our teaching needs...
Until we found the pedagogical gem you now hold in your hands! Head First books simply make us better teachers...
There is no better introduction into the Servlet technology on the market than Head First Servlets & JSP.
Head First Servlets and JSPs is the first book I recommend to developers, both new and experienced, who are interested in learning to do more with Java EE.
I thought I knew JSP/Servlets before picking up Head First, but later after reading the book I really knew that I know JSP/Servlets.
When I read my first book from the Head First series, I realized how much fun learning a technology or methodology can be.
It makes you glide through the learning process so easily, and it makes the learning stick to the walls of  your brains.
I picked this one when I was tired of  reading big books for the SCWCD exam...After reading this book once, not only did I understand everything, but it really stayed there.
I really really recommend this book to all the aspirants of  SCWCD.
Java technology is everywhere—in mobile phones, cars, cameras, printers, games, PDAs, ATMs, smart cards, gas pumps, sports stadiums, medical devices, Web cams, servers, you name it.
Head First Design Patterns manages to mix fun, belly laughs, insight, technical depth and great practical advice in one entertaining and thought provoking read.
Head First Object-Oriented Analysis and Design is a refreshing look at the subject of  OOA&D.
What sets this book apart is its focus on learning.
There are too many books on the market that spend a lot of time telling you why, but do not actually enable the practitioner to start work on a project.
I strongly believe that the future of  software development practice will focus on the practitioner.
The book does a good job of  capturing that entertaining, visually oriented, ‘Head First’ writing style.
But hidden behind the funny pictures and crazy fonts is a serious, intelligent, extremely well-crafted presentation of  OO Analysis and Design.
This book has a strong opinion of  how to design programs, and communicates it effectively.
I love the way it uses running examples to lead the reader through the various stages of  the design process.
I just finished reading HF OOA&D, and I loved it! The book manages to get across the essentials of object-oriented analysis and design with UML and use cases, and even several lectures on good software design, all in a fast-paced, easy to understand way.
Head First Software Development is a whimsical but very thoughtfully designed series of  information diagrams and clever illustrations meant to accurately and clearly convey information directly into YOUR brain.
Head First Software Development teaches many valuable lessons that will help anyone deliver quality software on time and on budget.
Following the core principles taught in this book will help keep your project on track from start to finish.
Wouldn’t it be dreamy if there were a Servlets book that was more stimulating than.
O’Reilly Media books may be purchased for educational, business, or sales promotional use.
Many of  the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and O’Reilly Media, Inc., was aware of  a trademark claim, the designations have been printed in caps or initial caps.
While every precaution has been taken in the preparation of  this book, the publisher and the author assume no responsibility for errors or omissions, or for damages resulting from the use of  the information contained herein.
This book is dedicated to whoever decided that the EL implicit object for a context param should be named initParam…
Kathy has been interested in learning theory and the brain since her days as a game designer (she wrote games for Virgin, MGM, and Amblin’) and an AI developer.
More recently, she’s been a master trainer for Sun Microsystems, teaching Sun’s Java instructors how to teach the latest Java technologies, and developing several of  Sun’s certification exams, including the SCWCD.
Together with Bert Bates, she has been actively using the Head First concepts to teach thousands of  developers.
Bert is a longtime software developer and architect, but a decade-long stint in artificial intelligence drove his interest in learning theory and technologybased training.
He spent the first decade of  his software career traveling the world to help broadcasting clients like Radio New Zealand, the Weather Channel, and the Arts and Entertainment Network (A&E)
He’s currently a member of  the development team for several of Sun’s Java Certification exams, including the new SCWCD.
Bert is a long-time, hopelessly addicted go player, and has been working on a go program for way too long.
Java may finally be a language expressive enough for him to finish the project.
He’s a fair guitar player and is now trying his hand at banjo.
His latest adventure is the purchase of  an Icelandic horse which should give his training skills a new challenge...
Bryan has over twenty years of software development experience including time at NASA developing advanced automation software using AI techniques.
He also worked for a consulting firm developing custom OO business apps.
He was also the lead designer of both the original and new version of  the SCWCD exam.
Kathy has been interested in Kathy has been interested in KathyKathy.
Here you are trying to learn something, while here your brain is doing you a favor by making sure the learning doesn’t stick.
How many GUI apps do you know that are used by millions of users worldwide? As a web app developer, you can free yourself from the grip.
When a request comes in, somebody has to instantiate the servlet or at least allocate a thread to handle the request.
Somebody has to manage the life, death, and resources of the servlet.
It’s time to get your hands dirty writing an HTML form, a servlet controller, a model (plain old Java class), an XML.
When a request A servlet’s job is to take a client’s request and send back a response.
The request might be simple: “get me the Welcome page.” Or.
In today’s modern web app, many components work together to accomplish a goal.
How do you make information thread-safe? Your job may depend on the answers.
As soon as they send you a response, they forget who you are.
They don’t remember what you’ve requested in the past, and they don’t.
The Container looks at your JSP, translates it into Java source code, and compiles it into a full-fl edged Java servlet class.
But you’ve got to know what happens when the code you write in the JSP.
You can write Java code in your JSP, but should you? And if.
You’ll learn how, why, and what to write in your JSP.
Do your web page designers really have to know Java? Do they expect server-side Java programmers to be, say, graphic designers? And even.
Custom tags are powerful9 Sometimes you need more than EL or standard actions.
What if you want to loop through the data in an array, and display one item per row in an HTML.
They’re as easy to use in a JSP as standard.
Even better, someone’s already written a pile of the ones you’re most likely to.
When even JSTL isn’t enough...10 Sometimes JSTL and standard actions aren’t enough.
When you need something custom, and you don’t want to go back to scripting, you can write your.
That way, your page designers can use your tag in their pages, while.
Deploying your web app11 Finally, your web app is ready for prime time.
Your pages are polished, your code is tested and tuned, and your deadline was two weeks ago.
But where does everything go? So many directories, so many rules.
Keep it secret, keep it safe12 Your web app is in danger.
You don’t want the Bad Guys listening in to your online store transactions, picking off credit.
You don’t want the Bad Guys convincing your server that they’re actually.
Lisa in engineering makes three times as much as he does?
The power of filters13 Filters let you intercept the request.
And if you can intercept the request, you can also control the response.
It never knows that someone stepped in between the client request and the Container’s invocation.
Lisa in engineering makes three times as much as he does?
If you’re just starting to develop web applications in Java, you’re lucky.
You get to exploit the collective wisdom of the tens of thousands of developers who’ve been down that road and got the t-shirt.
J2EE-specifi c and other design patterns, you can can simplify your code and your life.
And the most signifi cant design pattern for web apps, MVC, even has a wildly popular.
You owe it to yourself to take advantage of everyone else’s work so that you can spend.
The tone, topics, and diffi culty level are all virtually identical to the real exam.
I can’t believe they put that in a programming book!
So, why DID they p ut that in a program.
Do you know how to program in Java (you don’t need to be a guru)?
Do you like to tinker – do you learn by doing, rather than just reading? Do you want to learn, understand, and remember servlets and JSPs, and pass the SCWCD for Java EE 1.5 exam?
Do you prefer stimulating dinner party conversation to dry, dull, academic lectures?
Are you completely new to Java? You don’t need to be an advanced programmer, but if you don’t have any experience, go pick up a copy of Head First Java, right now, and then come back to this book.
Are you a kick-butt Java programmer looking for a reference book?
Are you afraid to try something different? Would you rather have a root canal than mix stripes with plaid? Do you believe that a technical book can’t be serious if Java components are anthropomorphized?
Are you a Java EE veteran looking for ultra-advanced server techniques, server-specific how-to’s, enterprise architecture, and complex, robust, real-world code?
It was built that way, and it helps you stay alive.
So what does your brain do with all the routine, ordinary, normal things you encounter? Everything it can to stop them from interfering with the brain’s real job—recording things that matter.
It doesn’t bother saving the boring things; they never make it past the “this is obviously not important” filter.
How does your brain know what’s important? Suppose you’re out for a day hike and a tiger jumps in front of  you, what happens inside your head and body?
This must be important! Don’t forget it! But imagine you’re at home, or in a library.
Or trying to learn some tough technical topic your boss thinks will take a week, ten days at the most.
It’s trying to make sure that this obviously non-important content doesn’t clutter up scarce resources.
Resources that are better spent storing the really big things.
And there’s no simple way to tell your brain, “Hey brain, thank you very much, but no matter how dull this book is, and how little I’m registering on the emotional Richter scale right now, I really do want you to keep this stuff  around.”
We think of a “Head First” reade r as a learner.
If  you really want to learn, and you want to learn more quickly and more deeply, pay attention to how you pay attention.
Most of  us did not take courses on metacognition or learning theory when we were growing up.
We were expected to learn, but rarely taught to learn.
But we assume that if  you’re holding this book, you really want to learn how to build web applications in Java, and pass the SCWCD exam.
And you probably don’t want to spend a lot of  time.
If  you want to use what you read in this book, you need to remember what you read.
To get the most from this book, or any book or learning experience, take responsibility for your brain.
The trick is to get your brain to see the new material you’re learning as Really Important.
Otherwise, you’re in for a constant battle, with your brain doing its best to keep the new content from sticking.
I wonder how I can trick my brain into remembering.
So just how DO you get your brain to treat servlets like it’s a hungry tiger? There’s the slow, tedious way, or the faster, more effective way.
You obviously know that you are able to learn and remember even the dullest of  topics if  you keep pounding the same thing into your brain.
With enough repetition, your brain says, “This doesn’t feel important to him, but he keeps looking at the same thing over and over and over, so I suppose it must be.”
The faster way is to do anything that increases brain activity, especially different types of  brain activity.
The things on the previous page are a big part of  the solution, and they’re all things that have been proven to help your brain work in your favor.
For example, studies show that putting words within the pictures they describe (as opposed to somewhere else in the page, like a caption or in the body text) causes your brain to try to makes sense of  how the words and picture relate, and this causes more neurons to fire.
More neurons firing = more chances for your brain to get that this is something worth paying attention to, and possibly recording.
A conversational style helps because people tend to pay more attention when they perceive that they’re in a conversation, since they’re expected to follow along and hold up their end.
The amazing thing is, your brain doesn’t necessarily care that the “conversation” is between you and a book! On the other hand, if  the writing style is formal and dry, your brain perceives it the same way you experience being lectured to while sitting in a roomful of  passive attendees.
Here’s what WE did: We used pictures, because your brain is tuned for visuals, not text.
As far as your brain’s concerned, a picture really is worth a thousand words.
And when text and pictures work together, we embedded the text in the pictures because your brain works more effectively when the text is within the thing the text refers to, as opposed to in a caption or buried in the text somewhere.
We used redundancy, saying the same thing in different ways and with different media types, and multiple senses, to increase the chance that the content gets coded into more than one area of  your brain.
We used concepts and pictures in unexpected ways because your brain is tuned for novelty, and we used pictures and ideas with at least some emotional content, because your brain is tuned to pay attention to the biochemistry of  emotions.
That which causes you to feel something is more likely to be remembered, even if  that feeling is nothing more than a little humor, surprise, or interest.
We used a personalized, conversational style, because your brain is tuned to pay more attention when it believes you’re in a conversation than if  it thinks you’re passively listening to a presentation.
We included more than 40 activities, because your brain is tuned to learn and remember more when you do things than when you read about things.
We used multiple learning styles, because you might prefer step-by-step procedures, while someone else wants to understand the big picture first, and someone else just wants to see an example.
But regardless of  your own learning preference, everyone benefits from seeing the same content represented in multiple ways.
We include content for both sides of  your brain, because the more of  your brain you engage, the more likely you are to learn and remember, and the longer you can stay focused.
Since working one side of  the brain often means giving the other side a chance to rest, you can be more productive at learning for a longer period of  time.
And we included stories and exercises that present more than one point of  view, because your brain is tuned to learn more deeply when it’s forced to make evaluations and judgments.
We included challenges, with exercises, and by asking questions that don’t always have a straight answer, because your brain is tuned to learn and remember when it has to work at something.
Think about it—you can’t get your body in shape just by watching people at the gym.
But we did our best to make sure that when you’re working hard, it’s on the right things.
That you’re not spending one extra dendrite processing a hard-to-understand example, or parsing difficult, jargon-laden, or overly terse text.
In stories, examples, pictures, etc., because, well, because you’re a person.
And your brain pays more attention to people than it does to things.
We assume that if  you’re going for a PhD in JSPs, this won’t be your only book.
These tips are a starting point; listen to your brain and figure out what works for you and what doesn’t.
Your brain works best in a nice bath of  fluid.
Dehydration (which can happen before you ever feel thirsty) decreases cognitive function.
Take the final Coffee Cram mock exam only AFTER you finish the book.
If  you take the exam too soon, you won’t get a clear picture of  how ready you are for the exam.
Wait until you think you’re close to ready, and then take the exam.
And be sure you only give yourself 180 minutes—the length of  time you’ll have to take the real SCWCD exam.
Groaning over a bad joke is still better than feeling nothing at all.
If  you find yourself  starting to skim the surface or forget what you just read, it’s time for a break.
Once you go past a certain point, you won’t learn faster by trying to shove more in, and you might even hurt the process.
If  you’re trying to understand something, or increase your chance of  remembering it later, say it out loud.
Better still, try to explain it out loud to someone else.
You’ll learn more quickly, and you might uncover ideas you hadn’t known were there when you were reading about it.
Part of  the learning (especially the transfer to long-term memory) happens after you put the book down.
Your brain needs time on its own, to do more processing.
If  you put in something new during that processing time, some of  what you just learned will be lost.
They’re not optional sidebars—they’re part of  the core content! Don’t skip them.
We put them in, but if  we did them for you, that would be like having someone else do your workouts for you.
There’s plenty of evidence that physical activity while learning can increase the learning.
The more you understand, the less you have to memorize.
When the book asks you a question, don’t just skip to the answer.
The more deeply you force your brain to think, the better chance you have of learning and remembering.
Here’s what YOU can do to        bend your brain into submission.
Besides your brain and a pencil, you need Java, Tomcat 5, and a computer.
You do not need any other development tool, such as an Integrated Development Environment (IDE)
We strongly recommend that you not use anything but a basic editor until you complete this book.
A servlet/JSP-aware IDE can protect you from some of  the details that really matter (and that you’ll be tested on), so you’re much better off  developing the bean code completely by hand.
Once you really understand what’s happening, you can move to a tool that automates some of  the servlet/JSP creation and deployment steps.
If  you already know how to use Ant, then after chapter 3, you can switch to using it to help you deploy, but we don’t recommend using Ant until after you’ve completely memorized the web app deployment structure.
Scroll down to the “Binary Distributions” section and download the version of your choice.
If you do not know, then select the “Core” distribution; it is all you need.
For Windows, that means double-clicking the install .exe fi le and following the installer wizard instructions.
For the others, unpack the install fi le into the place on your hard drive where you want Tomcat to be.
To make it easier to follow the book instructions, name the Tomcat home directory “tomcat” (or set up a “tomcat” alias to the real Tomcat home)
You should have a copy of the  specs, although you do not need them in order to pass the exam.
Go to the JSR page and click on the Download Page for the fi nal release.
Test Tomcat by launching the tomcat/bin/startup script (which is startup.sh) for Linux/Unix/OS X.
Point your browser to: http://localhost:8080/ and you’ll see the Tomcat welcome page.
We deliberately stripped out everything that might get in the way of  learning whatever it is we’re working on at that point in the book.
And the fi rst time through, you need to begin at the beginning, because the book makes assumptions about what you’ve already seen and learned.
Although there’s a good chance you already know UML, it’s not covered on the exam, and it’s not a prerequisite for the book.
So you won’t have to worry about learning servlets, JSP, JSTL, and UML at the same time.
We don’t cover every single picky detail from the spec.
The exam is pretty detailed, though, and so are we.
But if  there’s a detail in the spec that’s not covered in the exam, we don’t talk about it unless it’s important to most component developers.
What you need to know to begin developing web components (servlets and JSPs), and what you need to pass the exam, overlap about 85%
We cover a few things not on the exam, but we point them out so you don’t have to try to memorize them.
We created the real exam, so we know where you should focus your energy! If  there’s a chance that this one picky detail might be on one question on the exam, but the effort to learn it isn’t really worth it, we might skip it, or cover it only very lightly, or only in a mock exam question.
The exercises and activities are not add-ons; they’re part of  the core content of  the book.
Some of  them are there to help with memory, some for understanding, some to help you apply what you’ve learned.
One thing that’s distinctly different in a Head First book is that we want you to really really really get it.
And we want you to fi nish the book remembering what you’ve learned.
Most information or reference books don’t necessarily have retention and recall as a goal, but in this book you’ll see some of  the same concepts come up more than once.
The code examples are as lean as possible Our readers tell us that it’s frustrating to wade through 200 lines of  code looking for the two lines they need to understand.
Most examples in this book are shown within the smallest possible context, so that the part you’re trying to learn is clear and simple.
Don’t expect the code to be robust, or even complete.
That’s your assignment for after you fi nish the book.
The book examples are written specifi cally for learning, and aren’t always fully functional.
Some of  the code examples for the book are available at www.headfi rstlabs.com.
How many questions? You’ll get 69 questions when you take the exam.
Not everyone gets the same 69 questions; there are many different versions of  the exam.
But everyone gets the same degree of  difficulty, and the same balance of  topics.
On the real exam, expect to see at least one question from each exam objective, and there are a few objectives where you’ll get more than one question.
How much time do I get to complete the exam? You get three hours (180 minutes)
Most people don’t find this to be a problem, because these questions don’t lend themselves to long, complicated, puzzles.
Most questions are very short and are multiple-choice, and you either know the answer or you don’t.
What are the questions like? They are almost exactly like our mock exam questions, with one big difference—the real exam tells you how many answers are correct, where we do not.
You will see a handful of  drag-and-drop questions, however, that we can’t do here.
But drag-and-drop questions are just the interactive way of  matching one thing to another.
When you finish answering all of  the questions, hold your mouse cursor over the done button until you have the courage to click it.
Because in, like, six nanoseconds, you’ll know whether you passed (of  course you will)
Why don’t the mock exams in the book tell you how many options to choose for the correct answer? We want our exams to be just a little more difficult than the real exam, to give you the most realistic picture of  whether you’re ready to take the exam.
People tend to get higher scores on book mock exams because they retake the same test more than once, and we don’t want you to get a false picture of  your readiness to take the exam.
Readers have reported that the score they get on the real exam is very close to the score they get on the mock final exam in this book.
What do I get after I take the exam? Before you leave the testing center, be sure to get your exam report.
It shows a summary of  your score in each major area, and whether you passed or failed.
Keep this! It’s your initial proof  that you’ve been certified.
A few weeks after the test, you’ll get a little package from Sun Educational Services that includes your real printed certificate, a congratulations letter from Sun, and a lovely lapel pin that says Sun Certified Web Component Developer in a font so incredibly small that you could pretty much claim to be certified in anything you like, and nobody could read it to tell the difference.
It does not include the alcohol you’ll be wanting after you pass the exam.
How much does it cost, and how do I register? The exam costs U.S.
You register through Sun Educational Services, by giving them your credit card number.
In exchange, you’ll get a voucher number, which you’ll use to schedule an appointment at a Prometric Testing Center nearest you.
To get the details online and buy an exam voucher, start at: http://www.sun.com/training/ certification/
If  you’re not in the U.S., you can select a country from the right menu bar.
What’s the exam software like? It’s dead simple to use—you get a question, and you answer it.
If  you don’t want to answer it, you can skip it and come back to it later.
If  you do answer it, but aren’t sure, and you want to come back to it if you have more time, you can “mark” a question.
Once you’re done, you’ll see a screen that shows all of the questions you haven’t answered, or have marked, so that you can go back to them.
At the very beginning of  the exam you’ll get a short tutorial on how to use the software, where you get a little practice test (not on Servlets)
The time you spend in the tutorial does not count as time spent on the SCWCD exam.
The clock doesn’t start until you’ve finished the exam software tutorial and you’re ready to begin.
Where can I find a study group, and how long will it take to prepare?
The best online discussion group for this exam just happens to be the one that the authors moderate! (Gosh, what are the odds?)  Stop by javaranch.com and go to the Big Moose Saloon (that’s where all the discussion forums are)
There will always be someone there to answer your questions, including us.
JavaRanch is the friendliest Java community on the Internet, so you’re welcome no matter what level you’re at with Java.
If  you still need to take the SCJP, we’ll help you with that one too.
How long it takes you to get ready for the exam depends a lot on how much servlets and JSP experience you’ve had.
Those with a lot of  recent servlets and JSP experience can often be ready in as little as three weeks.
Our biggest thanks to Mike Loukides at O’Reilly, for starting it all, and helping to shape the Head First concept into a series.
We love having an editor who is a Real Java Guy.
And a big thanks to the driving force behind Head First, Tim O’Reilly.
Lucky for us, he’s always thinking about the future, and enjoys being a disruptive inﬂ uence.
Thanks to the clever Head First “series mom” Kyle Hart for fi guring out how Head First fi ts into the rest of  the computer book world.
OK, so the book took a little longer than we’d planned.
But without JavaRanch review manager Johannes deJong, it would have been scarily late.
And our special thanks to Joe Konior, whose feedback on each chapter was pretty much the same size as the chapter.
We deeply appreciate the relentless effort and expertise (and cheerfulness) of  Philippe Macquet.
All three of  the authors love him so much we want to marry him...but that would be weird.
Jef Cumps, your MP3 rendition of  the “setHeader” song was terrifi c (except for maybe being a bit emo), and your technical comments were really helpful.
Dave Wood hammered us on everything, and was fond of  pointing to early pages and saying, “That’s not very Head Firsty.” We also got some excellent feedback from JavaRanch moderators Jason Menard, Dirk “fi sh face” Schreckmann, Rob Ross, Ernest Friedman-Hill, and Thomas Paul.
If  you fi nd yourself  banging your head over a particularly twisty or turn-y JSP mock question, don’t blame us—blame Marc Peabody! Thanks Marc for helping us keep all the SCWCD candidates on their toes.
Marc spends copious amounts of  his free time moderating at JavaRanch, where he has been known to incite ranchers to construct horrible mashups out of  innocent Java EE technologie s.
The large number of acknowledgments is because we’re testing the theory that everyone mentioned in a book acknowledgment will buy at least one copy, probably more, what with relatives and everything.
If you’d like to be in the acknowledgments of our next book, and you have a large family, write to us.
Point of clarification: Bryan is the only co-author we’ve ever had, but that in no way diminishes the intent.
Even more people* From Bryan Basham I could start by thanking my Mom, but that’s been done before...My knowledge of  Java web development is founded in a few medium-scale applications that I have written, but that foundation was honed and refined by years of  debate on a Java instructor email alias internal to Sun.
There were many people that carved my knowledge, but these six have been the knives that have cut me the deepest.
As with all book projects, the last three months were pretty difficult.
I want to thank my fiance, Kathy Collina, for being patient with me.
I want to thank Karma and Kiwi (our cats) for the late night sessions of  lap-sitting and keyboard trouncing.
Lastly, and most importantly, I must thank Kathy and Bert for even suggesting that we take on this project.
Her knowledge of metacognition and instructional design is matched only by her creative juice that pours out of  her Head First books.
I have worked in education for five years now and I have learned nearly everything I know from Kathy...
Oh, don’t worry about my Mom; she will get a big dedication in my next Head First book.
But it’s not like she missed you, out playing Ultimate all summer long while we were working like dogs at our Powerbooks.
But you really made this a rewarding experience Bryan, and you’re the best1 co-author we’ve ever had! It’s almost frightening how calm and happy you are all the time.
We all appreciate the hard-working Sun exam certification team, especially Java cert manager Evelyn Cartagena, and we thank all the folks who helped develop the JSRs for the Servlet and JSP specs.
Sure, GUI applications might use exotic Swing widgets, but how many GUI apps do you know that are used by millions.
But to build a truly powerful web app, you need Java.
Today’s users expect sites that are dynamic, interactive, and customtailored.
Within these pages you’ll learn to move from web site to web app.
List triggers that might cause a Client (usually a Web browser) to use the method.
Also part of Objective 1.1, but not covered in this chapter:
Identify the HttpServlet method that corresponds to the HTTP Method.
The objectives in this section are covered completely in another chapter, so think of this chapter as a first-look foundation for what comes later.
In other words, don’t worry about finishing this chapter knowing (and remembering) anything specific from these objectives; just use it for background.
You won’t have any mock exam questions on these topics until you get to the more specific chapter where those topics are covered.
Everybody wants a web site You have a killer idea for a web site.
To destroy the competition, you need a flexible, scalable architecture.
Before we start building, let’s take a look at the World Wide Web from about 40k feet.
What we care most about in this chapter are how web clients and web servers talk to one another.
These next several pages are probably all review for you, especially if you’re already a web application developer, but it’ll give us a chance to expose some of  the terminology we use throughout the book.
The web consists of gazillions of clients (using browsers like Mozilla or Safari) and servers (using web server apps like Apache) connected through wires and wireless networks.
Our goal is to build a web application that clients around the globe can access.
The web server gets the request, finds the resource, and returns something to the user.
Doesn’t matter—the client asks for the thing (resource) and the server sends it back.
Or at least it’s not where the server is expecting it to be.
You’re of  course quite familiar with the “404 Not Found” error—the response you get when the server can’t find what it thinks you asked for.
When we say “server”, we mean either the physical machine (hardware) or the web server application (software)
Throughout the book, if the difference between server hardware and software matters, we’ll explicitly say which one (hardware or software) we’re talking about.
What does your web server do? A web server takes a client request and gives something back to the client.
The client’s request contains the name and address (the URL), of the thing the client is looking for.
The server’s response contains the actual document that the client requested (or an error code if the request could not be processed)
A web client lets the user request something on the server, and shows the user the result of the request.
When we talk about clients, though, we usually mean both (or either) the human user and the browser application.
The browser is the piece of  software (like Netscape or Mozilla) that knows how to communicate with the server.
The browser’s other big job is interpreting the HTML code and rendering the web page for the user.
So from now on, when we use the term client, we usually won’t care whether we’re talking about the human user or the browser app.
In other words, the client is the browser app doing what the user asked it to do.
Browser formats the request and sends it to the server.
Browser gets the HTML and renders it into a display for the user.
Server formats the response and sends it to the client (browser)
On the web, clients and servers must speak HTTP, and browsers must know HTML.
Most of  the conversations held on the web between clients and servers are held using the  HTTP protocol, which allows for simple request and response conversations.
The client sends an HTTP request, and the server answers with an HTTP response.
Bottom line: if you’re a web server, you speak HTTP.
When a web server sends an HTML page to the client, it sends it using HTTP.
You’ll see the details on how all this works in the next few pages.
When a server answers a request, the server usually sends some type of  content to the browser so that the browser can display it.
Servers often send the browser a set of  instructions written in  HTML, the HyperText Markup Language.
The HTML tells the browser how to present the content to the user.
All web browsers know what to do with HTML, although sometimes an older browser might not understand parts of  a page that was written using newer versions of  HTML.
The server uses HTTP to send HTML to the client.
Two-minute HTML guide When you develop a web page, you use HTML to describe what the page should look like and how it should behave.
The goal of  HTML is to take a text document and add tags that tell the browser how to format the text.
Below are the tags we use in the next several chapters.
If  you need a more complete understanding of  HTML, we recommend the book HTML & XHTML The Definitive Guide (O’Reilly)
We’ll talk more about forms later, but briefly, the browser can collect the user’s input and return it to the server.
You’ll see HTML in the context of  a large chunk of  questions, though, so you need at least some idea of  what’s happening when you see simple HTML.
The browser reads through the HTML code, creates the web page, and renders it to the user’s display.
If  you’re not familiar with those networking protocols, here’s the crash course: TCP is responsible for making sure that a file sent from one network node to another ends up as a complete file at the destination, even though the file is split into chunks when it’s sent.
HTTP, then, is another network protocol that has Web-specific features, but it depends on TCP/IP to get the complete request and response from one place to another.
The structure of  an HTTP conversation is a simple Request/ Response sequence; a browser requests, and a server responds.
Apache is an example of a Web server that processes HTTP requests.
Mozilla is an example of a Web browser that provides the user with the means to make HTTP requests and to view the documents returned by the server.
An HTML browser uses that header info to help process the HTML page.
Think of  the HTML content as data pasted inside an HTTP response.
When the browser gets to an image tag, it generates another HTTP request to go get the resource described.
In this case the browser will make a second HTTP request to get the picture referenced in the <img> tag.
When the browser finds the opening <html> tag it goes into HTML-rendering mode and displays the page to the user.
If that’s the response, what’s in the   request? The first thing you’ll find is an HTTP method name.
The method name tells the server the kind of  request that’s being made, and how the rest of  the message will be formatted.
The HTTP protocol has several methods, but the ones you’ll use most often are   GET and POST.
Browser sends an HTTP GET to the server, asking the server to GET the page.
Browser sends an HTTP POST to the server, giving the server what the user typed into the form.
User types in a form and hits the Submit button.
That resource might be an HTML page, a JPEG, a PDF, etc.
The point of  GET is to get something back from the server.
With POST, you can request something and at the same time send form data to the server (later in this chapter we’ll see what the server might do with that data)
A: Those are the two big ones that everybody uses.
But there are a few rarely used methods (and Servlets can handle them) including HEAD, TRACE, PUT, DELETE, OPTIONS, and CONNECT.
You really don’t need to know much about these others for the exam, although you might see them appear in a question.
The Life and Death of a Servlet chapter covers the rest of the HTTP method details you’ll need.
The “?” separates the path and the parameters (the extra data)
The amount of data you can send along with the GET is limited, and it’s exposed up here in the browser bar for everyone to see.
Together, the entire String is the URL that is sent with the request.
The total amount of  characters in a GET is really limited (depending on the server)
If  the user types, say, a long passage into a “search” input box, the GET might not work.
The data you send with the GET is appended to the URL up in the browser bar, so whatever you send is exposed.
Better not put a password or some other sensitive data as part of  a GET!
And if you need help with the exam, check out javaranch which also includes 100% unbiased recommendations to buy whatever books the authors wrote.
Because of  number two above, the user can’t bookmark a form submission if  you use POST instead of  GET.
Depending on your app, you may or may not want users to be able to bookmark the resulting request from a form submission.
The protocol version that the web browser is requesting.The Reques t line.
The path to the resource, and any parameters added to the URL are all included on the “request line”
And just FYI, “hurry it up” is not part of.
For instance, if  a user has just completed a long form, the application might want all of  the form’s data to be added to a database.
The data to be sent back to the server is known as the “message body” or “payload” and can be quite large.
This time, the parameters are down here in the body, so they aren’t limited the way they are if you use a GET and have to put them in the Request line.
Don’t forget to look inside the body for the important data I’m sending.
Anatomy of an HTTP response,  and what the heck is a “ MIME type”?
The body holds the HTML, or other content to be rendered...
The content-type response header’s value is known as a MIME type.
The MIME type tells the browser what kind of data the browser is about to receive so that the browser will know how to render it.
Notice that the MIME type value relates to the values listed in the HTTP request’s “Accept” header.
Go look at the Accept header from the previous page’s POST request.
Now that we’ve seen the requests from the browser to the server, let’s look at what the server sends back in response.
An HTTP response has both a header and a body.
The header info tells the browser about the protocol being used, whether the request was successful, and what kind of  content is included in the body.
The body contains the contents (for example, HTML) for the browser to display.
A user is requesting a new page via a hyperlink.
A user hits the ‘next’ button to see the next page.
A user hits the ‘log out’ button on a secure banking site.
A user sends a name and address form to the server.
When you get to the U’s in the acronym dictionary there’s a traffic jam...
URI, URL, URN, where does it end?  For now, we’re going to focus on the URLs, or Uniform Resource Locators, that you know and love.
Every resource on the web has its own unique address, in the URL format.
Server: The unique name of the physical server you’re looking for.
You can specify an IP address here instead of a server name, but a server name is a lot easier to remember.
Path:  The path to the location, on the server, of the resource being requested.
Because most of the early servers on the web ran Unix, Unix syntax is still used to describe the directory hierarchies on the web server.
Protocol: Tells the server which communications protocol (in this case HTTP) will be used.
This could be an HTML page, a servlet, an image, PDF, music, video, or anything else the server feels like serving.
If this optional part of the URL is left out, most web servers will look for index.html by default.
Optional Query String:  Remember, if this was a GET request, the extra info (parameters) would be appended to the end of this URL, starting with a question mark “?”, and with each parameter (name/value pair) separated by an ampersand “&”
A 16-bit number that identifies a specific software program on the server hardware.
A port represents a logical connection to a particular piece of  software running on the server hardware.
You can’t spin your hardware box around and find a TCP port.
For another, they do not represent a place to plug in physical devices.
Without port numbers, the server would have no way of knowing which application a client wanted to connect to.
And since each application might have its own unique protocol, think of  the trouble you’d have without these identifiers.
If  you’re writing services (server programs) to run on a company network, you should check with the sys-admins to find out which ports are already taken.
Don’t use these ports for your own custom server programs!
Using one server app per port, a server can have up to 65536 different server apps running.
Directory structure for a simple  Apache web site We’ll talk more about Apache and Tomcat later, but for now let’s assume that our simple web site is using Apache (the extremely popular, open source web server you’re probably already using)
What would the directory structure look like for a web site called www.
The .html pages are each marked with a letter (A, B, C, D) for the exercise on the opposite page.
An Apache server will assume that “htdocs” is the directory that is the root for all of the server’s web applications.
Mapping URLs to content Look at the directory structure on the opposite page, then write in a URL that would get you to each of the four .html pages marked with the A, B, C, and D.
We did the first one (A) for you, because that’s the kind of people we are.
The answers are at the bottom of the next page.
The server finds it and hands it back to the client as is.
But what if I want, say, the current time to show up on.
What if we want to stick something variable inside the HTML page?
These pages go straight to the client just exactly as they were put on the server.
But sometimes you need more than just the web server.
I know a real nice program on the same machine.
But how does that help? My clients are all web clients.
When the user submits data in a form, the web server sees the form data and thinks,  “So? Like I care?”
To process that form data, either to save it to a file or database or even just to use it to generate the response page, you need another app.
When the web server sees a request for a helper app, the web server assumes that parameters are meant for that app.
So the web server hands over the parameters, and gives the app a way to generate a response to the client.
The web server application serves only static pages, but a separate “helper” application that the web server can communicate with can build non-static, just-in-time pages.
A dynamic page could be anything from a catalog to a weblog or even just a page that randomly chooses pictures to display.
It’s like making an HTML page out of thin air.
The request comes in, the helper app “writes” the HTML, and the web server gets it back to the client.
The non-Java term for a web server helper app is “ CGI” program Most CGI programs are written as Perl scripts, but many other languages can work including C, Python, and PHP.
Using CGI, here’s how it might work for a dynamic web page that has the current server date.
User clicks a link that has a URL to a CGI program instead of a static page.
Web server application “sees” that the request is for a helper program, so the web server launches and runs the program.
The web server app sends along any parameters from a GET or POST.
The helper app constructs the brand new page (that has the current date inserted) and sends the HTML back to the server.
As far as the web server is concerned, the HTML from the helper app is a static page.
The helper application is shut down, and the client gets back an HTML page that has the current date as part of its now-static content.
Servlets and CGI both play the role of a helper app in the web server.
Listen in as our two black belts discuss the pros and cons of  CGI and Servlets.
We write CGI scripts in Perl at our shop, because everybody knows Perl.
I guess that’s fine if  you use Java, since you know it.
But it’s certainly not worth it for us to switch to Java.
Web servers now are able to keep a single Perl program running  between client requests.
What are you talking about? Any CORBA-compliant thing can be a J2EE client.
I like Perl, but we’re all Java programmers in our shop so we prefer Java.
With much respect, master, there are many advantages to using Java over Perl for the things you want to do with CGI.
With Perl, the server has to launch a heavy-weight process for each and every request for that resource!
Ah, yes, but you see Servlets stay loaded and client requests for a Servlet resource are handled as separate threads of  a single running Servlet.
There’s no overhead of  starting the JVM, loading the class, and all that...
But it is not all web servers that can do that.
You are talking about a special case which does not apply to all Perl CGI programs.
But Servlets will always be more efficient in that way.
And let’s not forget that a Servlet can be a J2EE client, while a Perl CGI program cannot.
A Servlet running in a J2EE web container can participate in security and transactions right along with enterprise beans and there areto be continued...
This is a duplicate of page 18, so when you’re fi nished, fl ip back to that page to compare your answers.
Standard servlet declarations (there will be about 400 pages describing this stuff)
Write a servlet named Ch1Servlet.java and put it in the src directory (to keep this example simple, we aren’t putting the servlet in a package, but after this, all other servlet examples in the book will be in packages)
Create a deployment descriptor (DD) named web.xml, put it in the etc directory.
Just so those new to servlets can stop holding their breath, here’s a quick guide to writing, deploying, and running a servlet.
This might create more questions than it answers—don’t panic, you don’t have to do this right now.
It’s just a quick demonstration for those who can’t wait.
Copy the Ch1Servlet.class fi le to WEB-INF/classes, and copy the web.xml fi le to WEB-INF.
For now, every time you update either a servlet class or the deployment descriptor, shutdown Tomcat:
No offense here, but there’s something SERIOUSLY wrong with this servlets picture...
Actually, trying to format HTML inside a servlet’s out.println() pretty much sucks.
This is one of  the worst parts (no, the worst part) of  servlets.
Stuffing properly formatted HTML tags into the println(), just so that you can insert variables and method calls, is just brutal.
Don’t even think about doing anything the least bit sophisticated.
It’s not like I have to be able to read the code in there.
I’ll just make my page in a decent web page editor (or even a simple text file would be easier than in my Java code) and then a quick copy and paste into the println() and voila!
Remember, you can’t have a carriage return (a real one) inside a String literal.
Oh if only there were a way to put Java inside an.
A JSP page looks just like an HTML page, except you can put Java and Java-related things inside the page.
So it really is like inserting a variable into your HTML.
With JSP, Java developers can do Java, and HTML developers can do web pages.
Putting even marginally complex HTML into the argument to a println() is a compiler error waiting to happen.
You might have to do a ton of  work to get the HTML formatted properly in a way that still works in the client’s browser, yet satisfies Java rules for what’s allowed in a String literal.
You can’t have carriage returns, for example, yet most of  the HTML you’ll pull from a web page editor will have real carriage returns in the source.
Quotes can be a problem too—a lot of  HTML tags use quotes around attribute values, for example.
And you know what happens when the compiler sees a double quote...
It might be easier to write HTML in a JSP rather than in a println(), but the HTML developer still has to know Java.
A: Looks that way, doesn’t it? But with the new JSP spec, and by following best practices, the page designer should be putting very little (or no) real Java into a JSP.
They have to learn JSP syntax, but not the Java language.
If the response from the server is an HTML page, the HTML is added to the HTTP response.
Every resource on the web has its own unique address in this format.
It starts with a protocol, followed by the server name, an optional port number, and usually a specific path and resource name.
It can also include an optional query string, if the URL is for a GET request.
The non-Java term for these helper apps (most often written in Perl) is CGI (which stands for Common Gateway Interface)
Putting HTML inside a println() statement is ugly and error-prone, but JSPs solve that problem by letting you put Java into an HTML page rather than putting HTML into Java code.
When a request comes in, somebody has to instantiate the servlet or at least make a new thread to handle the request.
Somebody has to call the servlet’s doPost() or doGet() method.
Somebody has to get the request and the response to the servlet.
Somebody has to manage the life, death, and resources of the servlet.
For each of the HTTP Methods (such as GET, POST, HEAD, and so on), describe the purpose of the method and the technical characteristics of the HTTP Method protocol, list triggers that might cause a client (usually a Web browser) to use the Method, and identify the HttpServlet method that corresponds to the HTTP Method.
Construct the file and directory structure of a Web Application that may contain (a) static content, (b) JSP pages, (c) servlet classes, (d) the deployment descriptor, (e) tag libraries, (f) JAR files, and (g) Java class files; and describe how to protect resource files from HTTP access.
Describe the purpose and semantics for each of the following deployment descriptor elements: servlet instance, servlet name, servlet class, servlet initialization parameters, and URL to named servlet mapping.
All of  the objectives in this section are covered completely in other chapters, so think of  this chapter as a first-look foundation for what comes later.
In other words, don’t worry about finishing this chapter knowing (and remembering) anything specific from these objectives.
You won’t have any mock exam questions on these topics until you get to the more specific chapter where those topics are covered.
Enjoy this nice, simple, background material while you can! BUT...
When your web server application (like Apache) gets a request for a servlet (as opposed to, say, a plain old static HTML page), the server hands the request not to the servlet itself, but to the Container in which the servlet is deployed.
It’s the Container that gives the servlet the HTTP request and response, and it’s the Container that calls the servlet’s methods (like doPost() or doGet())
What is a  Container? Servlets don’t have a main() method.
They’re under the control of another Java application called a Container.
It’s OK if you don’t yet know much about what the Container does.
Just imagine you need server-side support for a web application, and all you have is plain old Java.
Create a socket connection with the server, and create a listener for the socket.
Possible answers:  create a thread manager, implement security, how about fi ltering for things like logging, JSP support - yikes, memory management...
List some of the functions you would have to implement in a J2SE application if no Container existed:
What does the Container give you? We know that it’s the Container that manages and runs the servlet, but why? Is it worth the extra overhead?
Communications support   The container provides an easy way for your servlets to talk to your web server.
You don’t have to build a ServerSocket, listen on a port, create streams, etc.
The Container knows the protocol between the web server and itself, so that your servlet doesn’t have to worry about an API between, say, the Apache web server and your own web application code.
All you have to worry about is your own business logic that goes in your Servlet (like accepting an order from your online store)
Multithreading Support   The Container automatically creates a new Java thread for every servlet request it receives.
This doesn’t mean you’re off  the hook for thread safety—you can still run into synchronization issues.
But having the server create and manage threads for multiple requests still saves you a lot of  work.
Well, who do you think takes care of  translating that JSP code into real Java? Of  course.
Lifecycle Management     The Container controls the life and death of  your servlets.
It takes care of  loading the classes, instantiating and initializing the servlets, invoking the servlet methods, and making servlet instances eligible for garbage collection.
With the Container in control, you don’t have to worry as much about resource management.
Declarative Security    With a Container, you get to use an XML deployment descriptor to configure (and modify) security without having to hard-code it into your servlet (or any other) class code.
Think about that! You can manage and change your security without touching and recompiling your Java source files.
Now all I have to worry about is how to sell my scratch-nsniff bubble wrap, instead of having.
Thanks to the Container, YOU get to concentrate more on your own business logic instead of worrying about writing code for threading, security, and networking.
You get to focus all your energy on making a fabulous online bubble wrap store, and leave the underlying services like security and JSP processing up to the container.
We’ll save some of  the juicier bits for later in the book, but here’s a quick look:
Web browser2 The container “sees” that the request is for a servlet, so the.
Remember, the container still has a reference to the response object!
Depending on the type of request, the service() method calls either the doGet() or doPost() method.
For this example, we’ll assume the request was an HTTP GET.
How it looks in code (what makes a servlet a servlet)
Q: I remember seeing doGet() and doPost(), but on the previous page, you show a service() method? Where did the service() method come from?
A: Your servlet inherited it from HttpServlet, which inherited it from GenericServlet which inherited it from...
Q: You wimped out on explaining how the container found the correct servlet...
But it points to a Really Big Topic (servlet mapping and URL patterns), so we’ll take only a quick look on the next few pages, but go into much more detail later in the book (in the Deployment chapter)
This is where your servlet gets references to the request and response objects which the container creates.
In the real world, 99.9% of all servlets override either the doGet() or doPost() method.
You can get a PrintWriter from the response object your servlet gets from the Container.
Use the PrintWriter to write HTML text to the response object.
You can get other output options, besides PrintWriter, for writing, say, a picture instead of HTML text.
The servlet’s lifecycle methods (like doGet()) are called by the Container.
Somehow, the URL that comes in as part of  the request from the client is mapped to a specific servlet on the server.
This mapping of  URLs to servlets might be handled in a number of  different ways, and it’s one of  the most fundamental issues you’ll face as a web app developer.
The user request must map to a particular servlet, and it’s up to you to understand and (usually) configure that mapping.
For each of the following approaches, think about the pros and cons.
In other words, the client is using the exact path and file (class) name of the servlet.
Use some sort of properties table to store the mappings:
The original developer of  the servlet class chose the class name (and the package name that defines part of  the directory structure), and the location on the server defines the full path name.
But anyone who deploys the servlet can also give it a special deployment name.
A deployment name is simply a secret internal name that doesn’t have to be the same as the class or file name.
Finally, the  servlet has a public URL name—the name the client knows about.
In other words, the name coded into the HTML so that when the user clicks a link that’s supposed to go to that servlet, this public URL name is sent to the server in the HTTP request.
The client sees a URL for the servlet (in the HTML), but doesn’t really know how that servlet name maps to real directories and fi les back on the server.
The public URL name is a fake name, made up for clients.
The deployer can create a name that’s known only to the deployer and others in the real operational environment.
This name, too, is a fake name, made up just for the deployment of the servlet.
It doesn’t have to match the public URL used by the client, OR the real fi le and path name of the servlet class.
The developer’s servlet class has a fully-qualifi ed name that includes both the class name and the package name.
The servlet class fi le has a real path and fi le name, depending on where the package directory structure lives on the server.
So you’ve hard-coded the real path and file name into all the JSPs and other HTML pages that use that servlet.
Now what happens when you need to reorganize your application, and possibly move things into different directory structures? Do you really want to force everyone who uses that servlet to know (and forever follow) that same directory structure?
By mapping the name instead of  coding in the real file and path name, you have the flexibility to move things around without having the maintenance nightmare of  tracking down and changing client code that refers to the old location of  the servlet files.
And what about security? Do you really want the client to know exactly how things are structured on your server? Do you want them to, say, attempt to navigate directly to the servlet without going through the right pages or forms? Because if  the end-user can see the real path, she can type it into her browser and try to access it directly.
Well isn’t that special how everyone gets to express their creativity and.
But what’s the point!? Really? Why don’t we all just use the one, real, non-confusing file name?
When you deploy your servlet into your web Container, you’ll create a fairly simple XML document called the Deployment Descriptor (DD) to tell the Container how to run your servlets and JSPs.
Although you’ll use the DD for more than just mapping names, you’ll use two XML elements to map URLs to servlets—one to map the client-known public URL name to your own internal name, and the other to map your own internal name to a fully-qualified class name.
This is what the client sees (and uses) to get to the servlet...
The <servlet> element tells the Container which class files belong to a particular web application.
Think of the <servlet-mapping> element as what the Container uses at runtime when a request comes in, to ask, “which servlet should I invoke for this requested URL?”
Besides mapping URLs to actual servlets, you can use the DD to customize other aspects of  your web application including security roles, error pages, tag libraries, initial configuration information, and if  it’s a full J2EE server, you can even declare that you’ll be accessing specific enterprise javabeans.
The crucial point for now is that the DD gives you a way to declaratively modify your application without changing source code!
But wait! There’s more you can do with the DD.
The deployment descriptor (DD), provides a “declarative” mechanism for customizing your web applications without touching source code!
Looking at the DD, you still don’t have anything that indicates the actual path name of the servlet! It just says the class name.
This still doesn’t answer the question of how the Container uses that class name to find a specific servlet class file.
Is there yet ANOTHER  mapping somewhere that says that such and such a class name maps to such and such a file in such and such a location?
You’re right that we put only the class name (fully-qualified to include the package name) into the <servlet-class> element.
That’s because the Container has a specific place it will look for all servlets for which you’ve specified a mapping in the DD.
In fact, the Container uses a sophisticated set of rules for finding a match between the URL that comes in from the client request and an actual Java class sitting somewhere on the server.
But we’ll get into that in a later chapter (on Deployment)
Right now, the key point to remember is that you can do this mapping.
Lets you fine-tune your app’s capabilities, even if you don’t have the source code.
Lets you adapt your application to different resources (like databases), without having to recompile and test any code.
Makes it easier for you to maintain dynamic security info like access control lists and security roles.
Lets non-programmers modify and deploy your web applications while you can focus on the more interesting things.
Like how appropriate your wardrobe isn’t for a trip to Hawaii.
Who has the time when there’s always another disk to defrag? Bob, who wants a piece of  the dot-com action (what’s left of  it, anyway), believes that creating a geek-specific dating site is his ticket out of  the Dilbertian job he has now.
The problem is, Bob’s been a software manager for so long that he’s, um, a little out of  touch with contemporary software engineering practices.
But he knows some buzzwords and some Java and he’s read a little about servlets, so he makes a quick design and starts to code...
Each servlet will have all the business logic it needs to modify or read the database, and prints the HTML to the response stream back to the client.
The servlet does whatever it needs to do to process the request (like insert or search the database) and returns the HTML page in the HTTP response.
All of the business logic AND the client HTML page response is inside the servlet code.
But then it gets ugly, so he adds JSPs Those pesky println() statements for the output response get really ugly, really quickly.
Client fills out the DQL query form and clicks the “Do it” button.
The web server invokes the servlet, the servlet runs the query on the database, then the request is forwarded to the appropriate JSP.
The JSP builds the response HTML and sends it back.
But then his friend says, “You ARE using MVC, right ?” Kim wants to know if  the dating service can be accessed from a Swing GUI application.
Bob says, “No, I hadn’t thought of that.” So Kim says, “Well, it’s not a problem because I’m sure you used MVC, so we can just whip up a Swing GUI client that can access the business logic classes.”
And Bob says, “Well, I did separate out the presentation from the business logic...”
But he’s determined to do this right, so he asks Kim to give him a quick crash overview of  MVC.
What if you want to make a Swing GUI app.
With MVC the business logic is not only separate from the presentation...
The essence of  MVC is that you separate the business logic from the presentation, but put something between them so that the business logic can stand on its own as a reusable Java class, and doesn’t have to know anything about the view.
Bob was partly there, by separating out the business logic from the presentation, but his business logic still has an intimate connection to the view.
In other words, he mixed the business logic into a servlet, and that means he can’t reuse his business logic for some other kind of  view (like a Swing GUI or even a wireless app)
His business logic is stuck in a servlet when it should be in a standalone Java class he can reuse!
He would have realized that with the business logic embedded in a servlet, he’d be screwed if  he one day needed a different way to access the dating service.
We’ll talk a lot more about MVC (and other patterns) later in the book, but you need a quick understanding now because the tutorial app we build at the end of  this chapter uses MVC.
If  you’re already familiar with it, then you know that MVC is not specific to servlets and JSPs—the clean separation of business logic and presentation is just as valid in any other kind of  application.
But with web apps, it’s really important, because you should never assume that your business logic will be accessed only from the web! We’re sure you’ve worked in this business long enough to know the only guarantee in software development: the spec always changes.
Takes user input from the request and figures out what it means to the model.
Tells the model to update itself, and makes the new model state available for the view (the JSP)
In other words, it knows the rules for getting and updating the state.
A Shopping Cart’s contents (and the rules for what to do with it) would be part of the Model in MVC.
It gets the state of the model from the Controller (although not directly; the Controller puts the model data in a place where the View can find it)
It’s also the part that gets the user input that goes back to the Controller.
The Model is a combination of the business data (like the state of a Shopping Cart) and the methods (rules) that operate on that data.
Separate out the business logic from the servlets, and create a regular Java class for each one...
Then the original servlet will be the Controller, the new business logic class will be the Model, and the JSP will be the View.
What do you think? Am I good or am I good? A perfect.
But then his friend Kim takes a look Kim comes in and says that while it IS an MVC design, it’s a dumb one.
Sure, the business logic has been pulled out into a Model, and the servlets act as the Controllers working between the Models and Views so that the Models can be brain-dead about the Views.
What do they even do? Now that the business logic is safely tucked away in the Model, the servlet Controller isn’t doing much except some generic application stuff  for this app, and, oh yeah, it does update the Model and then it kicks the View into gear.
But the worst part is that all that generic application logic is duplicated in every single frickin’ servlet! If  one thing needs to change, it has to change everywhere.
You have to add the same overall application code, like security, in almost every servlet.
Should Bob go back to just one servlet Controller, to avoid.
What do you think? Do you know the answer? IS there an answer? Would you agree with Bob, and leave the servlets as they are, or would you put the code into just one servlet Controller? And if you do use just one Controller for everything, how will the Controller know which Model and View to call?
The answer to this question won’t come until the very end of the book, so think about this for a few moments, then put it in a mental background thread...
Using MVC in a servlet & JSP world, each of these three components (JSP, Java class, Servlet) plays one of the three MVC roles.
Circle the “M”, the “V”, or the “C” depending on which MVC part that component plays.
What do the letters MVC represent in the MVC design pattern?
The Container gives your web app communications support, lifecycle management, multithreading support, declarative security, and support for JSPs, so that you can concentrate on your own business logic.
The Container creates a request and response object that servlets (and other parts of the web app) can use to get information about the request and send information to the client.
The deployer can map a servlet class to a URL that the client can use to request that servlet.
The name may have nothing to do with the actual class file name.
Who’s responsible? Fill in the table below, indicating whether the web server, the web container, or a servlet is most responsible for the task listed.
In a few cases more than one answer may be true for a given task.
For extra credit, add a brief comment describing the process.
Has a name that matches the <servlet-class> element in the DD.
A working servlet,and its DD are scrambled up on the fridge.
Can you add the code snippets on the right to the incomplete listings on the left to make a working servlet and DD whose URL ends with /Dice? There might be some extra magnets on the right that you won’t use at all!
Has a name that matches the <servlet-class> element in the DD.
Generates the HTTP response stream from the data in response object.
A “working” Deployment Descriptor (DD) Don’t worry about what any of  this really means (you’ll see and be tested on this in other chapters)
Here, we just wanted to show you a web.xml DD that actually works.
The other examples in this chapter were missing a lot of  the pieces that go into the opening <web-app> tag.
You can see why we don’t usually include it in our examples.
You do NOT have to m emorize any of this.
In other words, the web Container is for web components (Servlets and JSPs), and the EJB Container is for business components.
A fully-compliant J2EE application server must have both a web Container and an EJB Container (plus other things including a JNDI and JMS implementation)
Tomcat is just a web Container! It is still compliant with the portions of  the J2EE spec that address the web Container.
Tomcat is a web Container, not a full J2EE application server, because Tomcat does not have an EJB Container.
Tomcat is a web Container, but NOT a full J2EE application server.
Standalone web Containers are usually configured to work with an HTTP web server (like Apache), although the Tomcat Container does have the ability to act as a basic HTTP server.
But for HTTP server capability, Tomcat is not nearly as robust as Apache, so the most common non-EJB web apps usually use Apache and Tomcat configured together—with Apache as the HTTP web Server, and Tomcat as the web Container.
It’s time to get your hands dirty writing an HTML form, a servlet controller, a model (plain old Java class), an.
But fi rst, you need to set up your development environment—a project directory.
Then you’re ready to start writing, compiling, deploying, and running.
He may look tough, but he has never created and.
All of  the objectives in this section are covered completely in the Deployment chapter; this is just a first look.
This chapter is the only complete start-to-finish tutorial in the book, so if  you skip it, you might have trouble later testing some of  the other examples in later chapters (where we don’t go through every detail again)
As with the previous two chapters, you don’t need to focus on memorizing the content in this chapter.
Construct the file and directory structure of a web application that may contain (a) static content, (b) JSP pages, (c) servlet classes, (d) the deployment descriptor, (e) tag libraries, (f) JAR files, and (g) Java class files.
Describe the purpose and semantics for each of the following deployment descriptor elements: error-page, init-param, mime-mapping, servlet, servlet-class, servlet-mapping, servlet-name, and welcome-file.
Construct the correct structure for each of the following deployment descriptor elements: error-page, init-param, mime-mapping, servlet, servlet-class, servlet-name, and welcome-file.
Let’s build a real (small) web application We looked at the role of  a container, we talked a bit about deployment descriptors, and we took a first look at the Model 2 MVC architecture.
But you can’t just sit here and read all daynow it’s time to actually do something.
Review the user’s views (what the browser will display), and the high level architecture.
Perform iterative development and testing on the various components of our web application.
OK, this is more of a strategy than a step.
Note:  We recommend iterative development and testing, although we won’t always show all the steps in this book.
Create the development environment that we will use for this project (which you can use for any other example in the book)
Create the deployment environment that we will use for this project (which you can use for any other example in the book)
Users will be able to surf  to our app, answer a question, and get back stunningly useful beer advice.
Q: Why are we writing a web application that gives beer advice?
A: After an exhaustive marketing research effort,  we concluded that 90% of our readers appreciate beer.
The other 10% can simply substitute the word “coffee” for “beer”
This page will be written in HTML, and will generate an HTTP Post request, sending the user’s color selection as a parameter.
This page will be a JSP that gives the advice based on the user’s choice.
Even though this is a tiny application, we’ll build it using a simple MVC architecture.
That way, when it becomes THE hottest site on the web, we’ll be ready to extend the application.
The Container returns the page to the browser, where the user answers the questions on the form and...
The Container fi nds the correct servlet based on the URL, and passes the request to the servlet.
The expert class returns an answer, which the servlet adds to the request object.
From here on out when you don’t see the web server, assume it’s there.
There are lots of  ways you could organize your development directory structure, but here’s what we recommend for small- and medium-sized projects.
When it’s time to deploy the web app, we’ll copy a portion of  this into wherever our particular Container wants the pieces to go.
This is where you put 3rd party JAR files (from servlets-R-us)
All of your Java code lives under the src directory.
Notice that we’re separating the controller components from the model components.
We’re of course using a standard package structure so that we get all the normal benefits of packages: - project organization - namespace management - portability and reusability.
Deploying a web app involves both Container-specific rules and requirements of  the Servlets and JSP specifications.
If  you’re not deploying to  Tomcat, you’ll have to figure out exactly where your web app should be relative to your Container.
In our example, everything below the “Beer-v1” directory is the same regardless of  your Container!
This part of the directory structure is required by Tomcat, and it must be directly inside the Tomcat home directory.
Everything BELOW this dotted line IS the webapp, and will be the same regardless of your Container vendor.
This directory name also represents the “context root” which Tomcat uses when resolving URLs.
We’ll explore this concept in great detail in the deployment chapter.
This package structure is exactly what we used in the development environment.
Unless you’re deploying your classes in a JAR (we’ll talk about that later in the book), then you MUST put the package directory structure immediately under WEB-INF/classes.
Our roadmap for building the app When we started this chapter we outlined a four-step process for developing our web app.
We borrow from several popular development methodologies (a little from extreme programming, iterative development), and mangle them for our own evil purposes...
Build and test the HTML form that the user will first request.
This version adds the capability of calling the model class to get beer advice.
Build and test version 1 of the controller servlet with the HTML form.
This version is invoked via the HTML form and prints the parameter it receives.
Build a test class for the expert / model class, then build and test the expert / model class itself.
Build the JSP, upgrade the servlet to version 3 (which adds the capability of dispatching to the JSP), and test the whole app.
This is what the HTML thinks the servlet is called.
This is how we created the pulldown menu; your options may vary.
Q: Why is the form submitting to “SelectBeer.do” when there is NO servlet with that name? In the directory structures we looked at earlier,  I didn’t see anything that had the name “SelectBeer.do”
A: SelectBeer.do is a logical name, not an actual file name.
It’s simply the name we want the client to use! In fact the client will NEVER have direct access to the servlet class file, so you won’t, for example, create an HTML page with a link or action that includes a path to a servlet class file.
For now, think of the “.do” extension as simply part of the logical name (and not a real file type)
Later in the book, you’ll learn about other ways in which you can use extensions (real or made-up/logical) in your servlet mappings.
The HTML is simple—it puts up the heading text, the drop-down list from which the user selects a beer color, and the submit button.
Create this XML document, name it web.xml, and save it in your development environment under the /beerV1/etc/ directory.
This is a made-up name that you’ll use ONLY in.
This is how we want the client to refer to.
The “.do” is just a convention.Don’t forget to start with a slash.
Create this HTML fi le, call it form.html, and save it in your development environment under the /beerV1/web/ directory.
To test it, you need to deploy it into the Container (Tomcat) directory structure, start Tomcat, and bring up the page in a browser.
You MUST place it there or the Container won’t fi nd it and nothing will work, and you’ll become depressed.
Throughout this book we’re using Tomcat as both the web Server and the web Container.
In the real world, you probably use a more robust Web Server (like Apache) confi gured with a Web Container (like Tomcat)
But Tomcat makes a perfectly decent Web Server for everything we need to do in this book.
To start Tomcat, cd into the tomcat home directory and run bin/startup.sh.
But that isn’t the name of an actual servlet class fi le.
To the Container, a servlet is something named in the DD under a <servlet> tag.
The name of the servlet is simply the name used in the DD so that other parts of the DD can map to it.
If the servlet has not been initialized, the class is loaded and the servlet is initialized.
The Container starts a new thread to handle the request, and passes the request to the thread (to the servlet’s service() method)
The Container sends the response (through the Web Server, of course) back to the client.
We’ll use doPost to handle the HTTP request, because the HTML form says: method=POST.
Our plan is to build the servlet in stages, testing the various communication links as we go.
In the end, remember, the servlet will accept a parameter from the request, invoke a method on the model, save information in a place the JSP can find, and forward the request to the JSP.
But for this first version, our goal is just to make sure that the HTML page can properly invoke the servlet, and that the servlet is receiving the HTML parameter correctly.
We’re not giving back advice here, just displaying test information.
OK, we’ve built, deployed, and tested our HTML, and we’ve built and deployed our DD (well, we put the web.xml into the deployment environment, but technically the DD won’t be deployed until we restart Tomcat)
Now it’s time to compile the first version of  the servlet, deploy it, and test it via the HTML form.
Now we’ll restart Tomcat to make sure that it “sees” the web.xml and servlet class.
Compile the servlet with the -d fl ag to put the class in the development environment.
Adjust this to match your own directory path to your system! Everything after “tomcat/” will be the same.
Use the -d option to tell the compiler to put the .class file into the classes directory within the correct package structure.
If your servlet is working, you should see the servlet’s response in your browser as something like: Beer Selection Advice Got beer color brown.
Building and testing the model class In MVC, the model tends to be the “back-end” of  the application.
It’s often the legacy system that’s now being exposed to the web.
In most cases it’s just plain old Java code, with no knowledge of  the fact that it might be called by servlets.
The model shouldn’t be tied down to being used by only a single web app, so it should be in its own utility packages.
Create the test class for the model (yes, before you build the model itself)
You’re on your own here; we don’t have one in this tutorial.
Remember, the model will still be in the development environment when you first test it—it’s just like any other Java class, and you can test it without Tomcat.
They often involve connections to legacy databases, and calls to complex business logic.
Here’s our sophisticated, rulebased expert system for the beer advice:
Enhancing the servlet to call the model, so that we can get REAL advice...
In this version two servlet we’ll enhance the doPost() method to call the model for advice (version three will make the advice come from a JSP)
The code changes are trivial, but the important part is understanding the redeployment of  the enhanced web app.
You can try to write the code, recompile, and deploy on your own, or you can turn the page and follow along...
Enhance the servlet, version two Forget about servlets for a minute, let’s just think Java.
What are the steps we have to take to accomplish the following?
Servlet version two code Remember, the model is just plain old Java, so we call it like we’d call any other Java method—instantiate the model class and call its method!
Print out the advice (beer brand items in the ArrayList returned from the model)
In the final (third) version, the advice will be printed from a JSP instead of the servlet.
Key steps for servlet version two We have two main things to do: recompile the servlet and deploy the model class.
We’ll use the same compiler command that we used when we built the fi rst version of the servlet.
Now, in addition to the servlet, we also have to deploy the model.
Test the app via form.html, the fi nal browser output should be something like:
Review the partially completed, MVC beer advice web application What’s working so far...
The Container fi nds the correct servlet based on the URL, and passes the request to the servlet.
The expert class returns an answer, which the servlet adds to the request object.
The Container fi nds the correct servlet based on the URL, and passes the request to the servlet.
Create the  JSP “view” that gives the advice Don’t get your hopes up.
You’re going to have to wait for a few chapters before we really start talking about JSPs.
This JSP isn’t actually a particularly good one, either (because of  its scriptlet code, which we’ll talk about later in the book)
For now it should be pretty easy to read, and if  you want to experiment a little, go for it.
Although we could test this JSP now from the browser, we’ll wait until after we modify the servlet (version three) to see if  it works.
This is a “page directive” (we’re thinking it’s pretty obvious what this one does)
Some standard HTML (which is known as “template text” in the JSP world)
A little later in the book, we’ll explain everything about attributes and how we managed to get the request object...
We don’t compile the JSP (the Container does that at fi rst request)
Move a copy of it to the deployment environment in /Beer-v1/
Enhancing the servlet to “call” the JSP (version three) In this step we’re going to modify the servlet to “call” the JSP to produce the output (view)
The Container provides a mechanism called “request dispatching” that allows one Container-managed component to call another, and that’s what we’ll use—the servlet will get the info from the model, save it in the request object, then dispatch the request to the JSP.
Add the model component’s answer to the request object, so that the JSP can access it.
The Container fi nds the correct servlet based on the URL, and passes the request to the servlet.
The expert class returns an answer, which the servlet adds to the request object.
Code for servlet version three Here’s how we modified the servlet to add the model component’s answer to the request object (so the JSP can retrieve it), and how we asked the Container to dispatch to the JSP.
Use the request dispatcher to ask the Container to crank up the JSP, sending it the request and response.
Now that the JSP is going to produce the output, we should remove the test output from the servlet.
We commented it out so that you could still see it here.
Add an attribute to the request object for the JSP to use.
Compile, deploy, and test the final app! In this chapter we’ve built an entire (albeit tiny) MVC application using HTML, servlets and JSPs.
We’ll use the same compiler command that we used earlier:
You had three whole chapters to cruise along, write a little code, review the whole HTTP request/response thing.
But there’s still 200 mock exam questions waiting for you in this book, and they start with the next chapter.
Unless you’re already familiar with servlet development and deployment, you really shouldn’t turn the page until after you actually do the tutorial in this chapter.
Not that we’re trying to pressure you or guilt-trip you or anything...
A servlet’s job is to take a client’s request and send back a response.
The request carries crucial data, and your servlet code has to know how to fi nd.
The response carries the info the browser needs to render.
For each of the HTTP Methods (such as GET, POST, HEAD, and so on), describe the purpose of the method and the technical characteristics of the HTTP Method protocol, list triggers that might cause a client (usually a Web browser) to use the Method, and identify the HttpServlet method that corresponds to the HTTP Method.
Using the HttpServletRequest interface, write code to retrieve HTML form parameters from the request, retrieve HTTP request header information, or retrieve cookies from the request.
We won’t say much about the objectives related to cookies until the Sessions chapter.
All of  the objectives in this section are covered completely in this chapter, with the exception of  the cookies part of  objective 1.3
No other chapter will cover these objectives in detail, so this is it.
Do the exercises in the chapter, review the material, then take your first mock exam at the end of  the chapter.
If  you don’t get at least 80% correct, go back through the chapter to figure out what you missed, BEFORE you move on to chapter five.
That means there are fewer mock exam questions in this chapter, and more in later chapters, to avoid testing you on topics you haven’t covered.
Important note: while the first three chapters covered background information, from this page forward in the book, virtually everything you’re going to see is directly related to or explicitly part of  the exam.
Servlets are controlled by the Container In chapter two we looked at the Container’s overall role in a servlet’s life—it creates the request and response objects, creates or allocates a new thread for the servlet, and calls the servlet’s service() method, passing the request and response references as arguments.
Web browser1 User clicks a link that has a URL.
Web browser2 The Container “sees” that the request is for a servlet, so the.
The client sent an HTTP GET request, so the service() method calls the servlet’s doGet() method, passing the request and response objects as arguments.
The service() method completes, so the thread either dies or returns to a Container-managed thread pool.
The request and response object references fall out of scope, so these objects are toast (ready for garbage collection)
But there’s more to a servlet’s life We stepped into the middle of  the servlet’s life, but that still leaves questions: when was the servlet class loaded? When did the servlet’s constructor run? How long does the servlet object live? When should your servlet initialize resources? When should it clean up its resources?
The servlet   lifecycle is simple; there’s only one main state—initialized.
If  the servlet isn’t initialized, then it’s either being initialized (running its constructor or init()method), being destroyed (running its destroy() method), or it simply does not exist.
Called only ONCE in the servlet’s life, and must complete before Container can call service()
Container calls to give the servlet a chance to clean up before the servlet is killed (i.e., made ready for garbage collection)
This is where the servlet spends most of its life.
GenericServlet is an abstract class that implements most of the basic servlet methods you’ll need, including those from the Servlet interface.
Most of your servlet’s “servlet behavior” comes from this class.
The Servlet interface says that all servlets have these five methods (the three in bold are lifecycle methods)
All you do is override the HTTP methods you need.
The Container calls init() on the servlet instance after the servlet instance is created but before the servlet can service any client requests.
What it’s for Gives you a chance to initialize your servlet before handling any client requests.
If you have initialization code (like getting a database connection or registering yourself with other objects), then you’ll override the init() method in your servlet class.
Your job is to override the doGet() and/or doPost() methods and let the service() implementation from HTTPServlet worry about calling the right one.
We’re including only doGet() and doPost() here, because those two are probably the only ones you’ll ever use.
What it’s for This is where your code begins! This is the method that’s responsible for whatever the heck your web app is supposed to be DOING.
You can call other methods on other objects, of course, but it all starts from here.
Do you override it? ALWAYS at least ONE of them! (doGet() or doPost())
Whichever one(s) you override tells the Container what you support.
If you don’t override doPost(), for example, then you’re telling the Container that this servlet does not support HTTP POST requests.
The HttpServlet service() method then calls my overridden doGet() or.
So each time my doGet() or doPost() runs, it’s in a separate thread.
Thread A Thread B The Container calls init() on the servlet instance after the servlet instance is created but before the servlet can service any client requests.
If  you have initialization code (like getting a database connection or registering yourself  with other objects), then you’ll override the init() method in your servlet class.
When the first client request comes in, the Container starts (or finds) a thread and causes the servlet’s service() method to be invoked.
You normally will NOT override the service() method, so the one from HttpServlet will run.
The doGet() and doPost() inside HttpServlet don’t do anything, so you have to override one or both.
This thread dies (or is put back in a Container-managed pool) when service() completes.
Thread C When the second (and all other) client requests come in, the Container again creates or finds a another thread and causes the servlet’s service() method to be invoked.
So, the service() --> doGet() method sequence happens each time there’s a client request.
You might, for example, have a Container that lets you specify the maximum number of  simultaneous threads, and when the number of  client requests exceeds that, some clients will just have to wait.
The service() method is always called in its own stack...
Each request runs in a separate  thread! You might hear people say things like, “Each instance of  the servlet...” but that’s just wrong.
There aren’t multiple instances of  any servlet class, except in one special case (called SingleThreadModel, which is inherently evil), but we’re not talking about that special case yet.
The Container runs multiple threads to process multiple requests to a single servlet.
And every client request generates a new pair of  request and response objects.
Each client gets a separate thread for each request, and the Container allocates new request and response objects.
What happens if the same client makes multiple requests? Is it one thread per client or one thread per request?
The Container doesn’t care who makes the request—every incoming request means a new thread/stack.
Q: What if the Container uses clustering, and distributes the app on more than one JVM?
A: Imagine the picture above is for a single JVM, and each JVM has the same picture.
So for a distributed web app, there would be one instance of a particular servlet per JVM, but each JVM would still have only a single instance of that servlet.
In the beginning: loading and initializing The servlet starts life when the Container finds the servlet class file.
This virtually always happens when the Container starts up (for example, when you run Tomcat)
When the Container starts, it looks for deployed web apps and then starts searching for servlet class files.
In the Deployment chapter, we’ll go into more details of  how, why, and where the Container looks for servlets.
Loading the class is the second step, and it happens either on Container startup or first client use.
Your Container might give you a choice about class loading, or it might load the class whenever it wants.
Regardless of  whether your Container gets the servlet ready early or does it justin-time when the first client needs it, a servlet’s service() method will not run until the servlet is fully initialized.
Your servlet is always loaded and initialized BEFORE it can service its first client request.
Why is there an init() method? In other words, why isn’t the constructor enough for initializing a servlet?
What kind of code would you put in the init() method?
What do you think the argument to the init() method might be, and how (or why) would you use it?
A servlet moves from does not exist to initialized (which really means ready to service client requests), beginning with a constructor.
But the constructor makes only an object, not a servlet.
To be a servlet, the object needs to be granted servletness.
When an object becomes a servlet, it gets all the unique privileges that come with being a servlet, like the ability to use its ServletContext reference to get information from the Container.
Why do we care about initialization details? Because somewhere between the constructor and the init() method, the servlet is in a Schroedinger’s* servlet state.
You might have servlet initialization code, like getting web app configuration info, or looking up a reference to another part of  the application, that will fail if  you run it too early in the servlet’s life.
It’s pretty simple though, if  you remember to put nothing in the servlet’s constructor!
The proudest moment of my life is when the Grand Master Container makes.
If your quantum mechanics is a little rusty—you might want to do a Google search on “Schroedinger’s Cat”
When we refer to a Schroedinger state, we mean something that is neither fully dead or fully alive, but in some really weird place in between.
Use it to pass deploy-time information to the servlet (a database or enterprise bean lookup name, for example) that you don’t want to hard-code into the servlet (servlet init parameters)
Use it to access web app parameters (also confi gured in the Deployment Descriptor)
Use it as a kind of application bulletin-board, where you can put up messages (called attributes) that other parts of the application can access (way more on this in the next chapter)
Use it to get server info, including the name and version of the Container, and the version of the API that’s supported.
It’s about d eploytime values you’ve confi gured f or the.
In the next chapter we’ll look at ServletConfig and ServletContext, but for now, we’re digging into details of  the request and response.
Because the ServletConfig and ServletContext exist only to support your servlet’s One True Job: to handle client requests! So before we look at how your context and config objects can help you do your job, we have to back up a little and look at the fundamentals of  the request and response.
You already know that you’re handed a request and response as arguments to the doGet() or doPost() method, but what powers do those request and response objects give you? What can you do with them and why do you care?
Label the missing pieces (the empty boxes) of this lifecycle timeline.
Check your answers with the timeline shown earlier in this chapter.
Add your own annotations as well to help you remember the details.
Request and  Response: the key to everything, and the arguments to service ()*
The request and response objects are also arguments to the other HttpServlet methods that you write— doGet(), doPost(), etc.
The classes aren’t in the API because they’re left to the vendor to implement.
The good news is, you don’t have to worry about it.
You should never care about the actual implementation class name or type.
In other words, all you need to know are the methods you can call on the objects the Container gives you as part of the request! The actual class in which they’re implemented doesn’t matter to you—you’re referring to the request and response objects only by the interface type.
When one interface extends another interface (which is all they can do—interfaces can’t implement interfaces), it means that whoever implements an interface must implement all the methods defined in both the interface and its superinterfaces.
This means, for example, that whoever implements HttpServletRequest must provide implementation methods for the methods declared in the HttpServletRequest interface and the methods in the ServletRequest interface.
Q: I’m still confused about why there’s a GenericServlet and ServletRequest and ServletResponse.
Somebody, somewhere, one could imagine, is using the servlet technology model without the HTTP protocol.
Still, the flexibility was designed into the servlet model for those who might want to use servlets with, say, SMTP or perhaps a proprietary custom protocol.
The only support built-in to the API, though, is for HTTP, and that’s what virtually everyone’s using.
You’re not expected to know anything about how you might use servlets with a protocol other than HTTP.
You are, however, still supposed to know how the class hierarchy works.
All but one of  the eight has a matching doXXX() method in the HttpServlet class, so besides doGet() and doPost(), you’ve got doOptions(), doHead(), doTrace(), doPut(), and doDelete()
There’s no mechanism in the servlet API for handling doConnect(), so it’s not part of  HttpServlet.
But while the other HTTP Methods might matter to, say, a web server developer, a servlet developer rarely uses anything but GET and POST.
For most (or probably all) servlet development, you’ll use either doGet() (for simple requests) or doPost() (to accept and process form data), and you won’t have to think about the others.
The  HTTP request Method determines whether doGet() or doPost() runs The client’s request, remember, always includes a specific HTTP Method.
If  the HTTP Method is a GET, the service() method calls doGet()
If  the HTTP request Method is a POST, the service() method calls doPost()
Actually, one or more of the other HTTP Methods might make a (brief) appearance on the exam...
In the real servlet world, you care about GET and POST.
In the exam world, you care just a tiny bit about the other HTTP Methods as well.
If  you’re preparing for the exam, you should be able to recognize all of  them from a list, and have at least the briefest idea of  what they’re used for.
So it’s just like GET, but with no body in the response.
Gives you info about the requested URL without actually getting back the real thing.
The difference between GET and POST POST has a body.
Both GET and POST can send parameters, but with GET, the parameter data is limited to what you can stuff  into the Request line.
This time, the parameters are down here in the body, so they aren’t limited the way they are if you use a GET and have to put them in the Request line.
Sounds like the difference between GET and POST is the size of.
No, it’s not just about the size We talked about other issues with GET in chapter one, remember?
When you use GET, the parameter data shows up in the browser’s input bar, right after actual URL (and separated with a “?”)
Imagine a scenario in which you would not want the parameters to be visible.
Still another issue is whether you need or want end-users to be able to bookmark the request page.
That might be really important if  you have, say, a page that lets users specify search criteria.
The users might want to come back a week later and try the same search again now that there’s new data on the server.
But besides size, security, and bookmarking, there’s another crucial difference between GET and POST—the way they’re supposed to be used.
Sure, you might use the parameters to help figure out what to send back, but the point is—you’re not making any changes on the server! POST is meant to be used for sending data to be processed.
This could be as simple as query parameters used to figure out what to send back, just as with a GET, but when you think of  POST, think: update.
Think: use the data from the POST body to change something on the server.
If  it’s not, you could get into the kind of  trouble a little blue pill can’t fix.
If  you’re not familiar with the way the term “idempotent” is used in the web world, keep reading...
Browser sends an HTTP request to the server with the book purchase info and Diane’s customer ID number.
The story of the non- idempotent request Diane has a need.
She’s trying desperately to purchase Head First Knitting from the Wickedly Smart online book shop which, unbeknownst to Diane, is still in beta.
Diane’s low on money—she has just enough in her debit account to cover one book.
She considered buying directly  from Amazon or the O’Reilly.com site, but decided she wanted an autographed copy, available only from the Wickedly Smart site.
The Container sends the request to the Checkout servlet for processing.
Servlet does NOT send an obvious response, so Diane still sees the same shopping cart page and thinks...
Browser sends an HTTP request to the server with the book purchase info and Diane’s customer ID number.
The Container sends the request to the Checkout servlet for processing.
Servlet electronically debits Diane’s bank account for the second time.
Diane’s bank accepts the debit, but charges her a hefty overdraft fee.
The servlet does not have a problem with Diane buying the same book she bought before.
I guess she really likes this knitting book a lot...
We’ll let her buy this book, but we’ll charge her.
Eventually Diane navigates to the Check Order Status page and sees that she has TWO orders for the knitting book...
What stupid web app developer made THIS? It should have.
What are some of the ways in which a developer could reduce the risk of this?
It means you can do the same thing over and over again, with no unwanted side effects!
Servlet sends back a response with a generated HTML  page.
Servlet sends back a response with a generated HTML  page.
It’s up to you to make sure that your web app logic can handle scenarios like Diane’s, where the POST comes in more than once.
An HTTP GET is just for getting things, and it’s not supposed to change anything on the server.
So a GET is, by definition (and according to the HTTP spec) idempotent.
It can be executed more than once without any bad side effects.
So you have to be careful with your doPost() functionality!
Note: there are several different uses of the word “idempotent”; we’re using it in the HTTP/servlet way to mean that the same request can be made twice with no negative consequences on the server.
We do *not* use “idempotent” to mean that the same request always returns the same response, and we do NOT mean that a request has NO side effects.
What determines whether the browser sends a GET or POST request?
What happens if you do NOT say method=“POST” in your <form>?
FAILURE! If your HTML form uses GET instead of POST, then you MUST have doGet() in your servlet class.
If  you don’t put method=“POST” into your form, the default is an HTTP GET request.
That means the browser sends the parameters in the request header, but that’s the least of  your problems.
Because if  the request comes in as a GET, that means you’ll run into big trouble at runtime if  you have only a doPost() and not a doGet() in your servlet!
Q: What if I want to support both GET and POST from a single servlet?
A: Developers who want to support both methods usually put logic in doGet(), then have the.
The browser will send one of thes e four options.
Remember, the browser generates this request, so you don’t have to worry about creating it, but here’s what it looks like coming over to the server...
In this example, the String colorParam has a value of “dark”
The browser will send one of thes e four options in.
The browser will send one of these three options in the request, associated with the name “body”
Now the String variable colorParam has a value of “dark” and bodyParam has a value of “heavy”
Some form input types, like a set of checkboxes, can have more th.
In your code, you’ll use the get ParameterValues() method tha.
If you want to see everything in th e array, just for fun or testing, you.
You can have multiple value s for a single parameter! Tha.
Besides parameters, what else can I get from a  Request object? The ServletRequest and HttpServletRequest interfaces have a ton of  methods you can call, but you don’t need to memorize them all.
On your own, you really should look at the full API for javax.servlet.
In the real world, you’ll be lucky (or unlucky, depending on your perspective), to use more than 15% of  the request API.
Don’t worry if you aren’t clear about how or why you’d use each of these; we’ll see more details on some of  them (especially cookies) later in the book.
Q: Why would I ever want to get an InputStream from the request? A: With a GET request, there’s nothing but the request header info.
It is also possible to create a servlet that proceses a computer-driven request in which the body of the request holds textual or binary content to be processed.
In this case you can use the getReader or getInputStream methods.
These streams will only contain the body of the HTTP request and not the headers.
Q: What’s the diff erence between  getHeader() and  getIntHeader()? Far as I can tell, headers are always Strings!  Even the getIntHeader() method takes a String representing the name of the  header, so what’s the int about?
But if you know the value of the header is supposed to represent an int, you can use getIntHeader() as a convenience method to save the extra step of parsing the String to an int:
The Container initializes a servlet by loading the class, invoking the servlet’s no-arg constructor, and calling the servlet’s init() method.
The init() method (which the developer can override) is called only once in a servlet’s life, and always before the servlet can service any client requests.
The init() method gives the servlet access to the ServletConfi g and ServletContext objects, which the servlet needs to get information about the servlet confi guration and the web app.
The Container ends a servlet’s life by calling its destroy() method.
Most of a servlet’s life is spent running a service() method for a client request.
Every request to a servlet runs in a separate thread! There is only one instance of any particular servlet class.
They should be able to run multiple times without causing any side effects on the server.
If an HTML form does not explicitly say “method=POST”, the request is sent as a GET, not a POST.
If you do not have a doGet() in your servlet, the request will fail.
You can get other things from the request object including headers, cookies, a session, the query string, and an input stream.
The thing the browser gets, parses, and renders for the user.
Typically, you use the response object to get an output stream (usually a Writer) and you use that stream to write the HTML (or some other type of content) that goes back to the client.
The response object has other methods besides just the I/O output, though, and we’ll look at some of  them in a bit more detail.
Most of the time, you use the Response just to send data back to the client.
You call two methods on the response: setContentType() and getWriter()
After that, you’re simply doing I/O to write HTML (or something else) to the stream.
But you can also use the response to set other headers, send errors, and add cookies.
Using the response for I/O OK, yes, we should be using JSPs rather than sending HTML back in the response output stream from a servlet.
Formatting HTML to stick in an output stream’s println() method hurts.
But that doesn’t mean you’ll never have to work with an output stream from your servlet.
There are plenty of  older servers and containers out there that support servlets but not JSPs, so you’re stuck with it.
You don’t have the option of  using JSPs for some other reason, like, you have an incredibly stupid manager who won’t let you use JSPs because in 1998 his brother-in-law told him that JSPs were bad.
Who said that HTML was the only thing you could send back in a response? You might send something other than HTML back to the client.
Imagine you want to send a JAR to the client...
Let’s say you’ve created a download page where the client can get code from JAR files.
Instead of  sending back an HTML page, the response contains the bytes representing the JAR.
You read the bytes of  the JAR file, then write them to the response’s output stream.
Browser sends an HTTP request to the server with the name of the requested servlet (“Code.do”)
Diane is desperate to download the JAR of code for the book she’s using to learn servlets and JSPs.
She navigates to the book’s website and clicks the “code jar” link, which refers to a servlet named “Code.do”
The Container sends the request to the CodeReturn servlet (mapped to the name “Code.do” in the DD) for processing.
The HTTP response now holds the bytes representing the JAR.
The CodeReturn servlet gets the bytes for the JAR, then gets an output stream from the response, and writes out the bytes representing the JAR.
We want the browser to recognize that this is a JAR, not HTML, so we set the content type to “application/jar”
Here’s the key part, but it’s just plain old I/O!! Nothing special, just read the JAR bytes, then write the bytes to the output stream that we get from the response object.
Since the web app was named JarDownload,  then the directory structure looks like the directories in the picture.
The JarDownload directory is inside webapps (as a peer directory to all the other web app directories), then inside JarDownload we put the WEBINF directory, and the code JAR itself.
So the file “bookCode.jar” is sitting at the root level of the JarDownload web app.
Don’t worry, we’ll go into deep penetrating details about the deployment directory structure when we get to the deployment chapter.
What’s the deal with   content type? You might be wondering about this line:
You have to tell the browser what you’re sending back, so the browser can do the right thing: launch a “helper” app like a PDF viewer or video player, render the HTML, save the bytes of  the response as a downloaded file, etc.
And since you’re wondering, yes when we say content type we mean the same thing as MIME type.
Content type is an HTTP header that must be included in the HTTP response.
It’s nice of you to tell me what type you’re sending back.
You don’t need to memorize a bunch of content types.
You should know what  setContentType() does, and how you use it, but you don’t have to know even the most common content types except text/html.
What you need to know about setContentType() is mostly common sense...
But that does mean that you can’t set a content type, write some stuff, and then.
But think about it—how would the browser deal with that? It can handle only one type of THING at a.
To make sure everything works correctly, your best practice (and in some cases a requirement) is to always call setContentType() fi rst, BEFORE you call the method that gives you your output stream (getWriter() or getOutputStream())
That’ll guarantee you won’t run into conﬂ icts between the content type and the output stream.
Q: Why do you have to set the content type?  Can’t servers figure it out from the extension of the file?
But we’re talking about what happens inside a servlet where there IS no file! You’re the one who is sending back the response; the Container has no idea what you’re sending.
Q: But what about that last example where you read a specific JAR file? Can’t the Container see that you’re reading a JAR?
All we did from the servlet was read the bytes of a file (that just happened to be a JAR file), and turn around and write those bytes to the output stream.
The Container has no idea what we were up to when we read those bytes.
For all it knows we’re reading from one type of thing and writing something completely different in the response.
Q: How can I find out what the common content types are?
New MIME types are being added all the time, but you can easily find lists on the Web.
You can also look in your browser preferences for a list of those that have been configured for your browser, and you can check your Web server configuration files as well.
Again, you don’t have to worry about this for the exam, and it’s not likely to cause you much stress in the real world either.
You COULD configure the web server so that the user clicks an HTML link that goes to, say, the JAR file sitting on the server (just like any other static resource including JPEGs and text files), and the server just sends it back in the response.
You might, for example, need logic in the servlet that determines which JAR file to send.
Or you might be sending back bytes that you’re creating right there on-the-fly.
Imagine a system where you take input parameters from the user, and then use them to dynamically generate a sound that you send back.
In other words, sound that’s not sitting on the server as a file somewhere.
You just made it up, and now you’re sending it back in the response.
So you’re right, perhaps our example of just sending back a JAR sitting on the server is a little contrived, but come on...
Maybe it’s something as simple as putting code in your servlet thatalong with sending back the JAR—writes some info to a database about this particular user.
Or maybe you have to check to see if he’s even allowed to download this JAR, based on something you first read from the database.
Although you can still write character data to an OutputStream, this is the stream that’s designed to handle character data.
If you already use java.io, then you’ve been down this road.
Make sure you remember that the method names for getting the stream or the writer both drop the fi rst word in the returned type:
There’s just ONE output stream back to the client, but the PrintWriter “decorates” the stream by adding higher-level character-friendly methods.
You can set response  headers, you can add response headers And you can wonder what the difference is.
But think about it for a second, then do this exercise.
If a header with this name is already in the response, the value is replaced with this value.
Otherwise, adds a new header and value to the response.
A convenience method that replaces the value of an existing header with this integer value, or adds a new header and value to the response.
Adds a new header and value to the response, or adds an additional value to an existing header.
But for the exam, you should have them memorized so that if next Tuesday the guy down the hall asks, “What’s that response method that lets me add a value to an existing header?” you can, without the slightest pause, say “It’s addHeader, and it takes two Strings for the name and value.” Just like that.
Both setHeader() and addHeader() will add a header and value to the response if  the header (the first argument to the method)is not already in the response.
The difference between set and add shows up when the header is there.
The setHeader() method won’t complain if  you misspell the header names—it just thinks you’re adding a new kind of  header.
But something else will fail later, because now you haven’t properly set the content type of  the response!
Draw a line from the HttpResponse method to the method’s behavior.
The first person to send us an mp3 file of them actually reciting this poem, with the right timing and everything, gets a special edition t-shirt.
But sometimes you just don’t want to deal with the response yourself...
You can choose to have something else handle the response for your request.
You can  either  redirect the request to a completely different URL, or you can  dispatch the request to some other component in your web app (typically a JSP)
The HTTP response has a status code “301” and a “Location” header with a URL as the value.
The browser gets the response, sees the “301” status code, and looks for a.
The servlet decides that the request should go to a completely different URL.
There’s nothing unique about the request, even though it happened to be triggered by a redirect.
The browser makes a new request using the URL that was the value of the “Location” header in the previous response.
The user might notice that the URL in the browser bar changed...
Servlet redirect makes the browser do the work A redirect lets the servlet off  the hook completely.
After deciding that it can’t do the work, the servlet simply calls the sendRedirect() method:
You can use a  relative  URL as the argument to sendRedirect(), instead of  specifying the whole “http://www...” thing.
Relative URLs come in two flavors: with or without a starting forward slash (“/”)
When the request comes into the servlet named “bar.do”, the servlet calls sendRedirect() with a relative URL that does NOT start with a forward slash:
The Container builds the full URL (it needs this for the “Location” header it puts in the HTTP response) relative to the original request URL:
But if  the argument to sendRedirect() DOES start with a forward slash:
The Container builds the complete URL relative to the web Container itself, instead of  relative to the original URL of  the request.
The forward slash at the beginning means “relative to the root of this web Container”
When the request comes into the servlet named “bar.do”, the servlet calls sendRedirect() with a relative URL that does NOT start with a forward slash:
The Container builds the full URL (it needs this for the “Location” header it puts in the HTTP response) relative to the original request URL:
When the request comes into the servlet named “bar.do”, the servlet calls sendRedirect() with a relative URL that does NOT start with a forward slash:
The Container builds the full URL (it needs this for the “Location” header it puts in the HTTP response) relative to the original request URL:
No ! It looks so right, but it’s SO wrong.
You can’t do a sendRedirect() after writing to the response!
A  request  dispatch does the work on the server side And that’s the big difference between a redirect and a request dispatch—redirect makes the client do the work while request dispatch makes something else on the server do the work.
We’ll say more about request dispatch in a later chapter, but these two pages should give you a quick look at the highlights.
The browser gets the response in the usual way, and renders it for the user.
Since the browser location bar didn’t change, the user does not know that the JSP generated the response.
The servlet decides that the request should go to another part of the web app (in this case, a JSP)
I’ll forward you the details on how to get back to him, but I need you to take over now.
When a servlet does a redirect, it’s like asking the client to call someone else instead.
In this case, the client is the browser, not the user.
When a servlet does a request dispatch, it’s like asking a co-worker to take over working with a client.
The co-worker ends up responding to the client, but the client doesn’t care as long as someone responds.
The user never knows someone else took over, because the URL in the browser bar doesn’t change.
The method you call on your response for getting a binary stream is getOutputStream()
The setContentType() method tells the browser how to handle the data coming in with the response.
The difference depends on whether the header is already part of the response.
If it is, setHeader() will replace the value, but addHeader will add an additional value to the existing response.
If the header is not already part of the response, then setHeader() and addHeader() behave in exactly the same way.
If you don’t want to respond to a request, you can redirect the request to a different URL.
The browser takes care of sending the new request to the URL you provide.
A request dispatch (covered more in another chapter) happens on the server, while a redirect happens on the client.
A request dispatch hands the request to another component on the server, usually within the same web app.
A request redirect simply tells the browser to go a different URL.
They should call the service() method from doGet() or doPost() C.
They should call the service() method from the init() method.
This method is typically used for troubleshooting, not for production.
Option B shows the correct method call passing in the header name as a String parameter.
In general the same update should not be applied multiple times.
Option B specifies the correct method and the correct return type.
Option B shows the correct way to set an HTTP header with two String parameters, one representing the header name and the other the value.
Option A is incorrect because it uses a character-oriented PrintWriter.
Options A, B, and C all relate to components of an HTTP request.
They should call the service() method from doGet() or doPost() C.
They should call the service() method from the init() method.
Option D is correct, developers typically focus on the doGet(), and doPost() methods.
In today’s modern web app, many components work together to accomplish a goal.
But how do you tie the pieces together? How do you let components share.
You must understand how the pieces of the web app.
For the servlet and ServletContext initialization parameters: write servlet code to access initialization parameters, and create deployment descriptor elements for declaring initialization parameters.
For the fundamental servlet attribute scopes (request, session, and context): write servlet code to add, retrieve, and remove attributes; given a usage scenario, identify the proper scope for an attribute; and identify multithreading issues associated with each scope.
Describe the elements of the Web container request processing model: Filter, Filter chain, Request and response wrappers, and Web resource (servlet or JSP page)
Describe the Web Container lifecycle event model for requests, sessions, and web applications; create and configure listener classes for each scope life cycle; create and configure scope attribute listener classes; and given a scenario, identify the proper attribute listener to use.
Describe the RequestDispatcher mechanism; write servlet code to create a request dispatcher; write servlet code to forward or include the target resource; and identify the additional requestscoped attributes provided by the container to the target resource.
All of  the objectives in this section are covered completely in this chapter, with the exception of 3.3, which is covered in the Filters chapter.
Most of  what’s in this chapter will come up in other parts of  the book, but if  you’re taking the exam, THIS is the chapter where we expect you to learn and memorize the objective topics.
Kim wants to configure his email address in the DD, not hard-code it inside the servlet class.
I want my email address to show up on the beer web page my servlet makes...
He’d much rather put his email address in the Deployment Descriptor (web.xml file) so that when he deploys his web app, his servlet can somehow “read” his email address from the DD.
That way, he won’t have to hard-code his address in the servlet class, and to change his email he modifies only the web.xml file, without having to touch his servlet source code.
Init Parameters to the rescue You’ve already seen the request parameters that can come over in a doGet() or doPost(), but servlets can have initialization parameters as well.
Once you have a ServletConfig reference, you can call getInitParameter()
But remember, you can’t call it from your constructor! That’s too early in the servlet’s life...
When the Container initializes a servlet, it makes a unique ServletConfig for the servlet.
The Container “reads” the servlet init parameters from the DD and gives them to the ServletConfig, then passes the ServletConfig to the servlet’s init() method.
A: OK, yes, we’ll look at the ServletContext in just a few pages.
For now, we care only about ServletConfig, because that’s where you get your servlet init parameters.
Q: Wait a minute! In the last chapter you said that we could override the init() method, and nobody said a word about the ServletConfi g argument!
A: We didn’t mention that the init() method takes a ServletConfig because the one you override doesn’t take one.
Your superclass includes two versions of init(), one that takes a ServletConfig and a convenience version that’s a no-arg.
The servlet init parameters are read only ONCEwhen the Container initializes the servlet When the Container makes a servlet, it reads the DD and creates the name/value pairs for the ServletConfig.
The Container never reads the init parameters again! Once the parameters are in the ServletConfig, they won’t be read again until/unless you redeploy the servlet.
Container reads the Deployment Descriptor for this servlet, including the servlet init parameters (<init-param>)
Container creates a new ServletConfi g instance for this servlet.
Container gives the ServletConfi g references to the name/value init parameters.
Container calls the servlet’s init() method, passing in the reference to the ServletConfi g.
It’s still way better than putting it in my servlet source.
All I have to do is change the xml and hit the “redeploy” button, and the new address will be in the ServletConfig.
A: With Tomcat, there isn’t a one-button, really simple admin tool for deployment and redeployment (although there is an admin tool that ships with Tomcat)
But think about it—what’s the worst you have to do to change the servlet’s init parameters? You make a quick change to the web.
On restart, Tomcat looks in its webapps directory, and deploys everything it finds there.
Q: Sure it’s easy to tell Tomcat to shutdown and startup, but what about the web apps that are running? They all have to go down!
Taking your web apps down so that you can redeploy one servlet is a little harsh, especially if you have a lot of traffic on your web site.
But that’s why most of the production-quality Web Containers let you do a hot redeploy, which means that you don’t have to restart your server or take any other web apps down.
In fact, Tomcat does include a manager tool that will let you deploy, undeploy, and redeploy entire web apps without restarting.
But in the real world, even a hot redeploy is a Big Deal, and taking even a single app down just because the init parameter value changed can be a bad idea.
If the values of your init parameters are going to change frequently, you’re better off having your servlet methods get the values from a file or database, but this approach will mean a lot more overhead each time your servlet code runs, instead of only once during initialization.
Testing your ServletConfig ServletConfig’s main job is to give you init parameters.
It can also give you a ServletContext, but we’ll usually get a context in a different way, and the getServletName() method is rarely useful.
How can a JSP get servlet init parameters? A ServletConfig is for servlet configuration (it doesn’t say JSPConfig)
So if  you want other parts of  your application to use the same info you put in the servlet’s init parameters in the DD, you need something more.
What about the way we did it with the beer app? We passed the model info to the JSP using a request attribute...
The request object lets you set attributes (think of  them as a name/value pair where the value can be any object) that any other servlet or JSP that gets the request can use.
That means any servlet or JSP to which the request is forwarded using a RequestDispatcher.
We’ll look at RequestDispatcher in detail at the end of this chapter, but for now all we care about is getting the data (in this case the email address) to the pieces of  the web app that need it, rather than just one servlet.
Then we instantiated and used the MODEL to get the info we need for the VIEW.
Since that JSP needed the model data and the data was relevant to only that particular request, everything was fine.
But that doesn’t help us with the email address, because we might need to use it from all over the application! There is a way to have a servlet read the init parameters and then store them in a place other parts of  the app could use, but then we’d have to know which servlet would always run first when the app is deployed, and any changes to the web app could break the whole thing.
But I really want ALL the parts of my web app to have access to the email address.
I have to configure them in the DD for every servlet, and then have all the servlets make them available for the JSPs.
I wonder if there’s something like init parameters for the.
Context init parameters to the rescue Context init parameters work just like servlet init parameters, except context parameters are available to the entire webapp, not just a single servlet.
So that means any servlet and JSP in the app automatically has access to the context init parameters, so we don’t have to worry about configuring the DD for every servlet, and when the value changes, you only have to change it one place!
Here we broke out the code into TWO steps—getting the ServletContext reference, and calling its getInitParameter() method.
Remember the difference between servlet init parameters and context init parameters Here’s a review of  the key differences between context init parameters and servlet init parameters.
Pay special attention to the fact that they’re both referred to as init parameters, even though only servlet init parameters have the word “init” in the DD configuration.
To any servlets and JSPs that are part of this web app.
To only the servlet for which the <init-param> was configured.
Although the servlet can choose to make it more widely available by storing it in an attribute.
Notice it doesn’t say “init” anywhere in the DD for context init parameters, the way it does for servlet init parameters.
ServletConfig is one per servlet ServletContext is one per  web app There’s only one ServletContext for an entire web app, and all the parts of  the web app share it.
But each servlet in the app has its own ServletConfig.
The Container makes a ServletContext when a web app is deployed, and makes the context available to each Servlet and JSP (which becomes a servlet) in the web app.
Container reads the DD and creates a name/value String pair for each <context-param>
Container gives the ServletContext a reference to each name/value pair of the context init parameters.
Every servlet and JSP deployed as part of a single web app has access to that same ServletContext.
If your application is distributed across multiple servers (probably in a clustered environment), your web app really COULD have more than one ServletContext.
A ServletContext is one per app, but only if the app is in a single JVM! In a distributed environment, you’ll have one ServletContext per JVM.
Now, chances are this won’t create problems, but if you have a distributed web app, you better consider the consequences of having different contexts for each JVM.
If the app is distributed, there’s one ServletContext per JVM!
A: They didn’t ask us to help them come up with the names.
But no, that would have sucked all the fun out of trying to keep them straight.
A: It all depends on which part of your app is supposed to see the value.
Your application logic might require you to use a value that you want to restrict to only an individual servlet.
But typically, developers find app-wide context init parameters a lot more helpful than servlet-specific servlet init parameters.
Perhaps the most common use of a context parameter is storing database lookup names.
You’d want all parts of your app to have access to the correct name, and when it changes, you want to change it in only one place.
Q: What happens if I give a context init parameter the same name as a servlet init parameter in the same web app?
A: The molecular-sized black hole miraculously created in a research facility in New Jersey will slip from its containment field, plummet to the earth’s core, and destroy the planet.
Or  maybe nothing, because there’s no name space conflict since you get the parameters through two different objects (ServletContext or ServletConfig)
Q: If you modify the XML to change the value of an init parameter (either servlet or context), when does the servlet or the rest of the web app see the change?
Remember—we talked about this before—the servlet is initialized only once, at the beginning of its life, and that’s when it’s given its ServletConfig and ServletContext.
The Container reads the values from the DD when it creates those two objects, and sets the values.
Q: Can’t I get around this by setting the values at runtime? Surely there’s an API that’ll let me change those values dynamically...
If you think of them purely as deploy-time constants, you’ll have the right perspective.
In fact, that’s so important we’re going to say it again in a bolder way:
You can get them at runtime, but you can’t set them.
We know that as a developer, you ’ll be kinder to others and.
Rearrange the magnets to form a DD that declares a parameter that matches the servlet code:
You can’t deploy a web.xml file unless the <web-app> tag has all the attributes it needs.
So what else can you do with your  ServletContext? A ServletContext is a JSP or servlet’s connection to both the Container and the other parts of  the web app.
We put the ones you should know for the exam in bold.
Before I came into your life, you were just another loser object instead of a real servlet.
Q: How do all the parts of a web app get access to their own ServletContext?
For JSPs it’s a little different—JSPs have something called “implicit objects”, and ServletContext is one of them.
You’ll see exactly how a JSP uses a ServletContext when we get to the JSP chapters.
Q: So you get built-in logging through your context? That sounds VERY helpful!
Not unless you have a really small, simple web app.
The most popular, robust logging mechanism is Log4j; you can find it on the Apache site at:
It’s fine to use the ServletContext log() method for simple experiments, but in a real production environment, you will almost certainly want to choose something else.
Logging is not part of the exam objectives, but it’s important.
A servlet’s ServletConfi g object always holds a reference to th.
Not only is that legal, but it does t he same thing as:
In a servlet, the only time you wo uld NEED to go through your.
ServletConfi g to get your Servl etContext is if you’re in a Servle.
But what if the code is inside so me class that is NOT a servlet.
Hate to spoil your ServletContext party, but, um, those init parameters can’t be.
What if you want an app init parameter that’s a database DataSource? Context parameters can’t be anything except Strings.
After all, you can’t very well stuff  Dog object into an XML deployment descriptor.
Actually, you could represent a serialized object in XML, but there’s no facility for this in the Servlet spec today...
What if  you really want all the parts of your web app to have access to a shared database connection? You can certainly put the DataSource lookup name in a context init parameter, and that’s probably the most common use of  context parameters today.
But then who does the work of  turning the String parameter into an actual DataSource reference that all parts of  the web app can share?
You can’t really put that code in a servlet, because which servlet would you choose to be The One To Lookup The DataSource And Store It In An Attribute? Do you really want to try to guarantee that one servlet in particular will always run first? Think about it.
How could you initialize a web app with an object? Assume that you need the String context init parameter in order to create that object (think about the database example)
Oh, if only there were a way to have something like a main.
Some code that always runs before ANY servlets or JSPs...
She wants to listen for a context initialization event, so that she can get the context init parameters and run some code before the rest of the app can service a client.
She needs something that can be sitting there, waiting to be notified that the app is starting up.
But which part of  the app could do the work? You don’t want to pick a servlet—that’s not a servlet’s job.
There’s no problem in a plain old standalone Java app, because you’ve got main()! But with a servlet, what do you do?
Use the init parameter lookup name to make a database connection.
Store the database connection as an attribute, so that all parts of the web app can access it.
Now what do I do? Where do I put the.
What do you think the mechanism might be for making a listener be part of a specific web app?
Hint: how do you tell the Container about the other parts of your web app? Where might the Container discover your listener?
This is just a simple test class so that you can see how all the pieces work together; we’re not using the database connection example because you’d have to set up a database to make it work.
But the steps are the same regardless of  the code you put in your listener callback methods.
In this example, we’ll turn a String init parameter into an actual object—a Dog.
The listener then sticks the Dog object into a ServletContext attribute, so that the servlet can retrieve it.
The point is that the servlet now has access to a shared application object (in this case a Dog), and doesn’t have to read the context parameters.
Whether the shared object is a Dog or a database connection doesn’t matter.
The key is to use the init parameters to create a single object that all parts of  the app will share.
In this example, we’ll put a Dog into a ServletContext.
Making and using a context listener Maybe you’re still wondering how the Container discovers and uses the listener...
You configure a listener the same way you tell the Container about the rest of  your web app—through the web.xml Deployment Descriptor!
WEB-INF/classes is one of several places the Container can look for classes.
We need three classes and one DD For our context listener test example, we need to write the classes and the web.xml file.
For ease of  testing, we’ll put all of  the classes in the same package: com.example.
The Dog class is just a plain old Java class.
Its job is to verify that the listener worked by getting the Dog attribute from the context, invoking getBreed() on the Dog, and printing the result to the response (so we’ll see it in the browser)
Writing the listener class It works just like other types of  listeners you might be familiar with, such as Swing GUI event handlers.
Remember, all we need to do is get the context init parameters to find out the dog breed, make the Dog object, and put the Dog into the context as an attribute.
Use the context to set an attribute (a name/object pair) that is the Dog.
Now other parts of the app will be able to get the value of the attribute (the Dog)
Writing the attribute class (Dog) Oh yeah, we need a Dog class—the class representing the object we’re going to store in the ServletContext, after reading the context init parameters.
Q: I thought I read somewhere that servlet attributes had to be Serializable...
There are several different attribute types, and whether the attribute should be Serializable only matters with Session attributes.
And the scenario in which it matters is only if the application is distributed across more than one JVM.
There’s no technical need to have any attributes (including Session attributes) be Serializable, although you might consider making all of your attributes Serializable by default, unless you have a really good reason NOT to.
Think about it—are you really certain that nobody will ever want to use objects of that type as arguments or return values as part of a remote method call? Can you really guarantee that anyone who uses this class (Dog, in this case) will never run in a distributed environment?
So, although you aren’t required to make any attributes Serializable, you probably should if you can.
We’ll use the context init parameter as the argument for the Dog constructor.
If  everything is working right, by the time the Servlet’s doGet() method runs for the first time, the Dog will be waiting as an attribute in the ServletContext.
If things didn’t work, THIS is where we’ll find out...
Writing the Deployment Descriptor Now we tell the Container that we have a listener for this app, using  the <listener> element.
That wouldn’t work because a context listener is for a ServletContext (which means application-wide) event.
The whole point is to initialize the app BEFORE any servlets are initialized.
We just did it that way to make it painfully clear what kind of a class we wrote.
The Container figures it out simply by inspecting the class and noticing the listener interface (or interfaces; a listener can implement more than one listener interface)
Q: Does that mean there are other types of listeners in the servlet API?
A: Yes, there are several other types of listeners that we’ll talk about in a minute.
Create a directory named listenerTest and place it inside the Tomcat webapps directory.
Create a directory named WEB-INF and place it inside the listenerTest directory.
Make a directory structure inside classes that matches your package structure: a directory called com that contains example.
Copy your three compiled fi les into your web app directory structure in Tomcat.
Put your web.xml Deployment Descriptor into the WEB-INF directory for this web app.
Try it out Bring up your browser and let’s hit the servlet directly.
We didn’t bother making an HTML page, so we’ll access the servlet by typing in the URL from the servlet mapping in the DD (ListenTest.do)
Check the String name used in setAttribute() and make sure it matches the String name you’re using in getAttribute()
Recheck your web.xml and make sure the <listener> is registered.
Try looking at the server logs and see if  you can find out if  the listener is actually being called.
To make it as confusing as possible, we gave everything a subtly different name.
We want to make sure you’re paying attention to how these names are used, and when you name everything the same, it’s tough to tell how the names affect your app.
Here’s the scenario from start (app initialization) to finish (servlet runs)
You’ll see in step 11 we condensed the Servlet initialization into one big step.
Container creates a new ServletContext for this application, that all parts of the app will share.
The event object has a reference to the ServletContext, so the eventhandling code can get the context from the event, and get the context init parameter from the context.
Listener uses the init parameter to construct a new Dog object.
Listener sets the Dog as an attribute in the ServletContext.
Container makes a new Servlet (i.e., makes a new ServletConfig with init parameters, gives the ServletConfig a reference to the ServletContext, then calls the Servlet’s init()  method)
Servlet calls getBreed() on the Dog (and prints that to the HttpResponse)
Where there’s a lifecycle moment, there’s usually a listener to hear about it.
Besides context events, you can listen for events related to context attributes, servlet requests and attributes, and HTTP sessions and session attributes.
You don’t have to know all of the listener API.
The exam objectives are clear: you’ll be given a scenario (a developer’s goal for an application) and you’ll need to decide which is the right type of listener, or whether it’s even POSSIBLE to be notified of that lifecycle event.
Note: we don’t talk about sessions until the next chapter, so don’t worry about it if you don’t yet know what an HTTP session is or why you care...
You want to know if an attribute in a web app context has been added, removed, or replaced.
You want to know how many concurrent users there are.
In other words, you want to track the active sessions.
You want to know each time a request comes in, so that you can log it.
You want to know when a request attribute has been added, removed, or replaced.
You have an attribute class (a class for an object that will be put in an attribute) and you want objects of this type to be notified when they are bound to or removed from a session.
You want to know when a session attribute has been added, removed, or replaced.
Exercise Match the scenario on the left with the listener interface (at the bottom of the page) that supports that goal.
See what you can come up with just by looking at the names.
You want to know if an attribute in a web app context has been added, removed, or replaced.
You want to know how many concurrent users there are.
In other words, you want to track the active sessions.
You want to know each time a request comes in, so that you can log it.
You want to know when a request attribute has been added, removed, or replaced.
You have an attribute class (a class for an object that will be stored as an attribute) and you want objects of this type to be notified when they are bound to or removed from a session.
You want to know when a session attribute has been added, removed, or replaced.
You want to know if a context has been created or destroyed.
You have an attribute class, and you want objects of this type to be notified when the session to which they’re bound is migrating to and from another JVM.
I get that the Dog (an attribute that’ll be added to a session) wants to know when it’s in or out of a session.
If you don’t know about entity beans, you should run to your nearest bookstore and buy two copies of Head First EJB (one for you, one for your significant other so you can share special moments discussing it)
In the meantime, here’s a way to think about it—imagine.
You use the database info to populate the fields of the Customer object, but the issue is how and when do you keep the database record and the Customer info synchronized? You know that whenever a Customer object is added to a session, it’s time to refresh the fields of the Customer with this customer’s data from his record in the database.
They use the word “bound” and “unbound” to mean “added to” and “removed from”
Exercise Do your best to fill in the slots in this table.
Keep in mind that the listener interfaces and methods follow a consistent naming pattern (mostly)
What, exactly, is an  attribute? We saw how the ServletContext listener created a Dog object (after getting the context init parameter) and was able to stick (set) the Dog into the ServletContext as an attribute, so that other parts of  the app could get it.
You can think of  it as simply a name/value pair (where the name is a String and the value is an Object) in a map instance variable.
In reality, we don’t know or care how it’s actually implemented—all we really care about is the scope in which the attribute exists.
In other words, who can see it and how long does it live.
An attribute is like an object pinned to a bulletin board.
Somebody stuck it on the board so that others can get it.
The big questions are: who has access to the bulletin board, and how long does it live? In other words, what is the scope of the attribute?
We saw how the ServletContext listener created a Dog object (after getting the context init parameter) and was able to stick (set) the Dog into the ServletContext as an attribute, so that other parts of  the app could get it.
Earlier, with the beer tutorial, we saw how the servlet was able to stick the results of  the call to the model into the.
In reality, we don’t know or care how it’s actually implemented—all we really.
Who can see this bulletin board? Who can get and set the attributes?
Attributes are not parameters ! If  you’re new to servlets, you might need to spend some time reinforcing the difference between attributes and parameters.
Rest assured that when we created the exam we spent just that little bit of  extra time trying to make sure we made attribute and parameter questions as confusing as possible.*
If we’d made the exam simple and straightforward and easy, you wouldn’t feel that sense of pride and accomplishment from passing the exam.
Making the exam difficult enough to ensure that you’d need to buy a study guide in order to pass it was never, EVER, a part of our thinking.
There is no servletspecific attribute (just use an instance variable)
Don’t forget that attributes must be cast, since the return type is Object.
The Three   Scopes: Context, Request, and Session You can put an attribute into context scope, request scope, or session scope.
The scope controls accessibility (who can get and set the attribute) and lifetime (how long the attributes exists)
If  you understand scope, you’ll always know the best place to put your attributes, given a scenario or goal.
You want the scope to be what you need, but no greater.
Controller app, the model info needed to make the view for one specific client request doesn’t need visibility or life beyond the request, so you wouldn’t put the attribute in the context or session scope.
Accessible to only those with access to a specifi c HttpSession.
Accessible to only those with access to a specifi c ServletRequest.
Exercise Do your best to fill in the slots in this table.
You REALLY need to understand attribute scope for the exam (and the real world) because you have to know which scope is the best to use for a given scenario.
You’ll see the answer in a few pages, but don’t look ahead! If you’re going to take the exam, trust us...
Note: you should think about the implications of garbage collection when you think about scope...
Attribute API The three attribute scopes—context, request, and session—are handled by the ServletContext, ServletRequest, and HttpSession interfaces.
The API methods for attributes are exactly the same in every interface.
He sets an attribute and then immediately gets the value of  the attribute and displays it in the response.
Here’s what he sees the first time he runs it.
The second time he runs it, he’s shocked to see:
Look closely at the code, and think about what’s happening.
You might not have enough info to solve the mystery, so here’s another clue: Kim put this code in a test servlet that’s part of a larger test web app.
In other words, the servlet that holds this doGet() method was deployed as part of a larger app.
Can you think of how he might fi x it?
Remember, everyone in the app has access to context attributes, and  that means multiple servlets.
And multiple servlets means you might have multiple threads, since requests are concurrently handled, each in a separate thread.
This happens regardless of  whether the requests are coming in for the same or different servlets.
There must be another servlet hitting the same context attribute...
Yikes! Another servlet that is part of the same web app, running in a separate thread can set the “bar” attribute.
Servlet A sets the context attribute “foo” with a value of “22”
Servlet A sets the context attribute “bar” with a value of “42”
Thread A becomes the running thread again, and gets the value of “bar” and prints it to the response.
Let’s hear what some of  the other developers have to say...
I’m thinking I could synchronize the doGet() method, but that doesn’t really feel right.
The spec says you’re on your own if you need to protect attributes.
OK, so we know that synchronizing the service method will kill our concurrency, but it does give you the thread protection, right? Take a look at this legal code, and decide whether it would prevent the problem Kim had with the context attribute being changed by another servlet...
What do you think? Will it fix the problem Kim had? Look back at the code and the diagrams if you’re not sure.
Synchronizing the service method means that only one thread in a servlet can be running at a time...
Synchronizing the service method would stop other threads from the same servlet from accessing the context attributes, but it won’t do anything to stop a completely different servlet.
If you synchronize the service method, you WILL stop the Container from starting any other methods for new requests coming into servlet A.
So this WILL protect the context attributes from being accessed by more than one thread running a service method of Servlet A.
But you won’t do anything to stop OTHER servlets! Regardless of whether the service methods in other servlets are synchronized or not...
The typical way to protect the context attribute is to synchronize ON the context object itself.
If  everyone accessing the context has to first get the lock on the context object, then you’re guaranteed that only one thread at a time can be getting or setting the context attribute.
It only works if  all of  the other code that manipulates the same context attributes ALSO synchronizes on the ServletContext.
If  code doesn’t ask for the lock, then that code is still free to hit the context attributes.
But if  you’re designing the web app, then you can decide to make everyone ask for the lock before accessing the attributes.
Since we have the context lock, we’re assuming that once we get inside the synchronized block, the context attributes are safe from other threads until we exit the block...
Safe means “safe from any other code that ALSO synchronizes on the ServletContext.” But this is the best you’ve got for making the context attributes as thread-safe as you can.
Servlet For context attributes, it won’t do any good to synchronize on the Servlet, because other parts of the app will still be able to access the context!
On the exam, you’ll see plenty of code showing different strategies for making attributes.
We haven’t talked about HTTP sessions in detail yet (we will in the Sessions chapter), but you already know that a session is an object used to maintain conversational state with a client.
The session persists across multiple requests from the same client.
And if  it’s one client, and a single client can be in only one request at a time, doesn’t that automatically mean that sessions are thread-safe? In other words, even if  multiple servlets are involved, at any given moment there’s only one request from that particular client...
Even though both servlets can access the Session attributes in separate threads, each thread is a separate request.
Can you think of  a scenario in which there could be more than one request at the same time, from the same client?
Listen in as our two black-belts discuss the issues around protecting the state of  attributes from multithreading problems.
We know that context attributes are inherently NOT safe, because all pieces of  the app can access context attributes, from any request (which means any thread)
Yes! The Container can see the request from the second window as coming from the same session.
And how would you protect these session attributes from the havoc of  multiple threads?
And I know that synchronizing the service method is not a solution, because although it will stop that servlet from servicing more than one request at a time, it will NOT stop other servlets and JSPs in the same web app from accessing the context.
They are for only one client, and the laws of  physics prevent a client from making more than one request at a time.
But master, I have meditated and still I do not know how one client could have more than one request...
Very wise advice, master! I have it! The client could open a new browser window! So the Container can still use the same session for a client, even though it’s coming from a different instance of  the browser?
So Session attributes are not thread-safe, and they, too, must be protected.
I must synchronize the part of  my code that accesses the session attributes.
Look at the technique we used to protect the context attributes.
You can do the same thing with session attributes, by synchronizing on the HttpSession object!
Surely you’ve done this yourself without a second thought—opened a second window because you were tired of waiting for the other one to respond, or because you minimized one, or misplaced the window without realizing it, etc.
The point is, you can’t take the chance if you need thread-safety for your session variables.
You have to know that it’s quite possible for a session-scoped attribute to be used by more than one thread at a time.
Q: Isn’t it a bad idea to synchronize code, because it causes a lot of overhead and hurts concurrency?
A: You should ALWAYS think carefully before synchronizing any code, because you’re right—it does add some expense in checking,  acquiring, and releasing locks.
If you need protection, then use synchronization but remember the standard rule of all forms of locking—keep the lock for the shortest amount of time to accomplish your goal! In other words, don’t synchronize the code that doesn’t access the protected state.
Get the lock, get in, get what you need, and get the heck out so the lock can release and other threads can run that code.
Here’s what the servlet specification says about the SingleThreadModel (or STM) interface:
Ensures that servlets handle only one request at a time.
If  a servlet implements this interface, you are guaranteed that no two threads will execute concurrently in the servlet’s service method.
The servlet container can make this guarantee by synchronizing access to a single instance of  the servlet, or by maintaining a pool of  servlet instances and dispatching each new request to a free servlet.
But how does the web container guarantee a servlet gets only one request at a time? The   web container vendor has a choice.
The container can maintain a single servlet, but queue every request and process one request completely before allowing the next request to proceed.
Or the container can create a pool of servlet instances and process each request concurrently, one per servlet instance.
Since MyServlet implements STM, the web container will make sure this servlet only ha.
Which is the better STM implementation? Once  again we must consult our black belts.
These guys must know the score on the best STM implementation.
Queuing the requests to a single servlet makes the most sense.
Yes, but that is the only way to protect the instance variables of  the servlet.
Ahh, you see deeply into the fortune cookie, my student, but you do not see just how deadly that fortune might be...
The servlet spec defines that a single servlet declaration in the deployment descriptor becomes a single object instance at runtime, but now using the STM interface, this definition is no longer valid.
Can you imagine a scenario in which having multiple servlet instances fails?
YES! You have penetrated the depth of  the ruse that is servlet pooling.
The semantics of  the “single servlet instance” definition is lost.
But master, won’t performance be impacted? Surely, queuing each request prevents multiple users from access to the same servlet?
But master, the container may also create a pool of servlet instances.
Then the container can process one request with one servlet instance and another request with a second instance.
Hmm, what if  one of  the instance variables is meant to record how many requests have been processed.
The counter variable would have several different counts, and none of  them would be right...
Place a checkmark next to the things that are NOT thread-safe.
Q: What’s up? Why is the servlet spec so wishy-washy? A: The   specification writers wanted to give the container vendors the opportunity to compete with each other in terms of performance and flexibility.
Q: How do I know which strategy my vendor uses? A: Well, hopefully it is written down in some part of the documentation for the web container.
If not, you should contact your container vendor, and ask them.
Q: How will the STM strategy change how I write my servlet code?
A: If the container uses a queuing strategy, then the “single servlet instance” semantics still hold and you do not need to make any code changes.
But if the container uses a pooling strategy, then the semantics of some instance variables might change.
For example, if you have an instance variable that holds a “request counter,” then that variable no longer can be counted on when multiple servlet instances are created in the pool.
In this case, you could choose to make the counter variable a class variable instead.
Q: But are  class variables thread-safe? A: No, they are not, and the STM mechanism does not help with class variables.
Yes, it protects instance variables from concurrent access, but by pooling multiple instances the semantics of the servlet changes.
Furthermore, STM does not help with other variable or attribute scopes.
Which is why STM has been deprecated from the servlet API!
But you still need to know about it for the exam.
Everything else is subject to manipulation by multiple threads, unless you do something to stop it.
If you have multiple clients making requests on that servlet, that means multiple threads running that servlet code.
And all threads have access to the servlet’s instance variables, so instance variables aren’t thread-safe.
Q: But they WOULD be thread-safe if you implemented the SingleThreadModel, right?
A:  Yes, because you’d never have more than one thread for that servlet, so the instance variables would be thread-safe.
But of course nobody would ever allow you into the servlets club ever again.
The effect of implementing SingleThreadModel is virtually the same as synchronizing the service method.
Both can bring a web app to its knees without protecting the session and context state.
Q: But if you’re not supposed to use SingleThreadModel or synchronize the service method, then how DO you make instance variables threadsafe?
A:  You don’t! Look at a well-written servlet, and chances are you won’t find any instance variables.
And since you’re a Java programmer you know that even a final variable can still be manipulated unless it’s immutable.
So just don’t use instance variables if you need thread-safe state, because all threads for that servlet can step on instance variables.
Q: Then what SHOULD you use if you need multiple instances of the servlet to share something?
A:  Stop right there! You said “multiple instances of the servlet”
We know you didn’t mean that, because there is always only ONE instance of the servlet.
If you want all the threads to access a value, decide which attribute state makes the most sense, and store the value in an attribute.
Chances are, you can solve your problems in one of two ways:
Declare the variable as a local variable within the service method, rather than as an instance variable.
Request attributes and Request dispatching Request attributes make sense when you want some other component of  the app to take over all or part of  the request.
Our typical, simple example is an MVC app that starts with a servlet controller, but ends with a JSP view.
The controller communicates with the model, and gets back data that the view needs in order to build the response.
There’s no reason to put the data in a context or session attribute, since it applies only to this request, so we put it in the request scope.
So how do we make another part of  the component take over the request? With a RequestDispatcher.
The Beer servlet calls the getBrands() method on the model that returns some data that the view needs.
RequestDispatcher, passing in a relative path to the view JSP.
The servlet calls forward() on the RequestDispatcher, to tell the JSP to take over the request.
Not shown: the JSP gets the forwarded request, and gets the “styles” attribute from the Request scope.
Tell JSP to take over the request, and, oh yeah, here are the Request and Response objects.
RequestDispatcher revealed RequestDispatchers have only two methods—   forward() and include()
Both take the request and response objects (which the component you’re forwarding to will need to finish the job)
Of  the two methods, forward() is by far the most popular.
You can get a RequestDispatcher in two ways: from the request or from the context.
Regardless of  where you get it, you have to tell it the web component to which you’re forwarding the request.
In other words, the servlet or JSP that’ll take over.
If the path starts with a forward slash (“/”), the Container sees that as “starting from the root of this web app”
If the path does NOT start with a forward slash, it’s considered relative to the original request.
But you can’t try to trick the Container into looking outside the current web app.
That means you must start the path with a forward slash!
What’s wrong with this code? What do you think? Does this RequestDispatcher code look like it will work the way you’d expect?
That’s the line that causes the res ponse to be sent to.
You’ve already responded, and y ou get only one shot.
So, don’t be fooled if you see que stions on the exam.
Q: How come you didn’t talk about the RequestDispatcher include() method?
For another, we already mentioned that it’s not used much in the real world.
But to satisfy your curiosity, the include() method sends the request to something else (typically another servlet) to do some work and then comes back to the sender!  In other words, include() means asking for help in handling the request, but it’s not a complete hand-off.
With forward(), you’re saying, “That’s it, I’m not doing anything else to process this request and response.”  But with include(),  you’re saying, “I want someone else to do some things with the request and/or response, but when they’re done, I want to finish handling the request and response myself (although I might decide to do another include or forward after that...”)
Lifetime of the ServletContext, which means life of the deployed app.
If server or app goes down, the context is destroyed (along with its attributes)
Resources you want the entire application to share, including database connections, JNDI lookup names, email addresses., etc.
Any part of the application that has direct access to the Request object.
That mostly means only the Servlets and JSPs to which the request is forwarded using a RequestDispateher.
The life of the Request, which means until the Servlet’s service() method completes.
In other words, for the life of the thread (stack) handling this request.
HttpSession Any servlet or JSP with access to this particular session.
Remember, a session extends beyond a single client request to span multiple requests by the same client, which could go to different servlets.
A session can be destroyed programmatically or can simply time-out.
We’ll go into the details in the Session Management chapter.
Data and resources related to this client’s session, not just a single request.
They should be used for data that is specific to a particular servlet.
They should be used for data that is applicable to an entire web application.
Which is most logically stored as an attribute in session scope?
A copy of  a query parameter entered by a user.
The result of  a database query to be returned immediately to a user.
A database connection object used by all web components of  the system.
An object representing a user who has just logged into the system.
A copy of  an initialization parameter retrieved from a ServletContext object.
When a web application is preparing to shutdown, the order of  listener notification is not guaranteed.
When listener-friendly events occur, listener invocation order is not predictable.
The container registers listeners based on declarations in the deployment descriptor.
A RequestDispatcher can be used to forward a request to another servlet.
Parameters specified in the query string used to create a RequestDispatcher are not forwarded by the forward() method.
The servlet to which a request is forwarded may access the original query string by calling getQueryString() on the HttpServletRequest.
What is the recommended way to deal with servlets and thread safety?
Use local variables exclusively, and if  you have to use instance variables, synchronize access to them.
Match the methods above to the following classes or interfaces.
Note that each method can be used more than once.
Depending on the class whose method creates a RequestDispatcher, the path to the resource to be forwarded to will change.
Regardless of  the class whose method creates a RequestDispatcher, the path to the resource to be forwarded to will NOT change.
They should be used for data that is specific to a particular servlet.
They should be used for data that is applicable to an entire web application.
Option C is incorrect because this method does not exist.
Option B is incorrect because ServletContext init parameters are only read at Container start-up time.
Option E is incorrect because there is only one ServletContext object per web application.
Options A and B are incorrect because these methods do not exist.
Options C and E are incorrect because they provide access to servlet-specific initialization parameters.
Options C and D refer to methods that don’t exist.
Which is most logically stored as an attribute in session scope?
A copy of  a query parameter entered by a user.
The result of  a database query to be returned immediately to a user.
A database connection object used by all web components of  the system.
An object representing a user who has just logged into the system.
A copy of  an initialization parameter retrieved from a ServletContext object.
Option B is incorrect because such data is typically either immediately returned or stored in request scope.
Option C is incorrect because (since it is not specific to a particular session) it should be stored in context scope.
Option E is incorrect because servlet context parameters should stay with the ServletContext object.
Tricky!  The getValue method returns the OLD value of the attribute if the attribute was replaced.
Note: The other two types related to servlets, that can store attributes are HttpSession and ServletContext.
When a web application is preparing to shutdown, the order of  listener notification is not guaranteed.
When listener-friendly events occur, listener invocation order is not predictable.
The container registers listeners based on declarations in the deployment descriptor.
Options A and B are incorrect because the container uses the DD to determine the notification order of registered listeners.
A RequestDispatcher can be used to forward a request to another servlet.
Parameters specified in the query string used to create a RequestDispatcher are not forwarded by the forward() method.
The servlet to which a request is forwarded may access the original query string by calling getQueryString() on the HttpServletRequest.
Option B is incorrect because the interface also contains an include method.
Option E is invalid because there is no such type.
Options A, B, and C are invalid because these types do not store attributes.
Option C is incorrect because such parameters are forwarded in this case.
Option D is incorrect because this method returns the query string on the URL pattern from the RequestDispatcher.
What is the recommended way to deal with servlets and thread safety?
Use local variables exclusively, and if  you have to use instance variables, synchronize access to them.
Match the methods above to the following classes or interfaces.
Note that each method can be used more than once.
At this point this shouldn't really about memorization as much as about what methods would make sense in each scope.
Depending on the class whose method creates a RequestDispatcher, the path to the resource to be forwarded to will change.
Regardless of  the class whose method creates a RequestDispatcher, the path to the resource to be forwarded to will NOT change.
Option E: if your servlet uses an RD, it can never send its own response.
As soon as they send you a response, they forget who you are.
You’ll fi nd a surprisingly simple solution in the Servlet API.
Write servlet code to store objects into a session object and retrieve objects from a session object.
Given a scenario describe the APIs used to access the session object, explain when the session object was created, and describe the mechanisms used to destroy the session object, and when it was destroyed.
Using session listeners, write code to respond to an event when an object is added to a session, and write code to respond to an event when a session object migrates from one VM to another.
Given a scenario, describe which session management mechanism the Web container could employ, how cookies might be used to manage sessions, how URL rewriting might be used to manage sessions, and write servlet code to perform URL rewriting.
All four of  the exam objectives on session management are covered completely in this chapter (although some of  these topics were touched on in the previous chapter)
This chapter is your one chance to learn and memorize these topics, so take your time.
Kim wants to keep client-specif ic state across multiple requests Right now, the business logic in the model simply checks the parameter from the request and gives back a response (the advice)
Nobody in the app remembers anything that went on with this client prior to the current request.
I want the beer app to have a back and forth.
The model (the business logic) has to figure out whether it has enough information to make a recommendation (in other words, to give final advice), and if it doesn’t, it has to give back the next question to ask the user.
We check the one incoming parameter (color) and give back the final response (an array of brands that fit that color)
Dude, I’m at Joe’s beach party and I am holding in.
How can he track the client’s answers? Kim’s design won’t work unless he can keep track of  everything the client has already said during the conversation, not just the answer in the current request.
He needs the servlet to get the request parameters representing the client’s choices, and save it somewhere.
Each time the client answers a question, the advice engine uses all of  that client’s previous answers to come up with either another question to ask, or a final recommendation.
He could have his servlet become a client to a stateful session bean, and each time a request comes in he could locate that client’s stateful bean.
There are a lot of little issues to work out, but yes, you can certainly use a stateful session bean to store conversational state.
But that’s way too much overhead (overkill) for this app! Besides, Kim’s hosting provider doesn’t have a full J2EE server with an EJB Container.
His hosting provider does allow access to MySQL, so he could do it.
We can use an HttpSession object to hold the conversational state across multiple requests.
In other words, for an entire session with that client.
Actually, Kim would still have to use an HttpSession even if  he did choose another option such as a database or session bean, because if  the client is a web browser, Kim still needs to match a specific client with a specific database key or session bean ID, and as you’ll see in this chapter, the HttpSession takes care of that identification.
In other words, it persists for an entire session with a specific client.
We can use it to store everything we get back from the client in all the requests the client makes during a session.
The Container sends the request to a new thread of the BeerApp servlet.
The BeerApp thread fi nds the session associated with Diane, and stores her choice (“Dark”) in the session as an attribute.
Diane considers the new question on the page, selects “Expensive” and hits the submit button.
The Container sends the request to a new thread of the BeerApp servlet.
The BeerApp thread fi nds the session associated with Diane, and stores her new choice (“Expensive”) in the session as an attribute.
The servlet runs its business logic (including calls to the model) and returns a response...
The servlet runs its business logic (including calls to the model) and returns a response...
Diane’s session is still active, but meanwhile Terri selects “Pale” and hits the submit button.
The Container sends Terri’s request to a new thread of the BeerApp servlet.
The BeerApp thread starts a new Session for Terri, and calls setAttribute() to store her choice (“Pale”)
The client browser makes a connection to the server, sends the request, gets the response, and closes the connection.
In other words, the connection exists for only a single request/response.
Because the connections don’t persist, the Container doesn’t recognize that the client making a second request is the same client from a previous request.
As far as the Container’s concerned, each request is from a new client.
A: Oh, the Container can get the IP address of the request, but does that uniquely identify the client? If you’re on a local IP network, you have a unique IP address, but chances are, that’s not the IP address the outside world sees.
To the server, your IP address is the address of the router, so you have the same IP address as everybody else on that network! So that wouldn’t help.
You’d have the same problem—the stuff Jim puts in his shopping cart might end up in Pradeep’s cart, and vice versa.
So no, IP address isn’t a solution for uniquely identifying a specific client on the internet.
Q: Well then how about security info? If the user is logged in, and the connection is secure (HTTPS), the Container knows EXACTLY who the client is, right?
A: Yes, if the user is logged in and the connection is secure, the Container can identify the client and associate him with a session.
Most good web site design says, “don’t force the user to log in until it really matters, and don’t switch on security (HTTPS) until it really matters.” If your users are just browsing, even if they’re adding items to a shopping cart, you probably don’t want the overhead (for you or the user) of having them authenticate to the system until they decide to checkout! So, we need a mechanism to link a client to a session that doesn’t require a securely authenticated client.
The client needs a unique session ID The idea is simple: on the client’s first request, the Container generates a unique session ID and gives it back to the client with the response.
The client sends back the session ID with each subsequent request.
The Container sees the ID, finds the matching session, and associates the session with the request.
Yes, but I’m state-challenged and won’t remember you, so I’m giving.
You MUST give that back to me each time you make a request, so I’ll know it’s you.
How do the Client and Container exchange Session ID info? Somehow, the Container has to get the     session ID to the client as part of  the response, and the client has to send back the session ID as part of  the request.
The simplest and most common way to exchange the info is through cookies.
The best part: the Container does virtually all the cookie work! You do have to tell the Container that you want to create or use a session, but the Container takes care of  generating the session ID, creating a new Cookie object, stuffing the session ID into the cookie, and setting the cookie as part of  the response.
And on subsequent requests, the Container gets the session ID from a cookie in the request, matches the session ID with an existing session, and associates that session with the current request.
Somewhere in your service method you ask for a session, and everything else happens automatically.
You don’t set the Cookie into the response (under the Set-Cookie header)
Look familiar? Yes, it’s exactly the same method used to generate the session ID and cookie for the response!
Whoa! The method for GETTING a session ID cookie  (and matching it with an existing session) is the same as SENDING a session ID cookie.
You never actually SEE the session ID yourself (although you can ask the session to give it to you)
A: You get a session from the request object becausethink about it—the session is identified by the request.
But there is another way that you can get a session...
Remember, a listener class isn’t a servlet or JSP—it’s just a class that wants to know about the events.
For example, the listener might be an attribute trying to find out when it (the attribute object) was added to or removed from a session.
So, if you implement any of the four listener interfaces related to sessions (we’ll get to that later in the chapter), you can access the session through the event-handling callback methods.
What if I want to know whether the session already existed or was just created? Good question.
The no-arg request method, getSession(), returns a session regardless of  whether there’s a pre-existing session.
Since you always get an HttpSession instance back from that method, the only way to know if  the session is new is to ask the session.
What if I want ONLY a pre-existing session? You might have a scenario in which a servlet wants to use only a previouslycreated session.
It might not make sense for the checkout servlet, for example, to start a new session.
If you  don’t want to create a new session, call getSession(false), and you’ll get either null, or a pre-existing HttpSession.
The code below calls getSession(false), then tests whether the return value was null.
If  it was null, the code outputs a message and then creates a new session.
Now we can test for whether there was already a session (the no-arg getSession() would NEVER return null)
Q: Isn’t the code above just a stupid, inefficient way to do the same thing as the opposite page? In the end, you still created a new session.
The code above is just for testing how the two different versions of getSession() work.
In the real world, the only time you’d want to use getSession(false) is if you do NOT want to create a new session.
If your goal is to create a new session, but still respond differently if you know this is a new (versus pre-existing) session, then use the no-arg getSession() method, and simply ask the session if it’s new using the HttpSession isNew() method.
Q: So it looks like getSession(true) is exactly the same as getSession()...
The no-arg version is a convenience for those times when you know that you always want a session, new or existing.
You can do sessions even if the client doesn’t accept cookies, but you have to do a little more work...
We don’t agree that anybody with half  a brain disables cookies.
In fact, most browsers do have cookies enabled, and everything’s wonderful.
If  your app depends on sessions, you need a different way for the client and Container to exchange session ID info.
Lucky for you, the Container can handle a cookie-refusing client, but it takes a little more effort from you.
If  you use the session code on the previous pages—calling getSession() on the request—the Container tries to use cookies.
If  cookies aren’t enabled, it means the client will never join the session.
In other words, the session’s isNew() method will always return true.
Gee...this all sounds nice but, uh, NEWS FLASHanybody with half a brain disables cookies.
If a client doesn’t accept cookies, you won’t get an exception.
If  the client won’t take cookies, you can use URL rewriting as a backup.
Assuming you do your part correctly, URL  rewriting will always work—the client won’t care that it’s happening and won’t do anything to prevent it.
Remember the goal is for the client and Container to exchange session ID info.
Passing cookies back and forth is the simplest way to exchange session IDs, but if  you can’t put the ID in a cookie, where can you put it? URL rewriting takes the session ID that’s in the cookie and sticks it right onto the end of  every URL that comes in to this app.
Imagine a web page where every link has a little bit of  extra info (the session ID) tacked onto the end of  the URL.
When the user clicks that “enhanced” link, the request goes to the Container with that extra bit on the end, and the Container simply strips off  the extra part of  the request URL and uses it to find the matching session.
We add the session ID to the end of all the URLs in the HTML we send back in the Response.
The session ID comes back as “extra” info stuck to the end of the Request URL.
If  cookies don’t work, the Container falls back to URL rewriting, but only if  you’ve done the extra work of  encoding all the URLs you send in the response.
If  you want the Container to always default to using cookies first, with URL rewriting only as a last resort, you can relax.
That’s exactly how it works (except for the first time, but we’ll get to that in a moment)
But if  you don’t explicitly encode your URLs, and the client won’t accept cookies, you don’t get to use sessions.
If  you do encode your URLs, the Container will first attempt to use cookies for session management, and fall back to URL rewriting only if  the cookie approach fails.
Add the extra session ID info to th is URL.
A: A really dumb Container doesn’t care whether cookies work or not—the dumb Container will always attempt to send the cookie AND do URL rewriting each time, even if cookies are working.
When the Container sees a call to getSession(), and the Container didn’t get a session ID with the client’s request, the Container now knows that it must attempt to start a new session with the client.
At this point, the Container doesn’t know if cookies will work, so with this first response back to the client, it tries BOTH cookies and URL rewriting.
A: Remember, if the Container doesn’t get a session ID from the client, the Container won’t even KNOW that this is the next request from that client.
The Container won’t have any way to know that it tried cookies the last time, and they didn’t work.
Remember, the ONLY way the Container can recognize that it has seen this client before is if the client sends a session ID!
Now imagine the next request from this client—it  will have the session ID appended to the request URL,  but if the client accepts cookies, the request will ALSO have a session ID cookie.
How do I do URL rewriting on those static pages?
So, if you depend on sessions, you need URL rewriting as a fall-back strategy.
And since you need URL rewriting, you have to dynamically generate the URLs in the response HTML! And that means you have to process the HTML at runtime.
So you must think very carefully about the places where sessions matter to your app, and whether sessions are critical to have or merely good to have.
Q: You said that to use URL rewriting,  pages must be dynamically -generated, so does this mean I can do it with JSPs?
A: Yes! You can do URL-rewriting in a JSP, and there’s even a simple JSTL tag that makes it easy, <c:URL>, that you’ll see when you get to the chapter on using custom tags.
Q: Is URL rewriting handled in a vendor-specifi c way? A: Yes, URL rewriting is handled in a vendor-specific way.
Tomcat uses a semicolon “;” to append the extra info to the URL.
And while Tomcat adds “jsessionid=” in the rewritten URL,  another vendor might append only the session ID itself.
The point is, whatever the Container uses as the separator is recognized by the Container when a request comes in.
So when the Container sees the separator that it uses (in other words, the separator that it added during URL rewriting), it knows that everything after that is “extra info” that the Container put there.
In other words, the Container knows how to recognize and parse the extra stuff it (the Container) appended to the URL.
And you shouldn’t see a custom “jsessionid” header in a reques.
In fact, the ONLY place a “jsessio nid” belongs is inside a cookie he.
The session ID then comes back with the request as “extra” info at the end of the request URL.
Getting rid of sessions The client comes in, starts a session, then changes her mind and leaves the site.
Or the client comes in, starts a session, then her browser crashes.
Or the client comes in, starts a session, and then completes the session by making a purchase (shopping cart check-out)
You don’t want sessions to stick around longer than necessary.
Remember, the HTTP protocol doesn’t have any mechanism for the server to know that the client is gone.
In distributed application terms, for those of  you familiar with them— there’s no leasing.
But how does the Container (or you) know when the client walked away? How does the Container know when the client’s browser crashed? How does the Container know when it’s safe to destroy a session?
I REALLY don’t want a bunch of stale sessions sitting.
What are strategies you (and the Container) might use to manage the number of sessions, and eliminate unneeded sessions? What are some possible ways in which the Container could tell that a session is no longer needed?
Think about it, then look at the HttpSession API a few pages from now for clues.
Some distributed apps use leasing as a way for the server to know when a client is gone.
The client gets a lease from the server, and then must renew the lease at specified intervals to tell the server that the client is still alive.
If the client’s lease expires, the server knows it can destroy any resources it was holding for that client.
He wants to conserve space on his machine for playing “The Sims” with the “Hot Date” expansion pack.
The Container sends the request to a new thread of the BeerApp servlet.
The “JSESSIONID” cookie is sent back to Diane in the response (not shown)
Containers do in their spare time (although there are probably plenty of other clients to service)
We’d like the Container to recognize when a session has been inactive for too long, and destroy the session.
Of  course we might have to fight the Container over what “too long” really means.
The  HttpSession interface All you care about when you call getSession() is that you get an instance of  a class that implements the HttpSession interface.
Once you have a session, what can you do with it?
Most of the time, you’ll use sessions to get and set session-scoped attributes.
You might want to restrict certain sessions to a fixed length of time.
For example, you might say, “Once you’ve logged in, you have exactly 10 minutes to complete this form...”
Returns the last time the Container got a request with this session ID (in milliseconds)
To find out when a client last accessed this session.
You might use it to decide that if the client’s been gone a long time you’ll send them an email asking if they’re coming back.
Specifies the maximum time, in seconds, that you want to allow between client requests for this session.
To cause a session to be destroyed after a certain amount of time has passed without the client making any requests for this session.
This is one way to reduce the amount of stale sessions sitting in your server.
This includes unbinding all session attributes currently stored in this session.
To kill a session if the client has been inactive or if you KNOW the session is over (for example, after the client does a shopping check-out or logs out)
The session instance itself might be recycled by the Container, but we don’t care.
Invalidate means the session ID no longer exists, and the attributes are removed from the session object.
Returns the maximum time, in seconds, that is allowed between client requests for this session.
To find out how long this session can be inactive and still be alive.
You could use this to judge how much more time an inactive client has before the session will be invalidated.
Now that you’ve seen these methods, can you put together a strategy for eliminating abandoned sessions?
Setting session   timeout Good news: you don’t have to keep track of  this yourself.
See those methods on the opposite page? You don’t have to use them to get rid of  stale (inactive) sessions.
If  you want to change the session-timeout value for a particular session instance (without affecting the timeout length for any other sessions in the app):
Only the session on which you call the method is affected.
Specify in both the DD, and programmatically, that if a session does not receive any requests for 20 minutes, it should be destroyed.
We put one magnet in the servlet for you, to get started, and you might not use all magnets.
Each of the two listings represents code from a compiled HttpServlet.
Your job is to think like the Container and determine what will happen when each of these.
Describe what happens the first and second time the same client accesses the servlet.
Specify in both the DD, and programmatically, that if a session does not receive any requests for 20 minutes, it should be destroyed.
Uh-oh! It’s too late to call getAttribute() on the session because the session already IS invalid!
Setting the maximum inactive interval to 0 means the session times out and is invalidated immediately!
Here we’re causing the session to timeout IMMEDIATELY, because we’re saying, “timeout after 0 seconds of inactivity”
You can’t call isNew() on a session that’s already been invalidated.
So it’s really the same problem as the code above...
Can I use  cookies for other things, or are they only for sessions? Although cookies were originally designed to help support session state, you can use custom cookies for other things.
Remember, a cookie is nothing more than a little piece of data (a name/value String pair) exchanged between the client and server.
The server sends the cookie to the client, and the client returns the cookie when the client makes another request.
One cool thing about cookies is that the user doesn’t have to get involved—the cookie exchange is automatic (assuming cookies are enabled on the client, of  course)
By default, a cookie lives only as long as a session; once the client quits his browser, the cookie disappears.
But you can tell a cookie to stay alive even AFTER the browser shuts down.
That way, your web app can still get the cookie information even though the session with that client is long gone.
Imagine that Kim wants to display the user’s name each time he returns to the beer site.
So he sets the cookie the first time he receives the client’s name, and if  he gets the cookie back with a request, he knows not to ask for the name again.
And it doesn’t matter if  the user restarted his browser and hasn’t been on the site for a week!
You can use cookies to exchange name/value String pairs between the server and the client.
The server sends the cookie to the client, and the client sends it back with each subsequent request.
Session cookies vanish when the client’s browser quits, but you CAN tell a cookie to persist on the client even after the browser shuts down.
Using Cookies with the Servlet API You can get cookie-related headers out of  the HTTP request and response, but don’t.
String getDomain() int getMaxAge() String getName() String getPath() boolean getSecure() String getValue() void setDomain(String) void  setMaxAge(int) void setPath(String) void setValue(String) // a few more methods.
Setting max age to -1 makes the cookie disappear when the browser exits.
Simple custom cookie example So, imagine that Kim wants to put up a form that asks the user to submit his name.
The form calls a servlet that gets the username request parameter, and uses the name value to set a cookie in the response.
The next time this user makes a request on ANY servlet in this web app, the cookie comes back with the request (assuming the cookie is still alive, based on the cookie’s maxAge value)
This code is a simplified test version of  the scenario we just described.
Make a new cookie so store the user’s name.Keep it alive on the client for 30 minutes.
Loop through the cookie array looking for a cookie named “username”
If there is one, get the value and print it.
You don’t have to know ALL the cookie methods.For the exam, you don’t have to memorize every one of the methods in class Cookie, but you must know the request and response methods to get and add Cookies.You should also know the Cookie constructor and the getMaxAge() and setMaxAge() methods.
When you add a header to a respo nse, you pass the name.
But when you add a Cookie to the response, you pass a.
Key milestones for an HttpSession Highlights of  the important moments in an HttpSession object’s life:
Session attributes are added, removed, or replaced by other parts of the app.
The session is passivated in one VM and activated in another within a distributed app.
The session was created When the Container first creates a session.
At this point, the session is still considered new (in other words, the client has not yet sent a request with the session ID)
When the Container has just migrated (moved) the session into a different VM.
Called before any other part of  the app can call getAttribute() on the session, so the just-moved attributes have a chance to get themselves ready for access.
An attribute was added When some part of  the app calls setAttribute() on the session.
An attribute was removed When some part of  the app calls removeAttribute() on the session.
The session is about to be passivated When the Container is about to migrate (move) the session into a different VM.
Called before the session moves, so that attributes have a chance to prepare themselves for migration.
An attribute was replaced When some part of  the app calls setAttribute() on the session, and the name of  the attribute has already been bound to the session.
The session was destroyed When the Container invalidates a session (because the session timed out or some part of  the application called the session’s invalidate() method)
Remember from chapter 5 where we looked at how you might use this—if, for example, your attribute wants to know when it’s added to a session so that it can synchronize itself  with an underlying database (and update the database when it’s removed from a session)
This listener is just so that I can fi nd out when I’m put into a session (or taken out)
The word “Bound” means someone ADDED this attribute to a session.
If an attribute class (like the Do g class here) implements the.
But this is N OT true for the other sessionrelated listeners on the previous p age.
DD, since they’re related to the se ssion itself, rather than an.
Session migration Remember from the previous chapter, we talked briefly about distributed web apps, where the pieces of  the app might be replicated across multiple nodes in the network.
In a clustered environment, the Container might do load-balancing by taking client requests and sending them out to JVMs (which may or may not be on different physical boxes, but that doesn’t matter to us)
That means each time the same client makes a request, the request could end up going to a different instance of  the same servlet.
In other words, request A for Servlet A could happen on one VM, and request B for Servlet A could end up on a different VM.
So the question is, what happens to things like ServletContext, ServletConfig, and HttpSession objects?
Only HttpSession objects (and their attributes) move from one VM to another.
But there is only one HttpSession object for a given session ID per web app, regardless of how many VM’s the app is distributed across.
Note: everything is duplicated in the second server EXCEPT the HttpSession objects! Sessions live in only ONE place at any given moment.
The same session ID for a given web app will NEVER appear in two VMs at the same time.
Each servlet has its own ServletConfig, and both servlets in the web app share a ServletContext.
Everything except the HttpSession is duplicated on the other VM.
Session migration in action How an app server vendor handles clustering and web app distribution varies with each vendor, and there’s no guarantee in the J2EE spec that a vendor has to support distributed apps.
But the picture here gives you a high-level idea of  how it works.
The key point is that while other parts of  the app are replicated on each node/VM, the session objects are moved.
In other words, if  the vendor does support distributed apps, then the Container is required to migrate sessions across VMs.
This time, the Load-Balancing server decides to send the request to Container A-2 in VM Two.
The Container gets the request, sees the session ID, and realizes that the session is on a different VM, VM One!
The “JSESSIONID” cookie is sent back to Diane in the response (not shown)
In other words, it no longer exists on VM One once it moves to VM Two.
This migration means the session was passivated on VM One, and activated on VM Two.
The Container makes a new thread for ServletA, and associates the new request with the recentlymoved session #343
Diane’s new request is sent to the thread, and everybody is happy.
Diane has no idea what happened (except for the slight delay/latency waiting for the session to move)
Since it’s possible that an HttpSession can migrate from one VM to another, the spec designers thought it would be nice if  someone bothered to tell the attributes within the session that they, too, were about to move.
That way the attributes can make sure they’ll survive the trip.
If  all your attributes are straightforward Serializable objects that don’t care where they end up, you’ll probably never use this listener.
In fact, we’re guessing 95.324% of  all web apps never use this listener.
But it’s there if  you need it, and the most likely use of this listener is to give attributes a chance to make their instance variables ready for Serialization.
This listener is so that as an attribute, I can fi nd out.
A Container is required to migrate Serializable attributes (which assumes that all instance variables within the attribute are either Serializable or null)
But a Container is not required to use Serialization as the means for migrating the HttpSession object!
What does this mean to you? Simple: make sure your attribute class types are Serializable and you never have to worry about it.
If you’re familiar with Serializati on, you know that a class that i.
But the methods won’t necessaril y be called during session migrat.
Listener examples Over the next three pages, pay attention to the event object types and to whether the listener is also an attribute class.
Session counter This listener lets you keep track of  the number of  active sessions in this web app.
Attribute Listener This listener lets you track each time any attribute is added to, removed from, or replaced in a session.
Configuring the listener in the DD Q: Hey, what the heck are you printing to? Where does System.out go in a web app?
A: Wherever this Container chooses to send it (which may or may not be configurable by you)
In other words, in a vendor-specific place, often a log file.
You’ll have to read your server docs to find out what your Container does with standard output.
Attribute class (listening for events that affect IT) This listener lets an attribute keep track of  events that might be important to the attribute itself—when it’s added to or removed from a session, and when the session migrates from one VM to another.
Session activation events (but notice that the methods take an HttpSessionEvent)
You want to know how many concurrent users there are.
In other words, you want to track the active sessions.
You want to know when a session moves from one VM to another.
You have an attribute class (a class for an object that will be used as an attribute value) and you want objects of this type to be notifi ed when they are bound to or removed from a session.
You want to know when any session attribute is added, removed, or replaced in a session.
The getName() method returns the String name of the attribute that triggered the event.
The getValue() method returns the object value of the attribute that triggered the event.
Watch out! It returns the old value, not the new one.
In other words, it returns the value the attribute had BEFORE the change that triggered the event !
Session-related ListenersSharpen your pencil Yes, this is almost an exact copy of the table from two pages back, so don’t go there.
Try to think through these listeners and put down your best guess.
You can expect at least two, and as many as four questions on the exam about session listeners.
Use both your memory and common sense to fill this out.
An attribute wants to know when it has been moved into a new VM.
An attribute wants to know when it has been replaced in a session.
You want to be notified whenever anything is bound to a session.
A session whose timeout period has been set to -1 will never expire.
A session will become invalid as soon as the user closes all browser windows.
A session will become invalid after a timeout period defined by the servlet container.
When using cookies for session tracking, there is no restriction on the name of  the session tracking cookie.
When using cookies for session tracking, the name of  the session tracking cookie must be JSESSIONID.
Attributes bound into a session are available to any other servlet that belongs to the same ServletContext and handles a request identified as being part of  the same session.
When a session is moved from one JVM to another, any attributes stored in the session will be lost.
Session timeout declarations made in the DD can specify time in seconds.
Session timeout declarations made in the DD can specify time in minutes.
Session timeout declarations made programmatically can specify time only in seconds.
Session timeout declarations made programmatically can specify time only in minutes.
Session timeout declarations made programmatically can specify time in either minutes or seconds.
Option E is correct because both lines 13 and HttpSession is NOT necessary, but it does reflect the correct type, so it is valid.
Option B is correct because cookies CANNOT be used, but URL rewriting does NOT depend on cookies being enabled.
A session whose timeout period has been set to -1 will never expire.
A session will become invalid as soon as the user closes all browser windows.
A session will become invalid after a timeout period defined by the servlet container.
Option D is incorrect because the method that should be used is called invalidate()
Option B is incorrect because there is no explicit termination signal in the HTTP protocol.
When using cookies for session tracking, there is no restriction on the name of  the session tracking cookie.
When using cookies for session tracking, the name of  the session tracking cookie must be JSESSIONID.
Option C is incorrect because the specification dictates that the session tracking cookie must be JSESSIONID.
Option E is incorrect because there is no such class.
Options A and B are correct because these methods should have an HttpSessionEvent parameter.
Option C is incorrect because the listener is defined in the imported package.
Option D is incorrect because these are the only two methods in this interface.
Attributes bound into a session are available to any other servlet that belongs to the same ServletContext and handles a request identified as being part of  the same session.
Option D is incorrect because this call will simply replace the existing value.
Option B is incorrect because the return type is Object.
Option B is correct, removeAttribute() is the only way to remove attributes from a session object, and it removes only one attribute at a time.
When a session is moved from one JVM to another, any attributes stored in the session will be lost.
Option A is incorrect because serializable attributes will be transferred.
Session timeout declarations made in the DD can specify time in seconds.
Session timeout declarations made in the DD can specify time in minutes.
Session timeout declarations made programmatically can specify time only in seconds.
Session timeout declarations made programmatically can specify time only in minutes.
Session timeout declarations made programmatically can specify time in either minutes or seconds.
Option B is incorrect since attributes remain bound to the session.
Option D only looks at the first Cookie in the array.
Option E: removing an attribute isn’t tightly associated with a session timeout.
Option C: this is kind of round-about, but if you have an attribute class this is a way to be informed of a timeout.
Option D is not correct because it shows servlet code retrieving, not creating, a cookie.
You acquire an object that implements HttpSession by using req.getSession()
The Container looks at your JSP, translates it into Java source code, and compiles.
You’ll learn how, why, and what to write in your JSP.
Identify, describe, or write JSP code for the following elements: (a) template text, (b) scripting elements (comments, directives, declarations, scriptlets, and expressions), (c) standard and custom actions, and (d) expression language elements.
Write JSP code that uses the directives: (a) page (with attributes import, session, contentType, and isELIgnored), (b) include, and (c) taglib.
Write a JSP Document (XML-based document) that uses the correct syntax.
Given a design goal, write JSP code using the appropriate implicit objects: (a) request, (b) response, (c) out, (d) session, (e) config, (f) application, (g) page, (h) pageContext, and (i) exception.
Configure the deployment descriptor to declare one or more tag libraries, deactivate the evaluation language, and deactivate the scripting language.
Given a specific design goal for including a JSP segment in another page, write the JSP code that uses the most appropriate inclusion mechanism (the include directive or the jsp:include standard action)
Most is covered in this chapter, but the details behind (c) standard and custom actions, and (d) expression language elements are covered in later chapters.
The page directive is covered in this chapter, but include and taglib are covered in later chapters.
All covered in this chapter, although you’re expected to already know what most of  them mean based on the previous two chapters.
Hint: these will be some of  the most no-brainer questions on the real exam, once you’ve learned the fundamentals in this chapter.
Not covered here; refer to the next chapter (Scriptless JSPs)
In the end, a  JSP is just a servlet Your JSP eventually becomes a full-fledged servlet running in your web app.
It’s a lot like any other servlet, except that the servlet class is written for you—by the Container.
The Container takes what you’ve written in your JSP, translates it into a servlet class source (.java) file, then compiles that into a Java servlet class.
After that, it’s just servlets all the way down, and the servlet runs in exactly the same way it would if  you’d written and compiled the code yourself.
In other words, the Container loads the servlet class, instantiates and initializes it, makes a separate thread for each request, and calls the servlet’s service() method.
Some of  the questions we’ll answer in this chapter include:
Making a JSP that displays how many times it ’s been accessed Pauline wants to use JSPs in her web apps—she’s really sick of writing HTML into a servlet’s PrintWriter println()
She decides to learn JSPs by making a simple dynamic page that prints the number of  times the page has been requested.
She understands that you can put regular old Java code in a JSP using a scriptlet—which just means Java code within a <% ...
I know I can put Java code in the JSP, so I’ll make a.
She deploys and tests it It’s trivial to deploy and test.
The only tricky part is making sure that the Counter class is available to the JSP, and that’s easy—just be sure the Counter class is in the WEB-INF/ classes directory of  the web app.
The server encountered an internal error () that prevented it from fulfi lling this request.
Put the package directory and class file in the WEB-INF/classes directory, and any part of this web app will be able to see it.
To keep it easy, we put the JSP at the root of this web app.
The JSP doesn’t recognize the Counter class The Counter class is in the foo package, but there’s nothing in the JSP to acknowledge that.
It’s the same thing that happens to you with any other Java code, and you know the rule: import the package or use the fully-qualified class name in your code.
Counter.java I guess you have to use the fully-qualified class name inside.
That makes sense, since all JSPs are turned into plain old Java servlet code by the Container.
Use the page directive to import packages A directive is a way for you to give special instructions to the Container at page translation time.
We’ll look at the include and taglib directives in later chapters, but for now all we care about is the page directive, because it’s the one that lets you import.
Notice there’s no semicolon at the end of a directive.
Notice what’s different between the Java code that prints the counter and the page directive?
But the directive adds an additional character to the start of  the element—the @ sign!
If  you see JSP code that starts with <%@, you know it’s a directive.
We’ll get into more details about the page directive later in the book.
Scriptlets are normal Java, so all statements in a scriptlet must end in a semicolon !
But then Kim mentions “expressions” Just when you thought it was safe, Kim notices the scriptlet with an out.println() statement.
Part of  the whole point of  JSP is to avoid println()! That’s why there’s a JSP expression element—it automatically prints out whatever you put between the tags.
The expression is shorter—we don’t need to explicitly do the print...
But the expression adds an additional character to the start of  the element—an equals sign (=)
HELLO! If you’re gonna tell us how to improve our code, you.
A: You probably won’t use the implicit out variable from within your JSP page, but you might pass it to something else...
Q: In an expression, what happens if the method doesn’t return anything?
A: You’ll get an error!! You cannot, MUST NOT use a method with a void return type as an expression.
The Container is smart enough to figure out that there won’t be anything to print if the method has a void return type!
A: Good question! Rather than having a whole big pile of different directives, the JSP spec has just three JSP directives, but the directives can have attributes.
What you called “the import directive” is actually “the import attribute of the page directive”
Q: What are the other attributes for the page directive?
A: Remember, the page directive is about giving the Container information it needs when translating your JSP into a servlet.
The attributes we care about (besides import) are session, contentType, and isELIgnored (we’ll come back to these later in the chapter)
Decide which of the following expressions are and are not valid, and why.
We haven’t covered every example here, so make your best guess based on what you know about how expressions work.
Answers are later in this chapter so do this NOW.
I know the JSP turns into a servlet, so maybe.
I could declare a count variable in a scriptlet and that would turn into a variable in the servlet.
Declaring a variable in a scriptlet The variable declaration is legal, but it didn’t quite work the way Pauline hoped.
What she got the fi rst time she hit the page:
What she got the second, third, and every other time she hit the page:
What REALLY happens to your JSP code? You write a JSP, but it becomes a servlet.
The only way to really tell what’s happening is to look at what the Container does to your JSP code.
In other words, how does the Container translate your JSP into a servlet?
Once you know where different JSP elements land in the servlet’s class file, you’ll find it much easier to know how to structure your JSP.
The servlet code on this page is not the real code generated by the Container—we simplified it down to the essential parts.
The real generated servlet source code is slightly harder to read, but we will look at the real thing in a few pages.
For now, though, all we care about is where in the servlet class our JSP code actually ends up.
That means variables declared in a scriptlet are always LOCAL variables!
The underlined names will change depending on your system and your web app.
Declaring the count variable in a scriptlet meant that the variable was reinitialized each time the service method ran.
Which means it was reset to 0 with each request.
Directives are for special instructions to the Container, scriptlets are just plain old Java that lands as-is within the generated servlet’s service method, and the result of an expression always becomes the argument to a print() method.
That means you can declare both static variables and methods.
In theory, yes, you could define other members including inner classes, but 99.9999% of  the time you’ll use declarations for methods and variables.
The code below solves Pauline’s problem; now the counter keeps incrementing each time a client requests the page.
Time to see the REAL generated servlet We’ve been looking at a super-simplified version of  the servlet the Container actually creates from your JSP.
Some vendors won’t let you see the generated Java source, and keep only the compiled .class files.
Don’t be intimidated when you see parts of  the API that you don’t recognize.
Most of  the class and interface types are vendor-specific implementations you shouldn’t care about.
Tomcat 5 declares one static variable and one instance method of its own.
As part of building this method, the Container declares and initializes all the implicit objects.
You’ll see more implicit objects when you turn the page.
We’ve been showing generated code so that you can understand how the JSP is translated into servlet code.
But you don’t need to know the details about how a particular vendor does it, or what the generated code actually looks like.
You need to know, for example, that your scriptlet can use implicit objects, and you need to know the Servlet API type of the implicit objects.
But you do NOT need to know the code used to make those objects available.
The only other thing you need to know about the generated code are the three JSP lifecycle methods: jspInit(), jspDestroy, and _jspService()
The Container declares a bunch of its own local variables, including those that represent the “implicit objects” your code might need, like “out” and “request”
And it tries to run and output your JSP HTML, scriptlet, and expression code.
When a Container translates the JSP into a servlet, the beginning of  the service method is a pile of  implicit object declarations and assignments.
With implicit objects, you can write a JSP knowing that your code is going to be part of  a servlet.
In other words, you can take advantage of  your servletness, even though you’re not directly writing a servlet class yourself.
What were some of  the important objects you used? How did your servlet get servlet init parameters? How did your servlet get context init parameters? How did your servlet get a session? How did your servlet get the parameters submitted by the client in a form?
These are just a few of  the reasons your JSP might need to use some of  what’s available to a servlet.
All of  the implicit objects map to something from the Servlet/JSP API.
The request implicit object, for example, is a reference to the HttpServletRequest object passed to the service method by the Container.
A: The JspWriter is not in the class hierarchy of PrintWriter, so you can’t use it in place of a PrintWriter.
But it has most of the same print methods, except it adds some buffering capabilities.
Your job is to figure out what will happen when the Container tries to turn the JSP into a servlet.
Mock   Exam Magnets Study the scenario (and everything else on this page), then place the magnets on the JSP to make a legal fi le that would produce the correct result.
You don’t have to use any magnet more than once, and you won’t use all of the magnets.
This exercise assumes there’s a servlet (which you don’t need to see) that takes the initial request, binds an attribute into the request scope, and forwards to the JSP you’re creating.
Note: we called this “Mock Exam Magnets” instead of “Code Magnets” because the exam is FULL of Drag and Drop questions like this one.
The friends who share your hobby of extreme knitting are: Fred Pradeep Philippe.
The text “extreme knitting” comes from a form request parameter.
A servlet will get the request fi rst (and then forward the request to your JSP) but that doesn’t change the way you get the parameter in your JSP.
The three names come from an ArrayList request attribute called “names”
You’ll need to get the attribute from the request object.
Assume a servlet got this request and set an attribute in request scope.
Whatever you can do with a request object in a servlet, you do inside your JSP.
You don’t have to worry about which of the HTTP methods (GET or POST) was used in the request.
The code you put in this JSP MUST work with the code that’s already here.
The Java language doesn’t allow that, and the Container won’t bother to rearrange the order of your scriptlet code.
No problems; prints the first (and only) object in the ArrayList.
Once your JSP stuff is inside a servlet, it’s just Java.
If your answer looks a little different, but you still think it should work—try it! You’ll have to make the servlet that takes the form request, sets an attribute, and forwards (dispatches) the request to the JSP.
Finish the while loop block! (If you forget this, it won’t compile)
We need the import page directive because of ArrayList and Iterator.
Yes, because the new String array is an object, and ANY object can be sent to a println() statement.
NO! The arithmetic is fine, but there’s a space between the % and the =
Sure, this resolves to a boolean, so it prints ‘true’
If  you’re a Java programmer with very little HTML experience, you might find yourself  typing:
But if  you do, then unless it’s within a scriptlet or declaration tag, you’ll end up DISPLAYING that to the client as part of  the response.
In other words, to the Container, those two slashes are just more template text, like “Hello” or “Email is:”
You can put two different types of comments in a JSP:
The Container just passes this straight on to the client, where the browser interprets it as a comment.
These are for the page developers, and just like Java comments in a Java source file, they’re stripped out of the translated page.
If you’re typing a JSP and want to put in comments about what you’re doing, the way you’d use comments in a Java source file, use a JSP comment.
If you want comments to stay as part of the HTML response to the client (although the browser will hide them from the client’s view), use an HTML comment.
This is the only part of  the generated servlet’s API that you need to know.
You don’t care that in Tomcat, for example, your generated servlet extends:
All you need to know about are the three key methods:
This method is called from the servlet’s service() method, which means it runs in a separate thread for each request.
The Container passes the Request and Response objects to this method.
You can’t override this method! You can’t do ANYTHING with this method yourself (except write code that goes inside it), and it’s up to the Container vendor to take your JSP code and fashion the _jspService() method that uses it.
Note the underscore at the front of the _ jspService() method.
The Container writes the .java file for the servlet your JSP becomes.
Kim writes a .jsp fi le, and deploys it as part of a web app.
The Container “reads” the web.xml (DD) for this app, but doesn’t do anything else with the .jsp fi le (until the fi rst time it’s requested)
The client hits a link that asks for the .jsp.
The Container tries to TRANSLATE the .jsp into .java source code for a servlet class.
The Container tries to COMPILE the servlet .java source into a .class fi le.
The Container instantiates the servlet and causes the servlet’s jspInit() method to run.
The Container creates a new thread to handle this client’s request, and the servlet’s _jspService() method runs.
The object is now a full-fl edged servlet, ready to accept client requests.
Everything that happens after this is just plain old servlet request-handling.
Eventually the servlet sends a response back to the client (or forwards the request to another web app component)
Translation and compilation happens only ONCE When you deploy a web app with a JSP, the whole translation and compilation step happens only once in the JSP’s life.
Once it’s been translated and compiled, it’s just like any other servlet.
And just like any other servlet, once that servlet has been loaded and initialized, the only thing that happens at request time is creation or allocation of  a thread for the service method.
So the picture on the previous two pages is for only the first request.
I would never have guessed that they could make requesting a JSP.
I’m thinking the client has to wait, what, five minutes for all.
Q: OK, so that means only the first client to ask for the JSP takes the big hit.
There IS a mention in the JSP spec (JSP 11.4.2) of a suggested protocol for JSP precompilation.
If the JSP turns into a servlet, I wonder if I can.
Flip back through earlier pages (and chapters) if you need to, but don’t turn the page until you’ve done this.
Yes, you CAN get servlet init parameters from a JSP, the questions are:
Initializing your JSP You can do servlet initialization stuff  in your JSP, but it’s slightly different from what you do in a regular servlet.
If  you implement a jspInit() method, the Container calls this method at the beginning of  this page’s life as a servlet.
It’s called from the servlet’s init() method, so by the time this method runs there is a ServletConfig and ServletContext available to the servlet.
This example uses the jspInit() method to retrieve a servlet init parameter (configured in the DD), and uses the value to set an application-scoped attribute.
You’re in a servlet, so you can call your inherited getServletConfig() method.
You configure servlet init params for your JSP virtually the same way you configure them for a normal servlet.
This is EXACTLY what you’d do in a normal servlet.
Get a reference to the ServletContext and set an application-scope attribute.
When you define a servlet for a JSP, you must also define a servlet mapping to the JSP page.
Attributes in a JSP The example on the opposite page shows the JSP setting an application-scoped attribute using a method declaration that overrides jspInit()
But most of  the time you’ll be using one of  the four implicit objects to get and set attributes corresponding to the four attribute scopes available in a JSP.
Remember, in addition to the standard servlet request, session, and application (context) scopes, a JSP adds a fourth scope— page scope —that you get from a    pageContext object.
You usually won’t need (or care about) page scope unless you’re developing custom tags, so we won’t say any more about it until the custom tags chapter.
But this isn’t the whole story! In a JSP, there’s another way to get and set attributes at any scope, using only the pageContext implicit object.
The naming convention might tric k you into thinking that attributes.
Using  PageContext for attributes You can use a PageContext reference to get attributes from any scope, including the page scope for attributes bound to the PageContext.
The methods that work with other scopes take an int argument to indicate the scope.
Although the attribute access methods come from JspContext, you’ll find the constants for the scopes inside the PageContext class.
Using the  pageContext to fi nd an attribute when you don’t know the scope.
But if  there’s no “foo” attribute, the method starts looking in other scopes, from most restricted to least restricted scope —in other words, first request scope, then session, then finally application scope.
The fi rst one it fi nds with that name wins.
That was a page directive (one of  the three directive types) with an import attribute (one of  13 attributes of  the page directive)
We’ll take a quick look now at the others, although some won’t be covered in detail until later chapters, and some won’t be covered in detail at all in this book, because they’re rarely used.
We just said that to cover a bad pathetic nonexistent transition between two unrelated topics.
We hoped nobody would notice, but NO...you just couldn’t let it go, could you?
Defines page-specific properties such as character encoding, the content type for this page’s response, and whether this page should have the implicit session object.
A page directive can use up to thirteen different attributes (like the import attribute), although only four attributes are covered on the exam.
We haven’t talked about using custom tags and standard actions yet, so this might not make any sense at this point.
Just go with it for now...we have two whole chapters on tag libraries coming up soon.
Defines text and code that gets added into the current page at translation time.
This lets you build reusable chunks (like a standard page heading or navigation bar) that can be added to each page without having to duplicate all that code in each JSP.
Right now, the only possible value is “java”, but the attribute is here because isn’t it just like those spec developers to be thinking of the future, when other languages might be used.
We haven’t talked about EL yet; that’s coming in the next chapter.
For now, just know that you might choose to ignore EL syntax in your page, and this is one of the two ways you can tell the Container.
The default is “ISO-8859-1” (unless the contentType attribute already defines a character encoding, or the page uses XML Document syntax)
Defines the MIME type (and optional character encoding) for the JSP response.
Defines whether the current page represents another JSP’s error page.
The default value is “false”, but if it’s true, the page has access to the implicit exception object (which is a reference to the offending Throwable)
If false, the implicit exception object is not available to the JSP.
Defines a String that gets put into the translated page, just so that you can get it using the generated servlet’s inherited getServletInfo() method.
Defines whether the generated servlet needs to implement the SingleThreadModel, which, as you know, is a Spectacularly Bad Thing.
Defines how buffering is handled by the implicit out object (reference to the JspWriter)
Defines whether the page will have an implicit session object.
Defines the Java import statements that’ll be added to the generated servlet class.
Defines the superclass of the class this JSP will become.
You won’t use this unless you REALLY know what you’re doing—it overrides the class hierarchy provided by the Container.
You do NOT have to memorize the entire list; just get a feel for what you can do.
We’ll look at the isELIgnored  and the two error-related attributes in later chapters.
This is SUCH a nice chapter with a VERY lovely look at how to put Java code in a JSP, but, um, look at this companywide memo I just got.
Effective immediately, anyone caught using scriptlets, expressions, or declarations in their JSP code will be suspended without pay until such time as it can be determined whether the programmer was fully responsible or simply trying to maintain some OTHER idiot’s code.
If, in fact, the determination is made that the programmer is, in fact, responsible, the company will go ahead and, in fact, terminate the employee.
Scriptlets considered harmful? Is it true? Could there be a downside to putting all this Java into your JSP? After all, isn’t that the whole frickin’ POINT to a JSP? So that you write your Java in what is essentially an HTML page as opposed to writing HTML in a Java class?
Some people believe (OK, technically a lot of  people including the JSP and Servlet spec teams) that it’s bad practice to put all this Java into your JSP.
Why? Imagine you’ve been hired to build a big web site.
Your team includes a small handful of  back-end Java programmers, and a huge group of  “web designers”—graphic artists and page creators who use Dreamweaver and Photoshop to build fabulous-looking web pages.
These are not programmers (well, except for the ones who still think HTML is “coding”)
Aspiring actors working as web designers while waiting for their big showbiz break.
Two questions—WHY are you making us learn it, and WHAT is the alternative? What the f*** else IS there besides HTML if you can’t put scriptlets, declarations, and.
That means there are already mountains of  JSP files brimming with Java code stuck in every conceivable spot in the page,  nestled between scriptlet, expression, and declaration tags.
It’s out there and there isn’t anything anyone can do to change the past.
So that means you’ve got to know how to read and understand these elements, and how to maintain pages written with them (unless you’re given the chance to massively refactor the app’s JSPs)
Secretly, we think there’s still a place for some of  this--nothing beats a little Java in a JSP for quickly testing something out on your server.
But for the most part, you don’t want to use this for real, production pages.
The reason this is all on the exam is because the alternatives are still fairly new, so most of  the pages out there today are still “old-school”
For the time being, you still have to be able to work with it! At some point, when the new Java-free techniques hit critical mass, the objectives from this chapter will probably drop off  the exam, and we’ll all breathe a collective sigh at the death of  Java-in-JSPs.
Note to parents and teachers: the four-letter word implied in this thought bubble, that starts with “f”, followed by three asterisks, is NOT what you think.
It was just a word that we found too funny to include without distracting the reader, so we bleeped it out.
But certainly an answer to two big complaints about putting actual Java into a JSP:
Java code in a JSP is hard to change and maintain.
Of  course right now you’re thinking, “But if  I want my JSP to use custom methods, how can I declare and write those methods if  I can’t use Java?”
The purpose of  EL is to offer a simpler way to invoke Java code—but the code itself  belongs somewhere else.
That means in a regular old Java class that’s either a JavaBean, a class with static methods, or something called a Tag Handler.
In other words, you don’t write method code into your JSP when you’re following today’s Best Practices.
You write the Java method somewhere else, and call it using EL.
Oh if only there were a way in a JSP to use simple tags.
Sneak peek at EL The entire next chapter is on EL, so we won’t go into details here.
The only reason we’re covering it is because it’s yet another kind of  element (with its own syntax) that goes in a JSP, and the exam objectives for this chapter include recognizing everything that can go into a JSP.
Sure, it’s a little shorter, but is that worth a whole new scripting language and JSP coding approach?
A: You SO haven’t seen the full benefit of EL yet.
The differences will become obvious in the next chapter when we dive in.
But you must remember that to a Java programmer, EL is NOT neccessarily a dramatic development advantage.
In fact, to a Java programmer it simply means “one more thing (with its own syntax and everything) to learn, when, hey, I already KNOW Java...”
And for a Java programmer, it is still much easier to maintain a scriptless page.
It doesn’t let web page designers completely off the hook, but you’ll soon see that it’s more intuitive and natural for a web designer to use EL.
For now, in this chapter, you simply need to be able to recognize EL when you see it.
And don’t worry at this point about recognizing whether the expression itself is valid—all we care about now is that you can pick out an EL expression in a JSP page.
And just HOW do you expect me to get my programmers to stop using scripting elements in their.
Easy—you can put an element in the DD that disables all scripting elements!
Watch out—you might have seen other books or articles show a page directive that disables scripting.
In a draft version of  the 2.0 spec, there was a page directive attribute:
This does not work! The isScriptingEnabled attribute is no longer in the JSP spec!
You can choose to ignore EL Yes, EL is a good thing that’s going to save the world as we know it.
Think back to when the assert keyword was added to the Java language with version 1.4
Suddenly the formerly unreserved and perfectly legal identifier “assert” meant something to the compiler.
So if  you had, say, a variable named assert, you were screwed.
If  you knew you were writing (or recompiling) code that didn’t use assert as an identifier, then you could choose to enable assertions.
El is enabled by default! If  you want EL-looking things in your JSP to be ignored, you have to say so explicitly, either through a page directive or a DD element.
If  you want EL-looking things in your JSP to be ignored, you have to say so.
Although that’s misleading, because there are some actions that aren’t considered standard actions, but which are still part of  a now-standard library.
In other words, you’ll later learn that some of  the non-standard (the objectives refer to them as custom) actions are...
In a later chapter when we get to “using tags”, we’ll have a slightly richer vocabulary with which to talk about this in more detail, so relax.
For now, all we care about is recognizing an action when you see it in a JSP!
Look at the syntax for an action, and compare it to the syntax for the other kinds of JSP elements.
What are the differences between an action element and a scriptlet?
How will you recognize an action when you see it?
Think about what happens when each of these settings (or combination of settings) occurs.
You’ll see the answers when you turn the page, so do this one NOW.
Place a checkmark in the evaluated column if the settings would cause the EL expressions to be evaluated, OR place a checkmark in the ignored column if EL will be treated like other template text.
Place a checkmark in the evaluated column if the settings would cause the scripting expressions to be evaluated, OR place a checkmark in the error column if scripting will cause a translation error.
Remember, you’ll have Drag and Drop questions on the real exam similar to this exercise, so don’t skip it!
Put the element in the box corresponding to where that element’s generated code will go in the servlet class fi le.
Note that the magnet itself does not represent the ACTUAL code that will be generated.
Of course the word “expression” i s overloaded for JSP elements.
Declarations are for MEMBER declarations, so they go inside the c.
NOTE: remember that the JSP c ode doesn’t actually GO into the.
All files with the specified extension mapping should be treated by the JSP container as well-formed XML files.
All files with the specified extension mapping should have any Expression Language code evaluated by the JSP container.
By default, all files with the specified extension mapping should NOT have any Expression Language code evaluated by the JSP container.
Although this tag is legal, it is redundant, because the container.
The directive turns off  the evaluation of  Expression Language code.
The JSP containing this directive should be treated by the JSP container as a well-formed XML file.
The JSP containing this directive should NOT have any Expression Language code evaluated by the JSP container.
Given a request with two parameters: one named “first” represents a user’s first name and another named “last” represents his last name.
You can disable scripting programmatically by using the isScriptingEnabled page directive attribute.
None of  the lines in this example contain template text.
All four lines in this example would be valid in a JSP page.
In sequence, what are the Java types of  the following JSP implicit objects: application, out, request, response, session?
Which is an example of  the syntax used to import a class in a JSP?
An exception will be thrown because all taglib directives must precede any page directives.
All files with the specified extension mapping should be treated by the JSP container as well-formed XML files.
All files with the specified extension mapping should have any Expression Language code evaluated by the JSP container.
By default, all files with the specified extension mapping should NOT have any Expression Language code evaluated by the JSP container.
Although this tag is legal, it is redundant, because the container.
Option C turns off the evaluating of EL expressions by a JSP 2.0 container and by default the container does evaluate EL.
The directive turns off  the evaluation of  Expression Language code.
The JSP containing this directive should be treated by the JSP container as a well-formed XML file.
The JSP containing this directive should NOT have any Expression Language code evaluated by the JSP container.
JSPs turn into plain old servlets, so they have access to the plain old ServletConfig and ServletContext objects...
Option B is incorrect because the directive only affects the enclosing JSP.
Remember the underscore is your clue that a method can’t be overridden.
Given a request with two parameters: one named “first” represents a user’s first name and another named “last” represents his last name.
Options A, B, and D don’t exist as implicit objects created by the container for JSPs.
Option A uses the “out” implicit object and its println() method.
Options C and D are missing the “out” implicit object.
Option B shows the correct use of the application implicit object.
You can disable scripting programmatically by using the isScriptingEnabled page directive attribute.
None of  the lines in this example contain template text.
All four lines in this example would be valid in a JSP page.
Option C is incorrect because all four lines include template text.
Option D is incorrect because line 12 does not include a JSP standard action.
Option E is incorrect because the EL in line 11 is valid.
In sequence, what are the Java types of  the following JSP implicit objects: application, out, request, response, session?
Option C shows the Java type of each implicit object.
Which is an example of  the syntax used to import a class in a JSP?
Option C is the only example that shows the correct syntax.
Option E is invalid because there is no import directive.
An exception will be thrown because all taglib directives must precede any page directives.
Option A the EL expression is ignored and passed through verbatim.
Patterned after JavaScript and XPath, web designers feel right at.
Everything in my life is better since I stopped using.
Write a code snippet using top-level variables in the EL.
This includes the following implicit variables: pageScope, requestScope, sessionScope, and applicationScope; param and paramValues; header and headerValues; cookies; and initParam.
Write a code snippet using the following EL operators: aritmetic operators, relational operators, and logical operators.
For EL functions: Write a code snippet using an EL function; identify or create the TLD file structure used to declare an EL function; and identify or create a code example to define an EL function.
Given a design goal, create a code snippet using the following standard actions: jsp:include, jsp:forward, and jsp:param.
All of  the objectives in this section are covered completely in this chapter.
Take your time in this chapter; there’s a lot of picky details to go through.
Given a specific design goal for including a JSP segment in another page, write the JSP code that uses the most appropriate inclusion mechanism (the include directive or the <jsp:include> standard action)
Our MVC app depends on attributes Remember in the original MVC beer app, the Servlet controller talked to the model (Java class with business logic), then set an attribute in the request scope before forwarding to the JSP view.
The JSP had to get the attribute from the request scope, and use it to render a response to send back to the client.
Here’s a quick, simplified look at how the attribute goes from controller to view (just imagine the servlet talks to the model):
Use a scripting expression to get the attribute and print it to the response.
But what if the attribute is not a String, but an instance of Person? And not just a Person, but a Person with a “name” property.
We’re using the term “property” in the non-enterprise JavaBean* way—the Person class has a getName() and setName() method pair, which in the JavaBean spec means Person has a property called “name”
Don’t forget that the “name” property means a change in case for the first letter, “n”
In other words, the name of  the property is what you get when you strip off  the prefix “get” and “set”, and make the first character after that lower case.
We can tell from the getter/setter pair that Person has a property called “name” (note the lowercase “n”)
We’ll talk about JavaBeans in a few pages, but for now, just know that it’s a plain old Java class that has getters and setters that follow a naming convention.
We need more code to get the Person’s name Sending the result of  getAttribute() to print/write statement doesn’t give us what we want—it just runs the object’s toString() method.
The one that can be summarized as “Use Scripting and Die”
Person is a JavaBean, so we’ll use the bean-related standard actions With a couple of  standard actions, we can eliminate all the scripting code in our JSP (remember: scripting code includes declarations, scriptlets, and expressions) and still print out the value of  the person attribute’s name property.
Don’t forget that name is not an attributeonly the person object is an attribute.
The name property is simply the thing returned from a Person’s getName() method.
But how does the Container know what “person” means?  If  we had only the <jsp:getProperty> tag in the JSP, it’s almost like using an undeclared variable—the name “person”
The Container usually has no idea what you’re talking about, unless you FIRST put a <jsp:useBean> into the page.
This will match the “id” value from the <jsp:useBean> tag.
Look at the code from the generated servlet, and you’ll see what’s happening—there’s an if test in there! It checks for a bean based on the values of  id and scope in the tag, and if  it doesn’t get one, it makes an instance of  the class specified in class, assigns the object to the id variable, then sets it as an attribute in the scope you defined in the tag.
A: Ah...you bumped into a difference between Tomcat, and the JSP spec.
Which is funny, because Tomcat is supposed to be THE “Reference Implementation” of the spec, but whatever.
In this case, Tomcat is being friendlier than the spec guarantees.
It’s stranger than that, actually, because the spec actually encourages (but does not require) a Container to NOT work the way Tomcat does.
Declare a variable base d on the value of id.
Tries to get the attri bute at the scope you.
BUT, if there was NOT an attribute with that name at that scope...
Finally, set the new object as an attribute at the scope you defined.
You can use <jsp:setProperty> But you already knew that where there’s a get there’s usually a set.
The <jsp:setProperty> tag is the third and final bean standard action.
This could be a bad thing—I don’t WANT to have a bean.
That’s worse! NOW it means that if the bean already.
It runs ONLY if the bean isn’t found and a new one is created.Finally we close off the tag.
Q: Why didn’t they just let you specify arguments to the constructor of the bean? Why do you have to go through the extra trouble of setting values anyway?
A: The simple answer is this: beans can’t HAVE constructors with arguments! Well, as a Java class, they can, but when an object is going to be treated as a bean, Bean Law states that ONLY the bean’s public, no-arg constructor will be called.
In fact if you do NOT have a public no-arg constructor in your bean class, this whole thing will fail anyway.
We’re talking JavaBeans—NOT Enterprise JavaBeans (EJB) which is completely unrelated.
The plain old non-enterprise JavaBeans spec defines what it takes for a class to be a JavaBean.
Although the spec actually gets pretty complex, the only things you need to know for using beans with JSP and servlets are.
You MUST name your public getter and setter methods starting with “get” (or “is”, for a boolean) and “set”,  followed by the same word.
The property name is derived from stripping off the “get” and “set”, and changing the first character of what’s left to lowercase.
The property name and type are derived from the getters and setters and NOT from a member in the class.
For example, just because you have a private int foo variable does NOT mean a thing in terms of properties.
In other words, you have a property simply because you have a getter and setter.
For use with JSPs, the property type SHOULD be a type that is either a String or a primitive.
If it isn’t, it can still be a legal bean, but you won’t be able to rely only on standard actions, and you might have to use scripting.
The Container puts the extra property-setting code inside the if test.
Remember you aren’t expected to know the Tomcat implementation code...only the end result.
Can you make polymorphic bean references? When you write a   <jsp:useBean>, the class attribute determines the class of  the new object (if  one is created)
It also determines the type of  the reference variable used in the generated servlet.
Imagine we want the reference type to be Person, and the new object type to be Employee.
Adding a type attribute to <jsp:useBean> With the changes we just made to the Person class, we’re in trouble if the attribute can’t be found:
We need to make the reference variable type Person, and the object an instance of  class Employee.
Adding a type attribute to the tag lets us do that.
Type can be a class type, abstract type, or an interface—anything that you can use as a declared reference type for the class type of  the bean object.
If  the class type can’t be assigned to the reference type, you’re screwed.
So that means the class must be a subclass or concrete implementation of  the type.
Using type without class What happens if  we declare a type, but not a class? Does it matter if  the type is abstract or concrete?
Result if the person attribute already exists in “page” scope.
Result if the person attribute does NOT exist in “page” scope.
Q: In your example, “foo.Person” is an abstract type, so of COURSE it can’t be instantiated.
What if you change the type to “foo.Employee”? Will it use the type for both the reference AND the object type?
If the Container discovers that the bean doesn’t exist, and it sees only a type attribute without a class, it knows that you’ve given it only HALF of what it needs—the reference type but not the object type.
In other words, you haven’t told it what to make a new instance of!
There is no fallback rule that says, “If you can’t find the object, go ahead and use the type for BOTH the reference and the object.” No, that is NOT how it works.
Bottom line: if you use type without class, you better make CERTAIN that the bean is already stored as an attribute, at the scope and with the id you put in the tag.
If type is used without class, the bean must already exist.
If class is used (with or without type) the class must NOT be abstract, and must have a public no-arg constructor.
Be prepared to recognize that t his will NEVER work! You’ll get.
Be SURE that you remember: type == reference type class == object type.
Now imagine that a servlet does some work and then forwards the request to the JSP that has the code above.
Figure out what the JSP code above would do for each of the three different servlet code examples.
Going straight from the request to the JSP without going through a servlet...
We know we can do it with a combination of  standard actions and scripting:
We can even do it with scripting INSIDE a standard action:
You can send a request parameter straight into a bean, without scripting, using the param attribute.
The param attribute lets you set the value of a bean property to the value of a request parameter.
And all you have to do is make sure your form input field name (which becomes the request parameter name) is the same as the property name in your bean.
Then in the <jsp:setProperty> tag, you don’t have to specify the param attribute.
If  you name the property but don’t specify a value or param, you’re telling the Container to get the value from a request parameter with a matching name.
If we change the HTML so that the input fi eld name matches the property name:
If the request parameter name matches the bean property name, you don’t need to specify a value in the <jsp:setProperty> tag for that property.
Watch what happens if  you make ALL the request parameter names match the bean property names.
Bean tags convert primitive properties automatically If  you’re familiar with JavaBeans from any earlier lifetime, this is no surprise to you.
JavaBean properties can be anything, but if  they’re Strings or primitives, all the coercing is done for you.
That’s right—you don’t have to do the parsing and conversion yourself.
The <jsp:setProperty> action takes the String request parameter, converts it to an int, and passes that int to the bean’s setter method for that property.
Yes, something will definitely go wrong if the request parameter for the empID property can’t be parsed into an int.
You need to validate the contents of that field, to make sure it contains only numeric characters.
You could send the form data to a servlet first, instead of sending it straight to the JSP.
But if you’re committed to going from the form straight to the JSP, and you don’t want scripting, just use JavaScript in the HTML form to check the field before sending the request.
If you’re not familiar with JavaScript (which of course has virtually NOTHING to do with Java), it’s a simple scripting language that’s processed on the client side.
A quick Google search on “JavaScript validate input field” should turn up some scripts you can use to stop users from entering, say, anything but numbers into an input field.
Q: If a bean property doesn’t have to be a String or a primitive, then HOW can you set the property without scripting? The value attribute of the tag is always a String, right?
A: It is possible (but potentially a *lot* of extra work) to create a special class, called a custom property editor, that supports the bean.
It takes your String value and figures out how to parse that into something that can be used to set a more complex type.
This is part of the JavaBeans spec, though, not the JSP spec.
Also, if the value attribute in the <jsp:setProperty> tag is an expression rather than a String literal,  then IF that expression evaluates to an object that’s compatible with bean property type, then it will probably work.
If you pass in an expression that evaluates to a Dog, for example, the Person bean’s setDog(Dog) method will be called.
But think about it—this means the Dog object must already exist.
Anyway, you’re way better off NOT trying to construct new things in your JSP! Trying to get away with constructing and setting even marginally complex data types is gonna be tough without scripting.
If you use the <jsp:setProperty> standard action tag with the property wildcard, OR just a property name without a value or param attribute (which means the property name matches the request parameter name), OR you use a param attribute to indicate the request parameter whose value should be assigned to the bean’s property, OR you type a literal value, the automatic conversion from String to int works.
Once again, the benefit of  using tags over scripting is more about the web page designers than about you (the Java programmer)
Although even Java programmers find that tags are easier to maintain than hard-coded Java scripting elements.
With the bean-related tags, the designer needs only the basic identification info (attribute name, scope, and property name)
The web designer doesn’t need any knowledge of  what’s really behind it, and they can think of  beans as simply records with fields.
You tell the designers the record (the class and the identifier) and the fields (the properties)
Still, the bean standard actions aren’t as elegant as they could be.
And that’s why this isn’t the end of  the story on scriptless pages.
The bean standard action tags are more natural to a non-programmer.
Whew! I am just SO relieved at how much easier.
But what if the property is something OTHER than a String or primitive? We know how easy it is to print an attribute when the attribute itself is a String.
Then we made an attribute that was a non-String object (a Person bean instance)
But we didn’t want to print the attribute (person)—we wanted to print a property of  the attribute (in our example, the person’s name and empID)
That worked fine, because the standard actions can handle String and primitive properties.
So, we know that standard actions can deal with an attribute of  any type, as long as all the attribute’s properties are Strings or primitives.
But what if  they’re not? What if  the bean has a property that is not a String or primitive? What if  the property is yet another Object type? An Object type with properties of  its own?
What if what we really want is to print a property of that property?
String or primitive? What if  the property is yet another Object type? An.
What if  we want to print the name of  the Person’s dog?
This time we make a Dog, give it a nam.
Trying to display the property of the property We know we can do it with scripting, but can we do it with the bean standard actions? What happens if  we put “dog” as the property  in the <jsp:getProperty> tag?
All we got was the result of Dog’s toString() method.
There’s no combination of  the bean standard actions that’ll work given the original servlet code, because the Dog is not an attribute! Dog is a property of  the attribute, so you can display the Dog, but you can’t navigate to the name property of  the Dog property of  the Person attribute.
The <jsp:getProperty> lets you access only the properties of  the bean attribute.
There’s no capability for nested properties, where you want a property of  a property, rather than a property of  the attribute.
Expression Language (EL) saves the day! Yes, just in time to save us, the JSP Expression Language (EL) was added to the JSP 2.0 spec, releasing us from the tyranny of  scripting.
This is it! We didn’t even declare what person means...
The exam doesn’t expect you to be a complete EL being.
Everything you might typically use, or be tested on, is covered in the next few pages.
So, if you want to study the EL spec, knock yourself out.
Just so you’re clear that WE didn’t tell you to do that.
Deconstructing the  JSP Expression Language ( EL) The syntax and range of  the language are dirt simple.
The tricky part is that some of EL looks like Java, but behaves differently.
You’ll see when we get to the [] operator in a moment.
So you’ll find things that wouldn’t work in Java but will work in EL, and viceversa.
Just don’t try to map Java language/syntax rules onto EL, and you’ll be fine.
For the next few pages, think of  EL as a way to access Java objects without using Java.
Of all the implicit objects, only pageContext is not a map.
If the first thing in the EL expression is an attribute, it can be the name of an attribute stored in any of the four available scopes.
Java reminder: a map is a collection that holds key/value pairs, like Hashtable and HashMap.
Note: EL implicit objects are not the same as the implicit objects available to JSP scripting, except for pageContext.
If the expression has a variable followed by a dot, the left-hand variable MUST be a Map or a bean.
The thing to the right of the dot MUST be a Map key or a bean property.
When the variable is on the left side of the dot, it’s either a Map (something with keys) or a bean (something with properties)
This is true regardless of whether the variable is an implicit object or an attribute.
The pageContext implicit object is a bean—it has getter methods.
If the object is a bean but the named property doesn’t exist, then an exception is thrown.And the thing on the right must follow.
The [] operator is like the dot only way better The dot operator works only when the thing on the right is a bean property or map key for the thing on the left.
But the [ ] operator is a lot more powerful and flexible...
The simple dot operator version works because person is a bean, and name is a property of person.
Or what if name is something that can’t be expressed with the normal Java naming rules?
When you use the dot operator, the thing on the left can be only a Map or a bean, and the thing on the right must follow Java naming rules for identifiers.
But with the [ ], the thing on the left can also be a List or an array (of  any type)
That also means the thing on the right can be a number, or anything that resolves to a number, or an identifier that doesn’t fit the Java naming rules.
If the expression has a variable followed by a bracket [ ], the left-hand variable can be a Map, a bean, a List, or an array.
If the thing inside the brackets is a String literal (i.e., in quotes), it can be a Map key or a bean property, or an index into a List or array.
This is a joke, right? Or else there’s more than punch.
I could SWEAR that those are quotes around the array index, and that’s just not right, dude...
A String index is coerced to an int for arrays and Lists.
Foods are: [chai ice cream, fajitas, thai pizza, anything in dark chocolate]
You’ll get an error if the index can’t be coerced.
The EL for accessing an array is the same as the EL for accessing a List.
In EL, the [ ] operator is NOT the array access operator.
We swear, look it up in the spec—it has no name! Just the symbol [ ]
The fact that you even used the word Hashtable shows how up to date YOU are.
Have you actually checked the date on the JavaBeans spec.
For beans and Maps you can use either operator For JavaBeans and Maps, you can use either the [] operator or the convenient dot operator.
Just think of  map keys the same way you think of  property names in a bean.
You ask for the key or property name, and you get back the value of  the key or property.
Make a Map, put some String keys and objects in it, then make it a request attribute.
If it’s NOT a String literal, it’s evaluated If  there are no quotes inside the brackets, the Container evaluates what’s inside the brackets by searching for an attribute bound under that name, and substitutes the value of  the attribute.
If  there is an implicit object with the same name, the implicit object will always be used.
Use the VALUE of that attribute as the key into the Map, or return null.
This does NOT work in a JSP (given the servlet code)
This is a valid EL expression, but it doesn’t do what we wanted.
In other words, you can put a complex expression inside a complex expression inside a...
And the expressions are evaluated from the inner most brackets out.
This part will seem completely intuitive to you, because it’s no different than nesting Java code within parens.
The tricky part is to watch out for quotes vs.
What prints? Given the servlet code below, fi gure out what would print (or if there’d be an error, just write, you know, “error”)
We’ll talk more about EL operators in a few pages.
Study the three classes on the page, and the servlet code on the opposite page, then construct the code magnets to make the EL that’ll produce the response shown in the browser.
Turn the page for the answers, but not until you DO THIS, especially if  you’re going to take the exam.
This is not the ONLY way to produce the output, but it’s the only way using this set of magnets.
Bonus exercise: write the EL expressions a little differently (forget the magnets), but print the same result.
The Case of  the Missing Content Documents-R-Us has created a content management system used primarily for creating tutorials for desktop applications.
Part of  the application allows content developers to create “Tip of  the Day” chunks of  content, which are stored in the request-scoped.
For example, if  the tip was “Wash your hair every other day,” then the screen.
Tip of the Day: Wash your hair every other day.
A new client is trying to create a tutorial using the system, but can’t seem to get the tips to display correctly.
For example, the tip “<b></b> tags make things bold!” is rendered like this:
What do you think? Did the bold tags get sent to the output stream? Why aren’t they being displayed?
So, the “<b></b>” portion of  the tip is being sent in the output stream, but the web browser is simply rendering it as raw HTML—by bolding an empty space on the page.
So, of  course the user does not see the “<b></b>” tags on the screen.
OK, so the tip string is being sent to the output stream, but Documents-R-Us wants to convert HTML special characters into a format that is rendered properly in their tips.
Whatever this evaluates to is treated as standard HTML, so any HTML tags are rendered, not.
The EL implicit objects Remember, EL has some implicit objects.
But these are not the same as the JSP implicit objects (except for one, pageContext)
Here’s a quick list; we’ll look at some of  them in more detail on the next few pages.
You’ll notice that all but one (pageContext again), are simple Maps—name/value pairs.
Remember that my HTML form action goes straight to the.
The  param implicit object is fine when you know you have only one parameter for that particular parameter name.
Use   paramValues when you might have more than one parameter value for a given parameter name.
In the client’s browser (client fi lls in the form and hits the submit button)
Even though there might be multiple values for the “food” parameter, you can still use the single param implicit object, but you’ll get only the first value.
What if you want more information from the request? What if  you want, say, the server host information that comes with the “host” header in the request? If  you look in the HttpServletRequest API, you can see a getHeader(String) method.
We know that if  we pass “host” to the getHeader() method, we’ll get back something like: “localhost:8080” (because that’s where the web server is)
The header implicit object keeps a Map of all the he.
Use either access operator to pass in the header name.
Can you figure out how to do it? Hint: look at the other implicit objects.
The  requestScope is NOT the request object The implicit requestScope is just a Map of  the request scope attributes, not the request object itself ! What you want (the HTTP method) is a property of  the request object, not an attribute at request scope.
In other words, you want something that comes from calling a getter method on the request object (if  we treat the request object like a bean)
But there is no request implicit object, only requestScope! What to do?
It’s so easy to think that, say, app licationScope is a reference to Se.
But just as with requestScope an d the request object, the scope M.
You can’t treat it like a S ervlet Context, so don’t expect to.
Scope implicit objects can save you If  all you need is to print the name of  a person, and you really don’t care what scope the person is in (or, you do care, but you know there’s only one person out of  all four scopes), you just use:
Or, if  you’re worried about a potential naming conflict, you can be explicit about which person you want:
Think about this scenario: if  you have a name that’s not in quotes in brackets [ ], that means it MUST adhere to Java naming rules, right? Here, we’re OK, because person is a perfectly legal Java variable name.
But an attribute name is a String! Strings don’t follow Java variable name rules!
And then you’d be in trouble, because THIS won’t work:
If EL looks through all the scopes anyway, why would.
I ever use one of the scope implicit objects? The only thing I can think of is a naming conflict, but I wonder if there might.
NO! This is certainly legal, but the Container just thinks that “foo” is an attribute somewhere, with a “person” property.
Perfect! Using the requestScope object gives us a way to put the attribute name in quotes.
Getting Cookies and init params We’ve looked at all the implicit objects except cookies and init params, so here we are.
And yes, any of  the implicit objects can show up on the exam.
Just give it the name, and the value comes back from the Map of Cookie names/values.
We have to confi gure the parameter in the DD.
She doesn’t know about EL functions When you need a little extra help from, say, a Java method, but you don’t want scripting, you can use an EL function.
It’s an easy way to write a simple EL expression that calls a static method in a plain old Java class that you write.
If only there were a way to have an EL expression call a Java method that returns a value...then I would.
Imagine you want your JSP to roll dice You’ve decided it would be awesome to have a web-based dice-rolling service.
The method MUST be public and static, and it can have arguments.
It should (but isn’t required to) have a non-void return type.
After all, the whole point is to call this from a JSP and get something back that you can use as part of the expression or to print out.
Put the class file in the /WEB-INF/classes directory structure (matching the appropriate package directory structure, just like you would with any other class)
For an EL function, the TLD provides a mapping between the Java class that defines the function and the JSP that calls the function.
That way, the function name and the actual method name can be different.
You might be stuck with a class with a really stupid method name, for example, and maybe you want to provide a more obvious or intuitive name to page designers using EL.
No problem—the TLD says, “This is the Java class, this is the method signature for the function (including return type) and this is the name we’ll use in EL expressions”
In other words, the name used in EL doesn’t have to be the same as the actual method name, and the TLD is where you map that.
There are other places the TLD can go; we’ll talk about that in the next two chapters.
The taglib directive tells the Container, “I’m going to use this TLD, and in the JSP, when I want to use a function from this TLD, I’m going to prefix it with this name...” In other words, it lets you define the namespace.
You can use functions from more than one TLD, and even if the functions have the same name, that’s OK.
The taglib directive is kind of like giving all your functions fully-qualified names.
You invoke the function by giving both the function name AND the TLD prefix.
The prefix “mine” is just the nickname we’ll use inside THIS page, so that we can tell one TLD from another (in case you DO have more than one)
It has to be somewhere within WEB-INF or one of  its subdirectories (unless it’s deployed in a JAR file, but we’ll talk about that later in the book)
The key point is that the class with the static function MUST be available to the app, so...
And remember that in the taglib directive in the JSP, we specified a URI that matches the URI declared in the TLD.
For now, think of  the URI as simply whatever you decided to  name the TLD.
In the next chapter on using custom tags, we’ll go into all the details about TLDs and URIs.
The TLD that declares the function class, method signature, and function name.
The Java class with the function (a public static method)
The class with the function (the public static method) must be available to the web app just like servlet, bean, and listener classes.
Put the TLD file somewhere under WEB-INF, and make sure the taglib directive in the JSP includes a uri attribute that matches the <uri> element in the TLD.
This is an identifier that must match the <uri> inside the TLD.
A: No! It’s NOT the same with EL functions, although just about everybody finds that...
Q: How did the Container fi nd the TLD? The URI doesn’t match the path or fi le name of the TLD.
A:  Just the question we were hoping someone would ask.
Yes, you’re right—we never did tell the Container exactly where to find the real TLD file.
When the app is deployed, the Container searches through WEB-INF and its subdirectories (or in JAR files within WEBINF/lib) looking for .tld files.
When it finds one, it reads the URI and creates a map that says, “The TLD with this URI is actually this file at this location...” There’s a little more to the story that we’ll cover in the next chapter.
Just remember in the TLD to specify the fully-qualified class name (unless it’s a primitive) for each argument.
What you use in EL to invo ke the function must.
The correct tag for the function na me is <name>!
You probably won’t (and shouldn’t) do calculations and logic from EL.
Remember, a JSP is the View, and the View’s job is to render the response, not to make Big Important Decisions or do Big Processing.
If  you need real functionality, that’s normally the job of  the Controller and Model.
For lesser functionality, you’ve got custom tags (including the JSTL tags) and EL functions.
So, with that perspective, here’s a look at the most useful EL artithmetic, relational, and logical operators.
Addition:    + Subtraction:   Multiplication:  * Division:    /   and   div Remainder:    %  and   mod.
You can already see 11 of them o n this page—the.
Look at the servlet code, then figure out what prints next to each EL expression.
You’ll have to guess in a few places, since we haven’t covered every possible rule.
This exercise will help you figure out how EL behaves.
Another hint: the actual nine answers are printed at the bottom of this page upside down, but they are NOT in any order.
But if you really need help, at least you’ll have the nine answers, and you can use elimination to figure out where they all go.
Why? Because they figured “it’s better to show a partial, incomplete page than to show the user an error page.”
Assume that there is not  an attribute named “foo”, but there IS an attribute named “bar”, but that “bar” does not have a property or key named “foo”
In logical expressions, EL treats the unknown variable as “false”
In logical expressions, EL treats the null value as “false”
The first named variable in the expression is either an implicit object or an attribute in one of the four scopes (page, request, session, or application)
The [ ] operator is more powerful than the dot, because it lets you access arrays and Lists, and you can put other expressions including named variables within the brackets, and you can nest them to any level you can stand.
If what’s inside the brackets is not in quotes, the Container evaluates it.
If it is in quotes, and it’s not an index into an array or List, the Container sees it as the literal name of a property or key.
All but one of the EL implicit objects are Maps.
From the Map implicit objects you can get attributes from any of the four scopes, request.
The non-map implicit object is pageContext, which is a reference to...
Don’t confuse the implicit EL scope objects (Maps of the attributes) with the objects to which the attributes are bound.
In other words, don’t confuse the requestScope implicit object with the actual JSP implicit request object.
The only way to access the request object is by going through the pageContext implicit object.
To use a function in a JSP, you must declare the namespace using a taglib directive.
Put a prefix attribute in the taglib directive to tell the Container the TLD in which the function you’re calling can be found.
Reusable template pieces You have headers on every page on your web site.
You have the same footer on every page as well.
How stupid would it be to code in the same header and footer tags into every JSP in your web app?
If  you’re thinking like a Java programmer (which of  course you are), you know that doing that is about as un-OO as it gets.
The thought of  all that duplicate code probably makes you feel a little sick.
What happens when the site designer makes, oh, a tiny little change to the header or footer?
There’s a mechanism for handling this in a JSP—it’s called include.
You write your JSP in the usual way, except that instead of  putting the reusable stuff  explicitly into the JSP you’re authoring, you instead tell the Container to include the other file into the existing page, at the location you select.
If ANYONE knows about reusable components it’s a Java programmer.
Standard header file (“Header.jsp”) We want this HTML content on.
The include directive tells the Container one thing: copy everything in the included file and paste it into this file, right here...
The <jsp:include> standard action appears to do the same thing as the include directive.
We took this code directly out of  the _jspService() method from Tomcat’s generated servlet code...
The include directive just takes the contents of the “Header.jsp” file and places it into the “Contact.jsp” page BEFORE it does the translation!
This is different! The original Header.jsp file is NOT inside the generated servlet.
The include directive happens at translation time <jsp:include> happens at runtime With the include directive, there is NO difference between you opening your JSP page and pasting in the contents of  “Header.jsp”
In other words, it really is just as though you duplicated the code from the header file into your other JSP.
Except the Container does it at translation time for you, so that you don’t have to duplicate the code everywhere.
You can write all your pages with an include directive, and the Container will go through the trouble of  copying the header code into each JSP before translating and compiling the generated servlet.
Rather than copying in the source code from “Header.jsp”, the include standard action inserts the response of  “Header.jsp”, at runtime.
The key to <jsp:include> is that the Container is creating a RequestDispatcher from the page attribute and applying the include() method.
Q: So why wouldn’t you always use <jsp:include>? That way you can guarantee you’ll always have the latest content.
With the directive, on the other hand, the hit happens only once—when the including page is translated.
So if you’re pretty sure that once you go to production the included file won’t change, the directive might be the way to go.
Of course there’s still the tradeoff that the generated servlet class is a little larger when you use the directive.
Q: I tried this with Tomcat— I made a static HTML fi le, and included it with the directive.
Yes, most of the newer Containers have a way of detecting when the included files have changed, and they do retranslate the including file and everything’s great.
The problem is that this is NOT GUARANTEED BY THE SPEC! So if you write your code to depend on it, your app won’t necessarily be portable to other Containers.
The client makes a request for Contact.jsp, which has not been translated.
The Container reads the Contact.jsp page to start the translation process.
The container sees the include directive, and combines the source code of Header.jsp and Contact.jsp, and creates/translates that into a Java source fi le for the generated servlet.
The Container compiles the translated source fi le into a servlet class.
It’s just like any other servlet at this point, and the previous step never has to happen again, unless Contact.jsp changes (or, if your Container is smart and can tell that the included Header.jsp has changed)
To complete the request, the Container loads the newlycompiled class, initializes a servlet (instantiates the servlet then calls init() on the new object), allocates a thread for the request, and calls the _jspService() method.
From the second request on, the Container does only step (C): allocates a thread and calls the.
The include directive at first request With the include directive, the Container has a lot of  work to do, but only on the first request.
From the second request on, there’s no extra runtime overhead.
The Container reads the Contact.jsp page to start the translation process.
The container sees the include standard action, and uses that to insert a method call in the generated servlet code that—at runtime—will dynamically combine the response from Header.
This is not dictated by the spec, so we’re showing only an example of how it could work.
The Container compiles the translated source fi le into a servlet class.
The generated servlet class fi le is loaded into the Container’s JVM and is initialized.
Next, the Container allocates a thread for the request and calls the JSP’s _jspService()  method.
The Contact servlet hits the method that does the dynamic include, and something vendor-specifi c happens! All we care about is that the response generated by the Header servlet is combined with the response from the Contact servlet (at the appropriate place)
The <jsp:include> standard action at first request With the include standard action, there’s less work at translation time, and more work with each request, especially if  the included file is a JSP.
Memorize this! Look at the attri butes for the two include.
The directive attribute is fi le but the standard action.
And it’s the ONLY directive whose position in the JSP actually matters.
With a page directive, for example, you can put it anywhere in the page, although by convention most people put page directives at the top.
But the include directive tells the Container exactly WHERE to insert the source from the included fi le! For example, if you’re including both a header and a footer, it might look something like this:
Q: Can the included JSP have its own dynamic content? In your examples, the Header.jsp might as well have been a static Header.html page.
A: It’s a JSP, so yes it can be dynamic (but you’re rightin our example we could have made the header a static HTML page and it would have worked in exactly the same way)
There are a few limitations, though: an included page CANNOT change the response status code or set headers (which means it can’t call, say, addCookies())
You won’t get an error if the included JSP tries to do things it can’t—you just won’t get what you asked for.
Q: But if the included thing is dynamic, and you’re using the static include directive, does that mean that the dynamic stuff  is evaluated only once?
A: Let’s say you include a JSP that has an EL expression that calls the rollIt function that generates a random number.
Remember, with the include directive, that EL expression is simply copied into the includING JSP.
So each time that page is accessed, the EL expression runs and a new random number is generated.
Burn this in: with the include directive, the source of the included thing becomes PART of the page with the include directive.
This has to be at the bottom of your JSP (before the closing tags), if that’s where you want the stuff from Footer.html to appear.
It was a nice JSP all on its own, complete with its opening and closing HTML and BODY tags.
Then we made the “Contact.jsp” and it, too, had nice opening and closing tags.
Well, didn’t we say that everything in the included file is pasted (virtually) into the page with the include? That means everything.
The code below, from the generated servlet, will NOT work in all browsers.
The way we SHOULD have done it Here we took the opening and closing tags out of  the included files.
This does mean that the included files can no longer generate valid HTML pages on their own; they now depend on being included in something bigger.
But that’s the point—you’re designing these reusable chunks so that you can compose complete layouts from smaller pieces, without duplicating the code by hand.
These reusable chunks aren’t meant to live on their own.
Notice we took out all the HTML and BODY tags from the included files.
Customizing the included content with <jsp:param> OK, so you’ve got a header that’s supposed to appear the same way on every page.
But what if  you want to customize part of  the header? What if  you want, say, a contextsensitive subtitle that’s part of  the header, but that changes depending on the page?
The dumb way: put the subtitle information into the main page, as, say, the first thing in your page after the include for the header.
The smarter way: pass the subtitle information as a new request parameter to the included page!
Why that’s cool: if  the subtitle information is supposed to be part of  the header, but it’s a part that changes, you still want the header part of  the template to make the decision about how that subtitle should appear in the final page.
In other words, let the person who designed the header decide how the subtitle should be rendered!
To the included file, the param set with <jsp:param> is just like any OTHER request parameter.
Note: this idea of params doesn’t make any sense with the include directive (which is not dynamic), so it applies ONLY to the <jsp:include> standard action.
The <jsp:forward> standard action You CAN forward from one JSP to another.
Or from one JSP to any other resource in your web app.
Of  course, you don’t usually want to do this in production, because if  you’re using MVC, the View is supposed to be the View! And the View has no business doing control logic.
In other words, it shouldn’t be the View’s job to figure out if  the guy is logged in or not—someone else should have made that decision (the Controller), before deciding to forward to the View.
But let’s suspend all that good MVC judgement for the time being, and see how we could do it, if  we were to forward from a JSP page to something else.
Why bother if  you’ll never do it? Well, you might one day stumble on a problem where <jsp:forward> is a useful solution.
More importantly, like a lot of  what’s in the book (and the exam), the use of  <jsp:forward> is outthere.
Lurking in gazillions of  JSPs that you might one day find yourself  maintaining (or ideally refactoring)
So imagine you’re a JSP and you assume you’re being called from a request that includes a userName parameter.
Since you’re counting on that parameter, you want to first check that the userName parameter isn’t null.
But if  the userName parameter is null, you want to stop right here and turn the whole request over to something else—like a different JSP that will ask for the userName.
For now, we know we can do it with scripting:
If the parameter was null, forward the request (just like using a RequestDispatcher) to the page specified in the attribute.
If we made it this far, the userName must have been valid! NOTHING in this page will appear in the response if the request is forwarded.
This is just a plain old page that gets the request parameter input from the user and then requests the JSP we were just on...
The first time you request the Hello.jsp, the JSP does the conditional test, discovers there’s no value for userName, and forwards to the HandleIt.jsp.
Assuming the user types a name into the name input field, the second request won’t do the forward, since the userName request parameter has a non-null value.
How come the “Welcome to our page!” text didn’t print out the first time?
With <jsp:forward>, the buffer is cleared BEFORE the forward When a forward happens, the resource to which the request is forwarded starts with a clear response buffer! In other words, anything written to the response before the forward happens is thrown out.
But what if you commit the response BEFORE you do the forward? Like, what happens if you write something and then call flush() on the out object?
A: OK, we know you’re just asking this out of intellectual curiosity since it would be a phenomenally stupid and pointless thing to do.
The Container dutifully commits (sends) “Welcome to our page!” as the response and then the Container sees the forward.
Except nobody will see the exception! The client just sees “Welcome to our page!”...
The forward throws an exception but it’s too late for the Container to take back the response, so the client sees what was flushed, and that’s it.
The forward doesn’t happen, the rest of the current page doesn’t happen.
She doesn’t know about JSTL tags When you need more functionality, something beyond what you can get with the standard actions or EL, you don’t have to resort to scripting.
Here’s a sneak peek of  how to do our conditional forward without scripting.
If only there were a way to do a conditional test without having to go back to scripting...
The <jsp:useBean> standard action defines a variable that holds a reference to either an existing bean attribute or, if the bean doesn’t already exist, a new bean.
The <jsp:useBean> MUST have an “id” attribute which declares the variable name that’ll be used in this JSP to refer to the bean.
The type must be public, non-abstract, and have a public no-arg constructor.
If you put a “type” attribute in <jsp:useBean>, it must be a type to which the bean can be cast.
If you have a “type” attribute but do NOT have a “class” attribute, the bean must already exist, since you haven’t specified the class type that should be instantiated for the new bean.
The “property” attribute must be either an actual property name or the wildcard “*”
If you don’t include a “value” attribute, the Container will set the property value only if there’s a request parameter with a name that matches the property name.
If you use the wildcard (*) for the “property” attribute, the Container will set the value of all properties that have a matching request parameter name.
If the request parameter name is different from the property name but you want to set the value of the property equal to the request parameter value, you can use the “param” attribute in the <jsp:setProperty> tag.
If the property is “*”, then the JSP will iterate over all request parameters to set the JavaBean properties.
Property values can be Strings or primitives, and the <jsp:setProperty> standard action will do the conversions automatically.
You can build a page with reusable components using one of two include mechanisms—the include directive or the <jsp:include> standard action.
The include directive does the include at translation time, only once.
So the include directive is considered the appropriate mechanism for including content that isn’t likely to change after deployment.
The include directive essentially copies everything from within the included file and pastes it into the page with the include.
The Container combines all the included files and compiles just one file for the generated servlet.
At runtime, the page with the include runs exactly as though you had typed all the source into one file yourself.
The <jsp:include> standard action includes the response of the included page into the original page at runtime.
So the include standard action is considered appropriate for including content that may be updated after deployment, while the include directive is not.
Either mechanism can include dynamic elements (JSP code with EL expressions, for example) as well as static HTML pages.
The include directive is the only position-sensitive directive; the included content is inserted into the page at the exact location of the directive.
The attributes for the include directive and the include standard action are inconsistently named—the directive uses “file” as the attribute while the standard action uses a “page” attribute.
In your reusable components, be sure to strip out the opening and closing tags.
Design and construct your reusable pieces knowing that they’ll be included/inserted into something else.
If the param name used in <jsp:param> already has a value as a request parameter, the new value will overwrite the previous one.
Otherwise, a new request parameter is added to the request.
The included resource has some limitations: it cannot change the response status code or set headers.
The <jsp:forward> standard action forwards the request (just like using a RequestDispatcher) to another resource from the same web app.
When a forward happens, the response buffer is cleared first! The resource to which the request was forwarded gets to start with a clean output.
So anything written to the response before the forward will be thrown away.
If you commit the response before the forward (by calling out.flush(), for example), the client will be sent whatever was flushed, but that’s it.
The forward won’t happen, and the rest of the original page won’t be processed.
The Container KNOWS that if you have only a type specified, there MUST be an existing bean attribute of that name and scope.
We cheated a little, since on this question it isn’t “Be the Container”, it’s more like “Be the COMPILER”
Given an HTML form that uses checkboxes to allow a user to select multiple values for a parameter called hobbies.
Given that a web application stores the webmaster email address in the servlet context initialization parameter called master-email.
Given a Model 1 architecture in which a JSP page handles all of  the controller functions, that JSP controller needs to dispatch the request to another JSP page.
In an HTML page with a rich, graphical layout, which JSP standard action can be used to import an image file into the JSP page?
It is valid to include both the class attribute and the type.
Which, inserted at line 2 in the JSP, is a valid EL function invocation?
The user has sufficiently logged in or out: or true.
Given that the application’s top level directory is myapp, what is the path to the header.html file?
An online jewelry retailer wishes to customize their online catalog for users who are logged in.
They want to show specials for the user's birthstone month.
There is a bean stored as a session-scoped attribute named userInfo.
Which of  the following code snippets could correctly retrieve the appropriate special offerings?
A web based application for a major online movie rental retailer stores a List<Movie> as a session attribute to contain movies the user has requested.
A random, embedded movie trailer from this list must display on the users’ main page every time the users’ main page is viewed.
Management thinks a similar feature will be needed in the near future on other pages that display lists of  movies.
Streaming video is accomplished with regular HTML, just like adding images to a page but with more complex tags.
The development team needs a solution that is both flexible and maintainable.
The following statements are from a team meeting concerning EL functions as a solution to this problem.
The method implementing the EL function should not be declared static to give it access to session scope.
The EL function can accept a parameter of  java.util.List which will allow the needed movie list to be passed to it using EL.
You might have to write HTML tags in the middle of  Java code using an EL function, which is more difficult to maintain.
Given an HTML form that uses checkboxes to allow a user to select multiple values for a parameter called hobbies.
Given that a web application stores the webmaster email address in the servlet context initialization parameter called master-email.
Option B is incorrect because there is no “paramValue” implicit variable.
Option D is incorrect because the function signature is incomplete.
Option  A is invalid because the type attribute is NOT used to create a new instance and the scope attribute must be specified (or defaults to page)
Option B is invalid for all of the above reasons plus jsp:makeBean is NOT a real tag.
Option D is invalid because jsp:makeBean is NOT a real tag.
Given a Model 1 architecture in which a JSP page handles all of  the controller functions, that JSP controller needs to dispatch the request to another JSP page.
Option B is invalid because the forward action has no file attribute.
Options C and D are invalid because there is no dispatch action.
Options A and C are incorrect because the dot operator cannot be used with a primitive.
Options D and E are incorrect because of the dash in User-Agent.
Option E is incorrect because EL tries to coerce ‘listIdx’ to a Long which is invalid.
The modulus operator returns the remainder of a division operation.
Options C and D are invalid because line 11 results in printing nothing rather than “null”
Option F is incorrect because this is NOT an implicit object.
Option C is incorrect because pageContext is NOT a Map and it doesn’t have a “foo” property.
Option A is invalid because line 13 prints the user’s last name as well.
In an HTML page with a rich, graphical layout, which JSP standard action can be used to import an image file into the JSP page?
It is valid to include both the class attribute and the type.
Options B and C are incorrect because scope is optional and defaults to page.
Option C is invalid, not bec ause the syntax of.
Option D is invalid because the include action does not take a file attribute.
This is a tricky question because it is NOT possible to import the contents of any binary file into a JSP page, which generates an HTML response.
Option A is incorrect because it uses an include directive, which is for static includes that happen at translation time.
Option D would be correct if it was a scriptlet: it functionally does the same thing as option C, but its syntax is only used by servlets.
Which, inserted at line 2 in the JSP, is a valid EL function invocation?
The necessary mapping information from the TLD  is NOT known.
The user has sufficiently logged in or out: or true.
Option B is correct because the EL expression using “or” will return true if either loggedIn or loggedOut is true.
Option D is incorrect because the dot operator can always be converted to the [] operator.
Given that the application’s top level directory is myapp, what is the path to the header.html file?
An online jewelry retailer wishes to customize their online catalog for users who are logged in.
They want to show specials for the user's birthstone month.
There is a bean stored as a session-scoped attribute named userInfo.
Which of  the following code snippets could correctly retrieve the appropriate special offerings?
It then attempts to get the month value from the user's birthday and uses that as the key to search for a Special[] in the Map.
Assuming a match is found in the Map, our Special[] is returned.
This EL could be used in a c:forEach tag to iterate over the returned specials.
A web based application for a major online movie rental retailer stores a List<Movie> as a session attribute to contain movies the user has requested.
A random, embedded movie trailer from this list must display on the users’ main page every time the users’ main page is viewed.
Management thinks a similar feature will be needed in the near future on other pages that display lists of  movies.
Streaming video is accomplished with regular HTML, just like adding images to a page but with more complex tags.
The development team needs a solution that is both flexible and maintainable.
The following statements are from a team meeting concerning EL functions as a solution to this problem.
The method implementing the EL function should not be declared static to give it access to session scope.
The EL function can accept a parameter of  java.util.List which will allow the needed movie list to be passed to it using EL.
You might have to write HTML tags in the middle of  Java code using an EL function, which is more difficult to maintain.
Option A: the movie list can be passed as a parameter to the function.
Option B: methods that implement EL functions must always be declared public and static.
Option C: a List may be passed to the function.
Doing so provides a more flexible solution than one that requires your EL function to handle session scope as in options a and b.
Option D: the biggest reason not to choose an EL function as the total solution.
The team chose to use a tag file as the solution but then also created an EL function that accepts a Collection and returns a random number based on the size of the collection.
What if you want to loop through the data in an array, and display one item per.
In this chapter we’ll learn to use custom tags, and.
Describe the syntax and semantics of the ‘taglib’ directive: for a standard tag library, for a library of Tag Files.
Given a design goal, create the custom tag structure to support that goal.
Identify the tag syntax and describe the action semantics of the following JSP Standard Tag Library (JSTL v1.1) tags: (a) core tags: out, set, remove, and catch, (b) conditional tags: if, choose, when, and otherwise, (c) iteration tags: forEach, and (d) URL-related: url.
All of  the objectives in this section are covered in this chapter, although some of  the content is covered again in the next chapter (Developing Custom  Tags)
In Tomcat 5, the two files are already in the example applications that ship out-of-the-box with Tomcat, so all you need to do is copy them from one directory and put them into your own app’s WEB-INF/lib directory.
And place it in your own web app’s WEB-INF/lib directory.
Developers usually want way more standard actions or—even better—the ability to create their own actions.
But it’s not that easy to create the support code that goes behind the tag.
For the JSP page creator, custom tags are much easier to use than scripting.
For the Java programmer, however, building the custom tag handler (the Java code invoked when a JSP uses the tag) is tougher.
Fortunately, there’s a standard library of  custom tags known as the JSP Standard Tag Library (JSTL 1.1)
Given that your JSP shouldn’t be doing a bunch of  business logic anyway, you might find that the JSTL (combined with EL) is all you’ll ever need.
Still, there could be times when you need something from, say, a custom tag library developed specifically for your company.
In this chapter, you’ll learn how to use the core JSTL tags, as well as custom tags from other libraries.
In the next chapter, we’ll learn how to actually build the classes that handle calls to the custom tags, so that you can develop your own.
There’s got to be a way to iterate through a.
The case of the disappearing HTML (reprised) On page 384, you saw how EL sends the raw string of  content directly to the response stream:
What we need is a way to convert those angle brackets into something the browser will render as angle brackets, and there are two ways to do this.
Both use a static Java method that converts HTML special characters into their entity format:
Remember this? The <b></b> tags didn’t show up as text, but got rendered as an empty space that was bolded.
There’s a better way: use the <c:out> tag Whichever approach you use, it’s a bit unclear exactly what’s going on...
You can explicitly declare the conversion of XML entities If  you know or think you might run into some XML entities that need to be displayed, and not just rendered, you can use the escapeXml attribute on c:out.
Setting this to true means that any XML will be converted to something the web browser will render, angle brackets and all:
You can explicitly declare NO conversion of XML entities Sometimes, you want just the opposite behavior.
Maybe you’re building a page that takes content, and you want to display that content with HTML formatting.
Your HTML is treated as XHTML, which in turn is XML...
Conversion happens by default The escapeXml attribute defaults to true, so you can leave it out if you want.
A c:out tag without an escapeXML attribute is just the same as a c:out tag with escapeXML set to “true.”
Q: Which HTML special characters are converted? A: It turns out this conversion is rather simple.
All of these are converted into the equivalent HTML entities.
Q: Last month my company hired a web consultant to audit our web application.
She noticed that we were using EL everywhere to output strings entered by users.
She said this was a security risk and recommended we output all user strings using the c:out tag.
The security risk she is referring to is called cross-site hacking or cross-site scripting.
The attack is sent from one user to another user’s web browser using your webapp as the delivery mechanism.
The cracker enters a comment field in your webapp, which is stored in the database.
The innocent user views the cracker’s comment, but the text the cracker entered also includes JavaScript code that compromises user2’s system!
Null values are rendered as blank text Suppose you have a page that welcomes the user by saying “Hello <user>.” But lately, users haven’t been logging in, and the output looks pretty odd:
Suppose you want to show these anonymous users a message that says, “Hello guest.” This is a perfect place to use a default value with the c:out tag.
Just add a default attribute, and provide the value you want to print if  your expression evaluates to null:
This value is output if the value attribute evaluates to null.
You can’t possibly hard-code the complete table—you have no idea how many rows there will be at runtime, and of course you don’t know the values in the collection.
This does require a very slight knowledge of  HTML tables, but we’ve included notes here for those who aren’t familiar with the topic.
By the way, on the exam you are expected to know how to use <c:forEach> with tables.
Make a String[] of movie names, and set the array as a request attribute.
They’ve got cells, arranged into rows and columns, and the data goes inside the cells.
The trick is telling the table how many rows and columns you want.
The actual thing to loop over (array, Collection, Map, or a comma-delimited String)
The key feature is that the tag assigns each element in the collection to the variable you declare with the var attribute.
Helpfully, the LoopTagStatus class has a count property that gives you the current value of the iteration counter.
In this example, we put String arrays into an ArrayList, then make the ArrayList a request attribute.
The JSP has to loop through the ArrayList to get each String array, then loop through each String array to print the actual elements of  the array.
One of the String arrays that was assigned to the outer loop’s “var” attribute.
Q: How did you know that the “varStatus” attribute was an instance of whatever that was, and how did you know that it has a “count” property?
If you don’t have the spec already, go download it NOW (the intro of this book tells you where to get the specs covered on the exam)
It is THE reference for all the tags in the JSTL, and tells you all the possible attributes, whether they’re optional or required, the attribute type, and any other details on how you use the tag.
Everything you need to know about these tags  (for the exam) is in this chapter.
But some of the tags have a few more options than we cover here, so you might want to have a look in the spec.
Q: Since you know more than you’re telling about this tag...
The <c:forEach> tag has optional attributes for begin, end (in case you want to iterate over a subset of the collection), and step if you want to skip over some elements.
Q: Is the “c” in <c:forEach>  a required prefi x? A: Well, some prefix is required, of course; all tags and EL functions must have a prefix to give the Container the namespace for that tag or function name.
It’s just the standard convention for the set of tags in JSTL known as “core”
We  recommend using something other than “c” as a prefix, whenever you want to totally confuse the people you work with.
And you already know what tha t means in Java terms.
You’ll see that for most other tags , a variable set with.
So don’t be fooled by code that tr ies to use the variable.
It might help to think of tag scope as being just like.
Doing a conditional include with   <c:if> Imagine you have a page where users can view comments from other users.
And imagine that members can also post comments, but non-member guests cannot.
You want everyone to get the same page, but you want members to “see” more things on the page.
Don’t forget that you can use EITHER double or single quotes in your tags and EL.
But what if you need an else? What if  you want to do one thing if  the condition is true, and a different thing if  the condition is false?  In other words, what if  we want to show either one thing or the other, but nobody will see both? The <c:if> on the previous page worked fine because the logic was: everybody sees the first part, and then if  the test condition is true, show a little extra.
But now imagine this scenario: you have a car sales web site, and you want to customize the headline that shows up on each page, based on a user attribute set up earlier in the session.
Most of  the page is the same regardless of  the user, but each user sees a customized headline —one that best fits the user’s personal motivation for buying.
We are, after all, trying to sell him a car and become obscenely wealthy.
At the beginning of  the session, a form asks the user to choose what’s most important...
Now you can stop even if you do drive insanely fast.
The Brakes Our advanced anti-lock brake system (ABS) is engineered to give you the ability to steer even as you’re stopping.
We have the best speed sensors of any car this size.
When buying a car, what is most important to you?
The first page asks the user what he feels is most important.
Just like a good salesman, the pages that talk about features of the car will customize the presentation based on the user’s preference, so that each feature of the car looks like it was made with HIS personal needs in mind...
Our advanced anti-lock brake system (ABS) is engineered to give you the ability to.
Lost your tech job? No problem--you won’t have to service these brakes.
But what happens if userPref does n’t match any of these?
The <c:if> won’t work unless we’re CERTAIN that we’ll never need a default value.
What we really need is kind of  an if/else construct:*
Yes, we agree with you—there’s nearly always a better approach than chained if tests.
But you’re just gonna have to suspend disbelief long enough to learn how this all works....
I will CHOOSE you WHEN you are ready to give.
OTHERWISE, I’ll have to go with Kenny for the synchronized.
It’s not like a sw itch statement-there’s no fall-th rough.
But what if  you want to set a value in a Map? What if  you want to make a new entry in a Map? Or what if  you simply want to create a new request-scoped attribute?
You get all that with <c:set>, but you have to learn a few simple rules.
The var version is for setting attribute variables, the target version is for setting bean properties or Map values.
Each of  the two flavors comes in two variations: with or without a body.
The <c:set> body is just another way to put in the value.
You MUST specify a value, but you have a choice between putting in a value attribute or putting the value in the tag body (see #2 below)
Remember, no slash here when the tag has a body.
If the value evaluates to null , the variable will be.
You can’t use it to add things to lists or arrays.
It’s simple—you give it the object (a bean or Map), the property/key name, and the value.
With the “target” attribute, you do NOT type in the String literal that.
Q: Why would I use the body version instead of the no-body version? It looks like they both do exactly the same thing.
The body version is just for convenience when you want more room for the value.
It might be a long and complex expression, for example, and putting it in the body makes it easier to read.
Q: If I don’t specify a scope, does that mean it will find attributes that are ONLY within page scope, or does it do a search beginning with page scope?
A: If you don’t use the optional “scope” attribute in the tag, then the tag will only look in the page scope space.
Sorry, you will just have to know exactly which scope you are dealing with.
Q: Why is the word  “attribute” so overloaded? It means both “the things that go inside tags” and “the things that are bound to objects in one of the four scopes.”  So you end up with an attribute of a tag whose value is an attribute of the page and...
We would have called the bound objects something like, oh, “bound objects”
If you put in a String literal that represents the “id” name of the bean or Map, it won’t work.
In other words, “target” is not for the attribute name of the bean or Map—it’s for the actual attribute object.
I can’t believe you have to use <c:set> to remove an attribute.
The scope is optional, but if you leave it out then the attribute is removed from ALL scopes.
The value of userStatus was removed, so nothing prints when the EL expression is used AFTER the remove.
The var attribute MUST be a String literal! It can’t be an expression!!
Now you can stop even if you <em>do</em> drive insanely fast.
If you’re studying for the exam, don’t skip this one.
Fill in the missing tag names (two different tag types), and the missing attribute name.
With     <c:import>, there are now THREE ways to include content So far, we’ve used two different ways to add content from another resource into a JSP.
Static: adds the content from the value of  the file attribute to the current page at translation time.
Dynamic: adds the content from the value of  the page attribute to the current page at request time.
Dynamic: adds the content from the value of  the URL attribute to the current page, at request time.
It works a lot like <jsp:include>, but it’s more powerful and flexible.
Each of the three mechanisms for including content from anoth.
Do NOT confuse <c:import> (a type of include) with the “import” attribute of the page directive (a way to put a Java import statement in the generated servlet)
The horse is coming from a completely different web server.
Don’t forget: as with other include mechanisms, the thing you import should be an HTML fragment and NOT a complete page with opening and closing <html><body> tags.
You’ll see that the structure is virtually identical to the one we used with standard actions.
JSPs, unless you explicitly disable it with a page directive that has.
The Container will, automatically, fall back to URL rewriting if  it doesn’t get a cookie from the client.
But with servlets, you STILL have to encode your URLs.
In other words, you still have to tell the Container to “append the jsessionid to the end of  this particular URL...” for each URL where it matters.
Well, you can do the same thing from a JSP, using the <c:url> tag.
Add the extra session ID info to th is URL.
What if the URL needs encoding? Remember that in an HTTP GET request, the parameters are appended to the URL as a query string.
For example, if  a form on an HTML page has two text fields—first name and last name—the request URL will stick the parameter names and values on to the end of  the request URL.
But...an HTTP request won’t work correctly if  it contains unsafe characters (although most modern browsers will try to compensate for this)
If  you’re a web developer, this is old news, but if  you’re new to web development, you need to know that URLs often need to be encoded.
For example, spaces aren’t allowed in a URL, but you can substitute a plus sign “+” for the space.
The problem is, <c:url> does NOT automatically encode your URLs!
Remember, the <c:url> tag does URL rewriting, but not URL encoding!
This solves our problem! Now we get both URL rewriting and URL encoding.
I’m interrupting this JSTL talk for a few moments to.
We’re about to do something that might cause an exception...
Make your own  error pages The guy surfing your site doesn’t want to see your stack trace.
And he’s not too thrilled to get a standard “404 Not Found”, either.
You can’t prevent all errors, of  course, but you can at least give the user a friendlier (and more attractive) error response page.
You can design a custom page to handle errors, then use the page directive to configure it.
Tells the Container, “If something goes wrong here, forward the request to errorPage.jsp”
The REQUEST was for “badPage.jsp”, but that page threw an exception, so the RESPONSE came from “errorPage.jsp”
The Container uses <error-page> configuration in the DD as the default, but if  a JSP has an explicit errorPage page directive, the Container uses the directive.
It will take me FOREVER to put page directives in all my JSPs, to specify the error page to use.
And what if I want a different error page depending on the error? If only there were a way to confi gure error.
That way you can show the client different error pages specific to the type of  the problem that generated the error.
This applies to everything in your web app—not just JSPs.
You can override it in individual JSPs by adding a page directive with an errorPage attribute.
Declaring an error page based on an HTTP status code.
This configures an error page that’s called only when the status code for the response is “404” (file not found)
The <location> MUST be relative to the web-app root/context, which.
You probably won’t show this to the user...we just did this so you could see it.
Note: the exception implicit object is available ONLY to error pages with an explicitly-defined page directive:
In other words, configuring an error page in the DD is not enough to make the Container give that page the implicit exception object!
What if I think there’s an exception I might be able.
You can do a kind of  try/catch using the <c:catch> tag, to wrap the risky tag or expression.
Because if  you don’t, and an exception is thrown, your default error handling will kick in and the user will get the error page declared in the DD.
The part that might feel a little strange is that the <c:catch> serves as both the try and the catch—there’s no separate try tag.
You wrap the risky EL or tag calls or whatever in the body of  a <c:catch>, and the exception is caught right there.
But you can’t assume it’s exactly like a catch block, either, because once the exception occurs, control jumps to the end of  the <c:catch> tag body (more on that in a minute)
About to do a risky thing: If you see this, we survived.
You can make the exception an attribute In a real Java try/catch, the catch argument is the exception object.
But how do I get access to the Exception object? The.
Won’t work because this isn’t an official error page, so it doesn’t get the exception object.
Use the optional var attribute if  you want to access the exception after the end of  the <c:catch> tag.
It puts the exception object into the page scope, under the name you declare as the value of  var.
Now there’s an attribute myException, and since it’s a Throwable, it has a “message” property (because Throwable has a getMessage() method)
In a regular Java try/catch, onc e the exception occurs, the cod.
With the <c:catch> tag, once the exception occurs, two things hap.
If you used the optional “var” attribute, the exception object.
Flow jumps to below the body o f the <c:catch> tag.
And on the exam, if you see code within the <c:catch>
What if you need a tag that’s NOT in JSTL? The JSTL is huge.
Version 1.1 has five libraries—four with custom tags, and one with a bunch of  functions for String manipulation.
The tags we cover in this book (which happen to be the ones you’re expected to know for the exam) are for the generic things you’re most likely to need, but it’s possible that between all five libraries, you’ll find everything you might ever need.
On the next page, we’ll start looking at what happens when the tags below aren’t enough.
Using a tag library that’s NOT from the JSTL Creating the code that goes behind a tag (in other words, the Java code that’s invoked when you put the tag in your JSP) isn’t trivial.
We have a whole chapter (the next one) devoted to developing your own custom tag handlers.
But the last part of  this chapter is about how to use custom tags.
What happens, for example, if  someone hands you a custom tag library they created for your company or project? How do you know what the tags are and how to use them? With JSTL, it’s easy—the JSTL 1.1 specification documents each tag, including how to use each of  the required and optional attributes.
But not every custom tag will come so nicely packaged and well-documented.
You have to know how to figure out a tag even if  the documentation is weak or nonexistent, and, one more thing—you have to know how to deploy a custom tag library.
In <c:set>, the tag name is set, and the prefix is c.
You can use any prefix you want, but the name comes from the TLD.
In other words, it’s a unique name for the tag library the TLD describes.
The URI is what you put in your taglib directive.
It’s what tells the Container how to identify the TLD file within the web app, which the Container needs in order to map the tag name used in the JSP to the Java code that runs when you use the tag.
Making sense of the TLD The TLD describes two main things: custom tags, and EL functions.
We used one when we made the dice rolling function in the previous chapter, but we had only a <function> element in the TLD.
Now we have to look at the <tag> element, which can be more complex.
Besides the function we declared earlier, the TLD below describes one tag, advice.
If your tag has attributes, then one <attribute> element per tag attribute is required.
The unique name we use in the taglib directive !
REQUIRED! This says that the tag must NOT have anything in the body.
This says you MUST put a “user” attribute in the tag.
Using the custom “advice” tag The “advice” tag is a simple tag that takes one attribute—the user name—and prints out a piece of  random advice.
It’s simple enough that it could have been just a plain old EL function (with a static method getAdvice(String name)), but we made it a simple tag to show you how it all works...
The TLD says the tag can’t have a body, so we made it an empty tag (which means the tag ends with a slash)
Each library you use in a page needs its own taglib directive with a unique prefix.
The custom tag handler This simple tag handler extends SimpleTagSupport (a class you’ll see in the next chapter), and implements two key methods: doTag(), the method that does the actual work, and setUser(), the method that accepts the attribute value.
The Container calls this method to set the value from the tag attribute.
It uses JavaBean property naming conventions to figure out that a “user” attribute should be sent to the setUser() method.
With EL functions, you created a Java class with a static metho.
Only functions use a method sign ature declaration in the TLD!
Q: You still didn’t answer the question about how you know what type the attribute is...
If the <rtexprvalue> is false (or not there at all), then the attribute type can be ONLY a String literal.
The <type> takes a fully-qualified class name for the type.
Whether the TLD declares the type or not, the Container expects the type of the expression to match the type of argument in the tag handler’s setter method for that attribute.
It has to be an expression, not just a scriplet.
So it must have the “=” sign in there and no semicolon on the end.
What is this?? I thought this tag didn’t have a body...
The <jsp:attribute> is simply an alternate way to defi ne attribut.
There’s a little more about this on the next page...
What can be in a tag body A tag can have a body only if  the <body-content> element for this tag is not configured with a value of  empty.
The <body-content> element can be one of  either three or four values, depending on the type of  tag.
We have an opening and closing tag, but NOTHING in between.
The tag body is treated as plain text, so the EL is NOT evaluated and tags/actions are not triggered.
The tag body can have anything that can go inside a JSP.
The tag handler, the  TLD, and the JSP The tag handler developer creates the TLD to tell both the Container and the JSP developer how to use the tag.
A JSP developer doesn’t care about the <tag-class> element in the TLD; that’s for the Container to worry about.
The JSP developer cares most about the uri, the tag name, and the tag syntax.
Can the tag have a body? Does this attribute have to be a String literal, or can it be an expression? Is this attribute optional? What type does the expression need to evaluate to?
Think of  the TLD as the API for custom tags.
You have to know how to call it and what arguments it needs.
These three pieces—the tag handler class, the TLD, and the JSP are all you need to deploy and run a web app that uses the tag.
It does NOT need to represent any actual location (path or URL, for example)
It simply has to be a name—the same name you use in the taglib directive.
The web Container doesn’t normally try to request something from the uri in the taglib directive.
It doesn’t need to use the uri as a location! If  you type that as a URL into your browser, you’ll be redirected to a different URL, one that has information about JSTL.
The Container could care less that this particular uri happens to also be a valid URL (the whole “http://...” thing)
It’s just the convention Sun uses for the uri, to help ensure that it’s a unique name.
Su could have named the JSTL uri “java_foo_tags” and it would have worked in exactly the same way.
All that matters is that the <uri> in the TLD and the uri in the taglib directive match!
You can’t, for example, have two TLD files in the same web app, with the same <uri>
So, the domain name convention is a good one, but you don’t necessarily need to use that for all of  your in-house development.
Having said all that, there is one way in which the uri could be used as a location, but it’s considered a really bad practice—if  you don’t specify a <uri> inside the TLD, the Container will attempt to use the uri attribute in the taglib directive as a path to the actual TLD.
But to hard-code the location of  your TLD is obviously a bad idea, so just pretend you don’t know it’s possible.
So when a JSP page had a taglib directive like this:
The Deployment Descriptor (web.xml) had to tell the Container where the TLD file with a matching <uri> was located.
You did that with a <taglib> element in the DD.
The OLD (before JSP 2.0) way to map a taglib uri to a TLD file.
The NEW (JSP 2.0) way to map a taglib uri to a TLD file.
The Container automatically builds a map between TLD files and <uri> names, so that when a JSP invokes a tag, the Container knows exactly where to find the TLD that describes the tag.
How? By looking through a specific set of  locations where TLDs are allowed to live.
When you deploy a web app, as long as you put the TLD in a place the Container will search, the Container will find the TLD and build a map for that tag library.
So the next step is for us to see where the Container looks for TLDs, and also where it looks for the tag handler classes declared in the TLDs.
Four places the Container looks for  TLDs The Container searches in several places to find TLD files—you don’t need to do anything except make sure your TLDs are in one of  the right locations.
Inside the META-INF directory inside a JAR fi le that’s inside WEB-INF/lib.
When a JSP uses more than one tag library If  you want to use more than one tag library in a JSP, do a separate taglib directive for each TLD.
In other words, don’t put in more than one directive with the same uri value.
Empty tags Write in examples of the THREE different ways to invoke a tag that must have an empty body.
No, we’re not going to tell you the page number.
Sharpen your pencil How the JSP, the TLD, and the bean attribute class relate Fill in the spaces based on the information that you can see in the TLD.
Draw arrows to indicate where the different pieces of information are tied together.
In other words, for each blank, show exactly where you found the information needed to fi ll in the blank.
Now you can stop even if you <em>do</em> drive insanely fast.
Fill in the missing tag names (two different tag types), and the missing attribute name.
Sharpen your pencil How the JSP, the TLD, and the bean attribute class relate ANSWERS.
A JSP page contains a taglib directive whose uri attribute has the value myTags.
A controller servlet creates a session-scoped attribute called customer that is an instance of  the Person bean.
Option B is invalid because TLD files configure tag handlers not the JSP environment.
Option C is invalid because TLD files are not recognized in the META-INF of the WAR file.
Option D is invalid because Tag Files may be declared in a TLD (but it is rare)
Option D is incorrect because this tag is used for iterating over tokens within a single string.
Options E and F are incorrect because the prefix ‘logic’ is not a standard JSTL prefix (this prefix is typically used by tags in the Jakarta Struts package)
Option A is incorrect as this is the tag used for iterating over XPath expressions.
A JSP page contains a taglib directive whose uri attribute has the value myTags.
A controller servlet creates a session-scoped attribute called customer that is an instance of  the Person bean.
Option A is invalid because EL does not permit assignment.
Option C is invalid because the var attribute does not accept a runtime value, nor does it work with the property attribute.
Option E is invalid because this is an example of a JSP standard action, not a custom tag.
Option B is correct because it uses the proper JSTL tag/attribute names.
But there are three different ways to build your own tag.
But why? Why didn’t you tell him you could do it?
Describe the semantics of the “Classic” custom tag event model when each event method (doStartTag(), doAfterBody(), and doEndTag()) is executed, and explain what the return value for each event method means; and write a tag handler class.
Using the PageContext API, write tag handler code to access the JSP implicit variables and access web application attributes.
Given a scenario, write tag handler code to access the parent tag and an arbitrary tag ancestor.
Describe the semantics of the “Simple” custom tag event model when the event method (doTag()) is executed; write a tag handler class; and explain the constraints on the JSP content within the tag.
Describe the semantics of the Tag File model; describe the web application structure for tag files; write a tag file; and explain the constraints on the JSP content in the body of the tag.
Objective  10.2 (PageContext API) is covered only very briefly in this chapter, because most of what you need to know about the PageContext API has already been covered earlier in the book.
Virtually all of  this objective is about using PageContext to access implicit variables and scoped attributes, both covered in the “Scriptless JSP” chapter, although we do provide a one-page summary again in this chapter.
And you can even customize how the included file behaves by setting new request parameters that the included file can use.
But should you really have to create new request parameters just to give the included file some customizing information?
Aren’t request parameters supposed to represent form data sent from the client as part of  the request? While there might be good reasons to add or change request parameters in your app, using them to send something to the included file isn’t the cleanest approach.
Until JSP 2.0, there wasn’t a standard way to deploy included files—you could put the included pieces just about anywhere in the web app.
Wouldn’t it be better if  the tag itself  told you something about the thing being included? Wouldn’t it be nice to say something like:
You can think of  Tag Files as a kind of  “tag handler lite”, because they let page developers create custom tags, without having to write a complicated Java tag handler class, but Tag Files are really just glorified includes.
Take an included fi le (like “Header.jsp”) and rename it with a .tag extension.
Put the tag fi le (“Header.tag”) in a directory named “tags” inside the “WEB-INF” directory.
Put a taglib directive (with a tagdir attribute) in the JSP, and invoke the tag.
To refresh your memory on how it works with <jsp:include>:
The old way: An included fi le that uses a param (coming from a <jsp:param> in the calling JSP)
To a Tag File, you don’t send request parameters, you send tag attributes! You invoke a Tag File with a tag, and tags can have attributes.
So it’s only natural that the Tag File developer might want to invoke the tag with attributes...
But the nice, clean thing about ta g attributes for Tag Files is that th.
Once the tag is clos ed, the tag attributes go.
Aren’t tag attributes declared in the TLD? With custom tags, including the JSTL, the tag attributes are defined in the TLD.
Remember? This is the TLD from the custom <my:advice> tag from the last chapter:
So, these are the things the developer who is using a tag needs to know.
What’s the attribute name? Is it optional or required? Can it be an expression, or must it be only a String literal?
But while you do specify custom tag attributes in a TLD, you do NOT specify tag file attributes in a TLD!
That means we still have a problem—how does the page developer know what attributes the tag accepts and/or requires? Turn the page...
Tag Files use the   attribute directive There’s a shiny new type of  directive, and it’s just for Tag Files.
What happens if you do NOT have the attribute when you use the tag.
When an attribute value is really big Imagine you have a tag attribute that might be as long as, say, a paragraph.
So, you can choose to put content in the body of  the tag, and then use that as a kind of  attribute.
This time we’ll take the subTitle attribute out of  the tag, and instead make it the body of  the <myTags:Header> tag.
This says, “Take whatever is in the body of the tag used to invoke this tag file, and stick it here.”
Now we just give the tag a body, instead of putting all this as the value of an attribute in the opening tag.
But we’re back to the same problem we had before—without a TLD, where do you declare the body-content type?
Declaring     body-content for a Tag File The only way to declare body-content type for a Tag File is with another new Tag File directive, the tag directive.
A value of  scriptless means you can’t have scripting elements.
In fact, Tag File bodies are never allowed to have scripting, so it’s not an option.
But you can declare body-content (using the tag directive with a body-content attribute) if  you want one of  the other two options, empty or tagdependent.
This means the body-content will be treated like plain text, which.
You CANNOT use scripting code in the body of a Tag File tag! The body-content of a Tag File defaults to “scriptless”, so you don’t have to declare body-content unless you want one of the OTHER two options: “empty” (nothing in the tag body) or “tagdependent” (treats the body as plain text)
The type for this body-content is declared in the Tag File using a tag directive with a body-content attribute.
Where the Container looks for  Tag Files The Container searches for tag files in four locations.
A tag file MUST have a TLD if  it’s deployed in a JAR, but if  it’s put directly into the web app (in “WEB-INF/tags” or a sub-directory), it does not need a TLD.
Inside the META-INF/tags directory inside a JAR fi le that’s inside WEB-INF/lib.
Q: Does the Tag File have access to the request and response implicit objects?
A: Yes! Remember, even though it’s a .tag file, it’s gonna end up as part of a JSP.
You don’t have a ServletContext, though—a Tag File uses a JspContext instead of a ServletContext.
Q: I thought on the opposite page you just said we could not do scripting in a Tag File!
You can do scripting in a Tag File, but you can’t do scripting inside the body of the tag used to invoke the Tag File.
Q: Can you combine Tag Files and  TLDs for custom tags in the same directory?
In fact, if you make a TLD that references your Tag Files, the Container will consider both Tag Files and custom tags mentioned in the same TLD as belonging to the same library.
Q: Hold on—I thought you said Tag Files didn’t have a TLD? Isn’t that why you have to use an attribute directive? Since you can’t declare the attribute in a TLD?
If you deploy your Tag Files in a JAR, they MUST have a TLD that describes their location.
Q: Why did they do it this way? Wouldn’t it be so much simpler to just have custom tags and Tag Files declared the same way in a TLD? But NO...
A: On one hand, yes, it would have been simpler if custom tags and Tag Files were declared in the same way, using a TLD.
The question is, simpler for whom? For a custom tag developer, sure.
But Tag Files were added to the spec with someone else in mind—page designers.
Tag Files give non-Java developers a way to build custom tags without writing a Java class to handle the tag’s functionality.
And not having to build a TLD for the Tag File just makes life easier for the Tag File developer.
Remember, Tag Files do need a TLD if the Tag File is deployed in the JAR, but a non-Java programmer might not be using JARs anyway.
The bottom line: custom tags must have a TLD, but Tag Files can declare attributes and body-content directly inside the Tag File, and need TLDs only if the Tag File is in a JAR.
Sharpen your pencil Before we move on to a new topic, make sure you can write one yourself (answers are at the end of the chapter)
Fill in what would you must put into a Tag File to declare that the Tag has one required attribute, named “title”, that can use an EL expression as the value of the attribute.
Draw a Tag File document in each of the locations where the Container will look for Tag Files.
Sometimes you need Java Tag Files are fine when you’re doing an include—when all you need to handle the tag you can do from another JSP (renamed with a .tag extension and with the appropriate directives added)
Sometimes you need good old Java code, and you don’t want to do it from scriptlets, since that’s what you’re trying to prevent by using tags.
When you need Java, you need a custom tag handler.
A tag handler, as opposed to a tag file, is simply a Java class that does the work of  the tag.
It’s a little like an EL function, except much more powerful and flexible.
Where EL functions are nothing more than static methods, a tag handler class has access to tag attributes, the tag body, and even the page context so it can get scoped attributes and the request and response.
Custom tag handlers come in two flavors: Classic and Simple.
Classic tags were all you had in the previous version of  JSP, but with JSP 2.0, a new and much simpler model was added.
You’ll have a hard time coming up with reasons to use the classic model when you need a custom tag handler, because the simple model (especially combined with JSTL and tag files) can handle nearly anything you’d want to do.
But we can’t dump the classic model for two reasons, and these two reasons are why you still have to learn it for the exam:
Like scripting, Classic tag handlers are out there, and you might need to read and support them, even if  you never create one yourself.
There are those rare scenarios for which a classic tag handler is the best choice.
So point #1 is by far the most important reason to learn about Classic tags.
We’ll start with the Simple tag model first, to get warmed up.
Tag files implement the tag functionality with another page (using JSP)
Tag handlers implement the tag functionality with a special Java class.
Put the TLD in WEB-INF, and put the tag handler inside WEB-INF/classes, using the package directory structure, of  course.
In other words, tag handler classes go in the same place all other web app Java classes go.
The doTag() method declares an IOException, so you don’t have to wrap the print in a try/catch.
If  the tag needs a body, the TLD <body-content> needs to reflect that, and you need a special statement in the doTag() method.
The easiest way to do that is to extend SimpleTagSupport and override just the method you need, doTag()
You don’t have to use SimpleTagSupport, but we reckon 99.999999% of  simple tag developers do.
Can you guess the order in which these methods are called?
SimpleTagSupport implements the methods of SimpleTag (but the doTag() doesn’t do anything, so you must override it in your tag handler)
It also adds three more convenience methods, including the most useful one—getJspBody()
When a JSP invokes a tag, a new instance of  the tag handler class is instantiated, two or more methods are called on the handler, and when the doTag() method completes, the handler object goes away.
This gives the handler a reference to a PageContext (a subclass of JspContext)
If the tag is invoked with attributes, the setter for each attribute is called, using JavaBean naming.
There’s a special exception to this that we’ll see later.
If the tag is nested (invoked from within another tag), call the setParent(JspTag) method.
If the tag has a body, the body comes in through this method, as an instance of JspFragment.
Now we’re finally ready to DO what the tag is meant to do!
If it works, which SimpleTag lifecycle methods are called in the handler?
If it works, which SimpleTag lifecycle methods are called in the handler?
If it works, which SimpleTag lifecycle methods are called in the handler?
It doesn’t work because it is supposed to have an empty body.
If it works, which SimpleTag lifecycle methods are called in the handler?
Imagine you have a tag with a body that uses an EL expression for an attribute.
Now imagine that the attribute doesn’t exist at the time you invoke the tag! In other words, the tag body depends on the tag handler to set the attribute.
The example doesn’t do anything very useful, but it’s here to show you how it works in preparation for a bigger example.
Imagine that the tag handler has access to an array of String movie names, and you want to print one row for each movie name in the array.
Write the tag handler doTag() method to support that goal.
In this example, the EL expression in the body of  the tag represents a single value in a collection, and the goal is to have the tag generate one row for each element in the collection.
It’s simple—the doTag() method simply does the work in a loop, invoking the body on each iteration of  the loop.
If  the tag needs an attribute, you declare it in the TLD, and provide a bean-style setter method in the tag handler class for each attribute.
If  the tag invocation includes attributes, the Container invokes a setter method for each attribute.
The method name MUST match the attribute name in the TLD (minus the “set” prefix and changing the case of the first letter)
It doesn’t matter that it’s a Simple Tag handler taking care of the tag.
In other words, it’s something that’s meant to run and generate output.
The body of  a tag that invokes a simple tag handler is encapsulated in the JspFragment object, then sent to the tag handler in the setJspBody() method.
The crucial thing you must remember about JspFragment is that it must NOT contain any scripting elements! It can contain template text, standard and custom actions, and EL expressions, but no scriptlets, declarations, or scripting expressions.
One cool thing is that since it’s an object, you can even pass the fragment around to other helper objects.
And of  course once you’ve got a context, you can ask for attributes.
So the getJspContext() method is really a way for the tag body to get information to other objects.
Most of  the time, though, you’ll use JspFragment simply to output the body of  the tag to the response.
You might, however, want to get access to the contents of  the body.
Notice that JspFragment doesn’t have an access method like getContents() or getBody()
You can write the body to something, but you can’t directly get the body.
For the exam, and real life, this is probably all you will ever need to know about the details of  JspFragment, so we won’t spend any more time on it in the book.
Imagine you’re in a page that invokes the tag, and the tag depends on specific request attributes (that it gets from the JspContext available to the tag handler)
Now imagine the tag can’t find the attributes it needs, and that the tag knows the rest of  the page will never work if  the tag can’t succeed.
What do you do? You could have the tag throw a JspException, and that would kill the page...
At this point, we decided that the rest of the tag AND the rest of the page should stop.
Only the part of the page and the tag BEFORE the exception will appear in the response.
The tag handled in the doTag() method above (that throws SkipPageException)
What is the result if the thingsDontWork test is true?
Everything in the doTag() method up to the point of  the SkipPageException still shows up in the response.
But after the exception, anything still left in either the tag or the page won’t be evaluated.
SkipPageException shows everything up to the point of the exception.
About to invoke a tag that throws SkipPageException Message from within doTag()
But what happens when the tag is invoked from an included page?
Look at the code below and fi gure out what prints when you bring up PageA.
PageB (the included fi le) JSP that invokes the bad tag.
Doing the include now: This is page B that invokes the tag that throws SkipPageException.
PageB (the included fi le) JSP that invokes the bad tag.
Were you surprised to see this line from page A print out?
If  the page that invokes the tag was included from some other page, only the page that invokes the tag stops processing! The original page that did the include keeps going after the SkipPageException.
SkipPageException stops only the page that directly invoked the tag.
Q: What happens to a SimpleTag handler after it completes doTag()? Does the Container keep it around and reuse it?
SimpleTag handlers are never reused! Each tag handler instance takes care of a single invocation.
So you never have to worry, for example, that instance variables in a SimpleTag handler won’t have the correct initial values.
A SimpleTag handler object will always be initialized before any of its methods are called.
Q: Do the attribute methods in a SimpleTag handler have to be of a type that can be automatically converted to and from a String? In other words, are you stuck with just primitives and String values?
A: Weren’t you paying attention a few pages back? The attribute we sent to the SimpleTag handler was an ArrayList of movies.
In other words, you can’t send a Dog into the tag if you’re forced to represent the Dog as a String literal.
But if you can use an expression for the value of the attribute, then that expression can evaluate to whatever object type you need to match the argument to the handler’s corresponding setter method.
Q: In a SimpleTag handler, if the tag is declared to have a body but it is invoked using an empty tag (since there’s no way to say that a body is required), is the setJspBody() still invoked?
A: No! The setJspBody() is invoked ONLY if these two things are true:
The tag is NOT declared in the TLD to have an empty body.
That means that even if the tag is declared to have a non-empty body, the setJspBody() method will not be called if the tag is invoked in either of these two ways:
Tag Files implement tag functionality using a page, while tag handlers implement tag functionality using a Java tag handler class.
Tag handlers come in two types: Classic and Simple (Simple tags and Tag Files were added in JSP 2.0)
To make a Simple tag handler, extend SimpleTagSupport (which implements the SimpleTag interface)
To deploy a Simple tag handler, you must create a TLD that describes the tag using the same <tag> element used by JSTL and other custom tag libraries.
The SimpleTagSupport class includes implementation methods for everything in the SimpleTag interface, plus three convenience methods including getJspBody(), which you can use to get access to the contents of the body of the tag.
The Simple tag lifecycle: Simple tags are never reused by the Container, so each time a tag is invoked, the tag handler is instantiated, and its setJspContext() method is invoked.
If the tag is called from within another tag, the setParent() method is called.
If the tag is invoked with attributes, a bean-style setter method is invoked for each attribute.
If the tag is invoked with a body (assuming its TLD does NOT declare it to have an empty body), the setJspBody() method is invoked.
Finally, the doTag() method is invoked, and when it completes, the tag handler instance is destroyed.
The setJspBody() method will be invoked ONLY if the tag is actually called with a body.
If the tag is invoked without a body, either with an empty tag.
The doTag() method declares a JspException and an IOException, so you can write to the JspWriter without wrapping it in a try/catch.
If the tag has an attribute, declare the attribute in the TLD using an <attribute> element, and provide a bean-style setter method in the tag handler class.
When the tag is invoked, the setter method will be called before doTag()
Passing null to invoke() writes the evaluated body to the response output, but you can pass another Writer in if you want direct access to the body contents.
Throw a SkipPageException if you want the current page to stop processing.
If the page that invoked the tag was included from another page, the including page keeps going even though the included page stops processing from the moment the exception is thrown.
Maybe the place you work is starting out with JSP 2.0, and can use Tag Files and SimpleTag handlers from the start.
Chances are, you’re working (or will work in the future) somewhere that’s been using JSPs since the pre-2.0 days, using the Classic tag model for writing custom tag handlers.
You probably need to at least be able to read the source code for a Classic tag handler.
You might be called on to maintain or refactor a Classic tag handler class.
But even if  you don’t ever have to read or write a Classic tag handler, they’re still covered (very lightly) by one of  the exam objectives.
Be grateful—on the previous version of  the exam you might have seen at least seven or eight Classic tag handler questions on the exam.
Today, exam candidates will see only a couple of  questions on Classic tag handlers.
The tag handler API has five interfaces and three support classes.
There’s virtually NO reason to implement the interfaces directly, so you’ll probably always extend a support class.
Everything in a grey box is from the original (  Classic) tag model for custom tag handlers.
This side (with the white boxes) is the SimpleTag API.
The JspTag superinterface was added with JSP 2.0, but it doesn’t affect the Classic tag API.
This example is so basic that it’s not much different from a SimpleTag handler’s doTag() method.
In fact the differences won’t become painful until you try to process a tag with a body (but you’ll just have to wait for that)
There’s no way to know f or certain that this <tag.
Classic tags inherit a pageContext member variable from TagSupport (in contrast to the getJspContext() method of SimpleTag)
Here we must use a try/catch, because we can’t declare the IOException.We have to return an int to tell the Container what to do next.
This example overrides both the doStartTag() and doEndTag() methods, although it could accomplish the same output all within doStartTag()
The point of doEndTag() is that it’s called after the body is evaluated.
We don’t show the TLD here, because it’s virtually identical to the previous one, except for some of  the names.
The tag is declared to have no attributes, and an empty body.
This says, “Evaluate the rest of the page” (as opposed to SKIP_PAGE, which would be just like throwing a SkipPageException from a SimpleTag handler)
Remember, SimpleTag bodies areevaluated when (and if) you want by calling invoke() on the JspFragment that encapsulates the body.
But in Classic tags, the body is evaluated in between the doStartTag() and doEndTag() methods! Both of  the examples below have the exact same behavior.
But how do you loop over the body? It looks like doStartTag() is.
But where do you loop over the body, if the body is evaluated in between the methods instead of IN a method like doTag()?
It’s easy to loop the body of a Simple tag; you just keep calling invoke() on the body, from within doTag()
But with classic tags, there’s a doStartTag() and a doEndTag()
And that brings up an interesting problem—when and how is the body evaluated? There’s no doBody() method, but there is a doAfterBody() method that’s called after the body is evaluated and before the doEndTag() runs.
If the tag is invoked with attributes, the JavaBean-style setter for each attribute is called (just as with SimpleTag handlers)
The body is evaluated between the doStartTag() and doEndTag() methods.
If the tag is nested (invoked from within another tag), call the setParent(Tag) method.
If the tag is NOT declared to have an empty body, AND the tag is NOT invoked with an empty body, AND the doStartTag() method returns EVAL_BODY_INCLUDE, the body is evaluated.
If the body content was evaluated, call the doAfterBody() method.
With doStartTag(), the question the Container asks is, “Should I evaluate the body?”  (assuming there is one, and assuming the TLD doesn’t declare the body as empty)
With doEndTag(), the Container asks, “Should I keep evaluating the rest of the calling page?” The return values are represented by constants declared in the Tag and IterationTag interfaces.
This is the only return value constant declared in IterationTag (the others are all from Tag)
But it’s not! So don’t b e fooled if you see code.
Returning SKIP_PAGE from doEndTag()  is exactly like throwing a SkipPageException from a Simple tag! If a page included the page that invoked the tag, the current (included) page stops processing, but the including page continues...
Without doAfterBody(), you can’t iterate over the body because doStartTag() is too early, and doEndTag() is too late.
Try to implement the same functionality of this SimpleTag doTag() in a Classic tag handler.
Assume the TLD is confi gured to allow body content.
Look at the legal tag handler code below and figure out whether it would give you the result.
This is also the same result produced by the ClassicTag handler from the previous page.
If  you don’t override the TagSupport lifecycle methods that return an integer, be aware of  the default values the TagSupport method implementations return.
It also assumes that you want the rest of  the page to evaluate (by returning EVAL-PAGE from doEndtag())
Default return values when you don’t override the TagSupport method implementation.
The TagSupport class assumes your tag doesn’t have a body, or that if the body IS evaluated, that the body should be evaluated only ONCE.
It also assumes that you always want the rest of the page to be evaluated.
With doAfterBody(), it should be obvious that if you want to iterate over the body, you have to override that method as well, since its return value is SKIP_BODY.
You MUST override doStartTag() if you want the tag body to be evaluated!!
Actual result (unless you add the two lines highlighted below)
This doAfterBody() method was correct, but it runs only AFTER the body has already been processed once! Without the two extra lines in doStartTag(), the body is processed once without there being a movie attribute, so you get the empty cell.
Q: This seems stupid—there’s duplicate code in doStartTag() and doAfterBody()
In this case, if you’re implementing TagSupport, and you want to set values the body can use, then you MUST set those attribute values in doStartTag()
You can’t wait until doAfterBody(), because by the time you get to doAfterBody(), the body has already been processed once.
Of course if you were writing the code, you’d make a private method in your tag handler...
Q: WHY are you setting the instance variable value for movieCounter INSIDE the doStartTag() method? Why can’t you just initialize it when you declare it?
A: Yikes! Unlike SimpleTag handlers, which are never reused, a Classic tag handler can be pooled and reused by the Container.
That means you’d better reset your instance variable values with each new tag invocation (which means in doStartTag())
Otherwise, this code works the first time, but the next time a JSP invokes it, the movieCounter variable will still have its last value, instead of 0!
Remember the beer webapp from Chapter 3? Let’s improve it a bit, and automate part of  the HTML form:
We want the set of options in this <select> tag to come from the application.
If  we make the options dynamic, they’ll be easier to update and change, without messing around with the HTML.
Instead, we want the options to be generated from a Java List created in the web application.
With this tag, an app can change the options without hard-coding business data in an HTML form.
Your mission (if you choose to accept it) is to complete the implementation of the  select tag handler.
First, the handler class needs to implement setter methods for each tag attribute; here’s a skeleton to get you started:
Go ahead and write your code in here, in the blank spaces underneath the comments.
Next, complete the implementation of the select tag handler class by writing the doTag() method.
We’ve provided the method signature and a few helpful comments help you out.
Sharpen your pencil Now you need to configure the select tag in the TLD file.
The boilerplate elements of the TLD are already provided for you.
You just need to add the element to declare the select tag, its handler class, and all its attributes.
Your mission (if you chose to accept it) was to complete the implementation of the select tag handler.
The handler had to implement setter methods for each tag attribute.
Next, you had to complete the implementation of the select tag handler class by writing the doTag() method.
The HTML <select> open tag uses the name and size attributes.
Finally, the tag handler must output the closing HTML </select> tag.
The optionsList object is used to create the HTML <option> tags.
Then, you had to configure the select tag in the TLD file.
Here’s what we did to add the element to declare the select tag, its handler class, and all attributes.
An example tab library of replacements for the HTML form tags.
The attribute also must allow a runtime expression in the value.
The name and size attributes are far easier because we can accept the data type default (String)
Do you think the name and size attributes should allow runtime values? Why or why not?
The HTML <select> tag accepts many more tag attributes than just name and size:
Form attributes:  name, disabled, multiple, size, tabindex, onfocus, onblur, and onchange.
My craft won’t shine without being able to apply styles.
Man! How am I supposed to add cool behavior without the event.
You can use these to make list boxes and list menus.
Don’t get all worked up, I can fi x this...
I’ll just add more attribute setters to the handler class and declarations to the TLD.
Gary’s design is  very simple; we just need to add a setter method for all of  the HTML pass-through tag attributes The UML for the tag class is on the right, with all the methods we’ll need to add.
The rest of the tag attributes are for the web browser.
This tag handler simply passes them through to the <select> tag output.
This is the only attribute we added to the select tag.
The next page shows the next chunk of tag attribute setters.
The return of the son of more tag attributes Yup, you got it...
Worse, what if  we want to create a suite of custom tags to augment other HTML tags?!
The tag handler class must implement a setter method for each of  the tag attributes declared in the TLD.
The values of  these attributes are simply passed on to the output generated for the HTML <select> tag.
We could apply an design principle: “Encapsulate that which varies.”* In this case the set of  optional HTML tag attributes is the thing that varies in this tag handler.
One solution would be to put all of  the attributes into a hashtable.
This generalizes the tag object’s storage of attributes, but what about all these setter methods? We can’t get rid of  them unless there’s a way to tell the JSP engine to set the tag attributes using a generic interface.
Of course, we would never shamelessly plug another Head First book, right?
Didn’t you know?!?!? The JSP spec provides an API just for this purpose.
You will most likely store the dynamic attributes in a hashmap.
The uri parameter is the XML namespace that defines the attribute.
Our tag handler code using the DynamicAttributes interface Let’s examine how DynamicAttributes looks in action.
First, our tag handler class must implement the DynamicAttributes interface from the JSP API.
This method needs to store the attribute name/value pairs; a hashmap is the perfect data structure to hold this information:
The rest of the tag handler code The only thing left is the doTag() method.
The only difference now is that the generation of  the standard HTML <select> tag attributes are stored in the hashmap.
The doTag() method must iterate over each entry in the map and generate the HTML attribute binding in the output stream.
The value of the attribute is stored in the map.
The get() method retrieves the value from the key (the name of the attribute)
OK, there is a little bit of configuration in the TLD Hah! You didn’t think the solution was only in code, did ya? Of  course, there is an element of  configuration required.
This element is all you need to declare that this tag may accept any number of dynamic attributes.
A: Yup, the DynamicAttributes interface can be implemented by a Classic tag in the same fashion as with a Simple tag.
Even the configuration in the TLD file is the same.
By default every dynamic attribute may use EL or JSP expression tags to specify the value of the attribute.
Q: What if I need to “compute” on data in a given dynamic attribute?
A: You can always inspect the name parameter and decide to perform some computation or transformation of the value of that attribute.
But if you need that kind of functionality, then you should probably make that attribute explicit, and perform your computation in that attribute’s setter method.
Q: What happens if the custom tag user enters an attribute name that is invalid?
The result is that the JSP author might mistype the name of  a standard HTML attribute and never know it—at least until the browser failed to invoke the behavior of  that attribute.
So, the first solution Gary proposed (using explicit attributes with setters and TLD declarations) has merit.
Can you think of  other reasons why Gary’s solution is better than Kim’s?
The mechanism is basically the same, but with Tag Files the JSP engine provides the Map object for you.
You can then inspect or iterate over that map of attribute/value pairs using the forEach JSTL tag.
Use the JSTL forEach custom tag to iterate over each entry in the dynamic attribute’s hashmap.
Remember, the key of the entry is the attribute name, and the value of the entry is the value of the attribute.
The   DynamicAttributes interface allows the tag handler class to accept any number of tag attributes.
The value of dynamic-attributes holds a hashmap of the dynamic attributes.
Typically, you will use the JSTL forEach custom action to iterate over this map.
You’ll probably find that most of  the time the lifecycle methods from the Tag and IterationTag interfaces, as provided by TagSupport, are enough.
Between the three key methods (doStartTag(), doAfterBody(), and doEndTag()), you can do just about anything.
Except...you don’t have direct access to the contents of  the body.
If  you need access to the actual body contents, so that you can, say, use it in an expression or perhaps filter or alter it in some way, then extend BodyTagSupport instead of  TagSupport, and you’ll have access to the BodyTag interface methods.
But what if you DO need access to the body contents?
You can use these to do something with the actual CONTENTS of the body of the tag used to invoke the handler.
You also get one new return value for doStartTag(), EVAL_BODY_BUFFERED.
That means there are now three possible return values for doStartTag(), instead of  the two you get when you extend TagSupport.
Lifecycle for a tag that implements BodyTag (directly or by extending BodyTagSupport)
The BodyContent argument to setBodyContent() is actually a type of  java.io.Writer.
Yes, it’s OK to find that disturbing from an OO perspective.
But that means you can process the body by, say, chaining it to another IO stream or getting the raw bytes.
Q: What happens if I return EVAL_BODY_BUFFERED even though the invoking tag is empty?
The Container knows there’s no body this time, and it just skips to the doEndTag() method, so this is usually not a problem.
Q: What about attributes in a Classic tag? Are they handled the same way as with Simple tags?
A: Yes, on the sequence diagram for both Simple tag handlers and Classic tag handlers, there was a place where beanstyle setter methods are called for each attribute.
This happens before a Simple tag’s doTag() or a Classic tag’s doStartTag()
In other words, tag attributes work in exactly the same way for both Classic and Simple tags, including the way in which they’re declared in the TLD.
That might be obvious, but it means you have to be careful to keep your tag handler and TLD in sync.
That also means there is no point in implementing IterationTag, but you get that automatically by extending TagSupport.
The point is, you need to return SKIP_BODY from doStartTag() if your TLD declares an empty body for the tag, even IF you implement IterationTag or BodyTag.
If the TLD for a tag declares an empty body, doStartTag() MUST return SKIP_BODY!
We’ve covered almost everything you need to do this correctly, but you’ll have to guess in a few places.
Number of times it can be called (per tag invocation from a JSP)
Number of times it can be called (per tag invocation from a JSP)
Number of times it can be called (per tag invocation from a JSP)
You’re expected to know all of this for the exam! Lifecycle return values for Classic tag methods.
Number of times it can be called (per tag invocation from a JSP)
Number of times it can be called (per tag invocation from a JSP)
Number of times it can be called (per tag invocation from a JSP)
The big question is, how do the tags talk to one another? In other words, how does the Menu tag (the enclosing tag) get the attribute values from the MenuItems (the inner/nested tags)?
And you might need to use “cooperating tags” (that’s how the spec says it) in your own custom development as well.
Fortunately, there’s a mechanism for getting info to and from outer and inner tags, regardless of  the depth of  nesting.
That means you can get info from a deeply nested tag out to not just the tag’s immediate enclosing tag, but to any arbitrary tag up the tag nesting hierarchy.
Sharpen your pencil Look at the Tag API, review the previous tag handler code, and think about how cooperating tags might get info to and from one another.
The getParent() in Tag returns a Tag, but the getParent() in SimpleTag returns an instance of  JspTag.
We’ll see the implications of  those return types in a minute.
You can walk your way up the ancestor tag chain by continuing to call getParent() on whatever is returned by getParent()
Because getParent() returns either another tag (on which you can call getParent()), or null.
If it’s null, then we’re at the top level, and we don’t have a parent.
But if it’s not null, get the parent of the.
This is not a problem, because a SimpleTag’s getParent() returns type JspTag, and Classic tags and Simple tags now share the JspTag super interface.
Actually, Classic tags can have Simple parents, but it takes a slight hack to make that work because you can’t cast a SimpleTag to the Tag return value of  the Tag interface getParent()
We won’t go into how to access a Simple tag parent from a Classic child tag*, but all you need to know for the exam (and almost certainly real web app life) is that by using getParent(), a Classic tag can access Classic tag parents, and a Simple tag can access either a Classic or Simple parent.
Using the getParent() method, a Classic tag can access Classic tag parents, and a Simple tag can access either a Classic or Simple parent.
It’s OK for a SimpleTag to ask for a Classic parent...
Once you have a parent, you can call methods on it like any other Java object, so you can get attributes of the parent tag!
What if the child (SimpleInner) wants access to the parent’s “name” attribute?
If you return SKIP_BODY, the inner tag will never be processed!
My child can fi nd me, his parent, but I have no way to fi nd my child! I just have to wait for him to call ME...That is so sad...
What can we do? How can the parent tag get information about the child tags, when a child can get a reference to the parent, but the parent can’t ask for a reference to the child?
Sharpen your pencil How could a parent tag get attribute values from a child tag? Describe how you would implement the functionality of the cooperating Menu and MenuItem tags.
We have two main ways in which tags can cooperate with one another:
The child tag needs info (like an attribute value) from its parent tag.
The parent tag needs info from each of  its child tags.
We’ve already seen how the first scenario works—the child tag gets a reference to its parent using getParent(), then calls getter methods on the parent.
But what happens when the parent needs info from the child?  We have to do the same thing.
In other words, if  the parent needs info from the child, it’s the child’s job to give it to the parent!
Since there’s no automatic mechanism for the parent to find out about its child tags, you simply have to use the same design approach to get info to the parent from the child as you do to get info from the parent to the child.
You get a reference to the parent tag, and call methods.
Only instead of getters, this time you’ll call some kind of  set or add method.
Menu items are: [Dogs, Cats, Horses] In this example we didn’t act.
Simple—get a reference to the parent tag and call its addMenuItem() method.
If you do not return EVAL_BODY_INCLUDE, the child tag’s will never be processed!
There is another mechanism you can use if  you want to, say, skip some nesting levels and go straight to a grandparent or something even further up the tag nesting hierarchy.
The Container walks the tag nesting hierarchy until it finds a tag that’s an instance of  this class.
It returns the first one, so there’s no way to say.
All you need to know for the exam is that it exists!
How you access implicit variables and scoped attributes from a support implementation.
With the getJspContext() method that returns a JspContext (which is usually a PageContext)
With the pageContext implicit variable--NOT a method like it is with SimpleTag!
How you access implicit variables and scoped attributes from a support implementation.
Using the PageContext API for tag handlers This page is just a review from what you saw in the Script-free JSPs chapter, but it comes up again here because it’s crucial for a tag handler.
A tag handler class, remember, is not a servlet or a JSP, so it doesn’t have automatic access to a bunch of  implicit objects.
But it does get a reference to a PageContext, and with it, it can get to all kinds of  things it might need.
Remember that while Simple tags get a reference to a JspContext and Classic tags get a reference to a PageContext, the Simple tag’s JspContext is usually a PageContext instance.
But the two-arg version can be us ed to get.
Fill in what would you must put into a Tag File to declare that the Tag has one required attribute, named “title”, that can use an EL expression as the value of the attribute.
Draw a Tag File document in each of the locations where the Container will look for Tag Files.
Inside the META-INF/tags directory inside a JAR fi le that’s inside WEB-INF/lib.
Inside a sub-directory of META-INF/tags inside a JAR fi le that’s inside WEB-INF/lib.
A medical website hides selective content from users who are not registered.
In place of  the hidden content, a message should display to encourage users to register.
At line 15, the price for registration should be retrieved from a context parameter named registrationFee, however there are no methods on JspContext for retrieving context parameters.
Cast the JspContext to type PageContext so that you can use the methods of  PageContext to retrieve the context parameter.
Throw an exception to let the user know that the price could not be found.
The Tag interface can only be used to create empty tags.
The SKIP_PAGE constant is a valid return value of the doEndTag method.
The EVAL_BODY_BUFFERED constant is a valid return value of  the doAfterBody method.
There are three tag interfaces—Tag, IterationTag, and BodyTag—but only two built-in base classes: TagSupport, and BodyTagSupport.
Which Simple tag mechanism will tell a JSP page to stop processing?
Your Simple tag must NOT declare any static tag attributes.
Your Simple tag CANNOT be used with the jsp:attribute standard action, because this action works only with static attributes.
It is NOT defined by any of  the standard JSP tag.
It requires two parameters: A Tag and a String, representing the name of  the tag to be found.
A tag file may be placed in any subdirectory of  WEB-INF.
A tag file must have the file extension of  .tag or .tagx.
A TLD file must be used to map the symbolic tag name to the actual tag file.
A tag file may NOT be placed in a JAR file in the WEB-INF/lib directory.
Assuming no exceptions occur, doAfterBody() is always called after doStartTag() for any tag that implements IterationTag.
Assuming no exceptions occur, doAfterBody() is called after doStartTag() for any tag that implements IterationTag and returns SKIP_BODY from doStartTag()
Assuming no exceptions occur, doAfterBody() is called after doStartTag() for any tag that implements IterationTag and returns EVAL_BODY_INCLUDE from doStartTag()
The setJspBody method is always called before the doTag method.
The setParent and setJspContext methods are called immediately before the tag attributes are set.
The JspFragment of the tag body is invoked by the Container before the tag handler’s doTag method is called.
This value, a BodyContent object, is passed to the tag handler using the setJspBody method.
Which is the most efficient JspContext method to call to access an attribute that is known to be in application scope?
Given a tag, simpleTag, whose handler is implemented using the Simple tag model and a tag, complexTag, whose handler is implemented using the Classic tag model.
Both tags are declared to be non-empty and non-tag dependent in the TLD.
What is the best strategy, when implementing a custom tag, for finding the value of  an attribute whose scope is unknown?
Each tag file must have a corresponding entry in a TLD file.
All directives allowed in JSP pages are allowed in Tag Files.
All directives allowed in Tag Files are allowed in JSP pages.
The <jsp:doBody> standard action can only be used in Tag Files.
The allowable file extensions for Tag Files are .tag and .tagx.
For each attribute declared and specified in a Tag File, the container creates a page-scoped attribute with the same name.
A web application includes many forms for users to fill out and submit.
Nothing in the pages indicates that a field is required.
Business decided that a red asterisk should be placed preceding the text labels of  required fields but the project manager is contending that the background color of  required fields be light blue and another department is demanding that the project’s application be consistent with their own, where the text of  the labels be bold for required fields.
Considering the different perspectives on how required fields could be identified in pages, choose the most maintainable usage of  a custom tag.
Option D is invalid because this is not a valid return value for doStartTag()
Option C is invalid because it only causes the body of the tag to be skipped.
Option B is invalid because the page directive is never allowed in a tag file (pg 1-179)
Option C is invalid because the jsp:body action can appear in EITHER a tag file or JSP.
Option F is invalid because the taglib directive can appear in EITHER a tag file or JSP.
A medical website hides selective content from users who are not registered.
In place of  the hidden content, a message should display to encourage users to register.
At line 15, the price for registration should be retrieved from a context parameter named registrationFee, however there are no methods on JspContext for retrieving context parameters.
Cast the JspContext to type PageContext so that you can use the methods of  PageContext to retrieve the context parameter.
Throw an exception to let the user know that the price could not be found.
Option A the pageContext variable is only available to Classic tags.
We never mentioned this trick and you won’t need to know it for the exam, but it might come in handy in the real world! -Option C Remember, we’re not looking for an attribute, we’re looking for a context parameter.
Option D Don’t give up so easily! With determination you can provide a good solution!
The Tag interface can only be used to create empty tags.
The SKIP_PAGE constant is a valid return value of the doEndTag method.
The EVAL_BODY_BUFFERED constant is a valid return value of  the doAfterBody method.
There are three tag interfaces—Tag, IterationTag, and BodyTag—but only two built-in base classes: TagSupport, and BodyTagSupport.
Option A is invalid because the Tag interface can support tags with a body, but you can’t iterate or gain access to the body content.
Which Simple tag mechanism will tell a JSP page to stop processing?
Option A is invalid because the doTag method does not return a value.
Option B is invalid because a Simple tag does not have the doEndTag event method.
Option D is invalid because a Simple tag does not have the doEndTag event method.
It is NOT defined by any of  the standard JSP tag.
It requires two parameters: A Tag and a String, representing the name of  the tag to be found.
Option G is invalid because the second argument is a Class.
Options A and F are invalid because the method takes two parameters.
Your Simple tag must NOT declare any static tag attributes.
Your Simple tag CANNOT be used with the jsp:attribute standard action, because this action works only with static attributes.
Option A is invalid because you can have both static and dynamic attributes in a Simple tag.
Option D is invalid because there is no such helper class in the built-in APIs.
Option E is invalid because you are allowed to use the jsp:attribute action with dynamic tags.
Option A is invalid because it causes the body of the tag to be skipped.
Option C is invalid because it directs the body of the tag to a buffer which this tag does not process.
Option D is invalid because this is not a valid return code.
A tag file may be placed in any subdirectory of  WEB-INF.
A tag file must have the file extension of  .tag or .tagx.
A TLD file must be used to map the symbolic tag name to the actual tag file.
A tag file may NOT be placed in a JAR file in the WEB-INF/lib directory.
Option A is invalid because tag files must be placed under the WEB-INF/ tags directory.
Option C is invalid because tag files may be discovered by the container in several well-known locations.
Assuming no exceptions occur, doAfterBody() is always called after doStartTag() for any tag that implements IterationTag.
Assuming no exceptions occur, doAfterBody() is called after doStartTag() for any tag that implements IterationTag and returns SKIP_BODY from doStartTag()
Assuming no exceptions occur, doAfterBody() is called after doStartTag() for any tag that implements IterationTag and returns EVAL_BODY_INCLUDE from doStartTag()
Option A is invalid because doAfterBody() can be called on any tag that implements the IteratorTag interface.
Option B is invalid because there is no such class.
Options C and D are invalid because doAfterBody() is only called when doStartTag() returns EVAL_BODY_INCLUDE.
Option A is invalid because there is no such method.
Option B is invalid because there is no request instance variable.
Option C is invalid because an attribute in page scope would be found before checking request scope.
Option D is invalid because there is no getPageContext() method.
The setJspBody method is always called before the doTag method.
The setParent and setJspContext methods are called immediately before the tag attributes are set.
The JspFragment of the tag body is invoked by the Container before the tag handler’s doTag method is called.
This value, a BodyContent object, is passed to the tag handler using the setJspBody method.
Option A is invalid because a Simple tag has no release method.
Option B is invalid because the setJspBody is not called if the Simple tag is an empty tag.
Option D is invalid because the fragment is invoked by the doTag implementation, NOT before the doTag is called.
Options A and D are invalid because there are no methods with these names.
Option F is invalid because findAttribute() does not have a scope parameter.
Which is the most efficient JspContext method to call to access an attribute that is known to be in application scope?
Option A is invalid because there is no such method.
Option B is invalid because this method only looks in page scope.
Option C is invalid because this method would be less efficient than Option D because it first checks the other three scopes.
Option F is invalid because it would be only the first step in a process that would be much less efficient than Option D.
Given a tag, simpleTag, whose handler is implemented using the Simple tag model and a tag, complexTag, whose handler is implemented using the Classic tag model.
Both tags are declared to be non-empty and non-tag dependent in the TLD.
Option A is correct; a Simple tag may include a Complex tag in the body as long as that tag contains no scripting code.
Option B is invalid because simple tags cannot have a body that includes a JSP expression tag.
Option C is correct because the include directive is processed before the body of the simpleTag is converted into a JspFragment; however, the included content must also be non-scripting (which is why this example includes an HTML segment)
Option D is not invalid because of the complexTag usage (as in Option A), but because the complexTag body has scripting code in it.
What is the best strategy, when implementing a custom tag, for finding the value of  an attribute whose scope is unknown?
Option A is invalid because this method only checks the page scope.
Options C and D are invalid because they are less efficient than simply calling findAttribute()
Each tag file must have a corresponding entry in a TLD file.
All directives allowed in JSP pages are allowed in Tag Files.
All directives allowed in Tag Files are allowed in JSP pages.
The <jsp:doBody> standard action can only be used in Tag Files.
The allowable file extensions for Tag Files are .tag and .tagx.
For each attribute declared and specified in a Tag File, the container creates a page-scoped attribute with the same name.
Option A is invalid because tag files need only to be placed in the appropriate location in order to be used.
Option B is invalid because the page directive is not available in Tag Files.
Option C is invalid because the tag, attribute, and variable directives are not available in JSP pages.
Option E is invalid because there is no value attribute defined for the attribute directive.
Option A is correct; it is the only one of the methods shown that exists.
Option C is invalid because the page directive is not valid in tag files.
A web application includes many forms for users to fill out and submit.
Nothing in the pages indicates that a field is required.
Business decided that a red asterisk should be placed preceding the text labels of  required fields but the project manager is contending that the background color of  required fields be light blue and another department is demanding that the project’s application be consistent with their own, where the text of  the labels be bold for required fields.
Considering the different perspectives on how required fields could be identified in pages, choose the most maintainable usage of  a custom tag.
Option A would work if you knew that the required field would always be marked with a preceding symbol and the only potential change would be the identifier used.
Even still, it would be just as simple to use an img tag and swap out a .gif icon in an images directory.
Your custom tag is given full control for constructing the label and text field and how they should be displayed.
Option C: specifying a color and symbol in the tag is an unsatisfactory solution, as a change to either of these values would require you to update the values of every tag in every JSP.
Option D: it would be possible to do things this way but your class implementing the tag would have to parse the body and manipulate it, creating a maintenance nightmare.
Options C and D are invalid because tag files must be placed under the /WEB-INF/tags directory or a subdirectory of /WEB-INF/tags.
Your pages are polished, your code is tested and tuned, and your deadline was two weeks ago.
But where does everything go? So many directories, so many rules.
I’m proud of you father! Your deployment descriptor looks perfectyou’ve confi gured error pages, welcome fi les, servlet mappings...
Construct the file and directory structure of a web application that may contain (a) static content, (b) JSP pages, (c) servlet classes, (d) the deployment descriptor, (e) tag libraries, (f) JAR files, and (g) Java class files.
This objective has been covered throughout the book in other chapters, so most of  the content in this chapter related to this objective is either for review or to look at something in a little more detail.
Describe the purpose and semantics for each of the following deployment descriptor elements: error-page, init-param, mime-mapping, servlet, servlet-class, servlet-mapping, servlet-name, and welcome-file.
Construct the correct structure for each of the following deployment descriptor elements: error-page, init-param, mime-mapping, servlet, servlet-class, servlet-name, and welcome-file.
Explain the purpose of a WAR file and describe the contents of a WAR file and how one may be constructed.
While this is probably the least fun part of  the book (and the exam), most of  this content is easy to understand and it’s just a matter of  memorizing the tags.
There is one tricky part, though, and we’ll spend most of  our time on it—servlet mapping.
Write a JSP Document (XML-based syntax) that uses the correct syntax.
We decided it was better for you to concentrate more on the syntax and behavior of  all the other parts of JSP, rather than also worrying about the XML versions of  everything.
The Joy of Deployment We’ve covered most of  the fun stuff, but now it’s time for a more detailed look at deployment.
In this chapter, you need to think about three main issues:
Where will the CONTAINER look for things in the web app?
How does the CLIENT request things in the web app?
Where do you put static resources? JSP pages? Servlet class files? JavaBean class files? Listener class files? Tag Files? Tag handler classes? TLDs? JAR files? The web.xml DD? Where do you put things that you don’t want the Container to serve? (In other words, which parts of the web app are protected from direct client access?) Where do you put “welcome” files?
What does the client type into the browser to access an HTML page? A JSP page? A servlet? Something that doesn’t actually exist as a file? In which places can the client make a direct request, and in which places is the client restricted from direct access to a resource? What happens if the client types in a path to only a directory, not a specific file?
What goes where in a web app In several chapters of  this book, we’ve looked at the locations in which the various files must be placed.
In the chapter on custom tags, for example, you saw that Tag Files must be deployed in /WEB-INF/tags or a subdirectory, or in a JAR file under /META-INF/tags or a subdirectory.
If  you put a Tag File anywhere else, the Container will either ignore it or treat it as static content ready to be served.
The Servlet and JSP specs have a lot of  picky rules about where things go, and you really do need to know most of  them.
Since we’ve already covered most of  this in one way or another, we use these first few pages as a test of your memory and understanding.
Don’t skip it! Treat these next few pages as practice exam questions!
Q: Why should I have to know where everything goes...
A: If you’re lucky, you’re using a J2EE deployment tool that lets you point and click your way through a series of wizard screens.
Then your Container uses that info to build the XML Deployment Descriptor (web.xml), build out the necessary directory structures, and copy your files into the appropriate locations.
But even if you are lucky, don’t you think you need to know what the tool is doing? You might need to tweak what the tool does.
You might switch to a different vendor that doesn’t have an automated deployment tool.
A lot of developers use a build tool like ANT, but even then, you still need to tell ANT what to do.
Q: But I just got an ANT build script off the Internet, and it’s already configured to do it all for me.
A: Again, that’s great—but you still need to know what’s really happening.
If you’re completely at the mercy of your tool, you’re in trouble if something goes wrong.
Knowing how to structure a web app is like knowing how to change a tiremaybe you’ll never need to do it yourself, but if it’s 3:00 AM and you’re in the middle of nowhere, isn’t it nice to know you can?
And for those of you taking the exam, well, you don’t have a choice.
Virtually everything in this chapter is covered on the exam.
Sharpen your pencil Name the directories Write the correct directory names in, given the fi les shown within those directories.
Everything in here has been covered in an earlier chapter, but don’t worry if you haven’t completely memorized them all yet.
This is the chapter where you have to burn it in.
Sharpen your pencil Draw the directory and file structure Look at the following web app description and draw a directory structure that supports that web app.
What’s wrong with this deployment? There are several things here that do not follow the Servlet or JSP specification for    where they should.
Assume that all files have the correct names and extensions.
Name the directories To deploy a web app successfully, you MUST follow this structure.
WEB-INF must be immediately under the application context (“MyTestApp” in this example)
The package structure for the classes must be immediately inside “classes”
The “lib” directory must be immediately inside “WEB-INF”, and the JAR fi le must be immediately inside “lib”
The “META-INF” directory must be immediately inside the JAR, and TLD fi les in a JAR must be somewhere under “META-INF” (they can be in any subdirectory, and “TLDs” is not required as a directory name)
TLDs that are NOT in a JAR must be somewhere under “WEBINF”
Tag Files (fi les with a .tag or .tagx extension) must be somewhere under “WEB-INF/tags” (unless they’re deployed in a JAR, in which case they must be somewhere under “META-INF/tags”)
TLDs in a JAR file MUST be somewhere inside “META-INF”
Oh if only there were a way to deploy my entire web app in.
And everything has to be in exactly the right place.
But there’s a solution, called a WAR file, which stands for Web ARchive.
And if  that sounds suspiciously like a JAR file (Java ARchive), that’s because a WAR is a JAR.
A WAR file is simply a snapshot of  your web app structure, in a nice portable, compressed form (it’s really just a JAR file)
You jar up your entire web app structure (minus the web app context directory—the one that’s above WEB-INF), and give it a .war extension.
But that does leave one problem—if  you don’t include the specific web app directory (BeerApp, for example), how does the Container know the name/ context of  this web app?
To deploy it as a WAR file, you jar up everything in the BeerApp directory (but not the BeerApp directory itself), then name the resulting JAR file BeerApp.war.
Then you drop the BeerApp.war file into the tomcat/webapps directory.
Tomcat unpacks the WAR file, and creates the web app context directory using the name of the WAR file.
But again, your Container may handle WAR deployment and naming differently.
What matters to us here is what’s required by the spec, and the answer is—it makes almost no difference whether the app is deployed in or out of  a WAR! In other words, you still need WEB-INF, web.xml, etc.
There is one thing you can do when you use a WAR file that you can’t do when you deploy without one—declare library dependencies.
That means you don’t have to wait until a resource is requested before the whole thing blows up because the Container doesn’t have a particular class in its classpath that the requested resource needs.
Quick quiz: do you still need a fi le named “web.xml” if you.
When you deploy a web app into Tomcat by putting the WAR file into the webapps directory, Tomcat unpacks it, creates the context directory (MyTestApp in this example), and the only new thing you’ll see is the META-INF directory (with the MANIFEST.MF file) inside.
You will probably never put anything into the META-INF directory yourself, so you’ll probably never care whether your app is deployed as a WAR unless you do need to specify library dependencies in the MANIFEST.MF file.
Making static content and JSPs directly accessible When you deploy static HTML and JSPs, you can choose whether to make them directly accessible from outside the web app.
By directly accessible, we mean that a client can enter the path to the resource into his browser, and the server will return the resource.
But you can prevent direct access by putting files under WEB-INF or, if you’re deploying as a WAR file, under META-INF.
Clients can directly access static content and JSPs at the web app root level OR in subdirectories.
You CAN put content here, but it will NOT be available for direct access by a client.
If the server gets a client request for anything under WEB-INF or META-INF, the Container MUST respond with a 404 NOT FOUND error!
Q: If you can’t serve content from WEB-INF or META-INF, what’s the point of putting pages there??!!
You have Java classes and class members with package-level (default) access, right? These are classes and members not available to the “public”, but meant for internal use by other classes and members that are publicly exposed.
It’s the same way for these nonaccessible static content and JSPs.
By putting them under WEB-INF (or, with a WAR file, META-INF), you’re protecting them from any direct access, while still allowing other parts of the web app to use them.
You might, for example, want to forward to or include a file while making sure that no client can directly request it.
Chances are, if you want to protect a resource from direct access, you’ll use WEB-INF and not META-INF, but for the exam, you have to know that the rules apply to both.
Q: What about a META-INF directory inside a JAR file inside WEB-INF/lib? Does that have the same protection as META-INF inside the WAR file?
But the fact that the content is in META-INF is not the point.
In this case, you’re talking about a JAR file inside the lib directory inside WEB-INF.
And anything in WEB-INF is protected from direct access! So, it doesn’t matter where under WEB-INF the content is, it’s still protected.
When we say that META-INF is protected, we’re really talking about META-INF inside a WAR file, because the META-INF inside WEB-INF/lib JAR files is always protected anyway by virtue of being under WEB-INF.
Are you required to do that? Isn’t everything in the WEB-INF/lib jar files and the WEB-INF/classes directory automatically on the classpath for this application?
A: Yes, classes you deploy in/with the web app, by using the WEB-INF/classes directory or a JAR in WEBINF/lib, are available and you don’t have to do or say.
Or maybe you’re depending on a particular version of a library! The MANIFEST.MF file gives you a place to tell the Container about the optional libraries you must have access to.
If the Container can’t provide them, it won’t let you successfully deploy the application.
Which is a lot better than if you deploy and then find out later, at request time, when you get some horrible (or worse—subtle) runtime error.
Q: How does the Container access the content inside JAR files in WEB-INF/lib?
A: The Container automatically puts the JAR file into its classpath, so classes for servlets, listeners, beans, etc.
In other words, it doesn’t matter whether the classes are in or out of a JAR as long as they’re in the right locations.
Keep in mind, though, that the Container will always look for classes in the WEB-INF/classes directory before it looks inside JAR files in WEB-INF/lib.
Q: OK, that explains class files, but what about other kinds of files? What if I need to access a text file that’s deployed in a JAR in WEB-INF/lib?
The difference is, the methods inside ServletContext work only for resources within the web app that are not deployed within a JAR file.
For the exam, you need to know that you can use the standard J2SE mechanism for getting resources from JAR files, but you do not need to know any details.
How servlet mapping REALLY works You’ve seen examples of  servlet mapping in the Deployment Descriptors we’ve used in earlier chapters, beginning with the tutorial.
But I don’t see a directory named “Beer” and there’s no fi le named “SelectBeer.do”
Servlet mappings can be “fake” The URL pattern you put into a servlet mapping can be completely made-up.
Clients who have no business knowing anything about the real physical structure of  your web app.
With servlet mappings, you have two structures to organize: the real physical directory and file structure in which your web app resources live, and the virtual/logical structure.
The virtual/logical structure exists simply because you SAY it exists! The URL patterns in the DD don’t map to anything except other <servlet-name> elements in the DD.
In other words, it looks first for an exact match.
If it can’t find an exact match, it looks for a directory match.
If it can’t find a directory match, it looks for an extension match.
Which servlet will the Container choose given the DD servlet mappings.
Just to make sure you understand servlet mappings, here’s one more little example.
Don’t skim—look closely at both the mapping and the requests.
In this mini “Be the Container”, the answers are at the bottom of  the opposite page, so don’t peek.
Configuring   welcome files in the DD You already know that if  you type in the name of  a web site and you don’t specify a specific file, you (usually) still get something back.
Entering http://www.oreilly.com into your browser takes you to the O’Reilly web site, and even though you didn’t name a specific resource (like “home.html”, for example), you still get a default page.
You can configure your server to define a default page for the entire site, but we’re concerned here with default (also known as “welcome”) pages for individual web apps.
You configur welcome pages in the DD, and that DD determines what the Container chooses when the client enters a partial URL—a URL that includes a directory, for example, but not a specific resource in the directory.
In other words, what happens if  the client request comes in for:
Imagine you have a web app where several different directories have their own default HTML page, named “index.html”
It would be a huge pain if  you had to specify a specific default page or JSP for each directory that needs one.
Instead, you specify a list, in order, of  the pages you want the Container to look for in whatever directory the partial request is for.
The way in which the Container matches and chooses welcome fi les is not the same as the way in which it matches URL patterns.
If you put the slash in front of the fi le name, you’ll be violating the spec, and bad things will happen.
Which welcome files will the Container choose given the DD and the client.
Tomcat shows a directory listing for the newMember directory (which shows “foo.txt”)
Container looks in the DD for a servlet mapping, and doesn’t fi nd a match.
Container looks in the /MyTestApp/search directory for an “index.html” fi le, but does not fi nd one.
Container looks in the /MyTestApp/search directory for a “default.jsp” fi le, fi nds one, and serves its response to the client.
Configuring   error pages in the DD Sure, you want to be friendly when the user doesn’t know the exact resource to ask for when they get to your site or web app, so you specify default/welcome files.
But you also want to be friendly when things go wrong.
We already looked at this in the chapter on Using Custom Tags, so this is just a review.
This applies to everything in your web app—not just JSPs.
Declaring an error page based on an HTTP status code.
This configures an error page that’s called only when the status code for the response is “404” (file not found)
This configures an error page that’s called only when the status.
FYI: you can override this in individual JSPs by adding a page directive with an errorPage attribute.
Q: What are you allowed to declare as an exception type in <exception-type>?
Q: Speaking of error handling,  can you programmatically generate error codes yourself?
And if you’ve configured an error page to be sent to the client based on that error code, that’s what the client will get.
And by the way, “error” codes are also known as “status” codes, so if you see either one, they mean the same thing—HTTP codes for errors.
You must use the fully-qualifi ed class name in <exception-type>!
Configuring servlet initialization in the DD You already know that servlets, by default, are initialized at first request.
If  you want servlets to be loaded at deploy time (or at server restart time) rather than on first request, use the <load-on-startup> element in the DD.
Any non-negative value for <load-on-startup> tells the Container to initialize the servlet when the app is deployed (or any time the server restarts)
A: To answer that question, you ask yourself, “How many servlets do I have in my app, and how likely is it that they’ll all be used?”  And you’ll also need to ask, “How long does it take each servlet to load?”  Some servlets are rarely used, so you might want to conserve resources by not loading the rarely-used servlets in advance.
But some servlets take so painfully long to initialize (like the Struts ActionServlet), that you don’t want even a single client to experience that much latency.
So, only you can decide, and you’ll probably decide on a servlet-by-servlet basis,  evaluating both the pain level and likelihood of use for each servlet.
Values greater than one do not affect the number of servlet instances!
Making an XML-compliant JSP: a JSP Document This topic didn’t fit well anywhere else, so we decided to stick it in this chapter since we’re talking about XML so much.
The exam doesn’t require you to be an XML expert, but you do have to know two things: the syntax for the key DD elements, and the basics of  making what’s known as a JSP Document.
All it means is that there are really two types of  syntax you can use to make a JSP.
The text in grey is the same across both types of  syntax.
This is all the exam covers on JSP Do cuments.
We aren’t going to say any more about i t because writing XML-compliant.
There IS more you have to know if you write this.
Memorizing the EJB-related DD tags This exam is about web components, not business components (although in the Patterns chapter, you’ll see a few things about business components)
But if  you’re deploying a J2EE app, complete with Enterprise JavaBeans (EJBs) in the business tier, some of  your web components will probably need to lookup and access the enterprise beans.
If  you’re deploying an app in a full J2EE-compliant Container (one that has an EJB Container as well), you can define references to EJBs  in the DD.
You don’t have to know anything about EJBs for this exam, other than what you declare in the DD, so we won’t waste your time explaining it here.*
But if  you’re interested in EJB, there’s this really good book...
A LOCAL bean means the client (in this case, a servlet) and the bean must be running in the same JVM.
A REMOTE bean means the client (in this case, a servlet) and the bean can be running in different JVMs (possibly on different physical machines as well)
These must be fully-qualified names of the bean’s exposed interfaces.
Both the local and remote bean D D tags have two elements.
The <ejb-ref-type> describes whe ther this is an Entity or Session bean.
In other words, the local referenc e says it’s local, but the.
This also explains the OTHER ta g naming inconsistencythe name of the tag for the bea n’s home interface.
Memorizing the JNDI   <env-entry> DD tag If  you’re familiar with EJB and/or JNDI, this will make sense.
If  you’re not, it doesn’t really matter for the exam as long as you memorize the tag.
The details surrounding JNDI environment entries are covered in EJB/J2EE books like the lovely Head First EJB.
Think of  an environment entry as being something like a deploy-time constant that your app can use, much like servlet and context init parameters.
In other words, a way for the deployer to pass values into the servlet (or in this case, an EJB as well if  this is deployed as part of  an enterprise application in a fully J2EE-compliant server)
At deploy time, the Container reads the DD and makes a JNDI entry (again, assuming this is a fully J2EE-compliant app, and not just a server with only a web Container), using the name and value you supply in this DD tag.
At runtime, a component in the application can look up the value in JNDI, using the name listed in the DD.
You probably won’t care about <env-entry> unless you’re also developing with EJBs, so the only reason you need to memorize this is for the exam.
This will probably be the easiest tag to remember, because it just makes sense—you map between an extension and a mime-type, and guess what? In a rare moment of  simplicity and clarity, they named the tag sub-elements “extension” and “mime-type”
That means you have to remember only one thing—that the tag elements are named for exactly what they are!
Unless you start thinking of  it as “file-type” and “content-type”
Directly inside WEB-INF (which is directly inside the root of the web app)
Sharpen your pencil Where things go Fill in this table with explicit notes on where in the web app the given resource must be placed.
If you’re NOT planning on taking the exam, don’t worry about getting all of these right (although the bottom two elements are important to almost everyone)
If you ARE going to take the exam, you should spend some time memorizing these.
Directly inside WEB-INF (which is directly inside the root of the web app)
If deployed in a JAR, Tag Files must be in META-INF/tags, or a subdirectory of META-INF/tags.
Client-accessible HTML and JSPs can be anywhere under the root of the web app or any of its subdirectories, EXCEPT they cannot be under WEB-INF (including subdirectories)
In a WAR file, they can’t be under META-INF (including subdirectories)
Pages under WEB-INF (or META-INF in a WAR file) cannot be directly accessed by clients.
If NOT inside a JAR, TLD files must be somewhere under WEB-INF or a subdirectory of WEB-INF.
If deployed in a JAR, TLD files must be somewhere under META-INF, or a subdirectory of META-INF.
Actually ALL classes used by the web-app (unless they’re part of the class libraries on the classpath) must follow the same rules as servlet classes—inside WEB-INF/classes, in a directory structure matching the package (or in the appropriate package directories within a JAR inside WEB-INF/lib)
Sharpen your pencil Where things go Fill in this table with explicit notes on where in the web app the resource must be placed.
If you are going to take the exam, you should spend some time memorizing ALL of these (plus any of the others from from this chapter and the security-related tags you’ll see in the next chapter)
A reference to a bean that has a “local” interface.
A reference to a bean that has a “remote” interface.
An environment entry is a way to get deploy-time constants into a J2EE application.
Tells the Container which page to look for when a request comes in that doesn’t match a specific resource.
Inside of  <context-param> elements when you want to declare a context initialization parameter.
In the package-related directory tree begining at the top level of  the.
To allow code-generation tools to dynamically create servlets from an XML file.
To convey the web-application configuration information from developers to application assemblers and deployers.
To configure only database and Enterprise JavaBean access from the web application.
Line 10 is not valid in a JSP document (XML-based document)
They are used to declare initialization parameters for a specific servlet.
They are used to declare initialization parameters for an entire web app.
The method that retrieves these parameters has a signature that returns an Object.
Web applications should NOT attempt to override container implementation classes.
A web application must not attempt to load resources from within the WAR file using the J2SE semantics of  getResource.
A web developer may override J2EE platform classes provided they are contained in a library JAR within a WAR.
Inside of  <context-param> elements when you want to declare a context initialization parameter.
The container will not automatically discover TLDs if they are in /WEB-INF/classes or /WEB-INF/lib.
Option B is incorrect because web.xml does not contain an element named <web-application>
In the package-related directory tree begining at the top level of  the.
Option D is not correct because /WEB-INF/lib is designed as the container for JAR files.
To allow code-generation tools to dynamically create servlets from an XML file.
To convey the web-application configuration information from developers to application assemblers and deployers.
To configure only database and Enterprise JavaBean access from the web application.
Option D is inaccurate because these concerns are just a subset of the DD’s purpose.
Line 10 is not valid in a JSP document (XML-based document)
They are used to declare initialization parameters for a specific servlet.
They are used to declare initialization parameters for an entire web app.
The method that retrieves these parameters has a signature that returns an Object.
Initialization parameters can have web app scope or servlet scope.
Those with servlet scope are named <init-param> in the DD, and take and return a String.
Those with web app scope are named <context-param> in the DD and also take and return a String.
Option  A is incorrect because line 10 would be invalid in a JSP Document (XML-based document)
Options C and E are invalid as they are not valid elements in the http://java.sun.com/JSP/Page namespace.
Option B is incorrect because it confuses the servlet name with the servlet class.
The <web-app> element is the root element of the web application deployment descriptor.
Web applications should NOT attempt to override container implementation classes.
A web application must not attempt to load resources from within the WAR file using the J2SE semantics of  getResource.
A web developer may override J2EE platform classes provided they are contained in a library JAR within a WAR.
Options C and D are incorrect because only the <jsp:declaration> syntax is valid in JSP Documents.
Option B is incorrect because the webapp may use the getResource method from the webapp’s class loader to access any WAR file.
Trouble lurks in every corner of the network, as crackers, scammers, and criminals try to break into your system.
You don’t want the Bad Guys convincing your server that.
Based on the servlet specification, compare and contrast the following security issues: (a) authentication, (b) authorization, (c) data integrity, and (d) confidentiality.
All of  the objectives in this section are covered completely in this chapter, including securityrelated DD elements that were NOT covered in the deployment chapter.
We can’t make you a complete security being, but the content in this chapter is a start, and it’s everything you need for the exam.
In the deployment descriptor, declare the following: a security constraint, a Web resource, the transport guarantee, the login configuration, and a security role.
Given an authentication type (BASIC, DIGEST, FORM, and CLIENT-CERT), describe its mechanism.
The Bad Guys are everywhere As a web application developer you need to protect your web site.
There are three main kinds of  bad guys you need to watch out for: Impersonators, Upgraders, and Eavesdroppers.
I’m in too! I’m already a regular member, but now.
I fi gured out how to sneak in to the Premium Members area, and now I can do.
Not only are they trying to scam your web app, but they can burn some of  your good clients too.
If  an eavesdropper is successful, he’ll swipe your client’s credit card information and charge up a storm.
The Big 4 in servlet   security Servlet security helps you—the web app developerfoil Impersonators, Upgraders, and Eavesdroppers.
As far as the servlet specification is concerned (and hence, the exam), servlet security boils down to four main concepts:   authentication,  authorization, confi dentiality, and data  integrity.
Look Delbert, before I can send you this special Premium web page I have to.
I know I’ve handed you some bad jobs in the past, but this one should be really fun...
The boss continued, “Let me give you the elevator pitch to get you going, then we’ll go into details once you’ve had a chance to think this through.”
As you know, this beer website is really hot right now.
We’ve added several new features, and we’re getting a great response.
Some of  our users are happy with just the free recipes we offer, but a lot more people than we thought are willing to pay for our rare hops and other premium ingredients.
Oh, and our Frequent Brewer program is a huge hit.
If  a user decides he’ll be a repeat ingredient buyer, he can pay a one time fee and upgrade to Brew Master status.
Bob continued to listen, mentally calculating the code he’ll have to write to implement all this, and kissing that tropical vacation goodbye.
But now we have to make sure that when one of our users makes a purchase, no one can swipe his credit card information.
Oh, another thing, we’d better make sure that when a member logs in, it’s not actually one of  his friends trying to sneak in.
Reread the story and annotate the places where the boss’s requirements call for:
Yeah, yeah, we know this is obvious, but we’re just warming up the topic before it gets down and dirty.
I know I’ve handed you some bad jobs in the past, but this one should be really fun...
The boss continued, “Let me give you the elevator pitch to get you going, then we’ll go into details once you’ve had a chance to think this through.”
As you know, this beer website is really hot right now!  We’ve added several new features, and we’re getting a great response.
Some of our users are happy with just the free recipes we offer, but a lot more people than we thought are willing to pay for our rare hops and other premium ingredients.
Oh, and our Frequent Brewer program is a huge hit.
If a user decides he’ll be a repeat ingredient buyer, he can pay a one time fee and upgrade to Brew Master status.
Bob continued to listen, mentally calculating the code he’ll have to write to implement all this, and kissing that tropical vacation goodbye.
But now we have to make sure that when one of our users makes a purchase, no one can swipe his credit card information.
Oh, another thing, we’d better make sure that when a member logs in, it’s not actually one of his friends trying to sneak in.
A little security story “It’s all making sense so far.” said Bob.
Oh, and one more thing I forgot—you better make sure that Frequent Brewers.
But now we have to make sure that when one of our users makes a purchase, no one can swipe his credit card information.
Let’s start with a look at the communications that occur between a browser and a web container when the client asks for a secure resource on the web site.
How to Authenticate in HTTP World: the beginning of a secure transaction.
The browser makes a request for a web resource, “update.jsp”
The browser gets the 401, and, based on  the Realm info, asks the user for his username and password.
The browser asks for “update.jsp” again (stateless, remember), but this time the request includes a security HTTP header, and a username and password.
The Container verifi es that the username and password match, and if they do, performs authorization.
Container returns the HTML, if not it returns another HTTP 401...
On the last page we skimmed over what the Container was doing.
Throughout this chapter we’ll hit different levels of  detail, and here we zoom in just a little...
A slightly closer look at how the Container does  Authentication and   Authorization.
Having received the request, the container fi nds the URL in the.
If the Container fi nds the URL in the security table, it checks to see whether the requested resource is constrained.
When the Container receives a request with a username and password, it checks the URL in the security table.
If it fi nds the URL in the security table (and sees that it’s constrained), it checks the username and password information to make sure they match.
Which bits of security logic and information should be hardcoded in the servlet?
You just got an overview of  how the Container handles authentication and authorization.
But what was going on inside the Container that made all that happen? Let’s speculate a little on what was going on behind the scenes, deep down in the heart of  the Container...
We already know that the Container is really good at finding resources.
But now, once it finds the resource, it has to determine whether it’s a resource that anyone can view, or whether the resource has security constraints.
Does the servlet itself  have some sort of  security flag? Is there a table somewhere?
Once the Container determines that it’s dealing with a secured resource, it has to authenticate the client.
In other words, to find out if  “Bob” really is Bob.
The most common way is to see if Bob knows his own password.
Performed some authorization Once the Container determines that it is the real Bob asking for this resource, the Container has to see whether Bob is allowed access to that resource.
Whoa! This could get out of  hand in a hurry if we’re not careful.
Anything you can do to make security efficient will be a big help for performance.
Which bits of security logic and information should be hardcoded in the servlet?
Keep security out of the code! For most web apps, most of  the time, the web app’s security constraints should be handled declaratively, in the deployment descriptor.
Often maps naturally to the existing job roles in a company’s IT department.
Allows application developers to reuse servlets without access to the source code.
Allows you to use servlets you’ve already written in more fl exible ways.
Finally, a way to justify the cost of that Container...
Then I add these roles to the users in our Container’s users file.
My job is huge! Once I have a list of Annie’s roles, and a description of what Kim’s servlets.
The deployment descriptor provides me with an easy, if somewhat verbose, way to tell the Container who has access to which servlets.
And let me tell you, they don’t pay me enough...
A: Yes, you should; Kim the servlet provider was being a little sarcastic.
For instance, it makes sense to separate browsing capabilities from updating capabilities.
If these two use cases are implemented in separate servlets then it will be easy for the deployer to assign different security constraints to them.
Q: I don’t know where YOU work, but in my situation I have to wear all three hats: developer, admin, and deployer.
We still recommend that when you’re implementing security you do it in stages and “imagine” that you’re wearing one hat at a time.
A: We’ll get to programmatic security later in the chapter.
For now, what’s important to know is that you’ll probably find that 95% of the security work you’ll do in servlets will be declarative.
Q: So far everything you’ve talked about is related to authentication and authorization, how about the other two in “The Big Four”?
A: We’ll talk about confidentiality and data integrity later in this chapter.
The servlet specification makes implementing these concepts very easy, so we’re focusing on authentication and authorization because they’re the most complicated to understand and implement,  and, hint hint, more likely to show up on the exam.
Q: It seems like when people talk about servlet security the term “role” is overloaded...
A: Good point!  When Sun designs J2EE specs (EJBs, servlets, JSPs), they often think in terms of the kinds of people who might create and administer these components.
When developers tackle security for web apps, they think about the types of users that might exist.
For instance a “guest” might have very few privileges within a web app, and a “member” might have more privileges.
These “user roles” are defined, mapped, and fretted over in the Deployment Descriptor.
A: Cross-site hacking can happen when a website displays free form text entered by other users (for instance, a user book review)
If a malicious user keys some HTML with, say, Javascript into a text area, and the server doesn’t catch it, then unsuspecting browsers will render the potentially dangerous hidden code along with the good HTML when the page is served.
In other words, the server sends to users something another user typed in, without checking or processing it for malicious scripting code.
Q: So we’ve got to deal with “The Big Four.”  How hard is it to set these babies up and maintain them, I mean is this going to be painful?
Actually, some aspects of security are really low overhead, while others DO require a fair amount of work.
But none of it is very complicated, just potentially tedious.
The Big Jobs in servlet security The table below will give you a feel for the key items in servlet security.
Authorization is the most time-consuming to implement and Authentication is next.
From the servlet perspective, Confidentiality and Data Integrity are pretty easy to set up.*
We’re going to emphasize Authorization in this chapter because it’s the most important and complex of the vendor-neutral security concepts.
Actually, getting the SSL certification is not trivial, so by “easy” we mean “you don’t really do anything in your servlet code.”
Just enough Authentication to discuss Authorization Later in the chapter we’ll go deeper into authentication, but for now we’ll look at getting just enough authentication data into the system so that we can focus on authorization.
The servlet specification doesn’t talk about how a Container should implement support for authentication data, including usernames and passwords.
But the general idea is that the Container will supply a vendor-specific table containing usernames and their associated passwords and roles.
But virtually all vendors go beyond that and provide a way to hook into your company-specific authentication data, often stored in a relational database or LDAP system (which is beyond the scope of  this book)
The control for authentication is located in some sort of data structure like this.
The security “realm” Unfortunately, realm is yet another overloaded term in the security world.
As far as the servlet spec is concerned, a realm is a place where authentication information is stored.
It’s commonly known as the memory realm because Tomcat reads this file into memory at startup time.
While it’s great for testing, it’s not recommended for production.
For one thing you can’t modify its contents without restarting Tomcat.
To get authentication working (in other words, to get the Container to ask for a username and password), you need to stick something in the DD.
Don’t worry about what this means for now, but if  you want to start playing around with authentication, use this:
Authorization Step 1: defining  roles The most common form of  authorization in servlets is for the container to determine whether a specific servlet—and the invoking HTTP request method—can be called by a user who has been assigned a certain security “role”
So the first step is to map the roles in the vendor-specific.
The deployer creates <role-name> elements in the DD, so that the Container can map roles to users.
Don’t forget that you always need the <login-config> element if you want to enable authentication.
Authorization Step 2: defining resource/method   constraints Finally, the cool part.
This is where we get to specify, declaratively, that a given resource/method combination is accessible only by users in certain roles.
The <http-method> element(s) describe which HTTP methods are constrained (restricted) for the resources defined by the URL pattern.
The optional <auth-constraint> element lists which roles CAN invoke the constrained HTTP Methods.
In other words, it says WHO is allowed to do a GET and POST on the specified URL patterns.
Because they’re in the “Member” role, Diane and Annie can do GET and POST on resources that fi t the <url-pattern> elements.
Ted is only a “Guest”, so he can’t do a GET or POST.
Both of us are allowed to do a GET and POST on the.
My role (guest) is not listed under <auth-constraint>, so I.
We wish we could tell you to relax here, but you really do need to know the details of  these elements.
If  you make one little mistake in the security part of  your DD, you could leave the most sensitive parts of  your app open to...
In other words, once you specify even a single <http-method>, you automatically enable any HTTP Methods which you have not specified.
This says that the GET method can be accessed ONLY by the roles defined in the <auth-constraint>
But the OTHER methods have no constraint, so they can be accessed by anyone.
It’s tempting to think that resource s themselves are constrained.
The <auth-constraint> element does NOT defi ne which roles a.
If you do NOT specify any <http-method>, then you’re constraining ALL HTTP Methods.
You’ll probably never do that, because the whole point of a security constraint is to constrain specifi c HTTP requests on a particular set of resources.
Of course, HTTP Methods won’t work in a servlet unless you’ve overridden the doXXX() method, so if you have only a doGet() in your servlet, and you specify an <http-method> element for only GET, nobody can do a POST anyway, because the server knows you don’t support POST.
So we can modify the rule a little to say: any HTTP Methods supported by your servlet (because you overrode the matching service method) will be allowed UNLESS you do one of two things:
If you specify an <http-method> element, all the HTTP methods you do NOT specify are UNconstrained!
Remember this: if you don’t say wh ich roles are constrained, then NO.
Look at the DD fragments below, and imagine the different combinations of  <auth-constraint> configurations that might be used.
A and B refer to the DD on the previous page.
When combining individual role names, all of the role names listed will be allowed.
Q: I understand that putting in an empty <auth-constraint/> element tells the Container that NOBODY from any role can access the constrained resource.
But I don’t understand WHY you would ever do that.
A: When we said, “NOBODY”, we meant, “Nobody from OUTSIDE the web app”
In other words, a client can’t access the constrained resource, but another part of the web app can.
You might want to use a request dispatcher to forward to another part of the web app, but you don’t ever want clients to request that resource directly.
Think of 100% constrained resources as sort of like private methods in a Java class—for internal use only.
Q: Do I actually have to sit there and type in every one of my users with their passwords and roles?
A: If you’re using the test memory realm from Tomcat, yes.
But chances are, in the real world you’re using a production server that gives you a hook into the LDAP or database where your real user security info is stored.
Alice knows that most of  the time declarative security is the way to go.
As web application architectures have evolved, individual servlets have become more and more specialized.
In the old days, a single servlet would be used to provide business logic to support employees and managers.
Today, these functions would probably be split into at least two distinct servlets.
Alice has heard a rumour that RecipeServlet uses programmatic security, so she starts looking through the source code and finds this snippet...
What are the implications? Think about what you’ve learned so far in this chapter, look at the small code snippet above, and try to answer the questions.
What security step must have happened before this snippet runs?
What part, if any, does the DD play in this snippet?
What if the role of “Manager” doesn’t exist in your container?
Who came up with “Manager” as a ro le name?
It’s not commonly used, so we don’t cover it in this book (and there’s nothing else you need to know about it for the exam)
This gives you a way to customize how a service method behaves based on the user’s role.
Before isUserInRole() is called, the user needs to be authenticated.
If the method is called on a user that has not been authenticated, the Container will always return false.
The Container takes the isUserInRole() argument, in this example “Manager”, and compares it to the roles defined for the user in this request.
If the user is mapped to this role, the Container returns true.
I just got this servlet from Stan in accounting and he’s hardcoded roles that we don’t even have.
We do, however, know of  this really nice EJB book...
How do you match up roles in the DD with roles in a servlet?
The declarative side of programmatic security There’s a good chance that when a programmer hard-codes security role names in a servlet (to use as the argument to isUserInRole()), the programmer was just making up a fake name.
He either didn’t know the real role names, or he’s writing a reusable component that’ll be used by more than one company, and those companies aren’t likely to have the exact role names the programmer used.
Of  course, if  the programmer really wants to build reusable components, hard-coding a role name is a Terrible Idea, but we’ll suspend disbelief  for now.
So even if  you can’t stop a programmer from hardcoding a role name, you at least have a work-around when the hard-coded roles don’t match your real role names.
Because even if  you do have the servlet source code, do you really want to change, recompile, and retest your code just to change every instance of.
When the Container hits an arg ument to “isUserInRole()”, it loo.
Based on the combinations shown, decide who can directly access the constrained resource.
Authentication revisited For a J2EE Container, authentication comes down to this: ask for a user name and password, then verify that they match.
The first time an un-authenticated user asks for a constrained resource, the Container will automatically start the authentication process.
There are four types of authentication the Container can provide, and the main difference between them is, “How securely is the name and password info transmitted?”
OK, so I know all about authorization, but I still.
That might sound secure, but you probably already know that since the encoding scheme (base64) is really well known, BASIC provides very weak security.
CLIENT-CERT authentication transmits the login information in an extremely secure form, using Public Key Certificates (PKC)
The downside to this mechanism is that your clients need to have a certificate before they can login to your system.
It’s fairly rare for consumers to have a certificate, so CLIENT-CERT authentication is used mainly in business to business scenarios.
The three types above—BASIC, DIGEST, and CLIEN-CERTall use the browser’s standard pop-up form for inputting the name and password.
The username and password are sent back in the HTTP request, with no encryption.
Implementing Authentication This is the simple part—simply declare the authentication scheme in the DD.
If your container supports DIGEST, it will handle ALL the details.
Form-Based Authentication Although there’s more to implementing it than with the other forms of  authentication, FORM-based isn’t that bad.
First, you create your own custom HTML form for the user login (although this can certainly be generated by a JSP)
Then you create a custom HTML error page for the Container to use when the user makes a login error.
Finally, you tie the two forms together in the DD, using the <login-config> element.
Note: if  you’re using Form-based authentication, be sure to turn on SSL or session tracking, or your Container might not recognize the login form when it’s returned!
The Container requires that the HTTP request will store the user name in:  j_username.
The container requires that the HTTP request will store the password in:  j_password.
You need to know everything on this page for the exam!
Summary of Authentication types This table summarizes key attributes of  the four authentication types.
Hint: you’ll need to remember this table when you take the exam.
CLIENT- J2EE Strong - public key, (PKC) Strong, but users must have certificates.
A: When you’re authenticating a user, she’s sending you her username and password.
Data integrity and confidentiality refers to the degree to which an eavesdropper can steal or tamper with this information.
In a moment,  we’ll talk about how to implement data integrity and confidentiality during login.
Data integrity means that the data that arrives is the same as the data that was sent.
In other words, nobody tampered with it along the way.
Data confidentiality means that nobody else can see the data along the way.
Most of the time, though, we treat data integrity and confidentiality as a single goal—things you do to protect data during transmission.
Sharpen your pencil Fill-in the missing pieces for this FORM-based authentication app.
But I don’t want to use the ugly browser login.
Oh if only there were a way to use my own custom login form, but still protect the username and password.
You can have your custom login cake and secure it too.
Login data is still data, so you can secure it in the same way you’d want to protect an online shopper’s credit card number—using your J2EEcompliant Container’s data integrity and confidentiality features.
In other words, Containers are not required to use any specific protocol to handle secure transmissions, but in practice they nearly all use HTTPS over SSL.
The Bad Eavesdropper gets a copy of the HTTP request that contains the client’s credit card info.
The data isn’t protected, so it comes over in the body of the POST in a nice readable form.
The Bad Eavesdropper gets a copy of the HTTP request that contains the client’s credit card info.
But because it was sent with extra-strength HTTPS over SSL, he CANNOT read the information !!
If your web application is going to be fast, efficient and secure, you’ve got some questions to answer...
If you could apply transmission security measures to only some requests and responses, how would you want to tell the Container which requests and responses?
Can you think of any other DD elements that work on the same level of granularity that you want for declaring protected transmissions?
Do NOT tell me that if I choose to use data protection it encrypts EVERY request.
How to implement data confidentiality and integrity sparingly and declaratively Once again, we turn to the DD.
And when you think about it, it makes sense—if  you’re thinking about authorization for a resource, you’re probably going to consider whether you want the data transmitted securely.
Only Members can make POST requests to resources found in the UpdateRecipes directory, and make sure the transmission is secure.
NOTE: although not guaranteed by the spec, in practice virtually every Container uses SSL for guaranteed transport, which means that both INTEGRAL and CONFIDENTIAL do the same thing—either one gives you both confidentiality and integrity.
You’ll probably never specify NONE, since there’d be no ne.
The request data has already been sent over the wire.
You already know how to force the client to get a login screen—by defining a constrained resource in the DD, the Container will automatically trigger the authentication process when an unauthenticated user makes the request.
So now we have to figure out how to protect the data coming in from a request...
Unauthorized client requests a constrained resource that has NO transport guarantee.
The Container sends a 401 response to the client, that tells the browser to get login information from the user.
The browser makes the same request again, but this time with the user’s login information in the header.
The Container authenticates the client (checks that username and password match the user data confi gured in the server)
Then the Container authorizes the request to make sure that this user is in a role that’s allowed to get the constrained resource.
Client requests /BuyStuff.jsp, a constrained resource that also has a transport guarantee.
Unauthorized client requests a constrained resource that has a CONFIDENTIALITY transport guarantee.
The Container sees that this constrained resource has a transport guarantee.
The Container sees that the request did NOT come in securely...
The Container sends a 301 response to the client, that tells the browser to redirect the request using a secure transport.
The browser makes the same resource request again, but this time, over a secure connection.
In other words, the resource stays the same, but the protocol is now HTTPS.
Now the Container sees that the resource is constrained, and that this user has not authenticated.
So now the Container starts the authentication process by sending a “401” to the browser...
The browser makes the same request again, (yes, for the THIRD time) but this time the request has the user’s login data in the header AND the request comes over using a secure connection.
So this time the client’s login data is transmitted securely!
That way, the Container will get th e request for the constrained reso.
To make sure the user’s logi n info is submitted to the.
Doesn’t it just redirect back to the same original request?
A: Normally you think of a redirect as meaning “Hey browser, go to a different URL instead.” The redirect is invisible to the client, remember; the client’s browser automatically makes the new request on the URL specified in the redirect (301) header that comes from the server.
Instead of telling the client browser, “Redirect to a different resource”,  the Container says, “Redirect to the same resource, but with a different protocol—use HTTPS instead of HTTP.”
A: It’s not guaranteed by the spec, but it’s extremely likely that your Container is using HTTPS over SSL (secure sockets)
But it won’t necessarily be automatic! You probably have to configure SSL in your Container, and more importantly—you need a certificate!
You’ll have to check your Container’s documentation, but chances are, your Container can generate a certificate that you can use for testing, but for production, you’ll need to get a Public Key certification from an “official” source such as VeriSign.
Certificates and security protocols like HTTPS and SSL are way outside the scope of the exam, by the way.
You’re expected to know only what you have to do in the DD, and why.
You’re not expected to be the sys-admin and network security master.
Configure the security aspects of a web application by filling in the three blocks in the DD.
You want anyone to be able to do a GET on the resources within the Beer/UpdateRecipes directory (including any subdirectories), but you want ONLY those with the security role of “Admin” to be able to do a POST on resources within that directory.
Also, you want the data to be protected so that nobody can eavesdrop.
Sharpen your pencil Fill out the following table by writing in the relevant DD elements.
You want to constrain everything with a “.do” extension so that all clients can do a GET, but only Members can do a POST.
You do NOT need to include the DD elements needed to configure login information.
You want to constrain everything within the foo/bar directory so that only those with a security role of Admin can invoke ANY HTTP methods on those resources.
You do NOT need to include the DD elements needed to configure login information.
You want everyone to be able to do a GET on the resources within the Beer/UpdateRecipes directory (including any subdirectories), but you want ONLY those with the security role of “Admin” to be able to do a POST on resources within that directory.
Also, you want the data to be protected so that nobody can eavesdrop.
If you didn’t specify ANY <auth-constraint>, EVERYONE would be able to do a POST.
Putting in Admin means that only Admin can access the combination of the URL pattern and the HTTP Method.
You could have said INTEGRAL here and for virtually all Containers, you’d still get confidentiality, because Containers use SSL for their transport guarantee (although that’s not guaranteed by the spec)
You want to constrain everything with a “.do” extension so that all clients can do a GET, but only Members can do a POST.
You want to constrain everything within the foo/bar directory so that only those with a security role of Admin can invoke any HTTP methods on those resources.
We left off <httpmethod> so that ALL HTTP Methods are constrained to be accessible only to those in the Admin role.
We used the extension URL pattern that always starts with an asterisk (*)
Verifying that a specific user is allowed access to a specific HTML page.
Ensuring that an eavesdropper can’t read an HTTP message being sent from the client to the container.
Verifying that a client making a request for a constrained JSP has the proper role credentials to access the JSP.
Ensuring that a hacker can’t alter the contents of  an HTTP message while it is in transit from the container to a client.
Which authentication mechanism is recommended to be used only if  cookies or SSL session tracking is in place?
Authorization operates completely within the container once authentication has occurred.
Authentication can affect the transport layer based on how the <auth-method> element is set.
Verifying that a specific user is allowed access to a specific HTML page.
Ensuring that an eavesdropper can’t read an HTTP message being sent from the client to the container.
Verifying that a client making a request for a constrained JSP has the proper role credentials to access the JSP.
Ensuring that a hacker can’t alter the contents of  an HTTP message while it is in transit from the container to a client.
This would typically be accomplished through the use of HTTPS.
Option F is correct, the user’s password must be stored in a field called j_password.
In addition, the user’s name must be stored in j_username.
For form based authentication to work, the action of the login form must be j_security_check.
The isUserInRole method can be used programatically, to help determine whether a client’s role is authorized to access a given resource.
Which authentication mechanism is recommended to be used only if  cookies or SSL session tracking is in place?
Form based login session tracking can be difficult to implement, therefore a separate session tracking mechanism is recommended.
The getRemoteUser method can be used programatically, to help determine whether a client has been authenticated.
And if you can intercept the request, you can also control the response.
It never knows that someone stepped in between the client request.
Filters may be the most powerful web app development tool you have.
Do not even THINK about trying to talk to the master.
I control what goes to the master, and I control what comes from.
Describe the Web Container request processing model; write and configure a filter; create a request or response wrapper; and given a design problem, describe how to apply a filter or wrapper.
Given a scenario description with a list of issues, select a pattern that would solve the issues.
Filters, which are covered in this chapter, are an example of  (imagine this) the Intercepting Filter pattern.
We don’t cover pattern-specific info until the Patterns chapter, but it’s in THIS chapter where you actually see a design that demonstrates the Intercepting Filter pattern.
Enhancing the entire web application Sometimes you need to enhance your system in ways that span many different use cases or requests.
For example, you might want to keep track of  your system’s response times, across all of  its different user interactions.
I sure don’t want to go modify a bunch of.
How about some kind of “filter”? Filters are Java components—very similar to servlets—that you can use to intercept and process requests before they are sent to the servlet, or to process responses after the servlet has completed, but before the response goes back to the client.
The Container decides when to invoke your filters based on declarations in the DD.
In the DD, the deployer maps which filters will be called for which request URL patterns.
So it’s the deployer, not the programmer, who decides which subset of  requests or responses should be processed by which filters.
Filter The servlet was never changed, and has no knowledge of the filters.
And coming out of the filter and being passed to the servlet.
Filters are modular, and configurable in the DD Filters can be chained together, to run one after the other.
A filter doesn’t care which (if  any) filters ran before it did,  and it doesn’t care which one will run next.*
The DD controls the order in which filters run; we’ll talk about filter DD configuration a little later in the chapter.
The deployer often does need to configure the order based on the consequences of  the transformations performed by the filters.
You wouldn’t, for example, add a watermark to an image after you applied a compression filter.
In that example, the watermark filter would have to do its thing before the data hits the compression filter.
The point is, you as the programmer will not build dependencies into your code.
Three ways filters are like servlets Kim’s right, filters live in the Container.
Here are a few ways in which filters are like servlets:
If filters are like servlets, then I’m guessing they must be invoked by the Container, just like servlets.
When a Java class implements the Filter interface, it’s striking a deal with the Container, and it goes from being a plain old class to being an official J2EE Filter.
Other members of  the filter API allow filters to get access to the ServletContext, and to be linked to other filters.
Similar to a servlet’s doGet()/doPost() method, filters have a doFilter() method.
A web app can have lots of  filters, and a given request can cause more than one filter to execute.
The DD is the place where you declare which filters will run in response to which requests, and in which order.
Building the request tracking  filter Our task is to enhance the Beer application so that whenever someone requests any of  the resources associated with updating recipes, we’ll be able to keep track of  who made the request.
Here’s one version of  what such a filter might look like.
You must implement init(), usually you just save the config object.
But we’re pretty sure that we can cast the request and response to their HTTP subtypes.
This is how the next filter or servlet in line gets called - lots more on this in the next couple of pages.
Filters have no idea who’s going to call them or who’s next in line!
A filter’s life cycle Every filter must implement the three methods in the Filter interface: init(), doFilter(), and destroy()
When the Container decides to instantiate a filter, the init() method is your chance to do any set-up tasks before the filter is called.
The most common implementation was shown on the previous page; saving a reference to the FilterConfig object for later use in the filter.
When the Container decides to remove a filter instance, it calls the destroy() method, giving you a chance to do any cleanup you need to do before the instance is destroyed.
The doFilter() method is called every time the Container determines that the filter should be applied to the current request.
The doFilter() method is your chance to implement your filter’s function.
If  your filter is supposed to log user names to a file, do it in doFilter()
Want to compress the response output? Do it in doFilter()
Filters are designed to be modular building blocks you can mix together in a variety of ways to make a combination of things happen, and the FilterChain is a big part of what makes this possible.
We already mentioned that the filters (not to mention the servlet) shouldn’t know anything about the other filters involved in the request...
By the way, FilterChain is in the same package as Filter, javax.servlet.
What’s a doFilter() doing inside a doFilter()?  You’re not gonna get all recursive on us, are you?
A: The FilterChain interface’s doFilter() is a little bit different than the Filter interface’s doFilter()
The doFilter() method of the FilterChain takes care of figuring out whose doFilter() method to invoke next (or, if it’s the end of the chain, which servlet’s service() method)
This means a FilterChain can invoke EITHER a filter or a servlet, depending on whether it’s the end of the chain.
The end of the chain is always either a servlet or a JSP (which means a JSP’s generated servlet, of course), assuming the Container is able to map the request URL to a servlet or JSP.
If the Container can’t locate the right resource for the request, the filter is never invoked.
In practice, though, you can think of  the process of  filters chaining to each other as if  they were simply method calls on a single stack.
We know there’s more going on behind the scenes in the Container, but we don’t care, as long as we can predict how our filters will run, and a conceptual  (if  not physical) stack lets us do that.
Upon getting the request, the Container calls Filter3’s doFilter() method, which runs until it encounters its chain.doFilter() call.
The Container pushes Filter7’s doFilter() method on the top of the stack - where it executes until it reaches its chain.
The Container pushes ServletA’s service() method on the top of the stack where it executes to completion, and is then popped off the stack.
The Container returns control to Filter7, where its doFilter() method completes and is then popped off.
The Container returns control to Filter3, where its doFilter() method completes, and is popped off.
This “conceptual stack” is just a way to think about filter chain invocations.
We don’t know (or care) how the Container actually implements this—but thinking of it this way lets you predict how your filter chain will behave.
Declaring and ordering filters When you configure filters in the DD, you’ll usually do three things:
IMPORTANT: The Container’s rules for ordering filters: When more than one filter is mapped to a given resource, the Container uses the following rules:
This is NOT the same as the URL mapping rules the Container uses to choose the “winner” when a client makes a request for a resource, because ALL filters that match will be placed in the chain!! Filters with matching URL patterns are placed in the chain in the order in which they are declared in the DD.
Once all filters with matching URLs are placed in the chain, the Container does the same thing with filters that have a matching <servlet-name> in the DD.
It’s great that filters can be applied to requests that come directly from the client.
But what about resources requested from a forward or include, request dispatch, and/or the error handler? Servlet spec 2.4 to the rescue.
News Flash:  As of version 2.4, filters can be applied to request dispatchers.
If no <dispatcher> element is present, REQUEST is the default.
Based on the following DD fragment, write down the sequence in which the filters will be executed for each request path.
My boss liked my first filter so much he wants me to write another one.
Seems like a filter would be the way to go...
But since we’re dealing with responses, I’ll have to put the.
Compressing output with a response-side filter Earlier we showed a very simple request  filter.
Response filters are a bit trickier, but they can be incredibly useful.
They let us do something to the response output after the servlet does its thing, but before the response is sent to the client.
So instead of  stepping in at the beginning—before the servlet gets the request—we step in at the end—after the servlet gets the request and generates a response.
Filters are always invoked in the chain before the servlet.
There’s no such thing as a filter that is invoked only after the servlet.
The filter gets another shot at this after the servlet completes its work and is popped off  the (virtual) stack!
Now that the servlet is done, we can get to work on compressing the response the servlet generated...
It’s too early to do any compression—the goal is to compress the response output from the servlet.
The Servlet’s service() method goes on the top of the stack, does some work, generates a response output, and completes.
Now that the Servlet’s service() method has popped off the stack, the rest of the compression filter’s doFilter() method can run, and (it hopes) do the compression on whatever the servlet wrote to the response output!
The fi lter passes the request and response to the servlet, and waits patiently for its chance to compress stuff.
The fi lter was hoping to have a chance to do something to the output (compress it) before the output went to the client.
The call to chain.doFilter() has returned, and the fi lter was hoping to grab the output and and start compressing...
By the time the fi lter’s own doFilter() method is at the top of the (conceptual) stack, it’s too late for the ﬁ lter to affect the output.
But is it really that simple? Does compressing the response really involve nothing more than waiting for the servlet to finish, then compressing the servlet’s response output? After all, the filter’s doFilter() method has a reference to the same response object that went to the servlet, so in theory, the filter should have access to the response output...
This won’t work! I can’t compress something on the way.
The output goes straight from the servlet back to the client.
And that custom implementation has to also include a custom output stream as well, since that’s the goal—to capture the output after the servlet writes to it but before it goes back to the client.
The “MyResponse” object delegates (passes-through), most of the calls it receives, to the “real” response object.
The “MyResponse” object also has a custom output stream that compresses the data written by the servlet, and then sends the compressed data to the original output stream (that goes back to the client)
A:  Filters were designed to be generic, and so officially, you’re right.
If we thought one of our filters might be used in a non-web app, we’d be implementing the non-HTTP interface (ServletResponse), but today, the chances of someone developing non-HTTP servlets is close to zero, so we’re not worried.
Especially when all you want to implement are just a few of  the methods.
All of  the methods in that class delegate the calls to the underlying real response created by the Container.
Creating a specialized version of  a request or response is such a common approach when creating filters, that Sun has created four “convenience” classes to make the job easier:
Whenever you want to create a custom request or response object, just subclass one of the convenience request or response “wrapper” classes.
A wrapper wraps the REAL request or response object, and delegates (passes through) calls to the real thing, while still letting you do the extra things you need for your custom request or response.
Wrappers rock The wrapper classes in the servlet API are awesome—they implement all the methods needed for the thing you’re trying to wrap, delegating all calls to the underlying request or response object.
All you need to do is extend one of  the wrappers, and override just the methods you need to do your custom work.
You’ve seen support classes in the J2SE API, of  course, with things like the Listener adapter classes for GUIs.
And you’ve seen them in the JSP API with the custom tag support classes.
But while those support classes and these request and response wrappers are all convenience classes, the wrappers are a little different because they, well, wrap an object of  the type they implement.
In other words, they don’t just provide an interface implementation, they actually hold a reference to an object of the same interface type to which they delegate method calls.
By the way, this has nothing whatsoever to do with the J2SE.
It’s like saying, “I’m just a BETTE R version of the thing I’m wrapping—I do everything it does, and more.”  One characteristic of a.
Decorator/Wrapper is that it deleg ates method invocations to the.
Adding a simple Wrapper to the design Let’s enhance Rachel’s first pseudo-code by adding a wrapper.
The act of “wrapping” the response with our custom Wrapper class.
We’ll be doing some real overriding in a few pages!
None of the components down the chain will ever know that the response object they got was a custom job.
The fi lter passes the request object and a custom response object to the servlet.
Since we didn’t override any methods in the Wrapper, the output stream isn’t affected...
The fi lter passes the request object and a custom response object to the servlet.
When the servlet asks for an output stream, it doesn’t KNOW that it will get a “special” output stream.WRAPPED.
Add an output stream Wrapper Let’s add a second Wrapper...
Compression fi lter design, version 3 (pseudocode) Override this method to return.
The init method saves the config object and a quick reference to the servlet context object (for logging purposes)
The heart of this filter wraps the response object with a Decorator that wraps the output stream with a compression I/O stream.
Compression of the output stream is performed if and only if the client includes an AcceptEncoding header (specifically, for gzip)
If so, wrap the response object with a compression wrapper.
We end this chapter by looking at the code for both the compression filter and the wrapper it uses.
We’re expanding from the previous discussion, and while there is some new stuff  here, it’s mostly just plain Java code.
This filter provides a mechanism to compress the response body content.
This type of  filter would commonly be applied to any text content such as HTML, but not to most media formats such as PNG or MPEG, because they are already compressed.
You don’t need to study this code for the exam.The rest of this example is a demonstration of a response fi lter in action, just so that you can see something a little more real-world.
You don’t need to learn or understand this particular example for the exam, so consider the rest of this chapter completely optional.
A GZIP compression stream must be “finished”, which also flushes the GZIP stream buffer, and sends all of its data to the original response stream.
Debugging Tip! To test this filter, comment out this line of  code.
Compression wrapper code We looked at the Compression filter; now let’s take a look at the wrapper it uses.
This is one of  the most complicated topics in all of servlet-dom, so don’t panic if  you don’t grok it the first time.
This response wrapper decorates the original response object by adding a compression decorator on the original servlet output stream.
The super constructor performs the Decorator responsibility of storing a reference to the object being decorated, in this case the HTTP response object.
This decorator method, used by the filter, gives the compression filter a handle on the GZIP output stream so that the filter can “finish” and flush the GZIP stream.
Allow the servlet to access a servlet output stream, only if the servlet has not already accessed the print writer.
Wrap the original servlet output stream with our compression servlet output stream.
To make a print writer, we have to first wrap the servlet output stream and then wrap the compression servlet output stream in two additional output stream decorators: OutputStreamWriter which converts characters into bytes, and then a PrintWriter on top of the OutputStreamWriter object.
Allow the servlet to access a print writer, only if the servlet has not already accessed the servlet output stream.
This instance variable is package-private to allow the compression response wrapper access to this variable.
Write down the sequence in which the filters will be executed for each request path.
Filter chain order is always determined by the order the elements appear in the DD.
A class that extends an API request or response wrapper class must be declared in the DD.
A class that extends an API request or response wrapper class is using the Intercepting Filter pattern.
A filter can act on only the request or response object, not both.
The only way a filter can be invoked is through a declaration in the DD.
The next filter in a filter chain can be specified either by the previous filter or in the DD.
An exception will always be thrown if  line 31 executes.
Line 28 is invalid because request must be passed as the first argument.
The file is invalid because the URL pattern /my is mapped to both a servlet and a filter.
The file is invalid because neither the servlet name nor the filter name is allowed to contain spaces.
The filter MyFilter will be invoked after the MyServlet servlet for each request that matches the pattern /my.
The filter MyFilter will be invoked before the MyServlet servlet for each request that matches the pattern /my.
Filters may be used to create request or response wrappers.
Wrappers may be used to create request or response filters.
Unlike servlets, all filter initialization code should be placed in the constructor since there is no init() method.
Filters support an initialization mechanism that includes an init() method that is guaranteed to be called before the filter is used to handle requests.
A filter’s doFilter() method must call doFilter() on the input FilterChain object in order to ensure that all filters have a chance to execute.
When calling doFilter() on the input FilterChain, a filter’s doFilter() method must pass in the same ServletRequest and ServletResponse objects that were passed into it.
They can be used to decorate classes that implement Filter.
They can be used even when the application does NOT support HTTP.
When you subclass a wrapper class, you must override at least one of  the wrapper class’s methods.
Filter chain order is always determined by the order the elements appear in the DD.
A class that extends an API request or response wrapper class must be declared in the DD.
A class that extends an API request or response wrapper class is using the Intercepting Filter pattern.
A filter can act on only the request or response object, not both.
The only way a filter can be invoked is through a declaration in the DD.
The next filter in a filter chain can be specified either by the previous filter or in the DD.
Option C is incorrect, doFilter is both a callback and an inline method.
Option D is incorrect, wrappers are examples of the Decorator pattern.
An exception will always be thrown if  line 31 executes.
Line 28 is invalid because request must be passed as the first argument.
Option D is incorrect because the method signature is correct.
Option  B is incorrect because it is valid for a filter to wrap a request (note that UserRequest must implement ServletRequest)
Option C is incorrect because the doFilter method is NOT required to call chain.doFilter()
The file is invalid because the URL pattern /my is mapped to both a servlet and a filter.
The file is invalid because neither the servlet name nor the filter name is allowed to contain spaces.
The filter MyFilter will be invoked after the MyServlet servlet for each request that matches the pattern /my.
The filter MyFilter will be invoked before the MyServlet servlet for each request that matches the pattern /my.
Option A is incorrect because this is proper syntax used to map a filter to the same pattern as a servlet.
Option B is incorrect because there is no such restriction.
Option C is incorrect because filters are executed before servlets, not after.
Filters may be used to create request or response wrappers.
Wrappers may be used to create request or response filters.
Unlike servlets, all filter initialization code should be placed in the constructor since there is no init() method.
Filters support an initialization mechanism that includes an init() method that is guaranteed to be called before the filter is used to handle requests.
A filter’s doFilter() method must call doFilter() on the input FilterChain object in order to ensure that all filters have a chance to execute.
When calling doFilter() on the input FilterChain, a filter’s doFilter() method must pass in the same ServletRequest and ServletResponse objects that were passed into it.
Option C is incorrect because there is an init() method that should be used for filter initialization.
Option E is incorrect because calling doFilter() is not necessary if a filter wishes to block further request processing.
Option F is incorrect because the filter may choose to “wrap” the request or the response object and pass those instead.
They can be used to decorate classes that implement Filter.
They can be used even when the application does NOT support HTTP.
When you subclass a wrapper class, you must override at least one of  the wrapper class’s methods.
Option A is incorrect because you can create your own wrapper class.
Option B is incorrect because these classes are used to wrap requests and responses.
Option D is incorrect because the API does NOT provide a FilterChain wrapper.
Option E is incorrect because these wrappers implement the Decorator pattern..
If you’re just starting to develop web applications in Java, you’re lucky.
Using both J2EE-specifi c and other design patterns, you can can simplify.
I heard that he did not use J2EE patterns, and the punishment for that will be severe.
Can you believe that? Right there in a doPost method...
The objectives in this section are covered completely in this chapter.
The exam questions on patterns are the least tricky of  all the possible questions you’ll see on the exam, so you can almost relax in this section.
If  you’re already familiar with the fundamental enterprise design patterns, you can probably answer the exam questions on patterns.
And although Struts is not on the exam, this chapter also includes an introduction to Struts, currently the most commonly-used framework for an MVC web application.
A popular web site can get hundreds of  thousands of  hits per day.
To handle this kind of volume, most big web sites create complex hardware architectures in which the software and data is distributed across many machines.
A common architecture you’re probably quite familiar with is configuring the hardware in layers or “tiers” of  functionality.
Adding more computers to a tier is known as horizontal scaling, and is considered one of  the best ways to increase throughput.
As a web site gets more hits, more servers can be added to handle the load.
Most of the software for a big web application lives in either the “Web Tier” or the “Business Tier”
Web application software can get complicated As we’ve seen, it’s very common for a web application to be made up of many different kinds of  software components.
The web tier frequently contains HTML pages, JSPs, servlets, controllers, model components, images, and so on.
The business tier can contain EJBs, legacy applications, lookup registries, and in most cases database drivers, and databases.
How am I going to keep all this stuff organized? What if the requirements.
They found reoccuring themes in the nature of  the problems they were dealing with, and they came up with reusable solutions to these problems.
These design patterns have been used, tested, and refined by other developers, so you don’t have to reinvent the wheel.
What are the “ilities”? What are some of the important non-functional requirements of a system you’ve worked on (or could imagine working on)? One clue is that most of the requirements words end with “ility” (for example, “maintainability”)
Common pressures The most important job for a web app is to provide the end user with a reliable, useful, and correct experience.
In other words, the program must satisfy the functional requirements  such as “select a beer style” or “add malt to my shopping cart”
A software design pattern is “a repeatable solution for a commonly-occuring software problem.”
Performance (and the “ilities”) Here are three of  the most important non-functional requirements you’re likely to face:
If  your website is too slow, you’ll (obviously) lose users.
In this chapter, we’ll look at how patterns can help an individual user experience faster response time, and how patterns can help your system support a greater number of  simultaneous users (throughput)
In order for different pieces of  your application to run on different boxes at the same time, your software is going to have to be modular...
Flexibility:  You need to change your system without going through some big development cycle.
You might need to swap in the “limited time, special offer” components for a big sale.
You might find a bug in a new component and need to swap in the older component temporarily.
Maintainability:  You might need to change database vendors, and update your system quickly.
You might get obscure bugs and need to track them down ASAP.
The admins might decide to restructure the company’s naming service, and you’ll have to adjust—right now! You need your system to be maintainable.
Extensibility:  The guys over in marketing might need a new feature to land that big client.
Your users might demand that you support a brand new feature that their browsers have.
If J2EE patterns can help me solve all of these issues, I’ll be.
All of  the J2EE patterns rely heavily on common software design principles you’re probably very familiar with.
In the next few pages, we fling around several terms for these design principles.
Different people and books might have different perspectives on the same terms, so we’re giving you our definitions now, so that you’ll know what we mean.
Code to interfaces As you recall, an interface is a kind of  a contract between two objects.
When a class implements an interface, it’s saying in effect: “My objects can speak your language.” Another huge benefit of  interfaces is polymorphism.
The calling object doesn’t care who it’s talking to as long as the contract is upheld.
For example, the web container can use any component that implements the Servlet interface.
Separation of Concerns & Cohesion We all know that when we specialize the capabilities of  our software components, they get easier to create, maintain, and reuse.
A natural fallout of  separating concerns is that cohesion tends to increase.
Cohesion means the degree to which a class is designed for one, cohesive, task or purpose.
Hide Complexity Hiding complexity often goes hand in hand with separating concerns.
For instance if  your system needs to communicate with a lookup service, it’s best to hide the complexity of  that operation in a single component, and allow all the other components that need access to the lookup service to use that specialized component.
This approach simplifies all of the system components that are involved.
Loose Coupling By their very nature, OO systems involve objects talking to each other.
By coding to interfaces, you can reduce the number of  things that one class needs to know about another class to communicate with it.
The less two classes know about each other, the more loosely coupled they are to each other.
A very common approach when class A wants to use methods in class B is to create an interface between the two.
Once class B implements this interface, class A can use class B via the interface.
This is useful, because later on you can use an updated class B or even an entirely different class, as long as it upholds the contract of  the interface.
Remote Proxy Today, when a web site grows, the answer is to lash together more servers, as opposed to upgrading a single, huge, monolithic server.
The outcome is that Java objects on different machines, in their own separate heaps, have to communicate with each other.
Leveraging the power of  interfaces, a remote proxy is an object local to the “client” object that pretends to be a remote object.
The proxy is remote in that it is remote from the object it is emulating.
The client object communicates with the proxy, and the proxy handles all the networking complexities of  communicating with the actual.
As far as the client object is concerned, it’s talking to a local object.
Most commonly, this declarative control is implemented using  the application’s deployment descriptor (or DD)
Modifying the DD gives us the power to change system behaviors without changing code.
The DD is an XML file that can be maintained and updated by non-programmers.
The more that we write our web applications to leverage the power of  the DD, the more abstract and generic our code becomes.
Patterns to support remote model components We’ve talked at a very theoretical level about how J2EE patterns can help simplify complex web applications.
We’ve also talked about the software design principles that underlie J2EE patterns.
With that foundation in place, let’s get our feet wet by talking about a few of  the simpler J2EE patterns.
All three of  the patterns we’re about to discuss share the goal of  making remote model components manageable.
A Fable:  The Beer App Grows Once upon a time there was a small dot com that had a website that offered home brewing recipes, advice, ingredients and supplies for beer aficionados.
Being a small company (with big plans), they had only one production server to support the site, but they had created two separate software development teams to grow the application.
The first team, known as the “Web Designers” focused their attentions on the view components of  the system.
The second team, known as the “Business Team” focused on the controller components (Rachel’s focus), and the model components (Kim’s area)
Don’t bother us with your business tier issues—we’re creating art.
How the Business Team supports the web designers when the MVC components are running on one JVM As long as the business guys keep the interfaces to their model components consistent, everyone will be happy.
Having received a request for customer information, the Controller calls the ManageCustomer service component (a Model)
The service component does a JDBC call to the legacy database, then creates a Customer bean (this is NOT an EJB, just a plain old JavaBean), populated with customer data from the database.
Customer bean reference to the request object, as an attribute.
The JSP gets the reference to the Customer bean from the request object.
The View JSP uses EL to get the Customer Bean properties it needs to satisfy the original request.
The web designer’s need is for this interface to be stable.
In other words, how to find remote objects, and how to invoke their methods.
If  you’ve got objects that you want other programs on your network to find and access, you register your objects with JNDI.
When some other program wants to use your objects, that program uses JNDI to look them up.
Once you’ve relocated a component, all you need to do is tell JNDI the new location.
That way, other client component only need to know how to find JNDI, without knowing where the objects registered with JNDI are actually located.
So, we have to move some of our model components off.
Turn the page and we’ll do a quick refresh, in case you’re a little rusty.
Why think about RMI here? Because it will help make two of  the J2EE design patterns easier to understand and appreciate.
How will they handle remote objects? Things are fairly simple when all the web app components (model, view, controller) are on the same server, running in the same JVM.
It’s just plain old Java—get a reference, call a method.
But Kim and Rachel now have to figure out what to do when their model components are remote to the web app.
That’s what RMI gives youthe ability to pretend (almost) that you’re making a regular old local method call.
I just want to call a method on this object, you know, a.
I’m happy to do a little extra work up front.
How RMI pulls it off Let’s say your “business guy” hat is on, and you want to make an object available to remote clients.
Using RMI, you’ll create a proxy and you’ll register your object with some sort of registry.
Any client who wants to call your methods will do a lookup on the registry and get a copy of  the remote proxy.
Then the client will make calls on the remote proxy, pretending it’s the real thing.
The remote proxy (called a stub), handles all the communications details like sockets, I/O streams, TCP/IP,  serializing and deserializing method arguments and return values, handling exceptions, and so forth.
Oh, by the way, there’s usually a proxy on the server side (often called a “skeleton”), doing similar chores on the server side where the remote object lives.
There are 3 versions of getCustData()! The remote proxy’s, the skeleton’s and the server’s, which is the real one.
Just a little more RMI review Without doing an entire RMI tutorial,* we’ll look at a few more high level RMI topics to make sure we’re all talking the same talk.
Specifically, we’ll look at the server side and client side of  using RMI.
The client side, with and without RMI Let’s compare the pseudo-code of  a client using RMI to the pseudo-code of  a client NOT using RMI.
This is where the signature for methods like getCustData() will reside.
Both the stub (proxy) and the actual model service (the remote object) will implement this interface.
Create the remote implementation, in other words, the actual model object that will reside on the model server.
This includes code that registers the model with a well-known registry service such as JNDI or the RMI registry.
Start/run the model service (which will register itself  with the registry and wait for calls from far-away clients)
If you aren’t really familiar with RMI, drive to your local bookstore, pick up (but don’t buy) a copy of Head First Java, and just read the sections on RMI.
Then put the book back on the shelf, face forward, in front of the competing book of your choice.
Make sure that the cover is dusted and don’t spill coffee on it.
Let’s focus on what we need to do to keep Rachel’s life as simple as possible.
In other words, what impact does adding JNDI and RMI have on the controller?
Kim, the model guy, registers his model component with the JNDI service.
When Rachel’s controller gets a request, the controller code does a JNDI lookup to get the stub proxy for Kim’s remote model service.
The controller makes business method calls against the stub, just as though the stub were the actual model object iself.
Sure, the method calls are pretty close to what I was doing before when the model was local, but I still have to change.
I was hoping for something that would let me use the same Controller regardless of.
How can this design be improved? 1 - What are the problems with this design (list at least two)?
How might you change this design to handle those problems?
A common solution to the design problems we left you with is to create a new object—a single, “go-between” object for the controller to talk to rather than having the controller deal directly with the remoteness of  the remote model.
If  Rachel’s controller lets a “go-between” object handle the JNDI lookup, the controller code can stay simpler, free from having to know where (and how) to look up the model.
If  the “go-between” object can handle talking to the stub, Rachels’ controller can be shielded from all the remote issues including remote exceptions.
The “go-between” is a  Business Delegate Let’s take a look at the pseudo-code for a typical Business Delegate, and at how Business Delegates tend to be deployed in the web container.
Notice that there will be LOTS of  Business Delegates on the web tier.
Legions of Business Delegates on the web server (one per remote model)
Describe where the duplicate code exists and how you could solve that problem.
Unless your Business Delegates use a Service Locator, they will have duplicate code for dealing with the lookup service.
To implement a Service Locator, we’ll take all of  the logic for doing the JNDI lookup and move it out of  the multiple Business Delegates and into a single Service Locator.
Typically in J2EE applications, there will be a number of components that all use the same JNDI service.
While a complex application might use several different registries such as JNDI and UDDI (for web service endpoints), an individual component will typically need access to only one registry.
In general, a single Service Locator will support a single, specific registry.
By making the Business Delegate an object that handles only the business methods rather than also handling the registry lookup code, you increase the cohesion for the Business Delegates.
Moving the registry affects only the single Service Locator object.
Obtaining the stub is now handled by the Service Locator.
All the Delegate has to do is deal with business methods on the stub.
Q: Separation of concerns buys me...? A: Let’s take the Service Locator as an example.
In the event that your registry gets a new network address and/or registry interface, it’s far easier to modify a single Service Locator than change a whole flotilla of Business Delegates.
In general, separation of concerns buys us a lot of flexibility and maintainability.
Q: In your examples so far, you’ve taken POJOs that were local, and made them remote.
Isn’t it more likely that I’ll be faced with integrating existing EJBs into my web app?
And yes, it is likely that you’ll be integrating EJBs into your app.
And in fact that’s yet another reason to use these two patterns...
Without using ServiceLocator and Business Delegate, that difference means a lotenterprise beans and plain old remote objects don’t use the same lookup code!
Using these patterns, you can encapsulate the issues related to how and where the model is discovered and used, and keep the controller happy and clueless, so that you won’t have to change your controller code when the business guys change things and move things around on the business tier.
Q: This whole discussion has assumed RMI; what if our company is using CORBA?
A: All of the patterns we’re discussing can be implemented more or less independently of J2EE technologies.
Admittedly, they will be easiest to implement in J2EE, but they do apply to other situations.
Q: Is the same thing true for JNDI? A: Well, there are other Java-related registries besides JNDI—RMI and Jini come to mind.
Of those three, JNDI is probably the best choice for most web apps, it’s easy and powerful.
Although the authors would personally love to see Jini take its rightful place in the distributed world.
You might also be dealing with non-Java registries like UDDI.
In any case, the patterns will still work, even though the code changes, of course.
Q: It seems like these patterns are forever adding a new layer of objects to the architecture.
A: You’re right that this is a common part of a lot of patterns.
Assuming that your design is good, think about the software design benefits inherent in this approach...
A: Right!  Both the Business Delegate and the Service Locator increase the cohesiveness of the objects they support.
Adding a layer often shields existing objects from being network aware.
Then of course, closely related to cohesion is separation of concerns.
Protecting the web designer’s JSPs from remote model complexity By using the Business Delegate and Service Locator patterns, we’ve got Rachel’s controllers protected from the complexities of remote model components.
Now let’s see if  we can do the same for the web designer’s JSPs.
Having received a request for customer information, the Controller calls the ManageCustomer model component.
The model component does a remote call to the legacy database, then creates a Customer bean, populated with customer data from the database.
The JSP gets a reference to the Customer bean from the request object.
The View JSP uses EL to get the Customer Bean properties it needs to satisfy the original request.
Quick review of the old non-remote way— the JSP uses EL to get info from the local model.
This diagram should look familiar from earlier in the chapter.
Use the Business Delegate and the stub to get the “Customer Bean”, which in this case is another stub.
The JSP gets a reference to the Customer bean (stub) from the request object.
The View JSP uses EL to get the Customer Bean properties it needs to satisfy the original request.
Compare the local model diagram to this remote model diagram The shaded area in this diagram should look a LOT like the previous diagram, especially if  you remember that the Business Delegate is pretending to be the Manage Customer model.
Each network call is 1000 times as expensive as a local method call!
The previous architecture succeeds in hiding complexity from both the controllers and the JSPs.
And it makes good use of  the Business Delegate and Service Locator patterns.
When it’s time for the JSP to get data, there are two problems, both related to the fact that the bean the JSP is dealing with is actually a stub to a remote object.
All those fine-grained network calls are likely to be a big performance hit.
Not only is this a bandwidth/latency issue, but all those calls cause the server some problems too.
The JSP is NOT a good place to be handling exceptions that might occur if  the remote server crashes.
Why not have the JSP talk to a plain old bean instead of a stub?
Q: If you want the JSP to talk to a JavaBean, where will this bean come from?
A: Well, it used to come from the local model/service object, so why not have it come from the remote model/ service object?
Q: How do you get a bean across the network? A: Hey, as long as it’s serializable, RMI has no problem sending an object across the network.
Q: So what would this buy us again? A: First of all, we’d have one big network call instead of a lot of little ones.
Second, since the JSP would be talking to a local object, there’d be no remote exceptions to worry about!
Or maybe a big problem—if you’re using a bean on the client side, doesn’t that bean’s data become stale the moment it’s sent?
A: Yes, you’re right, and this IS a trade-off: performance vs.
You have to decide which makes sense based on your requirements.
If the data used by your view component must absolutely, positively, represent the current state of the database at all times, then you need a remote reference.
For example, if you make three calls, say, getName(), getAddress(), and getPhone() on customer, you’ll probably decide that this information doesn’t change rapidly enough to make it worth going back to the database (via the remote object) just in case the customer’s phone number changed IN BETWEEN the call to getName() and getAddress()
On the other hand, you might decide that in a highly dynamic environment, where a customer is making transactions 24/7, you DO need to show the most up-todate info.
Sending a JavaBean back for the client means the View would have a snapshot of the database at the moment the bean was populated, but since the bean has no connection to the database, the data begins to go stale immediately.
If  it’s likely that a business service might be asked to send or receive all or most of its data in a big, coarse-grained message, it’s common for that service to provide that feature in its API.
Commonly, the business service creates a serializable Java object that contains lots of  instance variables.
Under the covers, the Transfer Object is serialized, shipped, and deserialized on to the client’s local JVM heap.
At that point, it is just like any other local bean.
Catch remote exceptions and wrap them in a higher level exception.
Listen in as our two black-belts debate which pattern is better—Service Locator or Business Delegate.
First of  all, unlike the Business Delegate, one Service Locator instance can support an entire application tier.
It can cache references to stubs or service stubs once it has located them, reducing network traffic for subsequent calls.
Heavy burden?  Your simple business data does not impress me.
Ah, maybe programmers do benefit, but your simple pattern seems to forget that it often exists in a network environment.
It will make many calls to business services with no restraint, no consideration for the overhead of  remote calls.
Yes, yes, your weak pattern needs assistance, we all know that.
But when you partner with a Transfer Object other demons can haunt you...
That’s true, but Service Locator needs to talk to only one remote entity.
With much respect, you are forgetting that Service Locator has a much easier task.
The Business Delegate must carry the heavy burden of communicating with a dynamic object, whose data might change at any moment.
A Business Delegate gives web application programmers much more benefit than your Service Locator.
Ah ha!  The Business Delegate is not ashamed to form an alliance with the Transfer Object!  Working as a team, they help the programmer AND minimize remote calls.
But when these issues come up they can be solved.
You cannot expect to achieve great things without a little extra effort...
Use the Business Delegate and the stub to get the “Customer Bean”, which in this case is a Transfer Object.
The JSP gets the reference to the Customer Transfer Object bean from the request object.
Transfer Object Bean’s properties it needs to satisfy the original request.
Business tier patterns: quick review To wrap up our discussion of  business tier patterns, here’s a diagram that shows a Business Delegate, a Service Locator, and a Transfer Object in action.
At the end of  the chapter you’ll find a couple of  summary pages for these patterns and the presentation tier patterns we’ll discuss next.
The last two patterns we’re covering are presentation tier patterns, as was the Intercepting Filter.
First we’ll pick up where we left off  talking about MVC.
That discussion will lead us into Struts and finally Front Controller.
Takes user input from the request and figures out what it means to the model.
Tells the model to update itself, makes the model state available for the view (the JSP) and forwards to the JSP.
It gets the state of the model from the Controller (although not directly; the Controller puts the model data in a place where the View can find it)
In other words, it knows the rules for getting and updating state.
A Shopping Cart’s contents (and the rules for what to do with it) would be part of the Model in MVC.
It’s the only part of the application that talks to the database.
In its first incarnation, MVC was a design to simplify complex GUI applications.
First created in Smalltalk, one of  MVC’s chief attributes was that the View would be notified automatically of  changes to the Model.
More recently, MVC has been used on the web, even though the View is in the browser and cannot be automatically updated when the Model changes in the web tier.
Our focus is entirely on the web version of  MVC.
Way back in chapter two, we left you with a “Flex your mind” exercise about potential problems with our Dating App MVC architecture.
Let’s review where we left off  and get around to answering the question that’s certainly been haunting you for all these chapters: what could possibly be better than MVC?
For each browser use case, there will be a corresponding set of  Model, View, and Controller components, which might be mixed and matched and recombined in many different ways from use case to uses case.
The problem we had in the dating app was that we had many specialized controllers, which sounded  good from an OO perspective, but left us with duplicate code across all the different controllers in our app, and didn’t give us a nice happy feeling about maintainability and flexibility.
And seriously, take a close look at that controller code.
A single MVC app will have many models, views, and controllers.
I hate the way my MVC app has so many.
Looking at the MVC controller Let’s see if  we agree with what’s been said about controllers.
What principles does this component violate? List three or more software design principles this pseudo-code violates.
Improving the MVC controllers Besides a lack of  cohesiveness, the controller is also tightly coupled to the model and the view components.
Give this task to a separate form validation component that can get the form parameters, convert them, validate them, handle validation errors, and create an object to hold the parameter values.
Why not make this declarative as well? That way, based on the request URL, the controller can tell (from our custom deployment descriptor) which view to dispatch to.
Designing our fantasy controller Let’s do another one of  our now-infamous architectural diagrams to see what this controller and its support components might look like.
Having received a request, the Controller locates the correct Form Validation Component in the Declarations XML fi le.
The Controller invokes the Form validator, sending  it the request.
If the validator fi nds any errors, it tells the controller which view to return.
Controller locates and invokes the Request Action Component component, which invokes the model.
Yes! It’s  Struts in a nutshell Obviously this is an overview, and we’ve left out pretty much all of  the details, but this is the basic idea behind the Struts framework.
Let’s look at a few more details, starting with the fact that we’ve changed all the names...
Action Servlet - You’ll need only one of  these per application.
Best of  all, you don’t even have to write it, Struts provides it.
Form Beans - You’ll write one of  these for each HTML form your app needs to process.
They are Java beans, and once the Struts Action Servlet has called the setters on the form bean (to populate the bean with form parameters), it will call the bean’s validate() method.
This is a great place to put data conversion and error handling logic.
Action Objects - Generally, an action maps to a single activity in a use-case.
It has a call-back-like method called execute(), which is a great place to get the validated form params, and call model components.
Think of  the Action object as kind of  a “servlet lite”
In it you’ll map: request URLs to Actions,  Actions to Form beans, and Actions to views.
Is Struts a container? Officially, Struts is considered a framework.
Frameworks are collections of  interfaces and classes that are designed to work together to handle a particular type of  problem.
In the case of  Struts, the problem space is web applications.
The goal of  a framework is to “aid programmers in the development and maintenance of  complex applications”
So, Struts isn’t a container, but in some ways it acts like one.
Declarative: They both use an XML file to configure the application declaratively.
Lifecycle: They both provide lifecycles for predetermined types of objects.
Callbacks: They both perform automatic callbacks of key lifecycle methods.
APIs: They both provide APIs for key types of objects that are supported.
Application Control: They both provide a controlled environment in which your application runs.
You ARE expected to know the purpose and function of a Front Controller (and Struts is just a tricked-out Front Controller), but you will not have any questions about the Struts framework.
So, you can relax and follow along without having to memorize every picky detail.
Front Controller is another J2EE pattern, and it just happens to be on the exam.
Actually, Struts is a really fancy example  of using a Front Controller pattern.
The basic idea of  the Front Controller pattern is that a single component, usually a servlet but possibly a JSP, acts as the single control point for the presentation tier of  a web application.
With the Front Controller pattern, all of  the app’s requests go through a single controller, which handles dispatching the request to the appropriate places.
In the real world, it’s rare to implement a Front Controller all by itself.
Even a really simple implementation usually includes another J2EE pattern called an Application Controller.
Struts includes a class called the RequestProcessor, which is ultimately responsible for the handling of  HTTP requests.
Although the exam might contain questions about the Front Controller pattern, you’ll be fine if  you remember the benefits of  Struts, and the fact that Struts is simply a Front Controller with all the bells and whistles.
ActionForward which tells the ActionServlet which view to dispatch to.
This provides another layer of abstraction (and loose coupling) between the controller and view components.
Declarative Validation: Struts provides a validation framework that removes the need to code the validate method in your form beans.
The rules for validating a form are configured in an XML file and can be changed without affecting your form bean code.
Global exception handling: Struts provides a declarative error handling mechanism similar to <error-page> in the DD.
However, with Struts the exceptions can be specific to the application code in your Action object.
Plug-ins: Struts provides a PlugIn interface with two methods: init() and destroy()
You can create your own plug-ins to enhance your Struts application, and they will be managed for you.
For example, the Validator framework is initialized using a plug-in.
Refactoring the Beer app for Struts Enough theory, let’s write a Struts app.
The only code that’s going to change when we refactor to Struts is related to the MVC controller.
Having received a request, the Controller performs validation of the user form data.
The Struts Beer app architecture Here’s the Beer app architecture, all done up in Struts...
ActionServlet locates the correct form bean using the struts-confi g.xml fi le.
If the form bean fi nds any errors, it populates an ActionErrors object.
ActionServlet locates and invokes the Action object, which invokes the model and returns an ActionForward object to the ActionServlet.
Having previously extracted the necessary mappings from struts-confi g.xml, the ActionServlet uses the ActionForward object to dispatch to the correct view component.
Well, OK, the view *will* change in a Struts web app.
For one thing, Struts provides a tag library that provides a tag, <html:errors/>, that displays the form bean validation errors.
Also, the HTML tag library provides tags that repopulate the form on an error.
A  form bean exposed Remember, the form bean’s job is to validate the user’s form params.
A nice benefit of Struts is that a validation step is built right into the architecture.
Usually, you’ll want your Form beans to have getters and setters for all of the form params.
The ActionError constructor takes a String that is a symbolic key into a resource bundle.
How an  Action object ticks The Action object is mainly a dispatcher.
It is invoked by the  ActionServlet, which calls the Action object’s execute() method.
Sent from the ActionServlet, so we can return the right view.
The execute method returns an ActionForward to the ActionServlet that directs Struts to dispatch to the next appropriate view.
Similar to the DD, this file is where you’ll declare and map Struts components in your web app.
The <forward> element creates a mapping between the symbolic view name, used by the Action object, and the physical path to the view component.
The <form-bean> element declares the symbolic name and class of a form bean object.
An <action> element maps the URL path to the controller class; notice that the .do extension for the path is NOT included in the Struts configuration.
The <action> also associates a form bean with the action.
Struts will create this bean and store it in the specified scope.
If validation occurs and errors are returned from the validate method, then the input attribute declares the View responsible for displaying the error message; this is usually the form that submitted this action.
Specifying Struts in the web.xml DD As far as the Container is concerned, the ActionServlet is just another servlet.
So, you have to declare it and make sure all of  the web app’s requests are mapped to it.
Naming the ActionServlet “FrontController” isn’t required, but it’ll help remind you of its purpose in the app.
The “config” init param tells the ActionServlet where to find the Struts config file.
Wow! This one servlet is going to handle ALL of this app’s requests (assuming you name the request URLs with a “.do” extension)
The ActionServlet has a complex init method; you better load this servlet at startup.
The links and versions mentioned on this page were current at the time of  this writing.
Which is no help at all for you, but means simply: we have no idea what things will be like by the time you read this, but we gave it our best shot anyway.
From the General Availability list, click on the latest Struts v1.3.* link:
Copy the five JAR files listed in step 5 to the webapp’s WEB-INF/lib/ directory:
FYI:  make sure that there is a copy of  Struts core JAR file in your classpath when you compile your form beans and action objects.
Remember, the ActionServlet front controller is created for you automatically.
This is the directory structure you will create to run the Struts version of  the Beer app.
You’ll create one of these if you want to internationalize the text displayed to your user.
Rather than hardcode error text or other Strings for display, you can use a resources properties file to provide key/value mappings, and in your JSP, you can invoke a special tag for the key, and the mapped text will be displayed.
Use the Business Delegate pattern to shield your web tier controllers from the fact that some of your app’s model components are remote.
Patterns review for the SCWCD We’ve covered a lot of  patterns   in the last two chapters.
The next few pages pull together a lot of  the details you’ll want to study for the SCWCD exam.
Service Locator Use the Service Locator pattern to perform registry lookups so you can simplify all of the other components (such as Business Delegates)  that have to do JNDI (or other registry types) lookups.
Provides a local representation of a remote entity (i.e., an object that maintains some data state)
Transfer  Object Use the Transfer Object pattern to minimize network traffi c by providing a local representation of  a fi ne-grained remote component (usually an entity)
Minimizes the performance impact on the web tier when remote components’ data is accessed with fi ne-grained calls.
Transfer Object can receive out-of-date data, because the Transfer Object’s data is really representing state that’s stored somewhere else.
Can intercept and/or modify requests before they reach the servlet.
Can intercept and/or modify responses before they are returned to the client.
Intercepting Filter Use the Intercepting Filter pattern to modify requests being sent to servlets, or to modify responses being sent to users.
Declarative control allows the sequence of invocation to be easily updated.
Model components hide internal details (data structures), from the view and controller components.
If the model adheres to a strict contract (interface), then these components can be reused in other application areas such as GUIs or J2ME.
Separation of model code from controller code allows for easier migration to using remote business components.
Model, View, Controller ( MVC) Use the MVC pattern to create a logical structure that separates the code into three basic types of components (Model, View, Controller) in your application.
This increases the cohesiveness of each component and allows for greater reusability, especially with model components.
This is true because even though individual components become more cohesive, MVC adds many new components to the application.
Minimizes the impact of changes in other tiers of the application.
Centralizes a web app’s initial request handling tasks in a single component.
Using the Front Controller with other patterns can provide loose coupling by making presentation tier dispatching declarative.
A drawback of Front Controller (on its own, without Struts) is that it’s very barebones compared to Struts.
To create a reasonable application from scratch using the Front Controller pattern, you would end up rewriting many of the features already found in Struts.
Front Controller Use the Front Controller pattern to gather common, often redundant, request processing code into a single component.
This allows the application controller to be more cohesive and less complex.
The design of  your web application calls for certain security measures to be taken for every request received.
Some of  these security checks will be applied, regardless of  the type of  request.
Which design pattern can be used to achieve this design requirement?
Your job is to seamlessly integrate your application’s web service endpoints with its DAOs.
In addition, your coarse-grained Controller Locators must be enhanced to support J2ME, UDDI registries.
Which design pattern can be used to achieve these design requirements?
This statement describes the potential benefits of  a design pattern:
The pattern reduces network roundtrips between a client and an Enterprise Bean, and gives the client a local copy of  the data encapsulated by an Enterprise Bean after a single method call, instead of  requiring several method calls.
Your company, Models ’R Us, is creating an advanced inventory maximization component that can be used with all major J2EE container vendors.
Your job is to design the piece of  this component that will perform JNDI lookups with whatever vendor the client is using.
While fine tuning your multi-tiered J2EE business application, you’ve discovered that you’d get better performance if  you reduced the number of  remote requests your app makes, and increased the amount of  data collected for each request you make.
What design pattern should you consider to implement this change in your application?
Your web application uses a SessionBean component in a distributed application to make a specialized calculation, such as validating credit-card numbers.
However, you want to shield your web components from the code involved with looking up the SessionBean component and using its interface.
You want to decouple local application classes from the looking up and use of  the distributed component, whose interface could change.
Which J2EE design pattern can you use in this case?
The design of  your web application calls for certain security measures to be taken for every request received.
Some of  these security checks will be applied, regardless of  the type of  request.
Which design pattern can be used to achieve this design requirement?
The Intercepting Filter is a good choice when you want to intercept and manipulate requests before the normal request processing happens.
This pattern (among others), helps separate the tasks performed by application developers from the tasks performed by web designers.
Your job is to seamlessly integrate your application’s web service endpoints with its DAOs.
In addition, your coarse-grained Controller Locators must be enhanced to support J2ME, UDDI registries.
Which design pattern can be used to achieve these design requirements?
This statement describes the potential benefits of  a design pattern:
The pattern reduces network roundtrips between a client and an Enterprise Bean, and gives the client a local copy of  the data encapsulated by an Enterprise Bean after a single method call, instead of  requiring several method calls.
A key benefit of a Transfer Object is the reduction of network traffic.
Your company, Models ’R Us, is creating an advanced inventory maximization component that can be used with all major J2EE container vendors.
Your job is to design the piece of  this component that will perform JNDI lookups with whatever vendor the client is using.
The Service Locator can be used when you want to encapsulate vendor dependencies concerning service lookups.
Using this pattern will help isolate the code that will be unique from vendor to vendor.
While fine tuning your multi-tiered J2EE business application, you’ve discovered that you’d get better performance if  you reduced the number of  remote requests your app makes, and increased the amount of  data collected for each request you make.
What design pattern should you consider to implement this change in your application?
The Transfer Object can be used to aggregate multiple, fine-grained remote calls into a single call.
Often, the reduction in network traffic more than makes up for the overhead of populating a larger object, and an increase in performance can be achieved.
Although a layer is added, the benefits of this pattern (such as reduced coupling and a simpler business tier interface), make it worthwhile.
Your web application uses a SessionBean component in a distributed application to make a specialized calculation, such as validating credit-card numbers.
However, you want to shield your web components from the code involved with looking up the SessionBean component and using its interface.
You want to decouple local application classes from the looking up and use of  the distributed component, whose interface could change.
Which J2EE design pattern can you use in this case?
A key benefit of the Business Delegate is reduced coupling between the presentation tier and the business tier.
By using this pattern you can combine the network calls necessary to lookup and create business objects.
Do NOT try to take this exam until you believe you’re ready for the real thing.
If you take it too soon, then when you come back to it again you’ll already have some memory of the questions, and it could give you an artificially high score.
We really do want you to pass the first time.
Unless there were some way to convince you that you need to buy a fresh copy of this book each time you retake the exam...
To help defeat the “I remember this question” problem, we’ve made this exam just a little harder than the real exam, by not telling you how many answers are correct for each of our questions.
Our questions and answers are virtually identical to the tone, style, difficulty, and topics of the real exam, but by not telling you how many answers to choose, you can’t automatically eliminate any of the answers.
It’s cruel of us, really, and we wish we could tell you that it hurts us more than it hurts you to have to take the exam this way.
Most exam candidates have said that our mock exams are a little more difficult than the real SCWCD, but that their scores on our exam and on the real one were very close.
This mock exam is a perfect way to see if you’re ready, but only if you:
Give yourself no more than two hours and 15 minutes to complete it, just like the real exam.
Don’t look anywhere else in the book while you’re taking the exam!
By the fourth time, you might be getting 98% and yet still not be able to pass the real exam, simply because you were memorizing our exact questions and answers.
Wait until after you finish the exam to consume large quantities of alcohol or other mind-altering substances...
Final Mock Exam A programmer has a validly configured directory structure for his Java EE web application which is called MyWebApp.
Which of  the following are legal EL? (Choose all that apply)
A TLD from a Java forum website contains this tag definition:
The class should have a size member with at least a setter method.
No size variable is needed in the code because the TLD states it is not required.
A Servlet sets up a bean before forwarding to a JSP.
They are equally likely to invoke methods in a transfer object.
They are equally likely to be invoked directly from a controller object.
The service locator will typically be considered a server to the business delegate.
When both are implemented with a cache, data staleness is a bigger issue for the business delegate.
Not all of  them must be declared in the DD.
The DD tag used to declare them is placed within the <web-app> tag.
The DD tag used to declare them is placed within the <servlet> tag.
Some users have complained that strange things are happening when they have two browser windows open on a single machine and both windows access the application at the same time.
You want to test various browsers to see if  a session would be shared across multiple windows.
You decide to do this by outputting the JSESSIONID in a JSP.
Which implicit object can access the attributes from the ServletContext? A.
You have determined that certain capabilities in your web application will require that users be registered members.
In addition, your web application sometimes deals with user data that your users want you to keep confidential.
You can make transmitted data confidential only after your application has verified the user’s password.
Of  the various types of  authentication guaranteed by a Java EE container, only BASIC, Digest, and Form Based are implemented by matching a user name to a password.
No matter what type of  Java EE authentication mechanism you use, it will only be activated when an otherwise constrained resource is requested.
All of  the Java EE guaranteed types of  authentication provide strong data security without the need to implement supporting security features.
Given these fragments from within a single tag in a Java EE DD:
A Java EE DD can contain a single tag in which all of  these tags can legally co-exist.
It is valid for more instances of  <auth-constraint> to exist within the single tag described above.
It is valid for other tags of  the same type as the single encasing tag described above to have the same <url-pattern> as the tag above.
This tag implies that authorization, authentication, and data integrity security features are all declared for the web application.
You are creating a JSP Document that generates a dynamic SVG image which is represented by an XML document structure.
The JSP must declare the HTTP response header 'Content-Type' as 'image/svg+xml' so that the web browser will render the response as an SVG image.
Which JSP code snippet declares that this JSP Document is an SVG response?
Java EE containers must support HTTP sessions, even for clients that do not support cookies.
Java EE containers must recognize the HTTP termination signal that is issued to indicate that a client session is no longer active.
Your company has purchased a license for a third party JavaScript library for constructing menus.
Your team has run into countless errors by mistakingly misusing the library and the users are insisting that certain menu items should only be visible to users with the authorized security role.
A custom tag library using Simple tag handlers could shield developers from making syntactical JavaScript errors and provide the security features the users desire.
After a design meeting, your team lead documented that she would like the menu to look like the following:
You wish to put the full responsibility of  generating output on the outer <menu:main> tag handler, assuming that centralizing the display logic will be easier to maintain.
The outer tag handler will need access to its descendent tags to accomplish this.
Every inner tag should register itself  directly to its immediate parent.
The immediate parent can store its children in an ordered collection.
Every inner tag should register itself  directly to the outer tag handler, and the outer tag handler can store them all in a single HashSet.
Have each inner tag save itself  as a page scoped attribute with its text value as the attribute key.
The author wrote a handler that evaluates its tag body a hundred times, to be used in testing other tags that produce random content.
Tag handlers are not thread safe, so the iterationCount can become out of  sync if  multiple users are reaching the page at the same time.
The doAfterBody method is never being called because it is not part of  the tag handler lifecycle.
As written, the default doStartTag of  TagSupport is called which simply returns SKIP_ BODY, causing doAfterBody to never be called.
When doAfterBody returns EVAL_BODY_AGAIN the doTag method is called again.
And given that session is a reference to a valid HttpSession, and this fragment from a servlet:
It is impossible to determine the session timeout limits given the above.
If  the container receives no client requests for this session in 2 hours, the container will invalidate the session.
If  the container receives no client requests for this session in 2 minutes, the container will invalidate the session.
If  the container receives no client requests for this session in 10 seconds, the container will invalidate the session.
If  the container receives no client requests for this session in 10 minutes, the container will invalidate the session.
You have created a valid directory structure and a valid WAR file for your Java EE web application.
WARdir represents the directory that must exist in every WAR file.
APPdir represents the directory that must exist in every web application.
Placing your application in a WAR file provides the option for the.
Only HTTP POST can support multiple parameters in a single request.
Only HTTP POST requests should be handled by overriding a servlet’s service() method.
Given that a String is stored as an attribute named accountNumber of  some scope, which scriptlet(s) will ouptut the attribute?
You have inherited a legacy JSP web application with lots of  scripting code.
Your manager has demanded that every JSP be refactored to remove scripting code.
He wants you to guarantee that no scriptlet code exists in your JSP codebase and to have the web container enforce a “no scripting” policy.
Which of  the following lines of  code, if  inserted independently at Line 5, will cause the text within the c:otherwise tag to display? (Choose all that apply)
You are working on an application that manages a business listing directory.
The above snippet adds a special icon in front of  phone numbers that are toll free.
Which statement about the EL function from this code snippet is guaranteed to be true?
The EL function must not return any value and be declared void.
The name of  the class that implements the EL function must be.
Given a Java EE web application in which the following browser request:
The deployment descriptor must include instructions to handle the request as specified.
The request can be handled as specified with no related instructions in the deployment descriptor.
The servlet name is not predictable based on the information provided.
The name of  the directory in which the servlet resides is not predictable.
Your web application has a valid deployment descriptor in which student and sensei are the only security roles that have been defined.
The deployment descriptor contains two security constraints that declare the same resource to be constrained.
As the deployment descriptor stands now, the constrained resource can be accessed by both roles.
As the deployment descriptor stands now, the constrained resource can be accessed only by sensei users.
As the deployment descriptor stands now, the constrained resource can be accessed only by student users.
If  the second <auth-constraint> tag is removed, the constrained resource can be accessed by both roles.
If  the second <auth-constraint> tag is removed, the constrained resource can be accessed only by sensei users.
If  the second <auth-constraint> tag is removed, the constrained resource can be accessed only by student users.
Which of  the following custom tags is guaranteed to fail? (Choose all that apply)
Your n-tier web application uses the Java EE patterns that are most typically used when such an application wants to access remote registries.
Given this portion of  a Java EE .war file’s directory structure:
You are considering implementing some variety of  MVC in your Java EE n-tier application.
It often reduces network traffic by caching remotely located data.
Even though MVC solutions have many benefits, they often increase design complexity.
Both the front controller pattern and Struts could be considered solutions for this design goal.
This design will provide you with the capability to easily recombine request and response handlers.
You are tasked with adding several security features to your company’s Java EE web application.
Specifically, you need to create several classes of  users and based on a user’s class, you need to restrict them to use only some of  the application’s pages.
In order to restrict access, you must determine that users are who they say they are.
If  you need to verify that users are who they say they are, you must use the application’s deployment descriptor to implement that requirement.
Java EE’s authorization capabilities should be used to determine that users are who they say they are.
In order to help you determine that users are who they say they are, you can use the deployment descriptor’s <login-config> tags.
Depending on the approach you use, determining that users are who they say they are might require including a "realm"
ValidApp is a Java EE application with a valid directory structure.
ValidApp contains .gif  image files in three locations within the directory structure:
In which of  these locations can clients directly access these .gif  files?
A Tag File named Products.tag displays a list of  products.
You are taking part in an initiative to remove scriptlets from the JSPs of  a legacy web application for a major bank.
Match the event types above to their respective listener interfaces.
Note: you can match an event type to more than one Listener.
The service() method is the first method invoked by the container when a new request is received.
The service() method is invoked by either doPost() or doGet() after they’ve completed a request.
Each time that doPost() is invoked, it runs in its own thread.
The destroy() method is invoked after every invocation of  doGet()
The container issues a separate thread for each client request.
A programmer needs to update a live, running servlet’s initialization parameters so that the web application will begin to use the new parameters immediately.
For each parameter, you must modify a DD tag that specifies the name of  the servlet, the name of  the parameter, and the new value of  the parameter.
The servlet’s constructor must retrieve the updated DD parameter from the servlet’s ServletConfig object.
For each parameter, the DD must have a separate <init-param> tag.
What about the above taglib directives would cause the JSP to not function?
Line 4 is wrong because the prefix attribute must come before the uri attribute.
Line 3 is wrong because there is no uri attribute.
Line 4 is wrong because the uri value must begin with http:// D.
Line 3 is wrong because the prefix jsp is reserved for standard actions.
Given the following portion of  a web.xml from a legacy application:
Change the taglib directive’s uri attribute in your JSPs to use "*" and the container will automatically map it.
Remove the taglib directives that used this mapping in your.
The <jsp-config> entry here must be present for the container to map the TLD to the uri referenced in your JSPs.
For a page that lists shopping cart items, the message “Your shopping cart is empty.” must display when the cart is empty.
Which of  the following code snippets could satisfy this functionality assuming the scoped attribute cart is a List of  products? (Choose all that apply)
If  myVar is an HttpSession, s is guaranteed to have the value "myVal"
If  myVar is a ServletContext, s is guaranteed to have the value "myVal"
Given a portion of  Java EE web application’s deployment descriptor:
If  the application throws an IOException, nothing will be served.
If  the application throws an IOException, notFound.jsp will be served.
If  the application throws an IOException, mainError.jsp will be served.
An attempt is made to convert the above JSP to a JSP Document:
The template text should be wrapped in a <jsp:text> tag.
Which of  the following is LEAST likely to make or receive network calls?
The question attribute is a String that may contain XML tags that must be displayed in the browser as regular text.
With the above snippet, the browser is not displaying the XML tags.
What can be changed to fix this? (Choose all that apply)
Your Java EE web application is gaining in popularity and you decide to add a second server to support the volume of  client requests.
When a session is migrated, its HttpSession goes with it.
When a session is migrated, its ServletContext goes with it.
When a session is migrated, its HttpServletRequest goes with it.
A Java EE deployment descriptor declares several filters whose URLs match a given request, and also declares several filters whose <servlet-name> tags match the same request.
Of  the URL matched filters, only the first will be invoked.
Of  the <servlet-name> matched filters, only the first will be invoked.
The <servlet-name> matched filters will be invoked before the URL.
All of  the URL matched filters will be invoked, but the order of invocation is undefined.
All of  the URL matched filters will be invoked, in the order in which they appear in the DD.
Their respective DD tags are both placed directly under the <web-app> tag.
Their respective methods used to retrieve initialization parameter values are.
Only changes to context initialization parameters in the DD can be accessed without redeploying the web application.
A JSP developer wants to include the contents of  the file copyright.jsp into all primary JSP pages.
You are developing an application to manage customer accounts for a company that offers phone, cable, and Internet services.
The search box should look the same on every page but some of  the pages should limit the search to only phone, cable, or Internet accounts.
What tag should you use in a JSP that needs to search for cable accounts?
While testing how various tags and scriptlets work, a developer creates the following JSP:
Much to the developer’s surprise, the browser doesn’t display anything at all when her JSP is retrieved.
If  the developer views the HTML source of  the page, what will she find in the output?
A dating services application asks its single users a series of  questions.
How can this be replaced without using scriptlets? (Choose all that apply)
A programmer is creating a filter for a Java EE web application.
Your company wants to include a splash page, SplashAd.jsp, to advertise other company offerings to users as they first enter the site.
On this new page users will be given the option to click a checkbox on the ad page that says“Do not show me this offer again” and click a submit button that says “Continue to My Account”
If  the user submits this form with the checkbox checked, the receiving Servlet sets a Cookie with the name of  “skipSplashAd”to the user’s browser and then passes control back to the main JSP.
The main JSP will be responsible for forwarding the request to the splash page  What snippet can be added to the top of  the main page to send the user to the splash page if  they have not yet selected the checkbox to avoid the ad offer?
The wickedlysmart website has a validly deployed Java EE web application and Deployment descriptor that contains the following:
A portion of  the web app’s directory structure looks like this:
A single url tag should declare directory1 and a single role tag should declare EXPERT.
A single url tag should declare directory2 and a single role tag should declare EXPERT.
A single url tag should declare directory1 and a single role tag should declare BEGINNER.
A single url tag should declare directory2 and a single role tag should declare BEGINNER.
One url tag should declare ANY and its role tag should declare EXPERT, and another url tag should declare directory2 and its role tag should declare BEGINNER.
One url tag should declare both directories, and its role tag should declare EXPERT, and another url tag should declare directory1 and its role tag should declare BEGINNER.
A programmer has a validly configured directory structure for his Java EE web application which is called MyWebApp.
Which of  the following are legal EL? (Choose all that apply)
Options D and F: tag files MUST be located in the tags directory or in a subdirectory of tags.
Option F: you can't concatenate Strings with the + operator.
A TLD from a Java forum website contains this tag definition:
The class should have a size member with at least a setter method.
No size variable is needed in the code because the TLD states it is not required.
Option A: the tag handler should store size even though the tag usage doesn't always require it.
Option C won't accomplish anything unless you override this and provide the needed behavior.
There is a default implementation in SimpleTagSupport, but it does nothing.
Option E: there's only one lifecycle method for Simple tag handlers and any overloaded versions won't be recognized by the container.
A Servlet sets up a bean before forwarding to a JSP.
Options A and B both use the type attribute which requires that the bean is already saved to some scope.
Even if they used the class attribute it would be insufficient for populating all the bean's properties.
Options C and D: Individual <jsp:setProperty> tags must be used to map parameters to bean properties when the names do not match.
For the parameter names that do match, the property="*" can be used to automatically pass them all into the bean.
They are equally likely to invoke methods in a transfer object.
They are equally likely to be invoked directly from a controller object.
The service locator will typically be considered a server to the business delegate.
When both are implemented with a cache, data staleness is a bigger issue for the business delegate.
Not all of  them must be declared in the DD.
The DD tag used to declare them is placed within the <web-app> tag.
The DD tag used to declare them is placed within the <servlet> tag.
Some users have complained that strange things are happening when they have two browser windows open on a single machine and both windows access the application at the same time.
You want to test various browsers to see if  a session would be shared across multiple windows.
You decide to do this by outputting the JSESSIONID in a JSP.
Option A: typically the business delegate will ask another object to make a network call.
Option B: typically the service locator doesn't use a transfer object.
Option C: typically the controller makes requests of the business delegate, and when necessary the business delegate will make a request of the service locator.
Option C: we’re hoping that you can figure this out without memorization.
Option A evaluates to a Cookie object, which outputs the reference to the Cookie object, not its internal value.
These options all retrieve the JSESSIONID Cookie and call its getValue() method.
Which implicit object can access the attributes from the ServletContext? A.
Options A, B, and E are incorrect because these are illegal names for JSP implicit objects.
Option C is incorrect because the 'request' implicit object can only access request-scoped attributes.
Option D: HTTP has a CONNECT method, but it’s the exception to the rule, it’s the only method that’s not mirrored in HttpServlet.
You have determined that certain capabilities in your web application will require that users be registered members.
In addition, your web application sometimes deals with user data that your users want you to keep confidential.
You can make transmitted data confidential only after your application has verified the user’s password.
Of  the various types of  authentication guaranteed by a Java EE container, only BASIC, Digest, and Form Based are implemented by matching a user name to a password.
No matter what type of  Java EE authentication mechanism you use, it will only be activated when an otherwise constrained resource is requested.
All of  the Java EE guaranteed types of  authentication provide strong data security without the need to implement supporting security features.
Given these fragments from within a single tag in a Java EE DD:
A Java EE DD can contain a single tag in which all of  these tags can legally co-exist.
It is valid for more instances of  <auth-constraint> to exist within the single tag described above.
It is valid for other tags of  the same type as the single encasing tag described above to have the same <url-pattern> as the tag above.
This tag implies that authorization, authentication, and data integrity security features are all declared for the web application.
You are creating a JSP Document that generates a dynamic SVG image which is represented by an XML document structure.
The JSP must declare the HTTP response header 'Content-Type' as 'image/svg+xml' so that the web browser will render the response as an SVG image.
Which JSP code snippet declares that this JSP Document is an SVG response?
Option A is incorrect because the standard JSP directive syntax '<%@ ...
Option B is incorrect because there is no 'jsp:page' standard tag in JSP Documents.
Java EE containers must support HTTP sessions, even for clients that do not support cookies.
Java EE containers must recognize the HTTP termination signal that is issued to indicate that a client session is no longer active.
Option B: URL rewriting is almost always used as the fallback when cookies are not available, but it’s NOT a requirement for containers.
Your company has purchased a license for a third party JavaScript library for constructing menus.
Your team has run into countless errors by mistakingly misusing the library and the users are insisting that certain menu items should only be visible to users with the authorized security role.
A custom tag library using Simple tag handlers could shield developers from making syntactical JavaScript errors and provide the security features the users desire.
After a design meeting, your team lead documented that she would like the menu to look like the following:
You wish to put the full responsibility of  generating output on the outer <menu:main> tag handler, assuming that centralizing the display logic will be easier to maintain.
The outer tag handler will need access to its descendent tags to accomplish this.
Every inner tag should register itself  directly to its immediate parent.
The immediate parent can store its children in an ordered collection.
Every inner tag should register itself  directly to the outer tag handler, and the outer tag handler can store them all in a single HashSet.
Have each inner tag save itself  as a page scoped attribute with its text value as the attribute key.
Option A is the simplest solution, as it creates a simple tree structure of tags that gives the <menu:main> access to all of its descendent tags.
Options B and D wouldn't give the outer tag any clue how the inner tags are structured.
Option B is correct because any runtime exception thrown in the JSP must be handled by the container and it must generate a server-side error.
Option A is correct because if the JSP servlet code fails to compile, then the container must generate a server-side error.
Option C is incorrect; the destroy method cannot cause a 500 error.
Option D is correct because if the initialization method throws an exception, then the container cannot issue requests to the JSP and must send a server-side error.
Option F: removeAttribute() is used to unbind a single object.
Option E: invalidate() is used to unbind all objects bound to the session.
Options A and B: in these cases a new session is created.
The author wrote a handler that evaluates its tag body a hundred times, to be used in testing other tags that produce random content.
Tag handlers are not thread safe, so the iterationCount can become out of  sync if  multiple users are reaching the page at the same time.
The doAfterBody method is never being called because it is not part of  the tag handler lifecycle.
As written, the default doStartTag of  TagSupport is called which simply returns SKIP_ BODY, causing doAfterBody to never be called.
When doAfterBody returns EVAL_BODY_AGAIN the doTag method is called again.
Option A: tag handlers are thread safe, so it is OK to store state in them.
The doAfterBody method is part of the IterationTag interface which TagSupport does implement.
Option C: simply changing this method name should fix the problem.
Option D: even if the method name change from Option C is fixed, an infinite loop should never occur because a Classic tag lifecycle never calls doStartTag more than once.
And given that session is a reference to a valid HttpSession, and this fragment from a servlet:
It is impossible to determine the session timeout limits given the above.
If  the container receives no client requests for this session in 2 hours, the container will invalidate the session.
If  the container receives no client requests for this session in 2 minutes, the container will invalidate the session.
If  the container receives no client requests for this session in 10 seconds, the container will invalidate the session.
If  the container receives no client requests for this session in 10 minutes, the container will invalidate the session.
Option E: the argument for this method represents seconds, however the value in the tag represents minutes.
Option B: the method only overrides the timeout for this session.
You have created a valid directory structure and a valid WAR file for your Java EE web application.
WARdir represents the directory that must exist in every WAR file.
APPdir represents the directory that must exist in every web application.
Placing your application in a WAR file provides the option for the.
Option E: a WAR file gives you the option to perform additional deploy-time checks.
Option B: typically the container will name the application by using the name of the WAR file, but it’s not required.
Only HTTP POST can support multiple parameters in a single request.
Only HTTP POST requests should be handled by overriding a servlet’s service() method.
Option A: if a form doesn’t explicitly declare a method, GET is assumed.
Option E: for the sake of the exam, you should never override the service() method.
Option C is the correct syntax for the <init-param> tag.
Given that a String is stored as an attribute named accountNumber of  some scope, which scriptlet(s) will ouptut the attribute?
Option B: EL does not get evaluated inside of scriptlets.
This is an illegal use of scriptlets anyway, so don't think this was just a trick!
Option A: If you had to use scriptlets, this the easiest way.
You have inherited a legacy JSP web application with lots of  scripting code.
Your manager has demanded that every JSP be refactored to remove scripting code.
He wants you to guarantee that no scriptlet code exists in your JSP codebase and to have the web container enforce a “no scripting” policy.
Option A is incorrect because <permit-scripting> is not a valid configuration element.
Option D is incorrect because <jsp-config> is not a valid configuration element.
Which of  the following lines of  code, if  inserted independently at Line 5, will cause the text within the c:otherwise tag to display? (Choose all that apply)
Options A, B, and D all add something to the books List, making it NOT empty.
Option E: Making the List reference a null value satisfies the empty operator.
You are working on an application that manages a business listing directory.
The above snippet adds a special icon in front of  phone numbers that are toll free.
Which statement about the EL function from this code snippet is guaranteed to be true?
The EL function must not return any value and be declared void.
The name of  the class that implements the EL function must be.
Option A: all EL functions must be declared public and static.
Option B: it should return a boolean value so it can be used by the <c:if> tag.
Option C: the <uri> value should match whatever is declared in the JSP's taglib directive, which was not shown.
Option D: the fully qualified class name is mapped in the TLD using <function-class> and does not have to match any particular naming convention to be used for EL functions.
API28 -Option A: getReader() retrieves the body as character data.
Option D: this method retrieves the body as binary data.
Option B: it should return a boolean value so it can be used by the <c:if> tag.
Given a Java EE web application in which the following browser request:
The deployment descriptor must include instructions to handle the request as specified.
The request can be handled as specified with no related instructions in the deployment descriptor.
The servlet name is not predictable based on the information provided.
The name of  the directory in which the servlet resides is not predictable.
Option A: a <servlet-mapping> tag must be specified in the DD.
Options C and E: myDir and DoSomething are virtual names known only to the DD.
Your web application has a valid deployment descriptor in which student and sensei are the only security roles that have been defined.
The deployment descriptor contains two security constraints that declare the same resource to be constrained.
As the deployment descriptor stands now, the constrained resource can be accessed by both roles.
As the deployment descriptor stands now, the constrained resource can be accessed only by sensei users.
As the deployment descriptor stands now, the constrained resource can be accessed only by student users.
If  the second <auth-constraint> tag is removed, the constrained resource can be accessed by both roles.
If  the second <auth-constraint> tag is removed, the constrained resource can be accessed only by sensei users.
If  the second <auth-constraint> tag is removed, the constrained resource can be accessed only by student users.
Options A, B, and C: the second tag is “empty” which means no roles can use this resource.
Which of  the following custom tags is guaranteed to fail? (Choose all that apply)
Options B, C, and D are all potentially legal usages of custom tags.
Your n-tier web application uses the Java EE patterns that are most typically used when such an application wants to access remote registries.
The patterns used here are the business delegate and the service locator.
By using these two patterns together, each component has more focused responsibilities, and when architectural changes occur, maintenance efforts will be reduced.
Option D: if you picked option D don't worry - when the service locator is implemented with a cache you can indeed reduce network traffic.
However, caches always come with their own drawbacks, so this isn't the most standard solution.
Options B and F are usually done when a servlet needs to create and destroy resources used by the servlet, such as database connections.
Given this portion of  a Java EE .war file’s directory structure:
Option D: .tag files must be in the WEB-INF/tags/ portion of the tree.
Option C is OK, but not directly accessible to clients.
You are considering implementing some variety of  MVC in your Java EE n-tier application.
It often reduces network traffic by caching remotely located data.
Even though MVC solutions have many benefits, they often increase design complexity.
Both the front controller pattern and Struts could be considered solutions for this design goal.
This design will provide you with the capability to easily recombine request and response handlers.
Option B: objects that support MVC might cache, but MVC itself typically doesn't.
Option F: this is the job of the intercepting filter, which can work with MVC, but which is separate.
Option A is incorrect because the JSP declaration tag cannot be used to insert import statements into the translated servlet code.
Option B is incorrect because there is no import JSP directive.
Option D is incorrect because the JSP declaration tag cannot be used to insert import statements into the translated servlet code.-Option E is correct because the import attribute of the page directive is allowed to be specified more than once.
You are tasked with adding several security features to your company’s Java EE web application.
Specifically, you need to create several classes of  users and based on a user’s class, you need to restrict them to use only some of  the application’s pages.
In order to restrict access, you must determine that users are who they say they are.
If  you need to verify that users are who they say they are, you must use the application’s deployment descriptor to implement that requirement.
Java EE’s authorization capabilities should be used to determine that users are who they say they are.
In order to help you determine that users are who they say they are, you can use the deployment descriptor’s <login-config> tags.
Depending on the approach you use, determining that users are who they say they are might require including a "realm"
Option D: this tag is used to implement data integrity.
ValidApp is a Java EE application with a valid directory structure.
ValidApp contains .gif  image files in three locations within the directory structure:
In which of  these locations can clients directly access these .gif  files?
We know this is a real “memorization” kind of question, and we’re sorry, but you might get this kind of thing on the real exam.
A Tag File named Products.tag displays a list of  products.
Option C: a body is allowed because of the tagdependent body-content value in the tag directive.
Also, header may not hold a scriptlet because it was defined with rtexprvalue set to false.
You are taking part in an initiative to remove scriptlets from the JSPs of  a legacy web application for a major bank.
Match the event types above to their respective listener interfaces.
Note: you can match an event type to more than one Listener.
The service() method is the first method invoked by the container when a new request is received.
The service() method is invoked by either doPost() or doGet() after they’ve completed a request.
Each time that doPost() is invoked, it runs in its own thread.
The destroy() method is invoked after every invocation of  doGet()
The container issues a separate thread for each client request.
Option D: the container invokes destroy() when it decides to remove a servlet.
Options B and C: it can occur any time between its initial deployment into the JSP container and the processing of a client request for the page.
Option D won't cause another translation to the same page.
Option A: JSPs are not located in the src folder and the developer does not compile them like code.
Option B: because os.flush() wasn’t called, the uncommitted output (123), is cleared, and forward is invoked without exception.
A programmer needs to update a live, running servlet’s initialization parameters so that the web application will begin to use the new parameters immediately.
For each parameter, you must modify a DD tag that specifies the name of  the servlet, the name of  the parameter, and the new value of  the parameter.
The servlet’s constructor must retrieve the updated DD parameter from the servlet’s ServletConfig object.
For each parameter, the DD must have a separate <init-param> tag.
Option B: you can’t retrieve the ServletConfig object until after the consructor runs.
Option C: A new Servlet must be initialized to hold the new ServletConfig.
The constraint in this scenario is that only GUESTs can do POSTs in directory1
What about the above taglib directives would cause the JSP to not function?
Line 4 is wrong because the prefix attribute must come before the uri attribute.
Line 3 is wrong because there is no uri attribute.
Line 4 is wrong because the uri value must begin with http:// D.
Line 3 is wrong because the prefix jsp is reserved for standard actions.
Option B: when using Tag Files, tagdir is used instead of uri.
Option C: a URI simply must match how the TLD is identified by the container.
Option D: the jsp prefix is reserved for standard actions.
Option C: setHeader() replaces any existing data in the header; addHeader() adds data to any existing data.
Given the following portion of  a web.xml from a legacy application:
Change the taglib directive’s uri attribute in your JSPs to use "*" and the container will automatically map it.
Remove the taglib directives that used this mapping in your.
The <jsp-config> entry here must be present for the container to map the TLD to the uri referenced in your JSPs.
We can see that the TLD is under WEB-INF, so the container will find it.
If the TLD contains a <uri> then the container will implicitly map that value to the proper TLD location.
Option C: Remove the taglib directives from the JSPs and the tags for prettyTables will be passed over as template text.
For a page that lists shopping cart items, the message “Your shopping cart is empty.” must display when the cart is empty.
Which of  the following code snippets could satisfy this functionality assuming the scoped attribute cart is a List of  products? (Choose all that apply)
Option B: if cart is empty or null, the c:forEach will never execute its body.
You will never see the message when the cart is empty.
If  myVar is an HttpSession, s is guaranteed to have the value "myVal"
If  myVar is a ServletContext, s is guaranteed to have the value "myVal"
Option A: without synchronization, even HttpSession values can change unexpectedly.
Given a portion of  Java EE web application’s deployment descriptor:
If  the application throws an IOException, nothing will be served.
If  the application throws an IOException, notFound.jsp will be served.
If  the application throws an IOException, mainError.jsp will be served.
An attempt is made to convert the above JSP to a JSP Document:
The template text should be wrapped in a <jsp:text> tag.
Which of  the following is LEAST likely to make or receive network calls?
Option B: transfer objects are typically sent within network calls, but they seldom initiate or respond to network calls.
Option A: if you see a pattern or component that's not in the objectives you can rule it out as the correct answer!
The question attribute is a String that may contain XML tags that must be displayed in the browser as regular text.
With the above snippet, the browser is not displaying the XML tags.
What can be changed to fix this? (Choose all that apply)
Options A and C: escapeXml is true by default, so both A and C are correct.
Even though <c:out> can have a body, the body replaces the default attribute, not the value attribute.
Your Java EE web application is gaining in popularity and you decide to add a second server to support the volume of  client requests.
When a session is migrated, its HttpSession goes with it.
When a session is migrated, its ServletContext goes with it.
When a session is migrated, its HttpServletRequest goes with it.
Option G: the container must also send a passivation notice.
Option E: there's no way you can port an object unless it's serializable.
A Java EE deployment descriptor declares several filters whose URLs match a given request, and also declares several filters whose <servlet-name> tags match the same request.
Of  the URL matched filters, only the first will be invoked.
Of  the <servlet-name> matched filters, only the first will be invoked.
The <servlet-name> matched filters will be invoked before the URL.
All of  the URL matched filters will be invoked, but the order of invocation is undefined.
All of  the URL matched filters will be invoked, in the order in which they appear in the DD.
First the container will invoke all of the URL matched filters, in DD declaration order, then the <servlet-name> matched filters will be invoked, also in DD declared order.
Their respective DD tags are both placed directly under the <web-app> tag.
Their respective methods used to retrieve initialization parameter values are.
Only changes to context initialization parameters in the DD can be accessed without redeploying the web application.
Option E: in neither case are changes to the DD dynamically accessible.
Option D: only context params can be directly accessed from JSPs.
A JSP developer wants to include the contents of  the file copyright.jsp into all primary JSP pages.
Option A is correct because this syntax is appropriate for JSP Documents.
Option B is correct because this syntax is appropriate for JSP pages.
Option C is incorrect because you cannot use the page directive to import content.
Option D is correct because this standard action performs content inclusion at runtime.
Option E is incorrect because this standard action does not exist.
You are developing an application to manage customer accounts for a company that offers phone, cable, and Internet services.
The search box should look the same on every page but some of  the pages should limit the search to only phone, cable, or Internet accounts.
What tag should you use in a JSP that needs to search for cable accounts?
While testing how various tags and scriptlets work, a developer creates the following JSP:
Much to the developer’s surprise, the browser doesn’t display anything at all when her JSP is retrieved.
If  the developer views the HTML source of  the page, what will she find in the output?
A dating services application asks its single users a series of  questions.
How can this be replaced without using scriptlets? (Choose all that apply)
Option C: EL alone cannot set a value to an object.
Option D: <c:set> can be used to put values in a map.
A programmer is creating a filter for a Java EE web application.
Your company wants to include a splash page, SplashAd.jsp, to advertise other company offerings to users as they first enter the site.
On this new page users will be given the option to click a checkbox on the ad page that says“Do not show me this offer again” and click a submit button that says “Continue to My Account”
If  the user submits this form with the checkbox checked, the receiving Servlet sets a Cookie with the name of  “skipSplashAd”to the user’s browser and then passes control back to the main JSP.
The main JSP will be responsible for forwarding the request to the splash page  What snippet can be added to the top of  the main page to send the user to the splash page if  they have not yet selected the checkbox to avoid the ad offer?
The forward only occurs when the Cookie has not been set.
Be aware that users with cookies disabled will never get to skip the ad with this solution.
The wickedlysmart website has a validly deployed Java EE web application and Deployment descriptor that contains the following:
A portion of  the web app’s directory structure looks like this:
Option D: if the DD doesn’t contain a servlet mapping, it will search the directory specified in the request and serve the first file it finds in the welcome list that matches a file in the requested directory.
A single url tag should declare directory1 and a single role tag should declare EXPERT.
A single url tag should declare directory2 and a single role tag should declare EXPERT.
A single url tag should declare directory1 and a single role tag should declare BEGINNER.
A single url tag should declare directory2 and a single role tag should declare BEGINNER.
One url tag should declare ANY and its role tag should declare EXPERT, and another url tag should declare directory2 and its role tag should declare BEGINNER.
One url tag should declare both directories, and its role tag should declare EXPERT, and another url tag should declare directory1 and its role tag should declare BEGINNER.
Folks there are just so damn friendly it’ll make you want to throw.
And don’t forget to write and tell us when you pass the exam!
