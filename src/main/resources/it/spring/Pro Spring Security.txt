For your convenience Apress has placed some of the front matter material after the index.
Denying the impact of the Spring Framework in the Java world would be simply impossible.
Spring has brought so many advantages to the Java developer that I could say it has made better developers of all of us.
Spring’s core building blocks of Dependency Injection and Aspect Oriented Programming are widely applicable to many business and infrastructure concerns, and certainly application security can benefit from these core functionalities.
So this is Spring Security: an application-level security framework built on top of the powerful Spring Framework that deals mainly with the core security concepts of authentication and authorization.
Spring Security aims to be a full-featured security solution for your Java applications.
Although its main focus is on Web applications and the Java programming language, you will see that it goes beyond these two domains.
What I wanted to do in writing this book was to expose some of the internal works of Spring Security along with the standard explanations of how to use certain features.
My idea is to teach beyond the basics of how to do something in particular, and instead focus on the plumbing inside the framework.
For me, this is the best way of learning something: actually seeing how it is built in the core.
That’s not to say, of course, that the book doesn’t cover basic setups and give quick, practical advice on using the framework, because it certainly does.
With that said, I suggest that the best way to use this book is to have the Spring Security source code checked out on your computer and go through the examples with both the code from the book and the code from Spring Security itself.
This will not only help you understand each concept as it is introduced, but will also teach more than one good programming trick and good practice.
I recommend this approach to studying any software whenever you have the chance.
Sometimes a couple lines of code teach more than a thousand words.
Who This Book Is For This book is written mainly for Java developers who use Spring in their work and need to add security to their applications in a way that leverages Spring’s proven concepts and techniques.
The book will also be helpful to developers who want to add Web-layer security to their applications, even if those applications are not fully Spring powered at their core.
The book assumes you have knowledge of Java and some of its tools and libraries, such as Servlets and Maven.
It also assumes that you know what you want to use security for and in what context you want to use it.
This means, for example, I won’t explain protocols like LDAP in much depth; instead, I’ll concentrate on showing you how to integrate Spring Security with an LDAP user store.
An in-depth knowledge of Spring is not essential because many of the concepts are introduced as we go along, but the more you understand about Spring, the more you are likely to get out of this book.
How This Book Is Structured The book is divided into nine chapters that embody a progressive study of Spring Security.
Starting from a summary of basic applications and an explanation of how the framework is structured, the content moves on to more advanced topics, such as using Spring Security in different JVM languages.
The book follows a sequence that corresponds to the way this framework is normally used in real life.
Spring Security 3.1.3 was the version used throughout the book.
Jetty Web Server was used for the different web applications in the book, mainly through its Maven plugin.
You are free to use your own tools and operating system.
Because everything is Java based, you should be able to compile your programs on any platform without problems.
Downloading the code The code for the examples shown in this book is available on the Apress web site, www.apress.com.
A link can be found on the book’s information page under the Source Code/Downloads tab.
This tab is located underneath the Related Titles section of the page.
Contacting the Author You are more than welcome to send me any feedback regarding this book or any other subject I might help you with.
It means so many different things in so many different contexts, but in the end, it is all about protecting sensitive and valuable resources against malicious usage.
In IT, we have many layers of infrastructure and code that can be subject to malicious attacks, and arguably we should ensure that all these layers get the appropriate levels of protection.
Of course, the growth of the Internet and the pursuit of reaching more people with our applications have opened more and more doors to cyber criminals trying to access these applications in illegitimate ways.
It is also true that proper care is not always taken to ensure that a properly secured set of services is being offered to the public.
And sometimes, even when good care is taken, some hackers are still smart enough to overcome security barriers that, superficially, appear adequate.
The three major security layers in an IT infrastructure are the network, the operating system, and the application itself.
The Network Security Layer This layer is probably the most familiar one in the IT world.
When people talk about IT security, they normally think of network-level security—in particular, security that uses firewalls.
Even though people often associate security with the network level, this is only a very limited layer of protection against attackers.
Generally speaking, it can do no more than defend IP addresses and filter network packets addressed to certain ports in certain machines in the network.
This is clearly not enough in the vast majority of cases, as traffic at this level is normally allowed to enter the publicly open ports of your various exposed services with no restriction at all.
Different attacks can be targeted at these open services, as attackers can execute arbitrary commands that could compromise your security constraints.
There exist tools like the popular nmap(http://nmap.org/) that can be used to scan a machine to find open ports.
The use of tools like this is an easy first step to take in preparing an attack, because well-known attacks can be used against such open ports if they are not properly secured.
A very important part of the network-layer security, in the case of web applications, is the use of Secure Sockets Layer (SSL) to encode all sensitive information sent along the wire, but this is related more to the network protocol at the application level than to the network physical level at which firewalls operate.
The Operating System Layer This layer is probably the most important in the whole security schema, as a properly secured operating system (OS) environment could at least prevent a whole host machine from going down if a particular application is compromised.
If an attacker is somehow allowed to have unsecured access to the operating system, he can basically do whatever he wants—from spreading viruses to stealing passwords or deleting your whole server’s data and making it unusable.
Even worse perhaps, he could take control of your computer without you even noticing, and use it.
We can include in this layer the deployment model of the applications, as you need to know your operating system’s permission scheme to ensure that you don’t give your applications unnecessary privileges over your machine.
Applications should run as isolated as possible from the other components of the host machine.
The Application Layer The main focus of this book will be on this layer.
The application security layer refers to all the constraints we establish in our applications to make sure that only the right people can do only the right things when working through the application.
Applications, by default, are open to countless avenues of attack.
An improperly secured application can allow an attacker to steal information from the application, impersonate other users, execute restricted operations, corrupt data, gain access to operating system level, and perform many other malicious acts.
In this book, we will cover application-level security, which is the domain of Spring Security.
Application-level security is achieved by implementing several techniques, and there are a few concepts that will help you understand better what the rest of the book will cover.
These are the main concerns that Spring Security addresses to provide your applications with comprehensive protection against threats.
Authentication The process of authentication allows an application to validate that a particular user is who she claims she is.
In the authentication process, a user presents the application with information about herself (normally, a username and a password) that no one else knows.
The application takes this information and tries to match it against information it has stored—normally, in a database or LDAP1 (Lightweight Directory Access Protocol) server.
If the information input by the user matches a record in the authentication server, the user is said to have successfully authenticated herself in the system.
The application will normally create an internal abstraction representing this authenticated user in the system.
Authorization When a user is authenticated, that only means that the user is known to the system and has been recognized by it.
It doesn’t mean that the user is free to do whatever she wants in said system.
The next logical step in securing an application is to determine which actions that user is allowed to perform, and which resources she has access to, and make sure that if the user doesn’t have the proper permissions she cannot carry out that particular action.
In the most common case, the authorization process compares the user’s set of permissions against the permissions required to execute a particular action in the application, and if a match is found, access is granted.
On the other hand, if no match is found, access is denied.
ACLs Access control lists (ACLs) are part of the authorization process explained in the previous section.
The key difference is that ACLs normally work at a finer grained level in the application.
ACLs are simply a collection of mappings between resources, users, and permissions.
With ACLs, you can establish rules like “User John has administrative permission on the blog post X” or “User Luis has read permission on blog post X.” You can see the three elements: user, permission, and resource.
Figure 1-2 shows how ACLs work, as they are just a special case of the general authorization process.
Authentication and Authorization: General Concepts In this section, I shall introduce and explain some fundamental security concepts that you will be coming across frequently in the rest of the book:
The use of encryption achieves, among other things, two other security goals:
What to Secure Not every part of the application requires a strong security model, or even any security at all.
If, for example, one part of your application is supposed to serve static content to everyone interested in it, you can simply serve this content.
Anyway, when starting to work on a new application, you should think about the security constraints that your application will have.
You should think about concerns like those in the following list and whether or not they apply to your particular use case:
More Security Concerns There are many more security concerns than the ones explained so far.
However, I think it is important that you understand there are many more security concerns than those addressed directly by Spring Security.
Following is a quick overview of some of the most common ones.
This is only intended to make you aware of their existence, and I recommend you consult a different source (such as a general software security textbook) to gain a better understanding of all these concerns:
They cover areas ranging from a low-level permission system, through cryptography APIs, to an authentication and authorization scheme.
The list of security APIs offered in Java is very extensive, as the following list of the main ones shows:
So it overlaps mainly with the JAAS Java API, although they can be used together, as you will see later in the book.
Most of the other APIs are leveraged in Spring Security.
Summary In this chapter, I introduced security from a general point of view.
I explained in a very abstract way the main concerns in IT security and especially from an application point of view.
I also described, very briefly, the main Java APIs that support security at different levels.
You can see that this chapter was a very quick overview of security concerns.
It is beyond the scope of this book to go any further than this on general topics, although we will study some of them in more depth when they apply to Spring Security.
Obviously this is nothing like a comprehensive software security guide, and if you are interested in learning more about software security in general you should consult the specialized literature.
In this chapter, you will learn what Spring Security is and how you can use it to address security concerns about your application.
We’ll start with a Servlet-based web application without any security, and then we’ll add security to it in a declarative, nonintrusive way.
Also in this chapter, we’ll take a look at the framework’s source code, how to build it, and the different modules that together form the powerful Spring Security project.
What Is Spring Security? Spring Security is a framework dedicated to providing a full array of security services to Java applications in a developer-friendly and flexible way.
It adheres to the well-established practices introduced by the Spring Framework.
Spring Security tries to address all the layers of security inside your application.
In addition, it comes packed with an extensive array of configuration options that make it very flexible and powerful.
Although the majority of applications that use the framework are web based, Spring Security’s core can also be used in standalone applications.
Many things make Spring Security immediately attractive to Java developers.
To name just a few, I compiled the following list:
This is important from a business point of view as well because the application can either adapt to the corporate authentication services or implement its own, thus requiring only straightforward configuration changes.
This also means that there is a lot less software for you to write, because you are making use of a great amount of ready-to-use code that has been written and tested by a large and.
You can, to a certain point, trust that this code works and use it with confidence.
And if it does not work, you can always fix it and send a patch to those in charge of maintaining the project.
Imagine, for instance, that you offer services exposed through RMI, the Web, JMS, and others.
You could secure all of these interfaces, but maybe it’s better to secure just the business layer so that all requests are secured when they reach this layer.
Also, maybe you don’t care about securing individual business objects, so you can omit that module and use just the functionality you need.
But like anything else, it is not a tool that adapts to everything you want to do.
Where and why would you use Spring Security? Here is a list of reasons and scenarios:
Spring Security and Spring As I said before, Spring Security is part of the SpringSource portfolio of open source projects.
There are many more projects from SpringSource, and they are driven by a large and dynamic community of users.
All these projects are built on top of the facilities provided by the Spring Framework itself, which is the original project that started it all.
You can think of Spring as the hub of all these satellite projects, providing them with a consistent programming model and a set of established practices.
The main points you will see throughout the different projects is the use of DI, XML namespace-based configuration, and AOP, which as you will see in the next section, are the pillars upon which Spring is built on.
In the later versions of Spring, annotations have become the most popular way to configure both DI and AOP concerns.
So Spring Security is just one more of these projects, and it is dedicated exclusively to addressing security concerns in your application.
If you read the online documentation, you will find out that Spring Security started originally as a non-Spring project.
It was originally known as The Acegi Security System for Spring, and it was not the big and powerful framework it is today.
Originally, it dealt only with authorization and leveraged container-provided authentication.
Because of public demand, the project started to get traction, as more people started using it and contributing to its continuously growing code base.
This eventually led to it becoming a Spring Framework portfolio project, and then later it was rebranded as “Spring Security.”
So the project, for many years now, has been under the SpringSource umbrella of projects, powered by The Spring Framework itself.
It makes sense to give an overview of it at this point, because many of the Spring Security characteristics I will cover in the rest of the book rely on the building blocks of Spring.
I love Spring and have loved it for many years now.
I think Spring has so many advantages and so many great things that I can’t start a new Java project without using it.
Additionally, I tend to carry its concepts around when working with other languages and look for a way to apply them because they now feel so natural to me.
There are many things that attract me to Spring, but the main ones are the two major building blocks of the framework: dependency injection (DI) and Aspect-Oriented Programming (AOP)
These two concepts, and Spring itself, are covered extensively in other books and online tutorials; however, I’ll give you a brief overview here.
Dependency Injection The basic idea of DI, a type of Inversion of Control (IoC), is simply that instead of having an object instantiate its needed dependencies, the dependencies are somehow given to the object.
In a polymorphic way, the objects that are given as dependencies to the target object that depends on them are known to this target  object just by an abstraction (like an interface in Java) and not by the exact implementation of the dependency.
It’s easier to look at this in code than explain it.
In this example, every instance of NonDiObject is responsible for instantiating its own Helper in the constructor.
You can see that it instantiates a HelperImpl, creating a tight, unnecessary coupling to this particular Helper implementation.
The object receives its dependencies from some external source (with dependency injection)
In this version, the Helper is passed to the DiObject at construction time.
It doesn’t even need to know how to do that or what particular implementation type the Helper is, or where it comes from.
It just needs a helper and uses it for whatever requirement it has.
The second version is loosely coupled to the Helper, depending only on the Helper interface, allowing the concrete implementation to be decided at runtime and thus giving lots of flexibility to the design.
Spring dependency injection configuration is normally defined in XML files, although later versions have turned more to annotation-based configuration and Java-based configuration.
Aspect Oriented Programming (AOP) AOP is a technique for extracting cross-cutting concerns from the main application code and applying them in a transverse way across the points where they are needed.
Typical examples of AOP concerns are transactions, logging, and security.
The main idea is that you decouple the main business logic of your application from special-purpose concerns that are peripheral to this core logic, and then apply this functionality in a transparent, unobtrusive way through your application.
By encapsulating this functionality (which is simply general application logic and not core business logic)  in its own modules, they can be used by many parts of the application that need them, avoiding the need to duplicate this code all over the place.
The entities that encapsulate this cross-cutting logic are referred to as Aspects in AOP terms.
The most popular, perhaps, is AspectJ which requires a special compilation process.
Spring supports AspectJ, but it also includes its own AOP implementation, known simply as Spring AOP, which is a pure Java implementation that requires no special compilation process.
Spring AOP using proxies is available only at the public-method level and just when it is called from outside the proxied object.
This makes sense because calling a method from inside the object won’t call the proxy; instead, it calls the real self object directly (basically a call on the this object)
This is something very important to be aware of when working with Spring, and sometimes it is overlooked by novice Spring developers.
Even when using its own AOP implementation, Spring leverages the AspectJ syntax and concepts for defining Aspects.
Spring AOP is a fairly big subject, but the principle behind the way it works is not difficult to understand.
Spring AOP works with the use of dynamically created proxy objects that take care of the AOP concerns around the invocation of your main business objects.
You can think of the proxy and Spring AOP in general simply as a Decorator Pattern implementation, where your business object is the component and the AOP proxy is the decorator.
Figure 2-1 shows a simple graphical representation of the concept.
Thinking about it this way, you should be able to understand Spring AOP easily.
Spring creates dynamically at runtime an object that conceptually looks like the following code.
Again, remember this simple idea and Spring AOP should be easier to understand.
An Initial Spring Security Secured Application Spring Security builds upon the concepts defined in the previous section and integrates nicely into the general Spring ecosystem.
You need to understand those concepts well to take maximum advantage of Spring Security.
However, you could start using Spring Security without really knowing all these details, and then learn them as you progress and look to do more advanced things.
As many other programming books do, I will show an initial example of the subject with the familiar “Hello World” application.
It will need a tweak to make sense for our purposes.
So I’ll show the “Hello World” message just to authorized users and not allow unauthorized users to see the message.
In this example, we will create a simple web project powered by Spring Security.
To make sure that the examples in the book work as expected, try to use the same versions.
From the command line, go to any folder you want to use as the root of your projects and execute the following:
To do that, make the pom.xml file look like Listing 2-1
As you can see from the pom.xml listing, I included the Jetty plugin dependency.
I will be working throughout the book mostly with the Jetty server because it embeds nicely in the Maven life cycle.
Using any other container (like Apache Tomcat) to run the code from the book should be no problem, and it should work without issues.
The next task is to create a simple Servlet that will render the “Hello World” message.
Note N  Remember that you have to keep the conventional Maven file structure.
This means you have to create the /src/main/java folders for your source classes if you don’t have them yet.
Look at the Maven documentation online at http://maven.apache.org/ for more details.
In the command line, in the root of the project (where the pom.xml file resides), execute the following:
You’ll see the expected “Hello World” message, as shown in Figure 2-2
Now we want to secure this page and allow only authenticated users to be able to read the super top-secret “Hello World” message.
Let’s say that only the Scarvarez family (whose members are Carl, Mon, Bea, and Andr) is allowed to see this “Hello World” message.
To make this work, you need to do the following:
Configure the users and roles that will be part of the system.
I’ll give more detail about each of these steps in the next four sections.
Adding Spring Security (and Spring Core Itself) to the Project In this section, we’ll start our journey into the inner workings of the framework and see its main building blocks and how it works.
I’ll conduct a full, in-depth review of the framework in the next chapter.
I could just tell you what to add to the project to make the application work, but I think it’s better to tell you first what the different components of the framework are so that you can start coding with a better knowledge of how the framework is built.
This means that I will tell you how to grab the source code of the project and build it, and then explain in a general way the different modules that make up the framework.
Spring Security Source Open source software has an invaluable characteristic for software developers: free access to all its source code.
With this, we can understand how our favorite tools and frameworks work internally, and we also can learn a lot about the way other (perhaps very good) developers work, including what practices, techniques, and patterns they use.
Free access to source code also enables us, in general, to gather ideas and experience for our own development.
Not only that; as a more practical matter, having access to the source code allows us to debug these applications in the context of our application: we can find bugs or simply follow our application’s execution through them.
I really like understanding the frameworks I work with and learning from the great work and effort put into them by some very talented developers around the world.
A lot of this book’s content is based on looking at the source code of Spring Security.
Where appropriate, some of that code will be printed in the pages of this book to make points more clear.
However, if you don’t, you should definitely take a look at it because it has become a standard public source-code repository for many open source projects in a multitude of programming languages.
To get the code, go to any location you want to have the project in your command-line terminal and execute the following command:
That’s it, now you have the Git repository cloned in your computer.
Let’s go inside the newly created directory and see what is there.
The first thing that is worth mentioning is that the current versions of Spring Security use Gradle as the build tool.
Until version 2.5.0.M1, Spring Security used Maven as the build tool.
Maven support was finally removed in version 3.1.0.M1, leaving only Gradle as the build system.
Gradle is a build tool written in Groovy that uses an internal Domain Specific Language to specify the build configuration of your project.
A detailed explanation of Gradle is outside the scope of this book, so I will just cover what you need to build Spring Security from the source code.
You can see that in the top directory there is a file named gradlew.
This is what is known as a Gradle Wrapper, and its main advantage is that it is a self-contained build script-tool.
When you run it, it will download Gradle for you and use the downloaded Gradle to build your project.
Go ahead and run gradlew build install from the top directory and wait for the project to build.
Note N  It is possible for the build to fail in your system.
Because we are working in the master branch of the framework, a lot of code is being committed there all the time.
It is not under my control if this build fails at any given time.
Later, you will simply use a stable tag for developing the examples in the book.
You should now have the project built and available in your current Maven repository.
Yes, when using Gradle, the dependencies can be simply stored in the Maven repository.
You can see that it is very straightforward to build the project from the source code.
Setting the project build aside for now, take another look at the contents of the top project directory.
Most of the folders in the directory correspond to individual subprojects or modules that break the functionality of Spring Security into more discrete and specialized units.
For our project example, you need to depend on the core, web, and config modules.
So we add them to our pom.xml, as shown in Listing 2-3
Note N  As you probably know, Maven handles transitive dependencies.
In our example, the dependencies we just defined in Listing 2-3 will translate into more real-world dependencies, including the needed dependencies from the Spring Framework.
This includes Spring web support and the core libraries for DI and ApplicationContext management.
Configuring the Web Project To Be Aware of Spring Security To activate Spring Security in a Java web application, you need to configure a particular Servlet filter that will take care of pre-processing and post-processing the requests, as well as managing the required security constraints.
The name of this filter is important because it is the default name Spring Security will use to configure its filter chain.
You now need to define the actual Spring Security configuration.
That’s all we need to secure the given URL for the Scarvarez family only.
You can see that you are defining a role called "ROLE SCARVAREZ MEMBER" that is the only one that has access to the url "/hello"
You also see that you are assigning this role to all the Scarvarez family members.
To make this work, you need to reference this new file in the web.xml.
So open it again and add the content from Listing 2-6 to it.
It should be added at the top of the file after the <web-app> element.
Go to the command line, execute mvn jetty:run again, point your browser to the URL http://localhost:8080/hello, and press the Enter key.
You should see a login page asking you to provide the user name and password as Figure 2-4 shows.
Go ahead, impersonate a Scarvarez family member, and try to log in.
For example, use car as the user name and scarvarez as the password.
You should now be allowed access to the same “Hello World” page as Figure 2-2 showed before.
If you instead tried to log in as a nonexistent user, you should get the page shown in Figure 2-5
As a matter of fact, we haven’t written any code; we just did some XML configuration.
Now our Servlet-based application is secured to allow access only for authenticated users.
The fact that we are using this XML configuration to secure the application is very relevant, because it shows that we are adding security in a completely unobtrusive and declarative way to an application that is otherwise insecure.
This is all well and nice, but right now it looks like magic.
In the next section, we will cover the basics of what is going on.
A full, in-depth explanation of Spring Security follows in the next chapter.
I can imagine an application for which this simple configuration would be enough security—for example, an application that has an admin section and an open-to-all section, and where the admin user (or users) is predefined beforehand.
What follows is a general overview of the process, followed by a graphical representation of it:
Start the application (in this case, by using jetty run)
When the application is loading, it looks at its web.xml file.
This file uses the custom Spring Security namespace to define, in a friendly way, the different security concerns that we need to address.
Context LoaderListener after parsing the XML in the normal Spring way.
The result of trying to log in with an incorrect user name and password combination.
This Servlet filter implementation is a Spring contextaware filter that simply delegates the filtering to Spring-defined filter beans.
Spring looks at the current credentials in the web session and can’t find any user details with this role.
When Spring realizes (inside one of the filters) that there is no current user in the session with permission to access the requested URL, it generates a redirect response that redirects the user browser to a login URL that contains a self-generated login form.
When Spring Security detects that this URL has been requested, it tries to extract the user name and password from the request and creates an authentication request.
The authentication request is sent to an authentication manager, which you configured in your XML file.
Internally, the manager finds the user (if it exists) and fills one authentication object with the user details, credentials, and authorities.
This is now an authenticated user, and a session is associated with this user.
If the details contained in the authentication don’t match any user, an exception is thrown indicating that.
This exception is then handled by a different flow that takes care of presenting the login screen again with the error message.
A redirect response is created to the original requested URL.
When this new redirect request gets in the system, it goes through the filters again, but this time the authentication ones are not called because there is already an authenticated user.
This filter compares the authenticated user’s authorities against the authorities needed to have in order to access the requested resource (in this case, the /hello URL)
The framework decides that the user is allowed to access the resource, so the filter chain finally forwards the request to the Servlet.
This is the happy-path scenario of how the flow works.
If anything goes wrong (for example, if the user is not found), Spring Security normally throws an exception and, in the case of web security, maps that exception to a relevant HTTP status code.
This will be covered later in the book as we go deeper into the work of the framework.
Wow! That is a lot of work that Spring Security is doing on our behalf while we just had to define some simple XML configuration.
In the next chapter, I will dive deeply into how all this works internally when we look at the architecture of Spring Security.
Summary Right now, you should have a good idea of what Spring Security is and what it is useful for.
Along the way, I introduced some of the major architectural and design principles behind it and how they are layered on top of the great Spring Framework.
I also gave you a quick look at the source code of the Spring project and at the different modules that make up the framework.
I introduced dependency injection and AOP and gave an overview of the step-by-step process a typical web application goes through when it is secured with Spring Security.
In the next chapter, I’ll go deep into the architecture and design of the framework.
In the previous chapter, I developed an initial application secured with Spring Security.
I gave an overview of the way this application worked and looked in detail at some of the Spring Security components that are put into action in common Spring Security–secured application.
In this chapter, I am going to extend those explanations and delve deeply into the framework.
I’ll look at the main components of the framework, explain the work of the servlet filters for securing web applications, look at how Spring AOP (Aspect Oriented Programming) helps you add security in an unobtrusive way, and in general, show how the framework is designed internally.
I’ll offer a big-picture overview of the framework and then delve deeper into each major component.
The 10,000-Foot View Spring Security is a relatively complex framework that aims to make it easy for the developer to implement security in an application.
At the most general level, it’s a framework composed of intercepting rules for granting, or not granting, access to resources.
From this view, you can think of Spring Security simply as an extra layer built on top of your application, wrapping specific entry points into your logic with determined security rules.
The 1,000-Foot View Going into a little more detail, we arrive at AOP and servlet filters.
Spring Security’s interception model of security applies to two main areas of your application: URLs and method invocations.
Spring Security wraps around these two entry points of your application and allows access only when the security constraints are satisfied.
Both the method call and the filter-based security depend on a central Security Interceptor, where the main logic resides to make the decision whether or not access should be granted.
In Figure 3-2, you can see this more detailed overview of the framework.
The 100-Foot View Spring Security might seem simple conceptually, but internally there is a lot going on—in a very well-built software tool.
This next overview will show you the main collaborating parts that participate in the general process of ensuring that your security constraints are enforced.
This is particularly achievable with an open source project like Spring Security which allows you to get into the framework itself and appreciate its design and architecture by accessing directly the source code..
For me, what follows is the best way to understand Spring Security from the inside.
The enumeration of what I consider to be the main components of the framework will help you know where everything belongs and how your application is enforcing the security rules that you specify for it.
The Security Interceptor One of the most important components of the framework is the Security Interceptor.
The Security Interceptor works with a preprocessing step and a postprocessing step.
In the preprocessing step, it looks to see whether the requested resource is secured with some metadata information (or ConfigAttribute)
If it is not, the request is allowed to continue its way either to the requested URL or method.
If the requested resource is secured, the Security Interceptor retrieves the Authentication object from the current SecurityContext.
If RunAsManager is not configured, a no-op implementation is called.
RunAsManager returns either null (if it’s not configured to be used) or a new Authentication object containing the same principal, credentials, and granted authorities as the original Authentication object, plus a new set of authorities based on the RUN_AS that is being used.
This new Authentication object is put into the current SecurityContext.
This token will be used later in the postprocessing step of the Security Interceptor.
At this point, the Security Interceptor is ready to allow access to the secured resource, so it passes the invocation through and the.
After the invocation returns, the second phase of the Security Interceptor comes into play, and the postprocessing begins.
This is the case if you are using the postinvocation filters in method-level security, as you will see in the following chapter.
That is a lot of work for the Security Interceptor.
However, because the framework is nicely modular at the class level, you can see the Security Interceptor simply delegates most of the task to a series of well-defined collaborators, which in a very SRP (Single Responsibility Principle) way focus on single, narrowly scoped responsibilities.
This is good software design and an example you should emulate.
I include some comments in the code so that you can understand better what it does.
Here we are checking if this filter is able to process a // particular type of object.
Here we are retrieving the security metadata that maps to the // object we are receiving.
So if we are receiving a FilterInvocation, // the request is extracted from it and used to find the // ConfigAttribute (s) that match the request path pattern.
Here we are calling the decision manager to decide if // authorization is granted or not.
This will trigger the voting mechanism, // and in case that access is // not granted an exception // should be thrown.
Every call to a secured resource in Spring Security passes through this interceptor.
This, once again, sh-ows the effort put into the design and implementation of the framework.
Figure 3-4 shows the interceptor in a UML (Unified Modeling Language) class diagram.
We know how the Security Interceptors work, but how do they come to be? How do they know what to intercept? The answer to that lies in the next few components, so keep reading.
The XML Namespace The XML namespace is of extreme importance to the general appeal and usability of the framework, yet it is, in theory, not strictly necessary.
If you know how the Spring Framework’s namespaces work, you probably have a good idea of what is going on when you define your security-specific XML configuration in your application context definition files.
If you don’t know how they work, maybe you think Spring is somehow made aware of how to treat these specific elements and how to load them in the general Spring application context.
Either way, here I will explain in some detail the process behind the definition of a custom namespace in Spring, and particularly, the elements in the Spring Security namespace.
All that Spring understood was its own classes defined in the standard Spring Core namespace, where you can define <bean>s on a bean-to-bean basis and can’t really define anything conceptually more complex without adding that complexity yourself to the configuration.
I’ll explore this manual configuration later in the book, but for standard cases it is not needed, and you should simply use the namespace.
However, keep in mind that under the hood the namespace is nothing more than syntactic sugar.
At the end of the day, you still end up with standard Spring beans and objects.
Since then, a lot of projects have made use of this facility, making them more attractive to work with.
An XML custom namespace is simply an XML-based Domain Specific Language (DSL), guided by the rules of an XML schema (xsd) file, that allow developers to create Spring beans using concepts and a syntax more in synch with the programming concerns they are trying to model.
To make Spring aware of a new namespace is really simple.
That’s not to say it is simple to actually parse the information of the XML and convert it to beans—this depends on the complexity of your DSL.
In Chapter 8 you will see some examples of how to create a new namespace element and integrate it with Spring Security.
In Figure 3-6, you can see the expanded structure of the config module as seen in the Eclipse integrated development environment (IDE)
The files spring.handlers and spring.schemas should reside on the META-INF directory in the classpath so that Spring can find them there.
When you create a  Spring -based application using XML-defined application context configuration with some of the Spring Security namespace definitions, and you run the application, when it starts to load up, it looks in the application context’s namespace definitions at the top of the XML configuration file.
It will find the reference to the Spring Security namespace (normally a reference like this xmlns:security="http://www.springframework.org/ schema/security")
Spring calls the parse method of this class for every top element in the configuration file that uses the security namespace.
From the list of elements presented in the previous class, the top-level ones as used in the XML configuration files are as follows (in the previous listing, I refer to them by the name of the constant and not by the XML element name):
You will be using the Spring Security namespace thoroughly throughout the book, so many of the elements described here will be revisited in later chapters.
The Filters and Filter Chain The filter chain model is what Spring Security uses to secure web applications.
This model is built on top of the standard servlet filter functionality.
The filter chain in Spring Security preprocesses and postprocesses all the HTTP requests that are sent to the application and then applies security to URLs that require it.
The Spring Security filter chain is made up of Spring beans; however, standard servlet-based web applications don’t know about Spring beans.
For this reason, a special servlet filter is needed that can cross the boundaries between the standard servlet API and life cycle and the Spring application where the bean filters will reside.
The filter in the web.xml file has the same name as the bean in the Spring application context so that the listener can find it.
However, here I’ll provide an overview of which filters are available and what they do.
The enums are then referenced later in the startup process when instantiating the bean definitions for each filter.
For example, for our study purposes, ROLE_ADMIN is a ConfigAttribute.
There are a few implementations of ConfigAttribute, as you can see in Figure 3-9
On startup, as normal Spring functionality, all the bean postprocessors in the ApplicationContext get invoked.
And in the case of Spring Security, the process is the following.
What happens in the case of web requests is not really that complex.
For method-level security, you have many options—the most common one being the configurations performed through the use of annotations.
There are a few different annotations available in the framework; however, the setup treatment by the framework is very similar.
In the case of the @Secured annotation, for instance, you need to make Spring aware that this special annotation needs a special security treatment.
To do that, you register the following in the security application context XML file:
This processes all the beans in the application context and determines if any of the configured advisors can be applied to any of the beans and their methods.
If so, it wraps the bean with the required advisor or advisors.
Again, this is a lot of work that Spring and Spring Security do on your behalf.
At first sight, this looks like simple magic, but it takes a lot of hard work from Spring to do it.
And you have to thank the Spring and Spring Security developers for taking care of all this and giving you a simple and powerful API for resolving your security concerns.
The Authentication Object The Authentication object is an abstraction that represents the entity that logs in to the system—most likely, a user.
Because it is normally a user authenticating, I’ll assume and use the term “user” in the rest of the book.
There are a few implementations of the Authentication object in the framework, as you can see in Figure 3-12
An Authentication object is used both when an authentication request is created (when a user logs in), to carry around the different layers and classes of the framework the requesting data, and then when it is validated, containing the authenticated entity and storing it in SecurityContext.
The most common behavior is that when you log in to the application a new Authentication object will be created storing your user name, password, and permissions—most of which are technically known as Principal, Credentials, and Authorities, respectively.
Authentication is an interface, and it is pretty simple, as Listing 3-3 shows.
Note N  There are many implementations of the Authentication interface, and in the book I will be referring most of the time to the general Authentication interface when we are not interested in the particular implementation type.
Of course when I need to talk about the specifics of an implementation detail I will be referring to the concrete classes.
As Figure 3-12 shows, currently there are a few implementations of Authentication in the framework:
This interface has only two methods, as Listing 3-6 shows.
This is one of the major extension points of the framework, as you can tell by the many classes that currently extend this interface.
Each of the implementing classes deals with a particular external provider to authenticate against.
So if you come across a particular provider that is not supported and need to authenticate against it, you probably need to implement this interface with the required functionality.
You will see examples of this later in the book.
Here are some of the existing providers that come with the framework:
AffirmativeBased This access decision manager calls all its configured voters, and if any of them votes that access should be granted, it is enough for the access decision manager to allow access to the secured resource.
ConsensusBased This access decision manager implementation calls all its configured voters to make a decision to either grant or deny access to a resource.
The difference with the AffirmativeBased decision manager is that the ConsensusBased decision manager decides to grant access only if there are more voters granting access than voters denying it.
If there are the same number of granting voters as denying voters, the value of the instance variable.
By default, this variable’s value is “true”, access is granted.
When all voters abstain, the access decision will be decided the same way as it is for the AffirmativeBased manager.
UnanimousBased As you probably guessed, this access decision manager will grant access to the resource only if all the configured voters vote in favor of allowing access to the resource.
The satisfaction or not of the conditions is given  by analyzing the Authentication object’s rights against the required resource.
In practice this basically means that the Authentication’s authorities are compared against the resource’s security attributes looking for matches.
The voters model is yet another one in the framework that is open for extension and customization.
You could easily create your own implementation and add it to the framework.
UserDetailsService makes use of the provided user name for looking up the rest of the required user data from the datastore.
It defines just one method, as you see in Listing 3-9
It is also made available to be accessed later in the system from any point that has access to SecurityContext.
Normally, developers create their own implementation of this interface to store particular user details they need or want (like email, telephone, address, and so on)
Later, they can access this information, which will be encapsulated in the Authentication object, and they can be obtained by calling the getPrincipal method on it.
However, this is another of those configurable points of the framework, and you could easily create your own UserDetails implementation and use that in your application.
This means, in a general way, assigning an ID to each domain object in your application and creating a relationship between these objects and the different users of the application.
These relationships determine whether or not a determined user is allowed access to a particular domain.
The ACL model offers a fine-grained, access-level configuration you can use to define different rules for accessing the objects depending on who is trying to access it.
For example, a user might be allowed read access while another user will have write/read access over the same domain object.
The current support for ACLs is configured to get the configuration rules from a relational database.
The DDL (Data Definition Language) for configuring the database comes along with the framework itself, and it can be found in the ACL module.
The tags are simple to use and, at the same time, very convenient for making a more usable web site.
They help you adapt the UI of your application on a per-user (or more commonly, per-role) basis.
One of the great aspects of working with open source software is that you can (and I would say you should) look at the source code and understand the software at a new, deeper level.
Also, you can look at the way the software is built, at what is good, and at what is bad (at least by your own subjective standards) and just learn how other developers work.
This can have a great impact on the way you work, because you might discover a way of doing things that you couldn’t have learned on your own.
Sometimes, of course, you will find things you don’t like, but that is good as well.
You can learn from other people’s mistakes as much as you can learn from their successes.
For me, Spring in general and Spring Security in particular have achieved something that I found invaluable in the Java development space—that is, they can make us better developers even without us noticing it.
For instance, I often ask myself, “How many people would be using a template pattern for accessing databases if they weren’t using Spring, instead of a more awkward DB access layer?” or “How many people would be just programming against implementation classes all the time, creating unnecessary coupling if it wasn’t for Spring’s DI support?” or “How many people would have cross-cutting concerns, like transactions, all over their code base if it wasn’t for how easily Spring brings AOP into the development process?.”
I think helping good practices almost without noticing is really a great achievement for Spring.
It won’t create great developers by itself for sure, but it helps the average developer to not make mistakes that he might make if he didn’t have the support of the framework, and its principles to adhere to.
As you might see from the description of the main components of the framework, Spring Security itself is built with good design principles and patterns in mind.
You’ll have a brief look here at some of the things I find interesting in the framework, and from which you can learn about.
This section won’t really help you to do more with Spring Security, but it will serve as a way to appreciate the good work that has been done in constructing this fantastic framework.
Strategy Pattern A big part of the pluggability and modularity of the framework is achieved thanks to the wide use of the Strategy pattern.
Covering design patterns is outside the scope of this book but as a reminder of the strategy pattern’s power I leave you with this definition from the Wikipedia.
The strategy pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable.
That definition shows a great deal of the power that comes when working with interfaces.
You could have different implementations of the same interface and pass any of them to a client class for doing different kinds of work.
The client classes don’t need to know or care about the implementation details that it is working with.
Knowing the interface or contract is enough to leverage its job.
Decorator Pattern Built into Spring’s core AOP framework, you can find the Decorator pattern—mostly in the way that your annotated business classes and methods get security constraints applied to them.
Basically, your objects have only certain meta information related to the security constraints that should be applied to them, and then by some “Spring magic” they get wrapped with security handling.
In the listing, you can see how the objects are decorated with prefunctionality and postfunctionality that surrounds the invocation of the actual method.
There are many examples of it around the framework, because any object you choose seems to have one and only one responsibility.
A lot more examples like this can be extracted from the framework.
Dependency injection (DI) is one of Spring’s most important features.
Almost every component in Spring Security is configured through the use of dependency injection.
And like this, most of the framework is built by composing components together through dependency injection.
Summary This was a complex chapter, but going through the inner workings of a software tool is definitely the best way to understand it and take advantage out of it.
You looked at an in-depth explanation of Spring Security’s architecture, its major components, and the way it works from the inside.
You should now understand how the XML namespace works, how AOP fits into the framework, and how, in general, the Servlet Filter functionality is used to enforce web-level security.
I demystified the “Spring magic” by going through all the components that help you add security to your applications in a seemingly simple way.
You looked at some code snippets from the framework itself to get a greater appreciation of the work done in it, as well as to understand better why things work the way they do.
You also studied the modularity inherent in the framework and saw how it helps to create software that is both flexible and extensible.
Even with all we covered in this chapter, it is basically an introduction and a reference to have in hand when you read the upcoming chapters and you start looking at the options to secure your applications.
From now on, you will understand where everything fits in the framework and how the different components link to each other.
In the next chapter, you will start developing an example application.
At the beginning, it will be a simple web application, and you will see how to secure it.
You will use all your current knowledge of the framework to tweak the configuration and test different ways of implementing security at the web level.
In this chapter, I will explain how to apply security at the web layer for Java web-based applications.
You will see in detail the inner work of the security filter chain and the different metadata options at your disposal to define security constraints in your application.
I will also cover the Taglib facility for enforcing security constraints at the view level.
Introducing the Simple Example Application In this chapter, you will be working on a dummy test application: an “action movies” web application.
However, I will try to cover most of the options available for securing web applications with Spring Security, even if some of the options don’t seem realistic for an application of this kind.
As in Chapter 2, we will use Maven to start up and build the project.
Again, I will assume certain versions of the different tools we need.
Go to the command line, to a directory you like, and do the following:
Press enter on each prompt you get from the command line.
So make sure your pom.xml file has the content from Listing 4-1
Just to test that it works, go to the command line, and execute the following in the root of the application:
Note N  Jetty (http://jetty.codehaus.org/jetty/ and http://www.eclipse.org/jetty/) is both an HTTP server and a Java Servlet container in the same way as Apache Tomcat.
It is a powerful, flexible, open source server that can be used either standalone or embedded in applications.
I will use Jetty in all the examples of this book because I find it very convenient to work with in Maven environments.
With that said, most, if not all, of the examples should work as they are in any other Servlet container, such as Tomcat.
The application should start without a problem, and you should get output like that shown in Figure 4-2
In this chapter,  you will be working with Spring MVC instead of simple Servlets.
Covering Spring MVC in depth is outside the scope of this book, but the examples used in the book should be easy enough to follow.
The first thing you will do is set up Spring MVC in your application.
Add the content of Listing 4-2 to your web.xml file.
This code snippet defines a Servlet that will be used to handle all incoming requests to your application.
You can see that its implementation is a Spring-specific class.
This class is the entry point into the Spring MVC world.
This file will be the one Spring uses to configure the MVC support in the framework.
You will define a minimal file here because that is all you need at the moment.
You will create this file with the contents of Listing 4-3
First iteration of the application displays the simple Hello World! page.
For this first controller, you will focus on the “admin” part of the application.
At the beginning,  you will handle administration tasks with a particular URL namespace (/admin/*)
Note that, for the purposes of web security, it doesn’t really matter if you use a Spring MVC controller, like we do here, or if you use simple Servlets as we did in Chapter 2, or for that matter, if you use any other Servlet-based framework for developing your application.
Remember that, at the core, the web part of Spring Security basically attaches itself to the standard Java Servlet Filter architecture.
So if your application uses Servlets and Filters, you can leverage Spring Security’s web support.
You can see that in this controller you specified the URL, the HTTP method, and the body of the request you will receive.
The URL is built with a combination between the class-level RequestMapping annotation’s value concatenated with the method-level RequestMapping annotation’s value.
The HTTP method is specified as POST in the RequestMapping annotation on the method.
The RequestBody annotation in the method parameter simply tells Spring to populate the movie parameter with the string that comes in the body of the request.
And the ResponseBody annotation at the method level tells Spring to use the return value of the method as the body content of the response.
First, make sure you restart the application by pressing Ctrl+C and mvn jetty:run again as you did before.
You will be using curl for this first simple example.
Later,  you will be using the user interface of the application itself.
Curl is a command-line tool you use to send HTTP requests to a server.
It can be configured to use any HTTP method, add any arbitrary headers, use certificates, and so on.
For testing your new functionality, you start your application (using mvn jetty:run as I explained in Chapter 2)
Then, from the command line in another terminal, execute the following:
If you look back in the first terminal where the application is running, you should see the text “Adding movie!! Die Hard” printed in the console as Figure 4-5 clearly shows.
You are reaching the endpoint with your POST request to create movies.
But in a real application context, maybe only an admin user should be allowed to create new movies on the system.
You have defined your first user and your first role.
But what is an admin user? In this case, an admin user will simply be a user with a ROLE_ADMIN role.
You need to decide where you are going to store your users and your roles.
Because this is a greenfield fake application, you can decide to do whatever you want.
For starters, you will do the easiest thing and store your users and roles in memory with the application.
You will then modify this to a more realistic database-backed solution in later chapters.
In later chapters, you will also fully explore some of the other providers you can use and even implement your own.
Here, you can see you are defining your new admin user.
The next step is to secure your URL, allowing access only to your newly defined admin user.
You will make sure that only users with the ROLE_ADMIN role are able to reach your AdminController.
Note N  There is a catch in defining the security constraints of Spring Security.
In short, you need to define your Spring Security configuration in one of the root application contexts.
You also need to activate the Spring Security filter chain.
To do that, you add the contents of Listing 4-7 to the web.xml file.
Restart the application, and paste the following URL in your browser’s address bar: http://localhost:8080/admin/movies.
You will now look in more detail at what is going on in the application, and how the configuration you just defined is helping you secure the application.
You will follow the request throughout its trip through the framework and look at the different steps that it takes.
The request will go through all these filters in a predefined order.
Figure 4-7 shows each of the filters that your current request travels through in the framework.
The filter chain, with the filters invoked in the first request.
A new SecurityContext is created and associated to the current thread of execution.
The request is then sent to the next filter in the chain.
This interaction is really simple and is shown in Figure 4-9
LogoutFilter no-op interaction when the logout URL is not requested.
As with the previous filter, this interaction is simple and can be explained with the same diagram.
As in the previous two filters, this interaction is simple and can be explained with the same diagram.
This filter looks for HTTP Basic Authentication headers in the request (the header “Authorization” with a value starting with “Basic”)
Because none are found, the filter forwards the request to the next filter in the chain.
As in the previous three filters, this interaction is simple and can be explained with the same simple diagram.
So it forwards the original request to the next filter.
Cached requests are used normally when you do temporal redirections (like when you redirect to the login page) and then want to redirect back to the previously requested URL.
This object plays the role of an anonymous user in the system.
As a matter of fact, it will have a username of anonymousUser and will be the granted authority ROLE_ANONYMOUS in the system.
The request is then forwarded to the next filter in the chain.
At this moment, there is still no active Servlet session in the system for the particular agent that is accessing it.
This filter checks that the current request is with an anonymous Authentication object (which was set by the previous filter in the context) and, finding that it is, it simply forwards the request to the next filter in the chain.
When the request arrives here, the only processing is to wrap the invocation to the next filter in the chain in a try..catch block.
If any subsequent filter, or the request handler itself, throws an exception it will be caught by the catch block in this filter.
This actually happens for the current request, as you will see when I describe the next filter.
You see the interaction of this filter in Figure 4-12
You finally arrive at the last filter in the default-configured chain shown in Figure 4-7
I talked a lot about this filter in previous chapters, but I will refresh the information here in the context of our request.
When the request arrives in this filter, the filter creates a new FilterInvocation object that contains the request.
If it matches, it retrieves the required authorities from the “access” attribute contained in the <intercept-url> element.
The interceptor also extracts the Authentication object from the Security Context and sends these two elements (the Authentication object and the required authorities or config attributes) to the AffirmativeBased access-decision manager, which in turn sends them to the configured RoleVoter instance.
The voter will not find any matches, so it will vote to deny access to the resource.
The catch block in this filter will see that the current Authentication object stored in the SecurityContext is an Anonymous authentication and will start a new authentication process to obtain a complete Authentication from a user.
We’ll follow the request through the framework to see what happens:
In the login form, type the username user and the password uspass.
When the form is submitted, the filters are activated again in the same order as before.
This way, the login form is shown again in the browser with an error message displayed.
First, let’s create a new endpoint in the controller to retrieve some simple text.
In the controller AdminController, create the method from Listing 4-8
Notice in the listing how you are using the GET HTTP method to handle requests.
When http://localhost:8080/admin/movies is requested, the request works its way through the filter chain as in the previous cases.
This time, though, you already have a fully authenticated entity in the system.
Then it recovers the necessary credentials to access that URL (ROLE_ ADMIN)
The AffirmativeBased access-decision manager gets called, and in turn calls the RoleVoter voter.
The voter evaluates the list of authorities of the authenticated entity and compares them with the required credentials to access the resource.
The request gets to the AdminController, which simply returns the string movie x, which then gets rendered to the browser.
This is the complete flow of the Authentication and Authorization process.
Figure 4-16 shows this full interaction in a pseudo flow chart.
The Special URLs From the preceding explanation, you can see that Spring Security’s support for web security defines a few preconfigured URLs for you to use in your application.
From the previous URLs, the first thing that comes to mind is how to configure your own Login form in the application and, in general, how to customize the login process instead of using the default one.
Custom Login Form When you configure the <http> element as you did before, Spring Security takes care of setting up a default login process for you, including a login URL, login form, default URL after login, and some other options.
As you saw before, this filter is the one that generates the login form for you.
If you want to configure your own form, you need to do the following.
The first thing is to tell the framework to replace the default handling with your own.
This element tells Spring Security to change its default login-handling mechanism on startup.
With the new configuration in place, restart the application and try to access the URL http://localhost:8080/admin/movies.
Error 404 that appears when defining a new login handler page.
Let’s create a LoginController controller next to the AdminController in the project.
LoginController that handles the /custom_login URL specified in the configuration file.
The last line in the showLogin method returns a “logical view name,” in Spring MVC parlance.
This will be the name of the JSP file that has your login form.
Now you create the fantastically designed login.jsp from Listing 4-10 in the folder WEB-INF/views in your application.
If you type admin as both the username and password, you get access to the movie x page as you did before with the default login form.
If you take a look at the login.jsp, you can see certain names for the username field, password field, and action attribute of the form element.
Spring Security expects the use of these particular names in order to treat the authentication process correctly.
Also, the form should use POST for sending the information to the server because this is required by the framework.
Restart the application, go to the URL /admin/movies, and log in with admin/admin.
You should be able to access the application without any problem.
The other attributes you can configure in the <form-login> element are these:
If you now restart the application and try to access the URL http://localhost:8080/admin/movies and use an incorrect username and password, you will get the Login page again, but with the error message shown at the top.
Look at Figure 4-19 for the page you should be getting.
Note that this URL could be a different URL altogether, not related to the login URL at all.
But the common pattern is to allow the user another attempt at login, showing her any errors.
It will simply return a 500 status code when failing to authenticate.
And define the following Spring <bean> somewhere in that same file:
Restart the application, go to http://localhost:8080/admin/movies URL, use a random username and password, and click the submit button.
Basic HTTP Authentication Sometimes, you can’t really use a login form for authenticating users.
For instance, if your application is meant to be called by other systems instead of a human user, it doesn’t make sense to show a login form to the other application.
Web services talk to each other without user interaction, ESB systems integrate systems with one another, and JMS clients produce and consume messages from other systems.
In the context of HTTP-exposed interfaces that require no human user to access them, a common approach is to use HTTP basic authentication headers.
The header is appropriately named “Authorization.” When using this header, the client that is sending the request (for example, a browser) concatenates the username and the password with a colon between them and then Base64 encodes the resulting string, sending the result of this.
For example, if you use the  username bart and the password simpson, the client creates the string bart:simpson and encodes it prior to sending it in the header.
After replacing it, you restart the application and go to the URL http://localhost:8080/ admin/movies in the browser.
A standard HTTP authentication box pops up asking you for your authentication details, as Figure 4-21 shows.
Type admin as the username and password, and send the request.
You successfully arrive in the movie x page that you already saw a couple of times before.
The client should know how to handle this code and work accordingly.
In the case of a browser, it simply shows the authentication pop up.
This filter checks the request headers, looking for the “Authorization” header starting with “Basic.” The filter extracts the content of the header and uses Base64.decode to decode the string, and then it extracts the username and password.
The authentication manager will ask the authentication provider to retrieve the user and then create an Authentication object with it.
This process is standard and independent of using Basic Authentication or form authentication.
Its main purpose is to avoid sending clear text passwords on the wire, as Basic Authentication does, by hashing the password prior to sending it to the server.
Digest Authentication works with HTTP headers the same way that Basic Authentication does.
Digest Authentication is based in the use of a nonce for hashing the passwords.
It is passed through the digest computation together with the username, password, nonce, URI being requested, and so on.
In the authentication process, both the server and client do the digest computation and they should match.
This class sets the header “WWW-Authenticate” with the correct values (including the nonce) so that the client agent (the browser) knows it has to start the digest authentication process.
To configure it, let’s add the filter to the filter chain.
Also, it needs to be added as a child of the <http> element.
You also need to give the ID “userService” to the configured <user-service> in the same file.
If you restart the application and try to go to the URL http://localhost:8080/admin/movies, you will be presented with a browser dialog box asking for a username and password exactly like the one that was shown for Basic Authentication.
As I explained before, the entry point will fill the response object with the required headers so that the browser knows it needs to show the login form.
Log in with a username and password of admin, and you should be able to access the requested URL.
The browser will create its own digested message with the password input included and put it in the header.
An example “Digest” header that is sent to the server with your current request is the following:
The information in this header arrives as a csv string containing all the required information as I showed you in the last paragraph, including the nonce and the client nonce (cnonce)
A nonce is an arbitrary number used only once in a cryptographic communication.
Remember-Me Authentication The remember-me authentication functionality is used for allowing returning users of the application to use it without needing to log in every time.
Basically, the application will remember certain visitors, allowing them to just open the application and be greeted with their personalized version of the application, as if they were logged in.
Remember-me functionality is very convenient for users; however, it is also very dangerous and recommended for private (from home) use only.
If you use an application from a public computer and this application remembers your profile information, the next person who accesses that application from that computer will be able to impersonate you with minimum effort.
It is also common practice to offer just a limited amount of functionality in the remember-me session.
This means that even if you are logged-in automatically thanks to the remember-me functionality, you won’t have access to the whole functionality of the application.
More sensitive parts of the application might require you to formally log in to use them.
When you visit Amazon.com and log in, the next time you visit Amazon, the site will remember you, your recommendations, your name, and other information about you.
But if you want to buy something, it will ask you to log in fully to access that functionality.
Remember-me authentication is typically supported by sending a cookie to the browser, which then, on subsequent sessions in the application, will be sent back to the server for auto login.
How does remember-me functionality work in Spring Security? Remember-me functionality in Spring Security is supported mainly by two components: the.
Let’s see how they work in the context of a request.
Go and visit the URL http://localhost:8080/admin/movies, and log in with admin as the username and password.
If the property alwaysRemember is set to true in the service, it will also apply the remember-me functionality.
So let’s add the parameter to the login form you have.
As a value attribute, you can use any of the following values: “yes”, “on”, “1”, or “true”
You should now see a check box along with the username and password fields.
It extracts the username and password from the Authentication object and creates a token with this information and a time to expire.
It basically concatenates these three values and the remember-me key specified in the XML element (terror-key)
And it creates an MD5 encoding out of the resulting string.
You should be able to access the page without logging in.
The first thing the filter does is check that there is no current Authentication in the SecurityContext.
This implementation’s autoLogin method tries to parse the incoming cookie into its composing elements, which are the username, the hashed value of the combined elements (username + “:” + tokenExpiryTime + “:” + password + “:” + key), and the expiry time of the token.
Then it retrieves the UserDetails from the UserDetailsService with the username, recomputes the hashed value with the retrieved user, and compares it with the arriving one.
If they do match, the UserDetails is checked and an Authentication object is created and returned to the caller.
This Authentication object will be used by the Security Interceptor to allow access to the requested URL.
Allowing Remember-Me Access to Selected Parts of the Application Remember-me authentication can be easily configured so that certain URLs require a fully authenticated user (meaning the user is explicitly logged in) to access them.
AffirmativeBased, as I explained in Chapter 3, grants access to a.
By default, both the RoleVoter and the AuthenticatedVoter are configured in the manager, and the RoleVoter is queried first.
The RoleVoter will vote to grant access, so the AuthenticatedVoter won’t be called at all.
You need to define a UnanimousBased access-decision manager in your Spring Security configuration and reference that one from the <http> element.
And make the <http> element’s opening tag look like the following:
In this case, access will be denied because the Authentication object is a remember-me implementation.
This means that the login form will be shown even if a remember-me option was used previously.
Remember-me authentication supports the use of persistent storage, so the token is kept in a datastore and survives application restarts.
This way, you can reference a data source bean in the application context.
You could also create your own implementation based on some other kind of datastore and inject it into your <remember-me> element.
Persistent remember-me tokens come with a nice feature in the current implementation, which is detecting remember-me cookie thefts.
In the persistent model, tokens are stored against a series-id.
A series-id is simply a random Base64 string that is generated whenever a successful login is done in the system.
If they both match, another token is generated for the same serial-id and the datastore is updated with this new token value.
If the series-id matches but the token doesn’t match, it is assumed that a cookie theft has happened (or basically two people have the same cookie)
This is assumed because, as I just explained, the series-id is a quasi-unique random number that is generated on successful login and maintained for that user in the cookie.
That means it is virtually impossible that some other user in a different browser will have the same series-id, unless he had the same cookie.
This is because every time a remember-me autologin is performed, the series-id is used to retrieve the token from the store and then the token is updated.
On subsequent requests, if a user’s token doesn’t match the stored one, this is because someone else accessed the autologin functionality from somewhere else causing the token to be updated for the user’s series-id, so that the old legitimate user token doesn’t match the one that is now stored.
This implementation from Spring Security is based on the following article: http://jaspan.com/improved_persistent_login_cookie_best_practice.
When you log out of an application, you want the application to end your current session, but also to remove any information it might have stored on the client for you.
Now go to the URL http://localhost:8080/admin/movies and log in with admin/admin again.
You would expect that if you log out, these two cookies disappear from the browser, basically removing any trace of the application from your browser.
The JSESSIONID cookie exists, but the session was already invalidated by the framework.
When the request arrives, it follows the filter chain until it arrives at the LogoutFilter.
This filter notices that the URL that is being requested is for logout.
Let’s remove the JSESSIONID cookie from the browser when logging out.
After restarting the application, logging in, and logging out, you can go to the cookies section in your browser and you will see that the JSESSIONID cookie is no longer there.
By default, this URL is the root of the application.
The target URL can be configured using either a request parameter or the referrer header from the request.
And somewhere else in the same file, define the following bean:
Both the successful authentication and successful logout use a redirection strategy for request handling.
In Spring Security, at a low level, this is still the case.
However, as I mentioned before, Spring Security introduces some new concepts for handling user-session information.
In an application using Spring Security, you will rarely access the Session object directly for retrieving user details.
Go ahead and modify the current AdminController to look like Listing 4-16
Remember not to remove the package declaration or the imports from the file.
You should get the message “User admin is accessing movie x” in the browser window, as shown in Figure 4-24
Let’s make it more interesting and add more information to your Users.
You will make your users have a last name and first name.
A message with username information extracted from the Authentication object.
You want to keep the InMemory model of storing and retrieving users, but you need a more flexible user model.
Our user model needs to implement directly or indirectly the UserDetails interface.
You also need to create your own InMemory user details service, because the default one will create Spring Security’s own User instance and not your custom class instances.
Let’s restart the application, visit the URL http://localhost:8080/admin/movies, and log in.
You can see the message “User Scarioni is accessing movie x” as Figure 4-25 shows.
Application using a custom User object and accessing the last name of the user.
SpEL makes it possible to use programming expressions inside bean definitions and other parts of the Spring portfolio—for example, in some annotations you will see later, which allows you to manipulate objects at runtime.
It basically allows the developer to embed code in the configuration files as simple strings and then evaluate those strings at runtime, very much like a dynamic language would allow you to.
Following is the current supported functionality of SpEL extracted directly from Spring documentation at http://static.springsource.org/spring/docs/3.0.x/reference/expressions.html:
The first one we are going to look at is web-layer security using SpEL.
It should come as no surprise that Spring Security’s main Web support for SpEL is configured using Servlet Filters.
When you do this, Spring Security changes its startup process a little bit.
This time, when the Spring namespace parser mechanism is parsing the XML, it will notice that this attribute is in the <http> element.
This final class will be used at startup to map URLs to SpEL parsed expressions.
In the default case, it will also add a WebExpressionVoter to the list of voters configured in the access-decision manager.
When using the expression support, now the value in the access attribute of the <intercept-url> element will be interpreted as a SpEL expression.
Restart the application, go to http://localhost:8080/admin/movies, and log in with admin/admin.
Before and after logging in, the access-decision manager will make a call.
Then it creates a SpEL evaluation context using the Authentication object and the FilterInvocation object.
An evaluation context is where references are resolved when encountered during expression evaluation.
This means that methods called on the SpEL will evaluate against this root object.
Restart the application, visit http://127.0.0.1:8080/admin/movies, and log in with admin/admin.
You should be able to access the page without a problem.
Suppose that you want to support an expression such as “over18.” For that, you need to add your own ExpressionHandler to the configuration:
Define the following as a child element of the <http> element:
Alter the User class to add an “age” attribute as shown in Listing 4-21
This class is the one that will include the new method  you want to make available to the SpEL expressions.
Restart the application, go to http://127.0.0.1:8080/admin/movies, and log in with admin/admin.
You should be able to reach the page without problems.
As you can see from the preceding description, SpEL can be really powerful and you can make it do almost anything you want, provided that you execute the expressions in the context of the object you need.
Basically, you could extend the expression root as much as you want to handle different methods that you can then use in your expressions.
Switching to a Different User Sometimes a user (normally an admin user) needs to execute an operation with the permissions of a different user.
Suppose that in our dumb application we have a new URL and access to it is allowed only to users with role ROLE_USER.
This role allows us to retrieve information for users of the application.
Create a new controller named MovieController in the package com.apress.pss.
A user with access to the movie list through the role ROLE_USER.
Log in again with username admin and the password admin.
Both URLs need to be secured so that only the users who are allowed to switch users can use them.
In this case, they will be secured with a ROLE_ADMIN attribute.
Add the following two lines as children of the <http> element in the configuration file:
Add the filter into the filter chain, because it is not configured by default.
Restart the application, visit http://127.0.0.1:8080/movies/member/1, and log in with admin/admin.
You will get an “Access Denied” message as you saw before.
This will take care of switching to the user paco.
The way this whole process works is by creating a new Authentication object with the user whom you are trying to impersonate as the principal.
When you decide to exit the switched user, you can get back to your original Authentication.
Session Management Another area of Spring Security’s web support is the management of user sessions.
One very important thing to do regarding sessions is to make sure you create a new session ID when a user authenticates successfully.
Doing this reduces the likelihood of session fixation attacks, in which one user sets another user’s session identifier to.
Spring Security also offers a feature you can use to specify the number of concurrent sessions that the same user can have open at any given time.
So when you log in, this strategy will be invoked.
When the strategy is invoked, it retrieves the current session (which is normally the anonymous session) and invalidates it.
To summarize this strategy, when you log in it invalidates the current session, creates a new one, and copies certain attributes from the old one to the new one.
By default, this strategy determines that a maximum of one session can be active for any user at any given time.
In the following step-by-step explanation, I assume Chrome and Firefox are accessible to you:
You should be able to access the page without a problem.
You should be able to access the page without a problem.
You will get the following message: “This session has been expired (possibly due to multiple concurrent logins being attempted as the same user).” This message explicitly indicates what the problem is.
Restart the application, and follow the same flow as before.
This time, you should have both sessions active at the same time.
Using Different Pattern Matchers for Matching Requests So far in your <intercept-url> elements, you have been using Ant expressions for the “pattern” attribute.
Spring Security offers a few RequestMatcher implementations beyond the Ant one.
It basically supports standard Java regular expressions and standard Java case-insensitive regular expressions.
To enable support for using these matchers, you simply need to add the attribute request-matcher to the <http> element specifying the type of matcher your patterns will use within the values ant, regex, and ciRegex.
I won’t cover this here in any depth, because the idea is the same as for using Ant expressions.
Forcing the Request to HTTPS By default, the Spring Security–enabled application serve all content through the normal HTTP channel.
However, you can configure them so that they automatically ensure a particular web request is delivered over the HTTPS channel.
Note N  I’m assuming that, in general, you know the advantages of using HTTPS over HTTP.
First, it allows a connecting client to authenticate the web server that it is connecting to, ensuring that it is connecting to the proper certified website.
The other security concern addressed by HTTPS is the encryption of the information that is exchanged between client and server.
You can find more extensive information on this topic in Wikipedia (http://en.wikipedia.org/wiki/HTTP_Secure) and in many other places.
Setting this up is straightforward; you simply need to add a new configuration element to your Spring Security configuration.
Let’s do that with both the login page and the login form’s post URLs.
You add these two elements as children of the <http> element in the configuration file:
If you do this, however, your current application won’t work.
The problem is that the Maven Jetty plugin  you use to start the application, by default, doesn’t recognize the 8443 port for SSL communication.
So the only thing you need to do here is replace the current pom.xml’s plugin section with the one in Listing 4-29
After that last step, you can restart the application and visit the URL http://localhost:8080/admin/movies as you have always done in this chapter.
The browser will probably show the typical “insecure certificate” warning, which you can see in Figure 4-29, but you can safely proceed by clicking the “Proceed anyway” option, or the similar option in other browsers.
When the application starts up, the namespace parsing mechanism will note the presence of the attribute.
When a request is made, it will, as normal, travel through the filter chain.
The decision manager, with the aid of certain helper classes, decides if the request can proceed or if, on the contrary, the requested channel is not admitted by the requested URL.
In the latter case, it delegates to a ChannelProcessor and a redirection strategy to send a redirect response to the proper channel URL.
Using the JSP Taglib Spring Security’s web offering comes with a nice suite of view-layer tags you can use to configure the presentation of your application according to the user who is currently logged in.
The taglib is oriented mostly to JSPs as a view technology, although in Spring Security 3.1 a new class hierarchy was introduced to support different view-rendering technologies.
The taglib comes packed with plenty of security-oriented tags and attributes.
Here is a full list of supported tags and their attributes:
First, let’s create a new method in MovieController that allows both.
Create the method from Listing 4-30 in the MovieController class.
This new method simply creates one list of movies and passes it to the view as a ModelAndView Spring MVC object.
The important part is that you are using the standard jstl tag library to iterate through the list of movies  you are expecting to get back from your controller in the model.
Then, you use the <authorize> security tag that I explained before to secure certain parts of the view.
You can see that users with the role ROLE_USER can see the movie name.
Users with the role ROLE_VIP can see the movie budget.
Restart the application now, visit the URL http://localhost:8080/movies/, and log in with a username of paco and a password of tous.
Then visit the URL http://localhost:8080/movies/ again, and log in with the username lucas and the password fernandez.
You can see how you are using both “authentication” and “authorize” tags in the jsp and how they work.
In the “authentication” one, you are accessing the principal and the last name of the user.
In the “authorize” one, you are allowing only certain content to be shown based on the role of the logged-in user.
If you want to use the same conditions again later in the page, you can use the var attribute to cache the result of the condition evaluation so that you don’t need to evaluate it again.
For example, replace your movies.jsp with the content from Listing 4-32
Now if you log in with a username of lucas, a password of fernandez and visit the URL http://localhost:8080/movies/, you will see the text “You are a very appreciated VIP user” on the page.
If you do the same when logging in with the username of paco  and a password of tous, you won’t see the message output on the page.
Role Hierarchies So far, you have worked with simple roles assigned to users.
Spring allows you to do exactly that with the use of hierarchical roles.
That method returns all the reachable authorities for a particular list of authorities, which basically means all direct assigned authorities plus all the authorities that are children of those direct authorities.
Then it needs to make those available as GrantedAuthority objects to be queried and returned by the class’s main method.
It then uses those roles for voting on accessing or denying access according to the logic from the RoleVoter class.
The preceding code demonstrates practically everything I’ve explained so far in this section.
The new things that you haven’t seen before are the last bean and its internal anonymous bean.
When the page shows the login form, log in as an admin user.
The one you have is “car”, so log in with a username of car and a password of scarvarez.
In previous examples, you would not be able to access the page; however, thanks to the hierarchical roles, now you are able to access the page, as Figure 4-30 shows.
Summary In this chapter, I covered one of the biggest concerns of the framework: web support in Spring Security.
You saw that the main functionality comes in the form of Servlet filters.
This is a good thing from a standards point of view, because it means you can leverage Spring Security web support in other frameworks that use the standard Java servlet model.
You should now know a lot of details about the main filters that build the framework, how they work internally, and how they fit within each other and with the rest of the framework.
I explained all this in a practical way, trying to solve real-life scenarios (although in a not very real use-case)
I also explained how to attack them in a step-by-step process.
You should be able to understand both role-based security and the power of using SpEL for security rules.
You learned also how to extend the standard SpEL functionality to support new expressions.
You can now use the taglib support included in the framework to customize the user interface, depending on security constraints.
In the next chapter, I will cover the second major concern of Spring Security—namely, method-level security.
I will show you how it compares to web-level security, and you will see that you can leverage a lot of your current knowledge to apply it to the method-level security layer.
This chapter will drill down further into the core functionality of Spring Security.
Unlike in the previous chapter where I focused only on the web-level access to the application, here you will.
It can be seen as a more invasive type of configuration because it involves securing at the code level, while the web layer simply was concerned with URL matching.
However, you will see how the elegant way in which Spring can manage aspect-oriented programming (AOP) concerns will make business-level security as unobtrusive as its web-level counterpart.
The Limitations of Web-Level Security In the previous chapter, you established security constraints at the web layer of the application, mainly at the URL level and the view-rendering layer.
This is very nice and powerful; however, it is not a 100 effective solution in every use case.
The main concerns with applying only this kind of security are both functional and convenience related, as I will explain next.
First, by definition, web-layer security applies only to web applications, which makes it unusable for any other kind of Java application.
Although Spring Security’s main focus is on securing web applications, there is no reason why some of its parts can’t be used for different kinds of applications.
Second, the URL pattern-matching mechanism for security, although flexible, requires the developer to adopt certain rules or conventions just for the sake of security (like creating an /admin/ URL namespace for admin users and setting administrator rules on those URLs)
Third, securing at the URL level creates only a coarse-grained security, as a URL is the entry point into the application.
This means that security constraints are enforced on a per-request basis, greatly reducing flexibility.
For example, if you want to ensure that a particular Data Access Object (DAO) in your application is called only by an administrator user, you can’t do that with web security alone.
You need to make sure that all the URLs that call this DAO are secured for Admin users.
If, for some reason, you have a URL that is not secured correctly, that request will freely reach the DAO layer, where it could execute a potentially delicate operation.
You can surely find a few more reasons why web-only security is not enough sometimes, or simply not convenient enough to use by itself in your applications.
What Is Business Service-Level Security? Service-layer security (or more accurately method-level security) is a feature of Spring Security you use to enforce security constraints at the method level, much as web-level security does at the URL level.
At its core, method-level security relies on Spring AOP’s powerful support for providing you with its services.
This is the main difference in implementation with web-based security that depends on Servlet Filters, although it is worth noticing that under the hood most of the core code that will take care of the security constraints is the same.
This is of great importance, as it shows good care in designing a set of reusable and encapsulated components in the architecture.
As I said, service-layer security is normally used in combination with web-based security, and I will cover this scenario mostly in this chapter.
However, as you will see later, you can use service-layer security by itself without the context of a web application.
The traditional scenario for working with Spring Security is this: You have a web-based application, with a relatively thin web layer, backed by one Spring-implemented business service layer.
With regard to security, the web layer is configured to take care of ensuring that there is a user authenticated in the system (that is, it takes care of the authentication part of the security, using forms, http status codes, and so on)
The service layer has the authorization rules in per-operation criteria and with the needed level of granularity.
Most of the time, you secure the business services; some other times, you might need to secure the DAOs.
Setting Up the Example for the Chapter Let’s start doing some work and see how this whole thing works.
You will be using the same application from last chapter, so make sure you have it at hand.
So you need to add support for it in your application.
The only thing you will do to support it at the moment is break your classes (the ones you want to decorate with security concerns) into interfaceclass hierarchies.
You can see that I copied the Spring model view controller (MVC) annotations into this new interface.
If I had not done this and had left them on the implementation only, Spring MVC wouldn’t be able to find them when looking for a method to handle the incoming requests.
Note N  Normally, in simple controllers, you can keep the @RequestMapping annotations on the implementing class without needing to create an interface.
However, in the case of this example, you need to put the annotation on the interface because you will use security annotations in the class, which automatically will create a proxy object that needs the presence of an interface—for using standard Java Development Kit (JDK) proxy objects, as you will see in the upcoming paragraphs.
This proxy won’t know about the @RequestMapping annotation, so Spring’s MVC mechanism won’t be able to find the handler methods.
Later I will put the security annotations where they belong, in the service layer.
I’m putting them now in the controller simply to illustrate the simplest scenario.
In real life you would not do it this way and instead you would add it to the service layer as I will show you later in the chapter.
It is important anyway to bear in mind this behavior when working with Spring MVC or any other part of Spring that uses proxy objects around your objects..
In general, Spring favors standard interface-based proxies instead of CGLIB, and that is what I will use in this book.
Listing 5-1 demonstrates how a new interface is added to allow Spring to use JDK proxies to enable cross-cutting concerns.
The next thing you’ll do is activate method-level security in the framework.
As you will see later, you can use other types of annotations as well, but for now let’s focus on @Secured.
You can see that I removed a lot from the file, including the <intercept-url> elements.
That means you are no longer enforcing security at the URL level.
You still want your administration operations to be available only to administrator users, so I configured the AdminController to be accessible only by users with ROLE_ADMIN in their list of roles.
Note N  The @Secured annotation also can be used at the class level instead of at the method level.
If it’s used at the class level, all public methods of the class will inherit the behavior specified by the annotation.
A combination of class-level and method-level annotations also can be used.
In this case, method annotations will override the values of class-level annotations.
If you restart the application now and access the URL http://localhost:8080/admin/movies, you will be able to access it.
It will throw an exception, but one that is related to a class cast exception, as you can see in Figure 5-1
This exception is thrown because the @Secured annotation is not being detected by the framework for reasons I will explain next; and there is no User object instantiated at the point where the exception is thrown.
Instead, the application is using the anonymous authentication, whose principal is a string, which it then fails to cast to a fully built User object.
As I said, you shouldn’t have been allowed access to that page, as you have configured the method-level annotation to ensure that only administrators can access it.
Refer to that chapter for an explanation of the startup process.
You can see that if you try to access the URL http://localhost:8080/admin/movies, you get redirected to the already familiar login form.
This means that the security annotation is now finally working.
Remember that the main difference is that, in this case, Spring AOP mechanisms get into action to enforce security by decorating the method call, while in the filter case, the Servlet Filter standard itself helps to validate and enforce the constraints by intercepting the HTTP request.
Login form shown after ensuring that the @Secured annotation is being picked up.
This proxy has all the information it needs to enforce security at the method level.
Creating a Business Layer in Your Application Although I have shown you how to use security annotations at the method level for your controllers, the truth is that you can use these annotations in any layer of your application, and normally they are used at the business service layer.
As a matter of fact, you probably won’t ever use them in the controller layer.
I only used them in that layer in the first part of the example to introduce the concepts step by step.
The only constraints to using security annotations in the service layer, as explained before, are that they have to be used in Spring managed beans, which can be proxied, and they can be applied only in public methods that can be proxied.
Note N  Remember that Spring creates a proxy that wraps your objects.
This proxy is visible only to external callers of methods in the object through the proxy interface.
Once a call reaches the object, any internal method calls within the object itself are not proxied and go directly against the object itself, so no AOP is applied in internal calls.
For continuing with the explanations for this chapter, let’s create a thin business layer where you will start adding your security constraints.
JdkDynamicAopProxy is called by the proxy and invokes the interceptor.
Then replace our MovieController with the one from Listing 5-4
MovieController functionality simply Delegates to the MoviesService for Getting the Model which in this case is a Movie.
If you visit the URL http://localhost:8080/movies/die hard, you once again will be redirected to the login page.
Log in with "lucas" as username and "fernandez" as password and you should be able to access the requested page as expected.
Make sure you have a proper toString implemented in your Movie.java file.
Access granted in the service method for seeing the movie.
So you have moved the security authorization logic to the business layer and left the controller with the single responsibility of coordinating interactions and mapping views to models.
This should be the practice you implement most often, and as I said before, you normally won’t have security configured at the method level in controllers.
Note that although the authorization process has been moved to the business layer, the authentication process still exists in the web layer and the filter-chain logic.
This is the most common scenario where Spring Security fits in: a web-based front end application with a Spring-powered back-end business layer.
You will see later how you can use Spring Security in a non-web-based application.
This advantage also implies that someone coming from a JavaEE background, without Spring knowledge, can understand what is happening when she sees this annotation in place.
Note N  My attitude to standards is that using them is good, as long as they provide you with the functionality you need.
In my mind, you should not depend on the standards to drive your work.
Your work and your needs should be driving the standards, and the minute you can’t do it with standards you should consider finding a simpler solution that works (or develop it yourself if it is worth the effort), instead of trying to tweak the standard to work in an awkward way just to say that you still work within the standard.
I used to be a bigger believer in standards in Java, but my attitude has changed a lot through the years I have been developing software.
I tend to look for simple solutions that, to my eyes, look more elegant than unjustified complex systems.
My last experience was a few years ago when comparing different integration solutions (ESB-like tools)
But trying to get an understanding of OpenESB and Java Business Integration (JBI) was definitely not as straightforward.
This is a large subject of debate and is definitely outside the scope of this book.
To make @RolesAllowed work in your application is pretty simple.
Add the dependency from Listing 5-6 to the pom.xml file.
Now if you restart the application and access "http://localhost:8080/movies/die hard" from your browser, the behavior should be the same as before.
Again, it behaves pretty much like the RoleVoter, but it will make a decision based on the jsr250 annotations.
Securing the Application Using SpEL Expressions As in the case of web-based security, at the method level, you can use SpEL expressions to define security constraints.
This attribute gives you access to four different annotations in your methods.
However, the before and after processing are the same in both cases and it is inherited (both pre and post processing functionality) from the abstract class.
Let’s take a look at the use of these annotations one by one.
You will be denied access and shown the login form.
Fill the login form with the username “lucas” and the password “fernandez”
You will get redirected to the correct page—the same one you saw in Figure 5-5
You will be denied access again, getting an “Access is denied” message page as shown in Figure 5-6
The EvaluationContext is the context in which the SpEL expressions will be evaluated.
This means you can use the same expressions I talked about before, like getAuthentication, isAnonymous, hasRole, and so on.
Access denied page you get because the SpEL expression in a @PreAuthorize failed an evaluation.
Here, in this class, is where the expression context will be set up in order to evaluate the SpEL expression.
The expression context is set up the same way it was for the @PreAuthorize use case.
After this is done, if you restart the application and visit the URL http://localhost:8080/movies/two days in paris, you should be able to access it without a problem.
In this case, you don’t even need to log in, as you are not making constraints on the authenticated user.
Figure 5-9 shows the screen you see if you are following along.
However, if you visit the URL http://localhost:8080/movies/die hard, you will get an “Access denied” message.
Note N  Actually, you will get first the familiar login form.
You get the login form here and not in the previous case because that is the standard way Spring Security handles Access Denied errors in the framework when there is not a fully authenticated user accessing the system.
Spring Security will show the form, offering the user the opportunity to log in.
You can see from this example that you have access to the returned object from the method in the SpEL expression thanks to the getReturnObject() expression.
This allows you to do any kind of validation you need on the returned object.
Here, I will explain the general usage of these annotations and leave the ACL coverage for the next chapter.
The @PreFilter annotation allows you to filter collection parameters based on arbitrary expressions, removing certain elements so that they don’t even arrive at the target secured method.
Next, restart the application, access the URL http://localhost:8080/admin/movies, and log in with "admin" "admin"
You get to the new movie’s page, which shows you the title and budget.
An error page is returned because an exception was thrown.
Figure 5-12 shows the important part of the error page, which says that it is trying to get the budget property from a null object.
Of course, you wouldn’t want to show that in real-life, productionready applications; instead, you would show a properly formatted, friendly error page and message.
I haven’t done anything in that regard because it isn’t relevant to the concepts I want to show you.
This variable references each of the elements of the collection that is being passed to the method.
Basically, when you are using this annotation, the expression handler iterates through the elements in the collection, sets the filterObject value in the expression root.
Next we see the listings for the jsp, controller and service updates referenced in the previous paragraphs.
This is the code needed for showing a form to the user and allow him to create movies.
The difference is that @PostFilter annotations are evaluated after the target method returns, and the SpEL expression in the annotation is evaluated against the returned collection from the target method.
Note that I’m saying the “returned collection.” This is a condition required for the @PostFilter annotation to work.
As with the @PreFilter annotation, it applies only to collections and arrays.
Let’s create a couple new methods and a new simple jsp file.
For the rest of the users, these movies will be filtered out from the returned collection so that the jsp won’t have access to them.
Next, you add the method from Listing 5-11 to the MovieController.
This method calls the service method and wraps the result in a model to be rendered in the view.
Finally, you create the jsp file that will support showing all the movies.
You create the file allMovies.jsp from Listing 5-12 in the folder WEB-INF/views.
Note N  In a real application, of course, you wouldn’t ask your users to manually visit the URL http://localhost:8080/j_spring_security_logout.
You would most likely have a Log Out link the user could click to log out.
This time, you should only see the movie “two days in paris” because “die hard” was filtered out.
You can see how powerful security is when it’s based on the SpEL expression.
You can use this approach to define and combine different expressions to achieve security at different levels of granularity.
In the current example, I was explaining only the way the annotation works and how to use useful expressions to filter out elements from a collection.
But the truth is that there is nothing particularly unsecure in returning the movies with budgets greater than $5 million to standard users in our current application.
Security Defined in XML Annotation-based security is the most common solution that developers, using Spring Security, utilize when creating their business-layer security constraints.
As with most of the Spring suite of products, Spring Security security can be configured using XML configuration files.
There are supporters and detractors of both types of configurations (annotations and XML), and undoubtedly there are good and bad parts to either.
One very good thing about the XML configuration for securing methods is that it can be applied to more than one method of more than one class at the same time using AspectJ pointcut expressions—the same way you would in the rest of Spring Security’s suite of products.
Here, I will just give you a quick overview to help you use it in our example.
The most common pattern used in pointcut expressions is to match an undefined list of methods based on these methods’ signatures.
Let’s say you want to make all your methods in MoviesService available only to users with ROLE_ADMIN.
For that, let’s remove all annotations from the MoviesServiceImpl class except for the @PostAuthorize one in getMovieByName, as you want to see how you can combine annotation security with XML configuration.
You can combine both methods (annotations and XML) to meet your particular set of requirements.
So your MoviesServiceImpl class should now look like Listing 5-13
Next, you add the required XML configuration to guarantee that these methods are called only by a ROLE_ADMIN user.
For that, you simply add the dependency from Listing 5-14 to your pom.xml.
If you restart the application and visit the URL http://localhost:8080/movies/, you will be redirected to the login screen.
If you login with "lucas", "fernandez", you will receive an “Access Denied” screen (the one you have seen many times before), as this user doesn’t have ROLE_ADMIN.
On the other hand, if you log in with "admin", "admin", you are granted access to the page and will be able to see the movies on the page, which looks like Figure 5-13 again.
You can see how powerful the XML configuration can be in grouping many methods into a single expression to secure them all at the same time.
The AspectJ expression language for pointcuts offers a lot of flexibility to determine which methods to match against.
For example, you could specify all methods named "doSecured" (or any other name) in your application to be secured, or methods that receive a particular parameter type, or that return a particular type.
This is, to me, the less convenient way of securing your methods, as it removes the clarity of the annotations, and at the same time, removes the flexibility of the pointcut XML expressions.
Basically, it just adds XML verbosity in a place where some elegant annotations will do the same job.
This is all the configuration you need to do for securing that one method.
If you restart the application now and visit the URL http://localhost:8080/movies/, the login form will appear on the page.
If you log in with "admin", "admin", you be granted access to the page.
You have effectively secured the method for only ROLE_ADMIN users.
You can use wildcards in the method definitions to match more than one method at the same time.
With this new expression, all methods in the class require users to have the role ROLE_ADMIN in order to access them.
Security Without a Web Layer Even if this chapter has focused on securing the business layer of applications through the use of method-level security, you are still working in the context of a web application.
This is the standard model in which Spring Security is used.
A web front end takes care of the authentication process, and a combination of URL and method security rules and constraints takes care of the authorization process.
The web layer, through the use of all the filters you reviewed in the previous chapter, give you a lot of out-ofthe-box functionality for authenticating users into the application.
Your only job is to configure certain beans in the application context so that you can leverage all this functionality.
However, there should be no reason why you can’t leverage the rest of the Spring Security infrastructure in a non-web environment.
Let’s take a look at how to do this in a simple command-line-based application.
You will reuse most of your current code in the service layer, but you’ll create a thin command-line layer you can use to interact with the system.
First, let’s see what you need to do to make this work.
Spring Security’s web support is focused mainly in the authentication part of security—the part where the user presents his credentials and is correctly identified by the system.
The authentication process’ only concern, as I just said, is to take the username and credentials of a user (normally from a login form, but it can be from many different places), match these credentials to the saved users, and then create a new Authentication object (or, more accurately, one of its many implementations) that will carry all the necessary information of the just logged-in user, including her roles in the application.
So this part is the one you need to change for your command-line interface to work.
You need a way of providing the username and credentials, and then create an Authentication’s implementation object instance when the authentication infrastructure matches this user.
Thanks to Spring Security’s highly modular system, there are many places where you can plug in your new command-line “login” infrastructure, and then leverage most of the logic already provided by the framework.
In the following examples, I will cover the basic functionality of logging in to the application with a fully authenticated user, accessing a secured method, and then logging out.
Everything will be simple and concise and will serve to illustrate the idea.
You can see three simple methods: one to log in, one to log out, and one to execute a random method (parameterless) in a Spring bean.
The idea is that this method will be secured with Spring Security, so you should get familiar behavior when trying to access it with different levels of an authenticated user.
Next, let’s define the class that will actually receive the command-line requests and translate them to invocations on this interface.
This will be your main class, and it will take care of starting the Spring application context.
Remember that previously the application context was loaded and started by a Servlet Listener configured in the web.xml file.
That is a very simple class, which simply loops through accepting command-line commands.
It supports only three types of commands, and you will see them here.
But first, let’s define the class that will take care of the actual authentication process and that will serve as the entry for invoking Spring bean methods.
This class should also be straightforward if you have followed through the book.
It handles all the authentication processing you require for your application.
When it is instantiated by the Spring loading process, it begins by setting a Security Context Strategy to MODE_GLOBAL.
This strategy is only good in this kind of standalone (without a server part) application, where only one user will be using the application at any given time.
Next, you need to configure this object as a bean in the application context.
Let’s exercise the program and see how it works step by step.
Command outputs and exceptions will be truncated if necessary to show only the relevant values.
This flow should be familiar, as it is a simplified version of the flow that happens during Spring Security webbased authentication.
In step 1, you are trying to access a secured resource (a method, in this case) without being fully authenticated in.
The application uses, by default, an Anonymous Authentication, which is not enough for accessing this particular resource.
In step 2, you are trying to log in to the system with the wrong credentials.
In step 3, you are logging in with a correct username and password set.
This time, you get no output in the command line.
In step 4, when you try to access the secured resource again, the framework under the hood will notice that there is an Authentication instance stored in the SecurityContext that has the required authority needed to access the resource.
This is enforced in the standard way you studied before.
In step 5, you simply log out of the application.
The logout process here is simple, you clear the SecurityContext, and then initialize it again with an Anonymous Authentication.
I am simply demonstrating in this step that the logout process had the required effect in the application.
You can see how this simple application is leveraging most of the functionality from Spring Security.
You needed only a thin layer of authentication, working as an entry point, to get access to the full power of the security features that Spring Security offers.
This means you can integrate Spring Security into your Swing, AWT, command-line applications, among other types with relative ease.
It is always good to know that there is a tried and tested framework that can help you address the different concerns in your application.
In the case of security, you should consider Spring Security independently of the application stack you have, as you can probably leverage a lot of functionality from it.
The advantages of AspectJ over Spring are many and I will start to explain them by first explaining briefly what AspectJ is itself.
As we have explained to a certain degree, Aspect Oriented Programming (AOP) is a programming paradigm that allows to separate the crosscutting concerns of an application into their own dedicated modules.
AspectJ is a dedicated Java based implementation of AOP managed by eclipse.org.
AspectJ extends Java with an aspect-dedicated syntax and a new compiler that allows for the weaving of aspects to your applications.
Weaving in AOP parlance, is simply the process in which the aspect functionality is combined with the core business functionality to produce the final working entity that deals with both concerns (crosscutting and core business)
Weaving can happen at a few points in an application.
While Spring AOP focus exclusively in runtime weaving,  AspectJ supports the other kinds of weaving.
This makes AspectJ a more powerful solution (as you are not just limited to intercepting public non static method calls) at the cost of more complexity.
In the majority of cases when using Spring, Spring AOP will be everything you need to use.
This is a very small module which contains only one Aspect and one AspectJ configuration file for load time weaving of the said Aspect.
In the previous Listing, you can see the use of AspectJ syntax (which I won’t explain here as it is outside the scope of the book)
The source code is well commented so you can get a sense of the way it works.
Remember that pointcuts define places that will match a particular piece of code where we want the aspect to execute, and in the code snippet from Listing 5-20, in every pointcut, it is explained where will it match.
We will be using compile time weaving in our example, and we will prove the use of AspectJ by securing a private method in our service layer.
Something we know is not possible with standard Spring AOP.
We will be starting from scratch for this example so let’s do some of the usual work.
Then we replace the pom.xml file with the one from Listing 5-21
This plugin is the one that will take care of the process of weaving the Aspects into the application.
This element will find the already compiled aspect library that we want to weave into our application in the compilation process.
Make sure to save both previous classes in their corresponding package.
In the Service listing you can see that I have secured the private method methodB which is called by the public method in the same class method.
This, as you know, wouldn't have any effect if using Spring AOP.
From the root of the project, and as you have done so many times now, execute mvn clean install jetty:run.
After the application starts, if you visit the URL http://localhost:8080/hello/ you will be shown the login form that we have seen so many times now.
If you were to debug the Service class in both methods (method and methodB) you would note that there is not a typical Spring AOP Proxy around any of them (as we are not using Spring AOP but AspectJ)
That’s it on the cover of AspectJ with Spring Security.
You should have a good idea of when to use this type of security and how to apply it to different layers in your applications.
You should also know the different ways in which you can achieve method-level security, including using annotations, SpEL, and XML.
You saw that Spring Security can be used without a web layer, even when the standard use case is for web applications.
I also covered the use of  Spring Security with the powerful AspectJ library to secure private methods.
Also, you should have a clear understanding of the difference between the authentication and the authorization process.
One of Spring Security’s strongest points is that you can plug different authentication mechanisms into the framework.
Spring Security was built to create, as much as possible, a pluggable architecture model, where different things can be plugged into the framework in an easy and unobtrusive way.
In the authentication layer, this means that an abstraction exists that takes care of this part of the security process.
Among the different authentication mechanisms I will cover are the following:
Most of this chapter deals with explaining how each of these authentication systems work, independently of Spring Security.
Although this gives you certain key details, it won’t be an in-depth explanation.
Of course, you will see how Spring Security implements each of these authentication mechanisms, and you will see that they have many things in common when it comes to the parts of Spring Security they use.
Database-Provided Authentication Database-provided authentication works almost exactly the same way as with the memory-provided authentication users.
The only difference is that the users are stored in the database and not in memory.
This happens at runtime when you define them in the application context configuration file.
To configure the provisioning of users from the database is pretty simple, as you will see.
The first thing you do is define the database schema you need in order to make the authentication mechanism work.
The tables you need to make the authentication work are shown in Figure 6-1
Figure 6-1 shows a simple schema model for supporting authentication backed by a database.
Just by looking at the tables, you should be able to see how they work.
It is basically a one-to-one mapping from the in-memory implementation you have been using so far.
In the USER table, you store the user details—mainly, the username and the password.
In the AUTHORITIES table, you store the relationship between the usernames and the granted authorities for that member—for example, ROLE_MEMBER.
Figure 6-2 shows an extended default option you can use to define groups and establish authorities related to those groups instead of to individual users.
This time, the schema allows you to create named groups and establish authorities belonging to these groups.
At the same time, users now can belong to groups as well, meaning that users can inherit the authorities defined for the groups to which they belong.
By default, the group mechanism is not activated in UserDetailsService.
Note N  For this example project and the rest of the examples in this chapter, unless otherwise noted, you will start with an application configured as follows.
Remember to replace the artifactId property with a unique name for your application.
Replace the generated web.xml file with the one in Listing 6-2
Replace the generated pom.xml with the one from Listing 6-5
Remember to change the artifactId name with the name of your application.
We’ll use an HSQL database, so you need to configure its JDBC dependencies in the pom.xml file as Listing 6-5 shows.
Embedded datasources are a new feature introduced in Spring 3.0
You can use them to define different kinds of embedded datasources (basically, in-memory datasources that run within the Java process where they are used), such as HSQL and Derby.
You can also see here that in the tag you are also allowed to specify SQL script locations you want to execute when the datasource is started up.
The SQL files you are specifying here allow you to create a simple database schema to support the configuration of users and authorities the way you defined them previously in the section.
Using this embedded datasource is very convenient for examples of this type and unit testing your application, but most likely you won’t use them in production environments.
For production environments, you will use full database solutions, such as MySQL, PostgreSQL, Oracle, and others.
Creating the Basic Tables Next you create the two SQL files you are referencing in the configuration file and put them in the root of the classpath.
Later, you will see groups coming into the picture as well.
Everything should be set up now, so start the application:
You should be able to log in and access the URL http://localhost:8080/hello only if you log in with the username car and the password scarvarez.
What is happening here is pretty simple and similar to what you have been working with up until now.
Using Groups To use groups now, let’s modify the users.sql file a little bit and add the lines from Listing 6-9 to it.
Those lines effectively create a group and put the user “car” into that group.
You should also remove the SQL where you insert into the AUTHORITIES table the role for user “car”
The users.sql lines used to create a group and put members into group.
Setting this attribute automatically sets the property enableGroups to true.
The other option, of course, is not to use the XML namespace and instead use the standard bean definition and set the property.
If you restart the application now, you should see the same behavior as before.
This time, however, the behavior internally is different because the group query is the one being executed to retrieve the authorities for the user.
The code that makes this choice in the JdbcDaoImpl is very simple, and you can see it in Listing 6-11
The enableAuthorities property in the first if is automatically set to true in the JdbcDaoImpl class itself.
The advantage of using groups is that it offers a new level of organizing users into the same category and does not relate them directly to particular authorities.
All these authorities can be grouped into the same conceptual group, and at the same time, all users can be grouped into their respective groups.
This means that not all users need to reference all these authorities.
They simply need to be made part of the group.
Of course, a user can belong to more than one group at the same time.
Using Existing Schemas JdbcDaoImpl, by default, is configured to use the database schema and queries you have looked at already.
However, the schema configuration is flexible, and you can adapt your existing database user schema (if any) to be used by Spring Security JDBC UserDetails support instead of writing a custom schema just for Spring Security.
Of course, certain concepts need to exist in your current schema, like a “user” abstraction, an “authorities” or “role” definition, and a “group” abstraction if you will be also using groups.
If you have those abstractions in place in your database, accessing the information from Spring Security’s JDBC support is straightforward.
The first one represents the username, and the second one represents a particular authority.
Here you use the query needed to retrieve users using their username.
The query needs to return three columns in a record: username, password, and enabled.
You will change just some files from the example we are currently working on.
Now restart the application, log in with the username car and the password scarvarez, and access the URL http://localhost:8080/hello.
You should be able to reach the page in exactly the same way as before.
A directory, in general, is simply an organized datastore that allows for easy queries in its particular domain.
For example, a TV Guide is a directory that allows you to find TV shows easily, and a phone book is a directory that provides easy access to phone numbers.
Probably the most widely known use of LDAP-like structures is the Microsoft Windows Active Directory system.
Other LDAP systems are widely used to store the corporate user databases of many companies that serve as the centralized user store.
I will use the same code as in the previous section, but modify it as needed to work with LDAP instead of database authentication.
Remember that in the previous section, I offered a bootstrap application to start working in all the examples in this chapter—including this one.
The first thing to do is configure your users in the LDAP directory.
To do this, you need to understand the LDAP Information Model, which defines the type of data you can store in your directory.
The data in LDAP is defined by entries, attributes, and values.
An entry is the basic unit of information in the directory and commonly represents an entity from the real world, like a user.
Each entry in the directory has an identification known as a Distinguished Name (or, more commonly, DN)
Each entry in the directory also has a set of attributes that describe different things about the entry.
Each attribute has a type and one or more values.
We will use users, groups, and credentials as we have been doing so far.
Commonly in LDAP, the user entry definition is known as People, so we will use that name to define the user entries.
Our user will also use the standard LDAP object class person to define its attributes.
Installing and Configuring LDAP We will be using an ApacheDS LDAP implementation, which is a pure Java implementation.
You need to download and install the ApacheDS server from its web site: http://directory.apache.org/
You should download and install both the Server (ApacheDS) and the Studio (Apache Directory Studio)
The installation process of both tools is straightforward and shouldn’t give you any issues.
The Apache Directory Studio allows you to access and query the server.
The Apache Directory Studio is an Eclipse application built of plugins adapted to access LDAP servers.
Regarding the ApacheDS server, when it is installed (at least on a Mac), it will be started up automatically; however, you also have the option of running the ApacheDS server as an embedded server within the application process instead of having a standalone, independent LDAP server.
We will be using the standalone server in the example.
After installing the Server and Studio, you need to connect to the Server from the Studio.
To do that, go to the File menu in the Studio, select New, and then select LDAP Connection, as shown in Figure 6-5
In the LDAP connection form, enter the values to connect to the local ApacheDS server as shown in Figure 6-6
In the first form in New Context Entry, you choose to create an entry from scratch.
Then, from the list of available object classes in the left panel, you select dNSDomain and click Add.
The idea here is that you are creating the top-level entry from which all other entries derive.
In the next input form, use dc=example,dc=com as the DN name of the context entry, and click Next.
These values (example and com) are the default values for the partition and the top-level context entry included in the ApacheDS server.
These values also partially identify every entry you create in the directory because, as I said before, LDAP follows a hierarchical structure that builds names for entries on top of its parent entries.
The next step is to import your users into the LDAP server.
I will be importing a couple of users using an LDIF file.
An LDIF file is a text file that uses LDIF formatting, a standard format for describing directory entries in LDAP.
It allows you to import and export your directory data into or from another LDAP directory in a standard way or just to create new data or modify existing data.
You use it here to import the data with your users.
You can see in Listing 6-5 the hierarchical nature of the directory and how everything inherits the DN dc=example,dc=com.
You can also see how the different entries use different standard object classes.
You also established that “car” is a member of the “users” group and “mon” is a member of the “administrators” group.
The password for both users is “scarvarez.” In this example, they are shown in plain text, although they could easily be stored in encrypted form.
Graphically, the hierarchy is simple enough and looks like Figure 6-9
The next thing you need to do is configure the example application to be able to connect to the LDAP server and query the information stored on it.
You have a clean application at the moment, with only the bootstrap components.
First, you add the Spring Security LDAP dependency to the pom.xml file.
Listing 6-7 shows all the configuration needed to make your application work with LDAP-based authentication.
If you restart the application now with that configuration, you should be able to access the URL http://localhost:8080/hello only if you log in with the username mon and the password scarvarez.
If you log in with the username car and the password scarvarez, you get an “access denied” message.
The element <ldap-server> allows you to configure the LDAP server you will be connecting to from the application, and here, you are specifying the local ApacheDS server you configured in previous steps.
You also specify the Distinguished Name you will be using as part of the connection URL in this same <ldap-server> element.
This is basically the root path of your directory, as you specified before.
Remember that all your entries will be relative to the domain name dc=example,dc=com.
The attribute group-search-base specifies the base for where it will start to search for group membership.
It will look inside the hierarchy starting in this base for the groups defined.
Figure 6-11 shows a graphical description of the process, up to the point of creating a successful Authentication object.
This namespace offers some more attributes and elements you can use to configure different parts of the integration.
When this element is used, a different kind of authentication process happens in the application.
The Spring namespace parsing process takes care of instantiating this class instead of the BindAuthenticator.
The BindAuthenticator, as I said before, uses the standard bind functionality in LDAP to authenticate the user.
The <password-compare> element accepts a couple of attributes and one child element:
If both are specified, the hash attribute will be ignored.
Using the hash attribute can be thought of a shortcut for the standard digest algorithms, and internally it creates a password encoder.
Default password encoders that can be configured using the hash attribute on <password-compare>
As you can see from the example, configuring LDAP’s basic support as the authentication solution for your application with Spring Security is not that complex.
In fact, it is very straightforward thanks to the modular architecture and the well-thought-out XML namespace.
Although it is a simple hierarchical system (very much like the file system in your standard Unix box), some of the nomenclature and functionality seems a bit complex and very different from the database-based solution you explored in the previous section.
As I said before, using LDAP as your authentication solution makes great sense in the context of corporate intranets, where the company user base is already stored in LDAP-like directories in a centralized manner.
Plugins into this already existing user-management infrastructure are a good way to reuse the user information within the company instead of writing a parallel authentication datastore that then needs to be kept in sync with the main repository.
Authenticating with OpenID OpenID is an authentication solution that exists to address the problems inherent in having many user accounts in many different sites with many different sets of credentials.
It is common on the web for a user to be registered with many sites and applications at the same time.
Most of these applications, when you try to access them, ask you to authenticate against them directly—normally, asking you for a username and a password to access their functionality.
This is an obvious problem in terms of inconvenience and security.
OpenID allows users to rely on unique single authentication account to access different web sites.
In this way, it reduces the inconvenience of maintaining multiple accounts on multiple web sites.
Also, it reduces the risk of a password being compromised on any external site, because the OpenID identity provider manager is the only one that will know about your password.
There are many OpenID providers, including Google and Yahoo, as well as dedicated ones like myOpenID, which is the one I will use in the example.
As I have been doing so far in the book, I will explain the concepts as I am developing the example.
Once again, we will use the simple application we have been using in the other examples in this chapter, with the required modifications needed to support OpenID authentication.
These libraries are the Spring Security OpenID module and the nekohtml (available at http://nekohtml.sourceforge.net/) library, which is used internally by the openid4java library (which is used by Spring Security and is resolved as a transitive dependency) for parsing HTML.
Configuration file for a Spring Security application with OpenID enabled.
The password is stored only in the OpenID provider environment (MyOpenID)
The strange username of http://carlo8172.myopenid.com/ is my OpenID account identifier.
If you open an account yourself, it will be very similar to this one.
You might find it a bit strange to define the user in the application in the <user-service> element if it is already defined in the MyOpenID site.
The reason is that, as I said before, you need to specify the authorities that your users will have within the application and you cannot do that in the OpenID provider because it provides only an authentication mechanism.
What you could do, however, is autoregister the users after they authenticate successfully with the OpenID provider and assign them a particular user role.
For example, many applications use only one generally available user role that is common to all the users that access the application.
In this case, you could simply assign that role by default to the user after she has been successfully authenticated by the OpenID provider.
This is a common way of working, and the Spring Security source code includes an example that shows exactly this kind of behavior by implementing a custom UserDetailsService for use with the LDAP authentication provider.
The User Datastore is populated when the user is succesfully logged in with OpenID.
Default login form now includes the option to log in with OpenID.
You should get to a page that looks like Figure 6-13, which presents you with a login form that has a new text field.
In the new Identity text field, I type my OpenID identifier http://carlo8172.myopenid.com/, and then click the second Login button.
I get redirected to the MyOpenID site, which shows me a form to type in my password.
The MyOpenID site asking me for my password to authenticate me.
After I correctly enter my password in the MyOpenID site, I get redirected back to the application.
Now, if I visit the localhost URL /hello, I get the familiar “Hello World” message, meaning that I have been correctly authenticated and the correct authorities have been assigned to my user.
This time, however, the filter sees that OpenID is enabled in the application and generates one extra form like this:
The form has a text field for entering the OpenID identifier like this:
The filter then extracts the parameter openid_identifier from the request.
With the username it uses the openid4java library to discover the OpenID server provider to which the authentication.
Then it creates an OpenID authentication request with this information and redirects the response to the corresponding OpenID provider site.
However, this time the URL contains a set of parameters that MyOpenID has included in the invocation.
This parameter was added by the OpenID provider, as I just said.
Then the information sent by the provider is verified to see if it was successful.
As normal, the Authentication gets stored in the SecurityContext of the running application.
When you visit the URL /hello again, the normal process of authorization will start.
The authorities for the user match those required by the requested URL, so access will be granted to the URL.
Spring Security OpenID Namespace Spring Security’s OpenID namespace configuration provides other attributes and elements that enhance the functionality you have seen up to this point.
This element is used to use the OpenID Attribute Exchange (AX) functionality.
The AX functionality of OpenID allows for the interchange of information beyond simple authentication between the communicating endpoints of the authentication process.
For example, you could use it to fetch data from the OpenID provider or to store data.
I will show you how to configure it to retrieve some extra data when you are using the authentication process.
I will configure it to retrieve the email of the logged-in user.
This allows you to add information to your account profile in the MyOpenID provider.
After you add the information you want, it should look something like Figure 6-15
After you add this information to your account on the OpenID provider, you can ask for this information back when authenticating against it.
For example, let’s say that you want to retrieve the email of the user attempting to log in.
Attribute exchange configuration for fetching the email of the user.
Listing 6-10 shows how to retrieve a particular attribute from the OpenID account when logging in.
You can see that the type attribute specifies a particular URI that identifies how to retrieve this value in the particular OpenID provider.
I say in the “particular provider” because although there is some effort to standardize the AX attributes, each provider often uses different ways to refer to the same things.
The name attribute specifies the name that the attribute has in the local Authentication object after it is retrieved.
If you restart the application now and do the whole authentication process again, this time your email will be returned with a successful authentication with the OpenID provider.
As I said before, there are many other OpenID providers out there, including Google and Yahoo, and they work in a similar manner to what you saw in this section with MyOpenID.
The main difference, in many cases, is that the user identifier URI related to each of the providers.
Using this approach, a scheme known as mutual authentication takes place between the client and the server.
In practice, mutual authentication means that, as part of the Secure Sockets Layer (SSL) handshake, the server requests that the client identify himself by providing a certificate.
To work with client certificates, the application needs to be configured to use SSL channels in the sections that are expected to deal with the authenticated user, because the X.509 authentication protocol itself is part of the SSL protocol.
In Chapter 5, you configured the example application to use SSL channel and configured the pom.xml to be able to run a Jetty server with SSL support.
Here, I build on that example’s pom.xml file to explain the client-certificate solution.
You need to add a couple of properties to the Jetty plugin configuration.
Look at the properties wantClientAuth and needClientAuth that are configured in the last part of the plugin configuration.
The first thing you do now is to enable X.509 authentication on the Spring configuration file.
This element is all Spring Security needs in order to do its part of the work in activating the client-certificate authentication mechanism.
This is all the configuration Spring needs to handle client certificates.
Of course, things are not that simple and the job is not yet done.
In reality, Spring Security X.509 support doesn’t authenticate the user.
The user is assumed to be already authenticated, and Spring Security simply creates a successful Authentication object with information extracted from the certificate and stores it in the SecurityContext in the standard way.
So the entity that is actually in charge of authenticating the user (or more exactly accepting the user as a properly identified one) is the web server, which does this by accepting the provided client certificate.
Basically, if the server decides that the certificate sent by the user is a valid one, the user is who she claims to be and gets authenticated.
In a production system, the web server makes sure that the certificate provided by the client is signed by an authorized trusted authority.
However, we will use a test environment with our common Maven-configured Jetty installation, and for that we will configure a self-signed certificate and make sure that Jetty accepts it.
It is pretty straightforward to do, and we will use the openssl tool to do it:
Generate a certificate by executing the following command and pressing Enter at every prompt:
When executing that last step, it is important that when asked to introduce your name by the command-line prompt, you use the name “car” because that is the username you configured in the application configuration file.
The next thing you need to do is to make Jetty trust the certificate authority associated with this certificate.
Note N  A truststore is a repository of certificates that are trusted by the JRE that uses such a truststore.
By default the JRE truststore trusts any certificates signed by a recognised Certificate Authority (CA)
If you have a certificate not signed by a CA (like the self signed certificates) you will need to add it manually to the truststore so the it can be trusted.
The execution of that file is shown in Figure 6-18
Next you need to add the certificate to the browser you will use to connect to the application.
The first thing to do is create a p12 file that contains information about the certificate and the private key associated with the certificate.
This is the file needed by the browser to identify the user.
To generate that file from the command line, in the same directory where you previously generated the key and the certificate, execute the following command.
To import that file into the client certificates of Firefox, do the following.
This example is on a Mac computer, and it should be similar on other systems.
Locate client.p12 in the directory where it is stored, and double-click it.
The certificate is imported, and you should see a screen like Figure 6-20
Finally, the configuration is complete, and the application is ready.
The browser is also ready for the mutual authentication process to get underway.
You need to accept the self-signed certificate from the server to continue.
After you accept it, you will be presented with the screen shown in Figure 6-21, which asks you to select the certificate to use to authenticate.
Only one option is available: the certificate you just imported.
Most of the process is dealt with by the web browser and the web server SSL communication establishing the mutual authentication scheme.
There, it finds the whole client certificate sent by the browser in the request.
This is why it was important to use the name “car” when asked in the command prompt.
This provider uses the configured UserDetailsService to retrieve the user for the application using the username from the Authentication object.
In the example, it uses the in-memory UserDetailsService you defined in the application file.
That is the whole flow that is followed by a request using client-certificate authentication.
As you can see, Spring Security support for it is pretty straightforward.
You can use JAAS as another authentication provider in Spring Security.
The LoginModule extracts the username and password from the user (or uses a different kind of providing mechanism), and then verifies these credentials.
Those are the main steps for authentication with JAAS, and Spring Security can take care of this process with the use of the supplied JAAS authentication providers and some other helper classes.
You need to implement a simple LoginModule that will take care of the actual authentication of the user.
You will use a map as your user and password storage.
I will show you how to modify the code from the previous sections to adapt it to the JAAS authentication mechanism.
No specific dependencies are needed because JAAS support in Spring Security is in the core module.
Listing 6-13 is not as simple as the files you used in previous sections.
For a start, you are using standard Spring bean definitions instead of support from the XML namespace, because there is no XML schema for JAAS configuration.
The only high-level bean you need to define is for the authentication provider implementation you want to use.
The properties you defined in this bean are all important, and here is what they specify:
The pss_jaas.config file that specifies the class implementing LoginModule in the application.
If you restart the application now with all this configuration in place and try to access the URL http://localhost:8080/hello, you get the form to log in that you have seen many times before.
If you log in with the username car and the password scarvarez, you should be able to access the “Hello World” page as in the previous examples.
The preceding code is very simple, and all it’s doing is simulating a user data store with an in-memory map.
Then it assigns the role ROLE_ADMINISTRATOR to a user “car.” The only method that it is implementing from the interface grant is in charge of returning a java.util.Set of authorities given a username.
Listing 6-16 shows the main class you need to create to support JAAS authentication with Spring Security.
It is the main class in the JAAS authentication scheme because it is the one that takes charge of the real authentication of the users into the application.
People or companies that want to implement a custom authentication solution to be plugged into JAAS definitely need to create an implementation of LoginModule.
In our implementation, you can see the use of some of the concepts I was talking about in previous sections, like the Callbacks and CallbackHandler implementation classes.
NameCallback and PasswordCallback are standard classes in JAAS that will eventually be called back with the contents of username and password, respectively.
The CallbackHandler implementation is in charge of retrieving the credentials needed to authenticate the user.
It then makes sure the relevant callbacks are called in order to populate the needed information for the rest of the process.
After the CallbackHandler returns, the Callback classes will have the required values set in, and you can extract them and store them for later.
When the login method is called, the introduced user details are easily accessible in the instance variables.
In the example, this simply means making sure that the pair username-password exists in the in-memory map of users defined in the static variable USER_PASSWORDS in the class.
If a match is not found, a LoginException is thrown indicating the authentication failure condition.
If a match is found, the principal is stored and the execution continues normally.
However, the main concepts are the ones I showed you, and the goal of the section is to show the building blocks for integrating it with Spring Security.
Central Authentication Service (CAS) Authentication As you can see from the Spring Security source code I presented a few times already, there is a module dedicated to CAS authentication.
It has a great supporting community and integrates into many Java projects.
Understanding the ideas behind CAS (and indeed any other single sign-on solution) is not difficult.
Although I’m not going to explore CAS in detail, there are a few main concepts you need to know about the CAS system to understand better how the upcoming example works.
Those three elements illustrate the concepts from the following examples and explanations.
One important characteristic of CAS is that it is designed to serve as a proxy to different authentication storage.
This means that it can be used in combination with LDAP, JDBC, or a few other user stores that contain the real user data.
This looks a lot like the way Spring Security leverages these same user data stores.
In this section, you will use CAS to authenticate your users in applications.
As of this writing, the current version of CAS is 3.5.1, and that is the one you will use here.
The first thing you will do is download the latest version from its home at http://www.jasig.org/
After you download it and uncompress the file, you will find a folder inside the main folder named modules.
You will be using Jetty here again and to make things simple, you will use Jetty from Maven the same way you have been doing all along.
However, this time you will run the war file that is provided by CAS.
To do this, create the pom.xml file from Listing 6-17 in a directory of your choosing.
Remember to replace the path to the war file with the one that applies to your installation.
A pom.xml file used to run the CAS war application.
Note N  Single sign-on is a scheme that allows related applications to share the same user login session.
A user authenticates once in the central single sign-on authentication provider and as long as she remains authenticated on the system, she can log in to all the other applications without being asked to provide her credentials again.
Also, the other applications don’t need to know the user password.
If you now execute mvn keytool:genkey followed by mvn jetty:deploy-war from the directory where you have this new pom.xml file, the default demo application of the CAS server will execute.
This war file demo application allows users to log in by matching their username and password.
For example, you can log in with the username car and the password car.
Log in with the username car and the password car, and you should get a successful login as shown in Figure 6-23
Let’s create an application now that supports CAS authentication with Spring Security.
First let’s set up the application , and then I will explain how everything works:
From the command line, execute the familiar Maven command to create a new web application:
Replace the generated pom.xml file with the one shown in Listing 6-18
This one contains the proper dependencies and the proper Jetty plugin configuration to run the application.
Create the web.xml file from Listing 6-19 in the WEB-INF directory of the created application.
This file, as we have seen many times, has the listener to set up the Spring context.
This is a simple servlet that you will secure next.
This file contains the configuration for CAS security that I will explain next.
I will explain the elements from the previous XML a bit later.
But first we need to make a couple of configuration changes in the SSL elements of our application to be able to run everything together:
First, from the root of the CAS runner you created (wherever the pom.xml from Listing 6-17 is), run the following command:
That command creates an X.509 certificate that you need to include in the trusted certificates of your JRE so that other applications using the same JRE automatically trust this certificate.
To import the certificate, run the following command from that directory:
Next, from the root of the application you will use to test, you need to run the following command so that it generates the key you need to set up its SSL environment:
Then in the root of the example application execute mvn jetty:run and wait for the application to start.
You will get the page shown in Figure 6-24 automatically, which means that the application redirected to the CAS web site to handle the authentication.
Look at the URL in that figure and notice how it contains information that points back to the URL of the example application.
This is the callback URL that CAS will call when authentication succeeds.
Now log in with the username car and the password car.
Now let’s see exactly what is happening under the hood:
When you first request the URL http://localhost:8080/hello, the request goes through the security filter chain, as always.
Of course, you also defined a “casEntryPoint” bean in the same configuration file.
You can refer to this file back in Listing 6-21
As you can also see in the built URL, the method concatenates the jsesssionid, of the current user session, into the callback URL.
The application then redirects to this URL, which shows the CAS login screen.
After you log in to CAS, you are redirected back to the callback URL.
The first thing it does is check whether the request needs to be authenticated.
So the filter knows it needs to process this request.
You can see from the previous step that the parameter does exist.
So the filter extracts this parameter and uses it as the value for the user password.
When this URL is called, the CAS server internally validates the ticket and the service and then it returns an XML like the one shown in Listing 6-22
AssertionImpl, which contains the successful status and the principal name.
After you have the fully authenticated Authentication object, the flow continues as normal.
Not everything is covered, just the most important parts in the interaction with the CAS server.
Integrating CAS with a Different Authentication Provider As I said before, CAS is designed to support the integration of different back-end user storage mechanisms, including JDBC, LDAP, and others.
Currently, we are using the demo version of CAS, which matches users anytime you use the same username and password as you have been doing with “car.”
Because I am not going to explain CAS in any more depth than necessary, this part can be thought of as a bonus.
Let’s configure CAS to use file system user storage, which is probably one of the easiest things to configure.
You will get a nice surprise when trying to configure CAS, and this surprise is that CAS is configured using Spring.
So, many of the things you have learned regarding core Spring apply to configuring the CAS server.
In the pom.xml of the CAS runner, replace the line that points to the war file with the path to the newly generated war.
The CAS runner and the example application (remember to run them with the commands mvn jetty:deploy-war and mvn jetty:run, respectively)
Log in with the username car and the password scarvarez.
The same (but with different authentication handlers) can be done for LDAP, JDBC, and others.
Summary In this chapter, I showed you how you can use Spring Security’s modular architecture to integrate different authentication mechanisms with relative ease.
I explained some of the authentication mechanisms that come with the framework.
In particular, I showed you how to authenticate your users against a database, an LDAP server, and an OpenID provider, and by using Client X.509 Certificates and leveraging Java’s standard authentication system, JAAS.
This chapter focused on showing how all these different authentication providers relate to each other when they are used inside the framework.
The goal was to show you that integrating new providers into the framework is simple enough for you to try.
Of course, how easy it is depends on the authentication scheme that you want to plug in.
There are more authentication providers that I haven’t covered in the chapter, but the main ideas tend to remain the same: create a connector into Spring Security that deals with the particulars of the integrating protocol, and adapt it to use the Spring Security model of authentication and authorization.
This chapter will introduce access control lists (ACLs) in the context of Spring Security.
Access control lists can be thought of as an extension to the business-level security rules that we reviewed in.
In this case, however, we’ll be looking at more fine-grained rules to secure individual domain objects, instead of the relatively coarse-grained rules used to secure method calls on services.
What this means is that ACLs are in charge of securing instances of domain classes (such as a Forum class, a Cart class, and so on), while the standard method-level rules secure entry points determined by methods (like a Service method or a DAO method)
The idea is that any user will have a certain level of access (read, write, none, and so on) to each domain object.
A user’s level of access (permissions) to a particular domain object depends on the user, or the role or group to which the user belongs.
As in other chapters, I’ll try to explain each concept as I walk through an example.
The example I’ll be working on is, as usual, a very simple and not real-world application pared down to focus on the concepts relevant to understanding how ACLs work.
The Security Example Application The example application will be a simple forum system with two types of users: standard users and administrator users.
Any user can create a forum entry, but only the user who created the entry can edit it; the other standard users can only read it.
Administrator users can read or delete an entry, but they cannot edit it.
I think this give us all the combinations we need to show the full power of ACLs.
The action is shown with a solid line and permissions are shown with a dotted line.
The first thing we’ll do is review the required database schema to support ACLs in the application.
It will be in the src/main/resources folder in the source code, which means it will be in the root of the classpath.
To understand the meaning of these tables, you need to appreciate the main abstractions in SpringSecurity’s ACL support:
Let’s break down the database tables into their main attributes to see their meaning.
I won’t explain the ID attributes because they are the surrogate identifiers of each row in the pertinent table, and they serve to, well, identify the particular entry.
Figure 7-2 shows the tables in graphical form followed by the explanation of the attributes.
Here are the main attributes (columns) in the tables from the previous figure:
You can easily create your own class and define extra permissions if you want to do so.
The BasePermission class with the default permissions to use in the ACL system.
You can see that there are not a lot of tables defined in the schema, but it is important that you understand them individually and their relationships.
The diagram describes the meanings of the relationships between tables in simple terms.
This class can be replaced with a custom Permission implementation class that includes different permissions, or it can be extended to include more permissions.
In theory, working this way allows for the permissions to be easily combined to create composed permissions by adding two of them together.
So you normally have to include an ACE for READ and another one for WRITE.
You should now have an understanding of the main concepts used in ACLs and how they map to the database schema that the framework itself provides.
Then, in the generated pom.xml file, add all the required dependencies that I show you in Listing 7-3, which includes the new ACL dependency.
You also need to include in the pom.xml file, the configuration for the jetty plugin we have been using up until now.
So, in the plugins section of your pom.xml file, add the code from Listing 7-4
The next file to create is the ACL configuration file, so let’s do that.
Later, I’ll show you that some things could be changed to adapt to different needs.
After the listing, you will read a description of the relevant parts.
Let’s give an overview of each of the beans defined in Listing 7-7
Later, when using the application, I’ll offer a more in-depth explanation of the inner works of the framework and exactly what is going on both at startup and at execution time.
The bean that creates the database tables needed for working with ACLs.
The first three beans are not ACL specific because they simply define a data source, a JDBC template, and a transaction manager.
These beans will be used by the ACL infrastructure to access the ACL-specific tables and data in the schema.
Note N  The support beans for working with databases that we defined use classes from the Spring Framework core libraries.
If you have worked with Spring before, you most likely have encountered and used these classes.
You can find information about Spring database support on the official site http://static.springsource.org/spring/docs/3.0.x/reference/jdbc.html.
The next bean I defined is the one with the ID "aclCache"
You need to have a cache implementation for the ACL system to work.
Its function is to make ACL accesses faster by caching the ACLs and not accessing the database for every single query.
The next bean is the one with the ID "lookupStrategy"
A lookup strategy is in charge of retrieving the object identities (as explained before) and the ACLs that apply to each of those object identities.
It will try to load the ACLs from the cache, and if they are not there, it will look them up on the database and cache the results.
The lookup to the database is done in batches so that many items can be loaded to the cache at the same time to improve performance.
The default implementation we are using in the bean definition file receives in the constructor three instances of GrantedAuthority, which determine the entities that will have the permissions mentioned before.
In our example—and, in general, this is the most common approach—I am setting the ROLE_ADMIN to be the one that will have the mentioned permissions.
The last bean, with the ID "aclService", is the main component of the whole framework.
The interfaces AclService and MutableAclService allow access to all the ACL-related operations, such as reading ACLs by ID, creating ACLs, deleting ACLs, and updating ACLs.
These are all the beans needed in the application to work with ACLs.
As always, you need to make the file from Listing 7-6 load up with the application.
In case it is needed, the web.xml I provided already has the appropriate configuration.
Now let’s make a bean to create the database schema for ACL.
You normally will not do this in a standard application, but we’ll do it here just for convenience.
The file is provided in the source code of the book.
If you want to create it yourself, simply take the one that comes with the framework and uncomment the beginning lines that have the commented “drop table” statements.
Remember that the database is an in-memory HSQL database named aclexample that we.
This bean will be instantiated by the context as normal when starting up, and the constructor will take care of setting up the schema.
Now we can create ACLs for domain objects, so let’s create our classes to set up the whole process.
This will involve a bit of coding because we’ll need a controller, service, domain object and JSP file.
A simple domain model that we’ll use for trying ACL rules.
The form.jsp file with a form for a new post and a list of existing posts.
The first version of the controller shown in Listing 7-9 allows us to show the form to create new posts and has the action to actually post these new posts for them to be saved.
Later, we’ll add to this controller to support more functionality.
Listing 7-10 has the core functionality for creating an ACL for a domain object instance.
In this case, we are creating a new Post object.
The Post instance is stored in a memory map (which is not a realistic example, but is enough to show the functionality)
The ACL is created using the hash code of the Post instance as the ID of the domain object.
Then we create three ACEs (access control entries) for the ACL.
In the first one, we specify that the ADMINISTRATION permission is granted to the creator of the Post, given by the SecurityContext’s principal.
You can also see that the method is marked as @Transactional.
The ForumService interface that is implemented by ForumServiceImpl is simply defined as the following:
Note N  Keep in mind that the last code sample of the class ForumServiceImpl is just an example of the functionality for populating ACLs for a particular domain object.
I'm saying this because in a real application, you would probably move the security-related code away from the core business methods and not mix them together the way we are doing here.
You could create an aspect to deal with this or simply another helper service you can call to take care of all the ACL functionality.
After you put the form.jsp file in the WEB-INF/views directory, the application is almost ready to run.
When you start the application, navigate to the URL http://localhost:8080/forum/ and log in with username car, and the password scarvarez.
You will be shown a very small form with just a text box.
When you submit the form, it will be stored on the map and the corresponding ACL will be stored on the database.
You won’t see that on the screen, but it is happening.
You could use a SQL client to look at it.
What is happening under the covers inside the framework is simply the execution of some SQL scripts that are in charge of populating the tables mentioned before with the corresponding data.
The ACL system offers the APIs that can be used to manipulate this data using classes, which you can see in the ForumServiceImpl class.
Internally, all the requests are translated to SQL instructions against the configured database.
It’s also worth mentioning that among the internal workings of the framework is the use of the authentication’s principal as the owner of the ACL and the caching of the ACLs after they have been persisted to the database.
Accessing Secured Objects The next logical step is to make sure the rules are actually working by trying to access the created posts.
To do that, we’ll set up a couple more users and finish our service and controller so that they handle the new options.
Remember that we are re-creating the database every time we restart the app.
Again, that’s not what we want in a production environment.
Also, the posts are in an in-memory map, so they are lost when we shut down the application.
So let’s make all the code changes now step by step.
You need to create an AclEntryVoter instance for each of the operations you want ACLs to vote on.
For example, in our case, we’ll create three voters: one for voting on reading access, one for voting on update permission, and one for voting on delete permission.
Listing 7-15 shows the definition of these three voters, followed by a more comprehensive explanation of their work.
The AclEntryVoter(s) that correspond to the delete, read, and update actions.
We have three voter beans; however, to analyze one is to analyze them all.
When you define an AclEntryVoter, you need to pass three arguments to its constructor.
The first argument is a reference to the AclService we defined earlier, and the second parameter will be mapped to a config attribute name.
I talked about config attributes earlier in the book, so here I’ll just say that they are the attributes that Spring Security looks for in the @Secured annotation in order to use them when intercepting methods.
In the case of the AclEntryVoter, we are specifying exactly which config attribute that particular voter will support.
The third parameter that we pass to the AclEntryVoter constructor is the permission needed to allow access to the particular operation we are trying to perform on the object.
If it does, it will vote to grant access; if it doesn’t, it will vote to deny access.
I’ll explain this in more depth a little later when executing the application.
It’s as simple as adding the two beans shown in Listing 7-16
We are using an affirmative-based access decision manager, and we are injecting the three voters in the decisionVoters property.
Remember to update the ForumService interface as well with the new method.
Before doing so, you need to update the ForumController, adding the method from Listing 7-18
You also need to replace the form.jsp file with the content of Listing 7-19
Then if I click the delete button, the application redirects me to the familiar login screen shown in Figure 7-5
This is what happened here: When I clicked the delete button, the request got all the way to the AffirmativeBased access decision manager, as I explained in previous chapters.
One of the voters will get into action—the one dealing with ACL_POST_DELETE config attribute.
In our case, it is found, and it is actually the only parameter that the deletePost method expects.
If the object that arrives in this parameter is null, the voter will simply abstain from voting.
The next thing the voter does is try to retrieve an ObjectIdentity instance from the domain object.
This strategy simply invokes the constructor of ObjectIdentityImpl that receives a domain object as its only parameter.
This constructor in ObjectIdentityImpl assumes that the domain object provides a getId method to be able to retrieve the identifier for it.
If the method is not there, a corresponding exception is thrown.
Our Post class has such a method, so this works fine—invoking that method and setting the return value as the identifier of the ObjectIdentity.
After obtaining the ObjectIdentity, the voter tries to retrieve the SIDs from the Authentication object.
The next step for the voter is to retrieve the actual ACL for that particular ObjectIdentity and the SIDs.
It does this with the help of the configured AclService, which I already talked about.
In the next step, the retrieved ACL is consulted by its isGranted method to see whether or not access should be granted.
If it finds a match, it allows access; if it doesn’t find any match, it rejects access by throwing an exception, which is caught by the voter to return ACCESS_DENIED.
In our case, because the current authenticated user is ANONYMOUS, this whole flow is what happens.
The same thing as before is happening: the logged-in user car and its roles ROLE_USER don’t match the rules required to execute the deletePost action on that particular post.
As I said before, only a user with role ROLE_ADMIN can delete the post.
First I log out by visiting the URL http://localhost:8080/j_spring_security_logout, and then I log in with the username mon and the password scarvarez and try to delete the post again.
This time, the Acl.isGranted method returns true and the voter returns ACCESS_GRANTED because the match exists between the role of the authenticated user and the authorities required to perform the required action.
This means that the code execution will finally reach the deletePost method in the ForumServiceImpl.
This is a very simple method that removes the entry from the ACL for that object and, of course, deletes the object from the store.
Remember, we are using a java.util.Map as our in-memory store, which is not the most realistic simulation but works for the purposes of the example.
Figure 7-6 shows the most important aspects of the process I just explained.
Filtering Returned Objects So we successfully tested the DELETE action with a Post domain instance that should be allowed only to ROLE_ADMIN users.
Let’s secure the READ one so that only users with role ROLE_USER can read them.
Normally, your users wouldn’t need to have both roles defined, but for the sake of the example, it is OK to do it this way.
In our example, we want to secure the method getPosts in the ForumServiceImpl class in such a way that when the posts are returned, they are filtered out by the rules explained in the last paragraph.
If you are following along with the code, you should change all the classes and files that depend on this method, including the form.jsp file.
The getPosts method now returns a collection of posts and not the map.
Next, I’ll explain how it works, in the context of an execution scenario.
However, first we need to configure a couple of beans manually in the application context to allow the correct evaluation of permission expressions.
We need a bit of work to configure it, but it is not that difficult.
First, we need to define the bean that will be the new ExpressionHandler.
If you are following through in the code, you should restart the application now.
After the application is restarted, if you visit the URL http://localhost:8080/forum/ and create a post, you will see that the post won’t be shown in the page.
This is because you created the post as an ANONYMOUS user.
Remember that posts now will show only for ROLE_USER users.
If you log in to the application with the username car and the password scarvarez and again go to the URL http://localhost:8080/forum/, you will see the post in the page and the delete button.
The following paragraphs explain how it all works under the hood.
As you probably recall as well, the interceptors work in a pre-process, process, post-process flow.
The actual business logic happens in the “process” phase, and both the “pre-process” and “post-process” phases are used for the framework itself to apply all the security concerns, regarding authorization and access control, that are needed to secure the application.
The “pre-process” phase is taken care of mainly by the access decision managers and the access decision voters that decide whether or not access should be allowed to a particular resource (be it a method, a domain object, or a URL)
This handler checks that the returned value from the business method with the @PostFilter annotation was indeed a collection or an array (and throws an exception if it wasn’t)
Then it iterates through this collection, evaluating the SpEL expression on each object and discarding the object to which the evaluation of the expression gives the value false.
This method (hasPermission) uses the permission evaluator we defined in Listing 7-22 to decide if the authentication has the required permissions on the object being passed.
This evaluator uses the same suites of classes and helpers that the AclEntryVoter uses to decide whether or not to grant access, such as the AclService and the method isGranted in the ACL interface.
When we tried to access the list with the anonymous user, the only existing post was discarded from the return elements because the user didn’t match the permissions required to read the object.
When we logged in as car, scarvarez, we acquired the role ROLE_USER.
This role is indeed allowed to read post objects, as specified by the ACL rules that we created when we first created the post.
Let’s see how filtering works in an example with more than one post.
This time, we’ll create a post with a user with the role ROLE_ADMIN.
We’ll modify the post creation code so that when an Admin user creates a post, only other ROLE_ADMIN users can read that post.
To do that, change the createPost method in the ForumServiceImpl class to look like Listing 7-23
This listing (like many others in the book) takes an approach of preferring convenience over particularly good design.
For example, you might argue, and rightly, that the ACL mutation is not part of the core createPost method business functionality, and also that hardcoding role names in the code is not right.
Again, I’m doing this to illustrate concepts in a convenient way, without too much abstraction and directly to the point that I’m trying to show.
In a real environment, you should try to achieve a good separation of concerns, giving the security concerns their own space (whether using AOP or other methods) and leave the business method to handle, well, business concerns.
The createPost method that creates different ACLs depending on the user that is creating the post, along with a needed helper method to check whether the logged-in user has the ROLE_ADMIN role.
You can see in the listing that we added a conditional saying, basically, that if the logged-in user is an Administrator, the READ permission will be available only to other Administrators (users with the role ROLE_ADMIN)
If the logged-in user is not an Administrator, the READ permission will be available to any user with the ROLE_USER role.
I’ll now show an execution of this new configuration step by step.
Test Scenario 7-1 To execute this new configuration, I used the following steps:
I restarted the application, and then visited http://localhost:8080/spring_security_login and logged in with the username car and the password scarvarez.
The sceen that is generated after an admin user creates a post.
I visited the URL http://localhost:8080/j_spring_security_logout to log out of the application.
I visited the URL http://localhost:8080/j_spring_security_logout to log out of the application.
Then I visited the URL http://localhost:8080/spring_security_login and logged in with the username bea and the password scarvarez.
The screen that is generated after a user with the role ROLE_USER creates a post.
I visited the URL http://localhost:8080/j_spring_security_logout to log out of the application.
Then I visited the URL http://localhost:8080/spring_security_login and logged in with the username car and the password scarvarez.
I just showed you a simple walkthrough of how this ACLfiltering functionality works in practice.
You can see that by providing only the @PostFilter annotation with the hasPermission expression (which, as you know, internally calls a method in the SpEL context), we are instructing the framework what to do with the returned values of the method.
The diagram shows how parameters and return collections of domain objects are filtered out on the way in and out of the method.
A diagram showing the main classes and interfaces in the pre-processing phase of a method interception with ACL-based security.
A diagram showing the classes that participate in the post-processing phase of a method interception with ACL-based security.
You can see that these two branches map almost one to one to the branches in the pre-processing phase.
Also, you can see that there is a high level of reuse in the system and that many classes are present in both the pre-processing and post-processing phases.
I covered two different ways to handle ACL security, with the two branches I talked about in the previous paragraph.
They are newer options that support the use of SpEL expressions, so you will probably favor these over the other ones in your day-to-day use.
Securing the View Layer with ACLs Another option you have for using ACLs to secure applications is to use the view-layer JSP tags to filter out domain objects for users who don’t have the proper permissions to see them.
I talked a bit about these tags in the web security chapter, but I intentionally left the ACL tags for more thorough treatment here.
To use them in an example, let’s continue with our code from the previous section, but let’s make a couple of changes.
First, in the ForumServiceImpl class, comment out the @PostFilter annotation in the getPosts method so that it doesn’t filter out anything anymore.
Then change the form.jsp file to look like Listing 7-24
The form.jsp with taglib ACL security applied for filtering domain objects.
This listing shows how simply you can secure domain objects on the view layer.
In fact, it does a very similar job (in view terms) to what you get when you use the @PostFilter annotation.
It will work only if there is only one bean of this type configured in the application context, because it will try to retrieve the bean by type.
Now, if you restart the application and again execute the steps we defined in Test Scenario 7-1, you should have exactly the same behavior from a presentation layer point of view as you had before when you first executed that scenario.
If permission is granted, the body of the tag is evaluated and rendered.
If permission is not granted, the body of the tag is skipped.
The Cost of ACLs The example we have been working on shows that working with ACLs imposes a good deal of overhead in terms of the operations and logic you need to implement on top of your standard business operations.
It’s clear that storing a post is affected by the extra work that is necessary to store the corresponding ACL for that object, and retrieving posts is affected by the need to filter out certain elements of the collection based on the permissions.
This brief section will go inside the core class of the ACL Spring Security support to see how it works internally and how it might affect your application.
It’s configured by default to work with HSQLDB, which is the database we have been using in our examples.
This class has different SQLs for the different things you do when you interact with the ACL system—like inserts into the different tables, deleting ACLs, updating values and, of course, selecting from the different tables.
All of these operations are done using Spring Core’s JdbcTemplate support.
This method tries to retrieve the requested Acl from the cache.
If it finds the ACL in cache the method will return this found ACL; if the ACL is not found in the cache, the implementation will query the database with a somewhat complex query with four joins, as  Listing 7-25 shows.
The result from this query is then stored in the cache, which then makes these ACLs available so that if another method calls readAclsById requesting one of the cached elements, the database doesn’t need to be hit.
When you create a new post, the readAclsById is called.
Also, another select query is performed to retrieve the primary key of the objectIdentity represented by the domain object.
Then all the caching entries for that Object Identity are cleared and a new call to  the readAclsById is executed which will query the database for the up to date information.
You can see how the cost of deleting a post has increased considerably with the use of ACLs.
Deleting Post objects is also more costly because now it involves deleting ACE entries, deleting object identities, and clearing the cache for the relevant objects.
This section is not meant to scare you away from using ACLs.
I simply want to make you aware that there is an extra cost (apart from the complexity of using it) you should take into consideration when creating your applications with the use of ACLs in mind.
The more domain objects you have, the more ACL entries you will have as well.
In a big application, you might be talking about millions of entries in the ACL support tables.
Summary In this chapter, I explained in detail how to use Spring Security’s support for ACLs.
I also introduced some internal aspects of the framework and the main classes that are involved in its ACL functionality.
We examined different ways to make sure that secured domain objects don’t show up in the presentation layer for a user who doesn’t have appropriate permissions.
You saw that this is achievable either with SpEL expressions at the @PostFilter business level or with the ACL Spring Security tag library directly in your JSP files.
I also gave a quick overview of the different SQLs that are used by the ACL framework and how they might impact your application.
This is primarily because the framework is built using object-oriented principles and design practices so that it is open for extension and closed for modification.
In the previous chapter, you saw one of the major extension points in Spring Security—namely, the pluggability of different authentication providers.
This chapter covers some other extension points in the framework that you can take advantage of to extend Spring Security’s functionality or to modify or customize functionality that doesn’t work exactly the way you need in your applications.
I also briefly cover the Spring Security Extensions project (http://static.springsource.org/spring-security/site/extensions.html), an environment you can use to create extension modules for the core Spring Security project.
The next section defines what I consider to be some of the major extension points in Spring Security and describes how to use them to add or modify behavior in your security solution.
Spring Security Extension Points Spring Security offers a comprehensive set of extension points that can be customized (or completely overridden) with your own implementations and still leverage the core of the framework.
Some of the extension points are evident, while some others are a bit more subtle and, in some cases, not even intended.
However, because the framework is so flexible, you can take advantage of that flexibility to tweak its configuration to fit your intentions.
Plug into the Spring Security Event System Spring Security supports an event model that is built on top of Spring Framework’s own event model.
You can use Spring’s event model to develop applications that can listen to different events that happen within the framework and act accordingly.
I won’t explain in any depth why an event model is such a powerful programming practice to have at your disposal.
Instead, I’ll just point out one big advantage: it allows you to decouple your applications, because in general the event producer or producers and the event consumer or consumers don’t need to know anything about each other in order to operate correctly.
In theory (and, indeed, in practice for events in general, although not for Spring events), you can have a completely heterogeneous application where you can write and evolve each module at its own pace without affecting other parts, and then integrate them all together through the exclusive use of events.
Broadcasting an event to all interested listeners is also straightforward.
Spring then takes care of ensuring that all the listeners registered for that particular event are notified of the event publication.
You will use this when you configure the listeners in our examples.
Spring Security comes with its own suite of ApplicationEvent implementations, so you can hook into different points of the security life cycle in an unobtrusive and decoupled way.
Here, I will give a concrete explanation of them and when they are published within the framework.
Figure 8-2 shows these event classes and interfaces in UML (Unified Modeling Language) form.
This instance is configured by default for the web-layer security when using the <http> element.
Then an instance of this event will be created by reflection and will be published.
Figure 8-3 shows the mentioned event classes in a UML class diagram.
This is all the theory you need to know about publishing and handling events in Spring Security.
Next you will see a very simple example where you put this knowledge into practice to add behavior to your application based on listening to events.
This example will listen to only one type of event, but the configuration needed to listen to more types is exactly the same.
You implement the same interface but type it differently in the generic type.
You need to implement only the interface and type it with the class of the event that you want to listen to.
To define any other event handler, you do the same but type the handler class by the correct event that you want to listen to.
It should be simple enough to test this functionality for different event types.
Looking at how these different authentication providers are set up in your application and the nice way they are contained in their own “modules,” you could think that you should be able to use your own authentication provider.
The truth is, of course, that you can, and here I will show you how with a simple example.
First of all, let’s review how the authentication providers work in your application.
When you use the namespace to define an authentication manager and an authentication provider as shown in the listing, the framework instantiates two ProviderManager objects and sets one as the parent of the other.
This scheme is used by the ProviderManager which is able to establish a hierarchy of authentication managers.
This parent–child relationship is managed by Spring at startup time.
So these are the two providers that are used by default when you use the common definition from Listing 8-2
This method, as you can see, receives an authentication and returns an authentication.
The important difference between the two authentication objects (the one received and the one returned) is that the Authentication object it returns will return true in the method isAuthenticated (if authentication is successful, of course), indicating that a fully authenticated object is now in existence, while the Authentication object received in the method will have this method returning false.
This is the logical way to work, as this method in an Authentication object (isAuthenticated) and its return value are what conceptually differentiate an Authentication object that is fully authenticated from one that is used only to wrap the user details before actually applying the authentication logic; or, indeed, any Authentication object that hasn’t yet been fully authenticated and verified.
Of course, you can create a new UserDetailsService to retrieve this UserDetails from some other source, and that is something I’ll show you in the upcoming examples.
The UserCache, by default, uses a NullUserCache implementation, which is a no-op cache.
It can also be replaced easily, but I don’t cover that here.
The idea of the cache is to keep the UserDetails objects cached in case they need to be retrieved again.
If the authenticate method doesn’t find UserDetails in the cache, it will query the configured UserDetailsService for the user and then store it on the cache for subsequent requests.
In the example, I will also introduce the option to exchange password encoders in order to use different algorithms to cypher the passwords, instead of storing them in plain text.
The first thing we’ll do is get the code from Chapter 2, as you will use it as a base for all your examples in this chapter.
In my case, I changed the pom.xml a little bit to use a different project and artifact name.
I also removed all the files from the “discard” package and configured the <intercept-url> element to intercept all URLs.
If you do not, next is a quick step-by-step reminder on how to configure the applications from this chapter.
You can do the same with your configuration or simply start from scratch, remembering to copy the required dependencies in your pom.xml.
For you to have a running application and to not leave you guessing exactly what parts of Chapter 2 to grab here, I give you the step-by-step guide to get all the needed application setup.
I won’t explain the steps, as they have already been covered; I will just give a quick list of the steps to help you follow along with the examples.
In future sections when a new project is started to test some new functionality, you can refer to this part to create a new project from scratch:
In the pom.xml file, add the dependencies from Listing 8-3
In the pom.xml file, add the plugin from Listing 8-4 to the build section.
Remember that security is currently configured, as shown in Listing 8-5
Let’s create a new UserDetailsService implementation that will look for users in a MongoDB database.
Like many other examples in this book, the implementation I’ll show you will be somewhat trivial, but it will serve to show you the steps you need to implement the UserDetailsService.
First of all, let’s add the MongoDB dependencies to our pom.xml.
You will be using Spring Data to set up and use MongoDB.
It is not really required, but because you are working with Spring it seems like a good idea.
According to the Spring Data for MongoDB (http://www.springsource.org/spring-data/mongodb) website, it “aims to provide a familiar and consistent Spring-based programming model for new datastores while retaining store-specific features and capabilities.” So you have a Spring-based application and are using MongoDB, which is a good fit for it.
The dependency you need to add to the pom.xml file is shown in Listing 8-8
You can download it from its official site at http://www.mongodb.org/downloads.
After you download it (and assuming you are working on either Linux or Mac OSX), you can simply unpack the file somewhere and it is ready to run.
To run the MongoDBserver, simply go to the bin directory of the directory you just unpacked and run the file ./mongod.
If you have Windows, you should find easy-to-follow instructions in the MongoDB website.
It is part of the many NoSQL solutions that have become so popular in the recent past.
Its main power comes from the fact (at least from my perspective) that it combines a very scalable storage solution with a very intuitive document model built on top of known technologies (like JSON and JavaScript in the command-line interface)
And it does this without forgetting about one of the best things of the SQL world, which is the flexibility given by the availability to execute dynamic queries, allowing you to query your database using very varied criteria and filtering options.
This contrasts with, for example, key-value storage solutions that allow searching only by the key.
As I said, MongoDB is a Document store, where the Documents are structured as JSON.
MongoDB stores its Documents in collections of documents called collections.
I won’t go into explaining MongoDB any further, except for what is needed to create and run the example.
If you are interested in learning more about it, there is a lot of bibliography online that can help you out, starting with the project’s website and, in particular, this link to current books on the topic: http://www.mongodb.org/display/DOCS/Books.
You now have the MongoDB server running and the needed dependencies in your project.
To do this, you need to implement only one method:
You can see how nice the Spring Data MongoDB solution looks, and you should be able to understand to some degree what the code is doing.
The loadUserByUsername method uses this template to retrieve the user from the Mongo database.
As you can see, the loadUserByUsername method calls the findOne method in the mongoTemplate to try and retrieve the user by username, telling it (in the second parameter to findOne) the class of the object it expects its result to be unmarshalled to and the Mongo collection where it is trying to find the specified document.
The User class, which is an implementation of UserDetails, is the class of the objects that we expect to get back from the method call.
That is all specified by the following simple method call:
Actually, returning null from UserDetailsService is a “contract violation” for the interface, and you will be informed of this if you accidentally do it.
The next thing you need to do is configure the application so that it is actually aware that it will be using MongoDB.
You can see that this file is using a <mongo:> namespace.
This is part of the Spring Data project’s MongoDB support.
You can use these two converters to map the documents from the Mongo database to and from the User objects you are using.
UserReadConverter makes sure you can read the MongoDB document into a User object.
The relevant data is extracted from the document and is transformed when needed (as with the GrantedAuthority) to set it as properties of the object, and of course it calls the correct constructor on the User class.
It takes a User object and extracts the values from its properties to store them on the MongoDB collection creating a Mongo DBObject, which ultimately will represent a Mongo document.
These converters are automatically invoked with the definition you wrote in Listing 8-10
Although everything is configured right now, you still don’t have any users created in your users collection in your example1 Mongo database.
This interface has JDBC, LDAP, and InMemory implementations, but, of course, there isn’t a MongoDB one.
Then you will create a simple program to store a user using this service.
You can see that Listing 8-14 added the method createUser to the class, which simply uses the MongoTemplate to store the user in one line.
The listing also has a lot of new methods, which you are not going to implement but which are required by the UserDetailsManager interface.
This is so that you have a user for your tests.
Run this main class as you would normally run any Java class with a main method to store the user.
After running this class, you should have the user created in the collection.
You can check this out by completing the following steps:
The application is ready to go; start it with mvn jetty:run and give it a go.
If you visit the URL http://localhost:8080/hello, you will be prompted for the username and password.
Of course, as I mentioned in the previous paragraph, you now need to configure the insertion of the user to use the encoding algorithm as well so that Spring Security is able to match the password when retrieving the user from the database.
To do this, you will use the password encoder defined and retrieved from your UserInserter class before storing the password.
For that, you make the main method from the UserInserter class look like Listing 8-18
If you execute this code now, you will insert the user with the password hashed with the SHA-256 algorithm.
You can check that by querying your MongoDB database, as explained in Figure 8-5 and its preceding paragraph.
After doing this, you can restart your application and use “car” and “scarvarez” to log in as you did before.
You should be able to log in without any problems, with no apparent difference from a user interface point of view.
However, now, under the hood your passwords are not stored in plain text anywhere in the application, so they cannot be compromised easily.
I explained this process in detail in Chapter 7, so I won’t go into it any further here.
Again, do any modifications required to the pom.xml file if you would like to name the application differently.
You could implement this solution using a SpEL expression, but we want to show the use of custom voters, so this example will do.
The first thing you will do is create the voter implementation itself.
This code specifies that this voter supports any ConfigAttribute that starts with the string USERNAME_
Then, when it is time to vote on the authentication request, it will compare the username of the requesting Authentication with the ConfigAttribute substring (after the USERNAME_ prefix) to see if the user should be allowed access to the secured resource.
If it matches, access is granted; if it doesn’t, access is denied.
This is because, as you know, the UsernameVoter doesn’t read this property; instead, it simply queries the username property of the principal of the Authentication object.
Basically, this is an arbitrary string here as authorities is a required attribute of the <user-element>, but you know you are not using it in our example so you choose a descriptive name to point out this fact.
If you restart the application with this new configuration and log in with the username “car” and the password “scarvarez”, you should be able to access the http://localhost:8080/hello URL without problems.
Basically, they work by iterating through a list of voters to which they delegate the intermediate decision of whether or not to allow access.
Again, this is not going to be a very common piece of the framework to customize, as the voter system is very flexible and well designed.
The class is a toy, so it would break if method security interception were enabled.
You can see the code is simply retrieving the URL from the FilterInvocation object and comparing it to the list of authorities that the authenticated user has.
If they match, access is granted; if they don’t, access is denied.
Note that SpEL is a general functionality provided by the core Spring Framework, which is available to other projects covered by the Spring suite of projects, including Spring Security.
I showed you before how to add some extra functionality to the SpEL processing by creating a different root with an extra method.
Specifically, you can look at Chapter 5, where I introduced SpEL and customized its support by defining new expressions.
Non-JDBC AclService The current support for access control lists (ACLs) in Spring Security is related to the use of relational databases, JDBC, and Spring’s JdbcTemplate.
There is no reason why you couldn’t implement ACLs on top of a different storage solution, and there could be many reasons why you would want to do that.
For example, it could be because the JDBC solution is too slow, or it can even be that your application doesn’t support relational databases at all.
As I explained in the ACL chapter, most of the ACL functionality resides in a couple of classes and services.
It is not trivial to implement, but the fact that the SQL support is encapsulated in just a few classes makes the change very focused.
The two main interfaces you need to implement to support a different solution than SQL are the AclService (and the MutableAclService) and LookupStrategy.
You could think about implementing these services in many different ways, maybe using some of the NoSQL solutions that are so popular now, like MongoDB, CouchDB, or similar.
Custom Security Filter As you know, one of the main elements of Spring Security is the web-layer security support leveraged significantly by the Servlet Filter chain that it provides.
You can create your own filters and make them part of the security filter chain that processes the request that arrives in the application.
Say that you want to allow normal users to log in only through a Firefox web browser, while administrator users can log in with any browser they want.
This is, of course, an artificial example to show you how to use a custom filter, but there might be some legitimate reason why you would like to do something like this.
Maybe your application is verified just for one browser, but you want to allow administrator users to try other browsers to test them out and verify them later for widespread use.
You will be using the User-Agent http header to identify the browser that is making the request.
In the listing, you can see how the functionality is implemented.
One is for the administrator role that is allowed access from any browser.
Anonymous authenticated users are allowed to use any browser because in the false theory of my application, the anonymous accessible parts (if any) are working for any browser.
You can also see that the filter extends from the class GenericFilterBean, which is a Spring-aware filter implementation.
As you can see from Listing 8-24, it is pretty easy to configure a custom filter in the security filter chain.
You use the namespace element <custom-filter> and put in a reference to a filter implementation bean.
Also, you can specify where the filter will be within the chain.
If, on the other hand, you do the same with the Firefox browser, you will be allowed access to the now very familiar “Hello World” page.
If you do the same but log in with “mon” and “scarvarez” and access the URL http://localhost:8080/hello/, you will be able to access the functionality of the page (the “Hello World” message) from any browser.
An error you receive when logging in with Chrome instead of Firefox.
This was a simple example of configuring your own security filter to add additional behavior to the security implementation you are configuring in your application.
You could think of many different implementations in which you could improve or modify the security treatment through the filter chain.
Handling Errors and Entry Points Spring Security has a very nice error-handling mechanism built in.
It offers a comprehensive set of exceptions that map to the most common cases of security errors you could expect to have in a system.
If any other exception is caught by this filter, it will simply rethrow it as a RuntimeException.
Spring Security offers a couple of extension points you can use to plug in functionality in the form of a custom entry point and a custom access-denied handler.
As another artificial example, you will implement an entry point that will add a cookie each time an authentication attempt is made from the client side and then show the Basic Authentication scheme in the browser.
This means you will set a cookie in the response that will increment its value every time the entry point is invoked.
Then the cookie is sent back to the server every time with the new value.
This means that the counter for the attempts is not stored in the server at all, it is stored just in the client cookie and is sent back and forth between the client and the server.
So the server receives the cookie, increments its value, and then sends it back.
It is not really innovative in any way, but it allows me, again, to show that you can override the entry point to do different things.
Most likely, the entry point is overridden when a different kind of authentication scheme is being used.
In most cases, the implementation of an entry point goes hand in hand with the implementation of a new security filter.
Basically, the entry points set the groundwork and then the filter processes the subsequent request.
The cookie is first retrieved from the request in the private method getDeniesCookie.
Then the value of this cookie (which is assumed to be an integer) is increased by one and reset in the response header in the following line:
I just added the cookie in the response, which will be set to incremental values every time this handler is invoked.
You can see that there is also the logic for processing the errorPage property in case it is set.
A servlet dispatcher forward will be done to this error page URL, which means that it will have access to the same request that is used inside this class.
Changing the Security Interceptor The security interceptor is a class you rarely find yourself modifying or replacing, as the default implementations cover the most common scenarios of filter security and method-level security.
However, you can extend it for use in different kinds of applications that don’t strictly fit into the web app-business method services scheme.
This means that it basically intercepts send and receive calls on a determined secured channel.
The creation of a different security interceptor, as the Spring Integration example shows, is basically for when you want to add Spring Security’s authorization support to applications that don’t follow the standard web-service way of doing things.
However, keep in mind that a previous authentication mechanism must be in place, as the security interceptor will look for the different components that it needs to grant access to a resource.
Listing 8-28 shows the security interceptor implementation from Spring Integration.
See the License for the specific language governing permissions and * limitations under the License.
In the code, you can see that ChannelInvocation wraps a MethodInvocation before calling the beforeInvocation method on the parent class.
Apart from wrapping, it will also do some inner processing to make the current executing channel available to be queried for ConfigAttributes.
Also note that the interceptor will do its security validations only if the method being invoked is one of the standard “send” and “receive” methods of Spring Integration.
It is very unlikely you will override the security interceptor in your own applications.
However, it is good to know that you could do it and also understand why you would want to do it.
As the example for Spring Integration shows, one reason you would want to replace a security interceptor (or add an additional one) is because you have certain abstractions, to which you want to apply interception-based security, that don’t fit either URL interception or simple method interceptions.
You want to give a more meaningful name to your interception logic and also filter certain things that are not filtered by default with the default implementations.
It is intercepting MessageChannel communication, which is the domain element that makes sense in its context; However, in the end, it is basically intercepting methods and filtering to intercept only the methods send and receive, which again are the ones that make sense in the particular context.
Spring Security Extensions Project There is a whole project dedicated to the development of Spring Security extensions, where people from the community can develop their own extensions on top of Spring Security.
In this way, they can decouple these extensions from the main Spring Security project, allowing it to evolve independently.
If you visit that page, you will see that currently there are two extensions projects in existence: Kerberos integration and SAML2 integration.
There is also the OAuth integration, which lives on its own as an individual project.
Each project in Spring Security Extensions can implement as many parts of the framework as it needs in order to work correctly.
This means that many of the extension points that I defined in this chapter (and some others) could be overridden in a particular extension in order to do its work.
Summary In this chapter, I showed you how the modularity in the architecture of Spring Security pays off when you want to customize or extend its behavior.
I showed some of the different and most common extension points that Spring Security offers so that you can adapt its functionality to your particular application while keeping the core functionality, making the work easier for you by leveraging this functionality.
After reading this chapter, and with all the theory and practice from previous chapters, you should feel confident enough to implement functionality that goes beyond the out-of-the-box offerings of the framework.
Note that this chapter does not include a comprehensive list of extension points in the framework.
Remember that you can get the source code of Spring Security, which means that you can change absolutely everything to adapt it to your own needs.
You won’t often need to change any core aspects of the framework, but it is good to know that you could.
Keep in mind that sometimes working with Spring Security is like putting together a puzzle.
In each case, you are assembling components, but in the case of Spring Security, you can replace some of the default components with customized ones to change its behavior.
This chapter will explore Spring Security in the context of other application frameworks and languages that run on the JVM.
You saw in previous chapters that the two main ways of using Spring Security are in the web layer in the shape of filters and in the business layer with Spring AOP.
This means that you could use Spring Security in any application that is built on top of the Servlet technology or in any application that is willing to use Spring and Spring AOP to handle its object life cycles and interactions.
In the following sections, you’ll see examples of both cases.
We’ll start by looking at a couple of popular Java frameworks (one which is also Spring based) and how to use Spring Security with them.
These frameworks are the popular Struts 2 web framework and Spring Web Flow, another member of the SpringSource suite.
After studying these two frameworks, we’ll take a brief look at a few Java Virtual Machine (JVM) programming languages (and some of their related frameworks) and how to use Spring Security with them.
We’ll be looking at Groovy in the context of its web-development framework Grails, JRuby in the context of Rails, and Scala embedded in a Spring web application.
I will not go into any of these frameworks or languages in much detail, because that would be beyond the scope of this book.
The purpose of this chapter is simply to explain how to use Spring Security in a wider context.
True, Struts is not as common as it used to be, with new and more friendly frameworks coming out all the time.
Even version 2 is getting rather old, although it is still well maintained.
However, it is still widely used and is as good a candidate as any other external Servlet-based framework to integrate with Spring and Spring Security.
Struts 2 is a popular Java web framework built by merging the original Struts project and the WebWork project.
Struts 2 was always intended to be a complete evolution from the original Struts framework, adapted to a new generation of powerful web frameworks, and it really kept little of the original Struts principles and implementations.
Struts 2 is an MVC (model view controller) framework built on top of the standard Java Servlets technology, so many of the web-based security principles you have read about in this book apply without modification.
If you want to use only the URL-level, web-based security you studied in Chapter 4, you just need to configure your web.xml and your Spring Security filter chain accordingly.
As with the rest of frameworks and languages in this chapter, I won’t explain Struts 2 in any depth (because there are many good books available on that subject)
I’ll explain just enough so that you can use Spring Security with it.
In fact, I assume that if you are reading this section it is probably because you are already using Struts 2 and want to integrate Spring Security with it.
When a request comes to the application, a front controller (http://en.wikipedia.org/wiki/Front_Controller_pattern) implemented in a Servlet filter takes care of the request.
It sends the request through a set of configured interceptors that perform different kinds of functionality before and after the action is invoked.
The action is then invoked, which carries with it all the business logic required by the current request.
After the action finishes, a result object representing the view is created and the interceptor stack is invoked in inverse order as before (while returning the result) until a response is finally returned to the client.
The first thing we’ll do is create a new project.
From the command line in a directory of your choice, execute the command mvn archetype:generate –DarchetypeCatalog=http://struts.
Then follow the prompts by selecting a new starter project at the first prompt and selecting some relevant groupId and artifactId names.
Executing the last Maven command is a fantastic first step for creating our example because it creates a simple, functional Struts 2 web application with the components we need to create our test, including Spring integration (although it uses an old DTD version of the configuration XML file)
The file structure we have after executing that command is shown in Figure 9-2
Struts 2 application file structure after executing the Maven command.
In Listing 9-1, the important part to note is the definition of the two actions.
In the first action, "index" you can see that in the class attribute of the action element, a class name is defined.
The second action, on the other hand, doesn’t define a class name on the attribute class.
When a request comes in, the framework looks at the definitions from this file to determine how to handle the particular request.
This definition is simplistic, but it’s good enough to make the point.
If it sees the name of a class in the action attribute, the framework instantiates a new object of that class to handle the request.
If the framework detects that it is not a class, it looks for a bean with that ID in the Spring configuration and gets the object from there.
Next, you need to add the Spring Security filter to the web.xml.
This filter should execute before the Struts 2 filter, so an authentication object is populated before reaching the action.
Remember that Struts 2 works with filters and not with servlets.
Listing 9-4 shows the web.xml file you can use as a test.
I also removed some filter definitions I don’t care to use in the example.
The web.xml with the Spring Security filter and Struts 2 filter.
Next, I simplified the jsp files inside the jsp folder like this: the file helloWorld.jsp just contains the string “Pagina Segura” inside, nothing else.
Struts 2 has a built-in system to handle the exceptions that might be thrown in your application.
For example, when showing a login form, you need to deactivate the Struts 2 exception-handling mechanism.
Now if you restart your application and visit http://localhost:8080/struts-example/helloWorld, you’ll be presented with the standard Spring Security login form.
If you use the login username car and password scarvarez, you’ll be able to access the page shown in Figure 9-3
Spring Security with Spring Web Flow Spring Web Flow is a framework, built on top of Spring MVC, that allows you to link different steps of a web-driven process into a fluent workflow.
In other words, it allows you to define in a declarative way the different steps that a web application can go through while you are interacting with it.
Basically, you use it to define a set of rules and transitions between the user interface (UI) parts of a web application and the back-end process that each transition should trigger.
Graphically, Spring Web Flow works, in a simplified form, as shown in Figure 9-4
The example is a fake web page for a simplified product.
The boxes represent various states (the View state, Action state, Decision state, Subflow state, and others), and the arrows represent transitions.
Simple Spring Web Flow scheme showing that, from a product page, you can go to the review page or buy the product.
To implement this simple flow with Spring Web Flow, we’ll create a new project.
As is the case for most of the examples, we’ll use Maven to build and manage our project.
From the command line in a place where you want to create your project, execute the following:
That will create a new project named webflow-example in the directory.
Replace the pom.xml file in the new project with the one shown in.
It also defines Spring’s DispatcherServlet servlet, which takes care of setting up Spring MVC by loading the appropriate configuration file.
Both the security filter and the dispatcher servlet are configured to handle every URL in the system.
Note N  In Spring MVC, the name of the DispatcherServlet servlet is important because that name will match the name of the Spring configuration file that will be used in the application to configure the application.
This configuration will remain in a different file  just to keep it separated from the main servlet file.
This is another file you should be able to understand easily by now.
We are defining just a single user with role ROLE_USER, which will be enough for our tests.
We are not defining any URL security rules here because that is not what we want to do in this Spring Web Flow example.
We want to add security at the flow level (its states), and that is what I will show you how to do.
Now we need to define the web-flow configuration of the application as well as the actual web flows themselves.
Again, this will be a simplistic example just to show how the functionality works.
This file defines the general configuration for Spring Web Flow.
This element is  where the location of the flows in the application are defined.
Currently, we’ll define only one flow which will be in the product.xml file.
Also, note the way our views will get resolved when referenced in a view state in a flow.
By default, it will resolve view files by looking in the flow definition directory for files whose names are the names of the view states concatenated with .jsp at the end.
This simply means that if a view is named review, it will look for a file named review.jsp.
As I said before, each of these view states will map to a physical view file in the application.
The view files, by default behavior, should be located in the same directory as this flow file and should be named according to the view states concatenated with .jsp at the end.
The buy.jsp for the buy view state of the flow.
If you visit http://localhost:8080/product, you’ll be taken to the main view state.
At the moment, you can click on both links—Review and Buy—without a problem.
In a real application, you probably would want to allow anybody to read the product review but limit the ability to buy the product only to authenticated users.
Spring Security and Spring Web Flow integrate nicely because both are part of the Spring portfolio.
All you need to do now is decide which parts of the flow to secure and what constraints to define to secure them.
When a listener implementation is registered for the flows, it can intercept the flow execution at different points in its life cycle.
In that sense, it is similar to the AOP concepts you studied before.
So now we want to secure the view-state "buy" and allow access to it only to authenticated users with role ROLE_USER.
After you do that, if you restart the application and try to access the "buy" state, you’ll find yourself presented with the familiar Spring Security login screen.
If you log in with the username car and the password scarvarez, you’ll be able to reach the "buy" state.
The resulting "buy" state view is shown in Figure 9-6
The main.jsp, which is the entry point into the web flow.
This means that, to access any state of the flow, a user needs to have the required permissions.
Go ahead and try it yourself—it should be very straightforward.
This means that, by default, you can’t use SpEL expressions in your configuration.
However, defining your own support for SpEL expression–based security is straightforward.
Note how we are using a SpEL expression this time.
Now you need to create the new classes to support expressions at the flow state level.
In Spring Web Flow, there is a new abstraction—the state (a view state in our case)
So you need to provide the support for Spring Security to be able to handle this.
As you saw in Chapter 8, Spring Security offers many extension points, both intentional and unintentional.
In this particular case, I am taking advantage of the knowledge of the internal application programming interfaces (APIs) to develop support for SpEL for Spring Web Flow.
This is how I am making the framework aware of this class for evaluating SpEL against it.
The support I just created in this example is very simplified and might not be production ready, but it does a good job of showing the functionality.
If you now restart the application, you should get the same behavior as before.
The "buy" state will be secured, and you’ll need to log in with a user with the role ROLE_USER to access it.
Spring Security in Other JVM Languages I am not an expert in any of the languages that follow, and maybe I won’t be using them in the examples in the most idiomatic way.
I know Ruby best because I often use it both at work and during my leisure time.
However, my objective is just to show that, with some tweaking, you can integrate Spring Security into your projects that are written in a language other than Java.
So it should be possible to integrate it into any Java (Java JVM) application you have.
Of course, not all functionality will apply to any application.
For example, the filter chain won’t make sense in a non-web application.
Spring Security and Ruby (JRuby) Ruby is definitely one of my favorites languages, and I spend a lot of time working with it.
It combines great syntax with great language constructs, and it’s a pleasure to work with.
Ruby is an object-oriented dynamic language with a focus on productivity, concision, and simplicity.
The standard Ruby interpreter is written in C and was known as MRI Ruby until version 1.9
From version 1.9 forward, the official interpreter is known as the YARV interpreter.
Ruby is an incredibly popular language, and most of its popularity stems from the widespread use of its incredible web framework Ruby on Rails (RoR), also known simply as Rails.
Rails is an MVC framework that places great emphasis on convention over configuration practices.
It’s a very productive framework you can use to develop simple web applications in a fast and easy way if you follow the conventions enforced by the framework.
I won’t give an in-depth explanation of either Ruby or Rails because that would be beyond the scope of this book.
I also assume that if you’re reading this section, you probably know about them and just want to learn how to integrate Spring Security into them, or to learn if it’s at all possible.
However, I’ll try to give small explanations of Ruby concepts when I use them in the examples.
JRuby is a fully functional implementation of the Ruby programming language written in Java.
You can use it to run Ruby programs inside a Java virtual machine and interact with your other JVM languages—mainly, of course, Java.
What I’ll show in this section is a simple tutorial for integrating Spring Security into a Rails application and for deciding if it’s even worth doing.
In the JRuby case, there is no plugin like the one you find in Grails.
In fact, the integration between Java and Ruby is not as smooth as the integration between Java and Groovy.
Basically, we’ll have to roll our own implementation to make the integration work.
I’ll use the simple installation here, just downloading a file, uncompressing it, and adding its executables to the path.
Following is the procedure I use on my Mac (which should be similar to other operating systems):
Go to the directory you want to install JRuby in.
As in the rest of the book, this will be an application with very little functionality just to show you how to use Spring Security.
From a directory of your choice, write the following command: rails new demo.
We now have a new basic Rails application in the system.
You can run it by going to the directory demo that you just created from the command line and entering rails s.
That command will start a WEBrick server and run the application on that server.
If you are following the example, you should be able to visit http://localhost:3000 in your computer and access the default Rails application home page.
In the process of creating the Rails application, a lot of infrastructure code and a well-defined directory structure was generated for us.
If you take a look at the demo directory (which is the root of your application), you’ll see what I mean.
Anyway, as I said before, I won’t go into any depth examining the Rails framework or Ruby itself.
I’ll simply show with a rudimentary example how you could approach integrating Spring Security into a Ruby on Rails application.
Web-Layer Security in Rails When we ran our Rails application in the previous section, we ran it with a Ruby server (WEbrick)
This server doesn’t know anything about Java Servlets, so you might guess that it’s not possible to run Spring Security web-layer security with this server—and you would be correct.
What we need to do is run our Rails application in a standard Java web container, and that is what we’ll do next.
First, we install warbler, a gem you use to create standard WAR files from our Rails application.
To install warbler, use the command jruby –S gem install warbler.
After warbler is installed, you can execute jruby –S warble in the root directory of our application and it will create demo.war.
Let’s add some functionality to it first, and then let’s add Spring Security–level security.
One will return the string SECURED and will be accessible only to logged-in users.
The other one will return the string UNSECURED and will be available to any user.
Let’s create a pair of controllers: one for admin users and one for standard users.
Type the following two commands in the root of our demo application to generate them:
The execution of those commands generates output describing the artifacts that got generated.
You can find the controllers in the standard Rails location in the app/controllers directory.
The next thing you need to do is to copy all the Java libraries you need to use into the lib directory of our Rails application:
The next step is to enable our Rails application to be run in a standard Java web server, such as Tomcat.
Warbler is a JRuby exclusive gem you use to convert different kinds of Ruby applications into standard Java packaging artifacts, such as Jar and War files.
In our case, we’ll obviously be creating a War file.
Warbler uses internally the gem jruby-rack and packs it into the War-based application.
This gem is the core of the integration between Ruby Rack–based applications (such as Rails applications) and Java web servlet–based applications, which is what we need.
Of course, there is a lot more detail regarding warbler and jruby-rack, but for the moment, the explanations presented here should be enough for you to continue with the example.
In Figure 9-7, you can see a graphical illustration of how jruby-rack works.
Then you need to edit it and make it look like Listing 9-23
By doing this, you are including the Spring Security configuration in our web.xml file as you did in previous chapters.
Here we have our familiar Spring Security configuration from Chapter 2, with a few modifications.
We are simply securing the URL /admin/* for members of the Scarvarez family.
To do that, you execute the command "jruby –S warble config" in the root of our application.
That execution generates a warble.rb file inside the config directory of the application.
In the file, you are ensuring JRuby will be compatible with Ruby 1.9 and that the Spring configuration file will be included in the WEB-INF directory in the generated War file when warbler builds this file.
That’s all you need, so let’s create the War file again.
You should execute just warble and set the JRUBY_ OPTS variable separately.
That generates the War file with our Rails application embedded on it.
After it is deployed, you can visit the corresponding URLs.
On my computer, the behavior is as follows: when I visit the URL http://localhost:8080/demo/standard/message, I get the message on the screen “Anybody can read this meaningless message.”
However, if I visit the URL http://localhost:8080/demo/admin/message, the familiar login page is shown.
After I log in with the username car and the password scarvarez, I see the following message on the page: “This is top secret code.” This is the behavior we expected.
We have secured our Rails application with basic web-layer security.
The web.xml.erb in the config folder, including configuration for Spring Security.
Spring Security, Groovy, and Grails Groovy is one of the strongest contenders for the number one spot in the non-Java JVM language space.
It has a great community and currently is supported and managed by the SpringSource people.
Groovy is a programming language that tries to combine the power of Java with the elegance and developerfriendly characteristics of some dynamic programming languages—taking ideas mainly from well-known and much-loved languages such as Python and Ruby.
Groovy successfully creates an environment where different kinds of programmers, with some practice, can feel at home (experienced Java developers and Ruby developers, for example)
Groovy has many advantages when you compare it with other JVM languages—the main ones being, in my opinion, the easy transition from Java to Groovy and the interoperability between the two languages.
With regard to the transition part, it is easy to take a Java program and make it a Groovy program.
As a matter of fact, you don’t have to do anything.
This is good from one point of view but bad from another.
Even when you can compile a Java program as a Groovy one, it doesn’t make sense.
Ultimately, you are using Groovy to take advantage of the great features it has compared to Java.
Those great features include a lot of metaprogramming techniques, new powerful constructs like closures, faster development cycles, and a clearer and more concise and developer-friendly syntax.
Grails is a web framework written in Groovy and intended to be used with Groovy.
It is built on top of the Spring Framework and is heavily influenced by Ruby on Rails.
Grails is an attempt to make a friendlier and lighter framework in a JVM-based language that can be picked up quickly.
Also, it offers better and more concise ways to develop applications.
At the same time, it is built upon some of the strongest Java libraries and frameworks, such as Spring and Hibernate.
Using Grails to Secure the Web Layer with URL Rules Grails and Spring Security integration is incredibly simple because Spring Security is the default security solution for Grails applications and a comprehensive plugin exists to support it.
Here, we’ll create a simple Grails application, and I’ll show you how to secure it with Spring Security.
As usual, I’ll introduce this application in a step-by-step process.
Download and install the latest version of Grails if you still don’t have it.
I am running this example with version 2.1.1 of Grails.
To install it, simply unzip the downloaded .zip file and then set the environment variable GRAILS_HOME to point to the new expanded directory.
Also, add to your PATH environment variable the path GRAILS_HOME/bin.
At the command line, go to any directory where you want to create the application and execute grails create-app demo-grails to create the application.
Next, let’s generate a couple of controllers: a secured controller and an unsecured controller.
The next logical step is to secure the secured URL.
As I said before, Grails is built on top of Spring, so it’s only logical that an integration with Spring Security should be straightforward.
Grails is built in a clever modular way so that you can add functionality in the form of plugins.
Then execute the command "grails s2-quickstart demo.security User Role" to generate the needed models to support users and roles in the application.
Next, we’ll create a couple of test users to try out security.
Open the file BootStrap.groovy (in the grails-app/ conf directory), and make it look like the coding in Listing 9-28
You can see that this code uses the classes generated in the previous step, User and Role.
As with previous examples, we’ll secure certain URLs so that they are accessible only for users with a specific role.
To do this in Grails, you need to add the code from Listing 9-29 to the end of the file Config.groovy (which resides in the directory grails-app/conf)
It simply tells Grails to use an intercept URL map for security.
This map defines URL paths with wildcards (in Ant-style syntax, I already covered before for standard Java rules) and the roles that are allowed to access such URLs.
Run the application by executing the command grails run-app in the root directory.
If you log in with the username carlo and the password password, you’ll be granted access to the secured URL and not the unsecured one.
You can see that you have properly secured access to the URLs.
The first thing that is hard to see from this example is that you are actually using Spring Security.
I say this because you haven’t defined any filters, any authentication managers, any voters, any user service, or any authentication provider.
You could easily assume that something else is used under the covers because there is nothing specific to Spring Security here.
This is a good thing, and one of the nice features of Grails.
The use of plugins gives you sensible common defaults and leaves you only with the responsibility of defining the things that are exclusive to your business problem.
In the case of security, you need to define your users, their passwords, and the roles and access permissions for your application.
BootStrap.groovy setting up a couple of test users with security roles assigned to them.
An excerpt from Config.groovy, where we add the URLs that need to be secured.
Grails’ Spring Security plugin gives you more access to the functionality offered by Spring Security and, of course, it also allows you to customize it by overriding the defaults.
One of the things it supports is the use of SpEL for access rules.
In that listing, as you can see, we are using the security expression "hasRole", which you already studied in previous chapters.
Note that this is a simple example with "hasRole", but here you have access to the full suite of expressions offered by Spring Security SpEL support.
An excerpt from Config.groovy, which uses SpEL instead of simple roles.
Secured annotations (or the standard Spring Security @Secured annotation as well) in our controller classes and Spring Security will make sure they are secured according to those annotations.
After you do this, if you restart the application, you should get the same access constraints that you got in the previous section when you secured the URLs.
In these last two sections, I just scratched the surface of the functionality available using Grails’ Spring Security plugin.
You can do virtually everything you can do using the standard Java support.
For a comprehensive guide to using the Grails plugin, take a look at its official page at http://grails-plugins.github.com/grails-spring-security-core/docs/manual/
Spring Security and Scala Scala is probably the strongest language (in the sense of number of adopters and the liveliness of the community around it) running on top of the Java Virtual Machine apart from Java itself.
Scala also has a version that runs on the .NET platform.
Scala is a very powerful, general-purpose programming language that tries to merge the best of the object-oriented and functional programming paradigms.
Scala is a language that aims to provide a concise and elegant alternative to the world of enterprise Java programming, while keeping the type safety of Java.
As I said, it comes with functional programming features built in, adding a whole new layer of power for the seasoned object-oriented programmer that increases productivity.
I am not an expert in Scala or functional programming (far from it as I have just recently started to look at them) but I will give you the core definitions and the main characteristics of both and show you how to use them with Spring and Spring Security.
Functional programming is a paradigm in which programs are composed of functions that receive inputs and produce outputs, while also avoiding the use of state and mutability.
This is in clear contrast to object-oriented programming, where the main abstraction is the object and its internal state, and mutability is a very common thing.
By not allowing mutability and state, functional programming presents itself as a good alternative for programming concurrent programs, because programmers don’t need to worry about synchronization between concurrent processes or threads.
In Scala, functions can be passed around (as function parameters or function return values) as simple values.
In this sense, they behave pretty much like any other simple value (for example, a string), and this is an important concept in a functional programming language.
According to the literature, Scala’s name comes from the words scalable language.
This implies that Scala supports object-oriented and functional programming paradigms and that it is suitable for simple scripting tasks or full enterprise applications.
Combining this capability with an elegant and concise syntax makes the language scalable in terms of the number of domains and uses that it can address.
Uncompress the downloaded file in your directory of choice (which I will call YOUR_SCALA_HOME from now on)
You have now set up Scala to be used from the command line.
You can try it a bit from the command line.
Figure 9-8 shows some interaction with this command-line REPL (read-eval-print loop) interpreter.
The preceding figure shows a simple set of commands in the Scala REPL interpreter.
First, you perform a simple sum operation using two integer values.
The next line defines a new function called suma that receives two Int parameters and returns an Int value.
Note N  Scala makes a distinction between values and variables.
Values are like constants in other programming languages, and they are values that can’t change.
If you try to modify the entero value shown in Figure 9-8, you’ll get an error message such as “error: reassignment to val.” Values are defined with the val keyword.
Variables, on the other hand, are much like variables in any other language, and you can reassign values to them whenever you want.
OK, that was your introduction to Scala! It was a very simple introduction, I know.
However, as I said, covering the language in depth is outside the scope of this book and there are a lot of great books dedicated to the topic.
I’m assuming here that you probably know the language better than me and you are just interested in how to use Spring Security with it.
The next thing we’ll do is create the project by combining Scala with Spring and Spring Security.
Again, we’ll use our old friend Maven to create and manage the project.
In the generated pom.xml file, add the Scala dependency shown in Listing 9-35
Next, of course, you need to add the Spring dependencies to the pom.xml file.
You also need to add the Scala plugin in the plugin sections.
In the end, your pom.xml file should look like Listing 9-36
This will be a simple web application with Spring MVC, and it will have a very simple Service layer.
The big difference from applications you saw in other chapters is that both the Controller layer and the Service layer will be written in Scala instead of Java.
I’ll show you how to add security to the method level, but as you’ll see it is almost the same as with Java.
In the controller, we are defining a simple method that returns (writes on the response, actually) whatever the service returns.
You can see how we are using the annotation @RequestMapping in the example.
With Scala, we cannot use a simple string to set the value of array-based annotation values.
We need to set a real array with just one element as the value.
For the rest, the example is very much like the Java version, with some syntax modifications.
It is a service class with a simple method that returns a string.
Again, we are using the Array function (actually  what we are indirectly calling here is the apply method of the Array companion object which allows us to create a new instance of the Array class) and passing the string that will be the only element of the array.
With Scala, we can’t use the convenient technique of passing a simple string for this value as we did in the Java version.
Note also the use of the trait just before the class definition and then the class extending that trait.
A trait in scala is somewhat the equivalent of the interfaces in Java, but it has a lot more power.
Although not shown in this example, a trait can have fully implemented methods as well as the traditional abstract (definition only) methods typical of Java interfaces, and your class can extend more than one trait ‘inheriting’ the functionality defined in all of them without needing to implement the already implemented methods.
This technique, also called mixin, is in no way exclusive to Scala because other languages also have constructs that fulfil the same purpose.
For example, in Ruby you can use modules to achieve more or less the same outcome that you get with Scala traits.
For our example, you can think of a trait simply as a Java interface that you use from the controller to access the service.
By now you should be very familiar with configuring a Spring Security web application.
So I will simply show you the files next and won’t go into the details of any of them.
Note that we are referencing Scala classes just as we used to reference Java classes before in our beans.
It is great that interoperability between Java and Scala is so nicely achieved.
All files will live under the WEB-IF directory of your application.
From the root of the project in the command line, execute the command mvn clean install jetty:run to run the application.
Next, if you try to access the URL http://localhost:8080/enter/scala, you’ll be presented with the login screen you have seen so many times before.
If you log in with the username car and the password scarvarez, you should be able to access the application and see the page shown in Figure 9-9
That’s all I am going to say about integrating with Scala.
You can see that for a simple application like this it’s not really that different than integrating with Java itself.
Actually, beyond the syntactic differences, it’s probably just about the same.
Of course, in this example you are starting with a Spring application and defining the different components (controllers and services) in Scala.
It could be more of a challenge to integrate if you are using a Scala-specific framework.
All you need to remember is that to secure methods, those methods need to belong to Spring-managed beans.
To secure URLs, the URLs need to be accessed in a Servlet-based web application.
Summary In this chapter, I showed you, at a fairly high level, how to integrate Spring Security into various frameworks and languages.
The chosen framework was Spring’s own Spring Web Flow, and the illustrative languages chosen were JRuby and Groovy, with their web frameworks Rails and Grails, respectively.
I showed you that integrating Spring Security into these different frameworks and languages can be straightforward (as with Grails) or not so straightforward (as with JRuby or Scala)
However, through the JVM, in theory, you could integrate Spring Security into anything you need to secure.
Here is the main takeaway from this chapter, regardless of the frameworks or languages used: Spring Security is, ultimately, just a Java library (a couple of simple jar files)
You can integrate it into any Java (as in JVM) project that you want.
You simply have to remember what you can do with it and use the parts that make sense for your particular problem.
For instance, using web-layer security wouldn’t make sense in a Swing application, or even in a web application that doesn’t use standard servlet filters (such as the Play framework)
OpenID authentication auto-register functionality, 174 configuration file for Spring Security.
All rights are reserved by the Publisher, whether the whole or part of the material is concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction on microfilms or in any other physical way, and transmission or information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now known or hereafter developed.
Exempted from this legal reservation are brief excerpts in connection with reviews or scholarly analysis or material supplied specifically for the purpose of being entered and executed on a computer system, for exclusive use by the purchaser of the work.
Duplication of this publication or parts thereof is permitted only under the provisions of the Copyright Law of the Publisher’s location, in its current version, and permission for use must always be obtained from Springer.
Permissions for use may be obtained through RightsLink at the Copyright Clearance Center.
Violations are liable to prosecution under the respective Copyright Law.
Trademarked names, logos, and images may appear in this book.
Rather than use a trademark symbol with every occurrence of a trademarked name, logo, or image we use the names, logos, and images only in an editorial fashion and to the benefit of the trademark owner, with no intention of infringement of the trademark.
The use in this publication of trade names, trademarks, service marks, and similar terms, even if they are not  identified as such, is not to be taken as an expression of opinion as to whether or not they are subject to proprietary rights.
While the advice and information in this book are believed to be true and accurate at the date of publication, neither the authors nor the editors nor the publisher can accept any legal responsibility for any errors or omissions that may be made.
The publisher makes no warranty, express or implied, with respect to the material contained herein.
Apress and friends of ED books may be purchased in bulk for academic, corporate, or promotional use.
Any source code or other supplementary materials referenced by the author in this text is available to readers at www.apress.com.
To my wife, Monica, for her constant support and love.
And to my aunt Marisol, who we all miss so much.
He has worked in many industry fields in three different countries and has over nine years’ experience.
Currently living and working in London, Carlo focuses mostly on Java and Ruby software development.
Carlo fell in love with The Spring Framework when he first used it more than five years ago, and now he can’t conceive starting a pure Java project without the aid of Spring and its related technologies.
He is very passionate about his work and is constantly searching for the best ways to solve problems and trying to learn new and better technologies.
He also likes to write on his blog as a way to give back something to the software community that he so much respects, and he is a DZone MVB (Most Valuable Blogger)
Manuel Jordan Elera is a self-taught developer and researcher who enjoys learning new technologies for his own experiments and creating new integrations.
In his scarce free time, he reads the Bible and composes music on his guitar.
Manuel is a Senior Member in the Spring Community Forums, where he is known as dr_pompeii.
Manuel was Technical Reviewer for these books (all published by Apress):
Read and contact him through his blog at http://manueljordan.wordpress.com/, and follow him on his Twitter account, @dr_pompeii.
This book is definitely the work of more than one person.
The people involved in the preparation of this book have brought so much experience and quality to the final version that the end product is many times better than if I had done all the work myself.
Their input ranged from improving text style, to introducing better ways to present concepts, to performing code reviews and suggesting general improvements that have made this book a much better reading experience.
I am talking, of course, about the great people at Apress who have been with me along the full journey of writing this book.
I’m talking about Steve Anglin, who initiated me into the project, kept an eye from afar on the progress of the book, and tried to make sure I kept on track as much as possible.
I’m talking about Kevin Shea, who was my main editorial contact and made sure that I stayed on schedule with the book and helped with advice and support.
I’m talking about Tom Welsh, who had the great responsibility of reading every chapter as I was writing them and gave great input on each section, including helping with my use of English grammar as well as ways to make the different parts more attractive to potential readers.
I am talking about Manuel Jordan, who not only read every single chapter in a very detailed way, but also took on the laborious job of evaluating and executing every single line of code and made sure that the book provides code samples that can be reproduced by the readers in their own environments.
His input is greatly appreciated, and it is the difference between having a full book or a half a book.
There were, of course, many more people in Apress involved in the full review phases of the book, and I want to say “thank you for your help” to all of them.
I would like to also thank the creators, committers and community of Spring and Spring Security for creating such an amazing piece of software and making it available to everyone.
A big thank you to them for letting all developers share their knowledge and ways of work by freely distributing the source code of the different projects covered by the SpringSource umbrella.
Finally, I want to thank my wife for being with me all the time and motivating me to keep going forward.
