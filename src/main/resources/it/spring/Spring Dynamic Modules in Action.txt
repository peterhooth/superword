The publisher offers discounts on this book when ordered in quantity.
No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by means electronic, mechanical, photocopying, or otherwise, without prior written permission of the publisher.
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in the book, and Manning Publications was aware of a trademark claim, the designations have been printed in initial caps or all caps.
Recognizing the importance of preserving what has been written, it is Manning’s policy to have the books we publish printed on acid-free paper, and we exert our best efforts to that end.
Recognizing also our responsibility to conserve the resources of our planet, Manning books are printed on paper that is at least 15 percent recycled and processed without the use of elemental chlorine.
Yes, I’d heard of the Spring Framework, and I understood that it was a great improvement over existing techniques for writing software for the enterprise.
As a developer who had gained most of his experience in developing embedded and middleware applications, I found all that XML rather foreign.
However, I’d noticed the enterprise world’s interest in OSGi, so I too was interested.
It turned out that Interface 21, BEA, and Oracle were considering creating support for OSGi in the Spring Framework.
Spring is very good at configuring an application built out of simple objects that use, among other things, the simplified Spring interfaces to communicate with the world.
In contrast, OSGi provides strong modularity support but it’s not xv.
To discuss supporting OSGi in Spring, Adrian proposed a conference call with Hal Hildebrand (Oracle), John Wells (BEA), and one of the authors of this book: Andy Piper (BEA)
The initial conference call was followed by a meeting in London at the offices of BEA.
It was a meeting I’ll always remember, it was the start of what became Spring DM.
At first, I felt that the group saw OSGi as something that needed to be supported by Spring; that is, as one of many things to be supported.
As the meeting progressed, it became clear how nice the combination of Spring and OSGi could be; there was a lot of synergy and surprisingly little overlap.
At the end of the meeting, we were thrilled with this project's potential.
FOREWORDxvi The Spring DM project became crucial for the adoption of OSGi in the enterprise space.
At that time, OSGi had been adopted by Eclipse, which made it acceptable for general programming.
However, the enterprise space is conservative and was hesitant about adopting OSGi.
The fact that Interface21 people started to sell OSGi at the many conferences they visited helped to give OSGi a place in the enterprise world.
That said, it was a surprise for me when Interface21 changed their name to SpringSource and put a lot of emphasis on the OSGi connection.
They quickly became a member of the OSGi Alliance and started RFC 124, as an endeavor to put Spring DM under the OSGi flag.
SpringSource also introduced the dm Server (now project Gemini in Eclipse) and more importantly, they launched the OSGi Bundle Repository, filling a crucial gap for the acceptance of OSGi in the enterprise.
Before this repository, developers were forced to create their own bundles from open source projects, and this was not always painless.
The core principle of OSGi is modularity, creating inside and outside spaces with well-defined ports.
Unfortunately, it turns out that many open source libraries do not live well inside modules—thay need global visibility of all classes.
Over the past decade, mainstream Java has given rise to a number of patterns that appear to be modular but are not so in reality.
That’s why this book about Spring DM and Blueprint is so crucial.
First, it provides an excellent introduction to OSGi and what the guiding principles are.
As one of the participants of the OSGi specification, I do not think I could have improved on this description.
The book then explains how you should structure your projects with Spring DM, but it doesn’t stop there.
It doesn’t hide the complexities of today’s reality, which is that you have to use existing (open source) libraries.
It provides an extensive description of what you should do when you need to use libraries that do not play well in a modular world.
If you’re already building applications using Spring, then read this book and take the leap into the OSGi world.
Although you might run into some hurdles, this book will help you solve them, and the rewards are well worth it.
You know the one—it’s composed of multiple modules, each in charge of a specific, tightly defined set of tasks, each uniquely simple and elegant, interacting harmoniously to achieve the complex ends required by the user.
We are taught in school how to build these perfect programs using techniques such as object-oriented programming and aspect-oriented programming.
These techniques work well, but the end goal is always to make the system more reliable, more testable, more complete, and more flexible by making it more modular so that the whole is greater than the sum of the parts.
Of course, most of the software programs we work with are not perfect—have you encountered any of these issues?
When you do finally get it to deploy, you find you’ve made a mistake and now you have to undeploy, fix, and redeploy—all outside of office hours—missing the soccer and poker night with your mates.
The brittle-change problem A high-profile customer reports a problem, so you quickly fix the code and try to rebuild the application, only to find that the application won’t build because another component is using the internal function you just changed.
When you finally get the application built and deployed, you start getting reports of other parts of the application that are malfunctioning.
Working into the night—again missing the soccer game—you discover that the.
PREFACExviii change you made had unforeseen consequences that could only be discovered by running the full QA suite—a process that takes 48 hours.
The build-the-world problem Your development team is in Beijing, Mumbai, and San Ramon, and each subteam works on different parts of the application in different time zones and on different development schedules.
As the team and application grow, you find that it becomes increasingly hard to keep the different parts of the product separate—any time you make a change, you find it impossible to tell which teams will be affected by your changes.
The only solution is to keep all the teams on exactly the same version of the application, and to rebuild and retest the entire product every time any change is made.
You eventually spend all of your time building and testing the product and none actually developing it.
The company goes bankrupt, you lose your job, and now you have plenty of time to watch soccer—if only your widescreen TV hadn’t been repossessed.
But we all share the same enthusiasm and passion for Spring technologies and for anything that can help us build better software.
What could be more exciting for a Spring enthusiast than to be able to use Spring on the OSGi platform? At last, real, runtime modularity meets Spring! Unfortunately, there was not, at the time, much in the way of resources around Spring Dynamic Modules.
That was when he met Thierry and they both went on to write a French book on Spring.
In contrast, Andy in 2008 had already been working with Spring Dynamic Modules for a couple of years, having been involved with its original development and having used it extensively on several BEA products.
It was later in 2009 that Manning Publications contacted Arnaud and Thierry to suggest writing a proposal for a Spring Dynamic Modules in Action book.
Working with Manning can be difficult: they have high standards for their books, and we had no idea how high the mountain would turn out to be when we wrote that proposal, which then passed a succession of reviews.
Some reviewers were happy with it, but others were tough, like that Oracle guy, Andy Piper.
But his remarks were constructive, and based on his feedback Manning suggested that he be involved in the writing process.
After all, if you want something done right, you do it yourself! Having a native English speaker on the writing team also proved useful, as some say that the French accent comes across even in written text.
We have done our best to make this book as comprehensive and accessible as possible.
We hope you’ll benefit from our experience with the Spring Framework, OSGi, and in making both worlds cohabit as harmoniously as possible using Spring DM.
We believe that these technologies are an important piece of the puzzle in bringing your applications closer to the mythical “perfect” program.
Michael Stephens first contacted us and helped us create the book proposal.
Marjan Bace gave us the opportunity to write the book and provided us with valuable advice about its structure.
Karen Tegtmeyer organized the reviews, which resulted in further improvements.
Last, but not least, thanks to our development editor, Cynthia Kane, who helped us improve the book’s writing and structure.
Thanks to all the reviewers who took the time to read the book and make constructive remarks about its content.
This book is about an open source project, so it would not exist were it not for the xix.
An open source project is also a community project, so thanks to everyone who contributed to the project by answering questions on the forum or by participating in the bug-tracking process.
This also helped us to learn more about how people use Spring DM.
A very special thanks to Peter Kriens, the director of technology at the OSGi Alliance, who carefully reviewed the book and wrote the foreword.
My fellow authors, Arnaud and Thierry—who did the bulk of the writing—were invaluable with their contributions and intelligent insight; I could not have done it without them.
Thanks also to Oracle for giving me sufficient time for the project.
Spring hardly needs any introduction, being the framework of choice for a significant segment of the Enterprise Java development market.
OSGi, in contrast, although not a new technology is one that is just becoming mainstream, helped in no small part by Spring DM.
Spring Dynamic Modules in Action is a cookbook for using Spring DM, but it also serves as a primer for both of the technologies that Spring DM combines.
In the end, we decided to cover the basics of Spring, because some readers will be OSGi users wanting to understand Spring DM, and we decided to xxi.
If you are comfortable with either or both of these technologies, you can safely skip over the first couple of chapters.
Another problem for us was the breadth of technologies covered by Spring that could be supported in an OSGi environment.
There are already numerous books covering Spring in general, and also particular elements of the “Spring portfolio.” As a result, in chapters dealing with these technologies we’ve focused on how to make them work using Spring DM, rather than offering a more general discussion of the features offered by the technologies.
Likewise, some of the features of Spring DM support OSGi features (such as compendium services), the scope of which is too broad to be.
So again we have limited ourselves to describing the feature briefly and then focusing on its use in Spring DM.
The main exception to this general approach is the discussion of web applications.
Spring DM 1.2 includes extensive support for web applications, and we felt that the topic deserved a greater depth of coverage.
Then, toward the end of the writing process, the Eclipse Gemini project was started, with Spring DM moving to this project; right at the end, dm Server itself was transitioned to Gemini as the Eclipse Virgo project.
This technological shape-shifting would have been impossible to track accurately in the book, so we finally decided to stay with our discussion of Spring DM 1.2
Because this is an “in Action” book, we have striven to provide code and configuration examples throughout, both to illustrate the concepts and to provide a template for successful operation.
Who should read this book Our primary target audience for this book is Spring developers and architects who want to discover what OSGi can do.
Spring Dynamic Modules is about using Spring in an OSGi runtime environment, so if you want to write Spring-based applications on the OSGi platform, this is the book for you.
So the reverse is also true: if you want to build OSGi applications using the Spring Framework, this book is also for you!
The second part forms the core of the discussion of Spring DM’s features.
The final part covers more advanced topics, including advanced configuration, testing, and the Blueprint specification.
We also included several appendixes covering tooling support for Spring DM development.
Chapter 1 discusses Java modularity in general—after all, OSGi and Spring DM are primarily technologies that enable modularity—and also Spring, OSGI, and Spring DM.
The concepts covered are reinforced in later chapters, so if you want to get the flavor of the whole book, chapter 1 is a good place to start.
It also covers topics such as native code and error handling.
Chapter 3 then relates OSGi concepts to an overview of Spring DM features, covering the main facets such as the application context, dependencies, Spring extender, osgi namespace, container provisioning, fragment configuration, and application development using Maven.
Chapter 4 covers the operation of the two extenders that Spring DM provides: the standard extender and the web extender.
Chapter 5 covers the use of OSGi services with Spring DM.
Because service support is integral to the feature set provided by Spring DM, this chapter is one of the pivotal chapters of the book.
Chapter 6 covers the development of enterprise applications using Spring DM and, in particular, how to design and structure applications of this type to take advantage of all the power that Spring DM and OSGi provide.
The chapter also covers the integration of third-party enterprise libraries into an OSGi environment.
Chapter 7 covers the use of JDBC and JPA in Spring DM-enabled applications.
Chapter 8 covers the use of common web frameworks in Spring DM-enabled.
Chapter 9 covers some advanced topics, including configuration of the Spring DM.
Chapter 10 covers the testing of OSGi applications that use Spring DM.
Chapter 11 discusses Spring DM’s support for OSGi compendium services, in particular configuration admin and eventing.
Chapter 12 covers the OSGi Blueprint specification and its relationship to Spring DM.
Code The source code for the example applications in this book has been donated to the Apache Software Foundation.
Much of the source code shown in the book consists of fragments designed to illustrate the text.
When a complete segment of code is given, it is shown as a numbered listing; code annotations accompany some listings.
When we present source code, we sometimes use a bold font to draw attention to specific elements.
In the text, Courier typeface is used to denote code (Java and XML) as well as Java methods, XML element names, and other source code identifiers:
A reference to a method in the text will generally not include the signature, because there may be more than one form of the method call.
A reference to an XML element in the text will include the braces but not the properties or closing tag (for example, <action>)
This page provides information on how to get on the forum once you are registered, what kind of help is available, and the rules of conduct on the forum.
Manning’s commitment to our readers is to provide a venue where a meaningful dialogue between individual readers and between readers and the author can take place.
It is not a commitment to any specific amount of participation on the part of the author, whose contribution to the AO remains voluntary (and unpaid)
We suggest you try asking the author some challenging questions lest his interest stray! The Author Online forum and the archives of previous discussions will be accessible from the publisher’s website as long as the book is in print.
Prior to working for Oracle, Andy was open source architect at BEA systems looking at open source technologies such as Spring and core architect for WebLogic Server.
Andy was responsible for many of WebLogic’s enterprise-class features, such as clustering, RMI, IIOP, and HA technologies.
Andy is a committer on the Spring DM project and holds a PhD in distributed computing from Cambridge University, England.
According to research in cognitive science, the things people remember best are the things they discover during selfmotivated exploration.
Although no one at Manning is a cognitive scientist, we are convinced that for learning to become permanent, it must pass through stages of exploration, play, and, interestingly, retelling of what is being learned.
People understand and remember new things, which is to say they master them, only after actively exploring them.
An essential part of an In Action book is that it is exampledriven.
It encourages the reader to try things out, play with new code, and explore new ideas.
There is another, more mundane, reason for the title of this book: our readers are xxvi.
They use books to do a job or solve a problem.
They need books that allow them to jump in and jump out easily and learn just what they want just when they want it.
The books in this series are designed for such readers.
The Alka is an equestrian tournament held in Sinj every first Sunday in August since 1715, commemorating the definitive victory of the region over the invasions of the Ottoman Empire.
Alka is also the name of the object used in the tournament, which is made of concentric iron rings connected with three bars, and hung on a rope above the race track.
Over a course of three rounds, the ceremonially dressed contestants, called alkars, ride their horses down the track at full gallop and attempt to thread the central ring of the alka with their spears.
Points are scored depending on precision and which part of the alka the contestant pins.
The victor is celebrated as a bold hero and knight.
The illustration is from a recent reproduction of a book of Croatian dress customs, Characterization and Description of Southwestern Wende, Illyrians and Slavs, by Balthasar xxvii.
Dress codes and lifestyles have changed over the last 200 years, and the diversity by region, so rich at the time, has faded.
It is now hard to distinguish the inhabitants of different continents, let alone of hamlets or towns separated by a few miles.
Perhaps we have traded cultural diversity for a more varied personal life—certainly for a more varied and fast-paced technological life.
Manning celebrates the inventiveness and initiative of the computer business with book covers based on the rich diversity of regional life of two centuries ago, brought alive by illustrations from old books like this one.
Spring Dynamic Modules—a synthesis of Spring and OSGi-is the technology that can help you write better, more beautiful, programs.
In chapter 1, we cover the concepts of Java modularity in general—since Spring DM and OSGi are primarily technologies that enabled modularity—the specifics of the Spring Framework, and the features of OSGi.
We then move on to show you where Spring DM fits in, and how its approach and its features simplify the development of standard Java applications in an OSGi environment.
The concepts covered are reinforced in later chapters, so if you want to get the flavor of the whole book, chapter 1 is a good place to start.
Chapter 2 is an OSGi primer, focusing on how you can take advantage of OSGi technology within your Java applications.
It introduces the main building blocks of OSGi: bundles, wiring, and services.
At last, in chapter 3, we are ready to get down to the main business of Spring DM.
There is a lot to learn and we introduce all of the main features and concepts here—dependency injection, extenders, writing bundles container provisioning, fragment configuration, and application development using Maven.
In part 2 we delve deeper into the main features of core Spring DM, covering each in a good amount of detail.
In part 3 we look at some more advanced topics surrounding the use of Spring DM.
If you’re a Java programmer, you have probably heard of, or used, Springthe dependency injection framework for Java.
But what about OSGi? This dynamic module system for Java may be less familiar; but no matter, Spring DM is about OSGi for the masses, providing OSGi’s modularity features in a neat Spring-shaped package.
You don’t need to get too involved in the nitty-gritty of OSGi to benefit from its features.
In this book, we’ll describe what Spring DM is, how to use it, and more importantly how to benefit from it.
Because Spring DM is not only about using modular Java systems to get things to work—it’s about getting them to work well.
We’ll also look at some of the implementation challenges involved in using Spring DM, challenges that Modular development with Spring and OSGi.
For instance, using object/relational mapping (ORM) tools or creating web applications can seem daunting in an OSGi environment, but never fear—we’re here to help!
In this chapter, after having covered the concepts of modularity, the specifics of the Spring Framework, and the features of OSGi, we’ll show you where Spring DM fits in, and how its approach and its features simplify the development of standard Java applications in an OSGi environment.
If you’re already familiar with OSGi and Spring, you can skip the next few sections and go to section 1.4, which introduces Spring DM.
We all fall in love with abstraction sooner or later.
No man is an island, however, and code is no different.
No matter how beautiful your code—and let’s face it, we all like to think we write beautiful code—it eventually has to interact with other code.
In this book, you’ll learn how Spring DM and its OSGi substrate can be used to address the problems caused by unmanageable spaghetti code.
But before we get to the cool technology, it’s worth reviewing what we mean by modularity and the kind of problems modular software is designed to solve.
A modular application is, in essence, one that’s divided into several pieces with the connections between the pieces being controlled and well defined.
It’s this limit on connections that reduces the impact of change and markedly improves things like testability.
But what is a connection? What creates connections, and how do you reduce them? The answers are clearly contingent upon technology, which in our case is Java.
We would argue it’s the best general-purpose programming language ever developed, for it addresses many of the deficiencies of languages that went before it.
The first step toward modularity lies in the object-oriented features that the Java language offers: splitting applications into classes and enforcing encapsulation with interfaces and visibility modifiers (private, protected, and so on)
Java EE also acknowledged the need for composite applications by introducing several kinds of deployment units: the Java Archive (JAR), which is the most common, but also the Web Archive (WAR) and the Enterprise Archive (EAR)
But these archives, particularly the web and the enterprise ones, only allow you to split your application into coarse-grained components; they do nothing to enforce the program architecture that you know is required.
This is a good step, but, again, it isn’t enough, especially for large, complex systems and systems that need to be extensible or that want to promote reusability.
Are we facing a hopeless situation? We’ve been using Java for years, telling ourselves we’re developing well-designed applications.
Why should we care about real modularity? Isn’t there enough modularity in plain Java? And what would be the value proposition of modularity in any shape or form?
Anyone can write and maintain Hello World, but no system is as simple as Hello World, and many are at the opposite extreme in terms of complexity.
The drive toward ever more complex systems is inevitable in the digitally connected world that we now live in, but that complexity is now not something any individual can handle.
Just as there are really no “renaissance men” today—the world of science is simply too broad and deep—complete understanding of today’s systems is beyond even the most talented.
So for the question, “Are your applications really modular?” you should already know the answer—it will be defined by the degree of pain you feel when trying to make changes, or the degree of slippage you experience when trying to develop new functionality.
If you don’t know, the answer is almost certainly “no.” That may not matter if you’re a lone developer or part of a small team, but beware—small programs have a funny way of getting bigger quickly, and it’s much easier to keep things in order than it is to untangle them after the fact.
By now you should understand what we mean by modularity and appreciate the need for modularity in Java systems.
But, practically speaking, how do we make Java systems more modular? Part of the answer is in their design: finding the correct granularity, creating the components, and making them work together in a loosely coupled way.
This is what the Spring Framework is all about: decoupling and assembling components.
The lightweight container and the aspect-oriented programming (AOP) system are the main building blocks of Spring.
The Spring Framework isn’t an all-or-nothing solution; you can choose the modules according to your needs, the lightweight container being the glue for the application and the Spring classes.
We’ll see in this section the building blocks of the Spring Framework: its lightweight container, which makes dependency injection a breeze, and its support for AOP and for the development of enterprise applications.
We’ll start immediately by looking at the loosely coupled component model the Spring Framework promotes.
Loose coupling is the first step on the road that leads to true modular programming.
Any object-oriented system is made up of components interacting with each other.
They must be as independent as possible, or one change in the system can trigger cascading changes.
Imagine one of your business services needs to notify other components that a new user has been created.
Why can the previous snippet be considered tightly coupled? The reason is that the notification technology is concretely defined using the JmsNotifier property.
Reuse of the BusinessService with another type of notification technology or even without notification at all wouldn’t be an easy task.
In this snippet, the notification concept is embodied by the Notifier interface, without any reference to the underlying technology.
Figure 1.1 shows how we moved from a tightly coupled solution to a loosely coupled one.
The next problem is to assign the right Notifier implementation.
This is where dependency injection comes in and we let an external system assemble all the application components.
Dependency injection is all about creating, configuring, and wiring components.
The system in charge of doing this assembling is called a lightweight container.
With a container managing their dependencies for them, components don’t need to concern themselves with lookups.
Rod Johnson calls it the Hollywood Principle—“don’t call us, we’ll call you.”
Figure 1.2 illustrates how this container can manage and wire together our components.
Notice that the container API doesn’t leak to our application classes.
Typically, there are a number of ways to configure the component wiring, ranging from XML files to Java annotations to plain text.
The Spring lightweight container offers a rich set of features to do the wiring; the following snippet illustrates the XMLbased configuration for our business service and its Notifier dependency.
The container takes care of each step of a component’s creation (instantiation and wiring), leaving it with no dependencies on any callable class or interface such as a.
Figure 1.1 Introducing an interface helps in moving from a tightly to a loosely coupled solution.
The question now is how can we get the right implementation and stay loosely coupled?
Figure 1.2 When using dependency injection, application classes don’t need to look up their own dependencies—the lightweight container is in charge of assembling the components.
In Spring terminology, the container is referred to as the application context or simply the context.
Combined with interface-based programming, it allows you to write more testable and less tightly coupled code.
Component management (creation and wiring) can then be delegated to lightweight containers, such as Spring.
The Spring Framework can be a great help in your OSGi development: the lightweight container assembles the inner elements of your modules, and Spring DM will take over to make them interact easily with the OSGi platform.
With full control over the component lifecycle, lightweight containers can do much more than wire components together.
In traditional object-oriented programming (OOP), components are loosely coupled and each has its own responsibilities.
Nevertheless, components often require additional features beyond the basic ones they’re meant to provide.
These features are usually related to system services, such as security, logging, or resource management and are called cross-cutting concerns because they tend to cut across components or application layers.
You can deal modularly with these cross-cutting concerns by using aspect-oriented programming and transparently relieving your OOP components from dealing with them directly.
In AOP, the unit of modularity is called an aspect and deals with one cross-cutting concern (the unit of modularity in OOP is the class)
Figure 1.3 illustrates the transition from a pure object-oriented solution to a solution using both object- and aspectoriented programming.
Notice how the business code is tangled up with cross-cutting concerns such as logging and security in the completely object-oriented solution.
By using AOP, cross-cutting concerns are deported to dedicated aspects, and application code doesn’t have to deal with them anymore.
With AOP components, the developer can focus on their core tasks, then the aspects can be easily reused in any situation.
In this way, AOP isn’t meant to replace OOP but rather complements it.
By managing components, Spring is able to apply aspects to them.
Different ways of weaving exist, the simplest being using a proxy in place of the target component.
A POJO is a regular Java object without any dependencies on framework interfaces or classes.
Frameworks like Spring and Hibernate promoted the POJO programming model when standards like EJB 2.x were heavily relying on technical APIs.
The main benefits of using POJO are simplicity and testability.
In a way, POJO set us free from intrusive technical frameworks.
The Spring Framework standard Java features, as long as you stick to interface programming.
Each call to the target is intercepted by the proxy, and any aspect can be called before or after the call is delegated to the target.
The Spring Framework provides AOP features out of the box: the lightweight container has full control over the components, so it can weave them with aspects after their initialization.
Because Spring DM builds a bridge between the Spring Framework and OSGi, you’ll get AOP automatically in your OSGi developments.
Now that you’ve seen the main benefits of the Spring lightweight container, we’ll study what the framework can bring to enterprise developments.
Besides its lightweight container and AOP features, the Spring Framework provides support for a number of Java and Java EE standards and frameworks.
Although these libraries are self-sufficient, configuring and combining them in an application can turn out to be tricky, largely due to their configuration subtleties; Spring is able to handle configuration for the most common cases, leaving you with very simple configuration steps to perform.
If you’re more comfortable with the target framework or use less conventional features, all the regular configuration settings are still available through Spring configuration.
Spring support is particularly useful in the data access area, with its common abstraction layer for transactions and its template-based approach to persistence.
Spring deals with common resource management “plumbing” code and allows for declarative transaction management in various situations ranging from managed environments with JTA (Java Transaction API, the transaction standard in Java) to native database transaction with plain JDBC.
Declarative transaction management is made possible through Spring AOP support and can be applied to any kind of component.
Figure 1.3 With a completely object-oriented solution, business code becomes tangled and cross-cutting concerns are scattered all through the application.
It has no impact on application code, and switching from one environment to another is a matter of configuration.
Application components can focus on their primary task and don’t even know they’re fully transactional.
Transaction management and data access are only a few of the common use cases that the Spring Framework provides support for.
Figure 1.4 shows that Spring support extends to a number of other technologies.
Spring and its philosophy should no longer be a stranger to you, and it should be clear that Spring is the first step toward modularity.
We’ll see in the next section how the OSGi technology pushes the Java platform to its limits to offer true modularity.
As we asserted at the beginning of the chapter, modularity and reusability are key issues in the development of any reasonably sized application, but the Java platform doesn’t provide complete support at this level.
OSGi is a technology that makes it possible to tackle these problems head-on in Java applications.
OSGi relies heavily on Java’s different features and operating mechanisms, and in particular the classloader feature.
This section provides an overview of OSGi, and chapter 2 gives a more comprehensive introduction.
But if you want in-depth coverage of OSGi, you should read Manning’s OSGi in Action, by Richard S.
We understand that you’re stamping with impatience to learn about Spring DM, but if you’re totally new to OSGi, you’ll first need to understand the benefit of the bridge that Spring DM provides.
It defines exactly what a module is (Java defines only deployment units, like JAR or WAR)
Figure 1.4 In addition to supplying the lightweight container, Spring provides support for classic enterprise application scenarios and supports many Java frameworks in a consistent way.
OSGi is divided into a set of layers, each of which provides a brick in the modularity wall.
The next section gives an overview of this layered architecture.
OSGi provides a standardized environment that is divided into different layers, as shown in figure 1.5
Each layer has a role in making the OSGi platform modular: enforcing visibility rules between modules, making modules evolve through a set of states, and providing a broker for modules to communicate with each other.
Every OSGi container is based on the Java virtual machine (JVM) and specifically implements three layers that enable support for dynamic modularity.
The first container layer, the modules layer, is responsible for handling components.
Its main goal is to provide modularity based on the Java platform.
The key building block for this layer is the module or component, which in OSGi is called a bundle.
The module layer enforces visibility rules between modules, and it achieves this thanks to strict classloader isolation.
By default, a component is really a black box in OSGi.
If you want to make things visible, you need to specify them explicitly; conversely, when using classes, the required packages must be specified as being visible before you can reference them from other bundles.
OSGi bundles are standard JAR files, with additional metadata in their manifest file that aims at (among other things) identifying them and configuring the visibility rules.
So the module layer enforces modularity; now let’s see how the lifecycle layer defines a set of states the modules can evolve through.
A developer can install a bundle in an OSGi container; this is the first state a bundle can take: “installed”
Figure 1.5 An OSGi environment builds on top of Java and is divided into three layers, each of which provides a strong foundation for modularity.
It can, for example, be resolved, meaning that all its dependencies are met and that it can now make some its own Java packages visible to other modules.
The lifecycle layer relies on the module layer for classloading and provides a dynamic approach to bundle management, making it possible to update parts of an application without stopping it.
When a bundle gets to the active state, it’s then able to interact with the service registry, powered by the top layer of OSGi.
The service registry is an important part of OSGi because it allows bundles to be used and to interact in a way that takes the dynamic nature of the system into account.
Through the service registry, OSGi offers the ability to register one or several access points to components through services.
Figure 1.6 shows how modules can communicate by registering and consuming services.
The service layer programming model is POJO- and interface-driven: modules only expose what they need to expose in terms of services, making them more loosely coupled.
To summarize, OSGi provides a foundation for developing component- and servicebased solutions.
It implements components through a strict classloader and dependency versioning scheme.
It also provides a platform that follows all the principles of service-oriented architectures in a particularly lightweight way and directly within a JVM.
The strength of this solution is that OSGi enables the implementation of all these mechanisms in a dynamic way.
Indeed, the platform provides the mechanisms necessary to manage components at runtime and to dynamically interact with the service registry to both publish and consume services without stopping and restarting the.
Figure 1.6 Thanks to the service registry, modules can publish and consume services.
They can then communicate in a loosely coupled manner, which enforces modularity.
By using OSGi, monolithic Java EE applications can be split into modules and can leverage the dynamic updates of some of their inner parts.
These dynamic aspects also create new issues, because application features must now take into account the varying presence of entities or services.
The OSGi technology fills the lack of modularity in Java applications by providing a complete and lightweight platform for implementing component-based and serviceoriented applications within a JVM.
We described in the previous section the characteristics of Spring and OSGi and saw that they address a complementary set of features.
That background is important for understanding where Spring DM fits into the mix.
Now we’re ready to see how it’s possible to use Spring technologies in an OSGi environment.
Spring DM provides a powerful modular solution for developing Spring-based applications that can be deployed in an OSGi execution environment.
The aim of the technology is both to make Spring and OSGi work together in a simple way as well as addressing the limitations of the two technologies.
Figure 1.7 shows where Spring DM fits in and how it’s the bridge between components, the service registry, and embedded web containers.
This figure gives a highlevel picture of how Spring DM both allows the embedding of the Spring container within OSGi components and the use of web technology inside an OSGi container.
Why would we want to use Spring DM? Namely to make two different but complementary technologies work together.
Let’s discuss the limitations of both to justify their complementarity.
Figure 1.7 Spring DM is composed of a set of OSGi bundles that become part of the infrastructure when installed in an OSGi container.
They can then manage a Spring application context for bundles or even start a web container inside the OSGi container.
Despite the benefits of the Spring Framework described in section 1.2, it suffers from several drawbacks in particular use cases.
The first one occurs when trying to scale up to large and complex applications.
In this case, a lot of beans need to be configured within the Spring container, making its configuration more difficult to maintain.
In addition, Spring suffers from a lack of modularity and provides no real support to improve this.
For example, there’s no way to limit the visibility of a bean in Spring; any other bean can use it, and it can be looked up from the application context even if it should not be used directly.
Using more than one application context could allow you to split an application into modules more easily, creating clearer boundaries between these modules.
Another limitation of Spring is the static nature of its dependency graph configured using dependency injection.
As soon as bean A is injected into bean B, bean B depends on A.
An application may have hundreds of beans, and these dependencies between beans form a dependency graph.
The limitation arises because the links between beans are created once, mainly at the startup of the container, and there is no built-in support to update them at runtime.
To reload the dependency graph and take any updates into account, the whole application needs to be restarted.
This problem of static coupling is made worse by issues with the instantiation order of beans.
Spring computes a complex dependency graph to determine the order in which beans will be instantiated and injected.
This computation is internal to Spring, and application developers can’t get their hands on it.
If something goes wrong, debugging can be particularly complex, especially when you have a lot of dependencies.
Furthermore, there is very limited support for circular dependencies, putting an even heavier burden on developers to configure their beans correctly.
On the other side of the table, the OSGi core specification doesn’t provide any support for patterns or tools in the design and implementation of bundles.
This is by design, leaving the developer free to choose a suitable architecture and the framework.
Using a framework like Spring can really enhance the power of the platform because it enables the use of dependency injection, AOP, and other modern paradigms.
But “here be dragons” because there are obvious challenges in managing the disparate lifecycles of both Spring and OSGi bundles.
Another challenge in using OSGi relates to the explicit configuration and dynamic behavior of services.
Services are essential in creating any OSGi application because they’re the only safe way to access functionality across bundle boundaries.
But using the service management API is tedious, and managing the dynamic nature of services in user code is extremely error prone.
We can see that the two technologies appear to be mutually complementary, with the whole being potentially greater than the sum of the parts.
Spring DM is a framework, made of a set of OSGi bundles that can be deployed in any OSGi container.
These bundles don’t bring any business features to an OSGi application; instead, they aim at watching other bundles and creating Spring application contexts for them.
This is why Spring DM is sometimes called a bridge between Spring applications and OSGi.
Let’s now focus on how Spring DM makes it easy to work with Spring within OSGi.
In a classical Spring application, a dedicated Spring container is used, and the framework is configured from its enclosing contexts (from the classpath or web environment)
The framework also provides a hierarchical relationship between application contexts while tying them together.
A dedicated Spring container is associated with each Spring DM–powered bundle.
Each container is unconnected with the rest and is internal to its enclosing bundle.
Logically speaking, having separate containers is mandatory because each bundle has its own lifecycle and can appear or disappear at any time.
Spring DM manages all of these containers in a convenient and nonintrusive way.
No code or configuration is required inside a bundle to configure, start, or destroy a Spring container.
All that’s required is that Spring DM’s bundles are installed in the OSGi container, and that the bundle includes a Spring application context configuration file.
The Spring DM bundle in charge of managing Spring-powered bundles is called the Spring DM extender.
Spring DM and SpringSource dm Server We should mention in passing that Spring DM is not SpringSource dm Server, although the names sound similar.
Figure 1.8 The Spring DM extender is an OSGi bundle that scans bundles for Spring configuration files and manages (creates, destroys, and updates) a Spring application context on their behalf.
Spring DM monitors the bundle lifecycle in order to determine when to trigger the appropriate actions.
Once Spring DM is deployed inside an OSGi container, it can automatically detect Spring-powered components based on the presence of the Spring application context configuration file as well as through certain dedicated headers in the manifest file of the bundle.
When a bundle with the appropriate configuration is started, a Spring container is also configured and embedded inside the component.
As well as managing the creation of Spring containers, Spring DM also provides a convenient way to link bundles using the OSGi service registry.
In any OSGi application, simply using package imports and exports isn’t sufficient because these only specify the behavior of class linkages within the application; they do nothing to manage the lifecycle of object instances created from these classes.
This is what makes the OSGi service registry so essential—it provides a well-defined boundary through which object instances can be accessed while still maintaining appropriate class and lifecycle boundaries.
Think of it as being a bit like the old English class system: servants were never allowed to speak directly with the master of the house; instead they had to interact through the butler or another go-between.
It did not matter what the servants looked like, or even whether they were the same servants from one day to the next; the facilities provided to the master of the house were always the same, and hidden behind the austere demeanor of Jeeves or his counterpart.
Where Spring DM improves upon the services of the butler—or the service registry, in our case—is that it provides a very easy and declarative way to configure and reference services from within the Spring configuration itself, even allowing dependency injection of artifacts from the service registry.
The heart of this configuration is a dedicated Spring XML namespace.
Thanks to this mechanism, simple POJOs can be exposed as OSGi services, and OSGi services can be injected into regular Spring beans by using the appropriate elements.
The following code snippet shows how to expose a bean named myService as an OSGi service using the <osgi:service> element.
At the startup of the corresponding Spring container, the service is automatically registered, and it’s unregistered when it’s destroyed.
The following snippet shows the other side of the service coin—referencing and using an OSGi service in a classic Spring bean through the use of the <osgi:reference>
MyService being made available as a bean called myService and then being injected into myBean.
Now you have a better idea of what Spring DM is.
Let’s see the benefits of using it when writing OSGi applications.
Spring DM allows Spring-based applications to be deployed as OSGi bundles.
This allows for true application modularity while still harnessing the power of the Spring Framework.
Spring DM also provides a semantically rich and user-friendly way of linking components by declaratively providing and consuming OSGi services.
All these aspects allow applications to take advantage of the dynamic nature of OSGi.
Spring DM addresses several issues in order to make it easier to use Spring within an OSGi container:
Another important thing to understand is that you aren’t tied to a specific tool when developing your OSGi components, not even Spring DM! You can interact with existing bundles using a variety of different technologies.
Because links between bundles are based on the OSGi-standard service registry, the service consumer doesn’t knowand doesn’t care—what technology was used in the creation of the service.
In the same spirit as the design of the Spring Framework, Spring DM provides a programming model based on best practices and patterns that enable you to use the OSGi technology in an optimal and efficient way.
This is especially true if you have an enterprise application background: you’ll be able to use your favorite libraries and frameworks and the corresponding Spring support in your OSGi bundles.
Now that we’ve introduced all the background of Spring DM and the technologies it leverages, it’s time to see how to implement your first application.
Let’s stick to old programming traditions by providing a Hello World example using Spring DM! Like any other Hello World application, the example will be simplistic but it’ll show you enough of Spring DM to get the concepts.
The example consists of declaring a simple Java bean in a Spring application context and letting Spring DM handle the context creation when the bundle is deployed.
The bean will emit the “Hello World” message at its creation.
You’ll see that Spring DM handles most of the dirty work—application context discovery and bean creation—and that you’ll only have to write the bean class and create XML configuration files.
Before starting the example, take a look at table 1.1, which gives an overview of the various versions of Spring DM and their corresponding requirements and main features.
You can choose the version that best suits your target environment (version of Java or Spring or supported OSGi platform)
If you don’t have any constraints, you should choose Spring DM 2.0 (the latest version at the time of this writing) because it provides the most features and benefits from the latest bug fixes.
This is the version we’ll be using throughout this book.
Nevertheless, the Hello World example should work with any version.
The Hello World example will run in an OSGi container, and as you want to use Spring DM, you need to provision the container with Spring DM’s bundles before creating your Spring-powered bundle.
Most of the necessary bundles are in the Spring DM.
Eclipse is based on OSGi and is built upon Equinox, the Eclipse Foundation OSGi container.
You can type the ss command (for short status) to learn about the container state and the installed bundles:
The only bundle is the container itself; it’s now time to provision it with the Spring DM bundles.
Create a bundles directory at the root of your project, and copy all the necessary bundles listed in table 1.2
All bundles can be found in the Spring DM distribution except for one, the NOP SLF4J implementation.
You can download it from the SpringSource Enterprise Bundle Repository (EBR) by following these steps:
When you first launched Equinox, it created a configuration directory, where it keeps runtime information between executions.
It’s now time to tell Equinox which bundles it has to install each time it starts.
In the configuration directory, create a config.ini file with the following content:
You can start it and check that all the bundles have been resolved and some of them started:
Table 1.2 OSGi bundles for the Hello World project (continued)
The point is that now the Spring DM extender (bundle 8) keeps an eye on each bundle installation to create Spring application contexts for those powered by Spring DM.
Exit from Equinox and get ready to write your first Spring DM OSGi bundle.
Our first bundle will be minimal, because it will contain only one Java class and the necessary configuration files (JAR manifest and Spring DM XML configuration)
Create an src directory at the root of the project and create the following Java class (be careful to create it in the corresponding directory, following Java package conventions):
This class is obviously not useful, but it will emit our Hello World message in the console when Spring DM instantiates it, which is the point of this exercise.
OSGi bundles are standard JAR files with additional headers in the manifest.
The OSGi container uses these headers to identify the bundle: identity, description, version, and so on.
In the src directory, create a META-INF directory with a MANIFEST.MF file in it.
Note that the manifest must contain an empty line at the end (which is hard to illustrate in a book)
By this means, bundles will be able to import classes from our bundle package.
The bundle is a usual OSGi bundle and you’ll never see the Hello World message if you deploy it as is in Equinox.
You want Spring DM to create an instance of the HelloWorld class, and this implies creating a configuration file in the location expected by the Spring DM extender.
The following snippet shows the content you need to add to the file.
Those familiar with Spring will see no difference between declaring the helloWorld bean in an OSGi environment and declaring it in a Spring-based application, mainly because there is no difference at all.
You now have all the pieces of your bundle; you only need to package it before installing it in Equinox.
Copy the whole META-INF directory to the bin directory, and use the jar program to create the archive:
This creates a helloworld.jar file, ready to be deployed in Equinox.
It’s time to install the bundle into Equinox and see how Spring DM handles it.
Equinox answers by giving the bundle ID in the runtime environment, so the console should output something like this:
The bundle ID in your environment can be different from what you see in this text.
Remember this ID because it will be used in subsequent commands.
Check the bundle status by launching the ss command; this bundle appears at the end and is in the INSTALLED state:
The bundle is installed, but there’s no Hello World message on the console yet.
We didn’t miss anything—the bean has not been created yet.
The bundle needs to be started, which will trigger the Spring DM extender and your bundle’s Spring context creation.
Start the bundle, and you should see the long-expected message (use the correct bundle ID after the start command):
Congratulations! You’ve just finished the Spring DM Hello World example! This rather simplistic example shows one of the strengths of Spring DM: you’re.
This follows the Spring philosophy: the framework handles technical concerns, letting the developer concentrate on the application code.
All Java applications eventually have to deal with issues of modularity, both at build time and at runtime.
Making regular Java SE or Java EE applications modular, however, isn’t an easy task; you really need something else to do the heavy lifting.
OSGi is an open and lightweight technology for implementing truly modular Java applications.
Despite the power of this technology, it remains difficult to use, thanks to both the strictness of its classloader isolation model and its lack of support for modern application frameworks such as Spring.
All is not lost, however, because Spring DM is available to address these issues, making it easier to develop Java applications based on the Spring Framework, and web applications in an OSGi environment.
The power of both the Spring Framework and OSGi are harnessed by Spring DM to provide a rich framework for developing component-based and service-oriented applications.
Spring DM allows you to embed a Spring container inside OSGi components and manage these containers using the standard OSGi lifecycle.
Each component, or bundle, can use dependency injection, aspect-oriented programming, and other enterprise support provided by the framework like in any regular Java application outside an OSGi container.
In the next chapter, we’ll describe the key concepts of OSGi in a Spring DM perspective.
Because the tool runs inside an OSGi container, you need to understand how this platform works and become comfortable with OSGi mechanisms.
The next chapter will help you understand the features and mechanisms of Spring DM.
Perhaps you’re wondering how a dedicated chapter on OSGi technology is appropriate to a Spring DM book? As we saw in chapter 1, Spring DM enables the use of the Spring Framework within an OSGi environment.
Spring is really popular at the moment, and many Java developers know of its features: dependency injection, AOP, and its approach to structuring Java applications and simplifying development of enterprise Java applications.
In contrast, the term “OSGi” is reasonably well known, but its features are much less so.
Most developers and architects probably know that the technology addresses the modularity of applications but little else.
We’re strongly convinced that some OSGi features need to be understood in detail before you can understand and fully utilize Spring DM correctly.
As this book is about Spring DM, we’ll focus our discussion of the OSGi technology to the context of the framework and emphasize the most important aspects to make learning it easier.
Let’s now look at the OSGi technology and how you can take advantage of it within your Java applications.
Because we provided a high-level description of OSGi’s features in chapter 1, we won’t describe those key concepts again.
We’ll go ahead and show, in more detail, how the technology works and how to use its features.
As emphasized in chapter 1, the core concept of OSGi is the component, called a bundle in this context.
It leverages the existing Java packaging support and uses only elements, concepts, and mechanisms present in this Java technology.
In this section, we’ll describe what an OSGi component is and how to configure it, and we’ll introduce the concept of the OSGi container, which manages components based on a specific lifecycle.
The structure of OSGi components is quite similar to that of traditional Java JAR files.
It enables you to configure the different properties of a component and its behavior within the OSGi container.
Other JAR files, allowing for the inclusion of libraries and frameworks in a bundle.
Unlike classic JAR files, these files can be used internally by the component by specifying them within the OSGi Bundle-Classpath header.
Figure 2.1 sums up all the possible content of an OSGi bundle.
Note that embedded JARs are acknowledged as first-class participants in the makeup of the JAR.
Figure 2.1 An OSGI component can contain classes, configuration, resource files, and other JAR files, all of which make up the operating pieces used by the component.
The main way in which a bundle differs from a JAR file can be found in the new headers within the manifest file used to configure the bundle.
Let’s look at these different headers and what they allow you to configure.
Unlike classic JAR files, each OSGi component needs to specify information that’s used to identify it and describe its behavior inside the OSGi container.
The entire bundle configuration must be provided in the manifest file contained in the bundle JAR file.
Table 2.1 lists the main OSGi headers usable in a bundle’s manifest file.
You’ll notice that this list contains no headers for describing OSGi services.
The core specification only allows services to be defined using the OSGi API, as described in section 2.4
Table 2.1 The main OSGi headers used in a bundle’s manifest file.
This name must be unique for the same Bundle-Version number, and using the reverse domain name of the root package of the classes in the bundle is recommended.
Import-Package Specifies the names and versions of class packages that the component is dependent on.
The components providing packages don’t need to be specified here.
This header forms part of OSGi’s dependency management and will be described in section 2.2
Export-Package Specifies the names and versions of packages contained in the component that should be made available to other components.
This header also forms part of OSGi’s dependency management and will be described in section 2.2
The main difference between this and Import-Package is when the resolution of specified dependencies occurs.
Dependencies aren’t resolved when the OSGi container tries to change the bundle state to resolved but when a class from the package is actually used.
This header also forms part of OSGi’s dependency management and will be described in section 2.2
Using extra manifest headers to configure a JAR file is quite common in other Java technologies.
For OSGi, you have to learn the new OSGi headers and their meanings.
The name and value of a header must be separated by the a colon and a space character (: )
Listing 2.1 shows that OSGi makes it possible to specify a collection of values for a header with the comma (,) separator character.
Moreover, the technology allows you to apply much more complex configuration by specifying additional parameters for these values.
This kind of parameter is called a directive, and it usually modifies the meaning of the header.
A directive consists of a key and a value separated by the colon and equal characters (:=), and you can specify several directives for the same header value by using the.
In this case, all the packages provided by the specified components are automatically imported.
This header also forms part of OSGi’s dependency management and will be described in section 2.2
Bundle-Activator Corresponds to the class name that will be used to initialize and finalize the bundle when it’s started and stopped.
Bundle-Classpath Specifies the internal classpath, based on elements present in the component JAR file.
By default, when the header is omitted, the value corresponds to “.”, meaning that all the classes in the bundle are taken into account.
In this case, remember to add the value “.” to use the classes within the bundles.
Table 2.1 The main OSGi headers used in a bundle’s manifest file (continued)
The value of a directive can itself contain a list of values, making the whole header value quite difficult to read.
An attribute also consists of a key and a value, but in this case they’re separated by the equal character (=)
Attributes play an important role in the matching between exported and imported package configuration.
The configuration of a header follows the syntax illustrated in the following snippet:
This kind of configuration using headers and their associated directives and attributes is particularly useful when configuring dependencies for versions and resolution strategies.
The following snippet shows a real use case of directives and attributes in the configuration of Spring’s spring-beans.jar file.
Notice that this declaration uses the resolution directive and the version attribute.
Now that you know what an OSGi component is, what it can contain, and what rules must be followed to configure it, let’s see what an OSGi container looks like and what mechanisms and lifecycles it provides for managing these components.
The OSGi specification describes a platform for managing components and services.
An implementation of the specification is generally called an OSGi container, and using OSGi usually requires using such a container.
Because the OSGi specification is freely accessible through the OSGi Alliance website (http://www.osgi.org), several open source implementations are available.
These containers provide the basic OSGi platform components as described in the OSGi Alliance specification, but most of them also provide convenient administration tools for interacting with the container.
The more popular ones have console- and web-based interfaces, allowing you to see the details of all the components inside the container and allowing for convenient management and error diagnosis.
Equinox also extends the specification specifically to suit the needs of the IDE by providing extension points.
These allow enhanced component-based features, making it possible for components to register for the services of the extended features of a component.
This feature is widely used to extend the UI of the Eclipse platform.
We’ve seen in this section that an OSGi container is responsible for component management.
Let’s look now in more detail at the lifecycle services they provide to components.
We looked at the component lifecycle briefly in chapter 1, and we’ll expand on that now.
Each OSGi container manages components, also called bundles, and their lifecycles with associated states, transitions, and events.
This mechanism has some similarities to the way the Spring lightweight container uses events to initialize and finalize POJOs.
With OSGi technology, the component lifecycle is more tightly linked to the availability of components within the container and the resolution of their dependencies.
Let’s take a high-level look at the management of an OSGi component from cradle to grave.
In the first part, the component is installed into the container without trying to resolve its dependencies.
The resolution of dependencies takes place next, when the component tries to reach the resolved state.
If errors occur during the resolution of dependencies, the component remains in the installed state.
You’ll notice that OSGi allows the refreshing of components, and when this happens, dependency resolution must be performed again.
During these steps, other components in the container can’t use the component.
Figure 2.2 shows the different states, transitions, and events in the first part of the lifecycle.
Equinox The OSGi implementation from the Eclipse platform, which is the foundation for the plug-in model of the Eclipse IDE.
This container can be used outside Eclipse and is available at http://www.eclipse.org/equinox/
Figure 2.2 The first part of the OSGi component lifecycle: components are installed and their dependencies resolved.
The second part of the lifecycle involves making components available in the container for execution and making their code executable by other components.
The main state here is the active state, which is reached thanks to a start event.
The component first passes through a transitional state called starting.
When returning to the resolved state, OSGi triggers a stop event on the component, which then passes through another transitional state called stopping.
Figure 2.3 shows the different states of the second part of this lifecycle.
As you can see, understanding the OSGi lifecycle is important because it’s tightly tied to the bundle’s availability.
We’ll also see in section 2.2 that the resolution of dependencies is done according to this lifecycle.
When trying to diagnose problems, understanding the states of components is fundamental (as described later in section 2.6)
We’ve seen the core concepts relating to OSGi components, the key elements of the OSGi technology, and how they’re managed by the OSGi container.
Components form the core of OSGi, but because components are intended to work together and interact, OSGi provides complete support for managing component dependencies and controlling the visibility of component internals.
Having structured an application based on OSGi components, the next step is to orchestrate their interactions using the mechanisms provided by OSGi to control the versioning and visibility of component internals.
OSGi provides sophisticated support for dependency management at runtime through classloader management.
In the following sections, we’ll focus on the features related to dependency management.
We’ll see how OSGi applications are different from classic Java applications, though they bear similarities to container-managed enterprise applications because of the classloader management.
We’ll then deal with the configuration of components and how they reference each other.
Finally we’ll see how OSGi handles the matching of producer to consumer components and the management of their versioning.
Nothing is visible from outside except packages getting configured as boot delegation packages within the container, like the java package.
The component can only use resources that it contains; OSGi enables private classes to be scoped to a component.
Component dependencies our real interest here is in arranging these components into applications within the container.
This visibility feature is implemented and enforced using the classloader feature of Java.
It’s essential to have a clear understanding of how the OSGi technology handles classloading in order to understand what is going on in the OSGi container and to resolve errors when they occur.
Imagine you want to use several Java libraries or frameworks that use different and incompatible versions of the same library.
This problem is commonly called “JAR hell,” and there is currently no built-in solution in the Java platform to address this problem.
This processing is done on demand by the JVM when a class needs to be used.
The appropriate classloader searches the known location of classes, reads their contents, and loads them.
Before describing the way OSGi uses classloaders, let’s recap how default classloaders work in Java.
Classloader technology is based on a hierarchical approach to handling class resolutions, and Java integrates three types of classloaders:
Bootstrap classloader—Loads classes from the core Java libraries present in the lib directory of your java home directory.
Extension classloader—Loads classes from the lib/ext directory of your Java platform or any directory specified in the java.ext.dirs system property.
Application classloader—Loads classes based on the elements specified in the application classpath.
In order to load a class, a classloader first asks its parent if it’s able to load the class.
Figure 2.4 shows this mechanism and the relationship between the three classloaders.
As you can see, in Java the same classloaders are used to resolve all the classes of an application, which makes it difficult to isolate the resolution of different classes.
OSGi technology provides a different approach to using classloaders; it’s not based on a hierarchical approach but on the concept of classloader chaining, which allows fined-grained control of the visibility of classes from each other.
In this context, each component is associated with a dedicated classloader.
According to the component configuration, this classloader is linked to other components’ classloaders for the resolution of classes outside the current component.
Having classloaders dedicated to components makes isolation between components possible, and, by default, no class can be seen outside a component.
Instead, you need to explicitly import and export them by configuring the corresponding packages in the manifest files.
Figure 2.5 sums up this resolution process, called classloader chaining, by showing the links between component class loaders.
For the sake of simplicity, we associated a class loader with each component, but the implementation can differ depending on the configuration of the OSGi container.
We stated earlier that we must specify the required packages in the manifest file.
This configuration can be accomplished in two ways: declaring which packages—and hence classes—are visible and usable within the container, or declaring which OSGi components should be used.
The JSR is based on a similar approach to the OSGi Require-Bundle header but with a greater emphasis on language support and the runtime modularity of the JDK itself.
Before you can use the classes of other components, you must first make these classes visible.
OSGi doesn’t allow you to specify class visibility at the class level, but instead at the level of the containing package.
When specifying a package, the subpackages aren’t exported by default, which means you need to explicitly specify each one if you want to export them all.
This also means that when using this mechanism, the way you organize your classes becomes very important, because truly public and internal classes must be located in separate packages.
Of course, classes within private packages still have a role to play and can be used to hide classes in a package from other components.
Making the classes of a package visible from a bundle is an easy task.
You simply have to add the fully qualified package name to the value of the Export-Package header in the bundle’s manifest file, as shown in the following snippet:
If you only specify a list of packages, the default properties and behavior are used, but the header can provide finer-grained configuration thanks to dedicated directives that can be associated with each package name.
In addition to these directives, the version attribute can be added to specify the version of the exported package.
All these attributes can take part in the matching algorithm, which will be described in section 2.2.5
The following snippet shows an extract of the manifest file from the springbeans.jar file, showing its use of the Export-Package header together with the uses directive and the version attribute.
This directive is used by the dependency resolver to ensure that imported package versions correspond to those specified here.
The use of the Export-Package header provides other components with access to component classes.
When using those classes, the components need to explicitly specify that they want to consume them.
OSGi provides several different ways to do this, again through dedicated headers specifying packages or components.
The most common—and recommended—way is to specify Import-Package in the manifest, which makes it possible to use classes from the specified package in a component.
If this package has been exported by another component, the package is made visible to the consumer using the matching mechanism (which will be described in section 2.2.5)
By using this header, the package consumer doesn’t need to know which bundle exported it because the container handles the matching.
For the Import-Package header, the OSGi specification defines the standard attributes listed in table 2.4
In the case of a fragment bundle, the name will correspond to the host bundle’s symbolic name instead.
A fragment is a special bundle that allows extending an existing bundle.
All these attributes make possible fine-grained selection of the packages.
The following snippet shows how you can use the version attribute in the Import-Package header.
By default, the processing of the header content corresponds to the mechanism described in section 2.1.4
As we saw, the resolution is performed immediately prior to the bundle transitioning to the resolved state.
If problems occur during dependency resolution, the component remains in the installed state.
In addition to the previous attribute, the resolution directive of the ImportPackage header makes it possible to change the behavior of this resolution mechanism.
The first possible value of the directive is mandatory, which is also the default.
When a package is marked as mandatory, it means that if the package can’t be resolved, the component itself can’t be resolved.
In this case, if the package isn’t present during the resolution phase, the package isn’t considered imported by the component.
To better understand the behavior of this feature, imagine you want to use the spring-beans.jar file from the Spring Framework.
For your application, using a small number of the classes in the JAR file may be enough, so you only need to specify the packages of the classes you use.
Additionally, you don’t require features of the component that require additional dependencies.
In order for your application to resolve without these dependencies being present in the container, Spring specifies them using the optional value for the resolution directive.
Classes of these packages are now visible and usable within the components.
Figure 2.6 describes links between the components involved in the previous snippet.
It makes it possible to bypass the regular class-resolution mechanism we have described and instead allows classes to be loaded on demand at runtime.
Dependencies specified in this way are ignored during the transition between the installed and resolved states.
Moreover, these imports are searched for in the order in which they are specified.
This ordering is important, especially when using wildcards, because it determines the order in which matching occurs.
In the following snippet, packages with the value test for the attribute myattribute will be preferred over other packages.
OSGi also provides another approach, based on the Require-Bundle header, to directly import all the exported packages of a component.
The Require-Bundle header is provided by the OSGi specification so you can consume all exported packages from other components based on component symbolic names.
In this case, you directly specify the bundle you need, and the OSGi container gives you access to all packages it exports, regardless of whether or not you need.
Whereas the configuration using this header is much less verbose, it has the disadvantage of tying the component to the specific dependency that exports the packages.
Although its use is recommended for developing Eclipse plug-ins, using the Import-Package header is generally preferable because it more effectively decouples providers from consumers.
As with the previously described headers for consuming packages, the value of this header contains a list of element names, but this time they aren’t package names but rather bundle symbolic names.
The matching between exported and imported entities is still based on attributes, but only one standard attribute is defined by the OSGi specification: the bundle-version attribute.
The bundle-version attribute uses the same semantics as the version attribute of the Import-Package header and specifies the component version of the dependency.
The following snippet shows a simple use of the Require-Bundle header.
Import-Package and Require-Bundle headers can both be specified in the manifest configuration of a bundle, but the Import-Package header takes priority over the Require-Bundle header.
Moreover, packages that are implicitly exported by a Require-Bundle header and imported via an Import-Package header must not be treated as split packages.
When using the Require-Bundle header, the directive mechanism can be used to adapt the handling of the header.
Split packages You saw that referencing bundles with the Require-Bundle header is equivalent to importing all of their exported packages.
A problematic case occurs when two different required bundles export the same package.
Such packages are named split packages because their content comes from several bundles.
Although OSGi allows split packages, you’ll notice that they have several obvious drawbacks.
When different bundles provide the same classes, unpredictable shadowing of classes can arise.
In describing the headers for importing and exporting packages, we introduced the matching mechanism of OSGi.
This mechanism is powerful and flexible because it gives very fined-grained control over the individual elements specified in ExportPackage, Import-Package, and Require-Bundle.
We’ll now dive into the details of the matching and versioning mechanisms provided by OSGi and describe the matching of versions and attributes and the handling of optional dependencies.
The version concept is a key feature of OSGi dependency management.
As a matter of fact, OSGi allows several versions of the same bundle or of the same package to coexist within a container.
The version makes it possible to select which dependency to use.
Table 2.6 shows the parts that make up a version value.
You’ll notice that this format isn’t specific to OSGi and is generally used by libraries and frameworks.
These values can be used, for instance, in the version attribute, as shown in the following snippet:
If set to mandatory (the default value), the dependency must be successfully resolved for the bundle to resolve.
With the optional value, dependencies are only resolved if they’re present, and the bundle will resolve regardless.
Major number For major updates with no provision for compatibility with previous major versions.
Minor number For functional updates compatible with the current major version (compatible for clients using an interface, but not for implementers)
Qualifier Values like “–SNAPSHOT” for the current development version can also be added at the end of the value.
The version number with a qualifier is lower than the number without.
When matching packages, the OSGi container tries to find an exported package with a version number equal to or greater than the one specified in the importing component.
Specifying nothing when exporting a package means that the default version 0.0.0 is used.
For importing packages or components, OSGi allows you to specify either specific versions or a range of versions as the value for the version or bundle-version attributes.
These attributes define the compatibility range of a component when using a dependency.
The OSGi specification uses a mathematical convention for interval notation, used to define a range.
The notation contains two parts separated by the comma (,) character: the floor and ceiling values.
These values must be enclosed by the opening bracket characters “(” or “[” and the closing bracket characters “)” or “]”
The parentheses, ( ), specify that the end value of the range must not be included; the opposite is true with the bracket characters, [ ]
You’ll notice that a single version value is equivalent to the interval [version,?) and no version to the interval [0.0.0,?)
This implies handling specific entries in the manifest file of your bundles, but you should be aware that you usually won’t maintain the manifest file by hand.
Tools (such as Eclipse PDE, Bnd, and Bundlor) can help you easily and efficiently manage the manifest file, and they can easily be integrated with building tools like Ant or Maven.
Table 2.7 shows examples of common version expressions and their matching characteristics.
The following code snippet from the Spring Framework’s spring-beans.jar file shows how to specify version ranges within the Import-Package header:
Figure 2.7 shows the relationships between components at the version levels specified in the previous snippet.
OSGi also allows you to match packages by selecting a specific provider; for instance, if several components provide the same package with the same version.
This selection can be done by adding the symbolic-name and bundle-version attributes.
As a matter of fact, when packages are exported, these attributes are automatically added by the container and can then be used for matching.
The main drawback to using this approach is that you’re tying yourself to a specific component.
A dependency can be tagged as optional in the dependency configuration of a component with the optional value for the resolution directive.
The dependency is then not considered mandatory and will be used and imported if present and not otherwise.
OSGi supports this mechanism on both packages and bundles with the ImportPackage and Require-Bundle headers.
This feature is particularly useful for frameworks and libraries that have associated tooling.
Component dependencies the tool components don’t need to be present in the OSGi container for the components to be used.
For example, Spring components import all packages corresponding to third-party libraries for all parts of the framework.
You commonly only use a part of the framework and its related libraries, so all the imported packages are marked as optional.
You only need to specify libraries as mandatory for the parts of the Spring Framework you use within the container.
These components can be successfully started without the other dependencies.
The last feature related to matching is support for attributes.
Although the OSGi specification defines standard attributes like version and bundle-version, you’re also free to specify your own.
OSGi provides a generic mechanism for using all attributes when handling dependency matching.
Note that you should use this feature as a last resort—the standard attributes can usually handle dependencies in OSGi applications.
As described earlier, an attribute consists of a key and a value separated by the equal character (=), and which can be applied at the end of a header value separated with the semicolon (;)
Zero or more attributes can be specified in this way jointly with directives, as shown in this snippet:
When exporting packages with the Export-Package header, custom attributes can be added for each package.
These attributes can also be used when importing packages for fine-grained matching.
The use of attributes isn’t mandatory except if they’re specified in the value of the mandatory directive.
A package import without the attribute, or with this one and the value "Manning", will resolve successfully, as shown in the following snippet:
If, in the export configuration, the mandatory directive is added with the criteria value, as shown in the following snippet, the use of this attribute is then mandatory for resolution to be successful:
Figure 2.8 summarizes the attribute-matching mechanism according to the presence of attributes and the mandatory attribute.
Now that we’ve described how OSGi manages dependencies of components, we’ll focus on how the technology allows interaction with the corresponding container.
Because OSGi is intrinsically dynamic, it offers ways to interact with containers and manage the lifecycle of components and services through the use of a dedicated API.
This is very important, as it enables components to adapt their behavior based on updates to other components.
The bundle context, encapsulated in the BundleContext interface, is the central entity that makes it possible to interact with the container in different ways:
Managing and using bundles—You can access every bundle in the container, regardless of status, and manipulate them using the Bundle interface.
Handling bundle lifecycles—You can get the current state of the bundle and eventually update it.
The following subsections will cover all the features in this list (except for services, which will be discussed in section 2.4)
In the last subsection (2.3.6), we’ll describe how to obtain an instance of BundleContext by using the bundle activator.
The OSGi API observes the same class visibility rules as other APIs, and you need to import the corresponding package in order to use it.
When using the mandatory attribute, the specified attribute (criteria, in this example) is required for a successful match.
You can interact with bundles at several levels both to get information about the bundles’ configuration and contents and to manage them.
The first step consists of obtaining references to the bundles you want to interact with.
The getBundles method returns an array containing all the bundles installed in the container.
The getBundle method returns a particular instance of a bundle using its internal identifier within the container, which must be passed as a parameter.
This identifier is managed by the container and is different from the bundle’s symbolic name defined in the manifest file.
The getBundle method without parameters returns the current bundle associated with the context, which usually turns out to be the bundle in which the method is called.
The following snippet shows how to use these methods from a BundleContext instance to obtain references to the bundles present in the container:
Once you have obtained an instance of a bundle, the Bundle interface allows you access to the general information about the bundle and more generally to its whole configuration, which is defined in the manifest file.
The identifier, the install location, and the symbolic name of a bundle can be accessed using the getBundleId, getLocation, and getSymbolicName methods.
And the getHeaders method can be used to access all the headers present in the manifest file of a bundle.
Listing 2.2 Accessing general and configuration information about a bundle.
The Bundle interface also allows you to access the content of a particular bundle.
When accessing this content, OSGi bypasses the classloader and its visibility mechanisms.
You should be aware that accessing bundle resources this way can retrieve content from both the bundle and its attached fragments.
You can directly access a particular resource using the getResource method and providing its path.
The path is always relative to the root of the bundle classpath and may begin with the slash (/) character.
With this method, you must know the exact resource path in advance, but this isn’t always possible for applications.
This method also allows you to see resources present in imported packages.
Suppose you wanted to retrieve all the resources present under the META-INF/ spring folder of a bundle—the findEntries method would be preferable in this case.
Its first parameter is the root directory for the search, with the path following the same rules as for getResource.
The last parameter allows you to enable recursion for the search.
The following snippet shows how to use the getResource and findEntries methods:
In this example, getResource gets a particular file in the bundle, and findEntries gets all files inside a directory in the bundle.
The Bundle interface includes a set of constants corresponding to all the possible states of a bundle.
A component can be installed in the current OSGi container using one of the installBundle methods of the BundleContext interface.
After the method’s execution returns, the component is present in the container in an installed state.
The following snippet shows how to install a component using the OSGi API.
After having set the absolute path to locate the bundle JAR file, the installBundle method can be used to install the bundle.
After this task done, the state of the bundle is Bundle.INSTALLED.
The Bundle interface allows you to manage the component states programmatically, using the methods listed in table 2.9
Once a bundle is installed, using the start method tries to move the component into the active state via the resolved state.
The bundle reaches the active state if no exception occurs during its dependency resolution and activation.
The following snippet shows how to use the start method.
Starting Bundle is starting, moving from the resolved to the active state.
Active Bundle is available to do work within the OSGi container.
Stopping Bundle is stopping, moving from the active to the resolved state.
Table 2.9 Bundle interface methods related to component state management.
After a successful execution of this method, the component can no longer be seen in the container.
If the initial state of the bundle is active, starting, or stopping, the method attempts to stop it before trying to update.
After the update, the bundle state is set to installed.
After you’ve started the bundle using the start method, the bundle state moves to Bundle.ACTIVE.
Several global properties are defined by the OSGi container, and you can access their values via the BundleContext’s getProperty method.
Several property keys are standardized in the OSGi specification and are present in the Constants interface—these constants can be used as parameters of the getProperty method:
Listing 2.3 shows how to use the getProperty method to access to the name and version of the OSGi container.
Note that if the key searched for isn’t found in the OSGi container’s properties, it’s then searched for in the JVM’s system properties.
OSGi provides first-class event support, which is useful for handling the dynamic aspects of the technology.
Imagine that a dependency disappears from the OSGi container—all the components using it need to be notified in order to change their behavior and avoid errors.
OSGi’s event support allows you to achieve this regardless of whether the event occurs because of changes in the OSGi container itself, in.
Interacting with the OSGi container bundles present in the container, or in changes to services.
We’ll focus here on support for events at the bundle level; we’ll cover service support in section 2.4
OSGi’s event support at the bundle level allows code to be notified of every update to the state of a component during its lifetime.
Once the event listener is notified, it can change the behavior of the system according to the new state.
Both interfaces contain a bundleChanged method that provides the triggering event object itself.
This event object is of type BundleEvent, and it includes both the event type and the component triggering the event, as shown in the following snippet:
Listing 2.4 shows a simple use of the BundleListener interface to detect asynchronously the start and the stop of components within the OSGi container.
When such events occur, the listener prints the information in the standard console.
Listing 2.4 Handling a bundle event in an asynchronous listener.
Once you have implemented one of these listeners, you need to register it with the container by using the BundleContext instance and its addBundleListener method.
This work is handled by a special listener bundle, also called an extender.
Each OSGi container has a dedicated area where it stores persistent information, and this area is accessible through the BundleContext interface’s getDataFile method.
The parameter of the method is the relative path of the file within the area.
If the file doesn’t exist, it is automatically created by the OSGi container the first time information is written to it.
The getDataFile method returns a File object, so the Java IO API can be used to manage persistent data as for any regular Java application.
Listing 2.5 shows how to write to a file located in the persistent storage area.
The persistent storage area for a component is destroyed when the component is uninstalled, but OSGi containers preserve these areas between restarts and updates for a component.
As we’ve seen, the entry point for using the OSGi API is the BundleContext interface.
It gives you access to all the entities and interfaces in the container and allows you to manage the current bundle as well as others.
Listing 2.5 Interacting with the persistent storage area of a component.
Interacting with the OSGi container obtain an instance of this class.
Because bundles are managed within an OSGi container, the container will provide an instance of BundleContext at a specific point in the component lifecycle, thanks to an entity called an activator..
An activator is registered on a per-bundle basis and is notified when its bundle starts and stops.
Activators implement the BundleActivator interface, which requires two methods to be implemented, corresponding to the start and stop events, as shown in the following snippet:
The start method is called when the bundle is started; stop is called when the bundle is stopped.
The OSGi container ensures that the stop method will only be called if the start method successfully executes.
The container also guarantees that the same instance of the activator is used in both cases, making it possible to share instance attributes between the methods.
Figure 2.9 shows when the OSGi container triggers the methods of an activator in the context of the lifecycle of a bundle.
As you can see, the bundle activator provides a convenient way to initialize and finalize a bundle.
Listing 2.6 shows a simple implementation of the BundleActivator interface, which registers services on component startup and unregisters them at shutdown.
Because the framework can’t automatically detect the activator use, the activator’s class for your bundle must be explicitly specified.
Only one class of this kind can be used by a bundle, and this class must be contained inside the bundle.
The activator is configured in the manifest file for the bundle by using the BundleActivator header.
The header’s value is the fully qualified name of the activator class, as shown in the following snippet:
Now that we’ve described how to implement and use bundle activators, let’s see how the service support works within OSGi and how it handles the dynamic nature of the technology.
Having described the characteristics of OSGi components, how they’re managed by OSGi containers, and how OSGi handles the visibility of component content and component dependencies, we’ll now deal with OSGi’s last main core feature, the support for services.
OSGi services provide a robust way for components to interact with each other in an OSGi container, taking into account the dynamic nature of the OSGi technology (described in chapter 1)
The OSGi services feature is based on the service registry, which provides nameand property-based lookup, registration, and management of all service instances registered in the container.
It also can be used to notify components when changes occur, to prevent errors from occurring.
Figure 2.10 summarizes the possible interactions between the service registry and OSGi components.
OSGi services are a feature of the OSGi container, so the same rules of class visibility apply.
The component providing a service must also make sure that the packages required by the service are available.
This is a common requirement, as the bundle providing a service and the bundle providing the service type are usually different bundles (to provide better decoupling)
Activator mechanism and Spring DM Spring DM made the choice not to use the activator mechanism to manage Spring DM–powered components because this approach is intrusive for bundle configuration and can’t be configured globally.
Each bundle activator would have to have been configured explicitly in each Spring DM–powered bundle.
Instead, Spring DM chose the extender pattern to manage the initialization and finalization operations; this pattern allows Spring DM–powered bundles to be handled consistently without using activators.
OSGi services are implemented as regular POJOs—they don’t need to implement the OSGi APIs.
Interface-based programming is recommended when defining services, but it’s not mandatory.
Once you’ve developed a service, the only thing you need to do to make it usable is to register it in the OSGi service registry.
This is done with OSGi APIs present in the BundleContext interface.
When implementing a service using interface-based programming, it’s important to put the service interface and its implementation into separate packages.
Although this separation isn’t required, because services reside inside the OSGi container, the package visibility features allow you to expose only the contract of the service while hiding its implementation.
To achieve this, only the package containing the interface must be exported; that way nobody can see the implementation and become tightly coupled with the bundle internals by using the implementation directly.
To demonstrate this structuring, let’s consider a simple Hello World service that takes a string parameter and returns it embedded in a new string.
The service interface named SimpleService contains a single method named test.
The following snippet shows a simple POJO implementation of this interface:
Once the service is implemented, you can register it with the OSGi service registry by using one of the two registerService methods on the BundleContext interface.
These two methods take three parameters and have similar parameters, as listed in table 2.10
Only the first parameter changes, depending on the number of classes or interfaces specified.
If several classes or interfaces must be specified, the type of the parameter is an array of objects instead of a single object.
Concerning service properties, the OSGi container automatically inserts two additional properties that are related to the service identifier (service.id) and the classes used for the registration (objectClass)
Listing 2.7 shows a typical usage of one registerService method to register and unregister a service within an OSGi activator.
As shown in table 2.10, instead of the instance of the service itself, an instance of the ServiceFactory interface can be registered.
As a matter of fact, this mechanism allows you to provide different service instance types according to the bundle using the service or to maintain state.
In OSGi, these names correspond to the names of the service classes or, if interface-based programming is used, the names of the implementing interfaces.
Several services with the same name can coexist within the OSGi service registry.
The value can be null if there are no properties.
When a bundle tries to obtain an instance of this service, the getService method , which is responsible for creating the real service instance, is called.
When the service instance is no longer used by the bundle, the ungetService method is called to clear resources stored in the service factory.
To demonstrate the use of a service factory, imagine you want to provide particular service instances for bundles whose names begin with “com.manning”
Note that implementations of this interface are used by the container and therefore must be thread-safe.
The instance returned by the getService method is cached by the framework until the bundle releases the service.
Service registration with Spring DM As you can see in listing 2.7, when using only core OSGi, service registration must be done programmatically.
Conversely Spring DM provides a dedicated Spring XML namespace for registering services declaratively.
During the registration, Spring DM adds additional information to the service properties.
Note that other frameworks like Declarative Services or iPOJO also offer a declarative way to interact with the OSGi environment, but they’re not backed up by the Spring Framework the way Spring DM is.
The OSGi API provides access to all services present in the OSGi service registry.
As explained in chapter 1, the service registry is the feature that makes it possible for bundles to interact with each other in a way that takes the dynamic nature of the system into account.
As with registering services, the OSGi API must be used to obtain, and then use, service instances.
The OSGi technology offers two specific approaches for accomplishing this.
The first, and lowest-level, method of using services requires that you explicitly manage instances of service references yourself.
Get a ServiceReference instance for the service, based on the service name from the BundleContext instance.
The ServiceReference interface makes it possible to add one level of indirection between bundles and service instances, because when you want to use the service, you must get the service instance from the corresponding ServiceReference instance.
Get the service instance itself, based on the BundleContext instance and the previously obtained ServiceReference instance.
Listing 2.9 shows a typical approach to getting, using, and freeing a service instance.
The ungetService method is called at the end to notify the container that we’ve finished using the service.
Service names When registering a service, the convention is to use the interface that the service implements as the name in the service registry.
The OSGi framework requires the name to match an interface that is implemented or the name of the registered object’s class or one of its superclasses.
But if you register an implementation name, then look up the interface name, the lookup will fail unless you have physically registered both interface and implementation names.
Fortunately, Spring DM has some schemes for making the matching of class names within a hierarchy more natural.
ServiceReference instances can also be obtained by using bundle instances, which provide the following methods:
In addition to providing these low level APIs for accessing services, OSGi offers a utility class named ServiceTracker.
ServiceTracker correctly and transparently gets and ungets services based on service events, greatly simplifying the handling of service lifecycles.
When using ServiceTracker, you no longer need to manipulate instances of ServiceReference type.
The first step in using ServiceTracker is to create a ServiceTracker instance for a service or set of services, then call its open method.
Then you can obtain service instances using its getService method.
Because the class is generic, you need to cast the return instance.
When you have finished using the ServiceTracker instance, you only have to close it.
OSGi and generics You’ll notice that many of the OSGi APIs have a distinctly “old Java” feel to them, leveraging none of the ease-of-use features introduced in Java 5, such as generics and covariant return types.
Service registration even takes a Dictionary object (a class that was made obsolete in Java SE 1.2) rather than a Map! This is because OSGi is designed with maximum portability in mind, being targeted at not just enterprise systems, but also embedded and Java ME-style applications, where the JVM version typically trails the state of the art significantly.
Fortunately this restriction is likely to be lifted in OSGi R5
Applications using OSGi services likewise need to take account of service availability.
OSGi will notify registered observers when events are triggered, providing information such as the service properties, the registering bundle, and the bundles that use the service.
OSGi provides the ServiceListener interface, shown in the following snippet, to handle these events:
Referencing services with Spring DM Spring DM allows you to reference an OSGi service directly by configuring dependencies, thanks to its custom namespace.
The reference is then treated by Spring as a regular Java bean.
The referencing mechanisms are directly integrated into the Spring DM Framework itself, and the tricky work of handling OSGi dynamics is done transparently for you (assuming that the dynamics don’t involve services with state, especially state that can depend on the clients using the services)
Throughout this book, we say that the use of this API is tedious and error-prone, but this is mainly a matter of point of view.
The OSGi API is tedious and error-prone for application developers who would use it every day to build enterprise applications, but we don’t blame the OSGi Alliance for the API they designed, because it’s well suited for middleware development.
We’re sure that the teams who developed tools like Spring DM, iPOJO, and Declarative Services implementations have been happy to work with such an efficient API.
This interface contains a serviceChanged method, which provides the event object, of type ServiceEvent.
This event object contains both the event type and the relevant ServiceReference, as shown in the following snippet:
Listing 2.11 shows a simple example of using of this interface to print a message whenever a service is registered, unregistered, or updated.
Let’s now see the last big feature of the OSGi technologyhow it handles native code within components.
This support includes loading the correct library based on the OS of the target host.
As with any Java program, JNI must be used within the Java code wishing to call a native library.
This configuration of native libraries is done using the Bundle-NativeCode header, which defines the location of native libraries inside components and supports the set of attributes listed in table 2.11
Java Native Interface (JNI) JNI is a framework in the Java platform that makes it possible for Java code running in a JVM to call, and to be called by, native libraries.
This framework is particularly useful when applications can’t be written entirely in Java.
For such applications, JNI provides interfaces to map native code structures to Java classes.
Note that a single native library can only be used by one class loader.
Filter expressions A filter expression is an OSGi-defined construct that provides a concise description of constraints based on attributes.
Its syntax is based upon the string representation of Lightweight Directory Access Protocol (LDAP) search filters.
Suppose you want to use a math library that provides a set of high-performance math functions for a component.
You can create a lib directory in the structure of your component and make your configuration point to this directory, as shown in the following snippet:
In this example, your component is tied to the target execution environment.
OSGi also can load the right library for the environment, as shown in the following snippet, by using the osname and processor attributes:
Finally, it’s time to look at how to diagnose errors when implementing and executing OSGi components.
Developers new to OSGi can find errors difficult to understand and resolve because OSGi provides slightly different mechanisms than classic Java applications.
OSGi works quite differently from classic Java applications, but no technology always works perfectly, so you need to know how to diagnose errors and isolate their root cause.
This section describes how to diagnose and resolve basic errors, but it certainly isn’t exhaustive.
As we have explained OSGi relies on Java but provides a completely new approach for implementing modular Java applications.
The technology implements a strict classloader model and dependency management for components.
Most of the errors you’ll encounter in OSGi development come from these two features.
We’ll describe how to diagnose errors using the Equinox console, which provides a set of commands to inspect entities in the container.
Other containers provide similar kinds of tools, but the command names can vary.
Suppose we have a container that includes two components with the following behavior:
We purposefully left some errors in the configuration and coding of these two components.
Figure 2.11 shows the dependencies between the bundles and their interactions with the OSGi service registry.
When you notice problems in your application, the first step is to determine which components seem to have problems.
Problems can obviously come from internal execution—and you’ll need to debug the code if this is the case—but they can also be caused by issues preventing components becoming available in the container.
By having a look at bundle states, you can get a first hint of where the problem lies.
If the autostart mode of your container is enabled, all the bundles should be in the active state except for fragment bundles in the resolved state.
Fragment bundles are necessarily linked to the host bundle they extend, which makes it easy to identify them.
We can display component states within the Equinox container with the ss (short status) command, which gives the following output when components have started successfully:
If all your bundles are in autostart mode, and problems occur during their processing by the container, these components will remain in either the installed or resolved state.
These component states offer interesting hints, enabling you to diagnose where errors may be coming from.
For instance, if a problem occurs during the resolution of dependencies for bundle2, the output of the ss command would be as follows:
Figure 2.11 Example bundles and their dependencies for demonstrating error diagnosis.
After you’ve identified the component with problems, the important thing is to identify in which part of the component lifecycle the error occurred.
We’ll describe other problems in more depth in subsequent chapters.
The component state is installed, and when a user tries to manually start it, a BundleException exception occurs, indicating that a constraint is missing, as shown in listing 2.12
Adding this package in the Import-Package header of bundle2 solves the problem.
Errors can also occur when the component is started by a user.
To illustrate, we’ll manually throw a RuntimeException exception in the start method of the component activator.
The component can be resolved, but when trying to start it manually, a BundleException exception is still thrown.
For more details on this error, you’d need to have a look in the activator to see what happened and how to solve it.
OSGi fills the modularity void in the Java platform by providing first-class component support and strict classloader isolation.
The technology introduces a new approach to developing Java applications, requiring developers to explicitly specify which dependencies and dependency versions must be used.
All these features must be configured for each component via the component’s manifest file and a set of specific headers defined by OSGi.
Components are black boxes by default and can completely control what parts are visible and what classes and services can be used from other components.
Each component in the container can both provide and consume services by interacting with the service registry.
This feature allows components to interact in predictable ways while remaining dynamic.
The service registry allows components to be notified when updates occur and to adapt accordingly.
Fine-grained interactions between components and the container itself are made possible thanks to the OSGi API.
Implementing advanced mechanisms for managing and update components and services is possible, thanks to the ability to inspect installed components and their contents and to handle update notifications.
This API makes the dynamic nature of the OSGi platform possible.
OSGi is a fairly low-level framework for implementing modular applications in Java.
Indeed, application developers can find that some features, such as services, are tedious to use through the OSGi API.
On the other hand, whereas OSGi provides a complete and dynamic component platform, it doesn’t place constraints on the implementation of components.
It’s up to additional tools to provide appropriate abstractions and help developers adhere to best practices when using OSGi.
Spring DM aims to address all these aspects by making OSGi development simpler, more convenient, and more efficient.
In this chapter, we gave some hints about OSGi features that Spring DM supports or leverages.
If you want to go deeper into the OSGi technology, we recommend reading Manning’s OSGi in Action, by Richard S.
So far you’ve seen little of Spring DM itself, except in chapter 1, where we built our very first Spring DM–powered bundle.
Now you’re all set to get started with Spring DM!
Spring DM offers a lot of features, such as dependency injection and its ability to handle the dynamic nature of an OSGi environment, but before we dive into all that, you need a practical understanding of Spring DM’s mechanisms, especially its extender, which is at the heart of the framework.
Working with OSGi isn’t an easy task, and it can appear daunting when you don’t know exactly how to manage your workspace.
We’ll do our best to navigate you through this difficult path by explaining how to install Spring DM in an OSGi container from the very beginning.
Last, but not least, we’ll take our first steps with the Spring DM integration test framework.
Good news: with Spring DM, you can now use the power of the Spring Framework in your OSGi development.
This means that Spring DM is able to scan bundles and manage a dedicated Spring application context for them.
Perhaps you know the Spring Framework for its lightweight container, and you’ll see that it will help you in assembling the inner parts of your OSGi bundles.
But don’t forget that Spring also comes with an AOP framework and support for a large set of enterprise frameworks, like Hibernate or JPA.
This section introduces you to the basic mechanics of Spring DM: how the framework scans OSGi bundles, how it associates a Spring application context with each of them, and how it manages this application context for the bundles, unleashing the full power of the Spring Framework into OSGi.
Spring DM introduces a new kind of OSGi bundle: Spring-powered bundles.
This marketing-sounding expression means that a bundle can automatically have a dedicated Spring application context managed by Spring DM, and so can benefit from all the features of the Spring lightweight container.
A Spring-powered bundle is still a traditional OSGi bundle and can import or export Java packages, but it doesn’t need to worry about initializing and exporting its services or looking up its dependencies, as shown in figure 3.1
For these tedious tasks that normally imply the use of the OSGi.
Figure 3.1 Spring-powered bundles benefit from the Spring Framework features (dependency injection, AOP, and so on) but can also benefit from the OSGi environment like any other OSGi bundle.
Spring DM helps them with tasks like interacting with the OSGi service registry.
API, a Spring-powered bundle can rely on the Spring lightweight container and on Spring DM’s capability to communicate with the OSGi platform, using an XML configuration or annotations.
You saw in the previous chapter how a bundle can do initialization through its BundleActivator.
Usually, bundles use a BundleActivator to create and initialize their inner parts, and to consume and export some services.
To do this, you need to know how to use the OSGi API, which seems logical when developing OSGi applications, but manipulating this API over and over, for each of your bundles, is tedious; component initialization and OSGi service handling imply complex and error-prone API-driven programming, in particular when dealing with OSGi’s dynamic nature.
A Spring-powered bundle automagically has an instance of the Spring container tied to itself.
The container handles declaratively all the initialization and wiring of the bundle’s internal artifacts.
When it comes to interacting with the OSGi platform, Spring DM offers configuration features to consume and export services, listen to OSGi events, and reliably handle some of the dynamic aspects of OSGi.
These OSGi configuration features follow the Spring philosophy: they can be part of an XML Spring configuration file (with a dedicated OSGi namespace) or they can be annotations.
Table 3.1 summarizes how plain OSGi and Spring DM compare regarding the handling of some OSGi-specific aspects.
At the heart of the Spring lightweight container is the ApplicationContext interface, which represents an instance of the container.
Initialization Manual; done within a BundleActivator that needs to be written and explicitly declared.
Finalization Manual; done within a BundleActivator that needs to be written and explicitly declared.
Dynamic updates Manual; code must handle all the dynamic updates in a safe way.
Automatic; Spring DM handles service appearance and disappearance in a reliable way.
Access to the owning Bundle and its corresponding BundleContext, because there is a one-to-one relation between a Spring DM application context and an OSGi bundle.
The handling of the OSGi application context lifecycle isn’t part of a developer’s day-to-day job; everything is done transparently by the Spring DM extender bundle, which we’ll describe in the next section.
Spring bean factory and application context At the heart of the Spring lightweight container are its mechanisms to manage any kind of Java object.
The BeanFactory interface handles most of the bean lifecycle operations (creation, injection, and destruction)
The ApplicationContext is built on the BeanFactory and adds other functionality, such as easier integration with Spring AOP, event propagation, and context inheritance.
Bean scopes in Spring Bean configurations in Spring XML files can be thought of as recipes, and as such are often referred to as bean definitions.
Based on these definitions or recipes, the Spring lightweight container creates bean instances.
Spring DM provides an extender bundle, which listens for bundle installation events, detects Spring DM–powered bundles, and creates corresponding Spring application contexts.
Spring DM extender’s in-depth mechanisms and configuration are covered in chapter 4, but you’ll see the basics in this subsection.
Figure 3.2 shows how the Spring DM extender fits into an OSGi container, along with Spring-powered bundles.
The definition controls not only the bean configuration and dependencies but also its scope.
Each time you ask for a bean from the lightweight container, the container checks the bean scope to decide which instance of the bean to return.
The simplest scope is the singleton scope: the bean is created once, and for each request, the lightweight container returns the same instance.
Singleton beans are usually threadsafe objects, like data access objects or business services.
Another commonly used scope is the prototype: a new bean is created each time you ask for it.
With web-based scopes, beans can be tied to the HTTP request or session and even injected into singleton or prototype beans, with the lightweight container taking care of the wiring.
The Spring 2 (and above) bean-scoping mechanism is extensible, and Spring DM takes advantage of this feature by providing the bundle scope.
When a bundle-scoped bean is exported to the OSGi service registry, one instance of the bean will be created for each bundle importing it.
The extender pattern in OSGi As Peter Kriens has stated, “the extender pattern allows other bundles to extend the functionality [of OSGi] in a specific domain”.1 In OSGi, an extender listens to bundle lifecycle events and reacts to them according to predefined conventions.
Often, these conventions are identified by specific headers in the bundle manifest, like a header indicating the path to a Spring configuration file.
OSGi provides a basic HTTP service, which allows for registering servlets in a web container.
The Spring DM extender creates application contexts asynchronously, on a different thread than the one handling the bundle start event.
This ensures that bundle startup is fast and doesn’t block the entire OSGi container.
The asynchronous creation of application contexts is also vital to the ability of the extender to handle dependent bundles, especially if there are cycles.
This is the default behavior, and it can be overridden.
The Spring DM extender also takes care of application context destruction when the corresponding bundle is being shut down.
Wouldn’t it be simpler to have a dedicated header, whose value corresponds to the servlet class.
Then a dedicated bundle could track this header and, when a bundle is installed, do all the registration dirty work in a reliable way.
This is possible, and this dedicated bundle would be called an extender.
In Spring DM, the extender pattern can be achieved with the BundleListener interface.
The BundleActivator of the extender bundle registers a BundleListener, which listens to bundle events and creates or destroys Spring application contexts depending on the bundle content.
Other key contributions of the extender pattern implementation are the ability to inspect bundle content and to act on behalf of the inspected bundle (such as for service publications)
The extender pattern is particularly important in Spring DM because application contexts are only started when service dependencies have been satisfied.
This management would be onerous in the extreme for a programmer to handle by hand.
In OSGi 4.2, the new BundleTracker class provides additional support for implementing the extender pattern.
Also in OSGi 4.2, the extender pattern is the subject of the OSGi standardization process.
Figure 3.2 The Spring DM extender bundle scans bundles for Spring configuration files and manages a Spring application context on their behalf.
Spring application context management in OSGi environments is an example of the inversion of control (IoC) pattern: Spring DM–powered bundles wait for the extender to inspect them and create their application context; no application code is needed for this task.
The Spring DM extender is familiar with the OSGi-specific application context classes presented in the previous section and uses them to properly load lightweight container instances.
How does the extender determine that a bundle is indeed Spring DM–powered? To be Spring DM–powered, a bundle must meet one these conditions:
Contain a META-INF/spring directory with Spring XML files in it.
Spring DM will scan all files with an .xml extension in lexical order and try to create a single application context from them.
The header value specifies the configuration file location and can use the Spring resource syntax.
We’ll stick with the first alternative in this chapter, as this is the simplest and the most commonly used.
Spring DM supports two different kinds of bundles: standard Spring-powered bundles and web bundles.
In the previous section, we introduced the Spring DM extender, which tracks bundles with specific content or headers to start up Spring application contexts.
Spring DM also provides a web extender, which supports deploying web applications, packaged as standard OSGi bundles, in a dedicated web container.
Figure 3.3 illustrates the two kinds of supported bundles, along with their corresponding Spring DM extenders, and a web container packaged as an OSGi bundle.
Figure 3.3 Spring DM supports standard Springpowered bundles, but is also able to deploy web bundles, thanks to its web extender.
The two Spring DM–powered bundles are referred to as application bundles because they’re created for an application, unlike other bundles (Spring DM extenders and the web container), which serve infrastructure purposes.
Thanks to its Spring application context, a Spring-powered bundle can leverage the Spring Framework for its internal wiring, but that’s only half of the work.
Spring DM doesn’t only manage the Spring context according to the bundle lifecycle; it also helps the context interact with the OSGi environment, especially with the service registry.
Spring DM provides an osgi namespace whose primary goal is to interact with the OSGi service registry.
Before listing the namespace tags, let’s look at how to declare the namespace in an XML Spring configuration file.
The osgi namespace can be used nested in another top-level namespace (usually the beans namespace), as shown in listing 3.1
Listing 3.1 Spring DM osgi namespace declaration nested in Spring beans namespace.
Spring XML schema-based configuration Spring has used XML schema-based configuration since its 2.0 version.
Our apologies to the Spring creators for this quick-and-dirty summary.
This approach worked perfectly well for creating beans and injecting their dependencies, but this was not sufficient from a developer point of view.
Spring 2.0 came with a new, extensible, schema-based XML configuration system.
The Spring DM namespace can also be declared as the top-level namespace, and so can be used without any prefix, as shown in listing 3.2
You’ll use the osgi namespace to publish your Spring beans in the OSGi service registry, as well as to consume other services from this same registry.
Imported services can then be used as standard Spring beans and injected into your bundle beans.
Table 3.2 lists the main tags available in the osgi namespace.
By tying a Spring application context to a bundle and allowing declarative interaction with the OSGi registry, Spring DM deserves its title of bridge between OSGi and Spring.
This is the main goal of Spring DM—applying the Spring application model to OSGi.
Listing 3.2 Spring DM osgi namespace declared as the top-level namespace.
Each Spring portfolio project comes with one or more dedicated namespaces to provide the most natural and appropriate configuration using specific tags.
Spring DM is no exception, with its osgi and compendium schemas.
This was the theory you needed to fully understand the installation and first use of Spring DM, which we’ll cover in the next section.
In this section, we’ll look at how you can prepare an OSGi environment to host your Spring DM–powered bundles.
You already got a glimpse of this in chapter 1, with the Hello World bundle, but in this chapter we’ll dive deeper into the details of container configuration and provisioning, and we’ll also take a look at Spring DM’s web support.
You should know by now that OSGi is a specification, so several OSGi container implementations exist in this competitive market.
Spring DM is tested on three of these, which appear to be the most popular because they’re feature-rich, reliable, and open source: Eclipse Equinox, Apache Felix, and Knopflerfish.
To keep things simple, we’ll stick to Equinox—the most popular one—but the vast majority of what we’ll look at is also valid on the other OSGi platforms.
For now, we’ll assume we’re working in a dedicated directory, where we’ll build our Spring DM samples.
Create a container directory in your working directory, and copy the Equinox binary to it.
The Equinox binary contains its own classes but also the OSGi API classes, which explains its ease of installation.
You saw in chapter 1 that Equinox can be easily started using this command:
We also saw that some diagnostic information is accessible using the ss (short status) command:
If you look in this directory, you’ll find a log file with a scary error message saying Equinox cannot find an application service.
That’s because Equinox is integrated with Eclipse and, by default, it tries to start an Eclipse application.
As we’ll be sticking with plain vanilla OSGi, we don’t need an Eclipse application, and this default behavior can be overridden using a dedicated option; to do this we need to create an Equinox configuration file, config.ini, in the configuration directory.
Installing Spring DM the content of an appropriate config.ini to prevent Equinox from trying to start an application:
With this option set, the scary error message should be gone.
Your container is now ready to receive Spring DM bundles!
Once the OSGi container is ready, you need to copy the bundles Spring DM needs from the Spring DM distribution, and organize them in the container directory in a dedicated bundles directory.
As we saw earlier, Spring DM’s central component is its extender, which detects Spring-powered bundles and bootstraps their corresponding Spring application contexts.
The extender is an OSGi-compliant bundle and relies on two other Spring DM bundles.
Spring DM application contexts and AOP features are built on top of the Spring Framework and, as such, Spring DM depends on some of its modules.
As of Spring 2.5, all Spring modules are packaged as OSGi bundles and can be used in an OSGi container.
Table 3.4 lists the Spring modules Spring DM needs and their transitive dependencies.
You could also use any other OSGiified version of these libraries.
The last kind of bundles we need are log libraries.
The Spring Framework and Spring DM use Commons Logging as their log library, but logging must be bootstrapped from a custom log factory.
This complexity is necessary because of Commons Logging’s bad behavior in OSGi environments.
Don’t worry about these gory details, because the Spring DM distribution contains the OSGi-ified versions of all these log libraries.
We’re going to organize the bundles into three different categories: springdm, spring, and log.
Create a corresponding directory in the bundles directory for each category, and copy each bundle from the Spring DM dist and lib directories to its appropriate directory.
We could now launch Equinox and install each bundle manually, but this would be cumbersome and tedious! Instead, we’ll do exactly as we did in chapter 1 and use the osgi.bundles option in the config.ini file to tell Equinox which bundles to install and start when the platform is launched:
But alas! A disagreeable warning will take the luster off your sense of triumph:
This message comes from Log4j, which could not find an appropriate configuration file to configure itself.
Log4j configuration will be our use case for the upcoming section about fragments, and we’ll see how to fix that then.
At least this message tells us that the log libraries started correctly!
This bundle is actually not a bundle on its own, but a fragment, whose master bundle is the SLF4J API bundle.
Shortly, we’ll develop our own fragment to configure the Log4j library, which will eliminate the startup warning message as well.
For now, the container is ready to accept Spring-powered bundles; in the next section, we’ll prepare a container to accept web bundles.
As of version 1.1, Spring DM supports web application deployment in OSGi environments.
Web applications differ from plain vanilla OSGi bundles in resource and class loading, which web containers handle in traditional deployment scenarios.
Spring DM provides a bridge between the web container and the OSGi environment so that loading is no longer a concern.
Spring DM doesn’t provide a replacement web container; instead it delegates all the web application management by deploying applications to the web container and connecting its resource-loading facilities to the OSGi platform.
By doing it this way, web applications don’t suffer from any particular limitations, except ones introduced by the web container itself, as long as they’re correctly packaged as OSGi bundles.
Spring DM web support is also based on the extender pattern, through the web extender, which detects and installs web bundles.
Spring DM bundle, which acts as the bridge between the web container and the OSGi world.
Table 3.6 lists these two mandatory bundles for activating web support.
The Spring DM web bundles aren’t sufficient for web support because Spring DM relies on a true web container to handle web applications.
Spring DM supports two web containers, Apache Tomcat and Jetty (from Mort Bay), and provides all the necessary bundles for the basic use of each in its distribution.
Tomcat is the default container in Spring DM, and we’ll stick to using it to keep things simple.
We’ll see in chapter 9 how to configure the web extender to use Jetty.
Table 3.7 lists the bundles for the simplest web support with Spring DM.
You can embed Java code in JSPs, but the preferred way to handle logic in views is by using taglibs—reusable components that encapsulate some presentation logic.
We’ll add JSP support to our basic container configuration by providing a JSP compiler, because JSPs are compiled to Java classes, and use the JSP Standard Tag Library (JSTL) for our tag library.
Bundles for JSP and taglib support aren’t available in Spring DM, but you can retrieve them from the Spring DM OSGi repository or from this book’s source code.
Copy the Spring DM web bundles to the springdm directory and create a web directory for the remaining web bundles.
We also have to modify the config.ini file to include these new bundles:
Spring DM OSGi repository Not all libraries are packaged as OSGi bundles, which makes them unusable as firstclass components in an OSGi environment (although they can be packaged as part of an individual bundle’s classpath)
To address this problem, SpringSource has repackaged a large number of open source libraries and made them available through its EBR (http://www.springsource.com/repository/app/)
You can use this repository with Maven 2 or Ivy, or by browsing it and downloading the bundles you need.
Spring DM also has its own OSGi repository because not all dependencies can be downloaded from SpringSource’s EBR.
Most of the OSGi-ified libraries available in Spring DM’s OSGi repository are marked as SNAPSHOT (meaning they can change at any moment) and have an .osgi suffix.
Before launching Equinox, be aware that you must not have any kind of server listening on port 8080, because that’s Tomcat’s default port.
Once Equinox has been launched, you can check your installation with the ss command:
As everything looks fine, you should have a Tomcat server running on your computer.
We’ll see in the next section how to configure logs using an OSGi fragment.
You probably remember the nasty warning message we received after the installation of the Spring DM bundles.
It was coming from Log4j, complaining that it couldn’t find its configuration file.
This section explains how to get rid of this warning by properly configuring Log4j by using an OSGi feature: fragments.
A fragment is an incomplete bundle; it can’t exist on its own and must be attached to a host bundle.
The host bundle can’t itself be a fragment and must be a full-fledged bundle, even if it relies on its fragment to add classes or resources.
A fragment can serve many purposes, such as completing its host bundle with specific classes or providing configuration through resources (property or XML files)
The portable part could be provided by a bundle, bundle A, and the platform-specific code could be provided in a bundle fragment for each platform.
The fragment pattern is especially useful here because platform-specific fragments will generally be tied to internal features of bundle A, and they could not be deployed as regular bundles without exporting bundle A’s internal features.
Instead, classes and resources contained in a fragment are merged into the host bundle classpath without requiring export.
Configuration is another application for the fragment pattern: the host bundle can use a resource provided by one of its fragments as a configuration file.
You could use the host bundle without modification, then create a fragment that serves to configure the bundle.
Figure 3.4 A fragment complements a host bundle, as the fragment content is available to the host bundle.
The host bundle (generic) can then use the content of the fragment (specific) for retrieving configuration artifacts.
Now you’re aware of the fragment feature and how it can be leveraged to configure a host bundle, so let’s discuss how to create a fragment to configure Log4j.
A fragment is like any other OSGi bundle: a JAR file with specific headers in its manifest.
Even though a fragment is only part of a regular bundle, it must identify itself and the host bundle to which it must be attached.
The following snippet shows the manifest file for the Log4j configuration fragment:
This fragment host bundle is the Log4j bundle we installed while provisioning the OSGi container for standard use.
This fragment isn’t very useful without providing a resource for configuring Log4j.
The following snippet shows the content of this configuration file:
If you’re familiar with Log4j, you’ll have noticed that we configured the log output to an equinox.log file, with information like seconds from startup, thread name, log level, and log message for each log entry.
Now we have all the pieces, so let’s put them together.
To package these fragment as a JAR file, launch the following command:
This will produce a log4j-config.jar file that we’ll install in Equinox next.
You declare fragments in an OSGi container as you would any regular bundle, except that they can’t be started.
Copy the log4j-config.jar file to the bundles/log directory with the other log bundles, and modify the Equinox config.ini file to provision the container with the fragment:
After starting Equinox, you’ll notice that the Log4j warning has disappeared and that an equinox.log file has been created.
You’ll also notice that Spring DM has emitted some log messages:
The ss command also reflects the relation between the Log4j bundle and its fragment:
Congrats! You’ve just configured logging in your OSGi container! With logs enabled, we’ll be able to follow what Spring DM is doing and diagnose any problems.
You took your first steps with Spring DM in chapter 1 by implementing a simple bundle.
We made the creation of this bundle as simple as possible, using the JDK tools, but if we keep on using them we’ll be hindered by their lack of productivity as we get into more advanced usage.
We’ll keep using the old-fashioned way to test our bundle, by deploying it manually to Equinox, but we’ll also see how to use the Spring DM integration test framework for testing purposes.
OSGi bundles need careful packaging because their manifest contains key information about dependencies and exported classes.
Spring DM–powered bundles also contain some configuration files that we need to maintain and include in bundles, so we need to maintain a neat and precise organization of our bundle projects.
To do so, we’ll use the standard Maven 2 file structure.
Our bundle will consist of a single Java class and a corresponding Spring context file to create one instance of that class.
The Maven 2 archetype mechanism will help us create a bundle skeleton.
This will create a standard Maven 2 Java project that we’ll modify slightly to shape the bundle.
Appendix B gives an introduction to Maven 2, from its installation to advanced features like multimodules projects.
If you’re new to Maven 2, don’t hesitate to read this appendix, which also covers how to leverage plug-ins for OSGi development.
If you prefer Ant, appendix C explains how to adapt this chapter’s examples for that tool.
However, the pom.xml file is a unique, central location for gathering information such as the project group, name, and version, which we can then use to identify the resulting OSGi bundle.
Maven 2 also comes with a built-in dependency and versioning management system, which turns out to be very useful for OSGi-based development.
Dependencies are declared in the POM, and Maven takes care of downloading them from public repositories and storing them in the user’s local repository.
These are other good reasons why using Maven 2 makes sense for the source code of a Spring DM book.
Nevertheless, using Maven 2 isn’t compulsory when working with Spring DM.
If you’re already familiar with tools like Ant or Apache Ivy, you can use them to develop Spring DM bundles or adapt the examples from this book.
Our project is created in a springdm-sample directory, and the archetype command created the POM file and all its associated structure for us.
From now on, our work will only consist of creating a Java class and the Spring configuration file.
Here is the project structure (with our two files in bold):
The following snippet shows the SpringDmSample class, which is very simple, displaying only a message on the console when an instance is created:
We placed the Spring configuration file in META-INF/spring, which Spring DM scans to bootstrap application contexts.
Even if our bundle is simple, it needs proper OSGi packaging.
In chapter 1, we created a manifest file ourselves, and although this solution is sufficient for a Hello World application, it becomes cumbersome and error-prone for bigger bundles.
Maven 2 can package the bundle for us, and its JAR packaging mechanism supports a customization of the manifest (for OSGi-specific headers)
This is a more user-friendly solution than manually editing the whole manifest, but it still isn’t well-suited to complex OSGi bundles.
Even though our bundle isn’t that complex, we’ll use a more powerful dedicated packaging mechanism, the Felix Bundle Plugin for Maven.
Under the covers, it uses the Bnd packaging tool (http://www.aqute.biz/Code/Bnd)
We’re using this plug-in only for packaging; its usage doesn’t imply the use of the Apache Felix OSGi platform! You’ll learn more about Bnd in chapter 6, where we cover how to package an existing library as an OSGi bundle.
To use the Felix Bundle Plugin, we need to modify the pom.xml file as shown in listing 3.3
The Felix Bundle Plugin provides another packaging mechanism to Maven 2: the bundle.
The plug-in will now take care of the packaging and generate the manifest file, with OSGi headers retrieved from the project information contained in pom.xml.
You can open the archive to read the manifest and check that the plug-in retrieved the correct information from the POM (bundle name, version, and so on):
With the Equinox container provisioned with all the required Spring DM bundles, we can safely install the bundle.
The Spring DM extender scans bundles only when they reach the active state, so we need to start the bundle after its installation.
We’ll then see the message from the bean, and we can check the bundle status with the ss command:
We just ran an integration test: we tested that the bundle could be properly installed and started in an OSGi container.
Even if this activity can be somewhat entertaining, it involves manual steps and is limited to one type of container.
In the next section, we’ll start to use the Spring DM integration test framework, to automate the bundle integration test.
Spring DM provides an integration test framework to check if bundles can be successfully deployed on the three OSGi containers it supports.
The main benefit of the testing framework for the developer is it safely tests bundles without requiring any change in testing habits: the testing framework is based on JUnit, and tests can be launched as usual using Eclipse, Maven 2, or Ant.
When launching an OSGi-based integration test, Spring DM launches an OSGi container (Equinox is the default), provisions it from the local Maven 2 repository, and runs the test methods.
The test itself is deployed on the fly as a bundle.
All this makes the Spring DM integration test framework a fantastic tool for testing not only Spring DM–powered bundles but any kind of OSGi bundle.
In this chapter, we’ll only explore the basics of this test framework; the whole of chapter 10 is dedicated to its use.
As we described earlier, Spring DM uses the local Maven 2 repository to provision the OSGi container it launches for running tests.
Then they will be in our local repository and will be used each time we launch an integration test using the Spring DM testing framework.
What we’re doing now is the equivalent of the manual provisioning we did in section 3.2.2
Notice that we didn’t reference any Spring Framework dependencies, because Spring DM’s own POMs reference them and Maven will download them too as it handles transitive dependencies.
Feel free to download the Spring distribution separately and use it, as long as it’s a 3.0.x distribution.
We also need to add extra dependencies on AOP and log, as shown in listing 3.6
That’s a lot of dependencies! Fortunately, Maven 2 will download them all for us, but to do this, it needs a nudge in the right direction.
Maven 2 downloads dependencies from public repositories, which contain most of the open source libraries, but our case is a little bit special: we need OSGi bundles and some very specific dependencies.
Spring DM and the Spring Framework binaries are available from public repositories and are packaged as OSGi bundles, so they aren’t a problem.
But the other dependencies can only be found on specific repositories, which we must register in our POM, as shown in listing 3.7
Almost set! For the integration test, the bundle must also be in the local repository, so we need to install it.
This also has the side effect of downloading all of its dependencies.
Type the following command to compile, package, and install the bundle:
You can see in listing 3.8 that the integration test doesn’t differ much from a standard unit test.
This integration test is simple but functional: it checks that the Spring DM Sample bundle has been correctly started.
The Spring DM integration test framework provides a handy abstract class that provides hooks for the OSGi container configuration, and this test uses it as its parent class B.
The test framework is based on JUnit 3.8, so test methods must have the test prefix.
Once in a test method, we’re running inside an OSGi container and we can work with the bundle context, because the test is a bundle deployed in the container C.
We could scan all the installed bundles and check their states, but we’re particularly interested in our bundle, whose name is com.manning.
As we’re also in a JUnit test, we can use TestCase methods to assert conditions E.
If we want our Spring DM Sample to be installed and started, we must provide it with its Maven 2 identity (group, artifact IDs, and version) as shown at G, and Spring DM will retrieve it from the local repository.
As we mentioned earlier in this section, Spring DM depends on a development release of the Spring Framework, so it uses it by default in its test environment.
We need to specify in the overridden method the path to a properties file where we list all the bundles we want to be installed in the OSGi container during the test.
Here’s an excerpt of this file (take a look at the book’s source code if you want all the details):
You can launch the test from Eclipse by right-clicking on the test file from the Package Explorer view, selecting Run As and then JUnit Test.
To launch the test with Maven 2, type the following command:
This means the bundle has been correctly installed and started, and that the Spring DM extender properly bootstrapped the Spring application context.
All this took about 3 seconds, including the OSGi container startup time!
By default, Spring DM uses Equinox in its integration tests.
You can check the platform used in the test with the getPlatformName method.
The Spring DM test framework can launch tests on Equinox, Felix, or Knopflerfish; we’ll see in chapter 10 how to switch from one platform to another.
Although it may seem somewhat involved to write this first integration test, every subsequent test should be much easier because all your OSGi integration tests can now be written as usual, from Eclipse, from the command line, or even through your continuous integration process.
That’s all there is to using Spring DM for standard bundles; we’ll now see what Spring DM can do for us when deploying web bundles.
So far, Spring DM has brought a lot of benefit to our OSGi development process: we can use the Spring lightweight container to wire up all the inner parts of our bundles, and we can even write OSGi-based integration tests.
We’ll continue to see in this book how it can bring many more benefits.
To illustrate, we’ll take a first look at its web application support.
We’re now going to develop and deploy a web bundle with a static page and JSP, using the same tools and approach we used for our previous bundle.
The web bundle will be created and packaged as a standard OSGi bundle, with OSGi entries in its manifest file.
But some of its content (a web.xml file and resources like JSP files) will indicate that the bundle is a web bundle, and Spring DM will treat it accordingly, by deploying it in a web container.
We’ll still use a Maven 2 archetype to create the project skeleton:
As before, we have only a basic Maven 2 structure and we need to create some files to complete our web bundle.
The following snippet shows the project structure with our files in bold:
You can see from the structure that our web bundle doesn’t contain a Spring context file.
Web bundles are a special case; they don’t usually contain any Spring-specific file that the Spring DM extender will load.
Instead, the Spring application context bootstrapping is delegated to the web application, with a dedicated servlet listener.
Spring DM provides an OSGi-aware web application context, which we’ll discuss in chapter 8, but we won’t be using it here.
Developing Spring DM web bundles with its web.xml file, a static “hello” page, and a hello JSP to check that the JSP compiler works properly.
The index.jsp page uses an expression element for the Hello World message:
How do we package our web bundle? Can the Felix Bundle Plugin really package this unusual kind of bundle? Well, yes it can.
Our bundle will be a standard OSGi bundle, except for additional information to help Spring DM deploy it.
Our bundle will be deployed in two steps: it will be deployed as a bundle in the OSGi container, then the Spring DM web extender will react to its registration with OSGi by deploying it to the web container.
To be deployed by the web extender, a bundle needs to meet one of two conditions:
Our bundle meets the second condition, so the Spring DM web extender will deploy it to the web container.
All we have to do is properly configure the Felix Bundle Plugin to include the webapp directory in the bundle, as shown in listing 3.9
The Felix Bundle Plugin is activated because we switched the packaging from jar to bundle at B.
We use an OSGi-compliant version number for the bundle at C.
First, to include the web application files, we used the Include-Resource tag at D.
Second, the Spring DM web extender can use the Web-ContextPath header specified in a bundle’s manifest to deploy the web application under this context name; we added this header by using Web-ContextPath tag at E, so the Felix Bundle Plugin will include it in the generated manifest.
The bundle is now ready to be packaged with the Maven 2 package target.
Because we provisioned Equinox with Spring DM web bundles and with the other necessary web bundles, our own web bundle can now easily be deployed.
Once installed, we need to start it, and the now familiar ss command assures us that everything is fine:
The short status isn’t very verbose, and for once we have a graphical result.
If you see web pages corresponding to the index.html and index.jsp pages we wrote previously, congrats! You successfully installed Spring DM web support and deployed a web application.
The next section covers how to write an integration test for our web application.
Developing an integration test for a web bundle is nearly the same as for a standard bundle, except that you need to add more bundles as dependencies.
Listing 3.10 shows the minimal dependencies for web support that we can add to the POM.
Listing 3.10 shows the dependencies for minimal web support, but our web bundle needs more than that because it includes a JSP.
We must add a JSP compiler, as shown in listing 3.11
The mvn install command, for example, will do this and also install our bundle in the repository.
The integration test, shown in listing 3.12, is more complex than our first one.
It not only checks our bundle installation but also launches HTTP requests against the application.
This test checks that the bundle is properly started B and puts the thread to sleep C to allow time for the web container to deploy the web application.
We’ll see in chapter 9 how to change the default configuration of the embedded Tomcat.
By executing the test with Maven 2, you should get output something like the following:
There are many ways to start with OSGi frameworks, and we’ve tried to take you through the installation of all the basic Spring DM elements that you’ll need when tackling OSGi development.
This will undoubtedly help you to manage dependencies and package your bundles.
We also saw two ways to test OSGi bundles: the manual approach, where you launch the OSGi container from the command line, and the integration testing approach, where you take advantage of Spring DM’s testing support.
We’re about to dive into Spring DM’s features in more detail in the next chapters, and you should be ready to develop, package, and test all that you’ll learn or apply it directly to your own applications.
In part 1 we discussed the building blocks of Spring DM, and you should now have more than a superficial understanding of what each piece does and why it’s important.
We’re now going to get into the nitty-gritty details of using Spring DM and its associated technologies in a variety of enterprise development contexts.
This part forms the meat of the book, so if you are going to read anything, read this!
In chapter 4 we look at the operation of the two extenders that Spring DM provides: the standard extender and the web extender.
Chapter 5 covers the definition and use of OSGi services with Spring DM.
Service support is at the core of the feature set provided by Spring DM and thus this chapter is one of the key chapters of the book.
Chapter 6 looks at the development of enterprise applications using Spring DM and, in particular, how to design and structure applications of this type to take advantage of all the power that Spring DM and OSGi provide.
The chapter also covers the integration of third-party enterprise libraries into an OSGi environment.
Chapter 7 covers the use of data access through JDBC and JPA in Spring DMenabled applications.
Spring DM brings new powers to your OSGi bundles; namely, all the power available in the Spring Framework, which means a great deal! We saw in the previous chapter how Spring DM can automatically create an application context on behalf of a bundle, assuming this bundle contains Spring configuration files in a specific location.
With the availability of the Spring lightweight container, a bundle can build and wire all of its constituent components and let Spring DM interact with the OSGi platform to register Spring beans in the service registry.
All this can be driven declaratively, without any of your Java code depending on the OSGi APIs.
As a result, writing Spring-powered bundles becomes very easy thanks to Spring DM.
The extender hides most of the complexity of the process from us.
The standard Spring DM extender presents opportunities to tune the structure of Spring-powered bundles and the way that their application contexts are created.
In this chapter, we’ll cover these options as well as how Spring DM manages the whole lifecycle of application contexts.
We’ll also see that Spring DM is truly simple, as it set us free from the vagaries of the OSGi API, but that it doesn’t sacrifice any features of OSGi.
Furthermore, Spring DM brings its web support to OSGi, making it possible to deploy bundles as web applications to an embedded web container.
We’ll see in this chapter how this web support is unique to an OSGi environment, because web bundles are treated like any other OSGi bundle and can consume services available in the OSGi service registry.
At the heart of the Spring DM web support is its web extender, which contains a WAR deployer, which we’ll take a look at to see how it differs from a standard web deployer.
This may sound like a lot for a single chapter, but this is because Spring DM offers a lot of options when managing Spring application contexts for OSGi bundles.
Spring DM has reasonable defaults, which makes it easy to use, but sometimes defaults aren’t appropriate, and that’s when you’ll come to this chapter.
As explained in previous chapters, the Spring DM standard extender is a special bundle that listens for bundle installations in the OSGi container.
What is so special about it? Extender-based bundles, if you’ll forgive the pun, spring into action when the kind of bundles they’re interested in change state or are deployed.
The Spring DM extender scans bundles looking for Spring configuration files and creates Spring application contexts on behalf of these Spring-powered bundles.
As an extender, it primarily listens for bundle starting events, but it also looks for Spring-powered bundles that are already in the active state when it is itself started.
This means that your Spring-powered bundles go from passive to real active OSGi components as soon as the extender discovers them, and this without any additional work from you.
In this section, we’ll cover the Spring DM standard extender mechanisms for creating and destroying Spring application contexts, as well as the lifecycle hooks it provides for these contexts.
We’ll also see what entry points Spring DM offers for interacting directly with the enclosing OSGi environment.
All this information will be valuable in understanding the way the extender works and when its default behavior won’t suit your needs.
We’ll start with a section that may look off-topic, but it’s at the heart of Spring DM’s extender: dependencies between Spring-powered bundles.
When working with Spring DM, you’ll hear a lot about dependencies between Springpowered bundles.
The word “dependency” includes a lot of notions, so let’s make it crystal clear at the beginning.
In the case of Spring-powered bundles, dependencies means that the application contexts of these bundles share some beans, thanks to the registering and consumption mechanisms of the OSGi service registry.
By looking at figure 4.1, you can easily see that bundle B’s and bundle C’s Spring application contexts depend on bundle A’s application context, because the latter registers one of its beans on the OSGi registry.
Bundle B’s and bundle C’s application contexts consume this OSGi service through Spring DM and it becomes one of their beans.
This service can become one of the key parts of these application contexts, so much so that they can’t work properly or even start without it.
You’ll learn everything about Spring DM’s declarative way of interacting with the OSGi service registry in chapter 5, but here is an overview.
The following snippet shows how bundle A first defines a service as a standard Spring bean and registers it in the OSGi registry:
To consume and use the service, bundle B or C would use the reference element from the osgi namespace and then use the OSGi service like any other Spring bean, as shown in the following snippet:
In real-world applications, dependencies between Spring-powered bundles can become complex and have deep impacts on the way Spring application contexts must be managed: their start and stop order, event propagation, and so on.
Luckily, it’s Spring DM’s job to deal with this concern.
We’ll see in this chapter that most of the behavior of Spring DM’s extender is driven by dependencies.
From the OSGi container’s perspective, Spring-powered bundles don’t differ from vanilla OSGi bundles.
As we explained earlier, a Spring-powered bundle needs to contain either a META-INF/spring folder or a Spring-Context manifest header.
If it contains a META-INF/spring folder, a Spring-powered bundle doesn’t need to contain non-OSGi manifest headers, and its packaging and manifest generation remain the same as any regular bundle (except that Spring configuration files must be included in the right place)
This packaging is particularly convenient for its simplicity, and this default behavior follows the convention over configuration pattern, but there are drawbacks.
First, the Spring DM extender scans for any XML files in the META-INF/spring folder, which means any files with .xml extensions.
If an XML file that has nothing to do with Spring is found in the META-INF/spring folder, the Spring DM extender will try to use it to bootstrap the application context, and this will usually result in an exception.
Luckily non-Spring configuration files should not usually be found in the META-INF/spring folder, because its name makes clear its specific purpose.
Second, and more serious, is the fact that the default behavior will also create the application context with default settings.
Fortunately, the default settings are suitable for most Spring-powered bundles.
The Spring-Context header can be used to specify the Spring configuration files’ location.
Any XML file in the METAINF/spring folder will be ignored, because the Spring-Context header overrides the.
Unleashing Spring DM’s standard extender default configuration file detection behavior.
You can specify more than one file by separating their names with commas:
To quickly summarize, when using the bundle space, the extender scans the bundle JAR and all of its fragments.
With the Spring-Context header, locations can use wildcards to define file patterns.
With the preceding header, the Spring DM extender would use all the files ending with .xml in the config folder of the bundle space.
The Spring DM extender understands Ant-style syntax for files and directories, so it can recursively scan directories.
Imagine your bundle contains a config directory with the following content:
If you used the following header value, the Spring DM extender would use all the preceding files to create the bundle application context:
Considering the bundle space consists of the bundle JAR and all its fragments, a bundle can have its application context augmented by any XML file contained in a fragment, as long as the XML file matches the Spring-Context header value.
This is a convenient way to facilitate the configuration of a Spring-powered bundle, as shown in figure 4.2
The MyApp bundle has its own Spring configuration files and lets some.
Figure 4.2 Applying the fragment configuration pattern to a Springpowered bundle.
The host bundle contains the static part of the application context and the fragment complements it with the remaining variable parts.
The latter can override the default behavior by providing their own bean definitions.
Spring DM isn’t only able to look in the bundle space; it has its own way to locate resources in bundles or from any other location.
In our previous examples, locations refer to resources, and, without any prefix, locations are interpreted as relative resource paths.
This is directly related to the Spring Framework resource abstraction and the way that Spring DM extends this mechanism.
Spring DM also has its own interpretation of some resource prefixes: for example, there is quite a bit of difference between classpath in the web environment and classpath in a regular OSGi environment.
This can seem odd at first, but it’s consistent with the Spring resource abstraction: the final behavior is defined by the underlying application context implementation.
Developers used to traditional, non-OSGi, Spring applications should be aware that commonly used prefixes, such as classpath, don’t behave the same way in an OSGi environment.
Spring resource abstraction The Spring Framework defines an abstraction to load resources from an application context.
This abstraction is based on the Resource interface, which represents the access to a resource and is agnostic to the underlying resource medium (filesystem, classpath, URL, and so on)
Spring defines the ResourceLoader interface, which is meant to be implemented by objects that can load resources (a Spring application context always implements this interface)
For a resource loader, a resource is defined by its path, which can be relative or explicit.
A relative resource path doesn’t contain any prefix and its loading (and origin) will depend on the resource loader’s nature.
A classpath-based application context will load this resource from the classpath, and a file-based application context will load it from the filesystem.
A resource path is said to be explicit when its starts with a prefix that describes the resource origin or medium.
If we’re sure our previous resource comes from the classpath, its path could be explicit thanks to the classpath prefix: classpath:path/ to/resource.txt.
In OSGi environments, class and resource loading are carefully controlled.
Spring DM application contexts have specific behavior and extend the resource management mechanisms of regular Spring application context implementations.
The demonstrated flexibility of resource loading has some important implications.
If one of your beans has a Resource property, you can use any prefix and Spring DM will load it, applying, as appropriate, any of the specific behaviors we’ve just described.
In the following snippet, the resource property is of type Resource:
Spring DM supports all conventional prefixes, such as file: and http:
These prefixes don’t imply any interaction with the classpath and behave identically in an OSGi environment as in any other context.
You can use them in your Spring-Context header if you’d like to configure your bundles from the filesystem:
This feature is quite handy, as it allows you to configure a Spring DM bundle without cracking the JAR and without having to generate a fragment.
This is especially valuable if you want to change configuration attributes at runtime.
A suggested practice regarding Spring configuration files in a bundle is to split the traditional Spring and OSGi configurations into two separate files.
The traditional Spring configuration would contain bean declarations, wiring, and technical concerns, such as transaction and AOP (AOP) configuration entries.
The OSGi configuration would mainly deal with the interaction between the bundle and the OSGi environment.
Spring DM comes with a dedicated namespace for interacting with the OSGi platform, and this namespace should not be used in the files used for wiring the bundle’s inner beans.
A typical Spring-powered bundle of this sort would have the following structure:
Bundle space osgibundle: The bundle and its fragments (if any) are scanned.
You can choose not to use the default location for Spring files (and use the SpringContext header) but you should at least respect the convention of keeping the regular bean declarations free from any OSGi-specific configuration.
The structure of Spring-powered bundles holds no secrets for you now.
You know how to tell Spring DM where to find Spring configuration files, how Spring DM handles file discovery, and how to properly package and organize your bundles.
In the next section, we’ll see how Spring DM manages application contexts, which is important for understanding the various options the framework provides.
A Spring-powered bundle doesn’t have to worry about its application context’s creation and destruction; the Spring DM extender handles this process on behalf of the bundle.
Nevertheless, it’s useful to have some knowledge of the application context lifecycle because it can have implications for the OSGi platform itself.
In this section, we’ll describe Spring DM’s default behavior for handling application contexts.
We’ll also describe why you might want to override the default behavior, and how.
How should you organize your Spring configuration files? The Spring lightweight container can create an application context from multiple files, as long as these files define a consistent set of beans and their dependencies.
Splitting Spring files makes them easier to maintain and improves modularity by allowing only one layer of an application to be bootstrapped—to unit test it, for example.
OSGi is all about modular programming so a module should not need dozens of Spring configuration files.
You can split the bundle application context definition into several files, but if one of your bundles needs a large and complex Spring configuration, you should consider splitting the bundle itself into more fine-grained bundles.
When the Spring DM extender is started, it scans the OSGi container for bundles in the active state and bootstraps the application contexts for those it identifies as Spring-powered.
It doesn’t often find any, because the extender is an infrastructure bundle and is usually among the first bundles to be started.
Nevertheless, it’s worth noting that the Spring DM extender is able to create application contexts even for bundles that were started before it was.
The extender tries to bootstrap application contexts only from bundles that manage to reach the active state.
Therefore, an application context is created after its owning bundle has been started (in OSGi terms, the extender initiates application context creation on the started event)
The Spring DM extender creates application contexts asynchronously; application contexts are started in a different thread than the one that started the bundle (usually a thread owned by the OSGi platform)
Spring DM behaves in this way primarily for two reasons:
The OSGi specification recommends that event processing complete in a short, finite time so that other event handlers are dealt with in a timely manner, and, depending on its content, creating an application context can take some time.
If the creation happened in the OSGi event thread, it could prevent other platform tasks from running and slow the whole container.
The extender bundle waits for application context service dependencies to be satisfied before starting a bundle’s application context.
If this task were performed synchronously, the bundle start order would have to be carefully managed to ensure that a bundle would not cause a deadlock by waiting for a service that had not yet been started (and could not be started because of the synchronous usage of the event thread)
For the same reasons, synchronous creation would make it impossible to start bundles with service dependencies involving cycles.
Thanks to asynchronous application context creation, starting Spring-powered bundles has virtually no impact on the OSGi container’s responsiveness, as shown in figure 4.3
Figure 4.3 Spring DM’s extender bootstraps Spring application contexts asynchronously to avoid blocking OSGi containers.
Asynchronous context creation is the default behavior, but we’ll see that it can be easily overridden.
What if the creation of an application context fails? Because an application context can contain a complex set of beans, it can easily fail to start.
If this happens, it will definitely have consequences for the bundle’s interaction with the OSGi container (for service registration, for instance) but it won’t affect the bundle’s state; it’ll still remain in active state.
Spring DM would, however, log the cause of the failure, which is another good reason to properly set up log reporting.
This illustrates another facet of the extender pattern; an extender should not modify the state of a bundle, but rather should react to bundle state changes.
The Spring DM extender is a bundle listener! In Spring DM 1.2, the extender is a synchronous bundle listener, registered by the activator of the Spring DM extender bundle.
What exactly is a synchronous bundle listener? It’s an implementation of the observer pattern, which allows code to react to bundle events, such as activation, startup, or stopping.
Synchronous listeners receive more events than their asynchronous brethren, as they’re notified of starting and stopping events (the targeted bundle is on the way to being started or stopped, respectively)
In the case of bundle startup, the caller asks the platform to start the bundle, the platform notifies the synchronous listeners, each does its work, and the bundle is started (and then the platform broadcasts a started event, but that’s another story)
With the synchronous method, listeners are always notified during the processing of the event.
Asynchronous bundle listener notification isn’t as straightforward as the synchronous case.
The OSGi platform doesn’t place any constraints on the timeliness of notification and can add events to a queue and let a background thread dispatch them to the asynchronous listeners.
There is no guarantee that event ordering is respected (the started event of the bundle could be delivered after the corresponding stopped event)
This doesn’t make asynchronous listeners useless, but the dispatch mechanism needs to be understood when writing listeners of this type!
Synchronous bundle listeners must be used with caution, because they can slow the whole platform if their processing takes too much time.
The Spring DM extender is a synchronous bundle listener but it delegates the creation of Spring application contexts to different threads by default.
Unleashing Spring DM’s standard extender but this would result in an inconsistent state machine—one that other dependent OSGi framework services would find impossible to accommodate coherently.
There is a one-to-one relationship between a Spring-powered bundle and an application context, so when a bundle is stopped, its application context is destroyed.
The Spring DM extender takes care of the destruction of application contexts (on stopping bundle events) and accomplishes this crucial operation in a managed and safe way.
All these kinds of resources need to be properly released.
Application beans can also have specific shutdown requirements, and it’s the application context’s responsibility to call the appropriate methods, because it’s in charge of the lifecycle of the beans.
The Spring Framework offers various hooks (interfaces to implement, annotations, and declarative configurations) for beans to register initialization or destruction methods.
OSGi applications have further requirements: each bundle can interact with the service registry, and because Spring DM handles this interaction (service publication and consumption), it must handle the interaction through the full lifecycle of the bundle.
So, when a bundle is stopped, all the services it exported must be unregistered and the services it imported disposed of.
To summarize, through application context destruction, Spring DM accomplishes the following things:
In contrast to the asynchronous creation of an application context, the destruction is handled synchronously : the OSGi container is told to stop a Spring-powered bundle, it sends a stopping event, the Spring DM extender receives the event and stops the bundle application context (in the same thread), and then control returns to the container, which then stops the bundle.
The destruction is done synchronously because the application context must be destroyed before the bundle is stopped.
Once stopped, a bundle—and in particular, its bundle context—can’t be used anymore.
A stopped bundle would thus prevent its application context from performing tasks such as unregistering.
The destruction of an application context isn’t always an isolated event, and it can be part of the shutdown of the whole OSGi platform or the Spring DM extender itself.
Figure 4.4 Spring DM’s extender shuts down Spring application contexts synchronously because the context needs to be shut down before the bundle itself.
In the next section, we’ll see that this implies the destruction of all extender-started application contexts and how the extender handles this.
When the extender is stopped, either explicitly or due to the shutdown of the OSGi platform, it has a lot of work to accomplish before it’s finished.
The extender bundle must obviously deal with its own internal housekeeping, which isn’t really our concern; what really matters is the way the extender destroys the application context of each Spring-powered bundle.
The good news is that it handles this gracefully—we have nothing to worry about! Nevertheless, let’s see exactly what the extender does for us.
The challenge mainly consists of destroying the application contexts in the right order.
Why must there be a “right” order? Well, application contexts can have dependencies on each other; some can export services that others consume.
The right order is therefore based on the way bundles are connected through the service registry.
Spring DM must compute the dependency graph of Spring-powered bundles by analyzing their service relationships.
Let’s look at the simple example of the Spring-powered bundles shown in figure 4.5
Figure 4.5 shows bundles as they would be organized in a typical, layered enterprise application.
By looking at the diagram, you could easily compute the dependency graph:
What’s the deal with application context creation and destruction? Creating or destroying a Spring application context can be slow, so does this mean Spring is slow?
No, the Spring lightweight container is powerful and accomplishes many things when it creates and manages Java objects, but it isn’t intrinsically slow.
What takes more time when starting a Spring application context is the initialization of the beans themselves, which are usually not Spring classes.
Creating a database connection involves network traffic and the creation of a security context, and this can take some time; creating an ORM context involves the scanning of classes and configuration files to load metadata, and this can take some time too.
That’s why loading a Spring application context can take a long time.
If you try to load a Spring application context with only one simple JavaBean in it, you’ll see it starts up pretty quickly.
Figure 4.5 Because of OSGi service registration and consumption, bundles depend on each other, and Spring DM takes these dependencies into account when it stops its extender.
Let’s see how Spring DM’s algorithm would lead us to this dependency ordering.
Spring DM would first track bundles that either don’t export any services, or export services that aren’t referenced (used)
These bundles are destroyed immediately (although Spring DM will additionally attempt to do this in the reverse order of their creation) and whatever services they’re using are released.
The services these bundles were using might then no longer be referenced, and Spring DM would find their owning bundles and destroy their application contexts.
This cycle continues until there are no more application contexts left to shut down.
By applying the algorithm to our sample bundles, the web bundle would come first, as it doesn’t export any services.
By destroying its application context, Spring DM would release the service references to businessservices, making the application context of the businessservices bundle available for destruction.
The same scenario applies to the dataaccess and then the datasource bundles; all the application contexts are properly destroyed without breaking service reference integrity!
Unfortunately, things aren’t always as simple as this: the algorithm will loop until there are no remaining bundles that export unreferenced services, but some application contexts may remain because of a cyclic dependency between service references.
In this case, Spring DM has no choice other than to break the cycle by trying to find the most appropriate bundle to stop first.
Spring DM bases its choice on an OSGi property of services: the service ranking.
Services are looked up from the service registry by their interface.
In the case that there are several services implementing the same interface, the one with the highest service ranking is returned by the OSGi platform.
For each remaining bundle, Spring DM finds the highest service ranking number and destroys the application context whose bundle has the lowest service ranking among the set just calculated.
If there is a tie in lowest ranking, Spring DM uses the bundle ID (an indicator of start order) as a tiebreaker, stopping the bundle with the highest ID (which was thus started last)
This will hopefully break the cycle, and Spring DM can restart its algorithm at the beginning to find other application contexts to destroy.
Figure 4.6 At shutdown, when there are cyclic dependencies between bundles, Spring DM tries to break them by using a specific shutdown algorithm.
Now it’s time to take a look at the settings that Spring DM provides for customizing application context creation.
We saw earlier that a Spring-powered bundle can use a dedicated Spring DM header in its manifest to tell it where to find its Spring configuration files.
You can use this header to override the default location of these files.
With these directives, we can tell the extender precisely how to create the application context of a bundle.
As they’re part of the manifest of a bundle, they’re interpreted by Spring DM on a per-bundle basis; they can’t be used to globally modify the creation of application contexts for all the Spring-powered bundles (we’ll see in chapter 9 how to configure the extender itself)
Table 4.2 lists the available directives for the Spring-Context header and their respective default values.
The following snippet shows how to force the creation of the application context even if some of its dependencies aren’t yet available:
With this setting, mandatory dependencies are treated as optional, and Spring beans using them will be injected with a service proxy that isn’t currently backed by an actual service retrieved from the service registry.
You should stick to the default behavior (waiting for dependencies before starting the application context creation) if your bundle dependencies are truly mandatory and if it can’t work properly without them.
Thanks to this mechanism, bundles can be started in any order by the OSGi platform, and Spring DM will take care of creating application contexts in the correct order.
A dependency can really be missing, compromising seriously the creation of an application context.
To avoid having the application context creation hanging forever, Spring DM maintains a timeout, which can be set through the timeout directive shown in the following snippet:
With this setting, an application context will wait for its mandatory dependencies for 120 seconds before the creation attempt fails.
The last directive, publish-context, controls whether the application context of a Spring-powered bundle should be published in the OSGi service registry.
This tells us that the bundle exported its application context to the service registry.
If you don’t want this to happen, you can do the following:
This concludes our exploration of the options available for tuning the creation of application contexts with Spring DM.
All these options act on a per-bundle basis; we’ll see in chapter 9 how to tune the extender itself, using fragments.
We’re now done with context creation and destruction—the next section covers another facet of the lifecycle: how to react to events with the extender event system.
Spring DM has a built-in event mechanism that it uses to notify third parties of the application context lifecycle of Spring-powered bundles.
We’ll describe in this section how to take advantage of this event system and see that it’s implemented using a common OSGi pattern: the whiteboard pattern.
So far we’ve seen that the Spring DM extender does a lot of work in the background, taking care of the whole lifecycle of application contexts.
You’ll sometimes need to know about the success or failure of application context startup, for logging purposes for example, and that’s why Spring DM offers an event mechanism, through which application contexts send events about their lifecycle to interested parties.
People used to the Spring lightweight container know that standard, non-OSGi application contexts also have an event mechanism.
Spring DM will automatically detect it and add it to the list of managed listeners.
Listing 4.1 shows an implementation of a listener that counts refresh and closing events.
Figure 4.9 Spring DM’s event system: events are propagated outside the containing application context, possibly between bundles.
Spring’s standard event mechanism The Spring lightweight container comes with a built-in event mechanism that allows beans to be notified of lifecycle steps in their parent application context.
They will be notified of events such as the application context starting, stopping, or closing.
Spring also allows beans to raise their own events, which will be propagated the same way as built-in ones.
This makes it easy to use an event-driven approach in Spring applications, which would normally be enough for simple use cases.
Even though Spring DM offers its own event mechanism, the scope is quite different from that of the standard Spring one, which is, of course, still honored by Spring DM applications.
Figure 4.8 Spring’s container (nonOSGi) event system: container events are propagated to beans in the same application context.
Listing 4.2 shows how to declare a listener and export it as an OSGi service, using Spring configuration for the declaration and the Spring DM namespace for the export.
Thanks to this small amount of configuration, our listener bean will be notified of all relevant application context lifecycle events for all Spring-powered bundles in the container.
Figure 4.10 illustrates this mechanism: the configuration we’ve just seen would take place in bundle C, and the listener bean would be notified of the lifecycle events of bundle A’s and bundle B’s application contexts.
In this scenario, the Spring DM extender acts as a kind of event broker (the Spring DM OSGi implementation of application context is actually responsible for a good part of the event system, but this metaphor is sufficient for understanding the basic principles)
What is remarkable about this process is that Spring DM hides the required manipulation of the OSGi service registry, so that you, as an OSGi developer, don’t have to worry about it: write your listener, declare it, and export it.
You’re done, without even having to reference the OSGi API!
Spring container Figure 4.10 Spring DM’s extender can act as broker because it’s able to notify interested bundles of the lifecycles of Spring-powered bundles.
When the listeners don’t get called If you try the preceding example to monitor a number of different Spring DM–powered bundles, you may notice that you don’t see events for some of the bundles.
Remember that Spring DM creates application contexts asynchronously in their own threads by default, so their start order can’t be precisely determined.
In the example in figure 4.10, Bundle C will only receive notifications if its application context is started before that of bundles A and B.
Because bundles A and B don’t have any dependencies on bundle C (remember, only dependencies impose any order on startup) there is no guarantee that this will be the case, unless you, for example, start bundle C first manually and wait some period before starting bundles A and B.
A better way to ensure the behavior you desire is by introducing synthetic dependencies from bundles A and B to C.
The event mechanism is a simple example of what Spring DM can do for you when you want to interact with the OSGi platform, especially with the service registry.
You’ll see more of this in the next chapter, but don’t worry, we’re going to satisfy your thirst for knowledge by first exploring the pattern behind the Spring DM event system: the whiteboard pattern.
Event-based communication is a common way to decouple components, especially when they can be split in two categories: producers and consumers.
Think of the observer pattern: some components (observers) are interested in other components (observables), because the observers want to react when the observables’ state changes or when the observables take some specific action.
The observer components could be directly embedded in the observable components (or the latter could even implement some of the operations of observers), but that would then definitely tie them to each other and would not represent a very extensible design.
To avoid that, observable components usually maintain a list of observers and notify these observers when some events occur (a state update, for example)
In an OSGi environment, event-based communication between components can be implemented by following the observer pattern, but the dynamic nature of OSGi becomes a real hindrance to its use.
The difficulty mainly consists in maintaining consistent linkages between producers and consumers, because to provide modular interbundle connections, they should be OSGi services, and as such, they can disappear or reappear at any moment.
A producer would have to maintain its own collection of listeners, usually with the use of a ServiceTracker.
Even if this solution could work well, it would be cumbersome and error prone.
Another solution might consist of using some kind of middle tier to decouple producers and listeners.
Listeners would register with this middle tier, and producers could retrieve listeners from it in a totally safe manner.
The intricacies we described previously would now be handled by this middle tier.
Luckily for us, this middleware already exists in OSGi, in the shape of the service registry!
In the whiteboard pattern, each time a producer wants to send an event to its listeners, it retrieves it from the whiteboard and proceeds with the event dispatch.
The collection of listeners it receives from the registry can be seen as a snapshot of the listeners.
Why “whiteboard”? The whiteboard pattern takes its name from the analogy of subscribing to something by writing your name on a whiteboard.
You don’t have to find out who is in charge of subscriptions, and this person knows who is subscribed by reading the whiteboard.
Unleashing Spring DM’s standard extender that are registered at the moment the event is dispatched.
The producer relies on the service registry to correctly maintain the collection of listeners.
The usual way to retrieve listeners is to track them through their interface with a ServiceTracker and use the getServices method.
Figure 4.11 illustrates the whiteboard pattern, where the two bundles on the right register listeners; the producer (bundle on the left) retrieves them through the service registry and notifies each of them.
The Spring DM system for propagating application context events is an implementation of the whiteboard pattern, but Spring DM does so much for us that registering a listener ends up requiring writing a single line of XML! This is one of the major benefits of Spring DM: OSGi’s dynamic nature is taken care of, and application code doesn’t need to use the OSGi API at all.
Sometimes, however, we still need a way to interact more intimately with the OSGi platform, and that’s why Spring DM offers entry points to the OSGi API itself.
We’ll see in the next section how to access these entry points.
When using Spring DM, your application code should not depend on the OSGi API, because Spring DM is able to handle all the necessary interactions with the OSGi platform.
Nevertheless, Spring DM lets you access some of the low-level APIs of OSGi if you really need to.
When instantiating the bean, the Spring DM application context implementation detects that it implements this special interface and automatically hands the bundle context to the bean by calling the sole method of the interface, setBundleContext.
The bean can implement any logic it likes when it gets passed the bundle context: it can work directly with it or just keep a reference to it and interact with it later.
The following snippet shows a class implementing the BundleContextAware interface:
Figure 4.11 In the whiteboard pattern, the OSGi service registry acts as a middle tier to connect event listeners to event producers.
The bean can be declared as any other bean is, without making any reference to the bundle context, because Spring DM automatically passes the bundle context:
By implementing the BundleContextAware interface, our OSGi-addicted bean has a direct dependency on the Spring DM API.
That could be problematic, because if some OSGi-specific classes require a reference to the OSGi API, they can’t support references to other frameworks.
Fortunately, in each Spring DM application context, Spring DM automatically inserts the bundle context as a Spring bean with the name bundleContext.
The following snippet shows another kind of OSGi-specific bean, which keeps a reference to the bundle context (notice it doesn’t depend on the Spring DM API in any way):
Thanks to Spring DM, you can easily enjoy the best of both Spring and OSGi worlds! Let’s move on to the next section, where we’ll see how to interact declaratively with bundles.
The Spring DM osgi namespace comes with a bundle element that makes it possible to get references to OSGi bundles and even manipulate them.
You can then use this bundle bean like any other bean.
For example, you can make a reference to any already installed bundle in the OSGi platform by using the symbolic-name attribute, just as in the following snippet, which retrieves the Spring DM extender bundle directly:
The bundle element is not limited to only Spring DM bundles; it works for any OSGicompliant bundle.
You can also use the bundle element with bundles that aren’t yet deployed to the OSGi platform, thanks to the location attribute.
With this attribute, you can indicate where to find a bundle by using the Spring resource syntax.
You can also choose an action to be performed when the bundle is loaded by Spring DM.
The following snippet shows how to create a bundle bean from the filesystem and then start it:
The action attribute supports five values that are the equivalent of the methods of the Bundle interface: install, start, update, stop, and uninstall.
They have the same semantics, but Spring DM makes their use easier than in a pure OSGi environment.
If you take a look at the Javadoc for these methods, you’ll notice that they have strict preconditions.
For example, you can’t call the start method on a bundle that isn’t in the resolved state yet.
With the action attribute of bundle, Spring DM handles these kinds of implicit transitions, and no OSGi exceptions will be thrown.
Table 4.4 lists all the attributes available in the bundle element.
Notice the destroy-action attribute, which can tie an action to a bundle when the application context is destroyed, providing an easy way to stop bundles in a cascade, for example.
This ends our study of the Spring DM standard extender.
You have learned a lot about its mechanics and how to tune the way it handles application contexts; this.
This uses the same semantics as the methods from the Bundle interface, with preconditions weakened.
An action executed on the bundle when the application context is destroyed.
This uses the same semantics as the methods from the Bundle interface, with preconditions weakened.
In chapter 9, we’ll see advanced techniques to tune the extender itself, by changing its global behavior.
If you’re interested in the web support that Spring DM provides, move on to the next section, as it gives information about the web extender and how web applications can fit into an OSGi environment.
From reading the previous chapter, you’ll already know that you can deploy web applications on an OSGi platform thanks to the Spring DM web extender.
When using the web extender, OSGi bundles are installed on the OSGi platform the same way as usual, but they will also be deployed to the embedded web container if they’re detected as being web-enabled.
Spring DM defines its own structure for web OSGi bundles, but we’ll see that it doesn’t really differ from the structure of traditional bundles.
We’ll also see in this section that Spring DM web support opens up a realm of possibilities for web applications.
They will now be able to interact with the OSGi platform and will no longer have to be packaged as big, monolithic WAR files.
When started on the OSGi platform, the Spring DM web extender will try to deploy a bundle to the embedded web container if it meets one of the following conditions:
When a bundle is detected as a web bundle, the web extender will trigger its deployment to the web container, letting the latter handle everything.
This includes placing configuration in the META-INF/ spring/ directory, using the Spring-Context header, and mechanisms like asynchronous startup or waiting for dependencies to bootstrap the application context.
The structure of the simplest web bundle ever is the following:
The Spring DM web extender would then deploy it to the web container (assuming the platform is correctly provisioned, as explained in chapter 3)
The web bundle would be deployed under a web context named my-web-bundle.
This default strategy bases its decision first on the presence of the Web-ContextPath header, and then, if the header isn’t present, on the location of the bundle, by removing the trailing .war or .jar (just like in our example)
After that it falls back on some of the other bundle metadata (name, symbolic name, or identity) if it can’t use the bundle location.
You can consult the Javadoc to see the exact algorithm.
In most cases, the truncated bundle location would make a nice context path, but if this doesn’t suit you, you can override it by using the Web-ContextPath header in the bundle manifest:
This makes the deployment of web bundles easy, but you may be wondering, “Where are my WEB-INF/lib and WEB-INF/classes directories”? That’s a pertinent question, related to classloading, which happens to be the topic of the next section.
A web application is usually made up of its own classes, which can use other classes (frameworks, for example)
All these classes must be available on the web application’s classpath, which is structured like this:
They’re under their .class file form (not packaged) and organized following the traditional tree-like structure of Java packages.
Figure 4.12 illustrates this organization for two web applications in a web container.
They both come with their application classes (in WEB-INF/classes) and their libraries (in WEB-INF/lib)
What we’ve just seen is the usual way to make classes available for loading in a traditional, Java EE standard web application, and it isn’t valid for web applications deployed with Spring DM on an OSGi platform.
When you deploy a web application using the Spring DM web extender, OSGi-specific classloading mechanisms take precedence.
Remember that before being a web application, your application was also an OSGi bundle; as such, its classpath is the OSGi classpath.
Figure 4.12 In standard Java EE deployment scenarios, web applications come with their third-party libraries embedded in their archives.
Your web application will be able to load classes from the following locations:
Its bundle space (classes in the JAR or WAR and classes from all the associated bundle fragments)
Figure 4.13 shows the new scenario for web applications deployed with Spring DM in an OSGi environment.
Notice that web applications contain only their application classes and can rely on OSGi’s mechanisms for classloading (to be able to use bundle A and bundle B classes)
This scenario is possible thanks to Spring DM, because it builds a bridge between OSGi and the web container, so that web applications can use the OSGi classpath as if they were ordinary bundles.
If needed, you can still make your web bundles look like standard WARs, thanks to the Bundle-Classpath header, which indicates to the OSGi platform where to find classes and resources in the bundle.
This header defaults to “.”, meaning the root of the bundle.
You can override this default value and set it to the traditional locations of classes and libraries in WARs (you should not forget to include the default location):
You now know the nuts and bolts of Spring DM’s unique web support.
It’s time to see how Spring DM allows you to interact with the OSGi platform from your OSGi web applications.
Figure 4.13 In an OSGi environment, web applications can rely on OSGi classloading mechanism for their third-party libraries.
This is especially useful when different versions of the same library must cohabit.
When studying Spring DM’s standard extender, we spoke a lot about the application context lifecycle, but so far we’ve avoided this topic for web bundles.
We’ll see in this section how Spring DM extends the behavior of traditional Spring web applications.
Let’s start with a little refresher about the way this kind of application works.
Standard (web) Spring applications have only one Spring application context, which contains all the beans necessary for the application: data source, data access objects, business services, and even web controllers (if you don’t want to use servlets)
In a web container, web applications can’t share their Spring beans (there’s a way to make this possible, but it’s more of a hack and is beyond the scope of this book)
Figure 4.14 shows how Spring-based web applications are usually deployed to a web container.
Notice how the two applications and their respective Spring containers look isolated and can’t communicate with each other to share Spring beans as services.
What do we really want in our OSGi web applications? We want them to be able to consume backend services from the OSGi registry and use them as blackbox components in their web controllers.
This scenario is shown in figure 4.15: three bundles together build a backend layer (at the top of the diagram; their interconnections aren’t shown for clarity) and one of them exposes this layer by registering business services in the OSGi service registry.
Figure 4.15 In an OSGi environment, web applications powered by Spring DM can interact with the OSGi service registry.
Figure 4.14 Traditional Spring web applications can’t make their Spring containers communicate with each other.
Note that the backend bundles can be ordinary or Springpowered bundles, as they interact normally with the service registry; in contrast, the web bundles are backed by Spring DM.
This scenario isn’t science-fiction and can become a reality thanks to the OSGi-enabled web application context Spring DM provides!
The trick to making the scenario in figure 4.15 reality is to ask the web container to bootstrap an OSGi-enabled application context.
Don’t confuse this servlet listener with the Spring DM extender, which has the same class name but is an internal class and isn’t meant to be used directly.
You declare it in the web.xml file of your web application, and in it you can set the location of your Spring configuration files and, more importantly in our case, the implementation of ApplicationContext you want to use.
Listing 4.3 shows how to configure the context loader listener in the web.xml file of the web application to use this new class.
The context loader listener uses a context parameter so that it knows which type of web application context B it must use.
Listing 4.3 Configuring a web application to use the OSGi web application context.
That’s it, your web application is OSGi-enabled and can share OSGi services with other bundles!
You now know more about Spring DM web support in OSGi environments and should be able to see the possibilities it brings to web, as well as to OSGi, applications.
In the next section, we’ll see how Spring DM makes the scenarios we presented possible by discovering how it deploys and undeploys web applications.
Just like the standard extender, the Spring DM web extender is implemented as a synchronous bundle listener, which is registered by the activator of the bundle.
The bundle listener doesn’t itself handle the deployment of web bundles; it delegates this perilous task to a WAR deployer.
Figure 4.16 illustrates the relation between the activator, the extender, and the WAR deployer (class or interface names appear in parentheses)
Even though the activator of the web extender bundle coordinates and performs some of the work (scanning of incoming bundles, thread management for deployment and undeployment), the WAR deployer is in charge of truly deploying (or undeploying) web applications to the embedded web container.
Through the WarDeployer interface, Spring DM abstracts the action of deploying and undeploying WAR files, allowing a separation of concerns, because WarDeployer implementations just handle the deployment process for their web container, whereas the web extender sticks to its primary goal: listening for bundles starting or stopping.
Spring DM provides two implementations of WarDeployer: one for Apache Tomcat (the default) and one for Jetty.
We’ll see in chapter 9 how to switch from one web container to another.
Figure 4.17 shows the WarDeployer class hierarchy in Spring DM.
Figure 4.16 The Spring DM web extender delegates the handling of WAR files to a WAR deployer.
They can manage their own instance of the web container, but the usual way is to look it up in the OSGi service registry.
Remember that in chapter 3, when we made our first web bundle, we added a Tomcat activator bundle.
Its role is to bootstrap a Tomcat Service instance and register it as an OSGi service.
We’ll also see in chapter 9 how to publish our Tomcat Service or Jetty Server instances to be used by the corresponding WAR deployer.
This ends our tour of Spring DM’s web extender, which allows us to leverage the power of OSGi in web applications, mainly by making web applications rely on the OSGi classloading and letting them interact with the OSGi registry, just like any other bundle.
Spring DM extenders should no longer be a mystery to you, almost! By now you should understand that behind the term “Spring-powered bundle” lies complex mechanisms.
Fortunately, Spring DM is here to handle them and fill the gap between OSGi and the programming model of Spring.
Nevertheless, even though Spring DM does a lot for us in the management of Spring application contexts, we need a basic understanding of its extenders to use them appropriately; that’s why we dived into their functionality in this chapter.
From this chapter, the main takeaways are that Spring DM.
Now you know that your bundles are backed by the Spring container, a new OSGi world has opened up to you: you can leverage all the features of the Spring Framework in your OSGi bundles that were so empty before.
Your Spring-powered bundles can benefit from the Spring Framework for their own, inner components, but we’re also interested in the help Spring DM can provide for interacting with the OSGi service registry.
That’s the topic of the next chapter, where you’ll see how to declaratively export and import services, and let Spring DM handle the dynamic nature of OSGi for you.
In the previous chapter, we described how Spring DM provides support for managing Spring-powered OSGi components as well as web components.
We showed that the framework doesn’t actually use OSGi’s activator feature but instead provides an implementation of the extender pattern to decouple components’ implementation from the enabling technology and to configure bundles globally by providing a single point of management.
These mechanisms allow components to use classic Spring features, such as dependency injection, AOP, and support for enterprise applications.
In this chapter, we’ll focus on Spring DM’s support of OSGi services.
As we emphasized in chapter 1, services are a key OSGi feature because they allow you to define entry points for component interactions, and they provide a robust way to take into account the dynamic nature of OSGi.
Unfortunately, the core OSGi specification only provides low-level API-based support for implementing services.
Its use may initially seem simple, but the work becomes more tedious when you want to support OSGi dynamics in a robust fashion.
Moreover, you’re tied to the OSGi API when registering and using services, even if these services are POJO-based.
Fortunately Spring DM provides an abstraction layer that integrates service support with the dependency injection mechanisms of the Spring container.
In this section, we’ll describe all the concepts that Spring DM uses to integrate OSGi services with Spring’s support for dependency injection.
As we explained in chapter 2, OSGi doesn’t provide declarative support for services and, by default, you need to access them via the OSGi API.
We’ll also describe Spring DM’s mechanisms for managing services and how to configure those services with XML and annotations.
Before describing how to use Spring DM’s support for OSGi services, we’ll first describe the concepts underlying Spring DM’s support for services, then focus on its internal operation.
When it comes to services, Spring DM’s aim is to shield users from using the OSGi service API and enable users to easily support dynamic OSGi services in a robust manner.
Spring DM’s support for services is completely declarative and is done using XML configuration or annotations.
Spring DM also transparently supports service dynamics for you by managing a service’s availability at runtime.
In addition, Spring DM allows these dynamic mechanisms to be directly handled within dependency injection and decoration using AOP as if they were configured by the Spring container.
Spring DM provides the ability to define OSGi services directly in the Spring configuration.
The Spring DM container is responsible for interacting with the OSGi service registry according to the stages of the Spring DM lifecycle.
Beans configured as services are registered and unregistered when the Spring container starts and stops, respectively.
Because Spring DM is responsible for bootstrapping the Spring container when an owning bundle starts up, and for stopping it when the bundle is stopped, configured services are also registered and unregistered at these times.
Spring DM also allows you to reference an OSGi service as if it were a regular bean.
This service can then be injected into other beans configured within Spring.
Figure 5.1 describes the ways Spring DM lets you interact with the OSGi service registry.
When referencing OSGi services, Spring DM offers a bridge between beans and services and allows dependency injection with services.
In both cases, Spring DM handles all internal OSGi mechanisms and manages OSGI dynamics.
Spring DM’s service support is powerful and takes care of a lot of things under the hood by using a proxy mechanism between the service and the user of the service as a level of indirection for the service.
Because OSGi is dynamic and services can come and go at any time, directly injecting a service instance into another bean isn’t a good idea.
The instance could become stale over time if the underlying service becomes unavailable.
Instead, Spring DM uses a proxy that passes itself off as the target OSGi service, so the service user isn’t tied to the service.
Figure 5.2 illustrates the proxy mechanism used to inject OSGi services and shows how Spring DM provides a proxy between the service and its user.
Spring DM’s proxy behavior can be configured to modify the way service dynamics are handled: references can be configured as mandatory or optional.
For a single instance, Spring DM will automatically look for a replacement when the current service referent disappears.
For mandatory services, this lookup must always be successful, but this isn’t essential for optional services.
For service collections, Spring DM will automatically add and remove services when service registrations and unregistrations.
Injecting Figure 5.1 Spring-powered bundle can register and reference OSGi services and use them as traditional Spring beans.
Figure 5.2 The proxy mechanism of Spring DM references services and provides a level of indirection between service instance and service user.
If the service collection is configured as mandatory, an empty collection won’t be allowed.
Spring DM also provides support for when services become temporarily unavailable, such as during component updates.
The framework makes it possible not to lose requests by making them block.
When the service becomes available again, blocked calls will be executed on the target service.
In addition, Spring DM provides a timeout-based mechanism for when services remain unavailable for an extended period.
Figure 5.3 illustrates Spring DM’s blocking support for service calls.
The service proxy resolves one last important issue—it provides a flexible solution for controlling the classes that are visible in the context classloader.
We’ll now take a first look at how Spring DM allows you to configure services through XML configuration and annotations.
These features of Spring DM make it possible to leverage OSGi services together with dependency injection.
They provide a convenient way to allow components to communicate while transparently handling OSGi dynamics at runtime.
In this section, we’ll see how to use XML to configure OSGi services with Spring DM within Spring configuration files and we’ll describe the XML tags and their main attributes.
The XML-based approach supports both registering and referencing services as shown in figure 5.4
Spring DM supports services directly from Spring’s XML configuration, thanks to its dedicated osgi namespace.
Dependency injection and OSGi services registration and referencing of services directly from within a Spring XML configuration file.
In following sections, we’ll describe how to configure and use these registering and referencing features of Spring DM.
Spring DM permits you to define OSGi services by using the osgi namespace’s service tag.
This tag allows you to register a Spring bean in the OSGi service registry.
When the Spring container for the bundle is started, all the services declared through the service tag are registered in the service registry.
Similarly, when the bundle—and hence the Spring container—is stopped, the services are unregistered.
Listing 5.1 shows the most common way to configure an OSGi service using the service XML element.
As with a classic bean, an id attribute can be specified to identify the service.
The value of the ref attribute is the identifier of the bean to be registered, and the value of the interface attribute is the name of the interface to be advertised in the service registry.
Referencing service Figure 5.4 Spring DM allows you to both reference and register OSGi services from within XML-based configuration files.
The service XML element allows you to set an id attribute B to reference the bean from within the Spring configuration.
You can then use the ref attribute C to specify the bean that implements your OSGi service.
Finally, the interface attribute C allows you to specify the interface you need to expose for the OSGi service.
You’ll notice that in listing 5.1, any bean configured within Spring can be used in the ref attribute because a Spring-declared OSGi service is simply a POJO.
Spring DM provides additional configuration possibilities at this level, which we’ll describe in section 5.3.1
Spring DM also enables you to obtain OSGi service references.
In this section, we’ll describe how to use XML to configure a bean that references an OSGi service from within Spring DM.
Thanks to the osgi namespace, Spring DM provides the reference XML element, which transparently configures a proxy for the underlying service.
The configured entity can be thought of as a service instance and used directly as a simple bean.
Spring DM automagically handles all the dynamic behavior of OSGi for you.
Listing 5.2 shows a common way of referencing an OSGi service using the reference tag.
As with a classic bean, an id attribute can be specified to identify the service reference.
The interface attribute is used to specify the required service from the OSGi registry.
This attribute corresponds to the identifier stored in the registry and is usually the interface name that the service exposes.
OSGi service identifiers and Spring DM OSGi uses class names to locate services within the service registry.
Even though the identifier is a string, the OSGi container ensures that the service object is an instance of each of the specified service interfaces or classes unless the object is an instance of ServiceFactory.
Although we use the term “identifier” for this concept, you should remember that this identifier must represent an actual class.
The reference XML element allows you to configure a reference to an OSGi service.
The corresponding bean is identified with the id attribute B and can be used as a regular bean.
The service is selected by specifying its exposed interface in the interface attribute B.
Once the reference is correctly configured, it can be injected C into any other bean using the normal dependency injection mechanisms of Spring.
The entity configured with the reference element can only be used as an instance of the type specified in its interface attribute.
When configuring OSGi services with Spring DM and injecting them in beans, the beans aren’t aware that they’re actually using OSGi services.
Spring beans see OSGi services configured with Spring DM as regular beans.
In this section, we saw how to use the OSGi service support of Spring DM using its Spring DM osgi XML namespace.
This support allows you to both register and reference services from within a Spring XML configuration file using dependency injection.
Let’s now take a look at the alternative approach that Spring DM provides for referencing OSGi services—one based on Java annotations.
Spring DM also provides annotation-based support for referencing and using services, as shown in figure 5.5; service registration isn’t supported by this approach.
Annotationbased service lookup provides a less verbose way to configure service references because it gleans some of the required information from the class itself.
To reference a service, you need to annotate a property of your bean (by annotating its setter in the Java class) with the ServiceReference annotation.
If the annotation-driven strategy is activated in the Spring XML configuration, services are automatically looked up and injected as proxies into the target bean.
With annotation-based referencing, Spring DM uses the same underlying mechanisms as it does for XML configuration.
The ServiceReference annotation must be specified on the setter corresponding to the service, as shown in the following snippet.
Figure 5.5 Spring DM allows OSGi services to be referenced by annotations in the Java class.
With annotations, you can reference services directly from within classes configured by Spring.
You generally need to have a property B corresponding to the exposed interface of the OSGi service.
To implement the injection, you need to set a ServiceReference annotation on the setter method of the property C.
When detecting such an annotation, Spring DM will automatically inject an instance of the service.
The ServiceReference annotation accepts the same attributes as the service tag we described previously.
The other solution is based on Spring’s bean post-processor feature.
This feature is commonly used by the Spring web MVC framework with its annotation-based programming model.
Dependency management with annotations We’ve discussed how mandatory dependencies configured in a Spring-powered bundle’s XML file cause the application context to be suspended until the dependencies are satisfied.
Spring DM achieves this by preinstantiating service beans, then deciding whether or not they’re mandatory.
But instantiating mandatory service references declared through annotations gets quite tricky because the actual bean class is required, and mandatory dependencies don’t cause the application context startup to be suspended.
Instead, the application context is created as usual, but any subsequent calls to mandatory dependencies will block.
The most common approach to using services is to use Spring XML configuration, so we’ll focus on it in the following sections of the chapter.
Annotation-based support will suit people who prefer using Spring with annotations rather than with XML.
You’ll notice that both types of support are equal when referencing services, and the same configuration properties are available in both.
Before going further into advanced uses of Spring DM’s service support, we’ll focus on the context classloader and how it can be used within OSGi context.
Spring DM integrates context classloader management in its service support to make class resolution easier.
For some specific enterprise use cases, this strict behavior isn’t particularly convenient (such as when dynamic classloading is involved)
Luckily, Java provides a thread context classloader (TCCL) that allows the classloading of an implementation to delegate classloading to the caller, and vice versa, without having to specify an Import-Package declaration.
The next section describes what this classloader is, how to use it, and why it’s particularly important in the context of OSGi.
We’ll need to look at Java’s context classloader feature to understand how Spring DM uses this feature within an OSGi environment.
The TCCL was introduced in Java version 1.2 to allow code to associate a particular classloader with the current thread.
Java frameworks regularly use it for loading classes they need, and callers of these frameworks are expected to set the TCCL appropriately.
By default, this classloader is the application’s classloader, but Java gives you the ability to change it according to your needs.
For this reason, we recommend that you use the extender-based configuration mechanism (discussed in chapter 9) if you want to use annotation-based service injection.
Using the TCCL within OSGi makes it possible to solve some problems without having to export and import packages.
In particular, it helps frameworks that don’t know until runtime which classes they need to use.
Frameworks usually look at several classloaders, including the context classloader, when trying to load classes dynamically.
Resolving classes using TCCL is particularly useful for frameworks implementing dependency injection, such as Spring, and ORM, such as Hibernate.
With Spring, you can configure bean instances to be managed, and the framework will instantiate them according to the XML configuration.
Hibernate, in contrast, will instantiate persistent instances corresponding to mapped classes.
By default, implementation bundles for these kinds of frameworks don’t import application classes.
Figure 5.6 illustrates the problem when a Hibernate component tries to load mapped classes for an application component.
Hibernate can’t load the mapped classes because they’re user-defined classes and aren’t specified in the Import-Package header of the Hibernate component.
The framework tries to discover the required classes through configuration.
The way to best address these issues is described in detail in chapter 7 in the context of JPA.
Specifying packages directly within the bundles of frameworks isn’t practical because you would then need to update the manifest contents of third-party bundles.
Alternatively, you could use fragments to extend these bundles, but that’s also somewhat limiting because it requires you to implement a bundle and limits you to a single extension of the framework bundle.
This is where the TCCL comes into play, because most frameworks are smart enough to look for classes in several classloaders, including the TCCL.
If the caller’s bundle has set the context classloader with its associated classloader, the framework bundle will be capable of instantiating classes that are visible only to the caller’s bundle.
But if the caller sets the context classloader appropriately, Spring would be able to see the class and load it.
In listing 5.3, we first obtain and save the previous classloader B contained in the context classloader in order to restore it later.
We then set the bundle classloader as the context classloader C.
After executing our processing, we restore the initial classloader as the context classloader D.
By adjusting the context classloader this way, the implementation will be able to see the classes of the current bundle.
We’ve seen how Java’s context classloader can help in an OSGi environment to solve class visibility problems without adding packages to the Import-Package headers of components.
This mechanism can also be used to allow service implementations to see and use the classes of the caller.
We’ll see in section 3.2 that Spring DM makes it possible to directly configure this in the XML configuration file.
Listing 5.3 Using the context classloader when creating a Spring container.
In the next section, we’ll discuss advanced configuration when registering and referencing OSGi services using Spring DM.
In section 5.1, we discussed Spring DM’s support for services.
Spring DM also provides a flexible way of registering and referencing services by declaring specific properties.
In this section, we’ll discuss these advanced settings in detail.
In this section, we’ll look at the advanced settings related to the service tag.
Spring DM provides different advanced configurations when registering beans as OSGI services.
All these kinds of configurations are described in detail in following sections.
Spring DM supports several ways to specify which bean is used for registration.
It allows you to reference a bean via its Spring identifier.
Spring DM also supports the use of an anonymous bean within the service tag, as shown in the following snippet:
You can use anonymous beans when registering a service by directly specifying a bean tag B inside the service tag.
In this case, the bean doesn’t need to have an id attribute and can’t be used elsewhere in the Spring configuration.
When you use the service tag’s interface attribute, Spring DM registers the service with an identifier corresponding to the value of this attribute.
Because OSGi allows you to register services under several identifiers, Spring DM also provides an inner interfaces tag that accepts a list of values, as shown in the following snippet.
Note that the interface attribute and the interfaces tag can’t be used at the same time in a service tag.
In addition to this explicit configuration of interfaces, Spring DM provides a mechanism to detect values used for the interface attribute and interfaces tag.
This mechanism is configured through the auto-export attribute and provides alternative strategies to autodetect interfaces when the interface attribute and interfaces tag are not specified, as described in the table 5.1
The following snippet shows how to use the auto-export attribute with the interfaces strategy.
Because the class corresponding to the testServiceBean bean implements the TestService interface, its qualified name will be used as its identifier during the service registration:
When using a strategy other than disabled, you don’t have to specify values for the interface attribute and interfaces tag.
However, you can combine both explicit settings with the interface attribute and interfaces tag and autodetection to specify the identifiers to use when exporting a service.
Note that only visible types of the bundle will be used in autodetection.
Spring DM’s service tag allows properties to be specified when services are registered.
These properties can be used in a filter expression in combination with the service identifier when looking up a service.
Spring DM provides a service-properties tag to be used as an inner tag; it accepts a list of key/value pairs, as shown in the following snippet:
Table 5.1 Auto-export strategies for the interface attribute and interfaces tag.
The snippet first defines a block for properties using the service-properties XML tag and then specifies a property for the service with the key creationDate.
Specified properties correspond to the properties parameter of the registerService method in the BundleContext interface, and this properties map is of type Dictionary.
The values specified in the service tag are automatically passed to this registerService method by Spring DM when registering the corresponding service.
Spring DM lets you manage a service’s classloading context by setting a classloader as the TCCL during the call of a service method.
If specified in the service registration configuration, Spring DM makes it possible during the service call to see all the classes of the bundle that registers the service, as shown in figure 5.7
When exporting a bean as an OSGi service, Spring DM allows you to specify which classes are reachable from this service based on the TCCL managed by Spring DM.
At this level, either no classes, or classes present in the bundle that registers service, will be reachable.
This snippet shows how to use the service tag to configure the service-provider strategy when the service is registered:
Internally, Spring DM adds a proxy in front of the target service to transparently manage the TCCL.
Adding this proxy is supported for both interface-based and concrete classes, but for the latter you’ll need to use CGLib.
Spring DM allows you to specify a rank for a service through the service tag’s ranking attribute.
OSGi’s ranking feature is used when you’re trying to obtain a service reference and there’s more than one service match.
In this situation, the service with the highest ranking will match.
The ranking of services is also used by Spring DM as a tiebreaker in its shutdown algorithm.
The Spring Framework provides the scope attribute of bean tags to control the instantiation of beans.
Spring DM provides a dedicated bundle scope, which allows you to finely manage the creation of service instances by calling components.
The OSGi specification also describes the ServiceFactory interface, which allows you to create a unique service instance for each bundle that requests the service.
Spring DM can implement this mechanism without using the related OSGi ServiceFactory interface, based on the bundle scope.
For the bundle scope, Spring DM transparently enables service instantiation per component.
Spring’s scope support The Spring Framework allows you to manage bean creation through the bean tag’s scope attribute.
The default, singleton, guarantees that only one instance of a bean is provided; prototype allows you to obtain a new instance when requesting the bean from the container.
Basing on this new scope support, several new scopes (request, session, and globalsession) related to web technologies were also added.
The configuration of the service factory feature using bundle scope must be done on the bean (in the bean tag) in order to export the bean as a service.
It is not done on the service exporter (the service tag of the osgi namespace)
The registration of an OSGi service using the service tag B can be based on a bean definition using the bundle scope C.
This configuration automatically enables the service factory feature when accessing and using the service.
We’ve seen how to register services with Spring DM through its service tag.
Now we’ll look at the how to reference services with Spring DM’s reference tag.
Section 5.5 will address the support that Spring DM provides for using a collection of services.
Spring DM allows you to specify different advanced configurations when referencing OSGI services:
In the following sections, we’ll describe all the possible advanced configurations when referencing a service through Spring DM.
You can specify identifiers when referencing services in the same way as when registering services.
The interfaces tag is available and must be used as an inner tag.
It accepts a list of values, as shown in the following snippet:
Like the service tag, the interface attribute and interfaces tag can’t be used at the same time.
Spring DM includes sophisticated support for links between components made using OSGi services.
It allows you to define what happens when a service isn’t available or when one becomes unavailable.
The availability attribute of the reference tag allows you to configure whether or not service is optional, and it accepts the values listed in table 5.3
Setting the value for the availability attribute specifies how Spring DM should behave during service matching and, more particularly, when the service can’t be immediately resolved.
The following snippet shows how to use the availability attribute to specify that the service is optional for the component:
The service must always be present for the component’s execution.
Table 5.4 Different behaviors of Spring DM depending on service availability.
The container waits until the service is available before completing its startup.
The container starts even if the referenced service isn’t available.
On a service call, if the service isn’t available, the container waits until the service becomes available to execute the call.
It behaves in the same way as on Spring container startup.
The timeout attribute allows you to specify the amount of time, in milliseconds, to wait for a service to become available when an operation is invoked on it.
The depends-on attribute specifies that the service reference must not be resolved until the specified bean has been initialized by the Spring container.
The following snippet illustrates how to use these two attributes:
As with service exporting, Spring DM provides support to automatically manage the TCCL when calling a referenced service.
Spring DM allows a service call invocation to see all the classes of the calling bundle, or of the bundle that registered the service, through the setting of the TCCL, as shown in figure 5.8
When referencing an OSGi service, Spring DM allows you to specify which classes are reachable from this service by setting the context classloader.
At this level, either no classes, or classes present in the bundle that either registers or calls the service, will be reachable.
This strategy provides a robust solution for the problems described in section 5.2.2
The following snippet shows how to configure the service-provider strategy during the service referral through the reference tag.
As you’ll have noticed, classloader management for services can be configured both when registering and referencing services.
Spring DM will always override the reference setting if the service setting is configured.
Spring DM allows you to specify fine-grained selection of services at the level of the reference element.
The following snippet shows how to select the service corresponding to the TestService interface and having a creationDate attribute with the value 2009-12-12:
We’ve now seen how to configure OSGi service support in Spring DM.
As we’ll see, Spring DM can handle all the tedious processing necessary to keep your system consistent.
Because OSGi is intrinsically dynamic, Spring DM allows you to configure listeners that are notified when services are updated.
Although Spring DM internally handles OSGi’s dynamics for you, you’ll probably need to add your own dynamic logic at times to make your system work the way you want.
For instance, unregistering a service can affect components that use it, and those components need to be notified so they can adapt their processing.
Spring DM can send notifications both when a service is registered and referenced, depending on the Spring DM configuration, as shown in figure 5.9
You can even register user components as listeners for these events.
Spring DM provides a bridge between events triggered by the OSGi container and these listeners configured as beans.
It also provides an abstraction over the OSGi API and enables the use of POJOs as listeners.
Figure 5.9 summarizes the notifications that can be triggered by Spring DM regarding services.
Notifications can be handled on the referencing bundle side and the registering bundle side.
Spring DM is responsible to dispatch events to entities registered as listeners.
Let’s look now at how we can listen for these two kinds of events when exporting and referencing services.
Spring DM allows you to configure listeners in the service tag when exporting a service.
Like the Spring Framework, with its support for bean lifecycle notification, Spring DM provides two ways to implement and configure listeners:
When this interface is present, Spring DM will automatically register the bean as a listener of the service’s lifecycle.
This is a reasonable approach, but it ties your implementation to the Spring DM API.
This approach is preferred because it allows you to use a POJO as a listener.
The association between events and callback methods is specified through the service listener configuration.
We’ll focus on the latter and recommended approach, using the osgi XML namespace to configure the service listener.
Table 5.6 lists the available attributes for that XML element.
Specifies the method of the listener bean to be called when the service is registered.
The method must have exactly two parameters: One of the type of the service and corresponds to the service that’s being listened to.
A second which corresponds to the service’s properties and can be of type Map or Dictionary.
Specifies the method of the listener bean to be called when the service is unregistered.
The following snippet shows how you can specify the previous bean as a service listener for the testService service.
Let’s now look at how to register for notifications when a service is bound to and unbound from a service reference, and how to handle these events.
Spring DM allows you to configure beans that reference services to receive notifications when the configured service is bound or unbound by Spring DM.
Like its support for registration events, Spring DM provides two different methods for configuring beans:
Specify a service reference listener configuration in the reference tag.
This approach is preferred because it allows you to use a POJO as a listener.
The association between events and callback methods is specified through the service reference listener’s configuration.
These two approaches are equivalent because the listener can be configured as a dedicated entity in both cases and it’s separate from the service itself.
Which you choose depends on your preference for implementing an interface or using a declarative approach.
This interface has methods corresponding to the bind and unbind events: bind is called on a service bind event, and unbind is called on an unbind event.
The first parameter is the instance of the related service, and the second is the associated service properties.
The second approach is declarative, so the listener class doesn’t need to implement any interface.
Any POJO can be used, but the methods used when events occur must follow simple rules in the declaration of their signatures.
To configure the link between events and the methods to call, Spring DM provides the attributes listed in table 5.7 for the listener nested tag of the service tag.
Listing 5.5 shows the content of a service listener with an onServiceBound method for the service bind event and an onServiceUnbound method for the service unbind event.
Once the listener is implemented, it can be configured as a bean and referenced from the service reference definition using the ref attribute of the listener element.
The listener is defined as a simple bean B, and it’s then referenced as a listener of the service reference through the ref attribute of the listener element B within the reference element.
Within the listener element, you can use the bind-method attribute to specify which methods must be used on the service bind event and use the unbind-method attribute to specify the methods used on the service unbind event C.
Spring DM also supports the use of a nested bean for the listener instead of using the ref attribute of the listener tag to refer to another bean.
The method must have two parameters: The first is of the type of the service and corresponds to the service.
The second corresponds to the service properties and can be of type Map or Dictionary.
The method signature follows the same rules as for the bindmethod attribute.
We’ve now covered Spring DM’s core support for OSGi services.
You have learned all the concepts and seen how to register and reference single services.
You also know how Spring DM handles the dynamics of OSGi.
The next feature we’ll look at is Spring DM’s support for service collections.
This powerful and useful feature allows you to handle a set of services and easily implement the OSGi whiteboard pattern.
OSGi allows you to register several services using the same identifier, but when you do a lookup on the OSGi service registry, you usually want to refer to a single instance of a service.
The OSGi service registry finds all the services that match the requirements and choose one to be returned (as determined by an algorithm)
Nevertheless, you may be interested in all the services that implement a given interface and that meet some criteria.
Collections of services can be useful in parts of an application that can be extended, like entries in a menu, tabs in the UI that provide access to different modules of an application, and so on.
Imagine removing a bundle that registers such a service in your OSGi container, and the UI is immediately updated with the new functionality.
Collections of services can also be used in variants of the observer pattern, like the whiteboard pattern, where the listeners are services.
You can manipulate collections of services with plain OSGi, but this can lead to complex, cumbersome, and error-prone code; Spring DM provides a flexible way to transparently handle them.
Moreover, Spring DM internally deals with all the dynamic features of OSGi to provide an up-to-date collection at any given moment.
Spring DM provides two tags for configuring collections of OSGi services within the Spring configuration of components: the list tag for lists and the set tag for sets.
The difference between lists and sets is the uniqueness of contained elements, based on the returned value of the equals method of these elements.
This method must be overridden in this case and its return value is determined using the attribute values of the elements.
This mechanism is integrated within the Java Collections framework and isn’t specific to OSGi.
These tags accept the same attributes as the reference tag, described previously in section 5.3.1, along with a few others.
The comparator-ref, greedy-proxying, and member-type attributes are specific to list and set tags.
The following snippet shows how to use the list tag to reference a service collection for a given identifier and make it available within the Spring container as a java.util.List.
Let’s look at how to configure and use advanced features, such as collection sorting, greedy proxying, and integrated support when collections are updated.
Spring DM allows you to sort service collections within list and set tags by using the Comparator interface.
Comparators can be configured directly within the Spring container and referenced when configuring service-based collections.
These two ways to configure comparators are supported by Spring DM:
This is the same use as for the reference tag.
This is the same use as for the reference tag.
This is the same use as for the reference tag.
Can be used to automatically manage the TCCL when calling a referenced service.
This is the same use as for the reference tag.
A value of optional means that the collection can be empty and services are optional; a value of mandatory (which is the default) requires at least one service in the collection.
With a value of service-object (the default), Spring DM service proxies are present in the collection; with a value of service-reference, the collection contains ServiceReference objects.
Configuring a comparator as a nested bean through the nested comparator element.
A comparator is a class implementing the Java Comparator interface and its compare method to compare two objects, as shown in the following snippet:
Now that you know how to implement a comparator, we’ll see how to configure them within Spring DM to sort service collections.
Listing 5.6 demonstrates how to configure sorting using both the comparator reference and a nested element for comparator.
A custom comparator needs to be defined first as a regular Spring bean B, and it can then be referenced within the service collection configuration by using the Spring DM comparator-ref attribute C.
The comparator can be defined as a nested bean within service collection configuration by using the comparator tag D within the list and set tags.
Instead of providing your own comparators, Spring DM allows you to use natural comparators, through the natural tag of the osgi namespace.
This tag has a basis attribute that accepts one of two values, specifying which sorting strategy you want to use:
Listing 5.7 shows how to use Spring DM’s natural comparators within comparator tags.
Both strategies for using a natural comparator can be specified through the basis attribute of the natural tag within the comparator tag.
For the service-instance approach, the services value must be specified B, whereas the service-references value is used for the service-reference approach C.
Now that you know how to configure service collection references with Spring DM and how to sort them, let’s look at their more advanced features.
When configuring service collections, Spring DM allows you to use one or several interfaces to determine the services that will be present in the collection.
However, services can expose interfaces other than the specified ones, and applications sometimes need to use these additional interfaces.
By default, Spring DM doesn’t allow you to cast services in collections to other types than those set in the interface attribute or interfaces tag.
The greedy proxy feature of Spring DM makes it possible to cast services in collections to all of the exposed interfaces that a service supports.
The only restriction is that the interfaces used must be visible to the component within OSGi.
The following snippet shows how to enable the greedy proxy feature on list and set tags through the greedy-proxying attribute.
Once greedy proxying is enabled, you can cast your service reference to any of the exposed interfaces and classes visible to your component.
Listing 5.8 shows how to use this mechanism when iterating through the service collection configured in the previous section.
As usual, the service elements can be accessed as the type specified when configuring the service collection reference B.
When enabling the greedy proxying feature of Spring, you’re able to see these elements as other types corresponding to other exposed interfaces for the service C.
Let’s now look at how Spring DM handles service collection references in this context.
Spring DM supports the dynamic update of service collections and guarantees that the collections are always up to date according to the service registry.
For optional service collections, an empty collection throws no exception and is simply empty.
When parsing collections, the Iterator interface must be used as in standard Java applications.
Spring DM automatically updates iterators when services disappear, to avoid dealing with the resulting stale service references.
Note that this feature has no impact on unregistered service instances that have been obtained from an iterator.
That’s all there is to say about service collection management within Spring DM.
In the last sections of this chapter, we’ll describe how to programmatically use Spring DM to register and reference services.
This approach can be particularly useful when developing unit tests or implementing processing not configurable by using Spring DM’s XML and annotation support.
In some advanced scenarios, you’ll need to use Spring DM’s service support programmatically.
This part of the support is hidden by the osgi XML namespace and unfortunately is not publicly documented.
Fortunately, Spring’s FactoryBean feature makes it quite easy to use.
This programmatic support can be very useful when implementing test cases or building Spring configurations.
This approach is particularly suitable for bundles that can’t use the osgi XML namespace and must work directly with the underlying Spring DM abstractions.
As this class is directly used by the osgi XML namespace, you’ll find it has the same configuration properties as the service tag.
The first step is to instantiate the bean B and the dedicated Spring DM FactoryBean service abstraction C.
The FactoryBean then needs to be configured with the same elements that are used when configuring a service reference through the Spring DM XML namespace: the exported interfaces of the service, the target bean reference for the service, and the context classloader strategy must all be set.
The afterPropertiesSet method must then be called to check whether the FactoryBean is correctly configured, and the method also initializes it.
If no errors occur, the service is now successfully registered.
In order to finalize the FactoryBean, the destroy method must be called E.
You can similarly reference a service programmatically with the Spring FactoryBean feature.
Spring’s FactoryBean feature Spring FactoryBeans allow you to configure beans that can’t be created by simply using a new operator.
For example, this is the case when using the factory design pattern, which hides how you instantiate classes.
Once the FactoryBean is initialized, the target bean instance can be obtained through the getObject method.
The first step is to instantiate the dedicated Spring DM FactoryBean abstraction for referencing a service B.
The object then needs to be configured with the same elements required when configuring a service reference using the Spring DM XML namespace: the required interfaces of the service and the context classloader strategy must be set.
The afterPropertiesSet method must then be called to check whether the FactoryBean is correctly configured and to initialize it.
A valid service reference instance can then be obtained by using the getObject method C.
In order to finalize the FactoryBean, the destroy method must be called D.
That’s why we won’t describe it here, but we’ll show how Spring DM allows you to get native service references from service proxy management.
Spring DM supports injecting a service’s ServiceReference instance into a bean instead of injecting the service instance itself.
Nothing special needs to be done except for injecting the configured reference into a property of type ServiceReference.
You’ll notice that the injected instance corresponds to a proxy and not the target reference of type ServiceReference.
Having injected the ServiceReference for the referenced service, the instance can be used within the application, as in the first of the preceding code lines.
A typical use case for this technique is when you want to get hold of a real OSGi service because an OSGi container implementation expects a native ServiceReference instance instead of a Spring DM proxy.
The core OSGi specification doesn’t provide declarative support for managing and using services; it requires that you use the low-level OSGi API.
To do so, you have to handle OSGi dynamics by hand, which can be tedious and error-prone.
Together with the extender mechanism, service support is the most powerful feature of Spring DM as it allows both registering and referencing services transparently without having to use the OSGI API at all.
The osgi XML namespace, which allows you to manage and use services like regular beans in a Spring application context, is commonly used.
These two approaches for to managing OSGi services provide a flexible way to register and reference services using Spring DM.
Another powerful aspect of Spring DM’s service support is its management of OSGi dynamics: all the instances Spring DM manages adapt automatically to the registration and unregistration of services.
Spring DM also allows you to customize what happens when services are, or become, unavailable, by specifying services as mandatory or optional.
Spring DM also provides built-in support for managing the TCCL when calling services.
This allows you to solve classic problems of class visibility in a simple and straightforward way, without adding Import-Package entries in the manifests of framework-based components.
This chapter ends our discussion of the core features of Spring DM.
We’ll see in the next chapter how to apply them to develop enterprise, OSGi-based applications.
You saw in the previous chapter that OSGi lets its modules communicate only by way of services.
This helps decouple them and promotes a more modular programming model than in standard Java.
Modularity is good for applications, but, as enterprise application developers, we’ve become negligent when developing enterprise applications in the last few years.
These applications grew big and monolithic, did not have particularly strict dependency management, and sometimes used Java introspection or classloaders in fancy ways.
Now that we have discovered OSGi and want to build our enterprise applications on top of this wonderful platform, we need to eliminate these bad habits.
Don’t feel guilty or desperate: OSGi is a welcoming world, even for enterprise application developers.
Throughout this chapter, we’ll show you how to adapt your development to OSGi by choosing good frameworks and libraries that are OSGi-compliant, by getting existing Java artifacts ready for use in OSGi environments, and by designing your own applications to leverage the features of OSGi.
This may look like a tortuous path, but you’ll be surprised at how much OSGi has already become part of day-to-day development work.
You may well discover that you’ve been using OSGi-compliant frameworks for months without knowing it.
In this chapter, we’ll guide you along the OSGi path.
We’ll start by showing you that you can still use your favorite libraries and frameworks in OSGi: some of them are already OSGi bundles, and you’ll learn how to make the others compatible.
Because OSGi brings a new modularity paradigm to Java, we’ll also show you how to leverage it and design applications with OSGi, backed up by Spring DM.
This may seem off topic in a Spring DM book, but it will show you that introducing OSGi in enterprise applications isn’t difficult.
Spring DM will be the bridge between your applications and the OSGi runtime; we’ll discuss this in section 6.3, which provides guidelines about application design with OSGi.
Spring DM can help you follow and implement these guidelines.
You’ll learn how Spring DM can assemble and communicate with your OSGi bundles easily, and how it can help you handle the powerful but tricky dynamic aspect of OSGi.
Let’s start by looking at how traditional Java libraries and frameworks react within an OSGi environment.
The deployment unit in OSGi is the bundle, which is a standard JAR file, enhanced with metadata that (among other things) informs the OSGi platform of the bundle’s dependencies and what it can provide to other bundles in terms of Java packages.
Having all of your libraries, frameworks, modules, and applications packaged as bundles is essential for successfully using OSGi.
Note that this section isn’t specific to Spring DM; the information it covers is valid for any OSGi-based application.
As a developer of enterprise applications, you’ll know that you never start a new project from scratch.
You know you can rely on your pet frameworks, which relieve some of the recurrent technical concerns.
Indeed, that’s what enterprise application development is all about—not reinventing the wheel, and reusing existing code as much as possible.
But in developing OSGi applications, you’ll soon notice that not all Java and Java EE libraries or frameworks are packaged as OSGi bundles.
Even worse, some aren’t OSGi-friendly in their use and execution.
Fortunately, some projects are aware of the growing popularity of OSGi in Java enterprise middleware and applications, so becoming OSGi-compliant, from their design to their packaging, became one of their priorities.
Don’t abandon OSGi because you’re afraid you’ll have to start your project from scratch.
There are a lot of enterprise frameworks and libraries that work in OSGi environments.
If you decide to develop OSGi applications, the biggest changes will be in the structure of your applications rather than in the frameworks you use.
If you’re lucky, your favorite frameworks and libraries will work out of the box.
If you aren’t so lucky, you’ll have to make their packaging OSGi-aware.
We’ll cover both cases, starting by describing what’s known to work in an OSGi environment.
For example, Jakarta Commons Logging (JCL)is known to be OSGi-unfriendly because of its dynamic discovery process (see the sidebar for more details)
Some functions like dynamic loading of classes are sensitive within OSGi, so you should ensure that your favorite libraries and frameworks handle them in a safe and reliable way before using them in an OSGi environment.
Jakarta Commons Logging and OSGi JCL is probably the most popular logging facade, but despite its large adoption, JCL is very OSGi-unfriendly.
How can a good library become a bad egg in OSGi?
This means you can use the JCL API in your applications and simply plug in your favorite implementation, as long as it’s supported.
This initialization consists of dynamically finding which implementations are available on the classpath, choosing one, and redirecting all subsequent calls to it.
In theory, this sounds simple: you drop JCL and Log4j JAR files into your applications and the latter will be used automatically in most cases.
If you’re unlucky, you won’t get any log messages and will fight for hours trying to diagnose cryptic classloader issues.
JCL’s discovery process is dynamic and relies on the use of the TCCL.
Corresponding JCL implementation classes (such as Log4jLogger) are also loaded by the TCCL, but when it comes to instantiating one of these logging objects, JCL uses the current classloader, which doesn’t always see the same implementation classes (because it can be different from the TCCL)
This dynamic discovery process can be problematic in some servlet containers, and it makes the use of JCL in an OSGi environment very difficult, if not impossible.
To help you find appropriate libraries and frameworks, table 6.1 offers a nonexhaustive list of those that are known to be OSGi-compliant.
The Spring Framework binaries have been packaged as OSGi bundles since version 2.5
All binaries are OSGi bundles, and most of the projects have been tested in OSGi environments.
Jetty Web container Distributed as an OSGi bundle and used as an implementation of OSGi’s HTTP service.
OpenEJB EJB 3.0 container Distributed as OSGi bundles and used in several application servers.
Recall that we also deploy SLF4J bundles when we use Spring DM.
SLF4J is another logging facade, which strives to address JCL’s pitfalls by using a static discovery process.
But still, Spring and Spring DM use Jakarta Commons Logging! Yes, they do, and that’s why we also deploy a special JCL bundle, which is a library provided by SLF4J.
It defines the exact same API as JCL but it’s backed up by SLF4J.
This library has the appearance and smell of JCL, but it’s actually SLF4J.
That’s the trick for making Spring and OSGi happy about logging.
In the next section, we’ll introduce you to several repositories where you can download ready-to-use OSGi bundles.
We saw that some projects distribute their binaries as OSGi bundles.
If one of your dependencies happens to not be a part of these projects, there’s still a small chance you won’t end up wrapping it yourself, because there are some projects targeted at making OSGi bundles available.
Here is a list of some of these OSGi repositories:
OSGi Bundle Repository (http://www.osgi.org/Repository/HomePage) Maintained by the OSGi Alliance, this repository hosts more OSGi-centric bundles than OSGi-ified versions of enterprise frameworks.
You can search bundles by keyword or category and get precise information from the web interface.
The format of the repository follows a standard described in the “OSGi RFC 112 Bundle Repository,” making the repository usable remotely by any OSGi container.
Some volunteers OSGi-ify standard Java artifacts and make them available, hoping original developers will then include the OSGi-ification process in the build of their frameworks and libraries.
Contributions include most of the Apache Commons projects, ANTLR, and cglib.
Eclipse Orbit (http://www.eclipse.org/orbit/) This repository includes bundles that have been used and approved in one or more projects from the Eclipse Foundation.
These bundles can contain some Equinox-specific metadata because they’re meant to be used with this particular OSGi container.
SpringSource Enterprise Bundle Repository (http://www.springsource.com/ repository/app/) This repository hosts hundreds of open source enterprise libraries, usually OSGi-ified by SpringSource employees.
It features a search engine and precise information about bundles.
Artifacts are made available for use with Maven 2 and Ivy.
Logback Logging implementation OSGi-compliant; intended to be successor to Log4j.
Wicket Web framework Wicket binaries have been packaged as OSGi bundles since version 1.4
You should find what you need from among these repositories.
But if you don’t find a library, you’ll have to do the dirty work yourself, and in the next section we’ll describe techniques that make this relatively painless.
Before diving into the design of enterprise applications with OSGi and Spring DM (which we’ll do in section 6.3), we need to have all our dependencies be OSGicompliant.
Developing applications for an OSGi environment should not prevent you from using your favorite Java and Java EE libraries and frameworks.
More and more libraries are now OSGi-friendly, because packaging them as an OSGi bundle is part of their build; but bad things happen, and perhaps one day you’ll find that your best-loved Java framework is packaged as a normal JAR and is absolutely useless in your OSGi application.
You’re about to learn everything you need to know about transforming a non-OSGi JAR file into a 100 percent OSGi-compliant bundle, a process that we decided to qualify with the barbarism “OSGi-ification” for brevity.
We’ll start with a little bit of theory, and then we’ll dive into the transformation.
We’ll first try to do it by hand and then use tools like Bnd.
We’ll do our experimenting on the Apache Commons DBCP library.
The main issue in the OSGi-ification of an existing library is visibility.
From the library’s point of view, it means being able to see external dependencies but also making its own classes visible to other bundles if necessary.
You may have figured out that we’ll have to juggle the Import-Package and Export-Package manifest headers.
When a library is built upon other libraries, it uses their classes and imports some of their packages into its own classes.
In a standard Java environment, you can add these libraries on the classpath, and any class can import their packages and use their classes.
The story is different in an OSGi environment: libraries must explicitly export the packages they want to share, and modules that want to use them must explicitly import these packages.
The whole export/import process is managed by the OSGi platform with metadata contained in the bundle’s manifest file.
Let’s talk first about the process of importing: a library needs to use some classes defined in another library (we’ll assume the other library properly exports these classes, making them visible to other bundles)
As an example, consider the ORM module in the Spring Framework: this module includes support for popular ORM tools such as Hibernate, iBATIS, and OpenJPA.
If we focus on Hibernate, the ImportPackage of the ORM module might look like the following:
Hibernate has a lot of packages, and Spring ORM uses most of them, so we didn’t include the whole list.
The previous snippet is fine regarding what Spring ORM can see (some of Hibernate’s packages) but it isn’t precise enough regarding versions.
The Import-Package header can use the version attribute to specify the exact version or version range the bundle needs.
This attribute defaults to the range [0.0.0, ?), and because we didn’t use the version attribute in our first manifest declaration, the ORM module would use any available version installed in the OSGi container.
As you can see, when OSGi-ifying a library, good practice consists of indicating the version of each package in the Import-Package header.
Spring ORM not only includes support for Hibernate, but also for iBATIS, amongst others, so the Spring ORM bundle can apply the same pattern for declaring dependencies on iBATIS:
Nice, but let’s imagine you’re working on an application that uses Hibernate and the support provided by Spring ORM.
You provision your OSGi container with the corresponding bundles, but you soon notice that if you want the Spring ORM bundle to be resolved, you need all of its dependencies in your container, like iBATIS or OpenJPA, even if you only use Hibernate.
That’s a real pain, because you’ll have to get all these dependencies as OSGi bundles and deal with their dependencies—all for nothing because you don’t even use them!
Don’t panic, there’s a solution: these kinds of dependencies can be marked as optional in the manifest, by using the resolution directive.
This directive defaults to mandatory, meaning that the bundle won’t be able to resolve successfully if the imported package isn’t present in the container.
The resolution directive can also take the optional value, to indicate that the importing bundle can successfully resolve even if the imported package isn’t present.
Of course, if some code that relies on the missing import is called at runtime, it will fail.
Spring ORM declares its dependencies on ORM tools as optional, because there is little chance that all these libraries will be used at the same time in an application:
To sum up, when OSGi-ifying libraries or frameworks, you should remember the following guidelines with respect to the Import-Package header:
Import the packages that the library or framework uses, and don’t import unused packages, which would tie the bundle to unnecessary dependencies.
Specify the version of the packages, so the library or framework won’t use classes that it isn’t meant to use, which could lead to unexpected behavior.
Specify the difference between mandatory and optional dependencies by using the resolution directive.
That’s enough about importing from other bundles; let’s see now how a library can make its classes visible in the OSGi platform.
Which packages need to be exported by a library depend on its design.
Some libraries clearly make the distinction between their API and their implementation classes, through some kind of special structuring of their packages.
For example, interfaces (the API) may be located in one package and internal classes (implementation, utilities) in an impl or internal subpackage.
Nevertheless, the export declarations will usually end up exporting all the packages of a bundle because even if we follow the programming through interface pattern, we’ll usually need an implementation that’s provided by the same library as the API.
Just remember that OSGi services are a good way to expose what other bundles need to use.
This keep implementation details from leaking through the whole system.
In the Export-Package header, you should always specify the version of the exported package.
The following snippet shows the first line of the Export-Package header from the Spring ORM module manifest (notice the use of the version attribute):
The version value can be different for each exported package, but usually all the exported packages will share the same version as the owning bundle.
There are some exceptions, but this generalization covers most cases.
Import-Package and Export-Package are the most important headers to specify when OSGi-ifying libraries, but there are a few others to take note of, especially those used to identify a bundle.
In an OSGi environment, a library must be properly identified, because dependency resolution in OSGi builds on bundle-identity mechanisms.
We’ve looked at many manifest headers already, especially in chapter 2, so we won’t describe all of them again.
The following snippet (part of the Spring Core 2.5.6.A bundle manifest) shows these three manifest headers:
The other aspect of a bundle identity is its version, set with the Bundle-Version header.
The symbolic name and version tuple comprises the identity of your bundle: there can’t be two bundles with the same symbolic name and version number installed at the same time in an OSGi container.
Bundle-Name isn’t meant to be used directly by the OSGi platform but rather by developers, because it defines a human-readable name for the bundle.
Its value can contain spaces and doesn’t have to be unique (even though it should be, to avoid confusion)
Now that you’ve seen the theory behind the OSGi-ification of libraries, let’s discuss putting this into practice and see the different ways to convert a plain JAR file into an OSGi bundle.
Because the deployment unit in OSGi is the JAR file along with some metadata, the conversion boils down to carefully editing the MANIFEST.MF file.
We’ve already discussed the manifest headers, but we should not forget the specifics of the JAR packaging:1
For instance, lines can’t be longer than 72 characters and the file should end with an empty line.
Given these requirements and the sensitive needs of OSGi metadata, manually editing an OSGi manifest can end up being a nightmare.
A typo or extra space can break the manifest and be difficult to track down.
Take a look at the manifest of each module in the Spring Framework and imagine the daunting task of maintaining each manually.
Imagine doing this for a bunch of Java EE frameworks, like Hibernate or JavaServer Faces!
Manually editing manifests, without any support from tools, isn’t a realistic or desirable undertaking.
In the next section, we’ll discuss tools that can help you to reliably package your OSGi bundles.
You can’t deny that your life as a developer wouldn’t be the same without the tools you rely on every day.
You’ll also probably have strong opinions on tooling: developers should not become too dependent on their tools and should know exactly what these tools do for them under the covers.
Java and Java EE have a large set of tools, both commercial and open source: IDEs (for content assistance, debugging, and so on), build tools, continuous integration servers, and many more.
The good news is that OSGi tooling is getting better and better.
We’ll focus in this section on tools that can help you package Java libraries into OSGi-compliant JAR files.
We’ll adopt a progressive approach: we’ll start by using a command line tool, Bnd, and we’ll end up including the OSGi-ification process into a Maven 2 build.
The Apache Commons DBCP, the database connection pool library, will be our candidate library.
Bnd (http://www.aqute.biz/Code/Bnd) is a tool created by Peter Kriens to help to analyze JAR files and to diagnose and create OSGi R4 bundles.
It’s used internally by the OSGi Alliance to create OSGi libraries for the various OSGi reference implementations and Technology Compatibility Kits (TCKs)
Bnd consists of a unique JAR file but it can be used from the command line, as an Eclipse plug-in, or from Ant (yes, a JAR can be all of this)
You already know from chapter 3 that the Felix Bundle Plugin for Maven is based on Bnd.
Are there any other tools than Bnd? Bnd is arguably the most popular tool for packaging JARs as OSGi bundles, but OSGi tooling is getting more and more widespread.
The latest rival for Bnd is Bundlor (http://www.springsource.org/bundlor), a tool created by the SpringSource team to automate the creation of OSGi bundles.
In this section, we’ll use Bnd from the command line to OSGi-ify Apache Commons DBCP 1.2.2
So let’s get down to business! Download Bnd from http://www.aqute.biz/ Code/Bnd, DBCP 1.2.2 from http://commons.apache.org/dbcp/, and copy the two JARs into a working directory (both JAR files are also available in the code samples for this book)
You can’t convert a plain JAR file into an OSGi-compliant bundle without knowing a little about it.
It’s divided into sections, and we’re going to analyze the most important ones.
Bundlor follows a template-based approach, which consists of giving hints for the manifest generation in the guise of a property file (the same approach used by Bnd)
The use of Bundlor with Maven 2 is covered in appendix B.
OSGi also gets into your development environment: there has always been the Plugin Development Environment (PDE) in Eclipse (http://www.eclipse.org/pde/), which enables the development of Eclipse plug-ins and offers some nice support for OSGi (such as a dedicated editor for manifest files)
As SpringSource dm Server applications rely heavily on OSGi, STS offers some support for OSGi.
Why Apache Commons DBCP? Commons DBCP is a very popular database connection pool: Apache Tomcat uses it to provide its data sources, and a lot of applications embed a DBCP connection pool (often as a Spring bean)
Unfortunately, DBCP isn’t yet among the OSGi-ified libraries of the Apache Commons family.
The more interesting section is the one starting with [USES], which delivers information about the Java packages of the target JAR:
With this monolithic block of text, Bnd tells us that, with respect to the current classpath, some packages that our library needs to work are missing.
Indeed, Commons DBCP relies on the Commons Pool library to handle its pooling algorithm and adds a thin layer on top of it for database connections.
This dependency means that we’ll need to do two things in the OSGi-ification of Commons DBCP:
We can immediately start the OSGi-ification with Bnd’s wrap command:
Unfortunately, Bnd can’t guess the proper values for some important headers, and default values aren’t always appropriate.
That’s why Bnd uses a configuration file to supply this information: version, symbolic name, imports, and exports can be defined in a way that’s similar to the manifest format but more editor-friendly and more powerful, thanks to the use of variable substitutions and pattern matching.
The following snippet shows the Bnd configuration file for converting Commons DBCP into an OSGi bundle:
Where do the .class files come from? Bnd isn’t a traditional packaging tool; it doesn’t need as an input a directory containing .class files that it will compress in a JAR file.
It directly locates .class files in the classpath and packages them into a JAR file.
You can potentially include in your OSGi bundle all the .class files from the classpath you specified when launching Bnd from the command line.
Commons DBCP packages with the same version, to ensure a consistent class space.
The last wildcard refers to all the remaining packages used by Commons DBCP, and we mark them as optional.
If an element is matched twice, the first match always takes precedence.
That’s why the instruction to mark the dependencies as optional in our Import-Package header comes last.
Let’s issue the wrap command again, but now with the properties option, to specify the Bnd configuration file:
We can now look at the manifest file of the generated OSGi bundle.
Now you can compare the end result with the instructions we specified in the Bnd configuration file.
As you can see, Bnd is a very convenient tool.
We mentioned that we also need an OSGi-compliant version of Commons Pool, because Commons DBCP is built on this library.
Unfortunately, Commons Pool isn’t distributed as an OSGi bundle either, so we have to again do the conversion ourselves.
It turns out to be fairly simple, because we can follow the same process as for Commons DBCP.
Congratulations, you can now create database connection pools with Commons DBCP in an OSGi environment! But perhaps you’re fond of automation; we’ll look now at how to make the OSGi-ification part of a Maven build.
You met the Felix Bundle Plugin in chapter 3, where we used it to package our first Spring DM bundles.
We relied on Maven 2 to provision the Spring DM OSGi test framework.
The Felix Bundle Plugin provides integration between Bnd and Maven 2: the plugin uses Bnd under the covers, providing it with information from the POM file.
By using this plug-in, you can take advantage of all of Maven 2’s features (automation, dependency management, standard project structure, and so on) and still package your project as OSGi-compliant bundles.
The plug-in has reasonable default behavior, making the configuration simple for simple needs.
For the OSGi-ification of Commons DBCP, we start by creating a simple pom.xml file:
Notice how we clearly state that the project is our own distribution of an OSGi bundle:
Even if Bnd is wrapped in a Maven plug-in, it still bases its search for classes on the classpath, so we add Commons DBCP as a Maven dependency.
We do this inside the build tag (just before the dependencies tag), where we usually configure Maven 2 plug-ins.
Never omit the version of a plug-in with Maven 2 unless you want your build to break unpredictably.
All set! Any Maven packaging goal (install or package) will generate a 100 percent OSGi-compliant bundle.
OSGi-ifying a library and making the process part of a traditional build is fairly simple, thanks to the Felix Bundle Plugin.
You just need to be careful with the generated OSGi metadata, and Bnd will handle the rest.
We’ve now talked a lot about converting existing libraries, but what about packaging our own modules and applications? We’ll discuss this topic in the next section.
If you understand how to OSGi-ify existing libraries, making your own Java applications and modules into OSGi bundles should not be a problem for you.
You can apply all the OSGi-ification techniques we’ve covered so far to your own modules.
You can stick to Bnd, choosing the mechanism that suits you best:
Packaging existing libraries or your own modules as OSGi bundles should not cause you any trouble now.
It’s also about modularity, and without good design, you’ll have a hard time packaging your modules.
That’s why we’ll discuss how to design OSGi enterprise applications and how to leverage Spring DM in the next section.
Designing OSGi enterprise applications isn’t so different from developing “standard” enterprise applications: OSGi people don’t pretend that the world was waiting for them in order to write modular applications.
Nevertheless, anyone can learn from the strict modular approach of OSGi.
With plain Java, we can’t really encapsulate our classes and interfaces; they can be used as long as they’re on the classpath.
The standard deployment unit in Java, the JAR file, is a convenient kind of packaging, but Java doesn’t provide us with real dynamic deployment capabilities.
Web (WAR) and enterprise (EAR) deployment units usually end up being monolithic, hard to split entities; they’re too coarse-grained.
We, as enterprise application developers, have learned to get along with these pitfalls.
To see how OSGi can help to improve the design of a Java application, we’ll progressively transform a standard web application packaged as a monolithic WAR file into a modular web application.
Along the way, we’ll also see how to introduce Spring DM into our OSGi design.
Let’s start with a standard web application and reorganize it to obtain a truly modular, OSGi-compliant application.
Let’s focus first on libraries and frameworks; this is the first place where OSGi can help, because the WAR packaging has some pitfalls.
Web applications can embed these JAR files or let the application server provide them, as shown in figure 6.1
If the application server provides them, WAR files are smaller, and depending on the application server, the global memory footprint is also smaller.
This scenario, where the application server provides the libraries and frameworks, works well because both web applications depend on the same versions of the frameworks they use.
What would happen in figure 6.2, when the application server provides the libraries? Nobody knows.
Figure 6.1 Within an application server, web applications can embed their dependencies or let the application server provide them.
On standard Java EE application servers, applications have no standard way to indicate that they depend on a particular version of a framework; these kinds of metadata don’t exist in Java EE standards.
We could try to check the version when the application starts, but this would be cumbersome, especially if we had to do the check for all of the dependencies.
We could embed the libraries in the WAR (as shown in figure 6.3), but this could lead to unpredictable behavior, depending on the application server’s classloading strategy and the version of the WARembedded and server-provided frameworks: classes could be partially loaded from different JAR files, or frameworks could try to dynamically detect some libraries (Hibernate does that with Hibernate Validator)
Modules declare their dependencies, and the OSGi container is in charge of their resolution.
Designing OSGi enterprise applications don’t need to write our own checks; the platform does it for us.
If we fail to properly declare our module dependencies, shame on us.
The OSGi world is harsh, but in the end you’ll benefit from this.
Figure 6.4 shows how the two web applications can use the same libraries in an OSGi environment.
Applications declare their dependencies, and the OSGi container does the classloader wiring to the respective dependency bundles.
Figure 6.4 demonstrates a simple scenario, so let’s look at a more complex one, where applications don’t rely on the same versions of frameworks, and we still want to share the dependencies among modules.
Figure 6.4 In OSGi environments, modules explicitly declare their dependencies and don’t embed them.
Figure 6.5 In OSGi environments, different versions of the same modules can be deployed, and dependent modules declare which version they want to use.
Thanks to its sophisticated classloading mechanisms, OSGi supports this scenario out of the box: different versions of the same library can coexist in a container.
We’ve looked at dependencies, so let’s move on and see how we can organize our application.
Enterprise applications are usually organized as a stack of layers, where each layer has its own responsibilities and relies on the layer immediately below.
This layer organization encourages best programming practices, such as separation of concerns and unit testing.
The so-called domain layer is an exception: it represents business entities (customers, contracts, and so on), which mainly carry data across the layers.
As such, domain entities are used in all the layers.
How can we translate the layer concept into Java? We accomplish this by using the simplest constructs of Java—classes and interfaces—as shown in the UML diagram in figure 6.7
This is about the design; at runtime, we’ll need a little help from a lightweight container like Spring.
The next question is how to split our OSGi bundles, now that our design tells us more about our dependencies? The answer is the one we usually don’t like: it depends.
Domain-driven design versus the anemic domain model Saying that domain classes carry only data is a bold statement—they can also contain behavior in the form of business-oriented methods.
Layering applications is good, but, applied in a simplistic way, it can lead to poorly designed enterprise applications, whose structure becomes closer to procedural programming than real OOP.
This is especially true for the domain classes, which are then limited to data-transfer tasks.
Such a domain layer is commonly referred to as an anemic domain model.
Domain-driven design promotes rich domain models, where some parts of the business logic are embedded in the domain classes.
OSGi, layered applications, and domain-driven design can cohabit, but comprehensive coverage of these topics is far beyond the scope of this book.
Figure 6.6 Enterprise applications are layered, for a better separation of concerns.
OSGi static and dynamic features offer so much power that we have a choice of virtually unlimited combinations! Some combinations are good, but others should be avoided, so let’s see some guidelines.
The first tip when developing OSGi applications is to separate the static components from the dynamic components.
Static components are bundles that define APIs by exporting interface-based Java packages.
These bundles don’t contain a Spring application context (or a BundleActivator) and don’t register or reference any OSGi services.
Dynamic components are bundles that import Java packages from static bundles, provide implementations, and usually register OSGi services.
As this is a Spring DM book, these bundles are Spring-powered.
Figure 6.8 illustrates the pattern of splitting static and dynamic components.
Section 6.4, which deals with Spring DM and OSGi dynamic features, will explain just how using Spring DM is relevant to.
Figure 6.7 Layers communicate through interfaces to avoid being coupled to the underlying technology.
Only the domain classes are referenced from all the layers.
Now, let’s see how we can apply this pattern to our enterprise application.
This approach could be labeled the “So you want modularity” approach, and it’s shown in figure 6.9
The approach shown in figure 6.9 is the most flexible: you can update any part of your application, and other modules can be built on top of any of yours by importing your packages and defining other implementations.
Figure 6.8 Static parts of an application (such as the API) and dynamic parts (the implementations) should always be deployed in different bundles within an OSGi environment.
This helps the application to benefit from the dynamic features of OSGi.
Figure 6.9 Organizing bundles in the “So you want modularity” way.
There’s at least one bundle for each layer, and two bundles if the layer has an API and implementation classes.
One of the drawbacks of this approach is that you have to maintain of lot of bundles, usually as separate projects.
That approach gives us flexibility, but what if we don’t want or don’t need it? Perhaps exporting the packages of data access object (DAO) interfaces is useless, because what we’re really interested in is the business services.
Remember, OSGi is sometimes referred to as a service-oriented architecture (SOA) in a JVM.
We can still define the service API, but the implementation can hide its inner workings.
We can then reorganize our bundles in a simpler way and gather the service implementation and data access layer in the same bundle—the backend bundle.
Taking this approach doesn’t change the logical organization of our application, as it’s still a layered application; we just changed its physical organization.
The SOA approach is no less flexible than the extremely modular approach.
If DAOs and business services follow the same development and deployment cycles, there is no point in splitting them into different bundles.
We know now that the way we organize bundles is a question of balance.
We’ve mainly discussed how bundles are statically linked by their dependencies, but we haven’t considered how bundles communicate with each other using OSGi’s service layer.
In our enterprise application, Java packages can be shared between bundles because of the Export-Package and Import-Package headers in their manifests.
Nevertheless, Java packages aren’t enough; an application needs real Java objects to run, and these objects must be registered as services in the OSGi registry.
Spring DM will instantiate and wire beans in our bundles and register them in the registry based on declarations in the context file.
Figure 6.10 Organizing the bundles in a SOA way, the backend bundle hides its internal functioning.
We’ll see later that Spring DM will even handle OSGi’s dynamic behavior for us.
Let’s again take our extreme modular approach from the previous section and focus on the service dependencies—we’ll ignore dependencies related to Java packages for now.
The implementation bundles are backed by Spring DM and can easily register or consume services (see figure 6.11)
In this scenario, if other bundles need to use our DAOs, they can easily consume them, regardless of whether or not they’re Spring-powered bundles.
Remember that our OSGi services are created by the Spring lightweight container, and as such, they can benefit from dependency injection or AOP.
These are some of the benefits of using Spring DM.
It works in much the same way, but the backend bundle has a bigger Spring application context because it hosts DAOs and business services.
In this scenario, DAOs can’t be consumed by other bundles, because the only entry point is embodied by the business services.
The SOA scenario from the OSGi service layer’s point of view is shown in figure 6.12
Figure 6.11 Spring DM helps implementation bundles to share OSGi services.
Figure 6.12 The SOA approach implies fewer registered services and offers better encapsulation.
What should we remember about the way bundles communicate? Mainly that there is still no simple answer and that we need to find a compromise between what we want to offer and what we want to hide.
Generally speaking, we should only expose what is useful and is prepared to be used as a service: you should not let your system be compromised because a poorly written service isn’t used the way it was meant to be.
In any event, Spring DM will be your friend when it comes to registering or consuming services.
You’ll like Spring DM even more when you see in the next section how it helps you handle dynamic behavior in OSGi.
This dynamic behavior is specific to OSGi; it’s sophisticated and powerful but more complicated to deal with than static services.
Tracking services using plain OSGi is quite painful and error prone.
The best tool OSGi offers for this task is the ServiceTracker, which accomplishes a lot, but we want more! When using the ServiceTracker, we still need to write code, and we’re tied to the OSGi API.
Moreover, we have to write the same kind of tracking code over and over.
You saw in the previous chapter that with Spring DM you can register and consume services declaratively.
This looks static at first sight, but Spring DM handles all the dynamics for you, adopting a reasonable default behavior in most cases—default behavior that you can override.
In this section, we’ll discuss typical cases related to OSGi’s dynamic behavior and how Spring DM can help you deal properly and reliably with them.
These cases range from the appearance and disappearance of a service or collection of services to the dynamic update of your modules.
Spring DM’s support for referencing services comes in two flavors: individual, when you need only one service matching a given description, and collection, when you want to have all the services that match some criteria.
In enterprise applications, the individual case is the most common: a business service needs only one OSGi service implementing a given DAO interface.
Spring DM is able to transparently handle service appearance and disappearance for both individual and collections of service references.
When Spring DM’s transparent management isn’t enough, because you need to track services more carefully, Spring DM offers a simple POJO-oriented solution to react to the binding and unbinding of services.
We’ll also cover this topic, using a Swing application to illustrate it.
Let’s go back to our enterprise application, using the extreme modular approach.
This contact DAO is meant to be imported and used by business services, such as the contact business service, defined in another Spring-powered bundle:
In this scenario, there is only one OSGi service implementing the ContactDao interface, and it will be imported by the service.
If there is more than one, Spring DM will pick one by following a predetermined strategy.
If the choice doesn’t suit the business service, that’s too bad.
It should have given Spring DM enough information to pick the right service.
But what happens if there’s no OSGi service implementing the ContactDao interface? This could happen if the business service bundle is deployed in the OSGi container and the data access bundle isn’t.
In this scenario, Spring DM will figure out that the Spring application context of the business service bundle has a missing dependency, and it will defer the application context startup until the dependency is satisfied, which means when an OSGi service implementing the ContactDao interface is registered.
If this condition isn’t met after 5 minutes, Spring DM will throw an exception.
This is the Spring DM default behavior: references are mandatory, and all mandatory references must be resolved before an application context can start.
We covered how to change this default behavior in chapter 4, by using the timeout directive of the Spring-Context header.
This is reasonable default behavior, but what if the business service bundle doesn’t contain only the user business service but critical business services that need to be available as soon as possible? They would be unavailable because the user business service doesn’t have this unique dependency.
You can resolve this issue by making the reference to the contact DAO optional, by using the availability attribute of the reference tag:
Now the business service application context will start up even if there is no contact DAO available in the OSGi service registry.
The user business service delegates data access operations to the contactDao, so what happens if the user business service handles an incoming request and calls the contactDao? Well, nothing.
The call will block until a contact DAO service is registered.
This behavior makes sense: the overall system isn’t in a nominal state, and the missing dependency should not be missing for long, so we can wait until it appears.
All of this is handled by Spring DM, which injected a proxy into the user business service in place of the user DAO.
This proxy blocks when someone tries to call it, but as soon as the target OSGi service (the contact DAO, in this example) appears on the service registry, the proxy delegates all the calls to it.
So far we’ve been talking about startup, but services can appear and disappear after the OSGi container has been started.
Let’s imagine the container reached its steady state a long time ago and that the DAO service then disappears.
Any reference to it can be replaced on the fly if Spring DM finds a replacement for it.
Finding this replacement will depend on the filter the importing bundle declared when it imported the DAO and on the availability of a matching service.
As you can see, in the case of an individual service reference, Spring DM handles most of the dynamic behavior.
It does provide some opportunity for tuning, but the defaults should fit in most cases.
Let’s now discuss the case of a collection of service references.
We learned in chapter 5 that with Spring DM we can declaratively reference collections of OSGi services, thanks to the list and set tags of the osgi namespace.
Collections of services are interesting for the parts of an application that can be extended with additional services or for implementing observer-based patterns like the whiteboard pattern, where a central component (the whiteboard) periodically needs a snapshot of all the available services that meet some requirements (the listeners)
What can Spring DM do about the content of these collections when services appear or disappear?
It adds matching services to the collection, and when one of the services referenced in the collection is unregistered from the OSGi registry, Spring DM automatically removes the reference from the collection.
Indeed, Spring DM can’t track service appearances and disappearances and update collections that it doesn’t totally control.
This is good news: we can use our collections of service references as any other collections.
We usually use collections by iterating over them, using Iterators, but there’s one important thing to know when iterating over a collection of service references managed by Spring DM: even the Iterator is dynamic.
Imagine you start iterating over a collection of service references, and its content changes during the iteration because some services were unregistered and some matching services were registered.
With Spring DM, you’ll be aware of this immediately, because the Iterator will reflect these changes dynamically.
Thanks to Spring DM’s transparent dynamic management, we’re now well prepared to deal with the appearance or disappearance of services.
Nevertheless, the support for the dynamic side of OSGi would be incomplete if we could not easily track services and react accordingly.
In plain OSGi, the ServiceTracker is the Holy Grail for the developer who wants to track services.
But despite its unquestionable usefulness, the ServiceTracker implies the use of the OSGi API and needs to be registered programmatically, which means writing a BundleActivator.
This quickly becomes cumbersome, especially if we need to track services in many bundles.
We saw in chapter 5 that, when referencing a service (either with the reference, list, or set tags), we can attach a listener that will be warned when a matching service is registered or unregistered.
This can be done with the listener tag of the osgi namespace.
This is powerful, because an importing bundle can easily react to the appearance or disappearance of one or more matching services.
The next question is how do we deal with the generated events? Let’s take as an example a Swing program, the Paint application.
Hall, the founder of the Apache Felix project and co-author of OSGi in Action.
The Paint application is a Swing application that allows you to choose shapes from a toolbar and lay them on a painting area.
The different kinds of shapes are represented by the SimpleShape interface, which has several implementations: CircleShape, SquareShape, TriangleShape, and so on.
How Spring DM handles OSGi applications’ dynamic behavior user interaction and the drawing of the shapes, and a ShapeTracker tracks the different kinds of shapes available and notifies the DrawingFrame of their appearance or disappearance.
Figure 6.14 illustrates the design of the Paint application with a UML diagram.
The dynamic part of the Paint application rests in the availability or unavailability of shapes.
If a new shape implementation appears in the system, it should be automatically added to the toolbar.
Conversely, if a shape disappears from the system, it should be automatically removed from the toolbar.
Shapes can be seen as contributions to an extension point and are therefore good candidates for OSGi services.
We can easily infer the organization of our application as OSGi bundles, as shown in figure 6.15
If a bundle wants to contribute to the Paint application, it has to define an implementation of the SimpleShape interface and publish the instance in the OSGi registry.
The SimpleShape interface is an extension point, and implementations are then good candidates for being OSGi services.
The bundle of a SimpleShape implementation leverages the Spring lightweight container to declare the shape as a bean and Spring DM to export the bean to the service registry.
Here is an excerpt from the book’s code samples, which shows how to export the square shape implementation as an OSGi service:
The bundle of the Paint application is interested in SimpleShape services and wants to know when some are registered or unregistered.
It then uses the list tag to import SimpleShape services and the inner listener tag with the callback methods plugged into its ShapeTracker:
With this configuration, Spring DM calls the addingShape or removedShape method of the ShapeTracker when a shape service is registered or unregistered respectively.
The ShapeTracker will have to do all the dirty work, but OSGi dynamics are no longer part of its concern; it can focus on the update of the UI.
Here are the two callback methods, free from any reference to the OSGi API:
This means that the application will work properly and can be tested outside of an OSGi environment, which is very convenient.
Moreover, the application class (the ShapeTracker) is relieved of the burden of OSGi dynamics, because Spring DM handles most of the complex plumbing.
Shape services can appear or disappear, and the UI is updated on the fly, as shown in figure 6.16, where the square shape service has been removed from the registry.
The Paint application is the perfect example of using OSGi services as an extension mechanism.
With the dynamic features of OSGi and a little help from Spring DM, tracking services becomes easy, without any references to the OSGi API.
In the next section, we’ll continue with dynamics and see how Spring DM handles the updating of bundles.
One of the major features of OSGi is its capacity to dynamically update components, without stopping the container.
If we take our application in its extreme modular form, we can stop the DAO implementation bundle, install a new version, update the bundle, and restart it without redeploying or updating dependant bundles.
As you saw previously, if calls are made on the DAO service reference, Spring DM lets them block until it reappears, and as soon as Spring DM registers the new version.
It’s removed from the toolbar and drawn squares are replaced by “under construction” icons, all of this on the fly.
This is a common update operation, and the dynamic, on-the-fly service replacement works out of the box with Spring DM.
This is one benefit of following the pattern of splitting static and dynamic parts of an application.
How can you update a service like this? Let’s do it with Equinox.
You start by issuing the ss command to find the DAO implementation bundle:
As you can see, the DAO implementation bundle is bundle number 4 (shown in bold)
This is the point at which Spring DM blocks calls on OSGi services that were registered by the bundle and imported by Spring-powered bundles (the business service implementation bundle, for example)
You can then install a new version of the DAO implementation bundle and start it:
With Spring DM, the service update happens transparently, and dependant bundles don’t need to be restarted.
As soon as the new version of the bundle registers a contactDao OSGi service, Spring DM will send it the blocked calls, so that the waiting incoming requests can be processed.
A less common but still relevant situation is what happens when the DAO disappears but can be replaced.
This means that there are one or more OSGi services that can suit the importing bundles.
In this case, Spring DM will automatically switch to the next best replacement, observing the filters of the dependant bundles.
This kind of update works well for black-box components, meaning components that don’t export any packages and just provide services.
These are what we previously called the dynamic components of our OSGi applications.
But what about the static components of an application? In our DAO-based example, the static part is the DAO API, which the DAO implementation and service implementation bundles depend on.
Usually, if we ship a new version of the DAO API bundle, it will come with a new version of the DAO implementation and the service implementation bundles, which benefit from the API updates.
Simple update operations won’t be enough in this case, because implementation bundles need to be wired to the new version of the API bundle classes.
For this wiring to happen, you need to refresh the DAO API bundle, and the OSGi framework will handle the refresh of dependant bundles.
To summarize, when updating the DAO API bundle, we’ll have to go through these steps:
Stop the DAO API, DAO implementation, and service implementation bundles.
When updating an API bundle, the precise procedure is the hardest part, because.
Spring DM handles the Spring application context startup order, service registration, and importing.
If you carefully design and organize your OSGi application components, Spring DM will manage the complex technical jobs.
You should now have a good understanding of the right way to write OSGi-based enterprise applications.
More and more libraries and frameworks are packaged as OSGi bundles, but alternatively you can rely on OSGi repositories or handle the OSGi-ification yourself, building your own repository or even making your OSGi bundles available to the global OSGi-ification effort.
The second step is to properly design your OSGi applications and understand how to benefit from OSGi specificities.
If you’re on your own for the design, Spring DM is a great help for filling in the gap between OSGi and traditional application development.
It’s able to handle transparently most of the dynamics-related issues, and it allows you to retain a POJO-based development style.
We’ll continue with enterprise application development, as the next chapter is dedicated to a topic without which enterprise applications wouldn’t be the same: access to relational databases with Spring DM.
It implies updating, but also refreshing, dependant bundles to wire them with the new classes.
In the previous chapter, we showed you how to prepare third-party frameworks and libraries for use in an OSGi environment and how to organize the bundles of your enterprise applications.
You also saw that developing enterprise applications with OSGi is slightly different than for classical Java applications, especially with regards to data access.
Using the “open element in view” pattern, within OSGi applications with Spring DM Data access in OSGi with Spring DM.
In this chapter, we’ll focus on this last topic and describe how to implement data access components using standard Java technologies, such as Java Database Connectivity (JDBC) and Java Persistence API (JPA), within an OSGi environment using Spring DM.
OSGi has some constraints regarding the implementation of these technologies, and we’ll look at how to address them and the pitfalls to avoid.
The last subject we’ll tackle in this chapter is that of transactions.
We’ll see how to use Spring DM and the OSGi service registry to make transactions work smoothly.
It provides an abstraction that hides the specifics of interacting with different kinds of databases, and it allows you to specify SQL queries to get or update data.
Using JDBC within OSGi has particular constraints, especially with respect to the JDBC driver.
In this section, we’ll describe how to make JDBC work in OSGi and how to organize OSGi applications that use it.
The technology was designed to keep things simple and provide an independent way of interacting with databases.
It provides an abstraction over the specifics of different databases by using a driver to implement the actual communication with a specific database, as shown in figure 7.1
But JDBC doesn’t provide solutions to handle the specifics of SQL—this is left up to the client application.
The public API for interacting with databases is provided directly in Java SE within the java.sql package.
This package provides the key abstractions corresponding to connections, statements, result sets, and metadata, as listed in table 7.1
Listing 7.1 shows an example of using JDBC to execute a SQL select request from a Java application.
Connection connection = null; PreparedStatement statement = null; ResultSet resultSet = null;
Connection Corresponds to the connection to the database, allowing the execution of SQL requests and being responsible for handling local transactions.
Statement Corresponds to the core abstraction for executing all kinds of SQL requests.
PreparedStatement Corresponds to an advanced statement that supports precompiled SQL queries and parameter specification.
CallableStatement Corresponds to a kind of statement enabling you to execute stored procedures with JDBC.
ResultSet Allows for the parsing of data received on the execution of a SQL query.
ResultSetMetaData Provides access to metadata about the types and properties of the columns contained in a result set.
Listing 7.1 Using JDBC to execute a SQL select request.
Listing 7.1 shows a classic way of using JDBC to execute SQL requests for both querying and updating data.
We first obtain a JDBC connection B enabling us to create a statement to execute SQL requests C.
We create a JDBC prepared statement, allowing us to use a parameterized SQL request.
In our example, the request gets contacts whose names begin with the letter P.
We can then execute the request, get the corresponding result set, and iterate over it D to get data contained in its current line E.
Finally we need to release all the JDBC resources F.
An extension to JDBC is also available to provide additional support for server-side usage through the javax.sql package.
The more well-known interface of this extension is the DataSource interface, which corresponds to a connection factory and is commonly used by pool implementations.
The Spring Framework also provides implementations of the DataSource interface within its JDBC support.
We won’t discuss the details of JDBC any further, because it’s beyond the scope of this book, but we will concentrate on using it within an OSGi environment.
We’ll also look at how to use JDBC within enterprise applications when using Spring DM.
The underlying implementation of JDBC is the driver, which consists of the middleware between the Java application and the target database.
This driver is database-specific and implements communication protocols necessary to communicate with the database server.
The driver contract is specified in the JDBC specification through the Driver interface, as shown in the following snippet:
But what, then, is the issue with using JDBC in OSGi and Spring DM? The central class when using JDBC in common Java applications is the DriverManager class.
You’ve probably written code similar to the following snippet many times:
The driver class name is loaded using the static forName method of the Class class.
The driver can then be used to create a JDBC connection using the DriverManager class’s static getConnection method.
How does DriverManager know about the specific JDBC driver code? The driver automatically registers with the DriverManager class using a static code block in the driver’s implementation class.
The problem is that the DriverManager class uses classloaders in a specific way that can have strange side effects within an OSGi container.
To avoid this check, it’s better to not use the DriverManager class within an OSGi container.
The alternative is to use the driver interface directly to obtain a JDBC connection, as shown in the following snippet.
Note that Spring’s ClassUtils and BeanUtils classes can be used to safely instantiate a JDBC driver from within an OSGi container.
Moreover, when using a pool, you should ensure that it doesn’t use the DriverManager class.
The C3P0 library partially uses the DriverManager class to get a driver and then directly works with the returned class.
In this way, C3P0 uses classloaders correctly from the perspective of an OSGi container.
In the following sections, we’ll provide more details on configuring a JDBC data source from within an OSGi environment using Spring DM.
There are different strategies for managing JDBC connections within applications.
A DataSource supports provider implementations according to your required resource management strategy (direct use of driver, pools, and so on)
Applications, however, are completely independent of the chosen strategy, which can be varied according to the target environment (test or production), as shown in figure 7.2
You must choose which data source implementation you need according to your requirements.
If you aren’t in a multithreaded environment, implementations that manage or provide a single connection can be used.
Alternatively, for performance reasons, pools should be used to manage a group of preopened connections.
In this section, we’ll only describe the configuration of a pool within an OSGi environment using Spring DM.
Database connection pool classes need to see driver packages because the classes contained in these packages manage the connection resources.
By default, the components corresponding to the pools don’t have the correct OSGi package configuration in their JAR manifest entries.
During the packaging or OSGi-ification of the pool component, you can add optional import entries for each package for the possible drivers that you might use.
You can implement a fragment bundle that will add the package containing the driver class that’s used to the pool component’s manifest configuration.
This approach corresponds to the fragment configuration pattern described in section 3.3
The OSGi-ification of existing third-party libraries with Bnd is described in section 6.2.3
As we explained, you can use a configuration file to parameterize information that will be specified in the manifest configuration of the generated OSGi component.
We can add most of the JDBC driver packages as optional packages to the Bnd configuration file.
Only the drivers available at runtime in the OSGi container will be resolved.
A less intrusive way to configure driver visibility within pool components is to use the fragment configuration pattern by creating a fragment responsible for extending the Import-Package specification.
In the fragment, this header will only specify the package of the driver.
The fragment doesn’t have any content and only adds an Import-Package entry.
When using this version, you don’t need to add such a fragment, because the driver will be present in this classloader during the pool’s initialization.
Once the driver has been added in the pool component, we can focus on the data source configuration itself.
For OSGi, best practice consists of defining a dedicated bundle to configure the data source.
Within this bundle, Spring DM facilities can be used to configure a DataSource instance and register it as an OSGi service.
This service can then be referenced by data access components to interact with the database.
The C3P0 pool is configured as a simple bean within the Spring container.
Standard JDBC properties like driver class name, JDBC URL, username, and password are specified in this bean.
The driver class can be used because its package has been added to the pool component by using a dedicated fragment, as described in the previous section.
It allows you to gather configuration parameters into a property file.
This allows us to specify the properties file’s location in the classpath.
We can then configure the C3P0 pool using the JDBC properties of the configuration file C.
Finally, the pool must be registered as a service D in the OSGi service registry.
Because we’re in an OSGi environment, all the required packages must be added to the manifest configuration of the bundle, as shown in the following snippet.
We saw in previous sections how to use Spring DM to organize and configure JDBC data sources in an OSGi environment.
In the next sections, we’ll focus on how to provision the OSGi container to use Spring’s JDBC support, then how to use it with Spring DM.
At the JDBC level, nothing specific to Spring DM needs be added, other than its common components.
Table 7.2 lists the Spring components you need to add to the OSGi container along with the core Spring components to use Spring’s JDBC support within an OSGi environment.
You’re now ready to implement bundles that use the JDBC technology together with Spring and Spring DM.
In the previous sections, we described how to correctly initialize JDBC in an OSGi environment in order to follow OSGi best practice for bundle structuring and classloading.
We’ll now see how to build a Spring-powered bundle that relies on Spring JDBC support to access a database.
If you exclusively rely on ORM tools for you persistence layer, feel free to skip this section.
Spring JDBC support addresses this limitation by providing abstractions integrating all this complicated plumbing.
These classes provide a high-level abstraction over the JDBC API, which manages JDBC resources for you and allows you to concentrate on your application’s logic.
The support provides call-back interfaces that allow you to customize the behavior, and it also handles JDBC-specific exceptions by encapsulating them into unchecked, generic data exceptions with exception chaining.
We won’t describe this support in detail because books like Spring in Action by Craig Walls provide complete and in-depth coverage of Spring JDBC.
We will, however, show the basic use of Spring JDBC support through its JdbcTemplate class.
Let’s see now how to configure and use JDBC with Spring DM.
Referencing a data source is like referencing any other OSGi service—you use Spring DM’s service support and its reference element.
All data sources implement the DataSource interface and are registered under this interface, so the value.
If several data source services are available in the OSGi service registry, you must specify an expression for the filter attribute of Spring DM’s reference element to be sure you select the right one.
All of these data sources must be registered as services and have properties that makes it possible to distinguish them.
In the preceding snippet, the filter attribute specifies a custom source property to select the correct data source.
This data source can then be injected into your data access objects, just as you would do in a classic Spring application:
We’ve now correctly configured our beans by using Spring DM to reference the requisite data source in the OSGi service registry and injecting the data source into our DAO beans.
It’s time now to implement the beans using Spring’s JDBC support.
The JdbcTemplate class is the central class of Spring’s JDBC support.
This class encapsulates all the repetitive and error-prone logic of JDBC and makes it possible for you to concentrate on your own application logic.
Spring provides a convenient class for configuring this template, the JdbcDaoSupport class.
Having specified this class as the superclass for your DAO, you can inject an instance of type DataSource into your DAO and access a correctly configured instance of JdbcTemplate through the getJdbcTemplate method.
Listing 7.4 shows how to use this class with the ContactsDaoImpl class.
When using Spring’s JDBC support and the corresponding template, you need to specify all the required packages in the manifest configuration.
The following snippet shows the packages you need to specify for the Import-Package header in the bundle’s manifest file.
Once the JDBC template is correctly configured, you can use its methods to develop your DAO implementations.
We won’t discuss this further because this isn’t specific to OSGi and Spring DM.
To summarize, JDBC technology isn’t difficult to use within an OSGi environment when you have Spring DM.
The key enabler is the dedicated data source component, which makes the data source available as an OSGi service.
Although packages related to Spring JDBC support must be added in the manifest configuration, this support can subsequently be used in the same way as any classic Spring application.
When we look at implementing JPA, you’ll see that some parts of the configuration can be reused.
That’s because the Spring JPA support is based on a DataSource bean.
We’ll now look at another aspect of data access, namely how to use ORM technologies with Spring DM.
We’ll focus first on concepts of JPA that are specified in the Java EE 5 specification.
Although JDBC represents the foundations of data access using relational databases within Java applications (and OSGi applications), the technology has inherent limitations because you need to tackle different SQL dialects and convert between relational structures and object-oriented applications.
That’s why most complex enterprise applications don’t usually use JDBC directly but instead use transparent persistence through ORM tools.
In contrast to JDBC, which isn’t too hard to use with OSGi, ORM tools can be much more complex to implement.
Bootstrap packages The javax.sql package is provided by the OSGi container as a bootstrap package, which means that you don’t have to specify it explicitly in a bundle.
You can specify which of the packages already present in Java you want by setting your OSGi container’s configuration.
First we’ll discuss the key ORM concepts, then we’ll focus on how to use Java EE’s JPA within an OSGi container using Spring DM.
To that end, we’ll look at what loadtime weaving is, how you can use it within an OSGi container, and what its relationship is with JPA.
We’ll then look at the steps involved in making JPA work in an OSGi environment with Spring DM:
Provision the OSGi container You need to provision the OSGi container with the bundles needed by your chosen JPA implementation.
All of these components can be found in the SpringSource EBR.
Configure global packages in the OSGi configuration Having configured the JPA entities, you need to add the related packages to the OSGi configuration of the component.
This configuration is common to all JPA implementations, because it corresponds to client JPA and Spring JPA support APIs.
Implement DAO classes The next step is implementing JPA DAO classes using the configured entities and Spring’s JPA support.
OSGi environment for the chosen JPA implementations, such as the underlying mechanisms required to configure packages of classes used at runtime, and also LTW.
We’ll describe each of these steps in turn and concentrate on the specific issues that occur in an OSGi environment.
We’ll also look at what facilities are provided by Spring DM for using this technology in this context.
In this section, we’ll introduce the concepts of ORM technologies and how to use the Java EE ORM standard, the JPA.
We’ll give you everything you need to develop basic application logic using JPA.
If you want a more in-depth discussion of JPA, we recommend Java Persistence with Hibernate, by Christian Bauer and Gavin King (Manning, 2006)
Although any database-based Java application must rely on JDBC, there’s a structural mismatch between object-oriented applications, which are based on objects, and relational databases, which are based on rows, tables, and relations.
N+1 selects—When applications use entity relationships, a vastly different number of SQL requests can be executed (than when they don’t use entity relationships) depending on the chosen loading strategy.
Object graph handling—JDBC doesn’t provide an easy way to handle object graphs because you need to build this graph using data contained in result sets.
Object mapping—Entity mapping with table and inheritance support must be handled by the application.
They provide an abstraction above the SQL language so that applications can interact with relational databases using only the object-oriented paradigm.
It also has a conversational part, in which the lifecycle of entities is introduced through several states.
Transitions between these states allow the JPA engine to detect the operations that trigger the persistence context to be flushed or synchronized.
This context can be thought of as a first-level cache for the calling code.
In enterprise applications, this context is commonly associated with a transaction or a web request and is flushed at the end of each.
Note that the transition names are those specified in the JPA specification.
Figure 7.4 The general ORM architecture, showing that the ORM technology is based on JDBC and implements mapped classes and a persistence context for execution.
You’ll notice that entities that aren’t in the persistence context have no correspondence with the database.
Now that we’ve described the concepts of JPA, let’s see how to configure and use it based on its API.
Its aim is to provide a standardized layer so that ORM tools are merely specific implementations of this specification.
Table 7.3 JPA methods controlling transitions in the mapped object lifecycle.
Updates to these entities are automatically synchronized with the database on a flush operation.
All pending transitions on managed entities, except for loading, are done at this point.
The specification describes how to map managed entities to database tables and how to use JPA to interact with the database.
New features include the ability to use this technology outside of an Enterprise JavaBeans (EJB) container and to use local transactions instead of global transactions through the use of the JTA.
These are the main JPA implementations available in the open source community:
The recommended way to configure the mapping between objects and tables is to use annotations within managed entities.
A set of annotations is provided by JPA to map classes, properties, and different kinds of relationships and inheritance.
OneToMany(mappedBy = "contact",fetch = FetchType.EAGER, cascade = CascadeType.ALL) private List<Address> addresses;
Once mapping is complete, you need to configure the persistence unit by creating a persistence.xml file.
This file allows you to specify which classes to manage and the type of transactions the application uses, and it’s commonly located under the METAINF directory.
The following snippet shows a sample of a persistence.xml file:
Listing 7.5 Implementation of the Contact class using JPA annotations for mapping.
Once this configuration is complete, you can use the JPA API to interact with the database.
The EntityManager is associated with a persistence context and provides a set of methods to interact with it.
This interface is responsible for loading data and updating the states of managed entities.
Listing 7.6 shows how to use the EntityManager instance to store and access data.
The EntityManager allows you to interact with the JPA persistence context.
If you want to insert data contained in a Contact instance, you can instantiate and configure a plain Contact instance C.
In order to flush modifications back to the database, you need to validate the corresponding transaction D, which was started previously B.
If an exception occurs, the transaction is rolled back D.
Finally, we must close all resources we used as with JDBC.
This language allows you to query mapped objects with all their object-oriented features.
The JPA implementation is responsible for converting these queries to native SQL SELECT statements for the target database.
Listing 7.7 shows how to execute queries using the EntityManager interface.
In listing 7.7, having created an EntityManager instance, we create a Query instance from an object query string.
We then execute it and get the corresponding result list, which can be iterated through to access the data.
Next, we’ll describe how to use this technology in an OSGi environment with Spring DM.
We’ll start by explaining load-time weaving because JPA can use this technique to instrument managed classes.
Some JPA implementations have made the choice to use load-time weaving (LTW) to instrument managed entities.
Because LTW is tied to classloading, using it in OSGi can be tedious and depends on support from the underlying OSGi container.
We’ll start by outlining the main concepts, and then we’ll focus on how to use it inside Equinox and discuss which JPA implementations need this feature.
Without going into details, the term “weaving” refers to the way aspects are applied to the application code.
Compilation-time weaving—Java code is updated to add aspects before its compilation.
Several mechanisms in Java can be used to implement it:
The latter specifies how to transform classes and must be registered through the Instrumentation interface.
In this case, the ClassDefinition interface can be defined and registered through the Instrumentation interface.
Class enhancer tools—Such tools work by putting a proxy in front of instances to add logic around method execution.
This approach isn’t transparent to the application because it must use the tools’ API to obtain updated instances.
As you can see, LTW can be implemented in different ways and is usually tied to classloaders.
That’s why there are implications for its use in an OSGi container.
Moreover, there is no universal solution to the class instrumentation problem at the moment in OSGi because it would require updates to the OSGi specification itself.
In the following sections, we’ll describe how to use LTW with the Equinox container and Spring, and we’ll describe its interaction with JPA.
Be aware that LTW isn’t supported by all OSGi containers.
The Equinox Aspects tool is dedicated to leveraging AOP across all present OSGi components within an Equinox instance, and it enables LTW using the container’s hooks.
A dedicated project named Equinox Aspects allows you to use LTW and AspectJ within the Equinox container.
AspectJ is a tool that implements AOP concepts for Java.
It provides several ways to weave aspect in code including LTW.
Equinox Aspects takes advantage of the extensible nature of the Equinox Framework: the Equinox Framework adaptor hooks are responsible for handling internal mechanisms like classloading.
This feature allows you to hook into the framework through the hookable adaptor, which allows you to add extensions to insert additional functionality into the framework itself.
For example, ClassLoadingHook makes possible various classloader extensions, most specifically bytecode weaving.
These fragments aren’t considered regular bundles because they must be discovered before the platform is launched.
To use Equinox Aspects, the components listed in table 7.4 must be present within your Equinox container.
Equinox Aspects is a powerful tool that can used to weave aspects into components with AspectJ.
Because the workings of Equinox Aspects are outside the scope of the book, we won’t delve any deeper.
Instead we’ll concentrate on how it can help us in using JPA with Spring DM in an OSGi environment.
The support follows the style of AspectJ (despite it not being tied to this framework)
The main difference consists in the ability to apply LTW to only one specific classloader instance (as opposed to applying it to every classloader in a JVM process)
Because the support is open and interface-driven, Spring comes with several built-in implementations, and you can choose the best one for your needs, such as the best one for the application server you use.
As OSGi has a specific way of using classloaders, none of Spring’s built-in LTW implementations are quite suitable for OSGi.
We need an implementation dedicated to Equinox (based on Equinox Aspects) enabling instrumentation of classes through all components in OSGi.
You can also use the load-time-weaver element of Spring’s context XML namespace to register this implementation, as shown in the following snippet.
You now have LTW enabled within our Equinox container, so you’re able to use JPA implementations that rely on it.
Let’s focus on using this support in an OSGi environment with Spring DM.
First, you need to provision the container according to the JPA implementation that you use.
Before being able to use Spring’s JPA support, you need to provision the OSGi container with the necessary components.
These include common components for Spring JPA support and JPA implementation components and their dependencies.
All bundles referred to here come from the SpringSource EBR.
At this level, nothing specific to Spring DM needs to be added to the OSGi container.
Table 7.5 lists the components that need to be added to the OSGi container in order to use Spring’s JPA support.
In addition, you need to add components related to JPA implementations and their dependencies.
We’ll describe the provisioning for the three main JPA implementations: Hibernate JPA, OpenJPA, and EclipseLink.
As a result, you need to provision your container with OSGi-ified versions of both the Hibernate bundles and their dependencies.
You also need to add the Hibernate JPA bundles listed in table 7.6
These components require a large set of dependencies to work; dependencies that are inherited from Hibernate itself.
Table 7.7 OpenJPA bundles and their dependencies from the SpringSource EBR.
Table 7.6 Hibernate JPA bundles and their dependencies from the SpringSource EBR (continued)
Like Hibernate JPA, OpenJPA requires a set of dependencies that must be present in the OSGi container in order to work correctly.
EclipseLink requires two bundles with two external dependency packages for its use.
Having provisioned the container, you’re now ready to implement bundles that use JPA with Spring and Spring DM.
We’ll first describe the generic way to configure and implement DAO components using the JPA, and then we’ll look at specific OSGi configurations necessary at runtime.
We’ve now covered all the issues with using JPA in an OSGi environment, and you have correctly provisioned your container according to your chosen JPA implementation.
You can now implement your bundle logic using Spring JPA support.
In much the same way as Spring provides JDBC support, Spring provides support for JPA technology that simplifies the use of this technology.
It provides a thin layer over the JPA API and transparently manages resources.
We’ll first describe how to configure and use this support, and then we’ll discuss the issues involved in using JPA in an OSGi environment.
Table 7.8 EclipseLink bundles and their dependencies from the SpringSource EBR.
This makes it impossible to use this abstraction in an OSGi environment, because data sources are registered as OSGi services.
It allows you to inject a data source and specify a chosen JPA implementation.
Implementations of this interface can be injected in this class to select the JPA implementation to use.
Built-in implementations of this interface are listed in table 7.9
This bean can either be defined in the same application context or retrieved from the OSGi service registry, as we saw in section 7.1
This allows us to inject necessary beans and specify properties C.
The configuration of JPA continues with the specification of the JPA implementation and of the persistence.xml file to use.
We then configure the Hibernate JPA implementation D by specifying some properties E, like the target database and by activating traces for the generated SQL queries.
You need to specify in the manifest configuration all of the packages used.
Some correspond to the JPA API; others correspond to Spring’s JPA support and are common whatever the implementation used.
The following snippet shows the packages you need to specify in the Import-Package header in the component’s manifest file:
Vendor adapter configurations can also require specific classes, depending on the chosen JPA implementation.
In that case, additional packages must be added to the manifest configuration.
We’ll describe the specifics of JPA implementations in section 7.2.5
After configuring JPA in your bundle’s manifest file and Spring configuration files, you can use the central class of Spring’s JPA support, the JpaTemplate class, in your DAO implementations.
This class allows you to implement all your data access logic by providing an abstraction layer over the JPA API.
Spring’s JPA support provides the JpaDaoSupport class as a base class for all DAOs using the JPA technology.
Listing 7.9 shows how to use this abstraction with the ContactsDaoImpl class.
Once the JPA template is correctly configured, you can use its methods, which closely follow those of the EntityManager interface.
The following snippet shows how to configure the ContactsDaoImpl class:
But, because each JPA implementation uses slightly different mechanisms internally, some configuration specific to the implementation must be done for bundles using them, both in the manifest configuration and Spring configuration files.
In previous sections, we described the general concepts and configuration necessary to use JPA in an OSGi environment with Spring’s JPA support.
Although JPA is a specification, specific implementations can have their own requirements for configuration and use.
These requirements may have more impact in an OSGi environment, depending on the way they manage classloading and proxies for managed entities.
These are the requirements when using JPA in an OSGi environment:
Visibility of mapped classes—When configuring JPA implementations at runtime, the mapped classes must be visible.
Automatic discovery of mapped classes—JPA implementations provide support to autodiscover mapped classes.
This feature has implications when used within an OSGi environment.
LTW—JPA implementations require or have the option for load-time class instrumentation.
This feature has a big impact on components and the OSGi container itself, especially when using LTW.
Specific OSGi imports—In addition to the common packages described in section 7.2.4, packages must be specified according to the chosen JPA implementation.
We’ll also describe how you can make the three main JPA implementations work in an OSGi container with Spring DM and Spring’s JPA support.
Spring DM is smart enough to make these classes visible to components of the JPA implementation.
Another class visibility issue occurs when using classes enhanced (decorated) by the JPA implementation.
These classes will obviously depend on the chosen JPA implementation and we’ll detail each in the following sections specific to each implementation.
Moreover, some JPA implementations try to autodetect classes through classpath scanning for the Entity annotation.
In an OSGi environment, this feature can cause exceptions, as shown in the following snippet:
This happens because inspecting JAR files in OSGi doesn’t work the same way it does in classic Java applications.
As a matter of fact, this inspecting is based on URLs using the bundlesource protocol.
Because this isn’t handled by all JPA implementations, the JPA implementation may not be able to browse the contents of a component.
Best practice is to deactivate this feature and to explicitly define which classes must be used by the JPA implementation.
This can be done in the persistence.xml file, as shown in the following snippet:
As stated earlier, some JPA implementations need LTW to work properly, and this can be the biggest problem when using JPA in OSGi.
We described LTW in section 7.2.2, and we’ll see in the next section how to configure it with JPA.
Depending on the JPA implementation used, additional packages must be added to the manifest configuration file of the components.
This configuration is described in the following sections discussing specific implementations.
Strange behavior can also sometimes occur when using JPA implementations within an OSGi environment.
Adding a select clause solves the problem, as shown in following snippet:
This isn’t an obvious solution at first sight! This problem seems to be a bug caused by the use of Hibernate JPA in an OSGi environment.
The JPA specification defines the contract for class transformation through the ClassTransformer interface.
This interface must be implemented by persistence providers that want to transform entities and managed classes at class load time or at class redefinition time.
This feature isn’t mandatory, and implementations are free to use or ignore it.
Hibernate JPA—Doesn’t require LTW because the implementation provides a ClassTransformer implementation based on Javassist.
OpenJPA—Leaves the choice to the application about whether or not to use LTW.
If this registration is successful, LTW is enabled; otherwise it’s not.
Spring enables you to integrate ClassTransformer entities into its generic LTW support when their use is required for a JPA implementation.
To use this support, you need to configure the LTW implementation that you want to use.
As emphasized in the previous section, the Hibernate JPA implementation doesn’t use LTW to instrument managed entities.
Instead, the framework uses Javassist to manipulate Java bytecode on the fly.
The following snippet shows the packages that need to be added:
This package must be added to the manifest configuration of the bundle whose classloader corresponds to the context classloader.
Because OSGi doesn’t explicitly set the context classloader, Spring DM’s context classloader support can be used to address this issue by setting it on the service that exports the DAO entity.
Like Hibernate, OpenJPA requires you to set additional packages in the manifest configuration.
Moreover, you need to add some other packages related to the instrumentation runtime of mapped classes for both proxy-based and LTW strategies, as shown in the following snippet:
This ends our tour through the intricacies of using JPA with Spring DM.
Unlike the use of JDBC, using JPA in an OSGi environment can be quite tedious.
The technology implements several advanced concepts to overcome the structural mismatch between object-oriented applications and relational databases, and this comes at a price when using it in OSGi.
LTW—Configure LTW if needed by the JPA implementation or if you want to use it and your JPA implementation allows it.
In the Equinox container, LTW requires the use of Equinox Aspects and its integration with Spring’s LTW support.
Specific OSGi imports—Specify all the additional packages in the Import-Package header for the chosen JPA implementation.
These packages correspond to hidden classes used at runtime by implementations.
Having described the use of several data access technologies in an OSGi environment with Spring DM, we now need to address the associated issue of using transactions.
By using Spring data access support, we’ve already included support for transactions (in the shape of the Spring Transaction module), so we only need now to configure it.
It consists of managing transactions declaratively using AOP or annotations, and it can be used with a large set of data access technologies, including JDBC and JPA.
Moreover, all the required resource management is directly integrated into the corresponding Spring templates, which makes the demarcation of transactions transparent when using Spring’s data access support.
In this section, we’ll describe how the transaction support works and how you can set up and configure Spring transactional support for JPA in an OSGi environment with Spring DM.
We won’t cover JDBC here because its configuration is relatively straightforward.
Spring’s transactional support consists of two main parts for managing transactions on beans that are managed by the container:
This mechanism is directly integrated into Spring’s data access support and is based on a transactional context stored in a variable of type ThreadLocal.
Transaction demarcation—This allows you to apply transactions to application logic.
Although an API is available, Spring also provides features to declaratively apply them to Spring-managed beans through AOP and annotations.
The commit method successfully finalizes a transaction; the rollback one cancels it.
Implementations of this interface are provided for each data access implementation in Spring.
These implementations are commonly based on factories for the corresponding technology (because they must be able to access resources to manage transactions), or, in the case of JTA, on the Java transaction manager.
With respect to transaction propagation, Spring defaults to transactions being REQUIRED on beans, which allows application components to participate in the current transaction or to create it if it doesn’t exist.
In addition, Spring introduces read-only transactions, which can help improve performance in ORM tools.
We won’t discuss the generic use of transactions any further here.
You can configure transactions in Spring by following these steps:
Create and configure all your POJOs in the Spring container.
They will correspond to abstractions for data access, DAO entities, and business services.
Configure a transaction manager bean, whose implementation depends on the underlying persistence technology.
Apply transactional behaviors to business services using either XML or transaction annotations.
The last point can be implemented in Spring by using Spring AOP support and a dedicated transaction XML namespace, as shown in listing 7.10
Another possibility is to use the Transactional annotation to specify transactional behavior directly in interfaces and classes.
Information specified on interfaces is automatically used in corresponding implementations and can be overridden if necessary.
The annotation can be specified both at the class level or method level.
At the class level, it provides global configuration for all methods, which can then be overridden if another configuration is required.
The following snippet shows how to specify transactional behavior using the Transactional annotation.
Transactional annotation support isn’t activated by default and must be enabled through the annotation-driven element of Spring’s tx namespace, as shown in the following snippet:
We’ll discuss annotation-based support in the following sections because it’s easier to use.
When using local transactions, the transaction manager implementation depends on the underlying data access technology, whereas for global transactions Spring provides a specific implementation that interacts with the underlying JTA transaction manager (which is usually hosted by an application server)
We’ll describe here only the local transaction approach and use the annotation-driven method of configuring transactions.
We can identify two use cases for configuring transaction management, depending on the organization of bundles within an application:
Because you need a transaction manager to apply transactions to services, this must be registered as an OSGi service.
The service component is then able to reference and use it.
In the first use case, bundles are autonomous, containing both services and DAO entities, and they embed their own transaction managers.
Transactions are managed within these components, and transactions are already applied to entities registered as OSGi services.
In the use case where services and DAOs are separated, the Spring transaction manager can be provided as an OSGi service to a service component by the DAO component.
In the service component, this service is used to apply transactions to services.
Figure 7.7 depicts this organization and shows the interactions between these components.
That makes this service independent from the underlying data access technology.
The following snippet shows how to register the transaction manager as an OSGi service from the DAO component:
The following snippet shows how to use the transaction manager to apply transactions to the service component:
Here the transaction manager is provided as an OSGi service and is then used in the configuration of Spring’s annotation-based transaction support.
Because Spring transactional support requires more classes than just the transaction manager, new packages must be added in the manifest configuration for bundles that decorate their beans with transactional behavior.
Once all this is configured, you can apply transactional behavior directly within classes and interfaces to specify which methods are transactional, how they behave in the presence of an existing transaction, and whether their behavior is read-only.
We saw that Spring provides the Transactional annotation for describing transactional behavior.
A good practice consists of using this annotation on service interfaces.
All the implementation classes will then directly benefit from the definition of transactional behavior at the interface level.
It’s now time to look at a different aspect of transactions.
In the next section we’ll look at how to implement the “open EntityManager in view” pattern, which consists of extending the scope of ORM sessions to the web layer.
Using ORM tools can induce some problems, especially when building views such as JSP pages, because some parts of managed entities can only be partially loaded.
One solution used by ORM tools to improve performance is to lazily load entities, by using an on-demand approach.
This optimization becomes a problem when we need to use data that hasn’t been loaded, but we’re out of the scope of the ORM session.
In fact, by this point the session has already been closed at the level of the service.
The open element in view pattern (where the element is EntityManager in JPA) exists to address this problem.
In this section, we’ll describe the concepts behind this pattern and how to set it up and use it in an OSGi environment using Spring DM.
The open EntityManager in view pattern is useful; every ORM framework makes it possible to lazily load entities during view construction.
To do so, you need to keep hold of the EntityManager instance that loaded the entity.
If the associated EntityManager instance is closed when using lazy loading on an entity, you’ll encounter some exceptions, as shown in the following snippet using Hibernate:
The end of this error message specifies that the error occurred because the associated session was closed.
With Spring, the lazy loading is tied to its resource management within its data access support.
According to the data access configuration, Spring is responsible for obtaining and releasing the underlying resources of the JPA implementation.
This implies that the scope of the resource transparently changes.
These are the impacts on resources scope in two use cases.
Transaction applied on service methods—Spring obtains an EntityManager instance and uses it for all the nested calls within the service method logic.
The resource is obtained before the call of every service method, stored in a variable of type ThreadLocal, and released when the service method exits.
As you can see, using lazy loading of entities instrumented by the ORM tool after calling transactional services isn’t possible because these entities are outside the scope of transactions.
As a matter of fact, the underlying resource is closed after the service method returns.
This isn’t particularly convenient because applications commonly use entities managed by the ORM within their UI after service calls, and they can’t generally load data lazily, according to their needs, as shown in figure 7.8
The Spring Framework provides implementations of the open element (or EntityManager) in view pattern for each of the supported ORM technologies.
Components using the open EntityManager in view pattern and data access components are typically separated, because the former implement the UI of applications.
The web filter implementing the open EntityManager in view pattern can then be configured in the web.xml of the web application, as follows:
After performing this configuration, your web application can lazily load data to build its views.
To summarize, the open EntityManager in view pattern provides a workable solution to using lazy loading in JPA.
Components using this pattern are then tied to the underlying technology both through the service type and by the packages needed in the manifest configuration.
Implementing data access components is complex even in regular Java applications, and it requires avoiding a lot of potential pitfalls.
Components need to be specifically organized, and some components, like pools, need to be extended to allow them to see the JDBC drivers.
The more complex the technology used, the more numerous the issues to address.
Once you’ve correctly configured drivers, pools, and data sources, using JDBC with Spring DM is straightforward.
If you decide to use Spring’s JDBC support with Spring DM, you need to provision the container with the related bundles and then import the packages corresponding to JDBC and Spring JDBC you want to use.
When developing enterprise applications, using JDBC alone isn’t sufficient in most cases because of the mismatch between object-oriented applications and relational databases.
Using ORM tools is a good solution to this problem, but it can be tricky to implement because the logic of such tools is much more complex.
They commonly use class instrumentation to transparently manage mapped entities, but what is completely transparent to classic Java applications isn’t at all transparent with OSGi.
The classes used must be visible to the component, and these classes are often difficult to determine beforehand.
But with a few hints, using JPA with Spring DM turns out to be much less difficult than you might have expected.
Finally, transactions aren’t difficult to implement in an OSGi environment, but they can require the sharing of resources using the OSGi service registry, depending on how your bundles are organized.
In the next chapter, we’ll tackle one of the main aspects of enterprise applications: implementing the web layer.
We’ll show you how to use servlet and JSP technologies with Spring DM, and how to use web frameworks like Spring MVC, JSF, and GWT to implement real web applications.
We’ll also describe how to connect these kinds of components to the data access components described in this chapter.
In the previous chapter, we described how to use data access technologies such as JDBC and JPA with Spring DM to handle data for non-OSGi applications.
In this chapter, we’ll focus on another aspect of enterprise applications: developing web components.
Although Java EE provides servlets and JSPs (JavaServer Pages) to address these issues, using them on their own is generally considered tricky.
Taking advantage of Spring support for these frameworks to make using Spring DM simple Developing OSGi web components with Spring.
When implementing web bundles with Spring DM, these issues—and their solutions—are largely unchanged.
The key is knowing how to use web frameworks in an OSGI environment and how to integrate them with Spring DM.
In the following sections we’ll describe how to integrate Spring DM with various web technologies and frameworks to create web UIs or expose web services.
We’ll describe each in the context of the framework family they belong to:
For each, we’ll explain how to optimize their integration with Spring DM.
Action-based web frameworks are responsible for selecting the appropriate actions to handle requests.
Actions are responsible for extracting parameters from requests, executing the requests, and building responses.
Most frameworks of this kind provide integration with Spring and can also use Spring DM in an OSGi environment.
In this section, we’ll look at the general concepts of how to integrate such frameworks with Spring DM and how to do this integration using Spring MVC.
The central entity of action-based web frameworks is the action entity.
This kind of entity is responsible for handling requests and executing functionality based on the requests, typically by using external components.
Integrating Spring DM with action-based frameworks involves using OSGi services, configured through Spring DM, in action implementations.
When configuring Spring support for this kind of framework, there are two main steps:
Specify the OSGi web application context from Spring DM to use the osgi namespace.
This allows you to define and reference OSGi services from within Spring application contexts.
Inject OSGi services configured through Spring DM info the actions of the application.
This can be done using classic or annotation-based dependency injection.
Figure 8.1 shows the integration of action-based web frameworks with Spring DM.
By using Spring DM’s OSGi-aware web application contexts and its service support, we can reference business services from actions.
That’s the general concept behind integrating Spring DM with action-based web frameworks.
Now let’s take a detailed look at how to implement this concept using Spring MVC.
Spring MVC is an action-based web framework shipped with Spring itself.
It takes advantage of dependency injection and annotations to implement and configure the MVC 2 pattern.
Spring DM can be used easily with Spring MVC by taking advantage of the extensibility of Spring application contexts.
This feature allows you to specify OSGi-aware application contexts from Spring DM.
In the following sections, we’ll describe how to configure Spring MVC for Spring DM, how to use an OSGi service configured with Spring DM within a Spring MVC controller and how to display data returned from an OSGi service in a JSP page.
We know this may sound confusing, but in the next section we hope to clear things up.
Spring MVC is part of Spring itself, and, like other parts of the framework, it’s available as OSGi components directly in the Spring distribution.
Some additional components need to be present in the OSGi container if JSP and JSTL are used.
Table 8.1 shows all the components necessary for installing Spring MVC in an OSGi container and using it with JSP and JSTL views.
Figure 8.1 Using OSGi web application contexts and OSGi services based on Spring DM from action-based web frameworks.
The model corresponds to the data to be displayed, and the view to the UI.
The controller intercepts user requests, executes business services, and then forwards the results to the view.
Although this pattern is convenient, it can be cumbersome to implement.
That’s why a new version has been developed based on a controller called the front controller, which is responsible for forwarding requests to the right handling entity.
The rest of the pattern remains as it was before.
All current Java web frameworks base their implementations on the second version of this pattern.
To install Spring MVC, all these components need to be provided to the OSGi container.
Once you have Spring MVC installed in the OSGi container, the next step is to configure the framework to use it with Spring DM.
Spring MVC uses two Spring application contexts for its configuration.
The first one corresponds to Spring MVC’s association with the web application; it’s.
If you’re using Spring DM, this context is also where you’d put OSGi service references to business services.
This class must be set with the listener XML element D in the web.xml file.
The behavior of this listener can be configured using context parameters.
The other Spring application context corresponds to the Spring frontend controller, the DispatcherServlet.
This context is a child context of the web application context, and it has access to all artifacts configured in its parent.
We can also use Spring DM at this level to reference services by specifying an OSGi-aware application context class.
Listing 8.2 shows how to configure the DispatcherServlet by using the contextClass init parameter of the DispatcherServlet class in the web.xml file.
The configuration of the DispatcherServlet servlet consists of two parts.
The first part involves the configuration of the servlet properties using the servlet.
Here we can specify the servlet’s name, its class name, and its init.
The second part is the configuration of the servlet mapping, by using the servletmapping XML element D.
In our example, their URLs must end with the .do string.
This combination allows us to use OSGi services in the MVC framework.
We’ll now deal with implementing Spring MVC entities that use services configured with Spring DM.
The programming model for version 2.5 of the Spring Framework has changed: it’s based on using annotations to define and configure MVC controllers.
Because Spring DM provides annotation-based support for referencing OSGi services, this approach should be preferred (over the XML-based approach) when implementing MVC controllers.
In fact, everything will be configured using annotations within controllers.
Listing 8.3 shows how to configure Spring MVC with annotations for both Spring and Spring DM and how to specify a view resolver based on JSP.
The first line of code uses Spring’s component-scan XML element B to specify in which packages Spring will find Spring MVC annotated controllers.
The last XML element in listing 8.3 configures the Spring MVC view resolver to find the right view for a view identifier.
For simplicity, we’ve configured a JSP view resolver D in order to use JSP for our views.
Spring MVC builds JSP URIs based on the view identifier and then forwards request handling to the corresponding JSP resource.
With this configuration done, we can implement our controller classes.
As emphasized previously, Spring MVC uses an annotation-based programming model for parameterizing controller properties.
Annotations allow you to define a class as the controller and specify rules for accessing it with HTTP.
For controllers that want to use OSGi services for their processing, Spring DM’s annotation support can be used to follow the same programming model.
Listing 8.4 shows how to use these different kinds of annotations within a controller implementation.
The first annotation defines the Controller B, which specifies that the ContactsController class is a Spring MVC controller.
A RequestMapping annotation D is associated with each method of the class to specify that they’re entry points for the controller.
We also specify the URI to access these entry points.
The OSGI service that’s used must be defined as a property C in the class with a corresponding setter method, and the ServiceReference annotation must be specified on this setter method to let Spring DM transparently inject the corresponding OSGi service instance.
The instance can then be used to request processing using the service E and, in our example, get a list of contacts.
Only a few packages need to be added to the Import-Package header of the bundle’s manifest file.
Let’s now look at how to implement a Spring MVC view based on JSP and JSTL.
It provides a standard tag library for common tasks in JSP pages.
When using this technology in an OSGi environment, some packages need to be added to the Import-Package header of the manifest file.
These packages are related to servlet, JSP, and JSTL extensions and also to the specific JSTL implementation, in our case the one from Apache.
Listing 8.5 shows the specification of these packages in the web bundle’s manifest file.
With these packages loaded, we can use JSTL within our JSP pages to display information we obtain from calls to OSGi services referenced using Spring DM facilities.
Listing 8.6 shows how to initialize JSTL in JSP pages and which tags to use for iterations and for printing information contained in objects.
The first step in listing 8.6 consists of specifying the core tag library for JSTL B.
Thereafter, we can print the contact list using the forEach tag to iterate through the list and the out tag to print the contact information C.
Listing 8.6 Implementing a JSTL view in a JSP file.
As you’ve seen, configuring and using Spring MVC within an OSGi environment with Spring DM is easy because Spring MVC uses the extension capabilities of Spring application contexts.
Using existing OSGi services from web UIs in this way helps to improve application modularity.
Another kind of web framework uses a component-based approach on the server side to implement the MVC 2 pattern.
Spring DM can be integrated into such a framework so that managed entities can get OSGi services configured by the framework.
Component-based web frameworks, unlike action-based frameworks, use an eventbased implementation and have the ability to attach functionality, located on the server, directly to UI components.
Based on specific request-handling lifecycles, frameworks call the attached methods of managed beans on the server to obtain data and execute operations.
Most frameworks of this kind provide integration with Spring and can therefore use Spring DM in an OSGi environment.
In this section, we’ll discuss how to integrate such frameworks with Spring DM and then look at some examples using the most popular of these frameworks: JSF and Wicket.
These frameworks are useful if you want to implement the MVC pattern on the server side using a component-based approach.
The key abstractions of action-based web frameworks are the managed entities and components, which allow you to implement server representations of web UIs and to handle events and actions on the server side.
Integrating Spring DM with such frameworks is simply a matter of using the Spring DM-configured OSGi services within managed components.
When configuring Spring support for component-based frameworks, Spring DM’s OSGi web application context must be specified in order for you to use Spring DM’s osgi namespace.
Using this namespace allows you to define and reference OSGi services in Spring application contexts, which is the first step in integrating Spring DM and component-based frameworks.
The second step involves injecting OSGi services configured with Spring DM into managed entities or components of the application.
This can be done using either classic XML-based or annotation-based dependency injection.
Figure 8.2 illustrates integrating component-based web frameworks with Spring DM.
You can use OSGi-aware Spring DM web application contexts and Spring DM’s service support to reference business services from actions.
The integration of these Spring DM features is based on framework extensibility features.
Having described the general concepts behind integrating Spring DM with component-based web frameworks, we’ll now detail the implementation of these concepts using JSF and Wicket.
JavaServer Faces (JSF) is part of Java EE and provides a server-side component-based framework for implementing the MVC pattern.
It’s intended to simplify the development and integration of UIs with their corresponding business entities and services.
The request-handling lifecycle manages an in-memory UI representation and calls user entities as appropriate.
Several implementations, such as the JSF reference implementation (RI) and MyFaces, are available as open source projects.
The integration of JSF with Spring DM is based on the JSF support provided by Spring itself.
This support uses the Spring web application context and enables the configuration of JSF user entities directly in the application context.
In the following sections, we’ll describe how to configure JSF in an OSGi environment and how to use Spring DM to process JSF-managed beans.
We’ll use the MyFaces JSF implementation to show you how to integrate Spring DM with JSF.
The first step is to provision the OSGi container with the necessary bundles.
The SpringSource EBR provides almost all you need to use the MyFaces framework in an OSGi environment.
MyFaces requires a large number of dependencies, as shown in the repository.
Table 8.2 Bundles required to use MyFaces, available from the SpringSource EBR (continued)
We said “almost” previously because an error occurs when trying to use the provided MyFaces bundles.
We need to patch the framework to make it work in an OSGi environment with Spring DM.
When using Tomcat 6, a configuration fragment is required to properly configure the web container for serving JSPs.
The implementation of this fragment is described in section 9.4.2
The bundles required by version 2.5.6 or later of the Spring Framework also need to be added to the OSGi container.
Once MyFaces is installed, the next step is to configure it to use it with Spring DM.
But configuring these references requires the use of a Spring application context that supports OSGi concerns.
The configuration within the web.xml file is the same as the one shown in listing 8.1
Why did we choose the MyFaces JSF implementation? We chose to describe how MyFaces works with Spring DM here because this JSF implementation is commonly used by the Java community and it’s the one that poses the fewest problems within an OSGi environment.
However, this implementation can’t be used directly in an OSGi environment and needs to be patched to fix an issue regarding the use of the JspFactory instance.
We opened an issue for this bug in the MyFaces JIRA under the identifier MYFACES-2442
The issue shows how to solve the problem by updating the isJsp21 method of the ContainerUtils class in MyFaces.
We provide, in the book’s source code, a patched version of MyFaces 1.2.2 that fixes this bug.
Again, this is configured in the web.xml file, as with any servlet.
Listing 8.7 shows this configuration using the servlet and servlet-mapping XML elements.
The JSF web controller is configured using the servlet XML element C, which allows its name and implementation class to be specified D.
This servlet is responsible for handling all JSF requests by specifying a mapping for *.faces E.
Because we need to use web scopes for beans with Spring JSF support, a dedicated request listener must be added in the web application configuration file.
Listing 8.8 shows how to configure this using the listener XML element in the web.xml file.
This support provides a variable resolver, which enables entities to be resolved directly within a Spring application.
Listing 8.9 shows how to configure this in the JSF XML configuration file, faces-config.xml.
Everything is now configured for using Spring DM with JSF entities, so that OSGi services can be used in the JSF implementation.
Now let’s look at how to link these entities with Spring DM.
The first step is to configure the OSGi services themselves, using Spring DM’s facilities, in the Spring web application context of the web application.
Our old friend, the reference XML element, should be used to reference services, as shown in following snippet.
These services can then be used in JSF entities defined by applications.
The previous snippet shows how to reference an OSGi service using the Spring DM’s facilities.
Once this configuration is done, we can implement our managed beans and inject OSGi services into them.
With Spring’s JSF support, every entity can now be defined within the Spring XML application context.
For managed beans, we need to specify the appropriate scope.
A request scope specifies that the bean is shared across the scope of a request.
Listing 8.10 shows how to inject an OSGi service configured with Spring DM into a managed bean within the Spring XML application context.
When configuring such an artifact in a Spring XML configuration file, a web scope such as request or session must be specified because managed beans typically contain state for request handling.
For the bean we’re defining, we use request scope B.
Because managed beans using Spring’s JSF support are configured in Spring, we can inject OSGi services configured with Spring DM C.
The JSF bean is now properly implemented and configured, and we can create a simple JSP view to display our contact list in a table.
Listing 8.11 shows how to use JSF taglibs to implement this feature.
Having defined the use of taglibs from JSF B, a table component can be specified using the dataTable XML element C.
Its value attribute allows you to reference a method for the table data.
In this example, the getContacts method is called, which delegates to a method from the injected OSGi service.
For each column, we can then specify a value to display, such as the first name of a contact D.
As usual, when using external libraries in an OSGi environment, some extra packages must be specified in the Import-Package header of the manifest file for the component using JSF.
Listing 8.12 shows the packages that need to be specified.
Listing 8.11 Implementing the JSF view in a JSP file.
The integration between Spring DM and JSF allows us to use OSGi services within JSF managed beans.
We’ve now described JSF, but what if you want to use another component-based framework, such as Wicket? You’d have to know how to integrate this framework with Spring DM.
It provides a proper separation of markup and logic, and a POJO data model with no XML configuration.
The framework is based on powerful and reusable components written with plain Java and HTML code.
In this section, we’ll describe how to use this framework with Spring DM, which allows you to use a component-based approach with OSGi services on the server side.
Listing 8.12 Packages to import for the MyFaces JSF implementation.
The SpringSource EBR provides all you need to use the Wicket framework in an OSGi environment.
Table 8.4 lists all the necessary bundles for using Wicket and its Spring integration.
To install Wicket, all these components need to be provisioned to the OSGi container.
Once Wicket is installed, you need to configure it so that you can use it with Spring DM.
Wicket’s Spring integration is based on the application context associated with the web application itself.
When using Spring DM, you can reference OSGi services in this application context, but this requires the use of a Spring application context that can interact with OSGi.
The configuration in the web.xml file is the same as was shown in listing 8.1
The Wicket web controller can be configured by using the WicketServlet class in the web.xml file as for any servlet.
Listing 8.13 shows this configuration using the servlet and servlet-mapping XML elements.
The Wicket web controller is configured using the servlet XML element B, which allows its name and its implementation class name to be specified C.
Because we want to integrate Wicket with Spring DM, we must enable Wicket’s Spring support.
The last configuration is to specify the mapping for this servlet E.
Everything is now configured for using Spring DM in Wicket application entities so that they can use OSGi services to implement their functionality.
In the next section, we’ll look at how to link these entities with Spring DM.
In order to use OSGi services within Wicket entities, they must be configured themselves, using Spring DM’s facilities, in the web application context of the web application.
The reference XML element should be used to reference services, as shown in following snippet.
These services can then be used in Wicket entities defined by applications.
The preceding snippet shows how to reference an OSGi service using Spring DM’s facilities.
Now that this configuration is done, we can implement our Wicket application entities.
These must extend Wicket’s WebApplication class and be configured as beans in the Spring application context.
Wicket provides two approaches for injecting OSGi services configured with Spring DM into Wicket entities:
Injection based on annotations—Wicket provides a mechanism that allows automatic injection of Spring dependencies based on the SpringBean annotation.
For the first approach, the injection of OSGi services is done directly in the Spring XML configuration in the bean corresponding to the application.
Standard Spring configuration can be used, as shown in listing 8.14
To be able to inject the service, the application class must contain the property corresponding to the service and its getter and setter methods to allow injection.
Listing 8.15 shows the specification of a property referencing an OSGi service and the methods used for injection.
With these two steps done, Wicket pages can access OSGi services using their corresponding WebApplication.
In fact, each page class can reference its page using its getApplication method.
The following snippet shows how you can get a reference to an OSGI service configured with Spring DM in a page class:
With this approach, references to configured OSGi services are made using the corresponding application class.
Instances of the application class can be obtained using the getApplication method.
We can then use the application class’s accessor method to get the OSGi service instance.
The second approach is much more convenient and less intrusive.
In fact, the injection of beans and OSGi services is implicit and is performed internally by Wicket.
No injection needs to be explicitly done in the application class at all.
We only need to configure an instance, as shown in the following snippet:
Some additional configuration is needed in the Wicket application class to enable automatic injection of Spring beans.
The following snippet shows how to configure this in the application class:
In this case, there’s no need to define OSGi services as properties of the application class.
Only pages that use them need to specify them as properties.
The presence of this annotation will tell Wicket to inject the corresponding instance present in the Spring XML configuration file in the associated property.
As you can see, the annotation must simply be put on the property corresponding to the OSGi service.
The last thing we need to cover is the OSGi configuration of the component containing the Wicket application.
Because we want to use Wicket in an OSGi environment, we first need to specify some packages in the Import-Package header of the manifest file for bundles using Wicket entities.
Some are related to Wicket itself, and others to Spring and Spring DM.
Listing 8.16 shows all the packages that need to be specified in the Import-Package header.
As you can see, using Spring DM with Wicket is pretty easy, thanks to Spring’s support for Wicket.
It allows you to access instances of OSGI services configured with Spring DM directly from within entities of a Wicket application.
These allow you to add interactivity to web pages without having to reload them.
Spring DM can be integrated with such frameworks in order to, for instance, remotely expose OSGi services.
This allows for an improved user experience with web components by improving the interactivity provided by web user interfaces.
These frameworks provide facilities for linking server abstractions to their JavaScript representations and to the application protocol used.
Most frameworks of this kind provide integration with Spring, allowing declarative configuration of services as remote services.
Because of this support, integration with Spring DM is simple and consists of exposing OSGi services configured with Spring DM in an OSGi environment.
In this section, we’ll describe the general concepts behind integrating these frameworks with Spring DM, then we’ll look at examples of two of the most popular ones: DWR and GWT.
Integrating Spring DM with AJAX frameworks involves exporting OSGi services referenced through Spring DM as remote services with the exporting facilities of these frameworks.
When configuring Spring support for this kind of framework, Spring DM’s OSGi web application context must be specified so that the osgi namespace can be used.
The other step is to use OSGi services, configured through Spring DM, in the exporters of the AJAX application.
An exporter is a dedicated utility class that makes an existing service available remotely through a specific protocol.
This can be done directly in the Spring application context.
Figure 8.3 shows the interactions necessary between Spring DM and AJAX-based web frameworks in order for them to work together.
That covers the general concepts involved in integrating Spring DM and AJAX frameworks.
We’ll now detail the implementation of these concepts using DWR and GWT.
On the client side, DWR provides JavaScript objects that represent objects on the server side.
You’re given the impression of being able to directly use the same objects on the client side as those developed on the server side.
The DWR framework also provides direct support for the Spring Framework, and this support allows every bean configured in Spring to be exported as a remote service.
With DWR, you can also expose a simple Spring bean that uses an OSGi service configured through Spring DM, but in this case you must be careful not to implement unnecessary additional classes.
To use DWR, you must provision the OSGi container with the bundles necessary for using DWR in an OSGi environment.
In chapter 6, we described how to OSGi-ify existing Java libraries and frameworks with the Bnd tool.
Using this approach, we can create an OSGi bundle for version 2.0.5 of DWR.
This bundle contains all you need to use the DWR framework in an OSGi environment, and it’s included within the source code for this chapter.
Now we need to configure DWR’s Spring integration to allow the use of Spring DM.
DWR’s integration with Spring is based on the application context associated with the web application itself.
When using Spring DM, you can reference OSGi services in this application context, but using OSGi services configured with Spring DM requires the use of a Spring application context that can interact with OSGi.
The appropriate configuration in the web.xml file is the same as described in listing 8.1
You can configure the DWR web controller by using the DwrSpringServlet class.
Listing 8.17 shows this configuration using the servlet and servlet-mapping XML elements.
Everything is now configured for using Spring DM in DWR to expose OSGi services as remote services for AJAX calls.
Next, we’ll look at how we can use DWR facilities, such as its Spring 2 namespace and its creator mechanism.
This namespace must be configured using standard XML techniques, like any other Spring XML namespace.
Listing 8.18 shows how to configure the DWR XML namespace.
We’re now ready to export an OSGi service that has been configured through Spring DM.
Once the configuration described in listing 8.18 has been done in the Spring XML configuration file, we can use the dwr XML namespace to export the service for use by AJAX.
Although DWR allows you to specify DWR configuration within a Spring bean’s configuration, this can’t be done with elements from Spring DM’s osgi XML namespace.
Instead, we use DWR’s configuration element and its inner create element.
Listing 8.19 shows how to expose an OSGi service configured with Spring DM as a remote service for DWR.
In order to export an OSGi service through DWR, you need to get hold of the OSGi service itself using Spring DM’s reference XML element.
To do so, you need to define the global configuration for DWR with the configuration B and controller D XML elements.
You also need to add the specific configuration for the remote service by adding a create XML element C inside the configuration element.
Name and type attributes must be set with the values contactService and spring, respectively, to specify the name of the JavaScript object created and to activate the Spring support.
The bean name must also be specified, together with a converter entity, to indicate how to handle returned data objects.
In some situations, developers don’t want to directly expose OSGi services as remote services but prefer to implement an intermediate entity to expose.
In this case, a classic Spring bean can be defined, and the OSGi service can be injected into it.
This new bean can then be configured as a remote service and can use the OSGi service for its functionality.
In this situation, you can specify DWR’s export configuration directly within the bean definition.
The problem occurs because DWR incorrectly determines the type of the service instance.
When calling the service with DWR, the following exception then occurs:
We opened an issue for this bug in the DWR JIRA under the identifier DWR-429
The issue shows how to solve the problem by updating the afterPropertiesSet method of the BeanCreator class in DWR.
In the book’s source code, we provide a patched version of DWR 2.0.5 that fixes this bug.
As we saw before, the OSGi service must first be configured through Spring DM.
The Spring bean is then defined using the bean XML element of Spring B, and the OSGi service is injected into it C.
The remote DWR XML element is used D inside this bean element, defining the remote DWR service with the same properties we saw previously.
As usual, when using external libraries in an OSGi environment some packages must be specified in the Import-Package header of the manifest file for the component using DWR.
Some of these are specific to DWR’s handling of remote calls and others to Spring and Spring DM’s support for web application contexts.
Listing 8.21 shows the packages that need to be specified.
As we’ve shown in this section, using Spring DM with DWR is relatively simple, and it allows you to expose OSGi services configured with Spring DM for AJAX interactions.
Another useful framework with similar functionality is GWT, which specifically targets rich internet applications.
The Google Web Toolkit (GWT) is a web framework that allows you to develop rich internet applications based on JavaScript and AJAX technologies and entirely written with Java.
The main feature of this framework is that it allows you to write applications exclusively in Java.
The pieces related to web UIs are then compiled into JavaScript code.
If you want to go deeper into GWT, we suggest looking at GWT in Action by Robert Hanson and Adam Tacy.
The GWT Widget Library is based on the remoting concepts of Spring, which allow any bean defined in Spring to be exposed as a remote service.
In following sections, we’ll describe how to configure GWT and the GWT Widget Library in an OSGi environment and use them with Spring DM.
Unfortunately, as with DWR, the SpringSource EBR doesn’t provide OSGi-ified versions of GWT and GWT Widget Library JAR files, so we need to create them ourselves using the Bnd tool.
Table 8.5 lists all the files that need to be OSGi-ified.
To install GWT, the GWT Widget Library, and Gilead, all these components need to be provisioned to a OSGi container.
Once you’ve done that, everything is present within the OSGi container for using Spring DM with GWT to expose OSGi services as remote services for AJAX invocations.
Let’s look at how to use GWT to achieve this.
Table 8.5 GWT JAR files that need to be OSGi-ified.
Because we want to use the exporter mechanism provided by the GWT Widget Server framework to expose as Spring beans as remote GWT services, and this mechanism is based on Spring MVC, the global configuration is similar to that of Spring MVC.
This configuration enables us to use OSGi services configured through Spring DM when handling remote GWT RPC calls.
In the next section, we’ll look at how to declaratively expose these kinds of services as remote services for GWT.
As we saw previously, there are two distinct parts to GWT applications.
In this section, we’ll look at how to implement these two parts to export an OSGi service configured within Spring DM as a remote GWT service and call it from the client side through GWT remote interfaces.
For the JavaScript frontend making the remote call, we need to add two interfaces in order to be able to call the service from the rich web application.
The first interface corresponds to the remote interface for the service and contains all the exposed methods of the service.
The following snippet shows its content for our contacts example:
The second interface is a remote asynchronous interface with a variant of the same methods exposed in the remote interface:
Notice that the remote interface extends the GWT RemoteInterface interface and must be present in the OSGi container.
The corresponding packages must be imported in the bundle that defines the service.
Because these interfaces use external abstractions, such as the Contact class, the bundle containing them must also be a GWT module.
This can be achieved by adding a GWT XML configuration file to these bundles.
This file must be located at a level above the packages containing the classes.
By default, GWT modules have a particular structure for packages:
The package named client contains all the classes for the client side and will be compiled into JavaScript code by GWT.
This package must contain the classes needed to build UIs and remote interfaces to map AJAX APIs.
The package named public contains all the files related to HTML and CSS technologies and images.
An HTML file to launch the application must be defined here, and it must load the JavaScript resources generated by GWT for the application.
The package named server contains all the classes for the server side.
These classes won’t be compiled into JavaScript but will be executed in the Java EE web container containing the web application.
In our example, this package isn’t present because all classes are provided by the bundle containing the OSGi service used.
The elements in the preceding directory structure have the following roles:
The GWT framework also allows you to adapt this structure and do things such as define packages other than the client one as packages containing classes for the client side.
This is useful, in our case, so that we can use the model classes of bundles in GWT user interfaces.
The following snippet shows the GWT configuration of the com.manning.
Because GWT allows modules to use other modules, you must add this module into the GWT XML module file of your web bundle, as shown in following snippet:
This enables any entity to be exported as a remote service.
The interface to be exposed—the ContactService OSGi service in this example—must be injected into the exporter using its service property.
In our example, we specified the interface of the OSGi service.
When it’s all implemented and configured, we can call the getContact method of the GWT remote service from the GWT client code, as shown in listing 8.22
A client instance for the service must first be gotten using the GWT class’s static create method B; the remote interface must be specified as parameter of this method.
The service can then be asynchronously called D, and the result is returned through a callback.
If the call is successful, the onSuccess method of the callback is called with the result; otherwise its onFailure method is called with the error.
As usual, when using external libraries in an OSGi environment, some packages must be specified in the Import-Package header of the manifest file of the component using GWT.
Some of these packages are specific to GWT and the GWT Widget Library’s handling of remote calls, and others to Spring and Spring DM’s use of the web application context and its configuration.
Listing 8.23 shows the packages that need to be specified:
In this section, we’ve looked at how to integrate AJAX frameworks with Spring DM.
This makes it possible to expose OSGi services as remote services for use by AJAX calls.
These frameworks provide convenient mechanisms for declarative configuration in Spring web application contexts.
We’ve got one more web framework family to discuss—web services—which will also help you expose remote services.
Once again, we’ll see how to integrate frameworks of this kind with Spring DM.
Web service frameworks provide remote access to services using web technologies such as SOAP and REST.
They’re generally responsible for handling underlying technology complexities and for routing requests to the right recipients.
Most frameworks of this kind provide integration with Spring, which allows the use of dependency injection when configuring resources.
Because of this support, integrating with Spring is generally easy and consists of injecting OSGi services configured through Spring DM into resource-handling abstractions.
In this section, we’ll describe some general concepts related to integrating frameworks of this kind with Spring DM, and we’ll take a look at examples of the most popular ones: Spring Web Services (Spring WS) and Restlet.
The key abstractions of web service frameworks are request handlers (endpoints for Spring WS and resources for Restlet)
These abstractions are responsible for handling requests and implementing functionality, which can be done by using other entities such as OSGi services.
Integrating Spring DM with these frameworks is a simple matter of using OSGi services inside action implementations.
When configuring Spring support for this kind of framework, Spring DM’s OSGi web application context must be specified so that the osgi namespace can be used.
You also need to use OSGi services, configured through Spring DM, in the actions of the application.
This can be done directly in the Spring application context using classic or annotation-based dependency injection.
Figure 8.4 shows the interactions between Spring DM and a web service framework that enable them to work together.
That’s the general concept behind integrating Spring DM with web service frameworks.
Now we’ll consider the implementation details when using Spring WS and Restlet.
Spring WS is a Spring community project dedicated to implementing web services using SOAP.
Leveraging Spring facilities such as dependency injection and annotations, it provides a contract-first approach to implementing web services.
The framework naturally integrates with Spring DM because it uses Spring’s web application context for its configuration.
In following sections, we’ll explain how to integrate Spring WS with Spring DM to use it in an OSGi environment, and how to use OSGi services configured through Spring DM in web service endpoints.
Spring WS is part of the Spring portfolio, and, like other projects of this kind, is already available as OSGi bundles in the SpringSource EBR.
In order to use it, additional XML components also need to be present in the OSGi container.
Table 8.6 lists all the required OSGi components for using Spring WS in an OSGI environment with Spring DM.
Spring WS’s contract-first approach The contract-first approach used by Spring WS consists of first implementing web service contracts using the Web Services Description Language (WSDL) independent of the classes used to implement the services.
This approach is the opposite of contract-last, which deduces these contracts from service implementation classes.
The contract-first approach guarantees service interface stability, better performance, reusability, and versioning.
The bundles required by this version of the framework also need to be added to the OSGi container.
Everything is now present in the OSGi container for using Spring DM with Spring WS so that OSGi services can be used to handle web service requests.
We’ll describe in the next section how to configure the Spring WS framework with Spring DM.
The first application context corresponds to the association with the web application and should be used to configure entities that are independent from web issues, such as business logic or business layer abstractions.
If the web service application uses Spring DM, this context is the perfect place to put OSGi service references to business services.
For more details, see the “Configuring Spring MVC for Spring DM” subsection of section 8.1.2
The other application context is linked to Spring WS’s frontend controller.
Its configuration in the web.xml file is similar to Spring MVC’s servlet.
Listing 8.24 shows how to configure the servlet, as well as the configuration required for Spring DM.
The first is the configuration of the servlet properties using the servlet XML element B.
Here we can specify the servlet’s name, class name, and init parameters.
The last element is the configuration of the servlet mapping using the servletmapping XML element D.
In our case, the framework handles all the incoming requests on the web application.
We’ve finished configuring Spring WS so that we can use Spring DM in Spring WS’s application context files.
Before implementing endpoints for handling web service requests, we must first configure OSGi services for use with Spring DM.
This can be done using the reference XML element of the framework in the Spring XML configuration associated with the web application context, as shown in the following snippet:
Based on this OSGi service, we can build a Spring WS endpoint to handle our web service requests.
We implement a simple endpoint using the JDOM XML library to pull data from the request and build the response.
The content of the response is built from the result of the injected OSGi service configured through Spring DM.
Spring WS endpoints Endpoints are central abstractions of Spring WS because they handle web service requests.
Spring WS allows requests to be routed to the right endpoint based on the XML content of the request.
The first kind is based on DOM, which requires developers to handle the document structure for requests and responses themselves.
A more advanced kind of endpoint provides marshalling, which allows automatic object-to-XML conversion (and vice versa) for building request and response content.
Listing 8.25 shows the implementation of a simple endpoint based on the JDOM library using an injected OSGi service.
Spring WS passes the request content as the method parameter and takes the return element as the content of the response.
In our ContentEndpoint implementation, the Spring DM–configured OSGi service is injected into the contactService property using the associated setter method C.
The handling of the request is then implemented in the invokeInternal method.
Having created the root element of the response, we iterate over the results of the OSGi service call and build up the content of the response.
We then configure XML definitions for the provided services using a contract-first approach.
These definitions represent the XML structure of exchanged messages and operations.
Finally, we specify the routing of requests to endpoint handlers.
Listing 8.26 shows the configuration necessary for making it possible for the endpoint to handle requests.
We first configure the XML definition of the entities used with Spring WS’s SimpleXsdSchema class B.
This class is configured with the directory.xsd XML Schema file.
The configuration of this class uses the previous schema and specifies the port type, name, location URI, and target namespace of the service.
In our example, a message containing a GetContactRequest XML element with namespace http://www.manning.
The last step in implementing endpoints involves configuring the ContactEndpoint class and injecting into it the OSGi service configured through Spring DM.
Listing 8.27 shows how to do this configuration using the same Spring XML configuration file that was used in the previous listing.
As usual when using external libraries in an OSGi environment, some packages must be specified in the Import-Package header of the manifest file of the bundle using Spring WS.
We’ve shown in this section that using Spring DM with Spring WS to implement SOAPbased web services is relatively simple.
The integration between the two frameworks is natural and is based on the web application context provided by Spring DM.
Once this web application context is configured, you can reference OSGi services through Spring DM in endpoint implementations.
In the next section, we’ll describe how you can use Spring DM with this framework so that OSGi services can be used to handle service calls.
Restlet is a Java framework that allows you to implement Restful applications flexibly and to leverage of all the features of the web, the HTTP protocol, and the REST architectural.
The framework provides support for a large number of extensions, including Spring.
The Spring extension provides a convenient way of integrating Spring DM with Restlet so that OSGi services can be used in resource implementations.
In the following sections, we’ll describe how to configure Restlet and the corresponding web application so that we can use Spring DM.
The great news here is that Restlet already provides OSGi configurations for the JAR files contained in the distribution, so you don’t need to create them yourself.
Table 8.7 lists all the files that have been OSGi-ified.
The necessary dependencies for these bundles are CGLib, servlet, and various Spring bundles, all of which are already present in the standard Spring DM web configuration of an OSGi container.
You now have everything present in the OSGi container to use Spring DM with Restlet, which will allow you to use OSGi services to handle REST requests.
We’ll describe in the next section how to configure the framework with Spring DM.
Restlet’s Spring integration is based on the application context associated with the web application itself.
When using Spring DM, the referencing of OSGi services can be done in the context configuration file.
Listing 8.29 shows how to specify this class in the web.xml file.
Listing 8.29 Configuring the Spring web application context for Restlet.
With Restlet, we also need to specify the Restlet application with the org.restlet.
This is configured in the web.xml file like any servlet.
Listing 8.30 shows this configuration using the servlet and servlet-mapping XML elements.
Everything is now configured for implementing REST resources using OSGi services configured through Spring DM.
In the next section, we’ll explain how to implement such resources using Restlet.
Before implementing resources to handle REST requests, we must first configure OSGi services using Spring DM.
As we saw before, this can be done using the reference XML element of the Spring DM framework.
By using our ContactService service, we can build a Restlet resource to handle our REST requests.
We’ll implement a simple resource using the JDOM XML library that builds response content as XML.
The content is based on the results of calling the injected OSGi service that we configured through Spring DM.
We first define the resource class by extending Restlet’s ServerResource class B.
Annotations are used to specify which methods will be responsible for handling HTTP requests.
In our example, the Get annotation specifies that the representContacts method E will handle REST using the HTTP GET method.
Within this class, the OSGi service configured through Spring DM is injected into the contactService property using the associated setter method C.
The handling of the request is then implemented in the representContacts method.
Having obtained the results of the OSGi service call (#5), we build the response content (D and F) using the JDOM library.
The last step in implementing resources is to configure the Restlet application and specify the routing of REST requests to the appropriate handling resources.
Listing 8.32 shows the configuration necessary for the resource to handle REST requests.
We first configure the Restlet application using the Application class B.
This application is the one previously configured in the web.xml file, as described in listing 8.29
This configuration allows us to specify a router for handling REST requests by using its root property.
With the Restlet Spring integration, the SpringRouter class must be used as the router C.
This allows request URIs to be associated with the resources responsible for handling them via its attachments property.
In our example, the /contacts URI is handled by the resource with the bean name contactResource.
We’ll look at the configuration of this resource in listing 8.33
Automatic converter registration with OSGi In early Restlet 2 release candidates, the OSGi activator for Restlet didn’t automatically register default converters at startup.
If an “Unable to find a converter for this object” message is displayed in traces when trying to call REST resources in OSGi, you can explicitly register default converters using the following code:
The last step in making resources work consists of configuring the ContactResource class and injecting into it the OSGi service configured through Spring DM.
As usual, when using external libraries in an OSGi environment, extra packages must be specified in the Import-Package header of the manifest file of the bundle using Restlet.
As we’ve shown in this section, using Spring DM with Restlet to implement REST applications is relatively straightforward.
The integration between the two frameworks is natural and based on the web application context provided by Spring DM.
We’ve described in these sections how to integrate web service frameworks with Spring DM so that OSGi services can be used in endpoint and resource implementations.
Often, the use of OSGi services configured through Spring DM is made possible by the Spring integrations that these frameworks provide.
In this chapter, we tackled another important data access issue related to developing enterprise applications: web data access.
We focused on how to integrate Spring DM with several different kinds of web frameworks.
The Java EE community provides a large number of web frameworks, but we can categorize them into broad families based on their implementation and the issues they address.
Classic web frameworks implement the MVC 2 pattern and can be actionor component-based.
Other frameworks provide support for AJAX technology and web services.
Most of these frameworks provide integration with Spring, allowing their supporting classes to be configured directly in Spring web application contexts.
This integration makes it easier to use Spring DM with these frameworks.
Generally integration with Spring DM means that these web frameworks can be used in an OSGi environment and leverage OSGi services.
This chapter completes the trio of chapters dedicated to enterprise issues.
They described global concepts of implementing enterprise applications with Spring DM in an OSGi environment.
We also dealt with the most important issues of enterprise applications: data access and web issues.
In the next part of the book, we’ll focus on the advanced features of Spring DM and especially on advanced configuration.
You should by now have a deep understanding of what Spring DM is and does.
You should be ready to embark on your first Spring DM project, if you have not done so already! As we all know, there is always more to learn, and deeper understanding often comes through a process of experience and trial and error.
This part of Spring Dynamic Modules in Action draws on our own experiences-and the mistakes we made-in developing with Spring DM, and it’s devoted to more advanced Spring DM-related topics.
It is likely that you will want to refer to this part as you encounter problems rather than necessarily read right through it.
Chapter 9 covers advanced Spring DM topics, including overall configuration of the Spring DM container and Spring DM patterns that we have found useful in real products that use Spring DM.
Chapter 10 covers the testing of OSGi applications that use Spring DM.
Chapter 11 discusses Spring DM’s support for OSGi compendium services-in.
In chapter 12 we describe the Spring DM standard - the OSGi Blueprint specification and its relationship to Spring DM.
Following part 3 are four appendices which describe Spring DM development.
But OSGi applications always end up being deployed in OSGi containers, which we want to be robust, reliable, and stable.
When we use Spring DM, its bundles are part of the infrastructure of the OSGi containers, so they must provide global configuration hooks (as apposed to per-bundle configuration) and they must be able to take advantage of some of the components that the environment provides.
In this chapter, we’ll cover how we can globally configure Spring DM’s extenders through fragment-based configuration.
For the standard extender, settings range from thread management to the systematic registration of beans in Spring application contexts that Spring DM manages.
The web extender also has its own settings that we can leverage; for example, to switch from one embedded web container to Advanced concepts.
We’ve looked at how OSGi bundles can leverage the power of Spring by using Spring DM.
Indeed, increasing the power of bundles through Spring’s features is a.
We’ll also introduce the OSGi security model and see how Spring DM can be integrated into a secured OSGi container.
We’ll end this chapter with a description of two advanced patterns that can help implement elegant solutions in modular systems like OSGi.
Spring DM helps in their implementation and also uses them internally.
By the end of this chapter, you’ll be able to configure the global behavior of Spring DM (as opposed to the per-bundle configuration we mostly covered in previous chapters)
You’ll also learn how Spring DM can fit into and even benefit from the infrastructure that your OSGi environment provides.
This chapter covers some very advanced topics and settings of Spring DM and of OSGi, so you shouldn’t feel overwhelmed by its content.
The chapter isn’t meant to be read sequentially; instead you should acquaint yourself with the types of configuration hooks Spring DM provides and come back to this chapter for the details when you need to use them.
Here’s a quick overview of what the different sections of the chapter cover:
Section 9.1 covers the extender’s principles of configuration, and you should read this section.
There’s also a real-world example of configuration within SpringSource dm Server in section 9.2.9
Other subsections in section 9.2 dive into the details of configuration and are intended to be read on an ondemand basis.
The beginning of this chapter and section 9.3.1 provide the big picture, so you should read them first and come back to the remaining subsections when you need to configure the web extender.
You should read section 9.5 about security if you need to integrate Spring DM into a secured OSGi container or if you’re curious about the Java and OSGi security models and how Spring DM fits into them.
Read section 9.6 if you want to learn about modular design patterns.
The patterns we describe both leverage the modular nature of OSGi and help to solve technical problems that only emerge in OSGi development.
As you can see, the topics are quite independent from each other, and you can skip to the ones that will help you with your particular needs.
We saw in chapter 4 that the behavior of Spring DM’s extenders can be configured on a per-bundle basis, by using manifest headers, like Spring-Context or Web-ContextPath.
Extenders then manage the application context of a specific bundle accordingly.
But sometimes we want global settings that apply to all Spring-powered bundles.
For example, the duration Spring DM waits before failing the startup of an application context (because its dependencies aren’t satisfied) can be configured at the extender level for all Spring-powered bundles.
Setting this duration once means that you don’t have to specify it for every bundle; this allows for centralized control over the bundles.
We may also want Spring DM to be integrated deeply into our OSGi environment and need to replace some of its inner components with our own, so we can benefit from a service the environment provides (like thread management)
Luckily, Spring DM offers enough hooks for us to tune the behavior of its extender in a centralized way through fragment-based configuration.
In this section, we’ll cover the basics of the fragment-based configuration and the features Spring DM lets us configure.
OSGi fragment bundles are meant to complement a host bundle.
To tune Spring DM, we create fragments to complement its extender bundles.
Each extender (standard and web) looks for Spring configuration files in its potential fragments.
It can then use these files to bootstrap an OSGi-enabled Spring application context for the extender and use the beans declared there in place of its core components.
By using an OSGi Spring application context, the fragment can leverage all the features of the Spring lightweight container, such as dependency injection, AOP, OSGi resource loading, and interaction with the OSGi service registry.
A fragment can contain several XML files or there can be several fragments.
The target extender will search in its bundle space for all the .xml files in its META-INF/ spring/extender directory and will bootstrap an application context from them.
This implies that the composition of these files must define a consistent application context (consistent dependencies, no collision for the names of the beans, and so on)
Figure 9.1 illustrates the fragment-based configuration of the extender in Spring DM.
Spring DM’s extenders require specific beans to be defined in their fragments, which leads us to the nature of the contract between extenders and the application context they define.
Once one of Spring DM’s extenders has bootstrapped its fragments’ application context, it will pick up beans from that application context and use them in place of its default core components.
Miscellaneous properties (timeout for dependency resolution, activation of annotation parsing), covered in section 9.2.4
And this is what we can configure for the web extender:
From these lists, you can see that Spring DM is highly configurable.
Let’s move on to see how to tune the heart of Spring DM—its standard extender.
The extender uses beans from the fragment’s application context for its core components.
It will contain bean declarations meant to override Spring DM’s default core components.
These beans will be created by the extender, which means its classloader will be used.
The fragment is responsible for declaring all the necessary entries in its Import-Package headers.
These entries will complement those of the extender and make the classes available for instantiation.
We’ll now look at the beans that Spring DM lets us declare to override its default behavior.
We’ll provide samples and the corresponding Import-Package entries where appropriate.
Table 9.1 lists the beans that Spring DM’s standard extender recognizes.
Table 9.1 Beans in Spring DM’s extender available for overriding.
The following sections are dedicated to the description, default behavior and overriding of each bean.
Within Spring DM, creating a Spring application context is a sensitive task, because there are many parameters to take into account: asynchronous versus synchronous creation, waiting for dependencies, and so on.
Spring DM’s extender handles some of these parameters in preparation for creation, but once the preparation is done, it delegates the creation to a TaskExecutor.
Using a task executor allows the task submission to be decoupled from the way it will be run, because details such as the use of multiple threads and scheduling (to delay the execution) are part of the settings of the task executor implementation.
The TaskExecutor is a Spring interface, and even though you can use it in your own applications, it’s most often used by frameworks that build on top of Spring (such as projects from the Spring portfolio)
A ThreadPoolExecutor manages a pool of threads and also maintains some basic statistics.
The corePoolSize property defines the number of threads that the pool executor keeps alive, even if they’re idle.
If we don’t want the pool to expand too much under heavy load, the maxPoolSize property will limit the number of threads.
The keepAliveSeconds property defines the number of seconds extra idle threads (that is, if the number of threads exceeds the core size) will wait before terminating.
We can also define the prefix used for names of newly created threads B; this can help with logging, when the thread name is included in the log message.
The settings in listing 9.1 are just examples to show that the underlying ThreadPoolExecutor is flexible; you’ll want to adapt them to your own needs.
This allows the use of a thread pool, even if you’re stuck on Java 1.4
Listing 9.2 Overriding the default task executor with Doug Lea’s concurrent library.
An OSGi-ified version of the concurrent library is available in the SpringSource EBR.
But you’re not limited to these two implementations: if your container comes with a component that manages threads, you can write your own implementation of TaskManager that delegates the work to this component.
This TaskManager will then be a bridge between Spring DM and this management component.
Let’s now look at the task executor that’s in charge of destroying application contexts.
We explained in chapter 4 that the destruction of a bundle’s application context is done synchronously, before the bundle is stopped; otherwise the application context could not shut down properly.
We also explained that before stopping, Spring DM’s extender computes a dependency graph to shut down in the right order all the application contexts it manages.
Just like during creation, Spring DM’s extender performs a preparation step before closing application contexts, but it ends up submitting the task to a TaskExecutor.
Execution is asynchronous and occurs in a unique thread, separate from the calling one.
Spring DM uses this implementation mainly for the sequential execution of tasks it provides, and Spring DM does some synchronization work so that destructions occur.
Unlike when using the TaskExecutor for creation, there is no benefit in overriding the destruction TaskExecutor.
If for any reason you really need to do so, you must ensure that destructions occur sequentially—in the same order that Spring DM submits them.
We’re done with the task executors that Spring DM uses for application context creation and destruction.
Both are inner components of Spring DM, but you can override them with components of your own and even create a bridge between Spring DM and the container.
In the next section, we’ll look at how to set properties at the extender level and have them applied to all the bundles that Spring DM manages.
Each of these properties has an equivalent when you create a Spring-powered bundle, but setting them at the extender level will affect all Spring-powered bundles.
This is convenient when you want a unique but centralized configuration, instead of having a configuration for each bundle.
Table 9.3 lists the properties that Spring DM’s extender accepts.
If an application context exceeds this duration, Spring DM considers it to have failed to shut down.
It then stops the task and emits a logging message.
The default duration (10 s) is a bit aggressive for slow bundles; making it longer is a good reason to override it.
The cascading shutdown problem The most common reason that an application context might fail to shut down is because some remote resource involved in the shutdown is either slow or not responding.
Service references from other bundles are particularly problematic because bundles often need to interact with other OSGi services to shut down properly—think of unregistering servlets or MBeans.
By default, annotation detection isn’t activated, so you can set the property to true if you want to support annotations everywhere.
As we mentioned earlier, it’s better to do this in the extender configuration because that way you get support for service annotation–based dependencies.
Spring DM is able to defer the creation of application contexts if their mandatory dependencies aren’t satisfied.
The default value (5 min) is targeted at short update cycles (stop the current bundle, install a new version, start it, and test it)
If you want more time between updates, you can lengthen the duration.
Note that using the timeout directive of the Spring-Context header in a bundle overrides this global setting for that bundle.
The following snippet shows how to override all the properties by declaring an extenderProperties bean with Spring’s util tag:
You should use the extender’s properties when you need to set these properties globally.
Spring DM has its own event mechanism, which differs from Spring’s, as it propagates events about the full lifecycle of application contexts to interested parties.
These parties aren’t known in advance and generally belong to application contexts other than the ones that emitted the events.
For this and other reasons, it’s generally best not to let Spring DM forcibly shut down your bundles.
Instead, you should write your code in a way that ensures it won’t exceed the shutdown timeout.
Extending the standard extender the same thread as the caller.
This behavior is simple and fits the most common cases, but it can be problematic if some listeners take a long time performing their operations, because the propagation could then block the entire application.
Getting better control over the way events are propagated is a good reason to override the default event multicaster.
You can either implement your own event multicaster or use a combination of what Spring and Spring DM offer for this.
We use Spring DM’s adapter that builds a bridge between its event mechanism and Spring’s.
Thanks to the destroy-method attribute, the multicaster will release its listeners when the application context is destroyed.
Then we start defining the multicaster that will do the real job of propagation C.
With this configuration, event propagation will be done efficiently, without impacting the thread of the calling code.
Nevertheless, you should check whether the default behavior suits your needs before overriding it like this.
This interface is simple, but its implementation has a huge responsibility because it defines the creation of application contexts.
The other part of the contract finds Spring configuration files in the bundle context.
When doing so, you should follow one of the following three paths:
This filter is a barrier for bundles that shouldn’t have a Spring application context bound to them, so that the application context creator focuses only on the creation of application contexts.
The following snippet shows how to declare the application context creator bean in the configuration fragment:
With the previous configuration, bundles are filtered before they have any chance to be scanned for the presence of the Spring-Context header or for Spring configuration files in the META-INF/spring directory.
Let’s now see how we can configure the default application context creator.
It then hands the files to the application context creator, which uses them to load the application context.
It doesn’t interpret the directives of the Spring-Context header (asynchronous versus synchronous creation, timeouts, and so on)
The following snippet illustrates how to do so in the configuration fragment:
Overriding Spring DM’s default mechanism for creating application contexts isn’t a job for the faint-hearted.
Supplying systematic default behavior (for example, creating a default Spring application context for non-Spring-enabled bundles, providing a parent application context to all contexts, and so on)
In any case, your customization of the creation process should still support the Spring-Context header and META-INF/spring couple, because it’s the default and most accepted way to load Spring application contexts with Spring DM.
Let’s move on from application context creation to their postprocessing, which allows you to modify the definitions of Spring beans.
The principle of least surprise You may have heard of the principle of least surprise (or sometimes least astonishment)
Basically, it means that you should strive to make things work as a user would reasonably expect and that doesn’t cause surprise.
Function naming is an obvious example—you should name functions for the purpose they perform, rather than giving them obscure or counterintuitive names.
Although this may seem obvious, in highly configurable systems it can be tempting to “improve” on the default behavior.
The problem with this is that the user won’t be expecting it, and such changes can lead to problems because the way something works isn’t the way the user expects it to work.
This is particularly useful for working on bean definitions or even for adding beans to the application context in a systematic manner.
This post-processing is done before the beans are created, meaning that the postprocessor works on bean definitions and not on the beans themselves.
You need to register the postprocessor in the configuration fragment, and it will be called for the creation of the application context of each Spring-powered bundle:
Spring and Spring DM’s bean factory postprocessors can be used for any of the following:
Because Spring DM’s bean factory postprocessors also have access to the bundle context, their operations can be bundle-specific.
Spring DM’s event mechanism allows you to interact with the lifecycle of the application context of each Spring-powered bundle.
OSGi application context listeners are usually declared in Spring-powered bundles, and they must be exported as OSGi services if they want Spring DM to register them.
Spring DM can register a default OSGi application context listener through a configuration fragment.
You can register your own implementation of an OSGi application context listener, but by doing so you’ll lose the logging that Spring DM’s default implementation performs, unless you reimplement it in your listener.
This means there’s no real benefit in overriding the default OSGi application context listener: its logging features are welcome, and you can easily declare listeners in a dedicated bundle and export them thanks to Spring DM.
Nevertheless, the following snippet shows how you can declare your own default application context listener:
This ends our tour of the configuration of the core components of Spring DM’s extender.
The extender is flexible and even allows you to override part of its most critical components.
Some of them need to be overridden only in specific cases, and others (like the creation task executor or the extender properties) should always be considered for overriding in production environments.
By overriding components, you can also plug Spring DM into your environment and make it work in a truly managed manner.
Let’s now see a real-world example of the configuration of Spring DM’s extender within SpringSource dm Server.
SpringSource dm Server is a true modular application server, both in its design and in the programming model it provides for its hosted applications.
It provides monitoring capabilities like logging, trace, and service dumps, and it solves common pitfalls when running in an OSGi environment (like ORM or AOP)
It also defines new units of packaging, more adapted to enterprise applications than plain OSGi bundles.
Last but not least, it comes with a command-line utility, the dm Shell, which we’ll use to find the configuration fragment of Spring DM’s extender.
If dm Server is running on your computer, you can access the dm Shell through SSH:
Note you can access the dm Shell locally by adding the -shell flag to the start script.
Once connected, you’ll see the splash screen on the console:
The bundle list command issues the names of dozens of bundles, but by looking at the list carefully, you can find Spring DM’s extender bundle:
Bundles that embed a Spring application context are flagged with an “S”
The bundle examine command gives more information about the extender bundle and its fragments:
This gives us enough information to open the dmfragment bundle, which is located in the lib/kernel directory of the dm Server distribution.
As of dm Server 2, only the TaskExecutor bean is overridden.
By providing its own TaskExecutor, dm Server uses a portable and effective solution for creating Spring application contexts.
The way dm Server customizes the Spring DM extender module is a real-world example of how you can configure Spring DM as you need for your own environment.
Now that Spring DM’s standard extender no longer has any mystery for you, let’s move on to configuring the web extender.
We’ll cover how to switch to the Jetty WAR deployer, how to change the strategy of the context path of web applications, and how to modify Spring DM’s definition of web bundles.
This proves especially useful when you want to finely tune the web container you’re using with Spring DM web support.
Just like the standard extender, Spring DM’s web extender allows you to configure some of its core components through fragments.
To be attached to Spring DM’s web extender, a fragment must contain the following entry in its manifest:
Table 9.4 lists the beans that Spring DM’s extender recognizes.
Table 9.4 Beans in Spring DM’s web extender available for overriding.
The following sections are dedicated to the description, default behavior, and overriding of each bean.
Inside Spring DM’s web extender, the WAR deployer is in charge of installing and uninstalling web bundles.
An implementation of WarDeployer is specific to a web container and uses its API to achieve this integration.
A WAR deployer can also start the web container, but the preferred way to start the container is to consume the container service from the OSGi repository, letting another bundle do the work of creating and configuring it.
By default, Spring DM uses the TomcatWarDeployer and, following the philosophy of WAR deployers, expects another bundle to start the servlet container.
To change the default WAR deployer, your configuration fragment must declare a warDeployer bean, of type WarDeployer.
To use Spring DM’s web support, the WAR deployer isn’t enough.
The target container classes available in the OSGi container (which means an OSGi-ified version of the container)
A bundle that starts the container and registers it on the OSGi service registry.
We’ll learn more about this process in section 9.4, which is dedicated to web containers.
All you need to know for now is that you need to change the WAR deployer when switching from Tomcat to Jetty.
Changing the default WAR deployer is simple; the difficult part comes when you need to provision the OSGi container with all the container’s bundles.
The default context path strategy makes sense, but you might want to change it; for example, to change the order of the decisions or to use your own manifest headers.
The following snippet shows a skeleton for implementing your own strategy:
Note that the context path must begin with a slash (/) and must not contain any whitespace.
The following snippet shows how to declare the custom context path strategy in the configuration fragment:
Before overriding the context path strategy, try to take advantage of the default implementation, which has a flexible yet consistent algorithm.
Also keep in mind the usual restrictions for context paths that also apply in an OSGi environment: uniqueness, no whitespace, and so on.
Now that you know how to choose the context path of your web application, let’s see how we can easily choose which bundles should be web bundles, by changing the definition of a web bundle using Spring DM’s WAR scanner component.
Spring DM’s web extender relies on a WarScanner to decide whether or not a bundle is a web bundle.
The DefaultWarScanner considers a bundle to be a web bundle if its location ends with .war or if it contains a WEB-INF directory.
If the default WAR scanner doesn’t suit you, you can create your own implementation.
You just have to make sure that the scanning is consistent with the structure of a web archive as a web container would expect it.
The following snippet shows the skeleton of a custom WarScanner:
To tell the web extender to use your WarScanner implementation, you must declare a warScanner bean in the configuration fragment, as illustrated in the following snippet:
Simple! This ends our study of the configuration of Spring DM’s web extender.
That’s why the next section is dedicated to WAR deployers and the configuration of their web containers.
Spring DM provides out-of-the-box web support for two of the most popular Java web containers: Tomcat and Jetty.
Tomcat is Spring DM’s default choice, so we’ll see in this section how to configure the web extender to use Jetty.
Tomcat and Jetty are both excellent web containers, and choosing one or the other is mostly a matter of taste or company policy (although Jetty has a longer track record with OSGi than Tomcat because it’s often used as an implementation of the OSGi HTTP service)
If you use Spring DM web support and don’t have any opinion about Tomcat or Jetty, you can stick to Tomcat, because it’s the default (and simplest) choice with Spring DM.
When starting web containers, Spring DM uses a default configuration, which is convenient for demos but not sufficient when we have more specific requirements (such as starting the server on a port other than 8080, enabling SSL, and so on)
We’ll look at how to provide our own configuration for the web container, and we’ll start by discussing the nuts and bolts of Spring DM web support, because this is a prerequisite to understanding how to configure it.
Spring DM’s web extender is in charge of detecting and deploying web bundles.
We learned in section 9.3 that the web extender delegates most of the work to components that we can easily replace.
The WAR deployer is the most important of these components, because it handles the deployment and undeployment of web applications.
A WAR deployer should not start and stop the web container: it should let another bundle handle this and subsequently look up the service to deploy web applications.
This allows the management of applications to be decoupled from their target deployment environment.
This is the behavior of the two WAR deployer implementations that Spring DM provides.
Spring DM also provides the corresponding bundles that start the web container.
Figure 9.2 illustrates how the WAR deployer (embedded in the web extender) consumes the web container service that another bundle started and made available in the OSGi service registry.
Figure 9.2 illustrates another concept of Spring DM’s web support: the fragmentbased configuration.
We already saw how to configure the web extender, allowing (among other things) the definition of the appropriate WAR deployer to use.
The web container starter bundles that Spring DM provides can use a fragment to get a specific configuration file (server.xml for Tomcat and jetty.xml for Jetty)
Now that the configuration basics of Spring DM’s web support are clear, we’re going to apply them to configuring the two web containers that Spring DM supports out of the box: Tomcat and Jetty.
This will allow us to switch from one web container to the other, and it will also allow us to configure them as we can when they’re running standalone, outside of an OSGi environment.
The web container starter bundle starts the web service and registers it; the WAR deployer consumes this service.
Users can configure the web container or change the WAR deployer using fragments.
Apache Tomcat is arguably the most popular web container in the Java EE world and it’s Spring DM’s default web container.
We’ll discuss here how to use Tomcat 6.0 and then how to provide our own configuration for the web container.
From Spring DM’s repository, you can get a set of libraries that allow you to use Tomcat 6.0.16
Unfortunately, due to Tomcat and Jasper’s (the JSP compiler’s) design and package structure, JSP isn’t supported.
This solution uses a limited number of bundles, but although there are alternatives to the use of JSP, not supporting this standard Java EE view technology is a big limitation.
Don’t panic, you’ll be able to use JSP with Spring DM, but doing so requires a solution with a larger set of bundles.
The SpringSource EBR contains all the bundles necessary for feature-complete support of Tomcat 6.0.24
Now you have a functioning Tomcat container in your OSGi environment, and you.
Nevertheless, you’ll want to customize the configuration of your web container, and that’s what we’ll discuss in the next section.
Spring DM’s Tomcat bootstrap bundle is in charge of configuring and bootstrapping the Tomcat instance you use with Spring DM.
Before using this file, it looks in its bundle space to find a conf/server.xml file.
This means that we can use a fragment to provide our own configuration.
For example, by changing the default configuration, we can do any of the following:
To get attached to the Tomcat bootstrap bundle, the fragment must contain the following entry in its manifest:
For the bootstrap bundle to pick up the configuration file, the fragment must have the following structure:
The server.xml file can contain any configuration directives relating to Tomcat configuration (refer to the Tomcat reference documentation for an exhaustive description of the available options)
The following snippet shows how to start Tomcat on port 8090:
Another facet of Tomcat configuration is the configuration of its Servlet container, also known by the name Catalina.
The configuration of Catalina consists of providing a fragment to the Catalina bundle.
This fragment can contain files that usually lie in the conf directory of any standard distribution of Tomcat 6.0
Catalina uses these files to automatically add behavior to web applications (such as using web.xml to register a DefaultServlet that serves static resources) or to apply a security policy to the web container.
Without this extra configuration step, web applications in Tomcat are nearly unusable.
This section is mainly intended to configure the Catalina bundle from the SpringSource EBR.
The configuration fragment must contain the following entry in its manifest to get attached to the Catalina bundle from the SpringSource EBR:
All the configuration files that the fragment contains are optional.
The default web.xml file should always be added to the Catalina configuration because it contains important servlet declarations (you can find this file in the standard distribution of Tomcat)
Now that you’re able to configure every aspect of Tomcat within a Spring DM environment, let’s see how to configure the other web container that Spring DM supports: Jetty.
Starting with version 7, Jetty is part of the Eclipse foundation.
In this section, we’ll cover how to use and configure Jetty 6.1 with Spring DM.
Spring DM supports Jetty out of the box thanks to a JettyWarDeployer implementation and Jetty bootstrap bundle.
In section 9.3—dedicated to the configuration of Spring DM’s web extender—you learned that, by default, Spring DM uses a TomcatWarDeployer and that you can switch to JettyWarDeployer using a fragment.
Spring DM provides a working fragment that declares a Jetty WAR deployer bean, so switching to Jetty is just a matter of gathering the appropriate bundles.
Table 9.7 lists all the bundles necessary to make Jetty work (with JSP support) within Spring DM.
Jetty core JARs are distributed as OSGi bundles, which is why they’re available in public repositories.
As for Tomcat, Spring DM’s Jetty bootstrap bundle bootstraps the server with a convenient default configuration.
We’re going to see how to provide our own configuration.
In Jetty’s standard distribution, this file lies in the etc directory and is named jetty.xml.
Our work consists of writing a fragment that attaches to the bootstrap bundle:
The following snippet shows an excerpt of the jetty.xml file, for starting Jetty on port 8090:
You can see that getting Jetty to work with Spring DM is easy, because integration in various environments is a strong focus of the Jetty team.
So if you usually use Jetty as your web container, you can still do so when using Spring DM web support.
Because Spring DM can run with Tomcat or Jetty, the most popular web containers in the Java EE world, there’s little chance you’ll have to change your habits and learn to configure a new web container.
This is another demonstration that Spring DM’s foundations don’t prevent it from being a flexible and customizable framework that can be used in many different environments.
Speaking about integration, perhaps your OSGi and Spring DM-powered applications will have to run on an OSGi environment you don’t control, and this environment may be secured by its administrators to avoid third-party bundles.
We’ll see in the next section how Spring DM can run in a managed and secured environment, thanks to its support for the Java 2 security model.
As OSGi is all about modularity, you’re likely to run many modules on your OSGi platform.
Some of them will be yours, and others will have foreign origins, and you don’t want the latter to compromise the integrity of whole system or, worse, to execute some malicious code.
This is what the Java security model is about: being able to control which instructions code can invoke.
OSGi has its own security model, but it builds on top of Java’s.
We’ll give a primer on both models in this section.
What about Spring DM? Spring DM is just another set of modules, so perhaps you’ll need to run it in secured mode on your target environment.
Imagine you’re developing a web controller in an enterprise application.
Your mind is filled with data access objects, HTTP requests, transactions, and business services.
Why not try something fun for relaxation? Put System.exit(0) in your web controller, launch the server, and hit the controller URL with a browser.
Bravo, you just stopped the server! But what would have happened if your web controller had reached the production server unchanged?
It’s to avoid this kind of blunder that Java processes can be run in a secured mode, where a security manager checks what permissions are granted to the code.
By default, Java processes—even sensitive ones like web containers—don’t run in secured mode.
Nevertheless, we’ll give you the basics so that you can understand how OSGi uses Java security for the foundations of its own security model and what the OSGi security model implies for Spring DM.
If you want to learn more about the Java security model, we invite you to consult the resources available on Sun’s website.
A policy dictates what permissions are granted to the code.
Policy configuration files usually have a policy extension and contain the permission definitions.
Permissions implement some of the logic of checking, and they get passed to the SecurityManager, which throws a SecurityException if the code isn’t granted the permission.
Figure 9.3 illustrates the relationship between the codebase and permission in a secured JVM process.
How does the security manager get called? For built-in permissions (those included in the JDK), the checking is done in the class that needs protection.
If you take a look at the classes in the java.io package, you’ll see that they call the SecurityManager: they create FilePermission objects and hand them to the SecurityManager.
This checking is performed on the whole stack of the call.
Usually, a call to a protected function is encapsulated in a deep succession of method calls, and each of them must be checked.
If any frame of the stack doesn’t have the correct permission, a SecurityException is thrown.
This is the general rule, and, like any rule, it can be broken by privileged code.
Marking code as privileged enables the code to indirectly grant permissions to its calling code.
For example, if some privileged code that has advanced file permissions gets called by code that doesn’t have these permissions, no SecurityException will be thrown.
The following snippet shows how to mark the code in the run method as privileged:
When should you use privileged code? When you want to grant permissions to trusted code that gets called by unknown code or by code you don’t want to grant permissions to.
The trusted code can then do its work without worrying about who calls it and without compromising the system, because its own permissions are carefully controlled.
Now that we’ve covered the basics of the Java security model, let’s see how OSGi extends it for its own use.
Figure 9.3 In the Java security model, code is given permissions depending on its codebase, which is identified by the URL from which the source was loaded.
The CPA waits for conditions to be met and then checks permissions.
Conditions can be based on either the location of a bundle or on the vendor that signed the bundle’s code.
The OSGi API provides just these two kinds of permissions, but you can add your own because the system is extensible.
Conditions are filter-based: you can define patterns to broaden them to a set of bundles.
OSGi permissions use the exact same semantics as those for the Java security model (that’s where both models meet)
Figure 9.4 shows how the OSGi security model builds on top of the Java security model.
Notice that OSGi uses its own classes to represent conditions and permissions: ConditionInfo and PermissionInfo, respectively.
PropertyPermission Figure 9.4 To secure an OSGi container, we usually give it all permissions and it then grants permissions to bundles, following rules dictated by the ConditionInfo and PermissionInfo objects.
The security layer of OSGi is optional, so you have to turn it on explicitly when you start the container.
With Equinox, you can enable security and specify a policy file with system properties in the launch arguments:
Because the OSGi framework will handle all the security checking through the CPA, the policy file used to bootstrap the container just has to give it all permissions:
With these settings, all bundles will have all permissions by default.
This isn’t exactly what we want, but the OSGi specification gives us all the tools we need with the CPA.
We’re now on our own to make use of it.
A common way to set permissions in an OSGi container is to write a dedicated agent that listens to the installation of bundles and grants them permissions.
It usually takes the form of a BundleListener and is started immediately after the system bundle.
You now know how to enable the OSGi security model and to set permissions on bundles.
There is a last element in the OSGi security model that’s worth mentioning: special permissions for framework- and service-related tasks.
As OSGi brings new concepts, it also comes with new corresponding permissions.
Now that we’ve looked at the OSGi security model, we’ll discuss how Spring DM fits into it.
AdminPermission Authority to perform operations on or get information about a bundle.
BundlePermission Authority to require or provide a bundle and to receive or attach fragments.
PackagePermission Authority to import or export a package import, export.
When the OSGi container runs in secured mode, Spring DM needs to be granted some permissions, or it won’t work properly.
For example, one of the first jobs of Spring DM is to bootstrap Spring application contexts, and for this it inspects the content of bundles and their manifests.
For this duty, Spring DM needs the AdminPermission on the bundles it manages (though, only if security is enabled)
Because Spring DM can be considered a trusted framework, it should be granted AllPermission.
Nevertheless, if you need to run in a secured environment, table 9.9 lists the permissions that Spring DM needs for the different parts of its operation.
Using this list, you can adjust the granted permissions according to the parts of the framework you’re using.
The usual way to grant the correct set of permissions is to start without any permissions at all and increase them little by little, until the system works correctly.
Since version 1.2, Spring DM has used privileged blocks to execute sensitive operations with its own permissions.
This means that Spring DM-managed bundles can call some of the Spring DM code without being granted additional permissions, because the security checking will be based on Spring DM’s permissions.
This ends our tour of securely integrating Spring DM into an OSGi environment.
You have learned about both the Java and OSGi security models, and this should have.
BundlePermission * host For attaching a configuration fragment to extenders.
PackagePermission * import, export For importing and exported Spring DM’s packages.
You should also understand how Spring DM leverages the privileged blocks of code.
In the next section, we’ll cover two advanced patterns related to OSGi and Spring DM.
Like any other technology, OSGi has its own patterns, which build on its specific features.
Think about the fragment configuration pattern: a fragment gets attached to a host bundle and overrides the default behavior of the bundle.
This pattern is specific to OSGi, as it uses the concept of an OSGi bundle fragment.
In this section, we’ll cover two additional patterns: the implementation provider pattern, which helps enforce the modularity of a bundle, and the chained classloader pattern, which is designed to make aspect-oriented programming (AOP) work smoothly in an OSGi environment.
We’ll also see how Spring DM can help with the implementation of these patterns.
When using interface-based programming, we usually put all the interfaces of our API in a package that’s made available to other bundles via an entry in the Export-Package manifest header.
We can also provide a default implementation for each of our interfaces in an impl or support package.
By adding this implementation package in our Export-Packages, other bundles can directly use these default implementations.
This practice works reasonably well, but it becomes dangerous when the default implementations expose too much of the owning bundle’s internals: the bundle will probably need to share more packages, and its clients will need to add the corresponding entries in their Import-Package headers.
This leads to tight coupling and to a system that’s less modular overall.
How can we make implementations available to consuming bundles without tightly coupling them? The answer lies in the factory pattern and the service layer of OSGi.
Let’s consider an example: we want a component that’s able to clean all the tables of a database.
It needs to be portable and to work on several database systems.
We’ll define the DatabaseCleaner interface and provide implementations for H2, PostgreSQL, and Oracle.
The DatabaseType enumeration defines the database system our bundle supports:
The bundle would end up with the following structure, with the new elements in bold:
Why should we rely on a lookup in the Spring container instead of using dependency injection? Mainly because an explicit lookup allows us to honor the bean scope as defined in the configuration (singleton, prototype, and so on) and to benefit from features like dependency injection.
The last thing to do is to configure the application context of our Spring-powered bundle:
That’s because they aren’t thread-safe, and a new instance is needed for each call to the factory.
This illustrates that we can rely on all the features of the Spring container without them having any effect on the interface of our OSGi service.
To conclude, the implementation provider pattern prevents implementations from leaking from a bundle.
Clients can’t create objects directly; they must use a factory implemented as an OSGi service.
All the clients need to see are the interfaces of.
Spring DM helps us publish the factory and lets the owning bundle leverage the power of the Spring container to wire its inner components.
Proxy-based AOP implies the manipulation of bytecode, and OSGi doesn’t make such manipulations particularly easy.
The class of a proxy is generated dynamically and defined in a specific classloader, which must have privileged visibility, because it has to see all the classes and interfaces that are blended in the proxy class.
Usually, these classes and interfaces have nothing in common; that’s the whole point of AOP—separation of concerns, with the target object not knowing anything about its decorator.
The creation of the proxy class is where all the parties meet, and OSGi doesn’t like classloader gatherings!
Let’s first see how proxy-based AOP works in a standard Java runtime.
The following snippet uses the Spring AOP API to decorate a business service with a security aspect:
But in OSGi, the visibility is restricted and the code of the previous snippet would fail.
Solutions would typically consist of importing the appropriate packages or using dynamic imports.
Unfortunately, both solutions are cumbersome, unmodular, and error-prone (in the case of dynamic imports)
Luckily there’s another version of the getProxy method that accepts a ClassLoader as its parameter and uses it to generate the proxy class.
By providing a classloader that has the correct visibility to the proxy factory (in bold in the following snippet), the creation of the proxy becomes possible:
Anything else to hide behind the service? An implementation provider can encapsulate more than different implementations (as in our example here)
Issues like dynamic class loading can be hidden behind the implementation provider, which relieves the client bundle from complex or even unpredictable configuration.
The onus is purely on the provider, yielding a clear separation of concerns.
We need to build it so that it can see all the necessary classes (figure 9.5)
This synthetic classloader is usually implemented by chaining the classloader of each entity.
Now that we have the chained classloader ready, we can modify our first snippet to make it work in OSGi:
Figure 9.5 The synthetic classloader aggregates the class space of each entity for the creation of the proxy class.
The decorating now works, but the client module (the one that needs its business service decorated) has too many dependencies on the proxy creator API.
We can easily encapsulate the decorating process in a dedicated module and provide it as an OSGi service.
This makes the decorating code simpler for the client bundle:
Like our OsgiProxyFactory, these utility classes aim to provide ready-to-use classloaders that hide the implementation details of the generation of proxy classes.
We exposed only the basics here; you’ll find that Spring DM’s chained classloader is more sophisticated than ours.
We neglected one aspect in our chained classloader pattern: dynamics.
What happens if the module that provides the aspect classes is stopped? Some dynamically created proxy classes rely on the aspects’ definitions, and they should therefore be destroyed and recreated.
Such a scenario would imply tracking and managing the created proxy classes, and this isn’t part of Spring DM’s feature set.
To conclude, the chained classloader is one way to merge the class space of entities that are unaware of each other in term of class visibility.
It makes it possible to use proxy-based AOP in an OSGi environment, where visibility is restricted to only what bundles need to see.
Congratulations if you read this whole chapter in one go! You now have a strong foundation for customizing Spring DM’s extenders, integrating the framework into managed and secured environments, and leveraging Spring DM to implement advanced OSGi patterns.
We saw in this chapter that Spring DM offers configuration hooks for both of its extenders.
This configuration is based on the fragment configuration pattern: the extenders’ bundles can be augmented with Spring configuration files that declare custom beans, which the extenders use in place of their default components.
The scope of this configuration is global: the configuration applies to all the bundles that Spring DM manages.
The extender configuration is also an entry point to the runtime environment: you can provide managed components to Spring DM and keep sensitive resources like threads under your control.
Spring DM can also run in a secured environment, where the OSGi container controls each bundle’s permissions precisely.
By providing the appropriate permissions to Spring DM’s bundles, the framework can run properly without breaking the security rules of the OSGi environment.
Lastly, we saw that OSGi has its own design patterns.
Knowing them can help you implement elegant design solutions without losing the benefits of modularity.
It also allows you to avoid common pitfalls in OSGi environments, where the visibility of classes is restricted to what modules need to see.
The implementation provider pattern is a way to keep a system modular, and Spring DM helps in the implementation of this factory-based pattern.
The chained classloader pattern aims to merge the class space of modules that aren’t aware of each other, allowing the use of proxy-based AOP in OSGi.
Testing is one of the most important activities in software development, not only because it ensures better quality in the end product, but also because good testing techniques can make a developer more productive.
We introduced Spring DM’s testing support early on in chapter 3 because manually testing the behavior of OSGi components in a target environment can be cumbersome, mainly because of tasks such as provisioning.
You discovered then that Spring DM provides support for bootstrapping an embedded OSGi container and running JUnit test classes in it.
This early coverage gave you the basics necessary to test your own OSGi bundles, and proved also that OSGi applications aren’t particularly special in this regard: they can also be tested.
In this chapter, we’ll cover all the techniques and the tools that you’ll need to test your OSGi components, and hence make your OSGi applications more reliable.
As software testing has its own vocabulary, this chapter starts by briefly describing the different kinds of tests (unit, integration, and system tests) and how they fit together.
This will give us enough of a basis to explain how OSGi applications (Spring-powered or otherwise) should be tested using Spring DM’s testing support.
We’ll then move on to cover unit tests and integration tests.
Unit tests are for testing classes in an isolated manner.
Most of the time, classes have dependencies on other classes or APIs (like the OSGi API), and these dependencies must be simulated by using mock objects (objects that mimic the behavior of real objects in a controlled way)
That’s where Spring DM can help, as it provides ready-to-use OSGi mocks.
Automating integration tests for OSGi components is a difficult task, because it consists of testing how different OSGi components behave in an OSGi container.
This implies bootstrapping and provisioning an OSGi container, and running the test instance within the OSGi container.
Fortunately, Spring DM provides powerful and flexible testing support that takes care of all these steps.
This testing support also leverages Spring and Spring DM features (like dependency injection and declarative interaction with the OSGi environment) and makes them available for use by the test classes.
This is another incarnation of the bridge that Spring DM provides between the OSGi and the Spring worlds.
By the end of this chapter, you’ll know everything you need to know about the practical testing of OSGi applications, and you’ll have all the techniques necessary to test your OSGi components efficiently, thanks to the testing facilities that Spring DM provides.
You’ll also be able to take advantage of the hooks that Spring DM testing support provides for Spring-based OSGi applications.
Let’s start with an overview of testing in software development.
Testing OSGi applications isn’t much different than testing standard applications, as long as you know the appropriate techniques and tools.
So before diving into OSGispecific testing practices, we’ll remind you of the different kinds of tests we encounter in software development.
We’ll provide guidelines for unit-testing Spring-based applications, and this will give us enough of a basis to understand how to organize the testing of Spring DM applications.
There are three different types of tests that are commonly encountered in software development:
Unit tests—These verify and validate an individual programming unit (a class in an OOP language like Java)
As a programming unit usually relies on other programming units, we usually resort to mocks and stubs to test it in isolation.
Integration tests—These verify and validate that several programming units work as expected in collaboration.
System tests—These verify a whole system by assembling all its components together (not covered in this book)
Testing programming units in collaboration is very difficult if they don’t behave as expected individually.
That’s why it’s vital to run unit tests before integration and system tests.
Figure 10.1 shows how an application composed of four programming units can be tested.
It reads from left to right to illustrate the order of testing.
We mentioned mocks and stubs, but we didn’t really explain them.
Mocks and stubs help with testing a programming unit in isolation by simulating the collaborators of the tested unit.
Stubs are usually developed for one specific test and provide canned answers to the (limited) set of calls they’re supposed to respond to.
They can also record information about calls that the test uses for verification.
Mocks are preprogrammed to answer to a sequence of calls and are usually able to tell if the sequence occurred correctly during the test.
Mock object libraries can be generic (like JMock or EasyMock), allowing you to create a mock object from any interface or class and dictate its behavior.
They can also be specific to a particular technology, such as OSGi (like the mock object library provided by Spring DM), networking, database, and so on.
Generic mock object libraries are very useful for mocking application classes (DAO, business services, and the like) but they can become cumbersome to use for mocking the same set of classes (like those specific to a technology) over and over.
Now that we know more about testing practices, let’s look at some guidelines for testing Spring-based applications.
Thanks to its POJOprogramming model and its lightweight container, applications based on the Spring Framework are easy to unit test.
Strict unit tests (which involve a class that doesn’t use any dependencies) can be written with plain test frameworks like JUnit or TestNG.
When testing a class that needs some dependencies (such as a Hibernate-based DAO, which needs a SessionFactory and so a DataSource), the Spring.
Figure 10.1 Unit tests, integration tests, and system tests are usually run sequentially, because testing programming units in collaboration is easier when they all behave as expected individually.
By bootstrapping a Spring application context for testing the classes of a module, you can benefit from the wiring features of the lightweight container but also from features like transaction management, AOP, and so on.
Figure 10.2 illustrates the organization of tests in a Spring-based module.
This terminology is a matter of point of view (the notion of a programming unit changes according to the view we adopt)
From the module’s point of view, we can call such tests integration tests, because we test the integration of inner components.
From the whole system’s point of view, such tests are internal to a module, whereas integration tests concern interactions between a set of modules.
What’s the best way to write tests that leverage the Spring Framework? You could do it by hand—by bootstrapping a Spring application context at the beginning of the testbut you’d end up writing the same sequence of code for all your tests.
The Spring Framework integrates well with test frameworks like JUnit and TestNG, thanks to the Spring TestContext Framework, which offers features like these:
Coverage of the Spring TestContext Framework is out of the scope of this book, but let’s take a quick peek at how it’s used with the following code snippet (from the code samples for this chapter):
Figure 10.2 In a Spring-based module, strict unit tests involve classes that don’t use any dependencies.
Tests can also embed a Spring application context when wiring or enterprise features are needed.
Because Spring DM promotes a POJO programming model, these tests shouldn’t imply the use of OSGi, even if the module is meant to be used in an OSGi environment.
Remember that such tests should be written before testing the classes in an OSGi container: the core features of a module should be thoroughly tested in the module itself.
Having fragile modules can make integration tests more difficult to write and makes diagnosing errors much harder.
Now that you have guidelines about testing the core features of modules, it’s time to see how to test them in their target environment—OSGi, in our case.
This is the goal of the next section, which covers how software testing applies to OSGi.
Testing an OSGi component involves testing how it behaves when it interacts with the OSGi environment.
It can either interact directly with the OSGi API or interact with the OSGi platform (by exporting or consuming services)
OSGi is all about modularity, and hopefully only carefully chosen parts of a component will interact with the OSGi environment.
This means that most of the component’s parts will be tested the usual way, with plain old unit and integration tests, by using the same techniques and tools we saw in the previous section.
This is especially true when using Spring DM, as it enforces a POJO programming model where the framework handles most (if not all) of the interactions with the OSGi platform.
Application classes, like business services or DAOs, should be thoroughly tested as in a normal, non-OSGi environment.
Then their basic operations (some of them, but not necessarily all) should be tested in an OSGi environment, to check that they behave as expected when used in their target environment and when they interact with other OSGi components.
Automating these tests is challenging as it requires running the tests in an embedded OSGi platform.
That’s where Spring DM can help, because it provides this support, along with other testing facilities.
As testing OSGi applications can be quite different from testing standard applications in terms of project structuring, we’ll also cover how to organize the layout of OSGi projects.
Tests for OSGi components can be roughly divided into two categories:
Unit tests—When a part of the component relies on the OSGi API (BundleContext, ServiceTracker, and so on)
Integration tests—When the component interacts with the OSGi environment (imports or exports packages, registers or consumes services, and so on)
For example, if an OSGi bundle has a BundleActivator that handles critical operations, writing a unit test for it is essential.
Such a test can be written by using OSGi mocks: specific mock objects that implement the OSGi API and whose behavior can be modified programmatically.
For testing a BundleActivator, we’d need at least a mock BundleContext.
By using such a construct, the unit test doesn’t need to be run on an OSGi platform—a plain old test framework is enough.
Spring DM provides a set of OSGi mocks, which we’ll study in section 10.2
Integration tests imply interactions with the OSGi environment that can’t be easily mocked.
In OSGi integration tests we want to check several things, such as that a bundle can be started, which means that the platform resolved all the Java packages it imports or that a bundle published a service with the correct metadata (which can be part of its contract)
These two tests can’t be done with mock objects; they require a running OSGi platform.
This means adapting test frameworks like JUnit to be able to bootstrap an OSGi platform, provision it, and run the test as if it were executing in OSGi.
In doing this, OSGi integration tests can benefit from the array of tooling available for test frameworks (IDE and build tool launchers, XML/HTML reports, and so on) and thus don’t need any special treatment.
Spring DM provides such support, which turns the test into an OSGi bundle on the fly and runs its methods in an embedded OSGi platform.
Now that the purpose of OSGi tests is clearer, let’s look at how to organize application projects to make their testing easier and more efficient.
Depending on the nature of the test, test classes can be located in various places, and this has ramifications for the project’s structure.
We’ll see how to organize standard non-OSGi tests, OSGi tests that use OSGi mocks, and OSGi integration tests.
Standard non-OSGi test classes (either unit or integration) usually reside in the same project as the classes they test.
Let’s take a data access bundle as an example: the tests consist of checking that all the DAOs do their data access job correctly (such as complex SQL queries)
The test classes are located in a dedicated directory, separated from the actual application classes.
The project also has all the necessary dependencies in its classpath (application classes like the domain layer, and technical libraries like Spring and Hibernate)
There’s no technical constraint that prevents the tests from being in the same project, which is convenient.
OSGi tests that use OSGi mocks can also be located in the same project as the classes they test (for example, an OSGi test that tests a bundle activator or any application class that relies on the OSGi API)
As the scope of these tests is quite limited (there’s no need for a full-blown OSGi platform running), the class tests are based on standard test tooling; the only difference is that they use OSGi mocks.
OSGi integration tests usually lie in a different project than the OSGi bundles they test.
As these tests provision an OSGi platform with the bundles they test, the bundles being tested must be properly packaged before the tests can be run.
The common sequence for OSGi integration tests is to build the to-be-tested bundles (compilation, “standard” tests, and packaging) and then run all the OSGi integration tests using a dedicated test project.
Figure 10.3 illustrates the structure of an OSGi application and how to organize the tests.
Note that the default behavior of Spring DM testing support is to provision the embedded OSGi platform from the Maven 2 local repository.
Figure 10.3 Standard tests and tests that use OSGi mocks are in the same project as the classes they test.; OSGi integration tests are in a separate project.
Even though Spring DM promotes a POJO-based programming model and handles most of the interaction with the OSGi environment, some parts of an OSGi bundle may still have to work with the OSGi API.
These parts can be bundle activators or Spring beans that leverage the OSGi bridges that Spring DM offers (like the BundleContextAware interface introduced in chapter 4)
Integration tests can be sufficient for testing these interactions as long as these OSGi-related tasks remain simple, but unit tests generally prove to be necessary when the interactions become more complex.
This section introduces Spring DM’s OSGi mock classes and provides some examples to illustrate their use.
Spring DM comes with a set of OSGi mocks that make OSGi unit testing easier.
Generic mock libraries (like EasyMock or JMock) are another possible solution, but using them for mocking an API as complex as the OSGi Framework is very cumbersome.
Spring DM itself is tested using a combination of its own OSGi mocks and mocks generated by EasyMock.
The OSGi mocks that Spring DM provides are not meant to be a full-featured OSGi mock library, but rather internal tools that the Spring DM Framework makes available to others.
Nevertheless, they make a good basis for OSGi unit tests—what’s good for the goose is good for the gander.
MockBundle Bundle Maintains bundle metadata and delegates loading operations to its own classloader.
MockBundleContext BundleContext Maintains a bundle object, a list of service listeners, and a list of bundle listeners.
Spring DM’s OSGi mocks maintain minimal features, but most of their methods are empty implementations.
Users are encouraged to subclass the mock classes in their tests (as with anonymous classes) and override only the methods they need.
Let’s see how to use some of Spring DM’s OSGi mocks.
Suppose you want to test a simple BundleActivator, like the one defined in listing 10.1
The bundle activator’s contract consists of registering a service and also taking care of the unregistration.
You should always try to use Spring DM’s declarative features for such tasks, because they’re more reliable and flexible.
Is there a full-featured OSGi mock library? Although generic mock libraries proliferate in the Java world, there’s no de facto standard for mocking the OSGi Framework.
The SpringSource dm Server team developed the OSGi test stubs library, which is still in its infancy at the time of this writing.
Nevertheless, it looks promising and is already used in the dm Server test suite.
A SpringSource Team Blog entry (http://blog.springsource.com/2009/06/23/ osgi-test-stubs/) introduces the OSGi test stubs library.
Figure 10.4 illustrates which implementation of bundle context the bundle activator will use when running on an OSGi platform (such as Equinox) and when running in a test.
This is made possible by the use of the BundleContext interface.
Listing 10.2 illustrates how to test the bundle activator using Spring DM’s mocks.
Listing 10.2 Unit testing the bundle activator with OSGi mocks.
Figure 10.4 Depending on the environment (an OSGi platform like Equinox, or test), the bundle activator uses a different implementation of BundleContext.
When running a unit test, we use the MockBundleContext, which doesn’t need any runtime environment.
The test method C tests both the start and stop methods of the activator.
Because each needs the bundle context as a parameter, we declare a BundleContext variable and use Spring DM’s MockBundleContext class for the implementation D.
We use an anonymous class to override the registerService method and increment the daoRegistered variable only if the OSGi service is a ContactDao.
At F, we execute the start and stop methods of the bundle activator and check that the counter is properly updated.
We can push our bundle activator a little further and make it register the OSGi service only if a DataSource is available in the service registry.
Unit testing the new version of the bundle activator implies testing two paths (for whether or not the DataSource service is available), which means two test cases.
Listing 10.3 New version of the bundle activator (with conditional service registration)
This ends our tour of the OSGi mocks available in Spring DM.
These mock objects should fulfill your needs when the interactions between your classes and the OSGi.
Integration tests for OSGi applications environment need comprehensive unit testing rather than more coarse-grained integration tests.
Speaking of integration tests, the next section covers Spring DM’s integration test support for OSGi applications.
When testing one or more OSGi bundles in their target environment (an implementation of an OSGi container), there are a lot of things that can go wrong, so checking them in an efficient way can save a lot of time, money, and sweat.
The main challenge with OSGi integration tests is to keep close enough to developers’ usual testing habits (such as using test frameworks like JUnit) while executing the test itself within a properly configured and provisioned OSGi container.
Fortunately Spring DM takes up this challenge and provides a testing framework that smoothly fills the gap between OSGi and JUnit.
Section 10.3.1 covers the basics of Spring DM’s integration test support through an example based on the data access layer of an enterprise application.
We’ll see in this section how to check common OSGi features, like the correct package exports for tested bundles and the consumption of registered OSGi services.
Section 10.3.2 then dives into more advanced features, like customizing the creation of the test bundle and changing the target OSGi platform.
As shown previously in figure 10.3, OSGi integration tests should be located in a dedicated project.
Creating this project is the first step when you start writing integration tests.
Once your test project is created, you’re ready to benefit from Spring DM’s test support.
We’ll see in this section how to create a simple integration test that only displays the OSGi platform we’re running and what it’s provisioned with.
This first test seems simplistic, but it will illustrate how Spring DM runs the methods of the test within an embedded OSGi platform that it starts on the fly.
Through testing this sample application, we’ll see how to provision the embedded OSGi platform to test the visibility of Java classes and how to test that OSGi services are properly registered and functional.
Spring DM’s integration test support lies in the test module of the project, so you’ll have to add the corresponding JAR to your project, along with the other Spring DM binaries.
Using Spring DM’s test support is then as simple as inheriting from a test base class, as shown in listing 10.5
This is because Spring DM depends on a release of the Spring Framework that isn’t available in Maven 2 repositories anymore.
The listings of this chapter don’t override this method for brevity’s sake, but the examples in the book’s source code do.
All integration test classes must inherit from this class B.
As for any test based on JUnit 3, every test method name must start with test if it is to be executed C.
Our test method simply displays information about the running OSGi platform D.
We can use such a property because the test class is turned into an OSGi bundle on the fly by Spring DM test support.
This ties you to JUnit 3.8 when using the Spring DM testing framework for OSGi integration test, but it doesn’t prevent you from using the Spring TestContext Framework or any test framework for testing the core features of your modules.
If you run the test either in your IDE or on the command line with a tool like Maven 2, you should see something like the following on the console:
You can achieve this by using the “fork” option that tools like Maven 2 or Ant provide.
If you’re curious and want to learn about the bundles that Spring DM provisioned the platform with, you can write a test method that lists the installed bundles:
If you execute this method, you should see output like the following on the console:
Note that because Spring DM’s extender is installed, any Spring-powered bundle should see its Spring application context bootstrapped.
This means that all the bundles listed in the previous console output must be available in the Maven 2 local repository (apart from the test bundle, which is created on the fly, and the system bundle, which must be on the classpath when running the test)
This also means that, when provisioning Spring DM test instances from your Maven 2 local repository, the JARs you refer to must be OSGi-compliant bundles.
We’ve now seen the basics of Spring DM’s test support.
We’re about to take advantage of the features provided by the class to test our OSGi bundles, Spring-powered or not, but before doing so, let’s introduce the sample application that will be our guinea pig for the tests.
The sample application we’ll use is part of a typical layered enterprise application.
Figure 10.6 illustrates the relationships between the bundles and the interactions with the OSGi service registry.
The sample application gives us the opportunity to test the following:
Figure 10.5 When running an integration test, Spring DM bootstraps an OSGi platform for the duration of the test.
The test class is turned into an OSGi bundle on the fly and is used to provision the platform.
By default, Spring DM provisions the platform with bundles taken from the Maven 2 local repository.
As shown in figure 10.6, our directory domain and directory DAO API bundles export packages that need to be visible to other bundles.
An integration test can consist in provisioning an OSGi platform with both bundles and trying to import packages from them to ensure that these packages are correctly exported by our bundles.
Note that such a test doesn’t involve any Spring-powered bundles: Spring DM integration support works for any kind of bundle.
Listing 10.6 Provisioning a test and testing the visibility of classes.
Figure 10.6 The to-be-tested application, composed of two API bundles and a Spring-powered implementation bundle that interacts with the OSGi service registry.
The test method contains instructions that force the loading of a domain class and of a DAO interface B.
Spring DM needs such explicit references to classes to detect needed Java imports and generate an appropriate manifest on the fly.
The test class compiles, but what we want is to ensure that the loading of these classes works correctly in an OSGi platform.
We need to return an array of Strings, each element corresponding to a bundle D.
When running the test, you should get a green bar, because the OSGi platform is correctly provisioned and the test bundle can see the classes and interfaces it needs.
You can comment out the provisioning part of the test and note that the test fails, as the domain class and the DAO interface are no longer available.
When Spring DM generates the manifest of the test bundle, it never imports packages that are in the test bundle.
What did we learn from this test? Spring DM scans the test class to detect dependencies and generate an appropriate manifest for the test bundle.
Because the test methods are executed in the OSGi platform, these dependencies must be available.
We use a Maven-like method for this, by locating bundles with their coordinates.
We’ve just seen how to test a typical export/import package scenario.
Let’s see now how to test whether bundles correctly interact with the OSGi service registry.
There are several conditions to be fulfilled for our DAO implementation bundle to work correctly: some packages need to be exported (the domain package and the package of the DAO API), the bundle must import them correctly, and it must register a DAO as an OSGi service.
Our integration tests will check that all these things work fine.
We wrote “integration tests”, plural, because we’ll explore different testing strategies.
This will also give us the opportunity to explore features of Spring DM test support.
Listing 10.7 shows the first version of our integration test.
At B, we create a lookup to get the DAO from the OSGi service registry (we test that there’s at least a service registered under the interface)
The core of our test is rather simple C: we call a method to retrieve Contact objects and check the size of the list (this implies that we know how many Contact rows there are in the DataSource we’re usingwe’ll see more about that later)
Should we test more than that? If we suppose the DAO is correctly tested in its owning module, we don’t need to do more in an integration test.
The latter uses the JdbcTemplate, so we also need to add some modules of the Spring Framework E.
Note the use of the getSpringVersion method, which is convenient for provisioning the test OSGi.
As the JDBC-based DAO implementation needs a DataSource service (as shown in figure 10.6), we need to provision the OSGi platform with a bundle that registers such a service.
That’s what we do at F, where we add a bundle meant for the test and another bundle for the corresponding database driver.
We don’t show its full code here for the sake of brevity.
This is just fine: the OSGi platform is provisioned with everything we need to test that the DAO implementation bundle works correctly.
We just have to run the test and wait for the green bar.
But we want more! Spring DM promotes a POJO programming model, and the lookup on the service registry denies this.
Listing 10.8 shows what could be the configuration of this application context: it looks up the DAO on the OSGi registry with the osgi:reference XML element.
The application context configuration leverages Spring DM’s osgi namespace to look up the DAO and create a contactDao bean.
This bean will be injected in the test instance at runtime, just by adding the corresponding property.
This configuration may look like overkill for a single OSGi service, but it can save you a lot of tedious code when you have more services.
Listing 10.9 shows a new version of the test that benefits from the injection.
Listing 10.9 Injecting the DAO into the test via its Spring application context.
The test now declares a contactDao property and the corresponding setter.
Spring DM uses the latter to automatically inject the contactDao bean.
This injection is made possible by the matching between the bean name in the application context and the name of the property in the test (the corresponding setter is mandatory)
The test method is then simpler B, as it doesn’t need the lookup anymore.
We need to override the getConfigLocations method C to tell Spring DM where to find the Spring configuration files.
We just saw how to look up an OSGi service via Spring DM and inject it in the test instance.
This is made possible by the Spring application context that Spring DM ties to the test instance.
The scenario we chose is a little complex, because it involves an OSGi lookup and then dependency injection in the test, but the application context of a test instance can be used for any operation.
You could, for instance, retrieve the DataSource service and inject it in a bean that inserts data into the database.
That’s exactly what’s done in the application context of the final version of our test:
This is the case for any package involved in the creation of the application context of the test.
Spring DM has no way to know about such imports, so we must explicitly inform it about them.
In our case, this can be done by declaring a dummy JdbcTemplate property in the test class:
You’re now aware of the basics of Spring DM’s test support.
We’ve covered how to test classic scenarios like package export/import and interaction with the OSGi service registry.
This introduction should be enough for most of your OSGi integration tests.
We’re about to look at some of these hooks, which will allow us to dive further into the mechanics of test-bundle generation.
We’ll then apply this knowledge to customizing the creation of the test manifest and to changing the OSGi platform the test is run under.
Before running the test methods, Spring DM turns the test instance into an on-the-fly bundle before provisioning the OSGi platform with it.
Why not embed the DataSource in the test application context? The DAO implementation bundle needs a DataSource available in the service registry to work correctly.
We developed a dedicated bundle that creates and registers such a DataSource for our integration test, but wouldn’t it be simpler to do this directly in the test application context, to avoid developing a dedicated bundle?
Yes it would be, but there’s a reason we did what we did.
This means the creation of the test application context is triggered after the creation of the Spring-powered bundles.
If the DataSource service is a mandatory dependency of the DAO implementation bundle, Spring DM won’t complete the creation of the corresponding application context.
As the DataSource service is provided by the test application, which will start only after the creation of all application contexts, we’re in front of a deadlock: the test doesn’t run, it hangs.
What should we do then? We can make the DataSource service an optional dependency of the DAO implementation bundle, but if the DataSource must remain mandatory, this isn’t an option.
If you choose this path, remember that the test methods can be run before all the Spring-powered bundles have completed their initialization.
Table 10.2 lists these methods as well as methods that change the default behavior of test execution.
We can order the methods of table 10.2 into different categories.
We’ll start by covering those meant to customize the content of the test bundle, but first we need to study the principles of this customization.
Spring DM offers two ways to configure the content of the test bundle:
Table 10.2 Test methods to override to change the behavior of the test execution.
The list of packages whose loading is delegated to the boot classloader.
By default, all the content of the root path is included in the test bundle, and narrowing the included files by using appropriate patterns can speed up bundle generation, which matters when the number of integration tests grows.
Very specific integration tests may also need a very specific bundle manifest that Spring DM can’t automatically generate.
Table 10.3 lists the customizable content of the test bundle and the corresponding elements (method or property keys) for both configuration approaches.
Listing 10.10 shows how to customize the test bundle content programmatically.
The following snippet shows a properties file that performs the equivalent of listing 10.10:
We’ve now covered the ways Spring DM offers to customize the content of the test bundle it generates.
The manifest is one element of this configuration; let’s see how we can create it instead of relying on its automatic generation.
By analyzing the test class, Spring DM is able to generate an appropriate manifest for the on-the-fly bundle.
This is particularly convenient when the test depends on classes that are exported by other bundles; Spring DM automatically adds the correct ImportPackage entries.
But sometimes the automatic manifest generation isn’t enough, and we need to explicitly provide the manifest of the test bundle.
We saw previously how to indicate the location of a specific manifest file (either programmatically or declaratively), so let’s see now what it should contain.
The manifest needs specific entries for the test to run correctly as an OSGi bundle in the Spring DM test framework.
The first entry is the bundle activator B, and the second is the importation of packages related to the test infrastructure and the execution of the test methods C.
The packages of the test infrastructure are mandatory for every Spring DM test.
Packages that are used inside the test methods must also be specified.
The manifest must also meet the usual conditions of its folks (such as having no more than 72 characters on a line)
With all these conditions, you can certainly understand that Spring DM’s automatic manifest generation is worth using!
We thoroughly covered the customization of test bundles, so let’s finish our tour of Spring DM’s test support with the choice of the OSGi platform the tests run under.
This means that you can easily change the platform that tests are run under to check the portability of your applications.
Spring DM offers two ways to choose the OSGi platform:
Listing 10.12 shows how to switch to Felix, using the programmatic approach.
This programmatic approach is simple, but it ties the test to the platform.
Let’s look at the declarative approach, which doesn’t interfere with test classes.
The property must take as a value the name of the OsgiPlatform class you want to use.
Spring DM provides an implementation for each platform it supports.
How you specify the system property depends on the way you launch your tests.
The declarative approach is meant to be used with build tools: running the whole test suite on different platforms becomes just a matter of configuration.
Each build tool has its own way to set system properties.
Maven 2 uses the surefire plug-in to run tests, and system properties must be set in the configuration of this plug-in.
This happens to be in the build section of the POM, as shown in listing 10.13
Note that the platform binaries need to be in the classpath of the project; otherwise Spring DM won’t be able to create the embedded instance.
When using Maven 2, profiles are a good way to switch from one platform to another: you declare a profile for each platform with the corresponding dependencies and the surefire plugin configuration.
You now know how to change the platform in Spring DM tests.
Table 10.4 summarizes the constants (for the getPlatformName method) and the OsgiPlatform implementation (for the system property) for each platform Spring DM supports.
This ends our tour of the advanced features of Spring DM’s testing framework.
We looked at the basics of this testing framework and how to test classic classloading and.
Thanks to all the features the testing framework offers, writing integration tests for OSGi and Spring DM applications is the same as for any application.
Testing OSGi-based applications isn’t much different than testing traditional applications.
Thanks to the POJO programming model that Spring DM promotes, most parts of OSGi components can be tested with common testing techniques and tools, without knowing they’re meant to be run in an OSGi container.
So adopting OSGi won’t require that you lose your testing habits (build tools, continuous integration, and so on)
Nevertheless, OSGi brings with it a set of features like package visibility and services that need to be tested within an OSGi container.
That’s why Spring DM provides powerful testing support, which makes OSGi integration tests easier to write and run.
More importantly, they’re very similar to regular Java tests, because Spring DM builds on top of JUnit.
This support takes care of bootstrapping an OSGi container, provisioning it with bundles that the test class specifies, and running the test methods in the container.
The test is then run in an environment that mimics as much as possible the target environment.
Spring DM’s testing support not only makes available all of OSGi’s features to test classes, it also adds some Spring goodies like dependency injection to the test.
Spring DM still fulfills its role as a bridge between the Spring and OSGi worlds.
We’re now done with Spring DM’s testing support; the next chapter is dedicated to another part of OSGi for which Spring DM provides support: compendium services.
The chapters in this part of the book cover advanced aspects of Spring DM.
In the two previous chapters, we dealt with advanced configuration and unit tests.
In this chapter, we’ll describe features corresponding to additional OSGi specifications.
Besides the core OSGi specification, the OSGi alliance provides an additional specification describing standardized services called compendium services.
The range of these services is wide—the services can be specific to environments other than enterprise applications.
But some of them can be useful in the context of Spring DM because they allow for the centralization of certain behaviors and provide a level of indirection between the components and tools of an OSGi system.
They can enable configuration and events to be externalized from Spring Support for OSGi compendium services.
The framework offers mechanisms that can transparently link configured beans with these services.
In this chapter, we’ll explain what compendium services are and the benefits of using them with Spring DM.
Only the Configuration Admin Service and Event Admin Service compendium services are of interest to us in this context; Spring DM provides support for using them optimally and in a nonintrusive way.
The Configuration Admin Service allows us to externalize configuration properties in a centralized repository independent of Spring DM, and the Event Admin Service handles events without knowledge of Spring DM.
Before describing Spring DM’s support for compendium services, we need to describe at a high level what compendium services are and the benefits they offer.
Then we’ll be able to see how Spring DM takes advantage of these services.
As you saw in the first chapters of the book, the core of the OSGi technology is a standard that’s described in the OSGi core specification.
OSGi also comes with the compendium services specifications that build on the features provided by the core specification.
Each compendium service addresses a particular requirement and can be used on any conformant OSGi platform.
Only the APIs and their corresponding behavior are described in the specification.
The implementations aren’t standardized and are left up to providers.
Log Service Standardizes the handling of log messages within an OSGi framework.
When using this service, every message should be sent to it.
The service is then responsible for dispatching logs to bundles that are subscribed to it.
Provides a standardized and flexible approach to both receiving configuration information and configuring the framework.
Provides a mechanism for matching a driver to a new device and, when this occurs, allowing the bundle implementing the driver to be automatically downloaded.
The service can be typically used to implement plug-and-play features.
Runs as a database containing user information that’s usable as a foundation for security features (authentication and authorization)
Allows for declarative management of service registration and unregistration based on configuration files without having to directly use the core OSGi API.
Some of the services in table 11.1 target embedded systems, where others can be used for those systems as well as for classic Java applications.
In the context of this book, the Configuration Admin Service and Event Admin Service are particularly relevant, because they can provide additional functionality when using Spring DM.
Spring DM also provides integration for some of them that makes their use easier while implementing their features in a standardized way.
The HTTP service seems to be suitable for the web part of enterprise applications, but it unfortunately doesn’t allow the use of bundles as web applications and it has other limitations that make it inconvenient to use.
The upcoming RFC 66 specification addresses this and is to be preferred in the future.
Let’s now look at the two compendium services Spring DM provides support for: the Configuration Admin and Event Admin Services.
In this section, we’ll look at the benefits of using the compendium services with Spring DM.
We’ll first describe the two compendium services Spring DM provides support for, then we’ll see how to declare the dedicated XML namespace that Spring DM provides for interacting with them.
The most interesting compendium service in our context is the Configuration Admin Service.
Provides access to a hierarchical database of properties, similar to the Windows registry or the Java Preferences class.
Simplifies handling dynamic aspects of services by providing an XML-based declaration of the dependencies.
Provides facilities to handle an additional format for deployment: the deployment package.
This package can combine bundles with arbitrary resources into a single deliverable that can be installed and uninstalled.
Provides a standardized and centralized service to manage events triggered by entities used within the OSGi container.
It’s based on an event channel called topic, which makes it possible for entities to subscribe to, receive, and send events.
Provides a way to manage OSGi bundles through an application model, providing the ability to start and stop applications like in a typical desktop or mobile phone application.
Using the Configuration Admin Service within Spring DM consists of configuring the properties of beans.
This strategy allows the configuration to be shared across components and beans that are parameterized from outside the owning components.
Moreover, because the service is standardized, third-party configuration tools can be used to manage it.
Thanks to the osgix XML namespace (which will be described shortly), Spring DM can inject values retrieved from the Configuration Admin Service into beans’ properties.
The aim of Spring DM is to interact with the Configuration Admin Service in a nonintrusive way, without explicitly referencing it, thus enforcing the POJO programming model.
Another interesting compendium service is the Event Admin Service, which provides a standardized way of exchanging events between components using a central dispatcher.
The main advantage of this service is that consumers need not be aware of the event producers.
Figure 11.2 shows how the Configuration Admin Service provides a central service for event management.
Figure 11.1 Interaction between components and the Configuration Admin Service in order to externalize configuration properties outside Spring DM.
The Event Admin Service is interesting because it can notify components of events triggered by Spring or Spring DM without being tied to the event management and the APIs of the two frameworks.
Event listeners can be made independent of the tools that are sending events.
Although Spring DM doesn’t currently provide support for the OSGi Event Admin Service, developing a bridge between this service and Spring DM’s event management isn’t too difficult.
The only drawback is that you need to develop an asynchronous delivery mechanism if one is not supported by the tool triggering the initial event.
Spring DM’s standard XML namespace mainly covers the interaction of Spring DM with the OSGi service registry, but it provides no support for compendium services.
This namespace enables us to interact directly with the Configuration Admin Service within a Spring XML configuration.
The namespace can be configured using all the usual facilities and mechanisms provided by XML, as shown in listing 11.1
In this listing, the namespace is first linked to its identifier.
The XML schema file is then associated with this identifier, allowing the XML parser to check the validity of the XML elements used in the namespace.
Now that we’ve seen how compendium services work with Spring DM and how to configure the corresponding XML namespace, let’s delve into the details of using the Configuration Admin Service with Spring DM in order to externalize configuration properties.
The main compendium service supported by Spring DM is the Configuration Admin Service because it provides support for centralizing configuration information.
Spring DM allows XML elements of the osgix namespace to be used within a Spring.
In this section, we’ll first cover how to use the Configuration Admin Service to manage configuration properties.
We’ll then see how to link beans with configuration properties and implement managed services and managed service factories.
Before using Spring DM’s osgix namespace to configure the Configuration Admin Service, we need to install the Configuration Admin Service bundle, reference the corresponding OSGi service, and update data within its configuration repository.
As with every compendium service, you can distinguish between the components containing service interfaces and components providing implementations.
The service’s public API and implementation are commonly separated into different components.
We’ll use the implementation of the Configuration Admin Service provided by Equinox for this example.
The component containing the public API of a compendium service and its implementation in Equinox are both available in the SpringSource EBR as shown in table 11.2
Adding these two components to your OSGi container will install the Configuration Admin Service.
This service can be referenced using Spring DM like any other service—by using its reference XML element within a Spring XML configuration.
It can then be injected into any bean, as shown in the following snippet:
Before describing Spring DM’s support for the Configuration Admin Service, we’ll first look at how we can update configuration data.
The ConfigurationAdmin class allows you to interact with the Configuration Admin Service to access and modify configuration data.
The service class provides access to this data through persistence identifiers.
Its getConfiguration method allows you to get the configuration for a given identifier, represented by an instance of the Configuration class.
This class gives access to a property dictionary and some methods for managing the configuration.
The following code provides demonstrates the use of these classes and methods.
On this Configuration instance, the properties are gotten with the getProperties method.
If properties are null, they can eventually be initialized to an empty map by using the update method of the Configuration instance.
As you can see, properties for a given configuration identifier correspond to a map that can be updated.
When it’s created, this map is null, and you need to initialize it.
You can then either use this map or specify a new one.
In either case, the update method is used to save updates to configuration properties.
The Configuration class also allows you to delete configuration properties by using its delete method.
Listing 11.3 shows how to set properties for a configuration identifier.
You’ve now seen how to install, reference, and use the Configuration Admin Service to access and update configuration properties.
It’s time to look at how Spring DM’s support for this service allows you to simplify and centralize the configuration of bean properties.
Spring provides support for configuring properties from different sources through the properties tag of its util XML namespace.
Spring DM similarly allows you to configure properties stored in the Configuration Admin Service by using its osgix XML namespace.
The Configuration Admin Service’s persistence identifiers Persistence identifiers act as primary keys for objects within the configuration repository, and they must be unique within this repository.
They allow you to get the corresponding Configuration object by using the Configuration Admin Service’s getConfiguration method.
Persistence identifiers should follow the symbolic name syntax of bundles, which uses a restricted character set.
This particular feature can be implemented using the cm-properties tag.
This tag allows configuration properties for a persistent identifier to be retrieved, as shown in the following snippet:
By default, properties defined by the element are used if no corresponding keys are found in the Configuration Admin Service, but this behavior can be reversed by using the localoverride attribute.
This attribute’s default value is false; setting it to true forces the use of the specified default, regardless of whatever data is present in the Configuration Admin Service.
The following snippet shows how to use default values with the cm-properties element when keys aren’t present in the Configuration Admin Service repository.
Default values can be simply set within the XML element using the prop XML element.
These properties can then be used to configure the different attributes of the data source.
This approach allows global configurations to be defined across components in a centralized repository managed by the Configuration Admin Service.
But be aware that modifying this configuration requires restarting all affected components so they can take into account the new values.
As well as providing support for properties, Spring DM further supports the Configuration Admin Service by enabling tight integration between beans and the service.
Spring DM provides managed entities for both the OSGi services and service factories.
The Configuration Admin Service provides a useful feature that allows components to be notified when updates occur within a dedicated configuration space.
We’ll first look at how to use this feature together with Spring DM by implementing these interfaces, and then we’ll see how the framework leverages this feature by providing declarative support.
To do this, your services and service interfaces must implement one of these interfaces.
The following snippet shows an example of such a service.
Implementing the ManagedService interface allows the Configuration Admin Service to detect that the service is eligible for configuration updates.
When updates occur, the updated method of the service will be called with the updated properties as the function argument.
After implementing the class of the managed service, the service needs to be configured and exported as an OSGi service using the facilities of Spring DM, as shown in listing 11.4
The cm-properties tag and dynamics With early 2.0 versions of Spring DM, values contained in the properties corresponding to the cm-properties tag are lazily loaded on first access and remain unchanged after this.
With the following version, this behavior will be changed to support dynamic updates occurring after first access.
The bean can then update the system according to the new configuration.
Spring DM allows you to remove this dependency by providing declarative support for managed entities.
The first case of declarative support for managed resources we’ll consider is that for managed services.
This feature doesn’t require you to implement the ManagedService interface, but services can still be automatically notified when updates occur.
Two strategies are provided by Spring DM, but by default no strategy is used:
The bean is locked during the operation by a synchronized clause.
In this case, there is no lock, and it’s up to the class to decide how to update fields.
In both cases, the configuration of managed entities is done using the managed-properties element of Spring DM’s osgix XML namespace within the target bean’s configuration, as shown in the following snippet:
In this snippet, Spring DM uses the default container-managed strategy.
It corresponds to explicitly specifying a value of container-managed for the update-strategy attribute of the managed-properties element.
Property names must correspond to field names for a match to occur.
Corresponding setter methods are used by Spring DM to inject values.
If no property is found for a field, its value remains null.
Moreover, if a value is specified for a field using classic dependency injection, this value is overridden by the value found in the Configuration Admin Service.
Switching to the bean-managed strategy is simple, and is done by using the updatestrategy attribute of the managed-properties XML element.
Moreover, you need to specify with the update-method attribute which method will be called when updates occur.
The method signature must accept a map as its only parameter and return void, as shown in the following snippet:
Within the managed-properties XML element, the update-strategy attribute is used to specify the bean-managed strategy and the update-method attribute for the method used for updates.
Now that we’ve seen Spring DM’s convenient and declarative support for managing OSGi services through the use of the Configuration Admin Service, let’s take a look at the support the Spring DM framework provides for managed service factories.
Spring DM’s Configuration Admin Service support includes a managed service factory feature that handles configuration data for services with multiple instances.
This approach is suitable when OSGi components need to configure OSGi services with different configuration values.
The managed service factory allows you to link managed service instances with particular configurations for a persistence identifier.
With its support for managed service factories, Spring DM automatically creates and registers an OSGi service when a configuration element is added for managed service instances.
Spring DM then manages updates and deletions according to the configuration.
This XML element refers to the corresponding configuration identifier within the Configuration Admin Service repository and uses an inner bean template to create OSGi service instances.
The next step is to configure the bean template to create OSGi services for a configuration elementthis is done with a classical inner bean XML element.
Default values can be defined in this template if necessary.
An inner interfaces XML element can be used to specify several interfaces.
Specifies how the context classloader is managed when an operation is invoked on the exported service.
Possible values are unmanaged (by default) for no management and service-provider to make the context classloader see elements of the bundle exporting the services.
The same values as for the service element can be used.
The disabled value allows the developer to specify interfaces by hand.
The interfaces, class-hierarchy, and all-classes values autodetect interfaces based on different strategies.
By default (a value of none), no strategy is specified.
Other values correspond to those for Spring DM’s support of managed services: bean-managed lets the bean update fields and container-managed specifies updates done by Spring DM via setter methods.
For more details, refer to the previous subsection in this chapter.
Spring DM provides declarative support for the Configuration Admin Service, which enables transparent integration between beans configured in Spring DM and the configurations managed by this compendium service.
This support makes it possible to centralize the configuration of bundles in a single configuration repository.
We’ll now take a look at how to make Spring DM interact with the Event Admin Service, which provides standardized event management within the OSGi environment.
This interaction enables you to handle Spring DM events without being linked with the framework.
The Event Admin Service is another useful compendium service that allows for the standardized exchange of messages between components.
At the moment, Spring DM doesn’t support this service directly, but it’s possible to implement a bridge between Spring and Spring DM events and the Event Admin Service.
We’ll first explain how to install and use the service and the concepts behind linking Spring DM to the service.
Before using the Event Admin Service with Spring DM, we need to know how to install it, how to reference the corresponding OSGi service, and how to send and receive events.
The same bundle that provides support for the Configuration Admin Service can be used here, because it contains the public API for all compendium services.
The bundle provided by Felix is available in the SpringSource EBR, as detailed in section 11.2.1
Table 11.4 lists the components needed to install the Event Admin Service from the SpringSource EBR.
Adding these two components within your OSGi container will install the Event Admin Service.
This service can be referenced using Spring DM just like any other service, by using its reference XML element and then injecting the result into any bean.
This service can be then injected in the eventAdminManager bean using its eventAdminService property.
The EventAdminManager class configured in the preceding snippet contains a configured reference to the installed Event Admin Service, enabling the class to interact with it.
Now that the eventAdminService property is set, all the methods of the EventAdmin interface can be used to interact with the service.
Before describing how to implement a bridge between Spring DM and the Event Admin Service, we’ll first see how to exchange events.
The Event Admin Service is primarily used to send events.
This can be done explicitly using the EventAdmin service that we automatically registered.
This service provides a sendEvent method that takes an event object to send an event.
The Event Admin Service can also implement event listeners based on the whiteboard pattern.
These listeners must implement the EventHandler interface, and they have to be registered as OSGi services.
When an event occurs, the Event Admin Service dispatches the event to all the registered implementations by calling their handleEvent method.
The following snippet shows a sample implementation of the EventHandler interface.
Event data can be accessed using properties contained in the instance of the Event class passed as arguments to the handleEvent method.
The event topic has the same value as the topicName variable used to send the event.
Now that you know how to use the Event Admin Service to send and receive events, let’s see how we can use it with Spring DM.
Spring DM and Spring raise a set of events during their normal operation.
Applications, and components, in our case, can register event listeners to be notified of these events when they occur.
These system elements then use their own strategies for implementing event handling and delivering messages.
The scope of this event system is restricted to the owning Spring application context, and with this framework events are propagated synchronously.
In Spring DM, events are intended to be consumed by bundles other than the one that triggers them.
Event handling is based on the whiteboard pattern, which allows for the decoupling of event producers from their consumers and provides support for registering and unregistering listeners dynamically.
In the context of this pattern, delivery has important requirements because OSGi is dynamic and the implementation mustn’t freeze the entire system.
For this reason, Spring DM delivers events asynchronously to registered listeners.
In the next sections, we’ll describe how to link Spring DM and Spring events to the Event Admin Service.
When events occur in either framework, they’re redirected to this service.
To do so, the listener builds an event compatible with the Event Admin Service using data contained in the initial Spring DM event and then sends it using the EventAdmin service API.
This listener isn’t provided by Spring DM and needs to be implemented.
Figure 11.3 summarizes the steps for implementing the link between Spring DM events and the Event Admin Service.
Spring DM dispatches events to these listeners registered as services following the whiteboard pattern.
The bridge listener references the EventAdmin service through the OSGi service registry and sends events to the Event Admin Service when it receives events from Spring DM.
Every class registered as a listener on the Event Admin Service will then be notified.
This mechanism allows for third-party bundles to receive events and notifications from Spring DM without having to be tied to its use.
With Spring, things are a little different because its event management is completely independent from OSGi, and event listeners must be directly defined within the Spring application context.
Having detected all these configured classes, Spring notifies them when an event occurs.
For our purposes, we can use a special Spring application listener that receives these events and forwards them to the Event Admin Service.
Figure 11.4 summarizes the steps for implementing the link between Spring events and the Event Admin Service.
Spring dispatches events to these listeners configured within the Spring container.
The bridge listener then references the EventAdmin service through the OSGi service registry and is sends events to the Event Admin Service when it receives events.
Every class registered as a listener on the Event Admin Service will then be notified.
This mechanism allows for third-party bundles to receive events and notifications from Spring without having to be tied to the framework.
Note that the bridge listener must deliver events asynchronously for the reasons discussed at the beginning of section 11.3.2
Now that we’ve described how to have events triggered by Spring and Spring DM dispatched to the Event Admin Service, we’ll focus on how to implement the bridge listener for Spring DM events.
Having registered this listener as an OSGi service, this class will then be able to handle Spring DM events and forward them to the Event Admin Service.
This method is called when an event is triggered and is responsible for handling it correctly.
Because the class provides the link with the Event Admin Service, it has an attribute of type EventAdmin.
We’ll configure this attribute later on by using the corresponding EventAdmin OSGi service referenced with Spring DM facilities.
The first step in building the event is creating the name of the topic on which the event will be published.
Topic names allow classification of topics using tokens separated by the slash (/) character.
The following snippet shows how to use the class name of the Spring DM event to build the topic name:
Properties for the event then need to be specified—they should contain all the information describing the event.
In our context, this information can be obtained from the event instance provided by Spring DM.
Listing 11.8 shows how to build properties for an event compatible with the Event Admin Service.
This instance can then be used when using the sendEvent method of the EventAdmin instance to send the event.
Because this listener uses the EventAdmin service, it first needs to be referenced using Spring DM’s facilities.
The listener itself can then be configured as a bean in the Spring application context and exported as an OSGi service with the same facilities.
Once these configurations are done, the listener is ready to receive events from Spring DM and forward them to the Event Admin Service.
In this section, we saw how to implement and configure a bridge listener that receives and forwards Spring DM events to the Event Admin Service.
This listener is primarily a Spring DM listener that builds a new Event Admin Service event from the initial Spring DM event and sends it to interested parties via the EventAdmin service.
Let’s look now at how to implement listeners in Spring DM that can receive and handle events triggered by the Event Admin Service.
Creating event listeners for the Event Admin Service involves implementing the EventHandler interface, which requires defining a handleEvent method that is called whenever an event occurs.
From the event instance passed as a parameter, we can get the topic names and the properties of the event and iterate through them.
You can take advantage of this to define an event handler that receives a set of event kinds.
This means using hierarchies when creating event names is very important.
Listing 11.11 shows how to configure a listener for the Event Admin Service using Spring DM’s facilities.
The listener is configured as bean within the configuration and then registered as an OSGi service with Spring DM’s service XML element.
Within this element, the topic names are specified in service properties with the event.topics key.
For each event, the handleEvent method is called with the event instance passed as a parameter.
We’ve now seen how to use the Event Admin Service with Spring DM, even though this compendium service isn’t directly supported by Spring DM.
In addition to its core specification, OSGi provides a specification describing a set of standardized services called compendium services.
These services range from embedded technologies to web support, and some of them are useful in conjunction with Spring DM.
That’s particularly the case with the Configuration Admin Service, which allows for the centralization of configuration properties.
Using this service with Spring allows us to leverage configuration management and to share configurations across components.
Spring DM provides non-intrusive support for automatically injecting configuration properties into beans.
It provides a standardized way of exchanging events between components—event producers and consumers don’t need to be tied to a particular API.
Although Spring DM doesn’t provide support for this service, a bridge can be implemented to forward events triggered by Spring or Spring DM to the Event Admin Service.
This allows components to be notified without having to use the API provided by these two frameworks.
The Blueprint Service (RFC 124) is the most recent addition to compendium services and it aims to standardize Spring DM.
In chapter 12, we’ll take a look at all the concepts involved in this specification.
In this chapter we’ll describe and discuss the Blueprint specification and show how you can use it both standalone and together with Spring DM.
Because it’s the reference implementation, Spring DM 2.0 fully supports Blueprint, and it’s likely that many customers will choose to use Blueprint instead of Spring DM because of its standard status.
Fortunately Blueprint isn’t very different from Spring DM—all the concepts are the same.
In fact, Blueprint can be thought of as a dialect of the Spring DM language, so you should have no trouble at all understanding and using it.
So without more ado, let’s dive right in! The Blueprint specification.
In the previous chapter, we looked at the OSGi compendium services and how they.
Spring is what is known as a de facto standard—it’s a standard simply because so many people use it.
There is no Spring specification—Rod Johnson and his team at Interface21 simply implemented a clever solution to a thorny problem and documented what they did after the fact.
The fact that so many people then used it serves to demonstrate how attractive and suitable the solution was.
Many standards that people are used to, however, such as Java EE and all its constituent components, are developed as open standards.
In this section, we’ll discuss the history, goals, and scope of Blueprint, set in the context of open standards and their importance to the software industry.
It’s rare that anything remains a de facto standard for long.
Widespread adoption usually indicates a ripe technology market that attracts other entrants.
For customers, there is nothing worse than multiple technology offerings that do different similar things but that are generally incompatible with each other.
The so-called “vendor lock-in” that results has historically been treated with a great deal of fear and loathing by customers and often causes the market as a whole to grow at a reduced rate.
An open standard is generally open for anyone to implement and use (although the licensing terms vary), and vendors must then compete on quality of implementation.
Customers meanwhile get to use technology from different vendors in a broadly similar way, not only reaping the benefits of common training, knowledge transfer, and support but also benefiting from increased competition in the marketplace and hence decreased costs.
That’s why standards are good for customers, but interestingly they’re often good for vendors as well because standards have been shown to grow the overall market.
The genesis of Blueprint Spring DM’s genesis was a little different from that of Spring.
Over the next few months Adrian Colyer developed his ideas with input, and some limited development effort, from both Oracle and BEA.
As the nascent Spring DM took shape in code, a specification was written by Adrian Colyer to keep all the players headed in the same direction.
The implementation also evolved dramatically under the expert guidance of Costin Leau from Interface21
Most standards are developed by a standards organization because vendor-led standards will be viewed with suspicion by the competition.
OSGi is no different, being developed by the OSGi Alliance.
OSGi standards require more than just a specification document describing what is supposed to happen.
All OSGi standards also require a reference implementation (RI) and a technology compatibility kit (TCK), which is a suite of tests to check the conformance of any implementation.
This means that anyone can implement the specification and then physically check whether it’s conformant by running the TCK.
The original request for proposal (RFP) that spawned the Blueprint specification was called “A Component Model for OSGi.” The intent of the specification was to standardize the groundwork laid by the Spring DM (back then, Spring-OSGi) project so that enterprise developers could target the OSGi platform.
In particular, the RFP identified several features lacking in the existing crop of OSGi specifications:
Fortunately, at the same time a group was being formed inside the OSGi alliance tasked with developing specifications for enterprise customers—the so-called “Enterprise Expert Group.” This was perceived as an ideal vehicle to take Spring DM from a proprietary standard to a published, open standard.
Thus, with the full support of both BEA and Oracle, Adrian Colyer embarked on the tricky task of creating an open standard for Spring DM, which, because it relied so heavily on Spring itself, meant creating a partial standard for Spring too.
Generally it’s wise for the RI and TCK to be developed by different companies so that there are no implicit erroneous assumptions in either specification or implementation.
There was little component-level support for the dynamic nature of the OSGi platform.
Of course, Spring DM already addressed these deficiencies, and initially there was a feeling that perhaps the Spring DM specification could simply be rubber-stamped for inclusion in the OSGi Alliance’s suite of specifications.
Over time, however, the Blueprint specification evolved to something more of a compromise as it became clear that to be self-contained it was not sufficient to simply standardize Spring DM; parts of Spring itself would need standardizing as well.
Initially the scope of the Blueprint specification was to replicate in a standard the scope of the Spring DM specification and project.
But because of the need to standardize parts of Spring, it became necessary in the interests of time to trim down the scope to the bare essentials.
Out went some of the more esoteric extensions of Spring DM, out went the specification of namespace handlers, out went annotation support.
In fact, out went anything that was deemed noncore, or that was in danger of requiring too much further expansion in order to be complete.
In fact, as we look at the Blueprint way of implementing and accessing OSGi services, the biggest change you’ll notice—apart from the change in naming—is the things that are missing.
What does Blueprint look like in actuality, and how do we use it?
Perhaps it’s easiest if we start by listing the Blueprint XML elements available and their Spring DM equivalents.
The importance of Blueprint Why are we discussing Blueprint at all? You may know already, because your organization may aggressively advocate and adopt open standards.
All other things being equal, given the choice between an open or proprietary standard, most organizations will choose an open standard.
Thus Blueprint, as the Spring DM standard, is likely to be quickly adopted by many organizations using Spring DM and also by organizations currently hesitant to use Spring DM.
It’s therefore likely that the growth of Blueprint will be rapid and at the expense of Spring DM.
This should not concern you—Spring DM and Blueprint are sufficiently similar that your education so far will set you in good stead for the future.
Table 12.1 compares the Blueprint schema elements with their Spring DM equivalents.
Simple! As you can see, the key elements supported by Spring DM are also supported by Blueprint and they have mostly the same names.
So why don’t we end the chapter right here? After all, you now have what you need to know in order to write Blueprint components.
Not quite so fast—there are a number of details in Blueprint that are subtly different from Spring DM.
There is no direct equivalent to type-converters because Spring employs a number of schemes to convert source properties to a type compatible with the target.
You can see that apart from the top-level blueprint tag, the XML looks identical to a Spring DM application context file.
Each top-level element is a top-level manager of a specific type and has a specific component metadata type, which we shall look at later.
Managers manage component instances and they have a defined lifecycle similar to the lifecycle of Spring DM elements.
Blueprint bundles are constructed in much the same way as Spring DM bundles.
Other artifacts and resources, such as classes and properties files, should be put in their regular bundle locations.
The Bundle-Blueprint manifest header can be used to modify the search location for Blueprint metadata, so the default search location could be represented by.
With these minor differences in mind, we’re ready to build and run our first Blueprint bundle!
We’ve already talked indirectly about the top-level managers that Blueprint supports, so it’s time to look at the syntax of each of these individually.
Each manager has corresponding XML syntax elements, and in many instances the XML syntax is identical to its Spring DM equivalent.
We’ll list the supported attributes for each in the following sections, but only describe in detail those that don’t have a Spring DM equivalent.
Perhaps the most complex—and most important—manager is the bean manager.
The bean manager is also the manager that diverges most widely from Spring DM.
The main reason for this isn’t so much gratuitous renaming but the decision that Blueprint needed to be self-contained as a specification.
As such, it isn’t possible for the specification—or the XML schema—to reference external unspecified artifacts, such as the Spring Framework’s schema.
Instead, all XML elements and Java artifacts need to be described by the specification, so some needed to be changed in order to meet these goals.
The bean manager supports the following Spring attributes with their usual meanings: id, depends-on, factory-method, init-method, destroy-method, class, and scope.
However, if a factory-method is specified, or a constructor other than the default is required, arguments can be supplied via a sequence of argument elements, rather than constructor-arg, which is used in Spring.
The attributes for argument and constructor-arg are named the same with the same meanings.
Finally, properties can be specified via the property element as in Spring.
Properties are defined either as values (value), as references (ref) to other managers, or as inlined definitions.
Let’s take a look at a couple of simple examples.
The Blueprint service manager supports the creation of OSGi services just like Spring DM’s service element does.
The attributes that the service manager supports are very nearly a simple subset of those in Spring DM’s service element.
The one difference is the syntax for activation which we’ve seen already.
Let’s take a look at another simple example that illustrates the service manager’s use:
We can see in this example that we didn’t need to specify an interface to export.
Instead we relied on Blueprint to do the job for us via auto-export.
This example is almost identical to similar examples for Spring DM, so the syntax should seem very familiar.
The Blueprint service reference manager supports the creation of references to other OSGi services, just as Spring DM’s reference element does.
The attributes and elements that the service reference manager supports are again largely the same as for Spring DM.
Again, we have id, depends-on, interface, filter, timeout, and referencelistener with their usual meanings.
Again we have our friend activation instead of lazy-init, and instead of cardinality we have availability.
Let’s take a look at another simple example that illustrates the service reference manager’s use:
Now we’ll look at Blueprint’s reference-list manager and the differences between it and the Spring DM list equivalent.
Table 12.3 Blueprint service manager XML elements and their Spring DM equivalents (continued)
In a similar vein to the service reference manager, the service reference-list manager supports the creation of collections of OSGi service references.
Just like in Spring DM, the collection semantics are dynamic, with the set of managed service references changing over time as services disappear and new ones become available.
The attributes that the reference-list manager supports are identical to those of the reference manager, with the addition of member-type.
None of Spring DM’s comparator, comparator-ref, or greedy-proxying are supported, nor is the set version of the reference list.
Table 12.4 Blueprint service reference manager XML elements and their Spring DM equivalents.
The missing interfaces From the discussion of the reference manager, you’ll notice that you can only specify a single interface for reference and reference-list.
That’s quite a problem, because you can’t create a reference that can be cast to different support interfaces, as would be the case with the service object itself.
Under Spring DM, if you specify greedy-proxying for a reference-list, the proxied references will contain all of the supported interfaces of the underlying service.
Thus, you could have some service objects that provide additional capabilities based on an additional interface, and the consumer of the reference-list could take advantage of this through a simple instanceof operation.
Another simple example shows just how similar the reference-list’s use is to that of reference:
We have not, as yet, discussed the environment managers, but to do that we need to understand a little bit more about the Blueprint container and its metadata.
First, though, let’s look at a full example using Blueprint to reinforce our lessons so far and see the various managers in actual use.
This example can be found in the code samples, and it includes many of the snippets that we’ve already encountered.
In this example, we’ll create two bundles, one exporting a bean as an OSGi service using Blueprint and the other importing this service using Blueprint.
First of all, we need a Blueprint service to export.
The metadata for this bundle is shown in listing 12.1
Next, we need a reference to this service, which is shown in listing 12.2
Note that we don’t need to provide a particularly special manifest file because the defaults are perfectly acceptable and there are no Blueprint packages that we need to import by default.
We do need to import and export the TestService interface appropriately, but a tool like the Felix Bundle Plugin for Maven 2 will do this for us automatically.
We can start up Equinox and get the obligatory "Hello World!" message.
There is no need to configure anything special for Blueprint—Spring DM automatically recognizes Blueprint bundles and starts them appropriately.
Now that we have a working Blueprint example, we can delve deeper into the structure of the Blueprint container, its associated metadata, and the mysterious environment managers.
In order to understand the final managers that Blueprint defines—the environment managers—we first need to talk a little bit about the runtime model and Java interfaces supported by Blueprint.
We already mentioned that Blueprint managers manage component instances and are configured through component metadata.
For example, a service reference manager (bp:reference) creates service references (the actual object that your application interacts with) configured through service reference metadata (such as the configured interface)
The relationship between these elements is shown in figure 12.1
Each of these elements also has a Java representation, so that it’s possible to interrogate the managers, components, and associated metadata through Java.
The BlueprintContainer provides methods for getting both component instances and component metadata.
Instances are returned as type Object and metadata as type ComponentMetadata with specific metadata elements represented as subtypes of this.
You can think of ComponentMetadata as being a little like Spring’s BeanDefinition.
The definitions of BlueprintContainer and ComponentMetadata are shown in listing 12.3
As you can see, the definition of BlueprintContainer is fairly limited and doesn’t provide the rich array of abstractions that ApplicationContext has.
Note also that this is strictly a read-only interface—you can’t manipulate the components or their metadata at runtime.
Figure 12.2 summarizes the different metadata interfaces that are available.
Now that we understand Blueprint components and metadata, we’re in a position to delve into the details of environment managers.
We saw that there is a close linkage between Blueprint’s XML schema and its Java metadata model—each XML element has an equivalent in Java, usually defined on a subtype of ComponentMetadata.
But there are some managers that aren’t defined in XML at all; they only exist in the world of Java.
These managers are predefined and give components access to important runtime artifacts for the bundle.
As you might expect, one of them is the BlueprintContainer itself, but the others are Bundle, BundleContext, and Converter.
Even though they aren’t defined in the XML schema for Blueprint, these artifacts can be referenced from the schema, so, for example, to get hold of the Blueprint container you might put this in your Blueprint context file:
The name blueprintContainer is a special string recognized by the Blueprint container, and all of the environment managers have their own special reference strings.
The effect of this snippet is to inject an instance of BlueprintContainer into the blueprint property of the ex bean.
Table 12.5 summarizes the environment managers available and their corresponding XML keywords.
That completes our discussion of environment managers and our discussion of the static configuration aspects of Blueprint overall.
In this section, we’ll explore the runtime aspects of Blueprint, most of which are very similar to those of Spring DM.
Blueprint’s runtime behavior is important to understand because it directly influences the runtime behavior of our applications.
Blueprint also allows us to augment and introspect this behavior through the use of events and event listeners.
The lifecycle of a Blueprint bundle is much the same as that of a Spring DM bundle, but with some of the state names changed.
We won’t regurgitate the entire lifecycle here because it’s documented quite clearly in the OSGi compendium specification (section 121.3)
These differences fall into three categories: lazy initialization, control directives, and events.
What this means is that if all the components in a Blueprint application are marked as having lazy activation, then the application itself is considered lazy.
When an application is considered lazy, no initialization will be performed until a service request arrives.
Only then will the appropriate components be instantiated with all of the classloading and other housekeeping that this implies.
Of course, a little initialization needs to be performed so that declared services are actually registered in the service registry, but little else.
Spring DM and lazy-init Although Spring DM supports lazy-init for beans, it doesn’t support lazy-init for references or, more importantly, services.
This means that although a bean can be declared lazy, in practice it will generally be eagerly initialized because the service that references it is always eagerly initialized.
The main reason for providing lazy initialization as a feature is performance.
If no initialization is required, Blueprint bundles can be started very quickly indeed, contributing to lower startup times for the OSGi container as a whole.
Control of the lifecycle of Blueprint bundles is handled through manifest header entries, just as it is in Spring DM.
Table 12.6 summarizes the control directives that are available and their Spring DM equivalents.
These properties would be used in a manifest entry like this:
In a similar vein, the service property names used when a Blueprint bundle has been started are subtly different.
So, for instance, the service properties shown by Equinox might look like this:
The service properties for these are shown in table 12.7
Now that we’ve looked at how we can control the behavior of Blueprint bundles and access Blueprint-specific metadata, let’s look at Blueprint’s support for events.
Just as in Spring DM, components can register special listener services that the container will deliver Blueprint events to.
In Blueprint, components must register a service of type BlueprintListener.
Let’s take a look at the definition of this, together with the definition of BlueprintEvent, as shown in listing 12.4
Simple, yes, but this is one of the few instances where Blueprint goes a bit further than Spring DM and delivers some really useful functionality.
First off, we can see that Blueprint events provide access to all of the states applicable to a Blueprint bundle and its container.
Let’s look at how the OSGi 4.2 compendium specification defines these, because their behavior is a little subtle.
The list of missing dependencies must be made available through the getDependencies() method.
During the grace period, a GRACE_PERIOD event is sent each time the set of unsatisfied dependencies changes.
GRACE_PERIOD isn’t so much a single state as a state that the container constantly reenters as the set of unsatisfied dependencies changes.
Runtime support and lifecycle things that can be accomplished with this functionality is the logging of unsatisfied dependencies.
The Blueprint Container is waiting on the availability of a service to satisfy an invocation on a referenced service.
The missing dependency must be made available through the getDependencies() method which will return an array containing one filter object as a String.
The assumption is that all mandatory dependencies have already been satisfied and the container started, but at some later time one of the mandatory dependencies disappeared, so the container needs to be suspended.
Originally it was proposed that the Blueprint container be shut down when this happens; fortunately sanity prevailed and the result was the WAITING state.
What is this all about? Well, this is to support synchronous registration of BlueprintListeners.
When a listener is registered, the Blueprint container will deliver the last known event for each Blueprint-managed bundle to the listener.
Thus, new listeners can be assured of knowing the current state of the running system, even if they weren’t present when the original lifecycle events were delivered.
Of course, the last known event is essentially synthetic—the state transition that would have caused it is some way in the past—so these events are known as replay events.
As we’ve seen, Blueprint has its own eventing infrastructure just like Spring DM.
However, the OSGi-aware among you will realize that OSGi actually has its own eventing infrastructure already defined as a compendium service—EventAdmin.
So where does EventAdmin fit into all of this? Well, Blueprint defines a mapping between Blueprint events and EventAdmin events, and if an implementation of EventAdmin is available in the OSGi container, Blueprint will signal events using that as well as its own infrastructure.
All of the other Blueprint event information is then available as properties of the EventAdmin event.
Spring DM and mandatory services Spring DM has a similar state to WAITING.
When a mandatory reference becomes unsatisfied, it will unregister all service beans declared by the ApplicationContext until such time as the reference is once again satisfied.
However, Spring DM 1.2 doesn’t post events while waiting for a dependency to be satisfied.
The only material difference between the EventAdmin mechanism and Blueprint eventing is that EventAdmin doesn’t support replay events—events are simply delivered at the time they’re signaled.
In general, you’ll want to use Blueprint’s native eventing mechanism because it’s faster, doesn’t require EventAdmin, and is easier to understand.
Let’s now look at another runtime aspect of Blueprint—type conversion.
Type conversion is important when you want to make the source and target of dependency injection be compatible and Blueprint’s built-in conversion isn’t sufficient for your needs.
We’ve already mentioned in table 12.1 that type converters can be registered in Blueprint bundle configuration files, but what exactly do these components do, and how would you use them?
Spring applies certain rules for converting a source argument for dependency injection to a target type.
The target type is dictated by the signature of the property mutator being used.
Spring must find a way of converting the string "fooble" (in the XML snippet) to an instance of a Foobrilator (for the class)
It does this through a combination of builtin rules and looking for property editors for Foobrilators.
Given the same declarations, Blueprint must find a way to convert from a String to a Foobrilator or die trying! Blueprint has some built-in rules for facilitating this conversion, which we summarize in table 12.8
In our example, we’d hope that Foobrilator has a String constructor, because Blueprint would use that without any further need for conversion.
However, if builtin conversion fails, Blueprint looks to the registered type converters to perform the conversion.
As you can see, a Converter specifies two functions: canConvert() to determine whether a type can be converted, and convert() to convert a type.
If we were to write a converter for our Foobrilator, it might look something like listing 12.6
As we mentioned in table 12.5, Blueprint provides an environment manager called blueprintConverter that gives access to the built-in Blueprint Converter, and this.
Enough of type converters—we’re done! You’ll be pleased to know that we’ve now covered all the major differences between Blueprint and Spring DM.
You should now be as proficient in Blueprint as you are already with Spring DM, and we think you’ll agree that the two aren’t so very different.
If you understand Spring DM, then understanding Blueprint is straightforward.
Before we finish, however, we need to discuss what you may already be thinking“I am using Spring DM now—how do I transition to Blueprint?” The answer, as we’ll see, is very simple.
As we’ve already seen, Spring DM 2.0 supports Blueprint out of the box because it’s also the RI for the Blueprint specification.
But Spring DM 2.0 doesn’t stop supporting the Spring DM mechanisms when it supports Blueprint, and this gives us some interesting possibilities.
Spring DM and Blueprint export and import services and classes using standard OSGi mechanisms.
As far as anyone is concerned, the other end of a service reference could just as easily be defined using regular OSGi APIs as Spring DM or Blueprint.
There is no reason why an application can’t have both Blueprint and Spring DM bundles in the same container.
The Spring DM 2.0 extenders support both, and they can interact easily because the only touchpoints are the OSGi service registry.
This gives us a very useful way of transitioning existing applications from Spring DM to Blueprintthey can be migrated over time, a bundle at a time.
This means you can run both Blueprint and Spring DM bundles together at the same time.
Spring DM 2.0 will start both extenders—one to manage Blueprint bundles and one to manage Spring DM bundles.
Because the only interaction between bundles is through regular OSGi mechanisms—classes and services—each bundle will be blissfully unaware of the other types of bundles that it’s interacting with.
If an implementation should change, it won’t affect the overall operation of the application as long as the class and service interaction points are maintained.
In this chapter we’ve discussed the Blueprint specification, the OSGi standard for Spring DM, and the OSGi component model that you may well be required to use in the near future.
You should by now have realized that Blueprint is a lot like Spring DM without the bells and whistles.
You can generally do in Blueprint most things that you can do in Spring DM—even the names are the same or similar!
The good news is that you can pick and choose which technology you want to use because Spring DM 2.0 supports both Blueprint and the Spring DM programming model.
Although Blueprint might seem like a slightly inferior technology to Spring DM, its use will become more important as server containers begin to support Blueprint without supporting Spring DM.
For instance, IBM is working on a Blueprint implementation under the Apache Aries project, and it seems a pretty safe bet that their community edition application server will support Blueprint at some point in the future.
Other containers already based on Spring DM, such as Oracle’s CEP product and SpringSource’s dm Server, will almost certainly support Blueprint as they move to the Spring DM 2.0 codebase.
As a Spring DM expert, you should find its use straightforward, and by using it you’ll be ensuring application portability for the future.
It’s written in Java and was intended primarily for developing Java applications.
The Eclipse platform is also extensible because it provides an advanced plug-in framework.
The range of provided plug-ins is quite large, with plug-ins being available for many languages including C, C++, COBOL, Python, Perl, and PHP.
Eclipse is particularly suitable for OSGi development because it is based internally on this technology.
The Eclipse IDE is built on Equinox, an OSGi 4 implementation that extends the specification with various extension points.
Because Eclipse allows you to develop OSGi applications, implementing Spring DM applications is also possible.
A.1 Installing and configuring Eclipse for Spring DM Using Eclipse to develop OSGi and Spring DM applications requires some setup to enable the plug-in development environment and provide Spring DM components access to the embedded OSGi environment.
You need to install the plug-ins required for OSGi and Spring DM development and configure the OSGi environment.
The Eclipse website offers a set of Eclipse distributions, each serving particular needs.
Having retrieved the distribution, you simply have to decompress it.
In order to launch Eclipse, execute the eclipse.exe file under Windows or the eclipse file under Linux.
In order to run Eclipse, you need to have the JDK installed on your computer.
You’ll need to install this tool separately by going to http://download.eclipse.org/eclipse/downloads/, selecting the desired version, and then downloading the archive from the PDE SDK section in the menu on the left.
Having done this, unzip the file into your Eclipse installation directory and restart the IDE.
An additional plug-in called Spring IDE can also be installed because it provides useful facilities for developing Spring DM applications in Eclipse.
The Spring portfolio contains an interesting project that supports the development of Spring applications in the Eclipse IDE: Spring IDE.
Spring IDE provides tooling that makes Spring development easier, especially the detection of errors in Spring XML and AOP configurations, thanks to its deep integration with Eclipse features.
You’ll notice that version 2.0 of the SpringSource Tool Suite, now freely available, provides additional tools for OSGi development and can be used to analyze bundles and visualize their dependencies based on import and export package headers and service production and consumption.
New versions of Spring IDE are now integrated into this tool.
You can install Spring IDE by using the update manager feature of Eclipse.
To do so, select the Install New Software entry in the Help menu.
You’ll need to specify an update site, which must be http://dist.springsource.com/release/TOOLS/update/ e3.5
This site contains all the Eclipse plug-ins for the latest stable version of Spring IDE.
Figure A.1 shows the configuration window of the Eclipse update manager.
When the update site is configured, Eclipse automatically inspects its contents and shows all the available modules.
Spring IDE and AOP If you want to use the visualizer features of Spring IDE, you need to install the Spring IDE/AspectJ Development Tools (AJDT) integration.
This feature allows you to graphically see the impact of aspects on classes.
Figure A.2 shows the list of available modules from Spring IDE and the ones required in order to use Spring IDE to develop Spring DM bundles.
Once you’ve selected all the components, you can click the Next button and be guided by the Eclipse wizard.
In the last step, the wizard asks you to confirm the installation of the previously selected extensions.
Once you restart Eclipse, you’ll be able to use Spring IDE within your Eclipse IDE.
Spring IDE core Contains core features of Spring IDE for creating and editing Spring XML files, providing development tooling.
Spring IDE AOP extension Contains extension features for checking AOP configuration and displaying the impact on classes.
Spring IDE AJDT integration Contains integration with AJDT so that the Visualizer view can be used.
Spring IDE provides various levels of support for Spring DM.
Support for the Spring DM namespaces is the central one of these levels.
This support is useful both for creating namespaces and for detecting errors when developing Spring applications using these namespaces.
Predefined target platforms—Spring IDE registers predefined target platforms provisioned with the necessary bundles for Spring DM.
These target platforms are accessible in the template list when adding a new target platform.
Creation of XML configuration files for Spring DM—Spring IDE allows XML configuration files to be created and preconfigured with the requisite XML namespaces for Spring DM.
This feature is natively present in Spring IDE, and Spring DM namespaces have simply been added to the list of available namespaces.
Spring IDE will help you when adding tags and attributes for these namespaces.
It also gives support for filling fields like interface and ref attributes when registering or referencing services, and checks whether the values are correct.
Let’s now focus on how to configure Eclipse for developing Spring DM applications.
The target platform corresponds to the set of OSGi components used for development and any OSGi components defined as projects within the workspace.
Eclipse PDE uses these components for compilation and checks if imports can be resolved.
The target platform is based on a directory containing these components.
By default, this is the plugins directory under the Eclipse installation directory, which contains all plug-ins associated with Eclipse.
This is definitely much more than we need! We need to create a target platform containing only the relevant plug-ins.
Two approaches can be used to configure the target platform.
The first consists in using the facilities provided by Eclipse PDE to specify all the components you need.
In the following subsections, we’ll describe how to use these two approaches.
The first approach consists of creating an empty target platform and configuring it.
To do this, we need to create a dedicated directory for gathering the necessary components, and it must contain the components required by Spring DM and their related dependencies.
Best practice is to create this directory in the current workspace in a project called “target-platform”
We then need to copy all the JAR files required by components into this directory.
Figure A.3 shows a simple Eclipse project containing bundles for provisioning the target platform of the current workspace.
Now that we’ve created the directory and filled it with the required components, we need to tell Eclipse to use this directory as a target directory for the current workspace.
With the latest version of Eclipse, several target platform definitions can be specified and configured, but only one can be active—the one used for the current workspace.
The default definition corresponding to the configuration for the running Eclipse is shown in figure A.4
A new target platform definition must be added using the Add button to use only the components that are necessary, and not include all of Eclipse itself.
This target platform will use the bundles present in the previous target-platform project in the workspace.
In the first screen of the Add wizard, select the option, Nothing: Start with an Empty Target Definition (see figure A.5) and click the Next button.
In the next screen, configure the target platform content (Figure A.6)
As you can see in figure A.6, no source is present.
You need to add one by clicking the Add button.
Figure A.6 Screen for configuring the content of the target platform.
The source should now appear in the list of target platform content (figure A.9)
You can now click the Finish button to end the configuration of the target platform.
Your platform will now appear in the list of available target platforms.
The only remaining thing to do is to activate the target platform so you can use it.
To do this, select the target platform from the list and check its check box.
The platform is now used for the workspace, as shown in figure A.10
Now let’s take a look at the support Spring IDE provides to make it easier to configure the target platform for developments using Spring DM.
This means that Spring IDE automatically creates a directory for the target platform containing all the bundles required by a specific version of Spring DM.
With the Spring IDE’s support for Spring DM, when creating the target platform, we need to select an appropriate template from the Template list in the Target Definition screen, as shown in figure A.11
When we select a target platform template, Spring IDE automatically provides an installation source pointing to a directory containing all the bundles needed for.
Figure A.10 The target platform for Spring DM activated for the current workspace.
We can easily add other directories to specify additional bundles according to our needs.
As we saw previously, the Add button in the Target Content screen can be used to add installation sources based on a directory.
Figure A.12 shows the target content for a target platform created from a template, where an additional source directory has been added.
You’ll notice that all the steps we described in the previous subsection are the same here.
You’ve now seen how to install and configure the tools in Eclipse that simplify Spring DM development.
Let’s look at how we can use these tools to efficiently develop OSGi applications with Spring DM.
A.2 Developing OSGi components Now that we have a functional environment in Eclipse for developing OSGi and Spring DM applications, it’s time to implement bundles to be used by an application.
We’ll tackle the three classic kinds of bundles: simple Spring DM components, OSGi fragments, and Spring DM web components.
Let’s look at how to develop an OSGi component with a Spring DM powered bundle whose development is entirely managed by the framework.
As we described in chapter 1, this kind of bundle is a regular OSGi component containing additional Spring artifacts and specific headers in its manifest file.
In Eclipse, the first step consists of creating a plug-in project using the IDE.
A New Project wizard will display the list of supported elements ordered by category.
The items that interest us are located in the Plug-in Development category.
The next wizard screen allows you to configure information related to the project itself (name, source, and output folders) just as you would with a Java project—a plugin project is first and foremost a Java project.
Other information you need to provide is related to OSGi itself.
Here you can specify the link to the target container.
The Content wizard screen is displayed next, allowing you to specify general information for the manifest configuration, such as ID, Version, and Name.
Because Spring DM doesn’t use activators but is based on the extender pattern, you need to uncheck the Generate an Activator check box.
Before starting development, you must remember to activate Spring IDE support for the project.
The newly created project is a regular Java project with OSGi support and it contains a MANIFEST.MF file within a META-INF directory.
You can then create a spring directory inside this for Spring configuration XML files using Spring IDE features.
Having specified the file location in the first screen of the wizard, you will be asked for the XML namespaces to include, as shown in figure A.17
This approach generates an XML file with the contents shown in listing A.1
You can then add Spring DM elements to the XML file, such as reference and service definitions, using Spring IDE’s code-completion for the osgi XML grammar.
Codecompletion applies on the osgi XML grammar at different levels:
Creates XML elements of the osgi XML namespace, as shown in figure A.18
References bean identifiers from attributes of osgi namespace elements, as shown in figure A.19
This is supported natively by Spring IDE for all supported Spring namespaces.
Selects type attributes in osgi namespace elements, such as the interface attribute shown in figure A.20
Types are found in the bundle classpath and are dependent on the manifest configuration.
We won’t describe component development any further because this has been tackled throughout the book.
Although fragments aren’t specific to Spring DM, they’re very important to Spring DM because they allow system bundles to be configured, such as Spring DM extenders and trace bundles.
Eclipse PDE provides a wizard to make the creation of fragments easy.
This wizard is similar to the one for a regular bundle, the only difference being in the selection of the fragment host, as shown in figure A.21
A Browse button allows you to select this bundle from ones present in the target platform.
Once the bundle is created, you can use all the techniques we described previously to implement its functionality.
Let’s now look at the last kind of bundle that is usually involved in Spring DM development—the web bundle.
Spring IDE and configuration set By default, Spring IDE provides code-completion to find bean identifiers within a given Spring XML configuration file but not between files.
With Spring DM, we typically have several files because best practice consists of separating OSGi-independent configuration from OSGi configuration.
To enable code-completion between files, a configuration set needs to be set up for the project, specifying configuration files that should be linked together.
This can be done in the project configuration: in the Spring category, select the Beans Support entry and then the Config Sets tab.
The last Spring DM component type is the web component.
In Eclipse, the same wizard used for creating a simple plug-in project should be used to create web components.
The main difference is that a WEB-INF directory must be created in the project root, and classes for the bundle must be located in the WEB-INF/classes directory.
This is configured in OSGi using the Bundle-ClassPath header in the manifest file.
The default output folder for the project must be changed to the WEB-INF/classes directory because by default it uses the bin directory.
To change the directory, we need to select the Java Build Path in the properties of the project, click on the Source tab, and edit the Default Output Folder, as shown in figure A.22
You’ve now seen how to develop different kinds of bundles for Spring DM applications and how PDE and Spring IDE help us in this task.
It’s now time to run our Spring DM applications in Eclipse IDE using the Equinox container.
A.3 Executing in the Equinox container Once our bundles are created, configured, and developed, we need to execute them within Eclipse.
The first step toward executing Spring DM components in Eclipse consists of configuring the execution environment for an Equinox application.
Eclipse provides a generic execution environment for different kinds of applications.
In the Run Configurations window, Eclipse displays a tree on the left with all the supported kinds of applications.
You can add a new application by selecting Add from the context menu, as shown in figure A.24
You can now change the name of the OSGi framework configuration, to “Spring DM Configuration”, for example, in the Name field at the top of the panel (see figure A.25)
The Equinox container is automatically provisioned with the bundles present in the workspace and all the bundles of the target platform.
You can remove some of them, if desired, by using the Bundles tab in figure A.25
Other settings are also available in this window, such as arguments provided to the JVM at startup in the Arguments tab, and the JVM and Equinox configuration used in the Settings tab.
When you’ve finished our configuration, click the Apply button to save it.
Figure A.25 shows the configuration window for the Spring DM application and the Bundles tab containing the bundles used.
Now that the application is configured, you can run it by launching your Spring DM application within Eclipse.
The previously configured application can be run directly from the configuration window (figure A.25) using the Run button once its configuration is complete.
But this window might not be open, so you can also run the application from the Run icon in the Eclipse toolbar or the Run menu, as shown in figure A.26
When the application runs, its output appears in Eclipse’s Console view at the bottom of the window.
This output is the same as the output of the Equinox console and it’s interactive.
Figure A.27 shows the content of this view after launching the application.
To finish up, we’ll see how to interact with the Equinox console to introspect the current bundles, show their states, and see which services they have registered.
Once you’ve launched an Equinox application, the console is immediately available from the Console view, together with a command prompt.
This prompt isn’t visible if traces haven’t been displayed at container startup, but you can nevertheless enter commands.
Table A.2 lists all the useful commands of the Equinox console.
Figure A.27 Console view after having launched the Spring application.
The main command is ss (for short status), which displays all the loaded bundles together with their internal identifiers, their states, and their symbolic names.
The internal identifier is a number, and it can be used as input to commands like bundle and diag.
Figure A.28 shows the output of the ss command for our application.
Another useful command is bundle, which displays information about a bundle.
Spring IDE goes further by providing all the necessary tools to facilitate the development of OSGi components using Spring DM.
Spring IDE can also be used to create Spring DM configuration files and for code-completion within these files.
Maven 2 is a popular and powerful build tool that spans the whole build lifecycle of a software project: compilation, automated tests, packaging, and deployment.
It provides a dependency management system, supports many other tools via its plugin architecture, and integrates well with continuous integration servers.
Maven 2 also offers good support for OSGi-based development, which can then stay close to traditional development in terms of building, as long as you’re aware of the good set of extensions and know to how use them.
It’s also intended for readers already familiar with Maven 2 who want to keep using their favorite build tool for their upcoming OSGi-based development.
These people will be happy to discover that the use of OSGi doesn’t need to disrupt their habits and that they’ll be able to use Maven 2 in nearly the same way as before.
Readers totally new to Maven 2 should read this appendix from the beginning.
These sections are the core of this appendix, as they cover how to include OSGi ingredients in your Maven 2 builds.
It runs only on Java 5 and needs a JDK installed (a JRE isn’t sufficient)
You can check that Maven 2 is properly installed by running the mvn --version command, which outputs some information about your system:
The output you get will certainly differ, but it ensures that Maven 2 is correctly installed on your computer.
We’re now ready to create our first project with Maven 2 and ready to discover its basic features.
We’ll see how to create a project with the mvn command-line tool, and this will give us the opportunity to discover the Maven 2 philosophy regarding project structure, build lifecycle, and dependency management.
Maven 2 provides archetypes for creating the skeleton of a project.
There are different archetypes you can use, depending on the nature of the project you want to create: standard, web application, and so on.
We’ll start by creating a standard Java project, using the default Maven 2 archetype.
To do so, cd to a working directory and type the following command:
Creating a project the Maven 2 way run it can take a while, because your computer doesn’t have any plug-ins installed.
Once the downloading phase is done, the archetype generation kicks in and Maven 2 prompts you with the following questions:
The number of the archetype to use—We want to use the “quickstart” archetype (the default), so type 15 and press Enter.
The artifact ID of the project—Type maven101 and press Enter.
The version of the project—The default (1.0-SNAPSHOT) is OK, so press Enter.
Maven 2 then asks you to confirm, so press Enter.
The project skeleton is then created in the maven101 directory (which is the artifact ID you entered)
The group ID, artifact ID, and version that Maven 2 asked you to enter are important because they identify your project.
They’re sometimes called “GAV coordinates” or simply “coordinates,” as they’re one way to locate a project.
We’ll see later that coordinates are central to Maven 2 dependency management.
We’re now ready to study the structure of the project we’ve just created.
The quickstart archetype created a project that follows Maven 2’s standard project structure (a pom.xml file at the root of the project, a src/main/java directory for application classes, and a src/test/java directory for test classes)
Figure B.1 Maven downloads dependencies from public repositories on the internet and stores them on the local filesystem, in the local Maven repository.
Note that Maven 2’s defaults can be easily overridden if they don’t suit you.
Our project is simple and doesn’t have all of them.
Maven 2 didn’t only create the skeleton of the project following its standard layout; it also created a pom.xml file at the root of the project.
This file is at the core of Maven 2 configuration.
Recall from chapter 3 that POM stands for Project Object Model, and the POM file of a project contains all the information to build the project, from compilation to deployment phases.
It contains two sections that deliver information about the project:
The project identification, with the coordinates we entered during project creation.
Note the packaging element, which specifies how to package the project (JAR, WAR, and so on)
The project dependencies, which informs us that it depends on the JUnit library.
Dependencies are an important feature of Maven, which we’ll study in section B.2.4
The POM file doesn’t contain a section for the structure of the project: because we’re following the standard directory layout, we don’t need such information.
This is one benefit of the convention over configuration approach.
A POM file can grow and have lots of sections; we’ll see some of them in the examples later in this appendix.
Type the following command in the maven101 directory to package the project:
The execution might take a while, because Maven 2 downloads the artifacts (libraries and plug-ins) it needs to compile, run, test, and package the project.
The console outputs a lot of messages; you should get something like the following at the end of the run:
Users familiar with tools like Ant should be thrilled: thanks to the convention over configuration approach and the dependency management, setting up a project with Maven 2 needs many fewer configuration steps than with Ant.
Maven 2 uses a more declarative approach than tools like Ant: we refer to the JUnit library (by its coordinates), not to a junit.jar file located in a specific directory.
Ant uses a low-level approach (referring directly to a junit.jar file), which is more cumbersome but can be more flexible.
But what is the package option we used in the command line? It refers to a phase in the default build lifecycle.
A build is composed of different phases, and when a phase is given in the command, Maven executes every phase up to and including the given phase.
Table B.2 lists the most important phases of the default build in chronological order.
Maven 2 defines two other builds: clean (which deletes the target directory) and site (which generates the project’s documentation)
We can use phases from different builds in the same command line.
The following snippet shows a commonly used command to deploy all the project artifacts (archive and documentation) from a cleaned project:
Here are some other commands that are useful while doing Maven-based development:
Sometimes you’ll need to run up to a particular phase without running previous phases.
There’s no uniform way to do so, but the plug-in that executes a phase can accept a command-line argument that prevents it from doing its job.
We usually use system properties as plug-in arguments, with the -Dargument.name syntax.
As an example, here is the command to package a project without running the unit tests:
To complete our tour of the Maven 2 command line, let’s study a topic we’ve avoided so far: the exact syntax of command-line commands.
Remember that we used the mvn archetype:generate command to start the creation of our project.
In the mvn archetype:generate command, we use the generate goal of the archetype plug-in.
Plug-ins provide features that can be called through their goals (goals can be seen as the equivalent of Ant tasks)
But when we built the project, we used build phases, and these don’t follow the plugin:goal syntax.
That’s because phases can be considered shortcuts for plug-in goals.
As an example, the compile phase is equivalent to the compiler:compile goal:
You’ve absorbed a lot of information about using Maven 2 so far, and that’s only the beginning.
You deserve what each developer seeks when starting to use a new tool: the Hello World! output.
We hope we’ve talked enough about modularity in this book for you to understand that an application should not be built as a monolithic piece of software, nor should it reinvent the wheel each time it needs to do something new.
An application should be divided into a consistent set of modules to encourage reuse, testing, and independent upgrades.
It should also be able to leverage third-party libraries, which give strong foundations and keeps the focus on the main goal of the application.
For the development phase of a project, we need to rely on something else to handle modularity, and that’s where Maven 2’s dependency management system can help.
When splitting an application into modules, some modules depend on each other and on third-party libraries.
We therefore need a strict way to identify the modules.
There are also subtleties that can make the notion of a dependency tricky: if a module uses Hibernate, it needs the Hibernate binaries to compile and at runtime.
This can be different for a module that uses Spring: it can only use the lightweight container, so it doesn’t need the Spring binaries to compile but obviously does need them at runtime.
We usually refer to this notion as the scope of the dependency.
Dependency management is a complex topic, and this section will cover how Maven 2 tackles it.
This topic is relevant to modularity, one of OSGi’s main concerns, but keep in mind that the scope differs: in this appendix, we’re covering a build tool, whereas OSGi is a platform.
The functionality of the two systems don’t collide but rather are complementary.
Dependencies are declared in the dependencies element of the POM file.
Remember the POM of the maven101 project, which uses the JUnit library for testing:
Adding a dependency is quite simple: just provide its coordinates.
In the next section, we’ll cover where to find these coordinates.
It’s worth noting that Maven 2 provides support for the notion of scope that we mentioned previously.
The JUnit library uses the test scope, which means Maven 2 will add JUnit to the classpath only when compiling and running the tests.
Any reference to the JUnit API in the src/main/java directory will result in a compilation failure.
Make sure you configure the scope of your dependencies, as it avoids having an inconsistent project.
Note the notion of dependency propagation in the description of the compile scope.
Maven 2 isn’t only able to handle direct dependencies but a whole graph of dependencies.
Frameworks like Hibernate and Spring rely on other libraries or frameworks.
When adding Spring or Hibernate to our application, we don’t want to worry about these indirect dependencies.
Maven 2 will provide them for us because it’s able to figure out and retrieve the whole graph of dependencies from a single dependency.
Suppose we want to use the Spring Framework’s lightweight container in our maven101 project.
Note that we didn’t specify any scope, which means Maven 2 will use the compile scope.
By using the dependency plug-in and its tree goal, you can see the dependency tree of the project:
Dependencies are available in all classpaths (compilation, test) and are propagated to dependent projects.
How does Maven 2 know about that? The answer is that the springcontext module has its own POM, which carefully describes its dependencies.
When building the project, Maven 2 will add the transitive dependencies to the appropriate classpaths, according to the scope of the root dependency.
As long as a dependency’s POM is correctly written, Maven 2 can retrieve its whole dependency graph, with correct versions of all dependencies.
We’re now going to describe how these features work by diving into one of its main mechanisms: repositories.
Maven repositories contain artifacts (JAR, WAR, POM, and the like) and store them in directories with the following structure:
What’s really interesting about the concept of a local repository is that artifacts are then shared with all Maven 2 projects.
This means that Maven 2 projects don’t need to embed their dependencies, which saves disk space and avoids cumbersome and errorprone copy-and-paste operations.
You can browse the central repository with your usual web browser, but this isn’t a particularly convenient way to find artifacts.
Creating a project the Maven 2 way that index remote repositories and provide a nice graphical interface for searching for artifacts:
It indexes the central repository and it’s simple to use.
It indexes several remote repositories (central, Codehaus, JBoss, and others) and understands Lucenelike queries.
By using these search engines, you can easily find the coordinates of your dependencies, and you’ll just have to copy and paste the XML code from the search results into your POM.
But what should you do when artifacts aren’t on the central repository? You can add repository entries in your POM that instruct Maven to look for artifacts in the default repository but also in these specific repositories.
Repository entries can be added at the end of the POM, in a repositories element.
Listing B.2 shows the necessary entries for the SpringSource EBR, which hosts Spring-related binaries and OSGiified versions of open source libraries.
Avoid spaces in the name of the local repository directory, as spaces prevent some (rare) plug-ins from working correctly.
Let’s put this into practice by adding some typical OSGi dependencies to a POM.
The OSGi Core and Compendium Services bundles are available in the central repository.
The following snippet shows how to add them to a Maven 2 project:
Note that we used the provided scope for the OSGi Core API: we’d need the OSGi API only if our project needs it to compile (we hope it won’t), but at runtime the OSGi platform provides the OSGi core classes.
Note also that we twice specified the 4.2.0 version of OSGi for the two bundles.
Let’s follow the DRY principle (Don’t Repeat Yourself) by using a property in only one place to set the OSGi version:
The next step: repository management Adding repositories to POM files is convenient, but it doesn’t scale when you maintain lots of projects.
A solution is to use a proxy that becomes the single entry point for Maven 2 and delegates artifact-lookup to a set of remote or local repositories.
Such a proxy is usually in the local network of a company that wants to host its own artifacts for its development teams, or a company that want to share its artifacts with external developers.
Nexus (http://nexus.sonatype.org/) is a powerful and open source implementation of a repository manager.
Adding Spring DM’s bundles isn’t so simple, because some of their dependencies are open source libraries that aren’t distributed as OSGi bundles.
The solution is to add the SpringSource EBR entries (shown in listing B.2) and then Maven will be able to find Spring DM’s bundles and its dependency graph.
The following snippet shows the necessary dependency entries in a POM:
When will you need to add Spring DM bundles to your Maven 2 projects? Hopefully, you won’t very often, as Spring DM promotes POJO-based programming and its API should not generally be present in your Java classes.
However, you’ll have to add these bundles for a special kind of Maven 2 project: integration test projects.
So far we’ve covered using Maven 2 features on one project at a time, but when an application grows, it’s usual to split it into smaller modules.
Maven 2 is able to handle multimodule projects; the immediate benefits (regarding the build) are the possibility of sharing metadata between projects (by using POM inheritance) and building all the modules at once (by launching the build of the root module)
The support Maven 2 provides for multimodule projects makes it an appropriate build tool for OSGi (and thus Spring DM) applications.
For brevity’s sake, we’ll limit our sample to the creation of the domain, DAO API, and DAO implementation bundles of the directory application.
We’ll end up with a nicely structured multimodule project, and the following sections on the Apache Felix Bundle and Bundlor will cover how to package these modules as OSGi bundles.
A multimodule project is defined by a parent POM referencing submodules.
Let’s take a working directory as the root of our project and create a pom.xml file with the following content:
A parent POM gathers information that will be shared among its submodules; it’s therefore a good location to centralize properties like framework version or repository locations.
Let’s create the domain module by using the mvn archetype:generate command from the project root directory and answer the following when prompted by Maven 2:
This creates a directory.domain directory that has the layout of a Maven 2 project.
The parent POM has been modified to reflect that it now has a submodule:
Let’s have a look at the POM of the submodule we’ve just created:
By using the parent element and providing the parent project coordinates, the submodule inherits all the metadata that resides in the parent POM.
As with object-oriented inheritance, the submodule can override some settings by providing its own: that’s exactly what it does with the group ID and the version.
Because we want to closely tie the submodule to its parent, we must remove the groupId and version elements, and Maven 2 will use those of the parent POM (this will make our example simpler, but that’s not the way to go if we plan on having a different release lifecycle for the submodules)
It’s now time to see how Maven 2 lets us build our module-based project in one go.
From the root of the project, type the mvn clean install command.
The end of the output informs you that Maven 2 built the parent root module and the directory.domain submodule:
If you want the command to be launched only against the parent project, use the --non-recursive option:
As stated previously, our sample multimodule project consists of three submodules: the domain, the DAO API, and a JDBC implementation of DAO.
The creation steps for the two remaining modules are the same as for the domain module, so we won’t dwell further on them (the whole project is available in the book’s code samples)
You should now have a good overview of Maven 2’s features and mechanics.
There are many other interesting topics that we could cover, but as Maven 2 builds on a plug-inbased architecture, these topics are virtually endless.
Packaging OSGi bundles is slightly different from packaging plain-vanilla Java archives, and Maven 2 doesn’t provide native support for this.
Fortunately, there are third-party plug-in solutions that smoothly integrate with Maven 2’s build system.
In the next sections, we’ll cover two powerful plug-ins that make packaging OSGi bundles with Maven 2 a breeze: the Apache Felix Bundle Plugin (which builds on top of Bnd) and the SpringSource Bundlor plug-in.
Our multimodule project will act as a guinea pig, and we’ll use each tool’s features for the OSGi-ification of its modules.
This will also give you the opportunity to learn more about Maven 2, by discovering best practices and settings that commonly apply to projects.
You can download the plug-in and access its documentation on its website: http://felix.apache.org/site/apache-felix-maven-bundle-plugin-bnd.html.
This section gives a more comprehensive (but nonexhaustive) introduction to this plug-in: the basic setup in a POM file, the default packaging behavior, and how to override this default behavior by using the set of instructions the plug-in provides.
More advanced topics, like the way to benefit from the plug-in without changing the packaging of the project, how to externalize instructions from the POM, and the integration with the Eclipse Plug-in Development Environment are also covered.
By the end of this section, you’ll be able to efficiently use the plug-in for your own OSGibased developments.
The most common way to use the Apache Felix Bundle Plugin is to change the packaging of the target Maven 2 project and declare the plug-in in the build/plugins section of the POM.
Listing B.3 shows this basic setup for the domain module of our sample project.
Listing B.3 shows how we changed the default packaging from jar to bundle.
Maven 2 natively supports jar packaging, but that’s not the case for bundle.
In Maven 2, packaging types are an extension point, which means plug-ins can provide new ways to package projects.
That’s exactly what the Felix Bundle Plugin does: it provides the bundle packaging type.
So we need to declare the Felix Bundle Plugin in the POM if we want Maven 2 to understand what the bundle packaging type is.
This is a good opportunity to describe two practices that will make our Maven 2 build more robust:
Now that you know the plug-in version is important information and that it’ll be used in all modules, using a property defined in the parent POM is a good idea.
So, the version of the Felix Bundle Plugin has a place in the properties of the parent POM (shown in bold in the following snippet):
Now let’s see what the Felix Bundle Plugin does with this packaging.
If we launch the mvn clean package command from the domain submodule directory, it creates the JAR file in the target directory.
What’s in the resulting JAR? As expected, the JAR contains the compiled Java classes and the resources of the project.
For this “normal” behavior, it’s worth remembering how Bnd (the tool the Felix Bundle Plugin builds upon) works: it doesn’t package Java classes and resources that are copied to a target directory; it scans the classpath and gathers what we tell it to gather into a JAR file and generates its manifest accordingly.
We provided the Felix Bundle Plugin with the appropriate instructions to filter the classes of the library from the classpath.
We won’t leverage this feature directly here; we’ll merely package the classes that are directly present in our project and focus on the generation of the manifest.
Speaking of the manifest, let’s see what the Felix Bundle Plugin has generated.
Given that the project contains only one Java package (with the domain objects), the Felix Bundle Plugin did a pretty good job at adding relevant OSGi metadata without much information provided by us.
This is one of the strengths of this plug-in: it uses reasonable default decisions.
It nicely bridges Bnd and Maven 2, because it takes information from the POM and can perform the translation to OSGi metadata in the manifest.
The next subsection covers the details of the plug-in’s default behavior.
By setting up the plug-in in the POM of the domain module, we’ve been able to produce an OSGi bundle with relevant metadata.
Thanks to the Felix Bundle Plugin’s default behavior, we didn’t need to provide very much information.
We’ll cover this default behavior in the current section, and in section B.3.3 we’ll see how to override it.
The default behavior of the plug-in for OSGi headers is outlined in table B.4
Figure B.3 The Felix Bundle Plugin builds on top of Bnd, which scans the classpath for Java classes and resources and gathers them according to instructions in a Bnd file.
Any Maven 2 plug-in can have a configuration element in its declaration where settings can be specified (this means the configuration element can contain any valid XML fragment)
The Felix Bundle Plugin configuration schema has an instructions element where nested elements map to Bnd instructions.
The following snippet shows how to override the name of the generated bundle, using the instructions element in the configuration part of the plug-in (the configuration element) :
The plug-in follows an algorithm to generate the most appropriate symbolic name.
Export-Package The set of packages in the local Java sources of the current project.
The default package and any package containing impl or internal are automatically excluded.
Private-Package The set of packages in the local Java sources of the current project.
Note that this isn’t a standard OSGi header but an instruction that Bnd uses.
Exported packages are also imported to ensure a consistent class space.
You can also mix static values and properties, as shown in the following snippet from the POM of the domain bundle:
Remember that the elements’ values are Bnd instructions: they accept the powerful set of patterns that Bnd supports, like ! and *
We’re going to use the plug-in configuration for our sample project’s JDBC DAO implementation module.
It uses the domain package and relies on the Spring 3.0 API (when using the JdbcTemplate)
Specifying the Spring version is important—it allows us to centralize the version range in the parent POM (note that a property definition can use another property) :
The following snippet illustrates the use of both kinds of properties (Maven 2 and user-defined) and of Bnd patterns for the plug-in configuration of the JDBC DAO implementation bundle:
In our case, Bnd will generate two entries (one for the domain package and another for the DAO package) from this expression.
The third expression specifies that any other references to Java classes in the project source code should be added to the manifest (*)
Because our bundle is a pure implementation bundle, it should not make any of its classes available.
Bnd scans most of the elements that have attributes relative to class or interface (such as bean@class) in most of the Spring namespaces (beans, aop, context, jee, lang, osgi, util, and webflow-config)
There’s similar support for Blueprint, but it’s included in the Felix Bundle Plugin itself, not in Bnd.
You now know pretty much everything about the configuration of OSGi metadata using the Felix Bundle Plugin.
By remembering the philosophy of the tool (building on top of Bnd, providing a bridge between Bnd and the POM, and using reasonable defaults), you can make the OSGi nature of your project nearly transparent for your build.
Chapter 6 covered most of its features with the OSGi-ification of Commons DBCP; we’re focusing here on building OSGi projects, not converting existing non-OSGi libraries.
The next section covers how to configure the Felix Bundle Plugin without using the special bundle packaging type that it provides.
Sometimes changing the packaging type of a project isn’t an option, so we need to find another way to make packaging plug-ins do their job.
Maven 2 provides hooks in its lifecycle where plug-ins’ goals can be launched.
So far we’ve covered all the settings necessary for the Felix Bundle Plugin in the POM of the target project.
In the next section, we’ll cover how to externalize the Bnd instructions in a dedicated file.
The Felix Bundle Plugin configuration accepts an _include element, which makes Bnd use the specified nested file when generating the bundle and its manifest.
The following snippet illustrates the use of the _include element to use an osgi.bnd for the Bnd configuration:
In the previous snippet, the osgi.bnd file lies at the root of the target project (besides its POM file) and must be a compliant Bnd file.
We covered the format of these files in chapter 6, when converting the Commons DBCP library into an OSGi bundle.
The following snippet shows the osgi.bnd file for the DAO JDBC implementation bundle of our sample project:
When should we use an externalized Bnd file instead of centralizing instructions in the POM? This is a matter of taste, but keeping instructions in a dedicated file can make sense, especially when the POM is big.
Another good reason is upgrading from a build system that relies on plain Bnd to a Maven 2-based build: existing Bnd files will integrate smoothly with the new build system.
The Pax Construct (covered in appendix D) makes ingenious use of the externalized Bnd file: it defines a common configuration for the Felix Bundle Plugin in a parent POM, which all OSGi modules inherit from.
This common configuration sets OSGi metadata like name, version, symbolic name, and so on, based on the POM information, and it includes an osgi.bnd file.
Modules can then benefit from the common configuration for most of the metadata and use the osgi.bnd file for more specific metadata, like Export-Package or Import-Package.
This solution provides a good balance between uniformity and specialization.
We’re now getting close to the end of our coverage of the Felix Bundle Plugin.
It’s obviously a great help for OSGi developments with Maven 2, but it can go further by enhancing day-to-day development with Eclipse, as we’ll see next.
Maven 2 is a powerful build tool that comes with some useful features like dependency management.
Using the Apache Felix Bundle Plugin not only for building your project but also when developing with your IDE, like Eclipse.
Let’s get started by introducing the Maven Eclipse Plugin, which has changed the life of many Java developers.
Java, and especially Java EE, applications can have a lot of dependencies, and configuring your IDE to have all these dependencies in the project classpath can be very cumbersome and error-prone.
By using a dependency management tool (which is what Maven 2 is), you gain a precise map of all these dependencies.
There’s only one step needed to use this map to configure your IDE, and that’s what the Maven Eclipse Plugin is for.
To try it, cd to a Maven 2 project that has numerous dependencies and type the following command:
The command triggers the creation of the Eclipse configuration files for the project (like .project and .classpath)
Maven 2 relies on the POM to create these files and uses information like the artifact ID and the dependencies to get a project that’s ready to import into Eclipse.
Appendix A covers how to develop OSGi and Spring DM applications within Eclipse, and you learned, among other things, that you need a META-INF/ MANIFEST.MF file at the root of your Eclipse project to be able to provision an OSGi runtime configuration with it.
We already know everything about the generation of the manifest with the Felix Bundle Plugin, so all we have to do is configure Maven 2 accordingly.
Listing B.5 illustrates the configuration that must be done in the build element of the POM.
Eclipse will then identify the project as an OSGi project and will let you add it in any OSGi framework runtime configuration.
Note that Spring DM configuration files should be located in the META-INF/ spring directory for Eclipse to see them when running an OSGi framework from the IDE.
We’ve demonstrated here that any Maven 2 project can easily be configured to benefit from the Eclipse PDE tooling by using manifest generation provided by the Felix Bundle Plugin.
Using both tools without losing the advantages of either is possible.
It builds on top of Bnd to generate the final OSGi bundle and doesn’t need much configuration, thanks to its reasonable default behavior.
This tool also integrates with Maven 2 but isn’t based on Bnd and, as such, doesn’t follow the exact same philosophy.
B.4 Introducing Bundlor and its Maven plug-in Bundlor is a tool to ease the creation of OSGi-compliant manifests.
It uses a template-based approach, where the developer writes a template that can contain standard OSGi headers as well as Bundlor-specific headers.
Bundlor then takes as input the target JAR and this template to generate the manifest file, with the correct OSGi metadata.
As you can see, Bundlor is more about manifest generation; it scans classes and resources available on the classpath to put them in the final bundle and generate the appropriate manifest.
Here, we’ll study its integration within Maven 2, but thanks to its templatebased approach, most of the content of this section is also valid for the other forms Bundlor takes.
Once you have grasped the basics of Bundlor, you’ll learn about its specific headers in section B.4.2 and discover the real power of the template-based approach.
Section B.4.3 then covers which sources (Java classes, Spring configuration files, and so on) Bundlor can scan to detect the dependencies of a JAR.
By the end of this section, you’ll know not only how to use Bundlor in your OSGi projects, but you’ll have enough points of comparison to choose between the Felix Bundle Plugin and Bundlor.
Bundlor’s Maven 2 plug-in doesn’t provide any new packaging type but rather a goal that must be launched after the packaging of the target JAR.
This section covers how to set up Bundlor for simple use and then how to take advantage of Maven 2 features for a more efficient setup.
It has a Maven 2 plug-in, which can be used in place of the Felix Bundle Plugin.
The SpringSource team created Bundlor mainly because Bnd lacks some features needed for the integration in an IDE (Bundlor is part of the SpringSource Tool Suite, and some functions build on top of it)
The code samples for this book use Maven 2 and the Felix Bundle Plugin, but we also provide this introduction to Bundlor because we think choice is good.
Most Springrelated projects (Spring Framework, dm Server, and projects of the Spring portfolio) use Bundlor as their OSGi packaging tool.
Figure B.4 Bundlor takes an input JAR and a manifest template to generate a manifest with OSGi-compliant headers.
Adding Bundlor to a Maven 2 project can be done in three steps:
Listing B.6 illustrates the steps that deal with the project’s POM.
Notice that listing B.6 doesn’t provide any configuration for the plug-in.
Bundlor accepts some optional configuration parameters, but only the template file is compulsory.
The template must reside at the root of the project and be called template.mf.
The following snippet shows the template file for the domain module of our sample project:
We can draw the following conclusions from our first Bundlor template:
We’ll see later that the template can also contain specific headers that help with generating the content of other headers in the final manifest.
As shown in listing B.6, we use the transform goal of the Bundlor plug-in.
This goal binds, by default, to the package lifecycle phase (which means the transform goal is launched just after the package phase), so we can use the mvn clean package command to generate the JAR.
The following snippet shows an excerpt of the manifest of the generated JAR (we kept only the relevant headers for brevity):
Notice that Bundlor substituted the values of the properties for the placeholders and automatically exported the package of the domain objects at the specified BundleVersion.
We’ll learn more about Bundlor’s default strategy for the Import- and.
We’ll also see in section B.4.2 how to override and tune these default strategies.
We’ll see in the next subsection how to leverage some features of both Maven 2 and Bundlor’s plug-in for a more efficient configuration, especially in multimodule projects.
If you use Bundlor for a multimodule project, it’s a good idea to centralize some settings in the parent POM.
Thanks to POM inheritance, submodules will then benefit from these settings.
Listing B.7 illustrates the centralization of the version of the plug-in and of the SpringSource EBR declaration.
The next step towards centralization is declaring the Bundlor plug-in and some default settings in the parent POM.
Listing B.7 Centralizing plug-in version and repository in the parent POM.
Every submodule will benefit from this common declaration and will have to complement the manifest generation guidelines in its own template.mf file (typically with instructions dealing with imports and exports)
Note that we bound Bundlor’s bundlor goal to the package phase in the parent POM in listing B.8
This means that each submodule that uses the parent POM must have a template.mf file in its base directory, or the build will fail.
The parent project doesn’t need a template.mf file because Bundlor doesn’t attempt to transform artifacts with the pom packaging.
If a submodule doesn’t need Bundlor (such as an integration test module), it can disable Bundlor with the enabled element:
We’ve covered the basic use of Bundlor in Maven 2 and the more advanced configuration suitable for multimodule projects.
The next section delves into the most important feature of Bundlor: the manifest template.
As stated previously, Bundlor uses a manifest template to generate an OSGi-compliant manifest.
Bundlor copies any entries from the template into the final manifest, except.
These specific headers help Bundlor grasp the essence of the bundle (imports, exports, version, and so on) and make the manifest generation less cumbersome and more reliable.
This section introduces the headers Bundlor accepts in manifest templates and provides samples and guidelines for their use.
Table B.5 lists the specific headers that Bundlor uses to generate the final OSGicompliant manifest.
A typical Bundlor manifest template contains standard OSGi headers, whose values can take advantage of property substitution, as well as specific headers.
Listing B.9 shows a manifest template that mixes both kinds of headers.
Let’s next see how to use Bundlor’s headers in order to understand the power of the tool.
Excluded-Exports Packages that must be excluded from the Export-Package header (Bundlor exports by default all the packages of the input JAR)
Excluded-Imports Packages that must be excluded from the Import-Package header (Bundlor imports by default all the packages referenced in the input JAR, either from the code or in special files)
Export-Template Special Export-Package instructions, which accept patterns (such as *) and property substitution.
By default, Bundlor exports all the packages at the specified Bundle-Version.
Manifest headers from the input JAR’s manifest that Bundlor should not include in the generated manifest.
Import-Template Packages that should be added to the final Import-Package header.
You can use this header to augment the imports that Bundlor automatically detects, to specify a version, or to mark imports as optional.
Version-Patterns Version expansion patterns that can be reused in the template manifest.
We’ll detail this advanced feature shortly in the “Support for the version directive” section.
In these cases, Bundlor accepts the * pattern to match multiple packages and property placeholders:
Matching multiple packages is useful when specifying the version for a set of packages or when setting them as optional.
A manifest template can also contain OSGi headers, like Import-Package, especially when Bundlor’s default detection capabilities fail.
Bundlor’s headers are guidelines that the tool uses, but they only complement what it’s able to detect.
This means that if Bundlor can’t detect some packages needed by the OSGi bundle, they shouldn’t appear in the Import-Template header but in the Import-Package header, just like the org.h2 package in the following snippet:
Regarding exports, Bundlor has the following default behavior: it exports all the packages from the input JAR at the specified Bundle-Version.
We use the Excluded-Exports header for the JDBC DAO implementation module of our sample project, from which no class should leak:
The following snippet (taken from Spring DM’s Bundlor configuration) shows the use of this header:
The next subsection deals with an advanced feature that Bundlor provides for the OSGi version directive.
Bundlor is able to expand package versions using expansion patterns, which makes the manifest more dynamic.
This is particularly useful when you want to specify a version range for imports.
You can use the range property in the manifest template and Bundlor will substitute the placeholder with the property value when generating the manifest:
This technique takes advantage of Maven 2’s features and Bundlor’s substitution capacity, but we can push it further to let Bundlor calculate the version range, based only on the version property (there’s no need anymore to specify a property for the range)
For a version property placeholder, Bundlor accepts not only the property name but also an expansion pattern that tells it how to generate the final version range.
The following snippet illustrates the syntax of an expansion pattern with the previous spring.version property:
The expansion pattern of the previous snippet specifies that the beginning of the range stays exactly the same as the value of the spring.version property (an = sign for each part of the version and the qualifier) and the end of the range should be one integer larger for the major number (+1) and 0 for the minor and micro numbers.
Thanks to the Version-Patterns header, you can name an expansion pattern and use it for several imports.
Instead of using the pattern itself in the property placeholder, you refer to its name.
The following snippet shows how to define a spring pattern and use it in the Import-Template header:
Note that we could have defined more than one version pattern by separating them with commas.
Writing a manifest template should no longer be a problem for you.
Bundlor provides a limited, yet powerful, set of headers that influence the generation of the manifest and makes it less cumbersome and more reliable.
As stated previously, the template mainly gathers guidelines for the generation.
Bundlor builds its generation mechanism on these guidelines but also by scanning the input JAR.
Understanding Bundlor’s scanning capacities helps with writing consistent manifest templates, especially for the Import-Package header.
What Bundlor is able to scan is the topic of the next section.
Bundlor’s main goal in life is generating OSGi-compliant manifests, and to do so, it scans JAR files to determine their runtime dependencies.
Bundlor can scan Java classes and also some commonly used file types (Spring configuration files, web.xml, and so on)
This analysis, augmented by the manifest template, makes the manifest generation easier and more reliable, as the developer ends up giving only guidelines in the template and lets Bundlor do the tedious work.
This section covers the categories of files Bundlor is able to analyze, and for each of them gives the basics of Bundlor’s capabilities.
Consult the reference documentation at http://www.springsource.org/bundlor/ to find out which dependencies Bundlor can extract from the different kinds of files.
Bundlor scans all the Java classes of the input JAR and detects the dependencies by analyzing the bytecode.
But Java classes are a specific case, because Bundlor also populates the Export-Package manifest header depending on the JAR content.
By default, Bundlor exports any package that contains a class or a non-Java resource.
Detecting dependencies for the Import-Package manifest header is trickier, because there are many places in a Java class that another Java type can be referenced.
For instance, if a class of the input JAR inherits from another class that comes from another bundle, the package that the parent class belongs to must be imported.
The same goes for implemented interfaces, annotations, field types, method argument types, exceptions, and so on.
Fortunately, Bundlor automatically detects all these references and imports the correct packages—you can (optionally) specify the version, with the help of the * wildcard to propagate it to subpackages.
To detect these files, Bundlor follows the same rules as Spring DM: files must be located in the META-INF/spring directory or specified in the Spring-Context manifest header.
Once Bundlor has detected Spring configuration files, it analyzes them to extract their dependencies.
Despite its powerful scanning capacities, Bundlor can miss some dependencies.
Why does Bundlor miss the dependency toward the database driver? As stated before, Bundlor focuses on attributes that require classes or packages.
This means the manifest template must explicitly add the org.h2 package to the dependencies.
The following snippet shows what the manifest template would look like:
The case we’ve just exposed is rather unusual, and Bundlor will detect dependencies from Spring configuration files appropriately most of the time.
Let’s see now what Bundlor can do for us when we’re using Blueprint.
Bundlor scans for Blueprint configuration files in the OSGI-INF/blueprint directory or follows the Bundle-Blueprint manifest header.
Bundlor’s Blueprint and Spring support are similar, and they suffer the same kind of limitations (for example, when specifying a class or package name in a value attribute)
The JPA configuration file, persistence.xml, can refer to classes that don’t belong to the owning bundle.
Such classes are entity classes (which lie in dedicated domain bundles) or the persistence provider class (which lies in the JPA implementation bundle)
Bundlor is able to detect a persistence.xml file in META-INF and scans it to extract classes from the provider and class elements.
The following snippet shows the content of a simple persistence.xml file:
Note that you should complete Bundlor’s detection in the manifest template by specifying the exact version for each package.
Let’s now see what Bundlor can do with a popular ORM tool, Hibernate.
Hibernate’s mapping files can refer to entity classes and implementation classes (user type, generator, and so on) that aren’t located in the owning bundle.
Bundlor also handles subtleties like unqualified entity class names by watching for the package attribute (the package attribute allows you to specify a package once in your Hibernate mapping files and then use unqualified Java class names in nested elements)
Let’s take as an example the following snippet of a Hibernate mapping file:
Let’s switch now from ORM tools to web applications, as Bundlor also scans web.xml files.
When an OSGi bundle is a web application, it contains a web.xml file that can declare servlet listeners, servlet filters, or servlets.
Servlets can come from the bundle itself, but most of the time they come from the bundle of the web frameworks used in the application (such as Spring MVC)
The web bundle then depends on these classes, and the corresponding packages must be included in the Import-Package manifest header.
Bundlor detects any WEB-INF/web.xml file in a bundle and scans elements that can contain class names (such as listener-class, filter-class, servlet-class, and also nested param-value elements in elements that accept them)
The following snippet shows an excerpt of a web.xml file that declares a listener to bootstrap a web OSGienabled Spring application context:
This concludes our exploration of Bundlor’s capacities for detecting runtime dependencies.
Applications aren’t composed only of Java classes—they usually contain configuration files for various frameworks or standards.
These files often refer to classes external to the owning bundle, and their packages must be included in its runtime dependencies.
Bundlor can not only detect dependencies from Java classes but also from the files of several common enterprise frameworks, like Spring and Hibernate, and of various standards like Blueprint, JPA, and web applications.
These detection features save you from the tedious and error-prone work of dependency tracking, but make sure you complete the template manifest with version ranges or directives like optional to obtain a consistent manifest.
If you were a total newcomer to the world of Maven 2, you should by now be more comfortable with it and be able to use it for all your Java projects.
When it comes to OSGi, Maven 2 has built-in features like multimodule projects and dependency management that are particularly useful.
Thanks to its plug-inbased architecture and the hooks it provides in its lifecycle, plugging tools like Bnd or Bundlor into projects is straightforward.
You can then change the project packaging to switch from a standard JAR to an OSGi-compliant bundle by just adding a few lines of XML, and you can enjoy Maven 2 features like POM inheritance and property substitution.
Which one should you choose? This is a matter of taste, and you now hold all the cards to make your own decision.
Let’s just say that the Felix Bundle Plugin, which builds on top of Bnd and also brings its own features, detects Java classes and resources that are available on the classpath and can gather them in the final JAR.
Bundlor is more of a manifest generator, as it takes a JAR as an input, analyzes it, takes instructions from a template, and generates a manifest with OSGi-compliant headers.
Now that you know exactly how to add an OSGi flavor to your Maven 2 projects, perhaps you want to go a bit further.
What is the next step? Appendix D, which covers two tools from the Pax family, can help you sharpen your OSGi development skills.
They build on top of notions we introduced here: tools like the Felix Bundle Plugin and Maven 2 features like multimodule project management—they constitute a natural continuation of the topic of this appendix.
We consciously chose to use Maven 2 throughout this book, mainly because that’s the build tool we’re the most familiar with, but also because Spring DM uses it for its own building and testing.
Nevertheless Ant remains a very popular build tool, so here we’ll provide enough information for you to get started with OSGi and Spring DM development using Ant.
The aim of this appendix is to reproduce part of what we did in chapter 3, but in an Ant and Ivy fashion: writing and packaging a Spring-powered bundle, then running the corresponding integration test.
We won’t focus on pure Spring DM topics—you should already be familiar with the core principles of Spring DM before reading this appendix.
We’ll start with the installation of Ant, and then dive into writing the bundle itself and compiling it with Ant.
We’ll then cover how to create an OSGi bundle using Bnd, which integrates nicely with Ant.
Apache Ivy will help us handle our dependencies, and we’ll see how to customize Spring DM’s testing framework to make it work with Ivy.
We’ll finish by writing and running the integration test with Ant.
C.1 Installing Ant Ant can be downloaded from its official website, http://ant.apache.org.
For all Ant’s tasks to work properly, you should use a JDK (not a JRE)
Next, you need to create an ANT_HOME environment variable that contains the directory where you installed Ant.
You can check that Ant is correctly installed by running ant –version, which outputs information about the version of Ant:
Now that we’re sure that Ant works, we’re ready to create a Spring DM bundle and the corresponding Ant build file.
C.2 Creating a Spring DM bundle with Ant Creating our bundle will involve three steps:
Creating the bundle’s files (a Java class and a Spring configuration file)
The bundle’s Java class and Spring configuration file are displayed in bold.
Listing C.2 shows the SpringDmSample class, which outputs a message on the console when an instance is created.
The Spring configuration file is in the META-INF/spring directory, which Spring DM’s extender looks at when searching for an application context to bootstrap when the bundle is started.
Our Spring application context will create an instance of SpringDmSample, which issues the message in listing C.2 on the console.
That’s it for the content of the project; let’s now see how to build it with Ant.
An Ant build file is an XML file located at the root of the project and usually called build.xml.
If you run the ant command in a directory that contains a build.xml file, Ant will use it by default, whereas you’ll have to provide the name of the file on the command line if it’s not called build.xml.
An Ant build file consists of a succession of targets that can run from compilation to packaging to the creation of test reports.
Here we’re going to see how to compile our project and package it as a standard JAR.
First, we’ll create a build.xml file at the root of the project.
Listing C.4 Ant build file for compiling and packaging as a standard JAR.
You can build a JAR archive by launching the following command at the root of the project:
But don’t we want to produce an OSGi-compliant bundle? The clean and compile targets are suitable for this, but we need to change the package target so that it uses a tool more appropriate to OSGi.
The good news is that Bnd can also work as an Ant task!
We’ll look at how to make Bnd available to Ant builds and how to use the Bnd task inside a build file to produce an OSGi bundle.
Ant can support new tasks by adding the corresponding libraries to its classpath.
There are several ways to do this, but the easiest is to copy the library into the ANT_HOME/lib directory.
The Bnd JAR contains the Ant task, so you only have to copy it to the ANT_HOME/lib to make the Bnd task available for all your builds.
Using the Bnd task in Ant consists of two steps: importing the task and then using it with the bnd XML element.
The package target is declared in the first line, the same way other targets are.
But because the Bnd task isn’t an Ant core task, we need to define it using a properties file that the Bnd JAR contains.
We can then use the task with the bnd element.
Bnd isn’t exactly a packaging tool: it scans the classpath (not a directory with class files) and gathers class files and resources into a JAR, following rules detailed in a configuration file (it also uses this file to generate the JAR manifest with the necessary OSGi metadata)
That’s why we use the classpath attribute to tell Bnd to scan the output directory, and the files attribute to indicate a configuration file.
The next step is to write the build.bnd file that the files attribute is pointing at.
This file contains instructions that Bnd uses to generate the JAR.
Note that the Bnd configuration file can contain references to properties defined in the build file.
We use this feature for defining the version of the bundle.
This produces a JAR in the same place as before, but this time it contains a manifest with the necessary OSGi metadata.
Once the bundle is installed and started, the SpringDmSample should output a message to the console indicating that it has been created.
Testing the bundle manually—by installing it in an OSGi container—is cumbersome.
The testing framework relies on Maven 2’s local repository to provision an embedded OSGi container that the integration test then bootstraps.
This is the default behavior, but as we’re in an Ant appendix, we don’t have a local Maven 2 repository, so we need to override the default behavior.
Fortunately, Spring DM provides enough hooks in its testing framework to do this—we’ll cover that in section C.4
What we have to do immediately is retrieve the bundles we need for provisioning the OSGi container.
For this we’ll use a popular dependency management tool that integrates nicely with Ant: Apache Ivy.
C.3 Provisioning with Apache Ivy Apache Ivy (http://ant.apache.org/ivy/) is a powerful dependency manager that’s primarily used with Ant.
What can Ivy help us with when developing a Spring DM bundle? It will download the bundles we need for our integration test.
These bundles will then be used for compiling the project and provisioning the embedded OSGi container that the test framework launches.
We’ll see in the following sections how to set up Ivy for Ant, how to configure the repositories Ivy will use to retrieve dependencies, and how to declare the dependencies in a configuration file before retrieving them from Ant.
Ivy is launched through an Ant task, so we need to make this task available to our Ant installation.
All we have to do is download the Ivy distribution and copy the Ivy JAR to ANT_HOME/lib, just as we did with Bnd.
Once this is done, all Ivy’s tasks will be available to your Ant build.
We’ll only use the retrieve task here, but before we do this, we need to configure the repositories Ivy will use for retrieving the dependencies.
Ivy can be configured with an ivysettings.xml file located in the same directory as the Ant build file.
This file can contain many configuration options, but we’ll focus on resolvers.
We’ll use a chained resolver here, which successively tries several remote repositories to download dependencies.
The default-chain resolver is set as the default resolver at B and its definition starts at C.
The chain is made of three repositories that host only OSGi-compliant JAR files D and the usual Maven 2 repository, IBiblio E.
Note that this repository will be queried only if none of the previous ones can return a dependency, because it’s the last element in the chain.
The next step consists of declaring the dependencies and modifying the Ant build files to make Ivy download them.
Ivy dependencies are declared in an ivy.xml file, located in the same directory as the Ant build file.
Listing C.8 shows the structure of an Ivy dependency file.
Note that with Ivy, a dependency is identified by its organization, its name, and its revision number.
Ivy also has the notion of type of dependency, but we’ll only use JAR files here, which happens to be the default.
For brevity’s sake, we won’t include the whole set of dependencies needed for running our integration test; you can find the complete Ivy file in the code samples for this appendix.
All you need to know is that these dependencies can be roughly divided into the following categories:
What we need to do next is to Ivy-enable our build file.
Ivy comes with its own namespace that we declare in the root tag of the build file.
This allows the use of the ivy:retrieve element in a target for retrieving dependencies.
Let’s run the resolve target to do so: ant resolve Here is part of the resulting console output:
What did Ivy do? It downloaded the dependencies from the various remote repositories, copied them into a directory to cache them, and then copied them into a newly created lib directory in the project directory.
The project now has the following structure (with the library directory and its content shown in bold):
We’re done with dependencies! It’s time to take advantage of these dependencies to write the integration test and run it using Spring DM’s testing framework.
The test framework handles the bootstrapping of the OSGi container and turns the test into an on-the-fly bundle to run the test methods in an OSGi environment.
In section C.4.1 we’ll see how to write the test and how to compile it by modifying the Ant build file.
Section C.4.3 then covers how to launch the test with Ant.
We’ll stick to Maven 2’s project layout by putting tests in the src/test/java directory of our project.
The project now has the following structure (with the test directory and its content shown in bold):
The test mainly consists of checking that our bundle has been installed and correctly started.
Listing C.11 shows the updates needed in the build file to compile the test.
Modifications start at B, with the declaration of properties for the location of test source files and for the test output directory.
We take advantage of our dependencies at C, by defining a dedicated path for our classpath.
Note that the test compilation target depends on the resolve target D, which means that the dependencies will be retrieved before its execution.
We refer at E to the classpath we created, as the test uses the OSGi API and the Equinox JAR (in the dependencies) provides this.
The test is almost ready to run, but before we do that, we need to tune the Spring DM test framework a little to use the Ivy-managed dependencies.
By default, the test framework uses the Maven 2 local repository to provision the embedded OSGi container that it then bootstraps.
What does the test framework provision the container with? With Spring DM’s bundles (I/O, core, extender, and so on) and their corresponding dependencies (Spring Framework, logging, and the like)
It also provisions the container with the bundles that should be tested together with their own dependencies.
The main issue we’re going to face is the way the test framework locates dependencies: we don’t want it to search the Maven 2 local repository, but rather the directory we copied the dependencies to.
Fortunately, the test framework offers a hook to customize the way bundles are found: the ArtifactLocator.
With an ArtifactLocator, dependencies are identified by their group, ID, version, and type.
We’ll provide a simple implementation that only uses the ID and the version to return a Resource from our lib directory.
Don’t hesitate to write an implementation that suits your needs better.
By default, Spring DM loads the necessary framework bundles and doesn’t load any application bundles.
We’re now done with the customization of the test framework: it uses our Ivy-managed dependencies instead of the Maven 2 local repository.
We can’t say it’s been particularly easy, but Spring DM gives us enough hooks to achieve what we wanted!
Get ready for the last step: running the test with Ant.
Ant has an optional task to launch JUnit tests, which is installed by default in the standard distribution.
When it comes to running tests, Spring DM integration tests don’t differ from plain JUnit tests, as shown in listing C.15
The JUnit Ant task can generate reports—that’s why we define at B a property for the directory where the reports should be generated.
Summary lib directory to make it available for provisioning (with our custom ArtifactLocator)
It takes several options: formatters at E (to set where the results of the tests should be printed–on the console and in XML files in our case), the classpath to use for launching the tests F, and the batchtest element specifying the set of tests that should be launched G.
We’re now ready to run the test with the following command:
The command will trigger the compilation of the SpringDmSample class, the bundle creation, the retrieval of dependencies, the test compilation, and the test launching.
That’s it! We managed to run our Spring DM integration test with a 100 percent Ant solution!
Doing OSGi and Spring development with Ant isn’t only possible, it’s not too difficult at all.
The build file for the Spring DM sample is similar to that of any other project.
Only the packaging task differs; for this we used Bnd to generate the OSGi metadata and create the bundle with the appropriate content.
The biggest difference comes with integration tests, as Spring DM testing defaults to using the Maven 2 local repository for provisioning.
Instead, we used Ivy to gather the necessary bundles and customize the test framework so that it used them from the project directory.
This gives you a shrink-wrapped solution for launching Spring DM-based integration tests but also enough knowledge to build your own solution.
Also keep in mind that once the testing framework is correctly customized, running the integration tests is the same as for any other tests, because Spring DM tests are JUnit-based.
Using Spring DM with Ant won’t force you to change your build habits, and most of your build files can remain the same.
Pax (http://wiki.ops4j.org/display/ops4j/Pax) is an umbrella project for a set of OSGi-based tools.
It is itself part of the Open Participation Software for Java (OPS4J) community, whose open source model is more decentralized and open than that of some other communities.
Pax projects are all about OSGi: some provide basic yet very useful utility bundles, like Pax Logging or Pax URL, and others build on top of these utilities to provide more advanced tools, like Pax Web.
We’ll focus here on two projects from the Pax family:
Both can be very helpful for any OSGi-related task, and they have built-in support for Spring DM.
They’re certainly the best tools for getting started quickly with OSGi, as they hide most of its underlying (and error-prone) aspects.
Throughout this book, we chose to follow a standard Maven-based approach, to show that you can use ordinary tools for OSGi development.
We don’t think relying on automatic tools without any understanding of what they do under the covers is a good approach, and it can put off people who want to know exactly what their tools do for them.
But now that you have a good understanding of OSGi, you may want to be relieved of some of the more tedious tasks that it involves.
Pax Runner control the provisioning, the type of OSGi container (one of Equinox, Felix, or Knopflerfish), and its own specific configuration.
With Pax Runner, you can easily try a set of bundles on different versions of the three open source OSGi 4 platforms, without worrying about having to get them from their respective websites.
You can also provision your entire platform, complete with all the Spring DM bundles and their dependencies, with a simple command-line argument, thanks to Pax Runner’s profiles, which define sets of bundles.
We’ll first cover the basics of Pax Runner (installation, syntax, and miscellaneous options) and then look at advanced topics like profiles, configuration within a text file, and detailed aspects about the provisioning process.
The distribution consists of a compressed file that you can unpack in any directory (from now on, we’ll refer to this directory as PAX_RUNNER_HOME)
Once the installation is done, you can start a command shell in an arbitrary working directory and type the pax-run command.
It also created a runner directory in the working directory for its internal functions (bundles, platforms configuration, and the like)
Let’s see a preview of the available options and switch from Felix to Equinox (use shutdown to exit from Felix)
That’s it for installing Pax Runner and its primary commands; let’s now look in detail at the exact syntax of the tool’s commands.
Pax Runner has a wide range of options, which vary from specifying the target OSGi platform to setting the working directory.
A provision spec is everything that doesn’t start with --
The goal of a provision spec is self-explanatory: it describes where to find one or several bundles.
We’ll see later that Pax Runner supports many formats for provision specs.
Three options—p (for the platform), v (for the version of the platform), and clean (which doesn’t take any value)
One provision spec—the foo.jar bundle that lies in the current directory Options and provision specs can appear in any order, so the following command is equivalent to the previous one:
Windows users must enclose options that contain the equal sign (=) with quotation marks.
Our first command would look like the following on a Windows/DOS shell:
We’ll describe in the next sections the most important options and the kinds of provision specs that Pax Runner supports.
Pax Runner accepts a lot of options; table D.1 lists the most important ones.
Table D.1 doesn’t provide an exhaustive list of the options for Pax Runner, but these are the options you’ll commonly use.
This section covers the platform, p, version, and v options, which let you select the target platform.
Pax Runner lets you switch from one OSGi platform to another easily.
If you want to use the latest version of Equinox, you can use the platform option:
If you don’t want to type the whole word, the p option is a shortcut for platform:
Each platform has an abbreviated name that you can use with either the platform or p option.
The abbreviated name is e for Equinox, f for Felix, and k for Knopflerfish.
That means the following commands are equivalent to the previous ones:
This last command is less readable and less self-explanatory, but it’s quick to type.
If you want to use a specific version of an OSGi platform, you must use the version.
The following command tells Pax Runner to use version 3.2.1 of Equinox:
You should consult Pax Runner’s documentation to find out the exact versions that the tool supports for each platform.
When you don’t specify the version of the platform, the version used depends on the version of Pax Runner itself.
If you use the latest version of Pax Runner, there’s a good chance it’ll use the latest version of the OSGi platforms.
When doing development, you can omit specifying the version, but you should always specify it when you use Pax Runner for a production system.
Pax Runner runs the target OSGi platform in a new process, which means the OSGi runtime has its own JVM, different from the one that the Pax Runner command-line.
This means you can explicitly set the JVM for the OSGi platform process, as well as its parameters (memory, debug, and so on)
Pax Runner uses a working directory to store installed bundles, platform artifacts, and configuration files.
By default, Pax Runner creates this working directory in the current directory and calls it runner.
You can use the workingDirectory option (or its shortcut, dir) to change the default behavior and specify a directory where Pax Runner will store its files:
Note that Pax Runner always creates the working directory if it doesn’t exist.
Specifying a working directory can be useful for gathering downloaded artifacts and configuration; this avoids downloading the same files repetitively and saves disk space.
In contrast, you can use the clean option to delete the working directory.
By doing this, all artifacts (bundles, frameworks, JARs, configuration files, and the like) will be removed, and Pax Runner will recreate the working directory.
The following command tells Pax Runner to delete the default working directory with the clean option:
This ends our tour of the most common Pax Runner options.
The args and profiles options, which allow you to specify options in a dedicated file and to provision the platform with a set of bundles, respectively, will be discussed later on their own.
In the next section, we’ll cover one of the most interesting features of Pax Runner: provisioning.
Provision specs are the other kind of parameter that the Pax Runner command line accepts.
They specify how to get, install, and start OSGi bundles within the target OSGi platform.
When it comes to provision specs, Pax Runner relies heavily on Pax URL, another project in the Pax family.
Pax URL provides different URL handlers, in addition to those supported in Java.
In the previous samples, we saw that we can provision the OSGi platform with a bundle from the filesystem:
We also saw how to get this bundle from a web server:
Java supports these two protocols natively—that’s why we can use them as provision specs with Pax Runner.
Thanks to Pax URL, Pax Runner supports other protocols: mvn to get bundles from the local Maven 2 repository, obr to retrieve bundles from an OSGi bundle repository, and so on.
Provision specs aren’t only about protocols: Pax Runner can also scan directories or read text files that specify the location of bundles.
Pax Runner can also combine these different types of provision specs, which makes its provisioning capabilities powerful and flexible.
In the following sections, we’ll guide you through the most useful provisioning features of Pax Runner and provide you with guidelines for using them efficiently.
We already know that we can provision the target platform with a single file.
Let’s just add that we can specify more than one file:
Listing all the bundles can be cumbersome, especially when their number grows.
Pax Runner is able to scan a directory and provision the platform with all the bundles that reside in that directory.
All we have to do is give the path of the directory:
We used the absolute path in the preceding example, but Pax Runner accepts relative paths too.
You can also ask Pax Runner to scan immediate subdirectories by adding the asterisk (*) character at the end of the directory:
Pax Runner is able to get bundles from a zip file.
All you have to do is give the path of the archive:
Pax will unpack the archive on the fly and provision the platform with the bundles it contains.
You have a great deal of flexibility in specifying the path to the archive: relative, absolute, or even remote.
The following command tells Pax Runner to get bundles from a remote zip file:
Using a zip file is convenient when you want to distribute a set of bundles; Pax Runner makes the provisioning entirely transparent thanks to its automatic unpacking.
The following command shows the use of the Maven 2 protocol:
You can also specify the URL of a remote repository:
When the number of bundles in your application grows, or when you want to mix different ways of provisioning the platform, the command line quickly becomes inefficient.
Pax Runner lets you provide the location of your bundles in a text file.
Here is an example of a text file that contains two provision specs:
If the name of this file is bundle.txt, we can tell Pax Runner to use it simply by providing its name:
Note that Pax Runner ignores empty lines and lines that start with #; this can help improve the readability of large provisioning text files.
These files can also contain the definitions of system properties, which will be available in the process of the OSGi platform.
The following snippet shows a provisioning text file that combines mixed provisioning, empty lines, comments, and the assignment of system properties:
We’ve seen so far that provisioning specs mainly consist of URLs, but even if the URL is the most important element, it’s only one part of a provisioning spec.
Pax Runner recognizes the following format for a provisioning spec:
The following commands illustrate the use of these provisioning options:
These options also apply to other protocols (http, mvn, and so on), as well as to the provisioning of text files.
You now have a good overview of Pax Runner’s provisioning capabilities, and you can see that you’re somewhat spoiled for choice; that’s why we provide some guideline recommendations in the next section.
The main guideline of Pax Runner provisioning is to maintain consistency: avoid mixing different kinds of provision specs (command line, text files, and others)
Your usage will be driven by your needs and context, and these will at least partly depend on whether you’re using Pax Runner for development or distribution.
For day-to-day development, including the provisioning spec in the command line is useful: it’s a handy way to quickly test a bundle on different OSGi platforms.
You can then use the various protocols (file, or mvn if you use Maven 2) for building your bundles.
When distributing an OSGi application to end users, using zip provisioning is probably the most simple and straightforward way to go.
The text file is more appropriate when the application needs more configuration (like system properties)
As the text file also accepts all the protocols, it’s well suited for development-based distributions (like the code samples of this book, which you can build with Maven 2 and then launch, thanks to a text provisioning file)
We advise you not to mix different kinds of provisioning specs, but there’s one case when it can be useful.
Imagine that you have written some Spring-powered bundles and you want to test them.
The provisioning for Spring DM’s bundles would always be the same, so you’ll save yourself trouble if you include it in a text file and then specify your Spring-powered bundles on the command line.
You’ll then end up with your own reusable provisioning text file.
This is a rather manual way of gathering a provisioning definition in a text file and it leads us to the next topic: profiles.
In Pax Runner, profiles allow us to quickly provision an OSGi platform, because they define consistent and ready-to-use sets of bundles.
In Pax Runner, a profile defines a consistent set of bundles that together provide one or more features.
These features range from logging to web support to Spring DM support.
The following command provisions the container with the OSGi compendium bundle:
You can specify more than one profile by separating them with a comma.
The following command provisions the container with the Pax Logging and Pax Web bundles:
You can also specify the version of the profiles by appending a slash (/) and then the version number:
Because profiles generally gather the bundles for specific projects (Pax Logging, Pax Web, and the like), the profile version is usually the same as the target project version.
As of version 1.2.0, Pax Runner considers profiles to be like any other provision specs, which means that the profiles option can be omitted.
The following snippet shows the equivalent of the three previous commands without using the profiles option:
Whether or not you use the profiles option is a matter of taste, even if readability and clarity matter.
Thinking of the profile feature as a special kind of provision specification (which don’t use any options) argues in favor of omitting the profiles option.
What makes profiles really interesting is that Pax Runner comes with a lot of them.
Table D.2 lists some of the main ready-to-use profiles included in Pax Runner.
Profiles are defined through provisioning text files, which are hosted on a Pax Runner web server.
Note that profiles can rely on each other: for example, the spring.dm profile “imports” the spring profile in its definition.
Including it is now up to the user, and even though some profiles depend on the Compendium bundle (like the log profile), it must still be explicitly added to the command line.
Pax Runner comes with a Spring DM profile, which makes provisioning an OSGi platform with Spring DM’s bundles (and their dependencies) using Pax Runner as simple as the following command:
We chose the hard way to show you what needs to be done and to illustrate what was happening under the covers.
Nevertheless, if you want to quickly test your Spring-powered bundles, Pax Runner and its Spring DM profile are obviously a good solution.
The profiles option is just another Pax Runner option, so it can be used together with any others or even with the provisioning specs we’ve seen so far.
This means you can complement the provisioning of one or more profiles with your own provisioning specs.
Profiles are just another way for Pax Runner to simplify the provisioning of the target platform.
To further simplify the launching of Pax Runner, let’s look at how to specify the entire command line in a file.
We’ve seen so far that Pax Runner comes with a lot of options and provisioning capabilities.
Launching OSGi applications can require a lot of options, and even though the provisioning can be specified in a file, the Pax Runner commands can become long and error-prone.
That’s why the args option exists: it specifies a text file that contains all the options, as well as the provisioning specs.
The following snippet shows how to specify all the command-line options and provisioning specs in a file:
Let’s imagine the previous file is called paint.args and is located in the current directory.
You can use it to launch Pax Runner with the following command:
You’ll probably be happy to learn that using a text file for options is the default for Pax Runner: when you launch the pax-run command without any options, Pax Runner looks for a runner.args file in the current directory and uses it if it’s available.
That means placing all the options in a text file is the way to go when distributing OSGi applications with Pax Runner.
Imagine including all the advanced provisioning specs we saw earlier (filesystem, remote, zip, and so on) in a runner.args file, along with miscellaneous options (type and version of the platform, JVM options, and others) and letting Pax Runner trigger the platform and do the provisioning: the result is a simple, reliable, and portable way to launch your OSGi applications.
It also applies to daily development tasks, when you want to quickly test bundles.
This ends our tour of Pax Runner, which you should consider an essential part of your OSGi tooling.
As we mentioned earlier, Pax Runner can help distribute your OSGi applications.
It’s also very useful for day-to-day development, and we’ll see in the next section that it’s included as the default launch tool in Pax Construct, a set of Maven 2 plug-ins for OSGi development.
D.2 Pax Construct Pax Construct is a tool for creating, building, managing, and deploying OSGi-based applications.
Whereas the Apache Felix Bundle plug-in offers a simple, yet powerful, new kind of packaging (based on Bnd), Pax Construct offers tooling for the whole build process, from creating a project through to packaging it and running it.
Why didn’t we introduce Pax Construct earlier, or even use it throughout the book? Mainly because it’s another layer between OSGi and the developer, and we wanted to focus on OSGi and Spring DM.
Nevertheless Pax Construct is great for managing your OSGi build or for getting started with OSGi (if you don’t want to be bothered with what happens under the covers)
In the following sections, we’ll provide a comprehensive introduction to Pax Construct, from installation to creating a module-based project, creating Spring-powered bundles with Pax Construct’s archetypes, and packaging and executing the application.
We’ll use a simple example based on a data source bundle and a database client bundle, which will give us the opportunity to illustrate most of the features of Pax Construct.
By the end of this section, you’ll know how and, more importantly, when to use Pax Construct.
At the heart of Pax Construct is a Maven 2 plug-in, but the Pax Construct’s team provides a set of scripts that encapsulates the calls to the underlying plug-in.
Pax Construct, you can either stick to using a 100 percent Maven command approach or combine the scripts and the Maven command.
We’ll use the latter approach here, as the scripts offer useful shortcuts, especially for arguments, and they don’t limit the capabilities of the tool.
The distribution consists of a compressed zip file that you can unpack in any directory (which we’ll refer to as PAX_CONSTRUCT_ HOME from here on)
You should then add the PAX_CONSTRUCT_HOME directory to your PATH environment variable so that you can launch Pax Construct scripts from anywhere.
Table D.3 lists all the scripts available in Pax Construct; we’ll use each of them and look at their options as our example progresses.
Each Pax Construct script accepts its own set of parameters, as well as Maven 2 options.
The script handles the parameters, whereas Maven 2 options are handed.
To clearly identify the two parts of the command, you must separate the parameters from the Maven options with two hyphens: --
The following snippet shows a Pax Construct command that uses both parameters and Maven 2 options:
Now that you have Pax Construct up and running on your computer and you know the basics, let’s create our first project with this new tool.
We’re going to create a project using Pax Construct’s archetype, which leverages the module-based layout of Maven 2 projects.
To create the project, open a shell in a working directory and type the following command:
The execution of the script results in some typical Maven 2 output.
The -g and a parameters refer to the Maven 2 coordinates of the project (the group ID and the artifact ID, respectively)
You could alternatively have typed the pax-createproject command, and you would have been prompted for the coordinates of your project, which is convenient when you don’t remember the exact names of the parameters.
If you take a look at the content of the dbapp directory, you’ll see a pom.xml file at the root and some directories that the archetype created.
Don’t feel overwhelmed by the apparent complexity of the project layout; we’ll discuss each module when the time comes.
You can cd to the newly created dbapp directory and use the pax-provision command to launch your project in an OSGi container:
With the pax-provision command, Pax Construct provisioned the default OSGi platform (Felix) with the content of your project and used Pax Runner to launch the platform.
Because we haven’t created any bundles so far, the platform instance contains only the bundles essential for Felix to run.
Type shutdown to exit from Felix, and edit the pom.xml file.
If you rerun the pax-provision command, Pax Runner will launch Equinox:
Before creating our bundle subprojects, we need to instruct Pax Construct to provision our project with Spring DM.
To tell Pax Construct to provision the project with Spring DM’s bundles, we need to add Maven 2 dependencies.
But as Spring DM refers to specific bundles that aren’t available on standard Maven 2 repositories, we first need to add the SpringSource EBR to the project.
The pax-add-repository command has two mandatory parameters: the repository’s identifier (-i) and the repository’s URL (-u)
With the previous command, we added the repository that contains the Spring Framework’s and Spring portfolio projects’ binaries.
They’re distributed as OSGi bundles but rely on external dependencies (such as Commons Logging and AOP Alliance), which are available as OSGi bundles on another repository, called the “External” repository.
We’re now ready to add the Spring DM bundles to the project.
Note that we used Maven 2 options in the previous command to add all of Spring DM’s transitive dependencies (widenScope to include compile and runtime dependencies, and importTransitive to import any provided OSGi dependencies)
Pax Construct gathers the declaration of these runtime dependencies in the provision/ pom.xml file.
We can now try to launch the project and see if Spring DM extender is properly deployed (we removed some unnecessary lines from the output for brevity):
Pax Construct leveraged Pax Runner to provision the platform from the Maven 2 local repository.
The Spring DM’s bundles have been correctly installed (with their dependencies)
This gives us the opportunity to create our first bundle with Pax Construct.
A fragment is a special kind of OSGi bundle, so we can use the pax-create-bundle script to create the skeleton of our bundle:
The -p and -n parameters refer to the package and the name of the bundle, respectively.
We don’t really need to fill in the package name, as our bundle will contain only the Log4j configuration file.
We also include Maven 2 options to disable the creation of some classes and interfaces that the archetype creates by default.
This module has the layout of a standard Maven 2 project.
We need to perform the following tasks to organize our fragment:
Delete the content of the src/main/java directory (our fragment contains only a configuration file)
Create a src/main/resources directory and create a log4j.properties file in it.
Our bundle is a fragment, so we need to know its host bundle.
We can learn this by issuing the ss command on Equinox:
Do I really need all these bundles? If you take a closer look at the bundles loaded in the platform, you’ll see that Pax Construct included a lot of them, some of which we won’t need.
That’s a limitation of the tool: it can help you get started quickly, but you’ll sometimes need to clean up after it.
In our case, we’d need to remove some of the unnecessary dependencies.
We’ll just live with them for the duration of this introduction to Pax Construct.
But where should we add the Fragment-Host header? Pax Construct uses the Felix Bundle Plugin internally, but in a slightly different way than we’ve used it so far (more about this later)
The only thing you need to know right now is that Pax Construct’s archetype created an osgi.bnd file in the module directory, and we can use it to include OSGi headers.
To attach our fragment to the Log4j bundle, add the following entry to the osgi.bnd file (and remove what the archetype added by default):
The nasty warning should have disappeared, and by using the ss command, you can check that the Log4j bundle discovered its fragment:
The dbapp.log file lies in the runner directory, which is the default working directory of Pax Runner.
We’re now ready to write our first Spring-powered bundle using Pax Construct, in which we’ll define the data source of our database application.
Our simple database application needs a connection to a database; that’s why we’re about to create a bundle that will publish this connection as an OSGi service.
We’ll be using the DataSource interface for our connection, because it’s a good example of a service: an object implementing DataSource can encapsulate advanced features, like pooling, behind a simple interface.
Let’s keep things simple for the moment: we’ll use an in-memory database (H2) and a simple DataSource implementation that Spring provides (the persistent database and the connection pool will come later)
Let’s create the data source bundle: cd to the base directory of the project, and launch the command shown in the following snippet:
Pax Construct configuration files, located where Spring DM expects to find them: in the META-INF/ spring directory.
It’s not a connection pool because it creates a new connection on each call to getConnection, but its ease of configuration is suitable for development or testing.
This is done in the osgi.bnd file of the data source project, with the Import-Package manifest header:
We also need to provision the OSGi platform with the bundles exporting the packages we imported.
These are the H2 library, the JDBC Spring module, and its dependency, the Spring Transaction module.
You can now check that the data source is properly configured and published by launching the platform with the mvn clean install pax:provision command.
Even though our data source is a little simple, it’s fully functional, and creating it has illustrated the support that Pax Construct provides for Spring DM projects.
As a database is nothing without clients connecting to it, we’ll create a Spring-powered client bundle next.
Our database client bundle will only display on the console the name of the database engine.
Even if this appears simple, this bundle will be a full-blown Spring-powered bundle that leverages Spring DM’s declarative service importing and dependency injection.
Let’s create the project by launching the following command from the root of our project:
The following snippet shows the source code of the DataBaseClient class:
The database client isn’t very useful, but it’ll tell us if our data source bundle is operational.
Where does the preceding snippet’s dataSource bean come from? From the data source bundle we created previously, of course! Thanks to Spring DM, we can import it from the OSGi service registry by leveraging the osgi namespace.
To avoid any import-package surprises, modify the osgi.bnd file to import every package that the bundle source code refers to:
You’re now ready to test the database client bundle by launching the mvn clean install pax:provision command from the root of the project.
You should see the long-awaited message a couple of seconds after the osgi> prompt has appeared:
Where are the packaging instructions? The bundle projects we’ve created so far with Pax Construct use a common parent POM that contains some instructions for the Felix Bundle Plugin.
By doing this, Pax Construct centralized the generic parts of the packaging.
As we already saw, these instructions can be modified on a per-bundle basis via the dedicated osgi.bnd file.
Another brick in the wall of our database application! This simple client is a way to check if the data source is up and running, so that’s a good reason to play around with the data source service.
In the next section, we’ll see how to replace our simple data source with a fullblown connection pool, made possible by the OSGi-ification of the DBCP library.
Unfortunately, DBCP isn’t distributed as an OSGi bundle, so we’ll have to wrap it.
Fortunately, Pax Construct comes with a script that makes OSGi-ification easy.
Once DBCP is OSGi-ified and included in our project, we’ll modify the data source bundle to use it.
What we’re about to do is more straightforward and ends up being a little less modular than the solution adopted in chapter 6, but the end justifies the means.
To wrap a library as an OSGi bundle, Pax Construct provides the pax-wrap-bundle script, which requires the Maven 2 coordinates of the target library.
It can also handle a bunch of optional Maven 2 options, but we’ll only look at a few of them (don’t hesitate to check the reference documentation to learn more about them)
To start the OSGi-ification of Commons DBCP, cd to the root of the project and launch the following command:
In this command, the most interesting option is embedTransitive: it tells Pax Construct to wrap in the resulting OSGi-ified bundle not only Commons DBCP but also all its dependencies.
Commons Pool is the only dependency of Commons DBCP, so its class files will also be included in the wrapper.
That’s why our solution is less modular than the one adopted in chapter 6, where we wrapped each library in its own bundle.
Wrapping two different libraries in the same bundle isn’t particularly modular—it will be more difficult to upgrade one without also updating the other.
Nevertheless, this rather unorthodox solution is sufficient for our simple database application.
They provide all the instructions that the Felix Bundle Plugin needs to wrap DBCP and its dependency, Commons Pool.
Chapter 6 gives all the details, so you should refer to it for more information.
This is the result of the embedTransitive option we used in the previous command, and this is reflected in the Bnd configuration file, osgi.bnd, that Pax Construct generates:
Because our DBCP bundle will connect to the H2 database engine, we must make the driver visible to DBCP, still in the osgi.bnd file:
Our DBCP bundle is now ready; you can check if it can be deployed on Equinox by launching the project.
It should appear in the ACTIVE state in the list of bundles:
The next step is to reconfigure the data source bundle to use the DBCP pool implementation.
Using a connection pool just requires an internal modification of the dbapp.datasource module: it has no impact on the bundles that use the data source service, because it’s hidden behind the DataSource interface.
We use the default configuration of the DBCP pool here; don’t hesitate to consult the reference documentation for the advanced settings (maximum number of connections, validation query, and the like)
The database is no longer in memory; it now uses the H2 server engine, which is persistent.
You can now test that the connection pool works correctly by building and launching the whole project.
There’s no difference for the client bundle; it still asks the data source service for a connection, but now this connection comes from a full-blown connection pool, which ensures the application scales under heavy load.
If you stick to Spring, this implies using a JdbcTemplate and adding the corresponding import.
We leave this as an exercise; you can check the book’s source code if you want to see how to implement this.
Even though we covered most of the Pax Construct scripts, we only scratched the surface of the tool—it offers many options and features.
Pax Construct’s approach, which uses a module-based Maven 2 project, allows us to start OSGi development quickly and offers consistent and comprehensive default settings.
Pax Construct builds on top of tools like the Felix Bundle Plugin, which we covered in this book, and takes care of the tedious initial settings.
This makes the projects created by Pax Construct ready to use on an OSGi platform.
Even if you don’t use them for all your projects, they’re certainly a great help for distributing OSGi applications or quickly building OSGi projects.
Pax Runner makes it easy to launch and provision an OSGi container.
It’s very flexible, and operations like switching from one container to another or provisioning from the local Maven 2 repository are just a matter of command-line arguments.
Pax Construct leverages many tools (Maven 2, the Felix Bundle Plugin, Pax Runner) to provide a consistent way of creating, building, and managing OSGi projects.
It offers OSGi-oriented commands, like wrapping an existing library as an OSGi bundle, that streamline the development process.
This relieves the developer from tedious and error-prone tasks like provisioning, and it also adds some flexibility, like the possibility of choosing the framework version with a commandline argument.
We based most of the samples in this book on more traditional approaches (manual provisioning, Bnd, and the Felix Bundle Plug-in) because they make it easier to understand the underlying mechanisms.
This also shows you that OSGi development isn’t so different from traditional development and doesn’t necessarily imply using different tools.
Nevertheless, Pax Runner and Pax Construct are a consistent and logical evolution of the tooling of a well-informed OSGi developer.
That’s why they deserve a whole appendix in a Spring DM book.
With Spring DM, you can easily create highly modular applications and you can dynamically add, remove, and update your modules.
Spring Dynamic Modules in Action is a comprehensive tutorial that presents OSGi concepts and maps them to the familiar ideas of the Spring framework.
In it, you’ll learn to eff ectively use Spring DM.
You will master powerful techniques like embedding a Spring container inside an OSGi bundle, and see how Spring’s dependency injection compliments OSGi.
Along the way, you’ll learn to handle data access and web-based components, and explore topics like unit testing and confi guration in OSGi.
Th is book assumes a background in Spring but requires no prior exposure to OSGi or Spring Dynamic Modules.
Developing OSGi web components with Spring DM and web frameworks.
Support for OSGi compendium services 11.1.1 What are compendium services?
