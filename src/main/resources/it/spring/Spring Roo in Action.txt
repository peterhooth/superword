No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form or by means electronic, mechanical, photocopying, or otherwise, without prior written permission of the publisher.
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in the book, and Manning Publications was aware of a trademark claim, the designations have been printed in initial caps or all caps.
Java has been the world’s most popular programming language for well over a decade.
You can find it running everywhere: on super computers, servers, set top boxes, PCs, phones, tablets, routers, and robots.
There are millions of expert engineers fluent in it, libraries for every conceivable purpose, and unparalleled tooling and management capabilities.
Today, most developers enjoy considerable latitude in their ability to use liberally licensed open source software.
So this book has undergone at least three major revisions since the time we started writing it.
Our pain is your gain, and that includes all of our hard work with code that was written the night before, identifying bugs for the Roo team to fix, and working with the fantastic community of readers we have in Manning’s MEAP program, aligned as well with completing the manuscript around the time of the Roo 1.2.1 release.
There are many people we want to thank for their help in making this book, starting with the Manning team: Michael Stephens, who first discussed the project with us; Christina Rudloff; the inimitable Marjan Bace; marketing genius Candace Gillhoolley; and our wonderful editors, in order of appearance: Emily Macel, Sara Onstine, and Sebastian Stirling.
They were absolutely invaluable in providing advice and critiques, and in revving us up when we were out of juice.
We wish to thank our production team of Mary Piergies; maestro Troy Mott and his band of merry editors: Ben Berg, Tara McGoldrick, and Bob Herbstman; our talented proofreaders: Katie Tennant and Alyson Brener; and others behind the scenes whom we are not able to name.
The reader community also deserves a huge amount of credit.
Brown, varevadal, Terry Jeske, and Jeff Hall, among others, helped us find bugs, from the stupid to the super-complex, and gave us honest feedback when we needed it most.
Finally, we’d like to thank the Roo development team for being there and fixing bugs almost before we thought them up: Dr.
Thank you for accepting our JIRA reports and working up fixes so.
Special thanks to Ben for agreeing to write the foreword to our book, and to Alan and Andrew for a final technical proofread of the manuscript just before it went into production.
I dedicate the book to my wife, Kris, because without seeing her complete more than nine books while raising our boys, I never thought I could finish this project.
She can now finally stop saying, “Give the guy room, he’s writing a book, you know.”
I would also like to acknowledge my employer, Chariot Solutions, for their support of the book by giving me a forum for training courses (http://chariotsolutions.com/ education) and podcasts (http://techcast.chariotsolutions.com), and allowing me to participate in other endeavors, such as the Emerging Technologies for the Enterprise conference (http://phillyemergingtech.com) that also inform my writing.
I would be remiss if I didn’t thank Gordon Dickens for his research and writing contributions during the beginning of this book project.
He and I are close friends, and without our crazy plan, hatched one day after the interview with Ben Alex, I might not have reached out to Manning.
It’s been a rewarding experience to contribute to the book as well as learn from others about authorship.
I also want to thank Ken Rimple for his guidance and mentoring in my transition from writing articles to writing a book.
I would like to also thank my wife Kavitha and my seven year-old daughter Srihasa for their continued support and patience during the writing of this book.
Welcome to Spring Roo in Action! If you’re reading this book, you’re looking for ways to improve your Spring development productivity.
Combine it with Git for version control, and you can create a branch for your new idea, try it out, and merge it back in if you like it.
Of course, because branches are cheap, you can remove the branch and forget it ever happened.
We encourage you to create a lot of throw-away projects with Roo.
Chapter 3 is an introduction to database persistence in Roo.
We detail the options for setting up persistence using JPA, setting up a JPA entity, using the Bean Validation framework to provide annotation-driven validations, how to use finders to write simple JPA queries, and how to create repositories using the repository command and the Spring Data API.
Chapter 6 digs deeply into the scaffolding engine and Roo’s tag libraries.
We show you how you can customize the scaffolded web views, and how to modify the way fields are displayed.
We outline how to display reference data in drop-down lists, customize date fields, deal with localization and theming, and we show you how Roo uses Apache Tiles to lay out your user interfaces.
We start by showing you how to use Spring MVC and Dojo to provide Ajax support for your forms.
We then show you how to install two other web frameworks, Google Web Toolkit and JavaServer Faces.
We end by listing a few other web frameworks and the support that Roo had for them at the time we wrote the book.
We cover unit testing and Mockito, mocking the persistence tier, integration testing in-container against entities, repositories and services, and how to write functional, black box tests with Selenium, both using Roo’s support for HTML table-based tests as well as using the JUnit API.
Chapter 10 discusses email and JMS, two external integration points that most developers have to work with at some point in their careers.
We begin by outlining a course management system, and then lay down the JMS and email features required to support that system.
We cover JMS installation, the JMS template, building a POJO listener, and testing the listener.
Then we cover building email messages with an email sender, configuring SMTP support, building an email template, and hosting it behind a Spring service.
We start by showing you how to search for publicly available add-ons and how to install and remove them.
Because add-ons are OSGi components, we spend time detailing enough of OSGi to be dangerous, and then we dive right in and create three add-ons: a Norwegian language addon, a Roo wrapper add-on to expose a non-OSGi JAR to the Roo system, and a “Simple” add-on to provide jQuery support.
Chapter 12 continues our add-on discussion and provides support for CoffeeScript by creating an advanced add-on.
We install the Maven plug-in for CoffeeScript compilation, build and test it, and show you how to detect the availability of both adding and removing the feature from your project.
We then wrap up the discussion by detailing how to publish and submit your add-on to the add-on community.
Chapter 13 shows you how to use cloud computing to host your Roo applications.
We discuss some of the platforms, including CloudBees and Heroku, and then focus on using Cloud Foundry, a VMware hosting offering.
We deploy the Course Manager application to the cloud and show how to fetch application statistics, as well as how to bind cloud resources to the application.
Chapter 14 details how to use Spring Integration from a Roo project.
We discuss event-driven application architectures, how to add a workflow to handle course registration, and how to build and install the Roo integration add-on from source, because it’s not yet released for Roo 1.2
To follow along with the book, you’ll need to download and install Spring Roo, version 1.2.1, from http://springsource.org/spring-roo.
You’ll also need an IDE; for the new Spring developer, we suggest using SpringSource Tool Suite.
This special version of Eclipse is fully configured to develop Spring-based applications, and can be configured to use your Roo shell.
IntelliJ is an excellent alternative IDE, and provides support for many of the same features as SpringSource Tool Suite, the key omission being an integrated copy of the Spring tc Server web application server, which comes bundled with STS.
You’ll also need to install Maven 3.0.3 or higher, because Roo projects are Maven projects.
If you’re going to write your own add-ons, you’ll need to install GPG, an open source encryption provider.
To make these add-ons available to the public, you’ll want to install Git and/or Subversion (SVN) to deliver your add-ons to public repositories hosted by Google Code, GitHub, or other places where the Roo team can access and index your add-on.
Users of earlier versions of Roo will need to make some adjustments in their shell commands, and the classes will look notably different.
We’ve found the best course of action is to perform the upgrade, but then create a brand new scratch Roo project with the features you’re using, and diff the pom.xml file to make sure that you’ve been properly upgraded to the most recent version.
Refer to the Roo documentation for details for each official release.
We occasionally use the continuation character to show a long line in a generated artifact as well.
The source code for Roo in Action is available at http://github.com/krimple/springroo-in-action-examples.
You can also find links to the source code repository and a post-publication errata list on the Manning page for this book, http://manning.com/ SpringRooinAction.
As the Roo project progresses rapidly, we’ve constantly been reworking our examples and upgrading them before publication of the book.
If you find a problem with the samples, please log a bug with the project by creating a GitHub account and clicking on the Issues tab.
We’ll also be taking contributions of example code to share with our readerscontact us via GitHub with pull requests to the user-contrib directory and we’ll review them.
Assume that your samples will be available for use by the public Roo user community, and that the code should be freely contributed without additional restrictive source licenses.
Any contributions are welcomed by the reader community, so feel free to lend your expertise.
If it contains a readme.txt file, please review it before running the sample.
This file may contain instructions on how to build, run, or review the individual sample.
The purchase of Spring Roo in Action includes free access to a private forum run by Manning Publications where you can make comments about the book, ask technical questions, and receive help from the authors and other users.
This page provides information on how to get on the forum after you’re registered, what kind of help is available, and the rules of conduct in the forum.
Manning’s commitment to our readers is to provide a venue where a meaningful dialogue among individual readers and between readers and authors can take place.
It’s not a commitment to any specific amount of participation on the part of the authors, whose contribution to the book’s forum remains voluntary (and unpaid)
We suggest you try asking the authors some challenging questions, lest their interest stray!
The Author Online forum and the archives of previous discussions will be accessible from the publisher’s website as long as the book is in print.
He has had an obsession with creativity in music and computers his whole life.
At the same time he began his lifelong love affair with the drums.
Today he’s a jazz drummer who plays whenever he can.
Ken has been active in emerging technologies since he entered the IT sector in 1989, at the dawn of the client/server movement.
He’s worked on technologies from fat clients to databases to servers, ranging from WebLogic to Tomcat.
He is currently immersed in Spring technologies, including Roo and Grails.
Ken runs Chariot’s education services (http://chariotsolutions.com/education) where he teaches Spring-related VMWare courses, including Maven and Hibernate, among others.
He also hosts the Chariot TechCast (http://techcast.chariotsolutions .com) podcast, and blogs at http://rimple.com.
He has over 16 years of experience in software architecture, security, and.
Dress codes and lifestyles have changed over the last 200 years, and the diversity by.
It’s now hard to tell apart the inhabitants of different continents, let alone of different hamlets or towns separated by only a few miles.
Perhaps we have traded cultural diversity for a more varied personal lifecertainly for a more varied and fast-paced technological life.
Manning celebrates the inventiveness and initiative of the computer business with book covers based on the rich diversity of regional life of two centuries ago, brought back to life by illustrations from old books and collections like this one.
Spring Roo is an excellent framework for the rapid development of Springbased Java applications.
With a simple command-line shell, it can create and manage Spring applications, adding and configuring components in all of the application architecture layers from SQL to URL, so to say.
We start exploring Roo with chapter 1, “What is Spring Roo?” explaining how Roo works and how it helps with creating the various configuration files required for a typical Spring application.
You’ll also learn how to install and launch the Roo shell.
We’ll look at a simple application by running one of the sample scripts provided in the Roo installation package.
You’re about to be introduced to a powerful new tool that makes your life as a Java.
Spring operates on the principle of making your development less about busy work and more about writing business logic.
Spring application developers define interface-driven beans that are then implemented as Plain Old Java Objects (POJOs) and mounted in a Spring container using XML, annotations, or Java-based configuration directives.
Configuration is a burden 5 Here’s an example business interface:
One way you can use this bean is to autowire it as shown next:
We’re leaving out the configuration here, but the basic idea is a simple one: let Spring find and mount your component, deal with it at the interface level, and just write a POJO both to expose and use your component.
Even Spring can’t save you from all of the tedium involved in building an application.
There are many decisions that you need to make, as shown in figure 1.1
Figure 1.1 The number of choices when working in an Enterprise Java application is mind-numbing!
Spring makes those tasks easier and shifts some of them to configuration, rather than coding, such as these:
Since Spring is so configurable, it almost provides you with too many choices of how to implement your solution.
It’s an extremely flexible platform for development, but it can be difficult to make a good decision on how to move forward.
The more choices developers are faced with when attempting to make a decision, the more difficult that decision becomes.
Some developers may just begin to select a configuration option at random, or start experimenting with several, comparing the results.
All of this takes time and can really hold up a project.
For example, the Spring JDBC API component, JdbcTemplate, provides method calls to query, insert, update, and delete data, which can be as short as a single line.
Here’s the Spring JDBC template method to fetch a single value from a SQL statement:
Simple, isn’t it? The JDBC template does all of that boilerplate work for you and throws a translated Spring runtime exception if the query fails so that you don’t have to write tedious try ...
Spring eliminates the layers of exception hierarchies such as your application datalayer exception, service-layer exception, and web-layer exception.
Sound familiar? If not, it’s likely because you’ve been working with Spring, which pioneered using runtime exceptions over declarative ones.
Another way Spring helps is by providing factory beans to easily configure enterprise APIs.
Those of you who’ve configured Hibernate applications by hand will appreciate Spring’s ability to set up Hibernate this way:
We may abbreviate those names because we know that most developers can use an IDE or even Google to look up the packages of well-known classes such as the one above.
Spring can use Java EE annotations to expose and consume resources.
Somebody still has to configure JPA for the project, come up with a persistence strategy, and show the other developers how to use it.
Let’s see how much work you would still have to do by hand in a Spring-based application:
Include dependent JAR files in the project for the JPA API, as well as a number of ORM vendor JAR files.
Install a JDBC data source, and include the JAR files for the data source and the database driver.
Configure a transaction management strategy in Spring to associate with the database data source and JPA.
To actually use the JPA API in your project, you’d have to do the following:
Create a repository class, and inject it with an EntityManager instance from the configuration above.
Rapid application development frameworks, such as Ruby on Rails or Grails, narrow choices and implement programming patterns in a simple yet predictable way.
Configuration is a burden also focus on removing repetitious configuration and coding from your application.
They’re only as good as the template maintainer’s diligence provides.
Once you create your project from the template, there generally is no easy way to upgrade it.
Plus, you still end up spending time manually configuring Spring for additional features needed by your application.
In short, Roo gives Java developers the same productivity that other RAD platforms have.
Roo makes life easier for the average Spring programmer by managing the busy work and implementing the code with sound architectural patterns.
When you ask Roo to set up your persistence tier, it responds by adding JPA, Hibernate, validations, transaction management‚ and a pooled data source.
When you need to send or receive JMS messages, a single command in Roo sets up your JMS listener or templates, and you can immediately get to work coding your sending or receiving bean.
The Roo tool provides an add-on system that enables developers to add new features, such as web application frameworks, databases, enterprise APIs, and more.
You can write your own add-ons and use them for your own projects, or even contribute them to the public directory.
If you don’t like a feature provided by Roo, customize it or remove it.
Roo will do as much or as little as you want.
From a developer’s perspective, Roo pulls the tedious code out of your classes and into files that it manages for you.
For example, your JPA entities will contain only the code that defines the fields, validation rules, and specific logic you require.
Behind the scenes, Roo will implement the setters, getters, persistence management, and even toString() methods in hidden files.
You can choose to write these elements yourself, but the advantage of doing so is eliminated for the majority of your code.
Have we whetted your appetite? Then let’s get going! We’ll start by installing the Roo shell.
To show you just how powerful Roo is, you’ll create and review one of the sample applications provided by the Roo team—the Pizza Shop.
After installing the Spring Roo path into your environment, open an operating system command line in an empty directory.
Roo will respond with a banner and a roo> prompt:
The Roo shell does the heavy lifting of configuring and maintaining your project.
Once launched, you interact with the shell by entering configuration commands, and Roo responds by modifying or creating the necessary files in your project.
In the next chapter, we discuss how to create your own project from scratch.
But for now, we’ll use the Roo script command, which executes a script provided to it by the user.
Let’s use this command to set up a sample application.
Other Roo scripts To experiment with a more complex model, create additional empty directories and experiment with the following prebuilt scripts:
You can find these scripts in the /samples folder of the Roo software installation directory.
Anything placed in this directory is available for execution using the script command.
The pizzashop.roo sample is a simple demonstration application that simulates a basic pizza shop.
It allows the user to define bases, toppings, pizzas‚ and orders.
Create an empty directory somewhere called pizzashop, and open your OS command-line shell in that directory.
You’ll see Roo go to work, executing commands and building your project.
If you’re watching the directory from a file manager, you’ll see it quickly expand into a fullfledged project structure.
What just happened? Everything! Roo just built a fully configured Spring application with the following features:
A JPA container, using EclipseLink as the backing object-relational mapping (ORM) API.
Four JPA entities, which are classes that map to tables in databases, namely Pizza.java, Base.java, Topping.java, and PizzaOrder.java.
A Spring MVC web application to input and display data, interacting with the four JPA entities via the repositories.
Now that we’ve let Roo do its magic, let’s build the application, launch it, and kick the tires on your new application.
Believe it or not, you’re ready to run the application.
Roo configures a complete Maven-based build, even preconfiguring both the Tomcat and Jetty web servers for you to experiment with.
Let’s use the Jetty web server to launch the application:
Roo configures both Jetty and Tomcat web servers for your testing.
You can also deploy a Roo application on any application server that accepts a WAR deployment.
Just use the mvn package command to generate your WAR, which will be located in the target folder.
Executing the Maven package goal guarantees that you run against the latest changes to your application.
This looks like a typical CRUD-based application, but looks can be deceiving.
Let’s create a new topping by clicking on the Create New Topping menu item on the left-hand menu system.
You’ll see a prompt to enter the name because it’s a required field.
We’ve omitted the full-page view on these images to focus on the important elements.
All pages show a full menu, title bar‚ and footer.
Spring should have turned the input field yellow and marked it with a triangle warning, as depicted in figure 1.4
Each time you save a choice, you’ll see something like figure 1.5, a confirmation of the saved results as a separate page.
Clicking the edit icon (the page with the pencil) will take you to a page similar to the creation form, except that it’s working with an already persisted entity.
Finally, if you click the List all Toppings menu item, you’ll see a list of the toppings you’ve already entered, as shown in figure 1.6
As you see in figure 1.6, Roo provides paging support.
It also enables viewing, editing, and removing of entities using icons on each row, as well as creating a new one using the new page icon to the left of the list results paging control at the bottom.
The shell has the ability to watch your entities, detect relationships, and automatically update your web forms and controllers with widgets to pick from your related entities.
Start with bases and toppings; create your perfect pizza components.
Create some pizzas based on those bases and toppings, and finally, experiment with placing an order.
You’ll see the Roo client-side validations for invalid data, drop-down lists of related data, and if you take enough time to enter a lot of data, paging support.
And all of this within 49 lines of Roo script code—not a single user-defined line of code.
Whenever you see the line arrow icon don’t hit Return; just keep typing.
This is in contrast to the Unix OS line continuation character, \, which can be typed.
Note the data sent in JSON format to create a new pizza base named Thin Crust; it was JSON data.
Curl will respond with the result of the web service call, which is an HTTP 201 response code:
If you open the web application and review the listing of pizza bases, you’ll now see the Thin Crust base appear.
To fetch a list of pizza bases, you’d just issue a GET call to the pizzashop/bases URL:
Remove something and see how Roo asks for a confirmation.
You get these features for free, all by asking Roo to configure Spring MVC and scaffolding your entities.
These are all enabled by various Roo add-ons, some of which are installed with Roo itself.
Go to your command window and shut down Jetty by hitting [CTRL]-[C]
Not bad for just a few lines of Roo script code.
Let’s take a few minutes and review the script that created your application.
Let’s walk through some of the commands in this script and touch on what they do.
First, the script creates a Roo project, defining the Java package structure that Roo will use to store objects that it generates:
At this point in time, Roo just defines the project as a JAR file—nothing yet tells it that you need a web application configuration.
Roo is flexible and won’t configure more than it needs to.
The script then sets up the four JPA entity classes—Base, Topping, Pizza, and PizzaOrder.
The entity jpa and field commands comprise the content of most of this script.
Here’s an excerpt that installs three entities—Base, Topping, and Pizza—and begins to add fields to each of them.
We talk about those in chapter 3, as well as the field reference and field set commands, which establish relationships between entities:
These are the objects that talk to the database in the service-based Spring architecture we discussed earlier:
Roo can optionally expose JSON to the web tier if needed.
These commands provide JSON support for the web services we reviewed earlier:
This code literally installs Spring MVC, configures the website layout, builds controllers for each entity automatically, and places the controllers in the web subpackage of the root package:
With only a few lines of Roo commands, you've already generated a complete Spring MVC web application.
Now that you’ve created your application, kicked the tires, and explored the script, let’s dig deeper into the project’s application architecture.
When an application architecture is defined in layers, developers are able to switch each layer’s implementation.
It becomes straightforward to switch persistence strategies or user interface implementations.
Spring, being a component-driven development framework, fits well with layered architectures.
Developers are encouraged to build beans using interface-driven development techniques, defining business method signatures in the interface, and implementing them in a realizing bean.
Spring uses the interface as the contract to the client, so that the implementation can be swapped later.
Defining interfaces also helps developers test their components in isolation, using unit testing tools such as JUnit, which can use various APIs to mock or stub other beans.
It uses annotationdriven controllers, and can integrate with traditional Spring business services or with Active Record–based entities, as you’ll see later.
Spring MVC is an MVC platform, and as such contains all of the views as well.
These views are written in a variant of JavaServer Pages that is fully XML-compliant, and all JSP files are well formed.
These files are known as JSPX files, and are written and saved with the .jspx extension.
Roo also deploys several major Spring MVC features, which we discuss in chapter 5:
Layout support—Roo installs the Apache Tiles framework to lay out your web applications, and separates the web pages into a header, menu, content‚ and footer.
Theming—Spring themes provide a way to present the website in several ways.
Localization—Roo installs Spring MVC’s localization support so that you can support multiple languages, allowing you to translate elements of your website so that various native language speakers can use your application.
Roo uses a set of generated tag libraries to handle operations such as displaying result lists, providing smart form elements such as drop-down pick lists, date and time pickers, and rich text editing.
It can generate, or scaffold, web application controllers, views‚ and logic automatically to manage your data objects.
Roo can provide all of the traditional features of a typical web-based layered application.
Figure 1.8 shows a fairly typical component architecture for a Spring MVC–based project.
Views—Components that display information or provide ways to edit data.
Controllers —Accept incoming HTTP web requests and return responses, generally using views to present the data.
Web service layer—Some applications expose web services, using a convention such as SOAP or REST.
These are analogous to web controllers and views and exist in the same layer as those in this diagram.
Services—Provide an abstraction of business functionality, and are usually coarsegrained, performing a task that may interact with a number of objects in the repository layer.
Messaging integration code using APIs such as JMS may also be defined at this level.
Models/Entity classes—These components represent data that is transferred from the data access layer or service layer upward to the user interface components.
These may either be simple Java Beans—data transfer objects—or “live” objects such as JPA entities, which can be manipulated and then updated directly.
You can even roll your own Spring Beans to represent each of these component types, and wire them together using Spring’s @Autowired annotation, or even drop down to using XML or even JavaConfig to configure them.
It enables a more lightweight, rapid application development approach to Spring development that may provide for even more rapid productivity.
Roo was created to allow developers of Spring applications to become even more productive, and attempt to match the rapidity of development frameworks such as Ruby on Rails or Grails, while not leaving the Java platform.
Though developers can still introduce services and repositories, by default Roo takes the approach of slimming down the required components, as shown in figure 1.9
At first glance, this may seem like a loss of structure.
One of the reasons applications in enterprise Java take so long to deliver is the sheer number of artifacts required.
There’s a constant push-and-pull between “getting the application out the door” and “architecting it so someone else just might understand it later.” Many non-Java frameworks have been able to deliver applications more quickly, with considerable maintainability, because they implement a more domaincentric view of the world.
But consider that this pattern, the Active Record, has been used by frameworks such as Ruby on Rails and Grails with great success.
In Roo, you can define your persistence objects as Spring Roo entities, and Roo automatically wires up the code to properly validate and persist the entities for you.
You’ll see the advantages of this in the next three chapters, but for now, consider that you’re able to use this feature to reduce the amount of code you type.
Who needs to write boilerplate methods to load and persist data if a tool can do it for you?
Actually, the original Roo platform envisioned that Active Record would take over, just as it has for those Ruby on Rails and Grails application tools.
Also, in most applications, there are cross-domain problems to solvewhat if you want to expose a data manipulation command that spans toppings and bases? Do you place the methods in the Base or the Topping entity? In those cases, developers would at least build a service, and call both entity manipulations behind the service.
You may find less code overall for the Active Record pattern, and if you have a large number of model objects that you’re manipulating, the extra work of building repositories and services for each one may be a bit tedious, especially when you aren’t doing anything special in those objects.
But if you truly have cross-entity transactions and you have significant business logic, you may wish to roll out services, and if you don’t want to see your persistence logic held within your entities, you can ask Roo to create repositories.
Roo is flexible about application architecture, and, in fact, it can dynamically re-fit your project using the shell.
Often, you’ll be adding fields to your entities, or adding annotations, and the Roo shell will generate code and keep up with you.
We introduced Spring Roo, and using a built-in sample script, configured the Pizza Shop Spring-based web application in a handful of lines of configuration code.
We used the built-in pizzashop.roo demonstration script to build a simple application, complete with validation, persistence‚ and a Spring MVC web framework, using only a page of Roo commands.
By running the application, you saw just how much Spring Roo can help greatly simplify the configuration and setup process.
You saw how Roo even exposes JSON-based RESTful web services against the object you’ve created.
That can certainly come in handy when wiring your application to nonweb applications or rich browser clients.
You’ll find a link to forums, documentation, the JIRA bug tracking system, the GitHub repository, and a whole lot more.
And by now you’re probably itching to get started on your own Roo-based application.
Roo encourages experimentation, so let’s get started by firing up the shell and building a basic Roo application.
You saw in chapter 1 that Spring Roo, with only a few commands, can really make.
As we mentioned in chapter 1, Roo is controlled through a command-line shell.
Let’s use the shell to create a simple training task management application, and introduce some of the major topics we cover in the book along the way.
We do the same thing if you’re at the operating system prompt.
We use the $ symbol to show that we’re on an OS prompt line, rather than executing commands in the Roo shell.
The Roo shell supports code completion, a help command, and hints.
Try it now: hit your TAB key and see how Roo automatically prompts you with a list of commands you can type.1
To do this, type 'project' (without the quotes) and then hit TAB.
Your new project will then be created in the current working directory.
Note that Roo frequently allows the use of TAB, so press TAB regularly.
Before we go any further, we need to show you how to get a list of all commands in your Roo shell.
Make sure you’re on an empty Roo command prompt, and hit the [TAB] key.
You’ll see the valid commands for your project at this stage:
If the entity is backed with ActiveRecord, it will write calls to the CRUD methods on the entity.
Otherwise, it will detect the repository and call methods on the repository instead.
There are several other commands that perform housekeeping for you, including backup, monitoring‚ and scripting.
Roo will prompt you with a series of allowable options:
You want the --projectName option, so start typing the beginning of the option name, pro, and hit [TAB] again.
In the preceding output, the uppercased names represent file paths; SRC_MAIN_RESOURCES equates to src/main/resources.
If you’ve worked on any Maven-based projects in the past, you’ll recognize the path structures, and especially the Maven project object model file, pom.xml.
Table 2.1 outlines the key Maven folders, Roo Shell uppercase labels, and purpose for each one.
Generally, this source code starts in the package named in the project command’s --topLevelPackage argument.
If you want to be more specific, you can change a particular component’s logging level.
Use the tab key to see what options are available to you.
Let’s say you want to increase the logging for your project files (the nonframework ones) to the level of TRACE.
You could use the --level attribute of TRACE; then‚ using tab completion again, type --package.
Use the logging system to your advantage Spring errs on the side of detail when outputting log messages in trace or debug mode.
Although that’s a lot of potentially useful information, it can prove extremely difficult to dig through the noise to find the one thing you’re interested in.
Add as many of these to your log4j.properties file as needed while troubleshooting or debugging.
Roo requires the installation of a persistence configuration, for example, JPA or MongoDB.
For JPA, type 'jpa setup' and then hit TAB three times.
We suggest you type 'H' then TAB to complete "HIBERNATE"
If you press TAB again, you'll see there are no more options.
As such, you're ready to press ENTER to execute the command.
Once JPA is installed, type 'hint' and ENTER for the next suggestion.
According to the hint command, Roo requires that you configure your database.
Type in these commands, each time waiting until the configuration operations complete before continuing:
Believe it or not, you now have a complete working application.
Now, try it out by pointing your browser to http://localhost:8080/taskmanager.
See? You’re pretty RAD yourself, and in only five commands.
Figure 2.1 shows the listing page of your task manager.
Convinced about the productivity you can get with Spring Roo? Wait, there’s more...
Figure 2.1 The task manager application—five lines of Roo; awesome!
Before a major change, you may want to back up your application.
Although you could argue that version control is a much better plan (especially using Git or Mercurial, where the developer keeps a copy of the entire repository on their hard drive) that’s a pretty handy command for quick and dirty prototyping.
Now let’s see how Roo tracks changes it has made to your project.
If you were to look around in your file explorer, you might also find a file named log.roo.
This file is a log of all shell commands typed into the Roo shell.
At the start of each session, Roo date-stamps the time the shell is launched so that you can find out when a particular command was requested.
A snippet from the log file for the application you’re working with would look like this:
If you’re using Git A Roo add-on exists for managing your application in Git.
You’ll then get commands to manage your project from Git, including.
Once you install this add-on, it’s available for all Roo projects.
Working with the Roo shell help logging logging setup --level WARN logging setup --level TRACE --package PROJECT quit.
What if you wanted to run that script to create a new project with the same configuration? Just create another directory, copy the file into that directory (name it something other than log.roo, so it doesn’t get overwritten), and edit the file to taste.
You can execute the script command to create your application:
For assistance press TAB or type "hint" then hit ENTER.
You can imagine how easy it would be to define starter project frameworks with just a handful of Roo commands.
Remember, Roo stores those commands you’ve entered in log files, and you can distribute scripts to other developers to reproduce your application template from scratch.
Of course, those scripts won’t write any business logic, or style a web page, but they at least can get things started for you.
The two ways of invoking scripting are using the script command inside of the Roo shell, and from the operating system, invoking the script command on the command line.
From within the Roo shell, you call the script command, passing it the file to execute:
You can use this technique when doing rapid prototyping; perhaps somebody has created a set of domain object models, and you want to try using them from various front ends such as Spring MVC, JSF, or GWT.
The other way, as you saw in chapter 1, is to invoke the script as you load the Roo shell:
Now let’s take a look at some of the rules for developing Roo-based applications.
Now we’ll review the project structure for the taskmanager project, discussing the files generated by Roo.
But before we begin discussing specific project structure, we should cover some basic tenets of how you should manipulate files in the Roo system.
For Java classes, make sure they live within the top-level package defined when the project is created.
You can use any annotation, as long as you know what it does.
This can be quite handy and save you a lot of time when you are heads down in your IDE.
As we move through the book, we’ll note the artifacts you can modify or should leave alone.
Once you get the feel for what you can change, you’ll be able to move quickly and easily throughout your Roo-managed application without fear of breaking it with simple modifications.
The application you just created, taskmanager, is a fairly typical Spring Roo project, created using Roo’s default Active Record–based entities.
Want to build a traditional layered application instead? You’re actually almost there.
Just open up the Roo shell in the taskmanager project and type these two commands:
Roo automatically creates the service and repository beans, and their respective ITDs:
It also updated all generated entity test files to test the entity via the service and repository instances.
If you run the Maven command mvn test, it will execute the JUnit test, using the TaskDataOnDemand class to generate instances of valid tasks.
The web layer is where Roo configures your web application.
As you can see, Roo generates an organized Spring MVC web application, another task that takes a lot of time to do by hand.
We need to look at the key configuration files Roo uses to manage your application.
Any home page named index.jsp will be served from here by default as the home page of the application.
Spring Roo manages a number of APIs for you when it creates your applications.
They’re managed by mounting them as APIs and services from within the Spring Framework.
Knowing where these files live and what they do is key to the success of any Spring-based project, including one generated by Spring Roo.
Spring configuration files are generally stored in two locations in a Roo projectthe business-tier application context directory, META-INF/spring in src/main/ resources and the web-tier application context in WEB-INF/spring, located in the src/ main/webapp directory.
Spring Roo configured all of these files for you, without any work on your part, beyond stating preferences in the shell commands.
Better still, if a feature is upgraded, such as a newer version of Spring, a newer version of Roo may upgrade generated files, or change the version property in the Maven pom.xml file.
Roo responds by generating the Roo entity as shown next.
It contains two fields, description C, which is required and must not exceed 40 characters, and an optional Boolean completed C field.
You were able to quickly surmise this because all of the boilerplate code has been extracted elsewhere, and you’re only looking at the code that makes this class unique.
The files Roo created when you defined your entity mix behavior into the entity class at compile time, and are generated by the Roo shell in response to the annotations that Roo added to the class definition.
To see how these ITDs work, we’ll take a look at one from the Task class.
We’ve mentioned ITDs and other likely unfamiliar terms a lot so far.
You may push code into the target .java compilation unit if you wish.
ITDs are not Java classes per se; they’re defined by the keywords privileged aspect rather than class.
When the compiler sees a definition starting with the class name of a Java class, it weaves the code into that type; hence the name inter-type declaration.
The aspect type Task_Roo_JavaBean mixes code into the Java type Task.java.
In this way, the byte code for all of the methods, variables‚ and annotations defined in these ITDs are folded into the class file of your original Java object.
What do all of these ITDs do for your Task entity? Anything repetitive or boilerplate.
We all know the standard line of movie Mafia Dons when they want to get rid of a troublemaker: “Take care of my dirty work...” How much dirty work do you have to do on a daily basis? Chances are, to write and test the code that manages a Task object, quite a lot.
But you’re using Spring Roo; it generated all of that code behind the scenes so that you don't have to.
When you issued the entity command to build your Task, the Roo shell emitted the entity class.
You may even find more AspectJ ITD files than the preceding ones, as Roo evolves to add additional features to the entities you create.
Roo expects you to mostly ignore these generated files and focus on writing your business logic.
But if you open up the ITDs in a text editor, you’ll see it’s the dirty work you’re used to coding yourself.
Long getId() Long setId(Long id) Long getVersion() void setVersion(Long version)
As you saw, all of these files are created by the Roo shell, which takes direction from special annotations contained within the source file, Task.java.
At compile time, the Maven aspectj compiler plug-in weaves them into the actual Task class file.
Any Roo ITD can be mixed into the class definition so that it appears exactly as if you wrote that code in Task.java yourself.
The generated test class and ITD actually spins up the Spring container and runs integration tests against the entity, helping you identify problems with the database design and mapping process early in the project lifecycle.
You can execute the Roo-generated tests within an IDE or by executing the Maven command mvn test.
To create a multimodule project, you begin by defining the outer project using the --packaging tag, setting the value to POM:
Roo uses Maven’s pom project type as an aggregator; it allows you to add subprojects below but doesn’t actually create a new deliverable artifact.
For example, to create a JAR-based project to hold Spring beans, you’d issue a module command:
Note the special --topLevelPackage syntax to refer to the outer project’s packagethe ~ symbol used when referring to top-level packages when defining other Roo objects.
This symbol can be post-fixed with your module’s specific subpackage.
This allows you to define your services within your outer project, separated in their own jar: --topLevelPackage ~.infrastructure.
When you create a module, the roo> prompt will switch to that module, focusing to it, prefixing the module name before the word roo:
You can switch to another module using the module focus command.
For example, to switch to another module use the following:
You can also move to the top-level Maven project by focusing on ~ (available via tab completion, as for all module names):
Mind the currently focused module when working on Roo projects.
Working with modules adds an additional level of complexity to your project, so when beginning just focus on nonmodular web applications.
You’ll do much better adding modules later, when you can appreciate the component models you’re building and how they relate each other.
Now that you’ve configured your project files using the Roo shell, let’s look at how you can open these Roo projects in your favorite Java IDE.
It would be inconvenient if you had to flip back and forth between the command line and an IDE when building applications.
Let’s take a look at the support for Roo projects in both applications.
SpringSource has a version of the Eclipse IDE known as the SpringSource Tool Suite, which we’ll call STS.
Geared toward developing Spring-based applications, STS is chock full of features supporting the Spring Framework, such as.
Spring context editing support—STS provides automatic code fill-in features and namespace support for Spring context files.
Code completion—Not only does STS provide the fairly typical [CTRL]-SPACE code completion features from Eclipse, it does so when completing information in Spring XML context files.
Open one of these files in the editor and see the tabs along the bottom, which provide graphical editing features.
But this isn’t a sales call, so let’s discuss the features specific to Roo:
AspectJ ITD support— Part of STS’s support for AspectJ, it will let you show or hide the generated ITDs and provides navigational access to the code written in those ITDs when editing source code or debugging your application.
Refactoring support—STS supports refactoring of code written in Roo ITDs; you can push-in refactor methods out of ITDs and into Java code for customization purposes.
Loading your project into STS can be done with the Eclipse’s import function.
To import the project from within STS, select File > Import...
Then navigate to the directory where the project was created.
There are a number of features directly available to you in a Roo project, over and above the typical Spring application:
Figure 2.3 The right-click menu is enabled when a Roo project is imported into the STS workspace.
You can turn on this feature and then use [CTRL]-[SPACE] to use methods from these ITDs in your Java source code.
The Refactor menu (not shown) —A menu item in the Refactor ...
Let’s take a look in detail at the Roo shell support provided by STS.
The Roo shell is opened automatically when opening a Roo-based project in STS, as shown in figure 2.4
This provides you with a concise view of the objects that you work with day to day.
But to see the generated code, you need to bring up the Filters dialog.
From the Package Explorer, click on the drop-down triangle and select the Filters ...
Figure 2.5 The drop-down triangle menu, shown in the Project Explorer view.
Figure 2.7 The project pane with ITDs Java classes themselves.
I want my IDE! Figure 2.8 The Aspect Declarations menu in action; note the weaved data access ITD methods for this service.
Now take a look at another STS feature—the ability to navigate to the woven ITD methods right from the Java source editor.
If you see a special icon to the left of your editor pane, that means that the class has been woven with ITD methods.
You can right-click on that icon and select from several menu options, including the Aspect Declarations pane shown in figure 2.8
Each of these techniques is supported from the SpringSource Tool Suite.
IntelliJ also allows you to perform these operations, but we will focus on STS in this discussion.
Push-in refactoring is used to customize and replace the default behavior of Roo’s aspects.
The technique moves a method or attribute from a Roo project to the Java source file.
From there, the developer can modify the method code directly.
To perform push-in refactoring using the SpringSource Tool Suite, make sure STS is showing the Roo-generated ITDs (see section 2.3.4)
You’ll implement a new business requirement for your task manager.
Every time you mark a task complete, you’ll prepend the task text with (completed) so that it is obvious you’ve done your work.
Right-click on the updateTask(Task): void method, as shown in figure 2.10
You’ll then see the Push In Intertype Declaration dialog, as shown in figure 2.11
If, on the other hand, you clicked on the ITD itself and not a method or member variable, the entire ITD will be pushed in.
This dialog is a chance to review your pending changes.
Click OK to perform the operation, as shown in figure 2.12
Let’s run the application now, this time on tc Server within STS.
You can then right-click on the server and select Start.
Once the server is started, you can right-click on the application name in the server pane, and select Open Home Page.
If you execute your taskmanager web application again and complete a few tasks, you’ll see the completed message appear when you click on the checkbox and update your task.
Although Eclipse can be clunky at times, STS installs several plug-ins that make developing Roo applications a snap, including AspectJ refactoring techniques, the Spring MVC namespace editor, and Maven editing support.
But if you don’t use STS, you can just cut and paste the code from your AspectJ ITDs, and use your editor’s search/replace feature to remove the Classname.
Fire up the Roo shell and allow it to remove the methods from the ITD.
Roo can then remove the ITD completely if you remove the annotation that created it, such as @RooWebScaffold.
Once finished, the method will be extracted into the AspectJ ITD you selected.
As much fun as you might have with Spring Roo, there may come a time when you want to remove it from your project.
Perhaps you aren’t comfortable with supporting an AspectJ-based application platform, or you’re using Roo to prototype your project, but then will switch over to a traditional Spring application architecture.
Leaving Roo, because it’s a compile-time platform, is as simple as several steps:
As outlined in the Roo installation guide, you can leave the Roo annotations in the source code.
That way, if you decide to re-install Roo and continue coding, you don’t have to redefine the annotations.
Other configuration settings are no longer relevant either, such as the AspectJ Maven Plugin, and skipping the scan of AspectJ ITDs, because they’ll no longer exist in the project.
Remove what you wish, unless you think at some point you may want to resume using Roo on your project.
Resources 53 Now let’s review what you’ve learned about working with the Roo shell, aspects, and the Eclipse IDE.
You also worked with the SpringSource Tool Suite to import a project, and enabled the Roo shell.
You experimented with pushing in code from an ITD, and pulling code out to your own ITDs.
We also discussed how to leave Roo if the time comes.
Chapter 3, “Database persistence with entities,” discusses how Roo manages database applications using the JPA API and JPA Entities.
Chapter 4, “Relationships, JPA, and advanced persistence,” explains how to create and manage relationships, add a service layer, and call JPA API code directly.
Finally, chapter 5 explains how Roo helps you develop web-based applications, and how you can use those entities you learned about in the prior chapters.
For more internals on Roo from the founder of the Roo project, Dr.
Although out of date, this is a great read to see what they were thinking when they originally architected Roo.
In part 1, you learned how Roo aids in rapid Java application development.
Most real-world enterprise software applications use some type of database to store and retrieve business data to display on user interface screens.
No matter how cool your application architecture is, it often boils down to loading data from a database, editing it, and then saving it back again with changes from the user or external system.
The challenge is to get the data to flow between your objectdriven Java application server and the relationally mapped database server.
The persistence context—A storage area assigned to an individual session or thread, this is the workspace that keeps track of changes to relational data.
Spring provides a factory to configure the JPA API, whether or not the Spring application is running as a standalone application or within a Java EE application server like WebSphere or JBoss.
There are a number of books available on the subject of JPA 2.0
In this chapter, you’ll begin to configure your application, the Course Manager, which manages a set of courses for a fictitious training company.
If you’re following along, you can start by creating your own project with the project command, naming the project coursemanager.
You can type -- [TAB] to see what options are available, and when when an option such as database is selected, you can hit [TAB] to get the available options.
As we described in the quick-start in chapter 2, the jpa setup command performs a number of configuration steps.
Include the dependent JAR files in your Maven pom.xml configuration file for the selected JDBC driver, the JPA API, and a number of Hibernate JARs (and their dependencies)
Let’s look at the jpa setup command in a little more depth.
Using [TAB] completion, you’ll be prompted for the appropriate parameters.
The most useful options of course are --provider and --database.
Of particular note, when running Spring Roo on an application server such as WebSphere, WebLogic, or JBoss, you can take direct advantage of a JNDI data source; just put the proper data source name in the --jndiDataSource option.
If using JNDI, the data source to reference in your Java EE application server.
Rerun jpa setup to change your database configuration You can run the jpa setup command over and over again.
Each time it will replace the configuration entry and reconfigure JPA to support whatever settings you’d like to change.
This makes the ORM implementation changeable without affecting your code, and lets you mix and match combinations of the various persistence providers and JDBC drivers to find the best fit for your application.
Colons (:) may be escaped in the file with a preceding backslash (\)
To view, change‚ or set properties, either edit the file yourself, or use the Roo properties shell commands.
The properties shell command can manipulate any properties file, and takes a symbolic --path attribute for the various paths in a Roo application.
Explore it with tab completion to view various files in your application.
In the current example, this file passes along configuration parameters to your selected ORM API, Hibernate.
You can use this file to send configuration information to the ORM layer, controlling settings such as schema generation.
The settings available include create, create-drop, update, validate‚ and none.
Can speed startup against a known database but often developers choose validate to spot changes in the database that may cause problems against the defined schema.
The default setting, create, drops and re-creates tables on startup.
Change this value to update to allow restarting your application and preserving existing data, since Hibernate won’t delete the data from the tables for you automatically.
Note that this option won’t delete columns you remove from your mappings; it will only add or alter existing columns.
For example, when configuring EclipseLink, Roo defines this property to determine whether to drop or create tables:
Now you’re ready to start creating some entities and writing some code.
You’ll start by defining the courses for your Course Manager application.
The Course Manager application primarily focuses on delivering courses to students.
In this section, you’ll define the Course class as a persistent entity and configure it with the appropriate fields.
We’ll then discuss how to use and test the Course in a Roo application.
But here’s some good news! The Roo shell has a command for that, jpa entity.
You can open up the Roo shell and execute this:
Roo just created your Course entity, a suite of AspectJ ITDs to manage it, and a set of files for testing purposes.
This includes the integration test and a strangely named series of files labeled DataOnDemand—we'll get to those later.
For now, we'll focus on adding fields to the generated Course entity.
We'll cover the Roo annotations and what they mean shortly, but for now, you need to define the fields in order for this class to be useful to anybody.
Any modifications you make, such as adding additional fields, will take place with that entity by default.
You can set the focus on a particular entity by using the focus command, or use the --class option when creating a field element.
Even though you don't know how Roo does it, you probably figured out from the annotations that Roo provides several automatic services for this entity: something about JavaBean support, a toString() method, the JPA code, and an equals method.
We'll talk about all of those things in a little bit.
But for now, let's go ahead and add some fields to this entity.
With these five commands, you’ve just added five fields to the Course class: name, description, listPrice, maximumCapacity, and runDate.
Let’s take a bird’s-eye view of the Course.java entity Roo just updated.
Let’s walk through each of the key features of the Roo entity defined in the listing.
For each feature, we’ll show the code snippet that corresponds to the feature itself.
For example, the fields you’ve defined via your command are implemented as private member variables:
Roo built this file when it detected at least one private member variable in your class definition, which was annotated with @RooJavaBean.
The @Temporal annotation tells JPA that this is a date field.
Roo did this for you when you defined the field with field date.
Finally, the @DateTimeFormat annotation was generated based on the --dateFormat SHORT option, which will help Spring MVC and other user interfaces parse and format the date.
You’ll see later in the chapter how Roo can also generate true JPA repositories, in a more traditional tiered approach to application software development.
In that case, a different combination of ITDs are generated.
A common task in programming involves printing the string representation of data within a given object.
Let’s take a bird’s-eye view of the ITDs as they relate to the Course entity.
Figure 3.1 shows how the generated ITD files relate to the Course class.
All of these files are viewable, and with Roo’s support for push-in refactoring, you can migrate any generated method to the Course Java source file itself and override the implementation.
You can enter fragments of your class name to look up the entries (even using the capital letters only) to locate a class.
And you can use this shortcut (or CTRL/CMD clicking on a class name) to browse the open source frameworks (JPA, Bean Validation, Spring) the entity is based on.
Let’s add one more field: an enumerated data type, courseType.
You’ll support seminars, courses for college credit, and continuing education seminars:
You can just build your Java classes normally, even adding Roo annotations, and the Roo shell will keep up, manipulating ITDs as needed.
Now you’ll add the field to your entity, using that enum type.
Now let’s actually write some code to use our Course.
In fact, technically it is already built into the class itself.
Here’s a small fragment of generated test ITD code for one of the methods, testPersist():
We’ll get to how this all works in a moment.
Maven users —Issue an mvn test OS shell command from the root of the Roo project, or issue the Roo shell command, perform tests.
You’ll see a number of tests execute (and hopefully pass)
For now, you’ll use it to form a base for running your own integration tests, so that you can exercise your newly created Course entity.
Roo shell and the perform command Not only can you run your tests without leaving the shell with perform tests, but Roo provides some other very useful perform commands:
In this stage, being only a JAR file, the application will merely be a JAR of all classes and resources, but when deploying to the web, this command will create a WAR file.
You might be thinking that this is all smoke and mirrors.
You may also be concerned that the code isn’t optimally written.
To allay your fears, we’ll dig a bit deeper and review the JPA code that Roo generates.
But if you look inside Course.java you don’t see anything but your attributes.
As we mentioned before, this code is hidden within AspectJ ITD files.
This is a simple method that calls the persist() JPA method.
This means each instance of a Course can persist itself.
Although this method looks simple, the key benefit of Roo’s entity ITD code is that you’re not directly writing JPA code yourself.
If Spring Roo needs to modify the code for persisting the data in a future version, your calling code doesn’t have to change.
And although this is code you’d normally have to write yourself, why should you? It is purely mechanical.
This static method fetches a Course by the primary key value.
Roo works a little harder here; JPA stipulates that if the row isn’t found, it returns null, but Roo also returns null if the primary key passed in is null as well.
If you write static helper methods for your entities, you can just use the entityManager() method to fetch a valid entity manager to use for persistence.
Table 3.2 Some Spring Roo entity methods (example uses  as the entity)
Counts the number of rows in the table that backs the Course entity.
Returns a range of courses, starting with the row position (not primary key value) of firstResult, for maxResults rows.
Resets the persistence context and clears any cached entity rows.
Updates the data in the persistence context using data provided in the entity.
Marks an entity as ready to persist in the persistence context.
Issues a select count(o) from Course o query and returns the result.
Be careful not to use this method against tables with many rows.
Used to paginate results in Roo web applications by default.
Also useful in conditions where you want to cancel any potential changes that may have been made in the cache before it is flushed.
May throw validation exceptions if the data scheduled is persisted at the time of this call (see section 3.3)
Working with entities 73 The Roo product developers may add more methods in the future.
You’ll get them automatically when you upgrade to the newest version of Roo by running the new Roo shell against your existing project.
You should review all Roo ITDs and become familiar with their APIs, since you can use them directly in code that accesses these classes.
More advanced users can take advantage of Roo 1.2’s repository and service features.
Now let’s write some code against the entity API, using Roo’s support for JUnit testing.
For example, to get a list of all Course objects in a method, you’d simply have to write.
To load a Course by ID, modify the class capacity, and update it, you could do this:
To create a new Course, you only need to construct it, set the fields, and call persist():
To delete the Course you’ve built, you just call the remove() method:
Roo provides a useful API for the CRUDbased work you usually end up doing in most data-driven applications.
Let’s try adding a course and retrieving it from the database using your pregenerated JUnit test.
In the preceding sample, you create a new Course, set the fields to valid values, and persist it to the database.
You flush and clear your persistence context B‚which executes the SQL INSERT statement to persist the data to the database and clears the cached entity.
This detaches the Course instance, c, but at the same time fills in the primary key value in the id field.
Not too shabby for just a few lines of code.
Roo marks the test class as @Transactional (which you can find in the Test ITD), so that the unit tests automatically roll back any changes.
You can test this code again and again without worrying about adding duplicate data rows.
This is a Spring Framework test best practice, automatically implemented by Roo.
Now that you’ve seen some of the power of Roo for creating entities, and some of the code generated by the tool, let’s discuss how to add validation logic to your entity using the Bean Validation Framework.
You may ask yourself a bevy of questions, such as these:
How do I validate? Should I use a validation rules engine, scripted code, datadriven rules, or annotations?
How will my errors be returned? Should I localize the messages?
Created by the Java EE Expert Group, it was developed to address the lack of a standard validation API on the Java EE platform.
This API uses Java annotations to define specific rules, which are attached to attributes of a Java bean.
With the Roo shell already fired up, open up a source code editor and delete all of the field definitions in the Course entity.
Then add them back in, this time with Bean Validations:
Note: an empty or all-spaces string is still a value.
Note this is a numeric range‚ whereas sizeMin/sizeMax are text-based.
Values are defined by the enum and can only be set as Enum values.
And now the entity contains Bean Validation annotations, as shown next.
Each option in the Roo shell turns into a similar annotation in the Java source code.
If you forget to set them during creation, you can edit the source file and add them later.
First, you’ll build a simple test to prove that you’re running validations.
You’ll just create a test that defines a Course, and not set any field values, which should trigger the @NotNull validations:
If you’re following along, use STS and choose to automatically fix/optimize imports with CTRL-SHIFT-O.
When resolving the exception class, choose the one from the javax.validation package over the Hibernate one.
In the preceding test, the fact that the test threw this exception causes the test to pass.
For a more detailed look at the errors returned by Bean Validation, look at the more detailed test in the following listing.
In the example, you trigger the validation exception by passing nulls to the name and description fields B and attempting to persist the data.
You then test the annotation property of the descriptor, checking the annotation type name.
There are a number of validation annotations available in the javax.validation package.
The validations in table 3.5 are built into the Bean Validation API.
Define a lower and upper boundary for the range of a number.
Support datatypes such as BigDecimal, BigInteger, String, byte, short, int, long, and the wrapper types.
Defines the integer and fractional digits of a given fixed-point decimal or scalar number.
For Array, Map‚ and Collections, validates against number of elements.
So far we’ve looked at implementing validations, and we’ve seen how Spring Roo automatically executes validation checks before saving an entity.
Now let’s take a look at how you can create your own validator annotations.
Here’s the same validation logic, expressed with an @AssertTrue annotated method within the Course entity:
This is the easiest way to build multifield and one-off validations.
The method must have no arguments and return a Boolean value.
The method must have a standard JavaBeans name compatible with a Boolean getter.
Specifically, the method name must start with get or is, as in getValidity() or isValid()
The rest of the samples assume this has been done.
As you’ve just seen, if you need to validate your beans before persisting them, you can use the Bean Validation Framework.
Be sparing in your processing power—Just because you can call a stored procedure behind a service to validate an entry in that list, doesn’t mean that you should.
Realize that if you’re saving a collection of objects, this validation will be called on each item within the list, thus causing many calls to the same procedure.
Within this method you have access to other fields in the entity.
Now that you’ve seen how to define well-validated entities with the Bean Validation framework, let’s switch gears a bit and discuss how to enable users of your entities to locate entities that they’ve created, using the finder Roo shell command.
Searching for data in a database-centric application generally involves writing a lot of queries: fetching a list of items, pulling back a single item by a particular key, joining data together from various tables.
In pre-ORM days, people wrote a lot of SQL to do this task.
But JPA aims to simplify the query process by providing the JPA-QL  (JPA Query Language) API.
There are some key differences in the way regular SQL and JPA-QL operate:
Use the name of the entity in the query and the mapped table will be substituted at query time.
Now you can write your own JPA-QL queries and place them in methods on an entity or service bean object.
Let’s look at how easy it is to have Roo write them for you.
Let’s take a look at an example that implements the search we just discussed, one that searches the name field in your Course object.
First you’ll ask Roo for a list of finders that you can generate:
This is simply a mechanical list of all finders Roo can generate for you, filtering on the fields that contain the search term name.
Let’s take a look at the code that the Roo finder add method set up.
Most of that test method involved test setup, but in the end it resulted in a one-line call to your pregenerated finder.
The finder command includes the --depth option, which lets you ask for combinations of finders for several fields at the same time.
Keep in mind that the output begins to get a bit voluminous after a depth of two, or with entities that have a large number of attributes.
You can use the --filter method to list the attributes you wish to see, separated by commas, to limit the output.
Let’s see the finders Roo can generate for a combination of both the courseType and runDate fields:
You can even tie three or four fields together, if you know the pattern.
In this way, you can save yourself from having to write boilerplate JPA query code.
Since finders are added to the entity along with the persistence code and validation rules, they help you to contain your complex data query logic within the entities themselves.
Roo repositories are built using the relatively new Spring Data API.
Spring Data provides support for dynamically generated proxy classes for a given entity, and those classes handle all of the methods you’re used to coding by hand (or using in the Active Record entities)
There are no methods defined in this interface; it exists merely as a holding place for the @RooJpaRepository annotation.
These are all methods to search, save, and remove data from the entity.
Note that the <T> designation is a Java generic type.
So now you can use a Roo repository to implement your JPA code.
The methods saveAndFlush() and getOne(Long) are provided dynamically at runtime via the Spring Data API.
This interface provides access to the Spring Data features for providing criteria-based query and paging support.
The methods accept a Specification class, which is used to define the search criteria to pass to the repository to find, sort, and page through a list of entities, or fetch a single entity.
For example, to provide a predicate that expects a non-null run date:
The toPredicate() method takes a Root<Course>, which provides access to the types in the JPA entity, a JPA CriteriaQuery, which is built by Spring and passed into the method automatically at runtime to be executed, and a CriteriaBuilder, which allows you to add predicates to the query using English language–like calls‚ such as cb.isNotNull above.
One of the most powerful features of the Spring Data JPA API is providing annotationdriven queries.
Since Spring Data builds the implementation class at runtime, you can define methods in your interface that Roo can use to implement custom queries and even updates.
You can define a query method in your CourseRepository interface to find all student registrations for a given student and date range (we define the Registration entity in chapter 4, but this code shows you more complex queries):
Roo implements the code for this method at runtime, based on the Spring Data @Query annotation.
Note that you’ve also passed the @Transactional annotation, and marked the query as a read-only transaction.
In this example, you’ve marked your interface method with @Modifying to signify that you’re expecting a data manipulation statement, not just a simple SELECT statement.
You also define your method with @Transactional, so that it’s wrapped with a read/ write transaction.
This file contains the Spring Data XML configuration element, <repositories/>, which scans for and mounts interface-driven repositories:
The package defined in this Spring XML configuration element is your root project package.
You can now add repositories in whatever subpackage makes sense.
Summary 91 don’t have to use Roo to generate your Spring Data classes either, so if you’re already a Spring Data or JPA expert, just code away!
For more about the Spring Data JPA API, visit the project website at http:// mng.bz/63xp.
As an added bonus, you can skip the Active Record generation for Roo entities by issuing the --activeRecord false attribute when defining an entity:
Fire up the Roo shell and watch it remove all of those Active Record ITDs.
Follow up by creating a JPA repository and you’re all set.
If you take advantage of Roo’s web interface scaffolding, Roo will even reroute calls in the controller to the repository after you create one.
In the next chapter, we’ll show you how to use Roo’s service support to automatically provide a wrapper service around your repositories.
All of these examples work against the Hypersonic SQL database by default, but feel free to re-execute the jpa setup command and switch to your favorite database.
Now let’s review the topics we covered in this chapter.
Just think of all the things Roo does for you as a Spring developer:
Roo supports adding finders to your entities, which provide results for various searches enabled as simple Java methods.
In the next chapter, we’ll take a look at how to relate entities to each other.
You’ll also see some of the more advanced features of the JPA persistence framework and how you can make them work in Roo.
The online reference for the Spring Data JPA project: http://mng.bz/Q9X4 The Spring Data JPA project home page, which includes references to blog entries by Oliver.
In chapter 3, we discussed how to install Roo’s JPA-based persistence engine, create entities, and manipulate them using Roo’s domain-driven entity ITD methods such as persist(), find(), and merge()
You saw how to validate entities using the Bean Validation API and how to generate search queries using the finder facility.
You also saw how to build Spring-based repositories so that developers who want a separation of application layers can still provide a data layer for their applications.
Let’s begin by reviewing how JPA manages relationships between database entities.
Let’s use the Roo shell commands to create and relate other entities to your Course.
You’ll use several relationship types and let the Roo shell configure the JPA annotations for you.
One-to-many Relates a row in a parent table to zero or more rows in a child table.
The relationship can either be defined as bidirectional or unidirectional.
Many-to-many Rows from each table are related to rows in another table.
For example, tracking the authors for a series of books, where books can be authored by more than one author, and an author can write any number of books.
Many-to-one A reference from a child entity back to its parent.
We don’t have enough space to teach all of the JPA in this chapter, but we focus on some of the major relationship types that you’ll use on a regular basis.
We refer you to a number of books at the end of this chapter to help you continue your JPA learning journey.
Let’s dive right in and create some entities and relationships.
You’ll start by adding a TrainingProgram entity so that you can group courses together.
Your Course Management application is comprised of a number of JPA entities, related together via a combination of relationship types, such as one-to-many, manyto-one, and many-to-many.
You’ll use this model to put Roo’s entity command through its paces.
Next let’s create the relationship between TrainingProgram and the Course entity.
You’ll make a bidirectional, one-to-many relationship, meaning that you can navigate from training programs to courses, and from courses to their training program.
First you establish the one-to-many side of the relationship, using the field set command.
This command creates a Course-typed Java set in the TrainingProgram entity:
The @OneToMany annotation tells JPA that a relationship is established between Course and TrainingProgram, so that when queries are issued, JPA can write the proper SQL statements.
You’ve used the mappedBy attribute, which describes the name of the attribute in the Course object that represents the related TrainingProgram.
This is done so that JPA manages the relationship at the many end, which you’ll configure next.
In order to complete this relationship, you need to define the reverse side: the many-to-one relationship between the Course and the TrainingProgram, which you’ll do by defining a trainingProgram attribute using Roo’s field reference command:
Figure 4.2 How Java sees your relationship—using a reference and a set.
But, in the database, you relate these objects using primary and foreign keys, as in figure 4.3
REMEMBER: STAY FOCUSED! If you restart Roo, or want to switch to adding fields to another entity, you can use the focus Roo shell command to switch the entity you’re working on.
Forgetting to switch back to the Course entity when adding the reference to TrainingProgram will add the reference to the TrainingProgram entity.
You won’t receive a warning because Roo doesn’t know you made a modeling mistake!
Alternatively, use the --class parameter to apply the field or reference to another entity and ignore the currently focused class.
In this test you assert that you can store and retrieve a one-to-many relationship between a training program and a related course.
Next you create an instance of your TrainingProgram C, and set the reference to your Course instance.
You still need to add the course to the collection, so ask the TrainingProgram for the set of Course instances with getCourses() and add your Course to the collection D.
Now, both sides of the relationship are satisfied, from both Java and JPA perspectives.
Calling flush() will force JPA to execute your SQL statements, and clear() will reset the context, so any future requests will have to come from the database and not the JPA session cache.
Finally you attempt to reload the training program from scratch and verify that the name that you loaded matches the name that you created, and that you have one course attached to the training program F.
Databases relate these same entities using a primary and foreign key.
The log setting above causes the actual DDL to be emitted in the STS console, and.
Here’s sample output from a configuration using the MySQL database, which includes both primary and foreign key definitions:
As you can see, you can focus on configuring and manipulating Java objects, and let the persistence layer figure out how to generate the appropriate SQL statements, both to create and manipulate your database tables.
Here are some tips when dealing with Roo’s relationship mapping commands:
Though Roo generates some baseline sanity tests against your entities, always exercise your entities and relationships before you start coding services and.
This is an alternate form of mapping for a one-to-many relationship that allows for switching later to a many-to-many relationship without major restructuring of your data.
So, when defining one-to-many relationships, be sure to use the --mappedBy option unless you expect this behavior.
For more information about the details of JPA 2.0 mappings, consult the books we refer to at the end of this chapter.
Now you’ve seen how to define a basic, bidirectional one-to-many relationship in Roo.
Let’s explore some other mapping options, starting with a many-to-many relationship.
You have two options for how to define your relationship in JPA:
You can define an intersecting entity that associates Tag entities to Course entities using two @OneToMany relationships.
Although the three-entity solution allows you to define attributes in the intersecting entity, you’ll use the simpler many-to-many relationship instead.
Regardless of how you map the entities, the relational database will require three tables, as shown in figure 4.4
Let’s create this relationship as a bidirectional, many-to-many relationship, so you can easily fetch the courses for a given tag, or the tags assigned to a particular course.
Roo responds by creating the Tag entity and adding the fields, as shown in the following listing.
Next you need to relate the Tag to your Course entity.
Assume your Roo shell focus is still on the Tag entity:
Just use the --class argument to specify the target entity.
The preceding command defines a Java Set collection, named courses, on the Tag entity:
To test your association, let’s add a method to the TagIntegrationTest JUnit test, shown in the next listing, that creates several courses and assigns a tag.
The test is remarkably similar to the preceding tests, except that you use a little more of your DataOnDemand testing framework.
First you create your CourseDataOnDemand object B, which allows you to get access to a number of Course entities, prefilled with legal data values.
The getRandomCourse() method you saw earlier may return the same Course twice, so you can’t use it here.
You also generate a single random Tag object, which is the focus of your test.
You then add the course to both tags using your convenience method, Tag.addCourse() D.
Finally, you save the tag instance, which cascades into saving the courses.
To test, you flush and clear the entity manager and then reload the Tag from the database, verifying that it is attached to two courses.
Both the test and the CourseDataOnDemand class have backing AspectJ files.
All of this is great, but what about the reverse relationship? What if your users need to fetch the tags assigned to a given course? In that case, you need to define the collection in Course that will contain the associated tags.
To define your Course to Tag mapping, you’ll create another @ManyToMany relationship.
But this time you’ll add the --mappedBy option so that you can define this as the inverse relationship.
An inverse relationship provides a way to navigate between entities, but doesn’t automatically persist changes by itself:
The inverse relationship, defined on the Course entity, looks like this:
As you can see, the mappedBy attribute defines the name of the set within the Tag entity and establishes that Course is not in charge of persisting the Tags.
In a bidirectional many-to-many relationship, one side must be the primary, and the other side must be the inverse side.
The inverse side is indicated here as Course, because it defines the mappedBy attribute.
Now that the relationship is bidirectional, you need to modify both sides to make Java and JPA happy.
You’ll notice that you add the tags to the tags collection on course B, and also ask each tag for its courses collection, adding the course to that collection as well  C.
As before, you then flush and clear the persistence context via the course, and try to load the course again to verify that it contains a reference to two tags.
It turns out that this code wouldn’t work if you only updated the tags collection in course.
Try it out by commenting out the two lines that add the course to the tags.
The assertion would fail, because the Course entity isn’t the active side of the relationship.
You need to know which side is active; updating the inverse side may not actually trigger JPA persistence, but updating the active end will always do so.
For most bidirectional one-to-many relationships, the appropriate active end is the many side, as the foreign key lives in the child.
For many-to-many relationships, the choice is arbitrary and something you need to decide on a case-by-case basis.
Next you’ll deal with registering students for your courses, which will help you learn about inheritance hierarchies and JPA.
To implement entity inheritance in your model, you’ll define an abstract Person entity, with typical fields such as firstName and lastName, and then define separate entities for Instructors and Students, which will extend the Person entity.
While you could use the Roo shell to define your fields, in this example you’ll just enter the field definitions in the editor.
This technique is used during rapid prototyping and enables developers to make changes to a data design quickly.
When defining a complex data model, generate your integration tests and prototype a user interface using the scaffolding to see what Roo can support out of the box.
You have several additional entities to create—students, instructors, and course registrations.
Let’s start this process by defining the people who are taking and teaching courses.
All of the relationships we’ve discussed so far are either “has-a” (one-to-many, many-to-many) or “belongs-to” (many-to-one) relationships.
These are exposed in Roo using the familiar entity and field commands.
You have two types of people that you track in your system—students and instructors.
Both have some common elements, so you can define an inheritance hierarchy to collect the common elements in a parent entity.
You’ll define this hierarchy using three entities, as shown in figure 4.5
You’ll use Person to hold common elements: address information and a name, for example.
For Students, you need to track dietary preferences and emergency contact information.
You’ll also need to track your Instructors’ tax ids, and whether they are still active trainers within your organization.
You’ll define these attributes in the Student and Instructor entities, which you’ll inherit from Person.
From the Java side, this is a straightforward inheritance design.
Student and Instructor entities can simply extend the Person entity.
But JPA needs additional information to map this hierarchy to a database.
Table 4.2 outlines the mapping options, which you can specify with the Roo entity attribute, --inheritanceType.
One important issue with Roo and the hierarchical relationships is that it doesn’t completely support all settings in the entity shell command.
For example, Roo doesn’t have a command to let you configure the discriminator for the SINGLE_TABLE model, so you’ll just have to edit the classes and add the proper annotations yourself.
SINGLE_TABLE Puts all data from the parent and child classes into a single table.
Each row is identified with a discriminator that defines which entity to create when fetching the row from the database.
Note that each field must be nullable in the child classes, so that the SQL statement can insert the row without those columns.
TABLE_PER_CLASS Also known as “Table per concrete class,” this strategy only creates the tables of the child classes in the relationship.
All parent entity data is defined in each physical child table.
Fields can be nullable or required in the child tables.
The JPA provider will create the parent and child tables for the relationship, and use SQL joins to fetch the data for a given entity.
This command is slightly different than the ones before it.
You make the person abstract because you don’t want anyone to create a generic one.
You’ll fill it in with the appropriate field definitions in the IDE:
If your Roo shell is running it will immediately update the ITDs.
Nothing different again, except the fact that it extends Person.
If you want to run all tests for the project at once, either use the Roo perform tests command or Maven’s mvn test command.
If you’d like to write more complex tests, ones that use the Student with other entities, feel free to do so.
Roo uses JPA annotations to define the primary key of each entity, holding them in.
On database engines that use an IDENTITY data type, such as MySQL, you can’t use the AUTO key generation strategy.
When using Hibernate as the persistence engine, your integration tests will fail when running on these databases, due to a database mapping failure on startup (see http://mng.bz/PpLH for details)
You can use another generation strategy, such as TABLE or SEQUENCE (with databases that support it)
The additional code you’ll add to your Java entity class when selecting the TABLE strategy looks like this:
The TABLE strategy defines a table that keeps track of the next highest value for a given entity’s primary key.
The SEQUENCE strategy uses a high performance internal number sequence, which the database will increment automatically when creating the primary key.
On databases that support sequences, you’ll get far higher performance by selecting the SEQUENCE strategy.
Let’s take a look at the database tables that Roo generated for the Student and Instructor entities.
You configured your database for MySQL using the persistence setup command and then used the mysql client tool to describe your tables.
You should always take a good look at your database table mappings and learn to use your JPA provider effectively.
Since you don’t specify the @Column annotation for your fields, EclipseLink’s defaults kick in, which are different than Hibernate’s defaults.
Again, you see the tax_number and active fields from the Instructor entity and the common fields from the Person entity.
Whenever a student registers for a course, you enter a row in the registration table via the Registration entity:
This schema gives you a good combination of data to experiment with.
In chapter 5, you’ll learn to use Roo’s user interface features to build a web-based frontend to this database.
What if you’re given a separate database schema, and you need to reverse engineer it into your current entity model? Roo has this covered using the database reverse engineering add-on.
Using the database reverse engineer Roo shell command, you can scan an existing database and have Roo generate entities automatically.
As your database evolves, Roo can keep the database and your entity model in sync.
Suppose you have to interface into a payments system via two SQL tables, invoice and payment.
If these tables exist in your current schema, you can have Roo generate entities for them automatically using the database reverse engineer command:
The preceding command takes several parameters, as shown in table 4.3
By default, all tables are included, except those listed by the --excludeTables option.
This option can list multiple tables, separated by spaces, in quotes.
You’ll need to install a piece of software known as an add-on, which will provide the JDBC driver for your database.
The Roo shell uses this JDBC driver to perform the database reverse engineering process.
For example, when you run this command against a project that points to a MySQL database, you get this (cleaned up for print) message:
Roo is telling you that the Roo add-on #01 is actually a JDBC Driver for MySQL.
You can install this add-on into the Roo shell so that it can communicate with MySQL.
If you’re successful, Roo will generate JPA entities automatically, as well as define a set of tests.
You can now run your suite of tests again, using the Maven mvn test command.
If Roo can properly test the entities, you can then write further tests to assert whether your mappings are properly defined.
Reverse engineering tips The Roo reverse engineering features heavily rely on the quality of the database schema.
If your schema has nontraditional database keys, mappings, or data types, expect that you might run into trouble.
So far, we’ve looked at how to create your own entities and database elements, and how to relate them to each other using one-to-many, many-to-one, many-to-many, and inheritance mapping strategies.
You also saw how to reverse engineer them from an existing schema.
Roo makes coding applications using this persistence model rather easy—just create or look up entities using their ITD findbyId, merge, persist, and remove methods, or define a finder.
You can define services in your application in two ways:
Using the service create command, which fronts one or more entities and/ or their repositories with a Spring service bean automatically.
Both approaches give you a traditional Spring bean for wiring to components such as controllers and web service interfaces.
Your services can either directly interact with your Active Record models or use a repository.
Roo will automatically detect the correct approach and write the service code appropriately.
Defining a service to expose the Course entity is quite simple:
If you want to write your own service methods, Roo has already provided the interface and a stub implementation class, so you can place your signature in CourseService and the implementation code in CourseServiceImpl.
Your service methods will just come along for the ride.
Again, Roo saves you a lot of time and coding effort.
Although you could do these operations by hand using @Service, with the Spring Data–based repository APIs and the handy Service builder command, you can put your data and service layers together in a jiffy.
You can also access the entity manager and make calls yourself.
There are two basic approaches you can use to gain access to the entity manager:
That’s great if you’re in the middle of coding against the Roo APIs in your own service, and just need to make a single call to JPA that isn’t provided by the ITD.
Create an interface to define the repository with the finder method signature.
Implement the interface and move the finder implementation method into it.
The finder method is largely the same as it would be in the finder itself.
The difference is that you’re starting to use some of the more familiar Spring Framework conventions.
You mark the method as @Transactional, in case the method is called by any external services.
A word of warning, though: Roo may not support the automatic generation of webbased applications based on handwritten services and repositories.
The scaffolding feature in chapter 5 will only work against the Roo-generated ITDs.
Finally, we should point out that you can even use Roo with JDBC.
Just configure your Spring application with the appropriate JDBC driver and data source, and then start using the Spring JdbcTemplate API, or MyBatis (a common SQL-mapping API), or even a non-SQL database platform.
You may not get all of the baked-in features of Roo, such as automatic website generation, but perhaps future add-ons will support these APIs.
Normalization kills query performance —Because relational data is normalized, or factored in to the least duplicated form, it can become hard to query across a number of entities.
Consider the performance issues with querying an overly normalized database that leads to a crazy 10 table joins.
Each column must be defined with a specific type, and the database engine optimizes indexing and performance around this structure.
Difficulty querying large volumes of data quickly —Although some database vendors have rolled out text searching capabilities, and other developers are using tools such as Lucene to index their data, databases themselves can’t quickly search through large volumes of loosely structured text without scanning vast amounts of data.
This makes them less than ideal for searching through content stored in XML or JSON format.
For these and other reasons, the NoSQL movement was born.
A number of types of NoSQL databases have been developed, but they generally fall into several types, as outlined in table 4.4
Facebook created Cassandra, a column store NoSQL database, and open sourced an implementation.
We won’t get into the religious debates about which NoSQL variant or engine to choose in this book.
But as Roo supports at least one (at the time of publication) NoSQL database, we will show you how to use it as a database store.
Like other servers, you’ll install the database engine and client by downloading it and configuring it as a standalone service.
Our tutorial assumes that you’ve configured a working MongoDB database and that your mongod daemon process is running when you work with MongoDB and Roo.
To build your course with Mongo support, you’d first set up your MongoDB database layer:
This configures support for MongoDB, assuming that the engine is running on the same machine, on the default port.
You can use parameters to adjust your MongoDB settings, or edit them later in database .properties.
You’ll start by defining the entity with the new entity mongo shell command:
Comparing this entity with the others, the major difference is the @RooMongoEntity annotation.
Beyond this, you can treat it the same way as your other entities.
Let’s add some fields and a relationship to a simplified Offer object.
Next, you’ll define your Offering POJO, for embedding within your Course:
Note, this is just a simple Java POJO which you’ll embed into your database.
To enable access to your Roo MongoDB entity, you need to build a repository.
Creating a service is the same procedure, whether you are using a JPA or MongoDB repository.
If you aimed your tests against the service, your methods would look similar to the SQL-based service wrapper methods.
Here’s the same test, but focused on a service instead:
The major differences between NoSQL and regular database services are.
Relationships will behave differently and may need special supporting code.
The example above just nests an Offering POJO within each Course, and doesn’t attempt to create a true two-way relationship similar to JPA.
We also discussed the support in Roo 1.2 for MongoDB, via the new Spring Data API.
Spring Data will prove to be a huge asset to Spring Roo projects, as you saw in this chapter, and also enhance standard JPA, as you saw in the previous chapter.
Coming up in chapter 5, we’ll begin to discuss web-based application development using Spring Roo.
You’ll configure your project as a web-based application, and learn how to leverage Roo to generate and manage your web user interfaces.
Pay close attention to the various GIT repositories that contain examples for the various features of the API.
With the back-end data persistence out of the way, we’ll switch gears in part 3 to focus on the user interface layer of your application.
Application security is a critical part of any software application.
This is the focus of chapter 8, “Configuring security,” where you’ll learn how to implement security aspects such as authentication, access control, and restricting the URLs in an application.
We’ll also look at how to enable security event logging so you can log all security events that occur when your application is running.
If you’re like us and have written a lot of web application code, you probably expect to spend a significant amount of time to configure a web application.
Because you want to get started, you may just want to dive right in, install Spring MVC by hand‚ and write some code against these entities.
Stop! Don’t touch that keyboard yet! We’ll show you how to save even more time by letting Roo configure and generate your web application for you.
In this chapter we use a simple Roo shell command, web mvc controller, to install Spring’s MVC web framework, and generate a sample controller and view.
Then we use web mvc scaffold to generate full web pages complete with create, read, update, delete‚ and searching capability.
The key components used by Spring MVC are as follows:
Model—Generally, controllers execute calls to other Spring beans, and then gather results that need to be rendered to the end user.
These results are loaded into a model object, a simple map-based class that can be injected into a Spring MVC controller method.
The dispatcher servlet then passes along this model for rendering by the correct view.
View—A view is the output of a Spring MVC operation, a representation of the results of a given request.
Views can access any object provided in the model, and can be written using a number of rendering technologies, such as JSP, Velocity, FreeMarker, or even using PDF or Excel.
Spring Roo is configured to use XML-compliant JSPs, which are commonly referred to as JSPX views.
Roo’s JSPX views are configured to use Apache Tiles, which is a layout engine that separates boilerplate code such as headers, footers‚ and other panels from the code specific to the view being rendered.
In the next chapter we look at other web frameworks supported by Roo, including Google Web Toolkit and JSF.
It takes a significant amount of time and expertise to completely configure a webbased Spring application by hand.
But as you’ve seen, Roo helps you by handling your dirty work, and for a web project architect there’s plenty of that to go around.
Roo takes care of configuring Spring MVC for you so you can focus on coding your web applications.
Let’s dive in and convert your project to a web application.
Remember the pizza shop example from chapter 1? The MVC setup was only two lines of Roo commands.
In this section, you’ll see how to direct Roo to generate and configure an entire web application structure, even the Tomcat and Jetty web servers, in just one command.
We’ll review components that Roo creates, such as the controller and view, and explain how to pass model information to the view for rendering.
When Roo built your Course Manager application, it just configured it as a jar project.
To get Roo to change the project type to a web application and output a war artifact, you need to execute the Spring MVC setup command:
This directory can contain raw HTML, JavaScript, CSS files, and other static resources.
Table 5.1 shows key subdirectories of this root directory and their purpose.
The overall Tiles page layouts are defined in this directory.
WEB-INF/tags Spring Roo custom JSPX tag libraries, used by views to render pages, forms, fields, and other elements.
WEB-INF/views Contains the view files, which are comprised of JSPX pages and Apache Tiles view composition files.
Ultimately you just want Roo to create a controller for you, so to do this you issue the web mvc controller command:
This controller uses the @RequestMapping annotation, which tells Spring MVC to map any requests with the given pattern to methods within this controller.
The classlevel mapping, /testdrive/**, makes sure anything with a URL that begins with /testdrive is handled by this controller.
Each method then provides its own request mapping, defining a unique URL subpattern, based on portions of the path, request attributes, request types (POST, GET), and other options.
Controllers wouldn’t be useful without a way to display the data that they place in their models.
Let’s take a look at the next component of your web application, the view.
If the method returns a String (as in the index() method above) it will be treated as a view name, and Spring MVC will attempt to resolve it based on the Roo-configured path for all views, /WEB-INF/views.
As you saw earlier, index and post are all annotated with @RequestMapping, and although the post method currently does nothing, it can respond to POST requests to /testdrive.
The index method responds to /testdrive/id, where id is a number.
You’ll see why this is important when we discuss Roo scaffolding in section 5.3
One of the more complex parts of Spring Roo is the way it configures and manages MVC views.
These files must be XML-parseable, so that the Roo shell can manipulate them.
As you’ll see later, Roo can generate and maintain forms and form fields in your views automatically.
The view for your controller’s index() method is index.jspx, shown next.
The page:page tag wraps the page content in a bordered box, complete with a title bar.1 The content is a simple message.
This is actually a Dojo rich JavaScript component, as are the fields that provide client-side validation and dropdown date fields.
You can use Dojo to build your own view with your own hand-selected components.
For now, keep in mind that Roo uses rich web interface components like this to give your web application a dynamic look and feel.
You may change your application’s friendly name by editing that file.
The welcome_titlepane message is located in another file in that directory—messages .properties:
Choose between Tomcat and Jetty by issuing tomcat:run or jetty:run.
Browse to http://localhost:8080/coursemanager to view your web application’s default page.
If you’re a SpringSource Tool Suite user, you can drag the project to a configured server in the Servers pane and install it in Tomcat or SpringSource tc Server automatically.
If you leave your web server running, STS will automatically redeploy the application when it recompiles the project.
In fact, some developers really dig Jetty because it’s so easily customizable, and it’s quite polite: it even tells you your web application name if you hit the root of the server by mistake! To kick off your application with Jetty, just use.
You can customize what port the Tomcat web server runs on by modifying the plug-in settings within the pom.xml file.
For example, replace the existing plug-in definition with something like this:
Review other options for the Tomcat plug-in by visiting the plug-in’s website at http:// mng.bz/IgJ5
Now every time you perform an mvn package command, Jetty will automatically reload.
It expects you to actually code something in that index() method before it returns the view name.
What if you wanted to render the current time? You’d have to place the current date and time in the Model, so that you can render it in the view.
To do this, you just add a parameter to the index method, Model map, and then use the addAttribute method of the model to inject the currentDate attribute to the view.
Let’s change the index() method in the TestController class to something like this:
Figure 5.3 shows the newly customized example, complete with dynamic evaluation from the controller.
How does Spring MVC resolve the right view? When the method returns testdrive/index, Spring MVC delegates to the Tiles view resolving mechanism, passing it a template named testdrive/index.
Ken remembers someone once lamenting about the trials and tribulations of web application development.
They wanted to do all of this really cool stuff, integrating with other systems, doing complex graphical work, and meaty programming.
What do we always do, day in and day out? Suck data out of a database, show it to the user, and let them change it.
In this section we’ll delve into the world of scaffolded Roo controllers.
You’ll see how to generate a scaffolded course controller, and we’ll review each of the generated controller methods and views for the list, create, update, and delete operations.
We’ll also look at how Roo integrates finders into these controllers.
The options, --class and --entity, specify the name of the new controller and the entity to use, respectively.
Assuming you’ve already set up the MVC framework with the first web mvc controller command, the output will look like this:
Of course, this time Spring Roo generates a few key files, including.
These view files are generated and configured using the Roo JSPX tag libraries, which are installed in WEB-INF/tags.
All fields available in the entity are generated as fields in these various view files.
This controller class manages all operations against the Course entity.
The code to implement the controller actions is stored within the AspectJ ITD.
Roo generates and maintains the JSPX pages based on the @RooWebScaffold annotation.
The gray area in all of this is the view technology.
Since Roo generated the views as user-editable elements, any changes made by a developer must generally be honored.
In fact, if you change your templates around, modify the HTML code, or otherwise modify the boilerplate code, Roo will allow this to happen.
Now, let’s take a look at the various views and controllers generated by your web mvc scaffold operation.
We’ll review the files based on the operations they provide.
The GET operations your scaffolded controller supports are both a list of all of the Course objects and the display of a single Course.
Both operations are supported by different generated controller methods and views.
We’ll look at both in turn, starting with the listing operation.
If you’re familiar with Spring MVC and the form taglib, you’ll be pleasantly surprised by the use of tag libraries, which shorten the amount of code in the next listing.
For more information about REST, start with the excellent Wikipedia article at http://mng.bz/1PMN.
The first thing you might notice is that you’re not defining a full JSP page.
In fact, the file looks a lot more like an XML document than an HTML page.
That’s because the combination of using Apache Tiles to render page fragments and the heavy use of JSP tag libraries reduces the view to a tighter, more compact version of the usual view.
That is, except things like those strangely long id and z fields.
The resulting output of the course listing view should be similar in appearance to figure 5.4
As you can see, the results are paginated, with alternating grey and white bars for the rows.
The list is wrapped with a box that’s entitled List all Courses, and if you click on the List all Courses drop-down arrow, it collapses the entire view.
Icons are shown for various actions, which all result in further calls to methods in the course controller’s ITD.
Displays a form that you can use to enter the data for the new course.
Clicking on any of these icons navigates to the other actions.
You should spend some time getting familiar with the custom tag libraries, such as.
We’ll continue to customize the user interface as we go through the CourseController example.
Now let’s see how you can review an individual course.
If a user clicks on the  icon for a given course in the web application, the browser navigates to another URL, passing the primary key as part of the path.
The method mapped to this URL pattern is called show.
There’s a bit of interplay going on between this view and the list view in listing 5.5
The list view’s table:table tag generates a table of results, each of which contains a link to edit an individual Course.
Of course, it would be rather difficult to list or show tasks without actually creating one.
Let's see how to create a Course, using the HTTP POST operation.
Spring MVC follows a very specific pattern for form-based processing, illustrated in figure 5.5
As you see above, creating new entities requires first the display of a form that can edit the data.
To create a new empty Course and edit it with the form, users would select the Create New Course menu item, which requests /courses?form.
The HTML form tag is generated by the <form:create> tag, which establishes that the form will be submitted using the POST method to the URI /courses.
Users with JavaScript-capable browsers will see the automatic rich field generation, including date pop-ups for date fields, and automatic rule validation.
You should get feedback from the web page immediately upon leaving the field.
There are several field types used in the form above.
Table 5.3 lists the field types available in the Roo tag library.
Several validation options available, including regular expressions, future, past, and required.
The default for any field not selected by another strategy, and for String fields less than 30 characters in length.
Used for String or large object fields if they exceed 30 characters.
This fragment sets up a <field:reference> tag for the Pet entity within the Visit form.
This is the heart of the forms processing in figure 5.5:
You can then create the course any way you wish and set values that make sense to you.
If you’re manually moving the createForm method, be sure to run the Roo shell to have it remove the ITD-generated one.
Just as the create course process is performed using a combination of the createForm method, create.jspx, and create method, the update course process is performed using an updateForm method, an update.jspx page, and an update action, as you see in figure 5.6
This method is remarkably similar to the create method in section 5.3.3
However, the major difference is that it maps to a GET method that passes a Course ID via the URL path just after /courses.
The method then adds the course to the model map, and redirects to the edit form.
This is a mirror image of the create form pattern above.
The major differences are that you’re submitting your form data to the same URL using the HTTP PUT method and that you’ve embedded hidden form data including the existing primary key field value (known as id), and a version field, which can be used to detect modifications by others after you’ve fetched your data.
This method looks for an HTTP request parameter named _method, which is.
Spring Roo builds RESTful URLs using this technique, and if you install the.
Below you see the update method in the ITD, which will save your changes to the course object, or redirect you back to editing the form in the case of an error:
You can click on the icon to trigger the delete operation.
The HTTP DELETE operation is mapped to a method on the CourseController ITD named delete:
First, the course id passed to the delete method is used to look up the course using findCourse, and then the remove method removes the found course.
The rest of the code within the delete method handles any paging settings, such as the number of rows per page and the number of the current page passed to the original list view, which is where the DELETE operation is generally being called from.
The DELETE operation then redirects the browser to the list operation again, by navigating to /courses.
You can expose the finders we discussed in chapter 3 to your web pages.
To expose the finders to your scaffolded controller, you have two choices:
Just annotate the CourseController with the @RooWebFinder annotation (which has the same effect as using the web mvc finder add command)
Once you do one of the above, Roo wakes up and generates the web-tier methods and artifacts:
This method renders the input form, which gives you a text input field and a submit button.
As you can see, a special Roo form tag, <form:find>, is used to submit a search form.
Though it appears that the form submits to the /courses path, the <form:find> tag actually sends along a hidden field, find, whose value is set to ByNameLike, which is the name of the finder method and is sent via the attribute above named finderName.
Roo can add additional finders by changing the value of this tag.
If you don’t like the way Roo configures web applications, you can choose to roll your own web interface, but for getting basic work done, the scaffolding process can really do the trick.
Roo controllers can write logic directly against Roo entities or in layered applications.
In scaffolded interfaces, Roo repositories and services are automatically detected and used.
The rule is to use the repository automatically, unless a Roo service exposes the repository.
In this way, you can easily refactor your data tier to various persistence models without modifying a single line of your scaffolded code.
If you’ve defined a repository for your Course entity, Roo will respond by adjusting the scaffolding calls.
Here’s the same method fragment with a Roo service defined against the same Course:
Feel free to experiment with various persistence configurations while keeping your scaffolding in place.
You can inject Roo-generated services and repositories into your own controllers by using the @Autowired annotation.
You can then directly access the service as with any injected Spring bean.
In the preceding example, simply inject the CourseService instance and use it in your index method to fetch the number of courses.
If you’re using multimodule projects using the module command, you’ll  need to be aware of the additional syntax for referencing models from scaffolds in other projects.
Roo can scaffold controllers and views against other modules in the same project.
Roo will still detect ActiveRecord models, or services and repositories, and will do exactly the same scaffolding you’ve seen previously.
For example, if you’ve created an entity in a module known as business, which is a JAR-based Roo module, you’d need to change module focus to your web module (here shown as web) and issue the scaffolding command as in the example below:
To execute a web-based project in the Jetty or Tomcat runtimes, you’ll need to do some gymnastics:
This will install the various projects into your local Maven repository and then run the web application, looking for collaborating libraries in the repository itself.
Now let’s take a few moments to review what you’ve learned about Spring MVC and Roo.
You can see just how much power Roo packs into its Spring MVC web framework support.
At the simplest level, Roo generates a template-driven website, complete with JSP tags and a predefined MVC configuration.
For applications that require a ton of data manipulation, scaffolding can save you weeks of effort.
Roo automatically scaffolds all CRUD behavior for you, even providing finder forms and views, if those are defined on your entities.
Finally, you saw that you can easily inject your Spring beans into a Roo controller using @Autowired, so your Roo web applications can support those business logic beans your development team has been building, and so you can keep that logic out of the controller.
In chapter 7, we’ll discuss other web frameworks that can be installed in Roo, such as GWT, JSF, and Vaadin.
You can find out more information on Spring MVC in a variety of resources.
The Spring MVC Showcase sample library, located at http://mng.bz/B91V‚ contains a number of useful samples.
The Spring MVC reference guide contains a wealth of information: http://mng.bz/nZQX.
Once the scaffold has been pushed in, you can do anything you want.
The z= view tags won’t be used anymore, so you can make changes to the views in any way you see fit.
Keep in mind that your views will no longer be maintained against your entity, so any new fields you add must be manually added to your view code.
In the last chapter, we discussed how to build Spring MVC web applications, apply.
Customizing Roo CRUD views 157 In this chapter you’ll learn how to customize your view layer.
We’ll start by discussing the generated scaffold CRUD views, and how to customize them by hiding, disabling, or modifying the field types attached to various form elements.
We’ll discuss how to provide reference data and how to customize date formats, and then dig into how Roo deals with layouts, localization, and themes.
By the end of this chapter, you’ll be able to strike out on your own and customize your Roo web applications.
Let’s begin by discussing Roo’s generated views and how you can customize them.
Before we begin, we need to lay out the rules behind some of the common field and component names.
Later, we’ll discuss techniques for manipulating and hiding pregenerated form elements.
Recall that most elements require an id attribute to identify them.
This id is generally created, for data-based operations, using the following scheme:
For example, your Course entity would generally have the following id:
These HTML id field naming conventions are manipulated by the custom tags to pull various other values.
This is done within the custom tag files themselves, which are located in the WEB-INF/tags directory.
In the HTML form views, all field id values are reduced to _fieldname_id so that they are easily scripted.
For example, _name_id is the HTMLid field representing the name column.
What if I’m building my own views? If you want to benefit from Roo’s predefined localization structure, you need to follow these naming guidelines.
You can also choose to bypass these conventions, and use the custom tag attributes such as label to define your text in-line.
But these won’t be localized, so it’s up to you to decide whether you want to buck the conventions for more control, or learn them and benefit from them.
To do so, you can modify the tag attributes for the various list and form views.
If you’re modifying scaffolded forms, rather than building your own, you’ll encounter the z attribute, which is assigned a generated unique ID.
This seemingly random value tells Roo that the field is being managed by Roo itself.
You don’t want to change this value unless you decide to manage a field yourself.
Beyond the ID fields and z attribute, Roo has a number of settings in the tag libraries that make it easy to customize your web views.
Above all, read through the tag libraries and learn their features.
With the conventions behind us, let’s see how to change the views to suit your needs.
List views are composed of tags nested as shown in figure 6.1
Roo automatically iterates through the rows in the collection, first outputting the.
In the list view, the tags you can customize include page:list, table:table, and table:column.
Keep in mind, you are limited in the scaffolding to showing the data returned by the controller, and may.
The collection to be iterated through in the nested table.
It’s listed here so that the outer tag can determine whether to show a table of results, or a message that there are no items available.
But more important customizations occur at the table:table and table:column level.
Let’s look at the customizations you can perform on your results table in table 6.2
Whether or not to show the icons for creating, updating‚ or deleting entries from the table.
The URL path fragment to prepend to any requests to edit or remove data.
You may wish to replace the table with other form elements instead.
The field name for the primary key of the row—id is the default.
You won’t want to render all 60 fields of your massive employee record, for example.
Setting render="false" for the ones you don’t want will omit them from the page.
For scaffolded date fields, this value will be automatically set.
In earlier versions, users were only shown 10 characters of each field.
Customizing Roo CRUD views 161 You can customize any of the attributes in these fields, as long as you don’t change the generated id field value, or, in the case of the column definitions, modify the name of the properties they’re attached to.
This way, Roo marks the customized elements as user-managed and leaves them alone.
They’re nearly identical to what you saw in the previous chapter.
Unlike the list view, form views are generally relatively flat.
Table 6.5 has a list of fields that are common to many field types, and their relevant uses.
The label to use to identify the field on the screen.
This version is not localized, and is useful during prototyping or for applications that don’t need localization.
As with label above, identifies the field on the screen.
This may be useful if set based on user permissions using the Spring Security API or other databased permission scheme.
Armed with these tables of information, you should be able to customize your views nicely.
You can always drop in additional HTML elements where needed, and update your CSS styles as well.
Here are a few additional helpful techniques you can use while customizing your forms and views.
For example, you can switch the description field to use the field:editor tag, so that users can enter HTML data.
Simply replace the original field:textarea tag name with field:editor, leaving the same z value.
This is also useful when Roo has chosen a textarea field instead of a single-line input field, or when you want to switch from a checkbox to a Yes/No select list.
After you make this change, the Roo shell will update your page for you, switching the field tag value to user-managed.
Remember that if you’d like to reset scaffolded field settings for a given field, you can remove the field from the file, and Roo will replace it with a brand-new Roo-managed field.
Roo has two attributes attached to most scaffolded field and form elements: render and disabled.
This isn’t the same as making it nonvisual; it literally removes it from the view output.
For text fields, the value will be emitted as text only, for example.
In the Offering entity, you’ve defined your offering date using the style-based format as the parameter to the Roo @DateTimeFormat annotation:
In addition to  -, which means suppress the date or time portion of the field, @DateTimeFormat supports three formats—S, M, and L.
In the US English locale, these resolve as shown in table 6.6
During scaffolding, Roo takes this information and uses it to translate the date into a localized String using the Joda-Time library.
Roo will add one addAttribute() setting for each field annotated by @DateTimeFormat.
The scaffolded field will use this format automatically in the attribute dateTimePattern during the scaffolding process:
You can use this technique yourself for your own nonscaffolded date fields.
Another way to date formats is to use the format attribute of @DateTimeFormat:
Roo simply adds the format as a String in the Controller ITD:
You can then use the dateTimePattern attribute to inject the pattern:
If you want to localize your date formats for nonscaffolded views, or want to use the same patterns across many date fields in your nonscaffolded or modified scaffold views, you can directly add the formats to a localized version of your application .properties file and use <spring:message> to load it into a variable at runtime.
Refer to the coursemanager file list.jspx in chapter 6 for the offering entity for an example.
Roo may also have problems converting these formats into a value supported by the date picker held in the field:datetime form field.
The brute-force method is to apply a format pattern to the field directly, using the dateTimeFormat attribute on the view:
Of course, this pattern won’t be updated based on changes to the entity’s @DateTimeFormat annotation.
But if you need to display a very specific date or time format for a given view, at least you have an option.
Let’s say you need to provide a list of values for a given field as a drop-down list, such as a course complexity level, a query from a database, or a list of values provided by a collection.
On the server side, you’ll need to provide the reference data to the page in the form of request data.
Use your own finder, service‚ or JDBC query to populate the list.
On the view itself, you can use the field:select tag to expose the options and allow them to be selected:
The itemLabel and itemValue clauses refer to properties of the collection provided in the Offering bean, and the provided collection is assigned with the attribute items.
You can even navigate to another controller to do a search, perhaps even making a modal dialog out of the selection process.
Anything you can do in standard Spring is available to you here.
Here’s how Roo identifies and renders various elements on the page:
If you’d like to change the way your entity is described, you can modify this file.
Column names —Column names are also stored within the  application .properties file in the same way as the singular and plural entity names (the field is appended to the end of the preceding label)
Remember, Roo won’t overwrite the tag libraries or layouts it creates, but it will attempt to keep fields in sync.
Now, armed with the knowledge of how Roo resolves messages, let’s dig into localization.
The icons placed in the footer.xhtml file of your standard layouts are automatically generated if you issue the web mvc language command.
Because all files are mounted in this directory, you don’t need any additional configuration.
Roo also copies an icon for the language flag into the webapp/images directory, and updates the footer to allow you to click on that image to switch locales.
For example, to translate the site to Spanish, you can issue.
See chapter 11 for details on how to create other language locales by writing an add-on.
Now that we’ve talked about the mechanics of rendering the page contents, we’re ready to discuss page layout concepts.
Roo uses Apache Tiles to provide a composite view: a view composed of various individual parts.
In this section we’ll take a look at just how Roo works with localized property files; the configuration of Apache Tiles in a Roo application; how you can define page layouts via tiles definitions; and then how to customize individual elements of the Roo layout.
TilesViewResolver processes view names, emitted in the controller, and attempts to find layout definitions within configuration files specified in the definitions property.
The main layout definitions file, layouts.xml, is what tells Roo about the two main layouts—default and public, as shown in the following listing.
In the previous example, each layout is given a physical file that defines the contents of the layout, and values to substitute for various tiles within that file, such as header, footer, and menu.
Hang in there, though: Tiles loves levels of indirection! That’s why you can create a number of layouts, assigning them to views, rather quickly by extending or modifying layouts.
This layout gives users a larger amount of screen real estate.
This layout defines a very comprehensive page structure, including features such as HTML5 compatibility C, JavaScript and CSS support, the Dojo widget library, D CSS, and preinstalled tag libraries B.
The template also includes a set of div elements, each of which defines areas that can be rendered with content at runtime.1
Figure 6.3 shows the layout divs, styled by Roo’s generated stylesheet, in a simple block diagram.
Figure 6.3 JSPX files involved in the Tiles At this point, you’re probably wondering just layout process.
To find out more about Internet Explorer’s support for various modes, see http://mng.bz/jQou.
Finally, you see that the layout named default will be used to render the throwaway/index page.
The header, footer‚ and menu tiles will be loaded from files based on the settings in WEB-INF/layouts, and the body tile will be loaded using the index.jspx file in the views/throwaway directory.
You can modify the content in any of these tiles just by changing the view files.
Here are a few suggestions for quick modifications you can do:
Read the documentation at the top of the menu.tagx, category.tagx, and item.tagx files for details.
Roo also supports the concept of theming, which is closely related to layouts.
If you look closely at the footer of each Roo page in a web browser, you’ll see two clickable links for these themes.
When you click on one of these, Roo uses Spring’s theming support to switch a simple client-side HTTP cookie named theme between the values of standard and alt.
A little too complex for this book, theming boils down to special properties files, stored in WEB-INF/classes in the web application, for each theme.
Roo uses a special generated tag, theme.tagx, to generate these links, and the theme resolver accepts clicks to these links, which sets the cookie value for the browser.
Each time the browser renders a page, it passes the theme name in a cookie to Spring.
As you can see, you have a range of options for customizing your web application.
In chapter 7, we’ll look at Spring’s support for the Dojo component library and JavaScript, delve a bit into Ajax, and look at several other advanced web frameworks supported by Roo: GWT and JSF.
Although rather general, if you get into CSS and HTML editing, this is a great reference.
In this chapter you’ll learn how to work with more advanced web frameworks in Roo.
Then we’ll discuss some of the other web platforms available to Roo developers today via add-ons: Google Web Toolkit, Vaadin, and JSF.
In this section, you’ll learn how Roo mounts Spring JavaScript and how the Roo tag libraries use it to create rich widgets.
Then you’ll wire a text field to an Ajax serverside method and invoke it using a JavaScript event.
Spring JavaScript API—A set of Spring-developed utility JavaScript methods to install Dojo widgets and perform automatic client validation.
Resource handling support—This used to be a Spring JavaScript feature, but was moved into the Spring Core in version 3.0.4
Spring will cache these resources and serve them to the client automatically.
The example is trivial but shows the minimum plumbing required to set up an Ajax call.
You’ll use the Dojo framework to wire changes to a course duration field to trigger calls to a Spring MVC method.
Every time you modify the field value, the Ajax method will calculate the list price of your course.
Spring MVC has full support for Ajax on the server side, as does Dojo on the client.
You’ll use a specially annotated Spring MVC method to handle the server-side call, but first you need to wire up the input field to trigger a JavaScript method every time you type a digit.
We'll use Dojo event handling to wire changes in the duration field to a method that executes the Ajax call.
The dijit.byId() method call B tells Dojo to hold a reference to the JavaScript object representation of the Dojo component for the duration field, which is a Dojo ValidationTextBox.
Your last step is to actually implement the Ajax calculation method.
To calculate the list price, you’ll use the Spring MVC @ResponseBody annotation.
This annotation tells Spring MVC to return the result of the method as the output, and not trigger traditional view resolution.
That’s the entire Ajax server method—of course, the serverside developers have it easier than the web developers do in this case.
If you try to type anything other than numbers into the numDaysduration field, the listPrice field will be replaced with a large amount of HTML text.
The text returned is actually a standard HTML error page that reports an invalid mapping; because your method was coded to accept an integer parameter, it didn’t find a suitable method to map to the incoming request, which, since specified as a set of characters, was not numeric.
There are a number of ways to solve this little problem.
The easiest is to simply zero out the field if the user submits invalid data.
You can change your method in the CourseController to look like this:
The create.jspx file can be customized the same way; the major difference is that you don’t have to carry along hidden id and version fields, and you use the POST method to create a new course using the /courses URL.
Roo provides a simple, one-line installation command, gwt setup, that installs the GWT compiler, server-side infrastructure, and build instructions.
You’ll use your Course Manager Roo starter schema to build out a GWT application.
Roo responds by building out your GWT application, installing the GWT Maven plugin and dependencies in the pom.xml file, and generating a scaffolded GWT web application.
You’ll need to decide whether you want to let Roo generate your GWT components using a scaffold, or whether you want to roll your own.
Table 7.1 lists the commands you can use to set up your GWT code.
These commands may take one or more of these options:
After the GWT application is generated, or you’ve developed your GWT code to suit, Roo is able to execute your GWT application from the Maven command line.
Go ahead and execute it by running the following commands:
These applications are referred to as permutations, as you may see during the build phase:
After a significant amount of processing, the application will start in an embedded Maven Jetty container.
If you use the gwt scaffold or gwt all commands to generate your GWT frontend, the user interface will be ready to test.
The frontend presented will act more like a desktop application than a typical website.
Figure 7.1 illustrates this with an example of the Courses pane.
Please refer to the Roo forums to gain details on the current version of this framework.
You can also run the GWT application out of an exploded EAR by issuing.
In this mode, GWT runs as a web application only, in the same way it will run on web application servers in test or production.
To target a specific browser only, such as Safari, add the following configuration entry:
The pages themselves, known as facelets, are composed of containers and components.
Roo uses the PrimeFaces JSF widget library (http://www.primefaces.org), which provides a wide array of JSF components.
Let’s take a look at how to set up JSF as an alternative web framework.
To install JSF on an existing JAR-based project, use the web jsf setup command: roo> web jsf setup.
Roo installs JSF files in several directories under the src/main/webapp directory, including.
Pages—All JSF pages for your views are stored in here.
They’re defined in an XML page format named facelets, which have the extension .xhtml.
We won’t go into the depths of JSF in this book.
There are plenty of resources we can point you to.
But let’s take a look at how Roo can scaffold JSF interfaces and dissect a scaffolded view and a page bean.
You can use the web jsf scaffold command to scaffold a single entity, or web jsf all to scaffold all entities.
In either case, Roo will generate page beans and pages in the appropriate directories.
Of course, by now you should assume the heavy lifting is provided by an ITD, and that the ITD is generated by the presence of an annotation.
One of the bean methods, allCourses(), is called when the course view is initially.
Observant Spring developers will see that these page beans are stateful.
Somehow, the allCourses collection was loaded before the view requested the course list.
In some ways, this is a simpler, more Swing-like programming model than the typical MVC approach.
Table 7.2 outlines some key methods generated by the scaffolding.
These methods are called to data-bind the form fields of the form view to the page bean before persisting or displaying a single entity.
More advanced JSF users may choose to remove the dynamic widget definitions from the populate methods and define them in the view itself by pushing in the method and modifying the code in the bean’s Java class.
Now let’s take a quick look at the JSF facelet for your course page bean.
Figure 7.2 shows the page layout of the JSF user interface, and displays the Course list scaffolded view.
Roo uses a mechanism similar to the MVC list view, embedding all columns in each row and providing icons to delete, edit, and view each row in a form view.
This is provided by the table of results and is bound to the getAllCourses() method in the page bean as shown next.
The list view is driven by the getAllCourses() method in the backing bean.
The fields are provided using the Java EE @PostConstruct method init(), which you can push-in and customize to provide a custom list of fields to display.
A column is defined with the various action buttons, such as view, edit, and delete.
Events are bound, such as the backing bean viewDialog method, which constructs the components to display a view.
To wrap up, let’s look at one of the embedded dialogs, the create dialog, which lives within the panel just after the list view definition:
Although support for JSF is early, the feature set is rather complete, and you have the ability to define your own custom JSF views as needed.
Unlike MVC, the JSF add-on takes a slightly different approach to scaffolding.
If you’re adding additional tag elements to the view, be careful not to remove the form views for editing, creating, and viewing.
They range from HTML and JavaScript-based frontends to platforms such as the Flex API.
Using web flow setup from the Roo shell, you can get Roo to generate the proper installation scripts, and mount a new Web Flow script.
Flex—Flex is a true client/server development platform when coupled with a smart application tier such as Roo.
The Roo Flex add-on, which configures Spring BlazeDS remoting (a super-fast binary API), is currently being taken over by the Roo community.
As of the time of this writing, it doesn’t work out of the box with Roo.
Check the Flex forum on SpringSource.org for details on the current state of the add-on.
Refer to the source code of the Spring MVC, WebFlow, JSF, and GWT add-ons to see how it’s done.
More web and rich internet platforms will surely appear in the future, so make sure you keep up to date with the Roo add-ons by visiting the Roo forums.
Spring Roo has support for a number of rich internet APIs.
From roll-your-own JavaScript and Ajax components and using Spring’s excellent support for partial server requests, to the embedded rich web components and Ajax libraries in Spring JavaScript and Dojo, to sophisticated frameworks like GWT, Vaadin‚ and Flex, you have tons of options to choose from.
If you’re looking to support a rich user interface but don’t want the sophistication of a GWT or Flex approach, the Dojo and/or other JavaScript toolkit approaches will serve you well.
But it would be wise for your team to bone up significantly on JavaScript mastery, because there are many pitfalls awaiting the Java developer who attempts to treat JavaScript as just another programming language.
The downside is that the current MVP design causes a ton of code generation and can be difficult for the uninitiated programmer to approach.
A more easy-to-grasp alternative is JSF, because it nests in the same way Swing components do, and has a component-driven lifecycle.
The folks at SitePoint (http://www.sitepoint.com) support and write about Dojo.
Spring developers know there’s a better solution: configure the Spring Security API.
Originally called ACEGI Security (and later acquired by SpringSource), the.
Spring Security API is a platform-neutral, general-purpose, security API that can be hosted on any Java application server without changing the code written by a developer.
In this chapter, you’ll learn about the Spring Security API and how to install it within a Spring Roo application, including the web URL security and a customized login page.
You’ll review the security artifacts and how to tailor security configurations to suit your needs.
You’ll also learn how to turn on security event logging, which logs all security-related activity, allowing you to run security analytics and receive alerts to any unauthorized access to your application.
Let’s get started by installing Spring Security in the Roo application.
Security commands aren’t available until you install the web components of a Roo application.
After you’ve typed in the controller command, the Roo framework will generate the controller classes and configuration files.
Now you’re ready to install and configure the security API in the Roo application.
Issue a security setup command inside the Spring Roo shell, and install the framework.
Configure a Spring context file to define your security rules.
To install Spring Security in an existing Roo application, issue the command security setup:
A login page (called login.jspx) and a views.xml layout file.
The views.xml file has the tile definitions for different views in the application.
An updated web.xml web descriptor file, which includes the Spring Security servlet filter.
Let’s take a look at some of these changes in detail, starting with the new security context file.
You’ll use the HTTP element C to configure HTTP security, basic authentication, and other defaults.
From an authentication standpoint, you’ll use the form-login D and logout E elements to enable a login page, with a login failure URL and a security logout page, respectively, for your web application.
Listing 8.2 Spring configuration snippet with special identification for anonymous users.
When you set the password value in the previous listing to ignored, you make the authentication occur based only on the username.
Don’t forget to comment out the password-encoder element as well; otherwise, the authentication will fail, with a message such as Bad Credentials.
Authentication is the act of verifying the identity of the agent requesting access to your system.
In Spring Security, authentication can be tied to various physical security mechanisms, such as BASIC authentication, form-based security, certificate-based authentication (CERT), or SSH-based key pairs.
As you’ve learned, Spring Security has already configured both authentication and authorization.
These roles are attached to the admin and user logins.
You can install the Spring Security engine into any web container using a standard servlet filter.
As you can see with the URL pattern of /*, all URLs pass through the filter, which means Spring Security can protect more than just controllers.
This security configuration can be extended and customized by adding more JSTL scriptlets and conditions using the Expression Language (EL)
For example, you can implement a feature called Remember Me so the application remembers the identity of a logged-in user between sessions (a feature supported in the Spring Security framework)
Also, once you modify and customize the configuration files, Roo remembers those changes and doesn’t override them the next time you run the Roo commands.
Now that you’ve been briefed on the configuration elements, let’s discuss how to use Spring Security to configure security in a simple application.
Let’s discuss the application security module of the Course Manager application.
You’ll learn more details about these later in the book.
With these application security requirements in the areas of authentication and role-based authorization defined, you’re ready to secure the web application.
Both roles may view the course catalog and course details, but only the admin can delete them.
This is a specific set of choices, but one that can be easily tweaked by modifying the tags in the previous code.
The expressions you can use in the access= tag are listed in table 8.1
Disables Spring Security for this URL pattern and allows access to all.
You can also apply more arbitrary expressions in this configuration, but this list will do for simple security configurations.
Listing 8.3  Spring Security JSP tag library to control access to web page elements.
To use Spring Security tags detailed in the previous listing, you’ll first specify the tag library namespace (http://www.springframework.org/security/tags) B and then use security tags such as authorize C with an attribute like ifAllGranted to specify the role or roles that will have access to the specific web page element (in this case, the delete menu item)
This will cause the Roo shell to automatically remove the delete and update methods from the controller class and update the corresponding JSPX view components:
The next step is to define a more permanent authentication storage mechanism by persisting roles and principals into a database.
Later in this chapter, you’ll also learn how to configure LDAP-based authentication in a Roo application.
In a real system, you’d never configure security credentials within a configuration file, because you’d have to redeploy every time you needed to add a new user.
First, you’ll create entities and controllers to manage your security credentials.
For all of these entities, let’s define the controller classes using the web mvc scaffold command:
You should also secure these new URLs so that only ROLE_ADMIN users can access them.
Add the following intercept-url entry to protect all URLs below /security:
You can do this by using the --path /security/pathname element in the web mvc scaffold Roo command, which automatically places controller request URLs and view paths in the pathname path, within the /security superpath.
It’s important to note that the Roo add-on community is working on automating the steps required to use JDBC-based authentication configuration, which will make the job of enabling database-driven user authentication much easier in the future.
First, you’ll configure your users using a relational database, accessing entities defined within the same Roo application.
You’ll add a real, data source–backed authentication database, as illustrated in the following listing, before the original user-service tag.
Spring Security provides support for LDAP-based authentication and authorization out of the box.
To use Spring Security LDAP authentication, you’ll first need to add the following Spring LDAP dependencies in the Maven pom.xml file:
You can use an open source LDAP server such as the OpenDS directory server for testing the previous LDAP user authentication configuration.
Refer to the readme.txt file in the sample application code provided with this book for instructions on how to configure and run the OpenDS server.
If your organization has a user data repository in a legacy system that doesn’t support JDBC- or LDAP-based authentication, you can use a custom authentication provider for user authentication.
In this scenario, the authentication configuration would look like the following:
After you’ve updated the authentication provider configuration using either a JDBC-based or an LDAP-based authentication provider and you run the application, you’ll see the authentication and authorization functionality in action.
To handle this error more gracefully, let’s create a new view page called AuthzError .jspx with a user-friendly message, such as the one shown in the following code snippet: <html>
Let’s also create a user-friendly error page (called Error.jspx) for handling the HTTP 404 errors.
Now you need to add these custom error pages to the web.xml file, as shown in the following:
The last step in making your code example a complete web application is to add links in the footer section for the login URL.
Note that the links in the footer tile of the web page don’t display the login link.
The footer tile displays only the logout link when you’re already logged in.
You’ll have to type the URL http://localhost:8080/coursemanager/login in the browser window to navigate to the login page of the Roo application.
Now the login link will display next to the home link when the user isn’t logged in.
The following log output snippet shows the security event logger output messages after you enable LoggerListener:
The default logger level in the generated log4j.properties file is ERROR, so you’ll need to modify the logger level to either WARN or INFO to be able to view the security event log messages.
Run the following Roo commands to change logging level from the ERROR to the INFO level.
Make sure that the ERROR log level is set for the application that’s running in the production environment and set the INFO level to run only in nonproduction environments:
The logging command shown in the previous example defaults to all packages in the web application‚ but you can use the optional --package argument to specify the package that you want to set the logging level.
The following example provides the logging command again, but this time it specifies the package name for the classes in the Roo project (using the variable PROJECT, which maps to the org.rooinaction .coursemanager package):
This will add the following line to the log4j.properties file:
This is helpful for troubleshooting any security-related bugs in the application.
As you can see in the previous listing, almost all of the application security aspectssuch as the user authentication, the role-based access (RBAC) to different web pages (URLs) in the application, the expression language–based access control, and the security event logging—can be defined in the XML file without having to write a single line of Java code.
This is the power the Spring Security framework brings to the table‚ and Roo takes complete advantage of this approach.
The Spring Security framework makes the job of every application architect and developer easier, because they can spend their focus, time, and effort on the business logic part of the application instead.
In this chapter, you learned how to implement security (which includes authentication and authorization aspects) in a Roo application.
You reviewed the Spring Security concepts and the configuration details of application security in a Roo application.
You also learned how to change the authentication provider configuration from the hardcoded username and password values that are used for testing purposes to a realworld user-credentialed data store like a relational database or an LDAP repository.
You looked at how to protect and restrict URLs and adjust the views for different web pages in the application based on what type of user is accessing that specific web page.
Finally, you enabled the security event logging in the application to view the authentication event details as and when users log in to your web application.
In the next chapter, we’ll switch gears a bit and discuss Roo’s testing facilities.
We’ll review unit, integration, and web tests, and you'll learn how to test Roo services, entities, and web pages using JUnit and Selenium.
First, you’ll learn how to find and install Roo add-ons from the central repository.
You’ll then build your own add-on to install jQuery and jQuery UI libraries.
In the advanced add-ons discussion, you’ll learn how to install CoffeeScript language into your local development environment.
You’ll also learn how to publish the add-ons using the OSGi Bundle Repository (OBR) and the Roo addon service.
Spring Roo helps you build your applications rapidly, but that doesn’t mean you should skimp on your testing plans.
Chances are, you’re building the applications so fast that it would help to slow down a bit and write some useful tests.
The more you test up front, the fewer surprises you’ll find in production.
You can also write integration tests for your Spring beans and install Selenium for end-to-end testing.
In this chapter, you’ll see how Roo makes it easy to set up your test environments and how you can test using Roo’s integration and web testing technologies, such as the Spring test runner and Selenium.
Think of these testing models as layers in a kind of testing cake.
Without all of the layers, your tests are one-dimensional, and they look at your application from only a single viewpoint.
You’ll find different bugs at each level, so implementing each of these types of tests is key to finding all of the bugs hiding in your application.
The review of the testing levels in this chapter follows the same order as depicted in the previous figure—you’ll start with unit testing and finish with functional testing.
Unit tests —Exercise single units of code, usually Java methods.
Where necessary, other collaborating objects are either stubbed or mocked so that they can behave in predictable ways.
For example, a Spring CourseManager bean may rely on a TaxCalculator bean.
In a unit test, you’d test the calculateCost() method of CourseManager, but you’d want to generate a predictable result from the tax calculator bean reference, so you’d mock or stub it.
JUnit is a popular testing API, and Roo uses it for all unit tests.
Integration tests—Exercise methods in components such as Spring beans, but run the tests in a live container.
Figure 9.1 Testing levels in Roo, Spring, and most other frameworks.
Note how complexity increases as the runtime environment is loaded or user interactions are posed, and how much faster tests run when isolated as unit tests.
Functional tests—Exercise the application using an external testing tool, such as a web browser emulator.
Selenium is an open source web testing tool that can be used to test your application’s web frontend.
Let’s see how Roo provides access to these test frameworks.
Table 9.1 provides detail on the methods in the CourseDataOnDemand aspect.
Table 9.1 A sample of DataOnDemand methods, using the Course entity.
Configures and persists ten instances of the Course entity, held in a member list variable, data.
This method doesn’t have to be called directly, because the other methods returning test entity instances will call it when necessary.
If you call it after the elements are initialized, it returns without modifying the collection.
This method doesn’t persist the course; hence the name includes the term transient.
If your validations are too complex for a simple static definition of a field, you may push one of these methods in to the DataOnDemand class, and modify the behavior.
Table 9.1 A sample of DataOnDemand methods, using the Course entity (continued)
If the course index specified is too high, the method returns the course with the highest available index.
Let’s dive into some detail on three key methods of the DataOnDemand framework.
You need to understand them fully to take full advantage of them and write tests quickly.
The index helps to define the values for the data.
All string-based fields hold the name of the field, an underscore, and the index value.
For this chapter’s sample course, the test data might look something like this:
Use of this method to set up test fixtures saves you time and energy.
Many of the tests in this book take advantage of this method.
The getSpecificEntity method returns an entity from the internal list of persisted entities.
If the list is empty, it will be initialized automatically.
Roo will initialize and persist ten instances in this list.
If the user requests an out-of-range index value, it will return either the lowest or the highest element.
If you don’t care which persistent entity instance you work with, ask for a random one with getRandomEntity()
Repeated calls won’t necessarily return unique instances because the sample range is only ten unique instances.
Let's look at some techniques you can use when working with the DataOnDemand components.
For working in an integration test, you can get a transient course and persist it, as in this code block that checks for a generated primary key after creating an instance of a course:
Stubbed unit tests 217 Alternatively, you can grab a prepersisted instance and manipulate it, as you see in the next example, where this test asserts that an updated course has a different version number:
The answer is, no; instead, you construct a new instance.
It’ll initialize itself, provided a persistence context exists and you’re running a Spring Integration test.
Now that you’ve seen how Roo approaches tests and how to generate test entity data, let’s start looking at the various types of entity tests you can write, and how you can allow Roo to help you during the creation and execution of those tests.
You’ll review unit and integration tests with JUnit, and then perform some web testing with the Selenium API.
Let’s begin by looking at the Roo unit testing framework.
The test stub command creates a JUnit test that constructs an instance of a class, and creates test stubs for each of the public methods.
You create the test by using the test stub command.
Let’s look at a simple service that calculates a tax amount:
This class is initialized with a BigDecimal tax amount and calculates a simple tax based on an injected tax rate.
This is injected into the component via the Spring container, either by annotation, JavaConfig, or XML injection.
This assumes you’ll be writing tests against the methods of the class.
The following code lists the sample test, with the stubbed test method for the calculateTax service method:
This class doesn’t compile because the DefaultTaxService constructor requires a tax rate, injected as a BigDecimal.
You can use the test stub command to quickly generate empty tests against controllers, services, and other beans, and quickly write simple JUnit tests.
Let’s take a look at the next type of Roo test command, test mock, which is useful when you need to work with collaborating services and Roo entities.1
Mock objects are objects that pretend to be instances of particular classes, but are completely controlled by the test developer.
They appear to implement the specified interfaces, and you can configure them to return predictable values when their methods are called.
You can use these mock objects instead of references to other Spring beans or collaborating classes.
There are a number of different mocking frameworks available for unit testing, including these:
Mockito (http://mockito.org)—A popular unit test mocking library, well known for its easy-to-understand syntax and literate API, which uses method names such as when, then, answer, and other English language predicates.
The Mockito API is great for mocking Spring bean and regular POJO collaborators with methods defined by an interface.
Uses a mock expectation recording and playback API, which can be a bit daunting to new users.
In addition to Spring’s interface-driven applications, it’s a popular library.
PowerMock (http://code.google.com/p/powermock)—An extension library that enhances the capabilities provided by EasyMock and Mockito.
This mocking tool can mock static methods, interfaceless classes, constructors, final classes, and so on, which other APIs cannot.
Mock objects are often used when a layered application requires a particular Spring bean to collaborate with other beans, either in the same level or lower levels of the application.
They take less time to create than a fully stubbed object, because you only have to create the mock object at runtime, define the specific behavior to mock, and ignore the rest of the methods in the class.
Stubs require you to create a concrete class, and implement each of the methods of the object under test.
That takes a lot of time, and unless you’re able to exercise the entire stub across all of your test methods, it may be a waste of your time.
What if you want to see whether the entity can be validated appropriately, or if you need to stub the entity itself behind a service? Spring provides a feature to mock the.
Refer to JUnit in Action, Second Edition for details on how to work with these APIs.
Here’s how you can use mocks to emulate collaborating objects:
If you were working within a traditional, layered Spring application, you’d likely have Spring service beans that would work with Data Access Objects.
You could easily make a mock version of a DAO that returns a predefined list of students if the getAllStudents() method is called.
A fragment of a test may look something like this example:
As you can see, the Mockito framework makes it easy to define a mock object, such as studentDAO shown in the previous example.
You can then manually inject the mock into studentService and tell the mock to return a prefabricated student list.
After the service requests the getAllStudents() method on your mock, it automatically returns your predefined list of students.
Mockito does a great job with typical, interface-driven Spring beans.
But it can’t mock Roo entities, because Roo uses static methods within the entity to find entity instances from the database, and holds onto a private JPA entity manager to provide persistence logic.
Rod Johnson, the creator of Spring, contributed a testing framework element to help out: the static entity method mocking API.
Spring provides a special mocking API to allow developers to write tests against static entity methods.
Because the annotation is in effect, the static method isn’t executed, but is added to the list of methods to expect.
You don’t need to do this if the method has no return value.
Because of the static methods used by the entity finders, testing a Spring bean involving an entity requires use of the Spring entity mocking framework.
To set up a mock test case, you use the test mock command:
Roo will then create a test class that looks like the example shown in the following listing.
In this case, you want the countCourses() method invocation to return the value 13 when executed.
You’ll need to decide whether to use integration tests for accuracy, or unit tests for speed, when testing validations and business logic attached to your entities.
You’ve examined the test mock command, and how to make use of it to write unit tests of Spring Roo entities.
Now it’s time to use this in a more complex example and test what happens when you try to validate data.
A typical JUnit unit test will test a single “unit” of code, such as a method on a Spring bean.
Everything else is either stubbed or mocked, so that you can focus your energies on exercising your method under test and verifying the result.
The method creates a number of Registration entities and associates them with the appropriate student and course offering.
The previous sequence diagram shows a fairly typical interaction with Roo’s Active Record–based entities.
Rather than relying on repositories or DAOs to wrap access to your entities, you use the static finder methods to locate them, and methods such as persist() and merge() to manipulate them.
Now, let’s implement the test using JUnit and Roo’s own entity mocking framework.
Let’s write a test that exercises a bean that processes student registrations.
The bean provides a registerStudents method that accepts a set of students and an offering, and then registers students for the provided course offering.
First, you’ll create the unit test class, using the Roo Shell test mock command:
This annotation enables the entity mocking framework, as you’ll see in the next example.
Now, you’ll define three DataOnDemand class instances, one each for Student, Offering, and Course, which you’ll use to decrease the amount of code in your test.
Define them in the Roo console with the dod command if they’re missing in your code:
You’ll also create the Service bean yourself, so hold onto a reference to that, too:
Next, define a JUnit @Before method, setup(), which executes before each test.
This method will create instances of all four of these objects:
Referring back to the sequence diagram in figure 9.3, you’ll see that the first action of the method under test is to look up an Offering based on the value of the offering key passed to it.
Now, you’ll invoke the call you’d like to have your unit execute when it’s under test, and you’ll follow that up with what you expect it to return:
You’ll do this for every interaction you expect your unit to invoke.
For example, you can pass in ten Long primary key fields of students to register for.
By now we hope you’re thinking that a straightforward integration test would be easier than this.
You’re right, but it’ll run slowly and you’ll have to run it against a live database.
If you’re trying to make sure the actions in your sequence diagram are called in the correct order, this test will do so at a fraction of the time.
You have to run the test—like EasyMock, Spring’s control doesn’t do anything until you call the playback() method:
Now you can perform the call, using the generated offering’s primary key (1L) and the list of fake primary keys generated for each student mock call:
If all is well, there’ll now be ten registrations, which you’ll fetch and assert, as shown in this next example:
What if you need to spin up the Spring container to run your tests? Perhaps you want to verify that the database schema still operates against your entities and JPA code, or you want to make sure your Spring configuration is valid.
Roo has two approaches for you—either you can use the Roo entity test framework and DataOnDemand classes, or build traditional Spring integration tests.
Let’s take a look at both approaches, starting with the entity test framework.
It also uses the DataOnDemand framework to scaffold the test data, and perform tests for all entity operations, as shown in figure 9.4
The testing framework shown in the figure automatically exercises all methods in the Roo entity.
The difference between this test and the ones discussed earlier in this chapter is that it runs within the Spring container.
The funny thing is how short the Java class is:
You’ll do all of the work using the IntegrationTest aspect combined with the DataOnDemand aspect.
As you saw in the previous listing, each method, such as findCourses(), is tested in a separate method, using some simple interactions with the DataOnDemand class and the entity’s API.
Obviously, these tests may require you to do some leg work, pushing in various methods so you can change them.
For Roo-built services and repositories, any entity integration tests you define with test integration will automatically adjust between testing the entity directly and using the repository or service layer, if you’ve generated one for your entity.
This means that you already know how to test Roo-built services and repositories.
Roo uses Spring’s annotation-driven JUnit 4 test runner in the automated integration tests.
Now you've seen how you can write tests against live Spring beans such as Roo services and repositories.
You can use this technique to test any Spring bean in your container; just autowire the bean into the test and exercise it as you would in your application code, using asserts to verify behavior.
Now that we’ve discussed how to write integration tests, we should mention that all of the tests introduced so far are rather invasive, looking at the system from the inside.
Equally valuable are tests that look at the system as a black box: tests external to the application that exercise the application as a user would.
For those tests, we’ll look at Roo’s support for web testing, using the Selenium automated web testing tool.
Testing shouldn’t stop at the unit test or integration test level.
These tests all exercise a particular component or set of components in compositions that you define yourself.
But the best way to verify that the entire stack functions properly is to use some sort of external, black box test—meaning a test external to the application itself.
It can exercise browser-based tests against an application, and has a Firefox-based IDE (Selenium IDE) for building tests interactively against a live application.
Selenium tests can be written in a number of languages, from HTML to the Java JUnit API to other languages such as Ruby or Python.
Selenium tests can be used in a number of ways, including.
Feature testing—Testing various use cases in your application, using a browserbased approach.
Load testing—Using Selenium’s distributed testing engines, a heavy load can be placed on the application from a number of machines.
Selenium is widely adopted and there are a number of resources, such as JUnit in Action, Second Edition, that document it in detail.
We’ll focus on how to get Selenium up and running against a RESTful controller, and then we’ll look at how to add JUnitbased Selenium tests for more sophisticated testing scenarios.
As with everything else in Roo, the Selenium framework is installed with a simple Roo shell command.
The selenium test command takes several options, including the mandatory controller class to test:
Installs the Selenium dependencies and the Codehaus Maven Selenium plug-in in the Maven pom.xml file.
You’ll see immediately that Roo’s support for Selenium mostly focuses on scaffolded controllers.
This may be a bit limiting, but later in this chapter we’ll show you how to install support for any controller you want by using the JUnit API.
To run your tests, you first have to launch your web server.
Open a new command prompt, switch to the project root directory and issue the following command to launch the Jetty web server:
You’ll need a running instance of your application in order to run Selenium tests.
To trigger the tests, issue the following command from another operating system prompt to run your tests:
This command launches the Selenium test runner, which should launch an instance of the Firefox browser and run your tests.
Figure 9.5 Successful Selenium report showing test run of the test-tag.xhtml test.
The contents of this test are shown in figure 9.5
So now that you know how to install Selenium and generate and execute your tests, let’s take a look at the test suite and the test that you initially generated on your Tag object.
Let’s review the contents of that file after you’ve generated the Tag test, as shown in the following listing.
Roo also generated your test case, based on the fields of your entity.
Let’s take a look at the test-tag.xhtml test file next.
Any change to the entity will also affect a change to the generated test file.
Roo will append only scaffolded tests to the test-suite.xhtml file, so you can add additional test files.
Any additional entity will add an entry to the test suite.
In this way, you can do some basic testing of the create method of the form.
But what if you’re not scaffolding, or you want to take it a step further? You have two options: either you can add the additional test to the suite and write it in HTML semantics, or you can use the JUnit framework to generate test cases.
The generated Selenium test submits form data based on legal values from the Bean Validation annotations, clicks the proceed button, and verifies that the next page is displayed.
The test opens an entity creation page, types data on the page, and submits the form.
You can go a step farther and assert that the data submitted by the test is reflected in the new page.
Here’s a variation on the test that checks that the fields are shown in the show view, which is displayed after you submit.
These commands verify that the div with the id specified in @id hold the value in the third table element.
You can use the assertText command to fail the test and stop running further commands, but the verifyText command you’re using marks the test as failed while it continues to run the rest of the commands in the test file.
Figure 9.6 The Selenium IDE editor—note the context-sensitive help in the Reference tab.
The Selenium IDE has full support for editing the commands generated by the tests you created in this chapter.
Fire it up and import your HTML test case into the editor.
You can run the test interactively, debugging and modifying the commands until you have the test you want.
Note: Don’t save it with a preexisting generated test name, or it’ll get overwritten when Roo adds another field to the entity.
You can also use this command to select from an option field, using the data value, not the visible option.
If used with the suffix AndWait, assumes a server call has been made, and waits up to the configured timeout time for a response from the server.a.
Pauses the script until a new page is fully loaded.
Many commands in the HTML Selenese dialect can be suffixed with AndWait.
Consult the Selenium reference guide, experiment with the Selenium IDE, and write your own tests.
If it seems wrong to you to write test code in an HTML or XML markup language because you think, as we do, that code is code, and XML is configuration, you can rest easy.
This means that APIs are available to a wide variety of programmers, and as such makes Selenium a go-to technology for many web testing efforts.
To install your Java Selenium API, add the following dependency to the pom.xml <dependency> section:
The following listing shows the generated code for your sample test, modified so that you can make it consistent with the rest of your application framework.
Your test method contains calls to the selenium object, which communicates with the Selenium server to execute your tests.
Now you can script tests to execute calls to your test web browser, typing data in fields, and clicking various buttons.
You can configure Selenium, and even Jetty, to run your Selenium JUnit tests during the integration test phase of Maven, rather than the unit test phase.
You can even start the Selenium server and Jetty web server when running your integration tests and execute the entire test suite automatically.
This eliminates the need to fire up a Selenium server, and the API is more direct and simplified.
To use the WebDriver API, replace your Maven dependency on the Selenium Java client driver with this:
With this API, you only need to boot the web server, not the Selenium driver.
First, WebDriver has a more fluent, chained API, and second, the web drivers are created and used.
No Selenium server needs to be configured to run WebDriver tests.
You can find out more about the WebDriver at the Selenium project website, http:// seleniumhq.org.
Here are other things you can do to improve your testing and overall code quality:
Install the Maven Reporting plug-in, configuring the Cobertura code coverage report as well as the Surefire Testing report.
These reports, when run with mvn site, can tell you the health of your unit and integration tests, and show you the code coverage of your application.
More information about Maven-based tests can be found in chapter 10 of JUnit in Action, Second Edition, or at the Maven website, http://maven.apache.org.
Configure a continuous integration tool, such as Jenkins (http://jenkins-ci.org), to run your build each time somebody checks in your code.
Look into other code-quality inspection tools that are compatible with Roo and Maven, such as Sonar (http://sonarsource.org)
Above all, your comfort level with changes to your application can only improve as your code coverage increases, because any change that breaks your software will instantly show up when you perform your unit testing and Spring container tests using mvn test and functional tests with Selenium, the Maven Surefire plug-in, and mvn verify.
In this chapter, you’ve learned how to test from a Roo perspective.
You’ve reviewed all of the major testing approaches, from unit tests with stubs, mocks, and Roo’s entity mocking support, to Spring container integration tests, to web testing with Selenium.
Testing is a key part of the development lifecycle, and you’re encouraged to write tests against any of your coded logic.
Let’s look at some other topics you may want to consider.
You should also pay close attention to mock object frameworks.
They’re the best way to isolate your objects under test from other objects.
Pick one mocking framework, as doing so makes it easy to read your tests without having to switch gears constantly.
One chapter can’t convey all of the nuances and issues you’ll face when writing tests against your applications.
You have a number of big topics yet to learn on testing in general.
JUnit in Action, Second Edition (Manning Publications, 2010) is a great guide to unit and integration testing from the ground up, and includes a section on web testing with Selenium and other APIs.
In this chapter, we discuss the integration that the Roo framework provides for email and asynchronous messaging using the Java Message Service (JMS) API.
We review three different use cases to demonstrate how to integrate email notifications.
Roo includes excellent support for several enterprise services as well as Java Enterprise Edition (Java EE) resources such as email and messaging.
Roo also makes it easy to install the various components (configuration files as well as application code) that you need to enable email and messaging functionality in a Java application.
Roo provides the mail commands to set up the three components you’ll need to implement the email notification capability.
Mail sender —This is the Spring Bean configuration for the JavaMailSenderImpl class and the SMTP mail server configuration parameters.
Email template —This is the Spring Bean configuration for the SimpleMailMessage class.
One of the use cases discussed later in this chapter (the course registration wait-list notification) is a good example of a use case that benefits from these advantages, and helps you implement JMS messaging using Roo commands.
In a publish-subscribe, or pub/sub, messaging scenario, a service component posts messages to a topic.
Publishers and subscribers dynamically publish or subscribe to the topic.
The messaging container takes care of distributing the messages arriving from a topic’s multiple publishers to its multiple sub- Publish-subscribe messaging scribers.
Topics retain messages only as long as it takes to distribute them to current subscribSubscriber 1 ers.
In this messaging domain, each message may have one or more message consumers.
If you have experience implementing asynchronous messaging using the JMS API in a Java application, you’ll understand how many different objects you need to create in order to send a simple message.
The steps include the following JMS constructs: connection factories, destinations, connections, sessions, message producers, and message consumers or listeners (for receiving messages)
Roo makes it easier to create all these messaging components by running just a few commands without having to write a lot of Java code or XML configuration..
This application will include different use cases that use the asynchronous messaging paradigm.
The business use cases for email and messaging services discussed in this chapter include course catalog distribution and course registration confirmation notification.
The course catalog distribution use case involves publishing course catalog updates to a JMS topic, which trading partners subscribe to to get course updates.
These trading partners can include institutions such as schools, community organizations, or other vendors.
The course registration confirmation notification use case uses email and a JMS queue to notify customers who have successfully registered for a specific course.
Setting up JMS in the Course Manager 247 (the two we discussed previously and a third called the course registration wait-list notification use case) that use email functionality and asynchronous messaging to implement the business requirements.
Asynchronous messaging uses JMS technology and covers both the pub/sub and PTP messaging scenarios.
The Course Manager application will broadcast the course catalog updates by posting a course catalog message to a JMS topic.
Then the trading partners who subscribe to this topic will receive the message to process it and update their information systems.
Roo uses the ActiveMQ messaging container as the default JMS provider.
Let’s look more closely at each of these three use cases and implement them using Roo commands so you can see how the Roo framework supports enterprise services like email notification and asynchronous messaging.
Your first step is to implement the course catalog distribution use case.
In this section, you’ll create all of the messaging components needed for the use case.
The process flow diagram for the course catalog distribution use case is shown in figure 10.3
You’ll use Roo commands to create the JMS topic and the other messaging components needed to implement this use case.
The first step to enabling JMS capability is to install a JMS provider in your Roo project.
Similar to the persistence setup command, the jms setup command requires you to specify the provider details such as the JMS provider type (a required argument), the destinationType (an optional argument; specify QUEUE or TOPIC), and the destinationName (also an optional argument)
The following example shows the console output for this command:
In the previous example Roo added dependencies to the Maven build file (pom.xml)
These dependencies are required to implement the JMS-related code in your application.
The XBean library E included in the Maven application build file in the previous listing allows you to run the ActiveMQ messaging broker by referencing an XML configuration file located in the classpath.
The XBean URI points to an XML document, which can be parsed via the XBean API.
Note that the previous configuration file uses the ActiveMQ namespace (amq) B, which simplifies the configuration syntax for defining the JMS components.
The ActiveMQ messaging broker D and the JMS connection factory E beans are used to configure the infrastructure details of the JMS container.
Listing 10.2 The Spring context configuration file with JMS components.
In the next section you’ll see how Spring’s JMS template G works.
The JMS template field and a new method called sendMessage have been added to the controller class, as shown in the following code.
In the previous code example, the new variable jmsTemplate B is used for injecting the instance of JmsTemplate into the controller class.
The sendMessage method C is where you add your custom business logic for posting the message into the JMS destination (topic)
The third step in the JMS setup is to create a JMS consumer class.
You’ll use the command jms listener class for this step.
The command takes three parameters: class (mandatory parameter to specify the name of the class to create the JMS listener), destinationName to specify the name of the destination (default value for this parameter is myDestination), and destinationType,  which is used to define the type of the destination (default is QUEUE)
Type in the following command specifying the custom names you want for your JMS components:
The Spring JMS module makes it easier to expose a POJO as a message-driven component C with the help of the JMS listener container B component.
You’ll also need to launch the application, navigate to the home page, update the course catalog, and publish it.
All of these steps take time, which could impact your development time and progress.
So, in the spirit of agile software development and unit testing, you’ll create few test client classes to make your job easier and your testing faster.
You’ll post the message to the JMS topic using Spring’s JMS template class in the test client.
This gives you an easy way to publish and intercept the events that you can use to unit test the JMS functionality from within the IDE, without having to build and deploy the web application to the container.
That’s all of the steps required to enable the publish-subscribe messaging feature for the course catalog distribution use case.
We’ll come back to the point-to-point messaging domain later in the chapter, but next we’ll look at how to integrate the email notification feature in a Roo application.
This is covered in the following section as part of the course registration confirmation notification use case.
Listing 10.5 JUnit test class for testing course catalog distribution event.
There are three main steps to implement the course registration confirmation notification use case, which we’ll cover in detail in the following section.
These steps include defining the SMTP server configuration, the email message template, and the email template attribute.
Similar to the JMS configuration, the main steps to enable the SMTP configuration using Roo mail commands include setting up the SMTP server and email message template, and adding the mail template attribute in a Java class (usually controller or service)
For your sample application, you’ll also create a custom Java class to encapsulate the email processing application logic so any class in the application can use this helper class for the notification requirements, without having to duplicate the same logic in multiple classes.
The next few sections show the different mail commands you’ll use to enable the email feature in your sample application.
Before you set up the email configuration, you need to create an interface and an implementation class for encapsulating the email processing logic to decouple it from the application logic.
The Roo shell supports creating new Java interfaces or classes from the command line using interface or class commands, respectively.
The email sender setup command installs Spring’s JavaMailSender in this project.
This command takes several parameters with the information required to configure the Spring bean configuration for the JavaMailSenderImpl class.
Here’s a list of these parameters and what information they provide to the command.
To set up the SMTP server configuration, use the following command:
In a real-world application, you should define the SMTP server as a JNDI resource.
For example, to configure an SMTP session as a JNDI object in a Tomcat container, you’d add a new Resource element in the configuration to Tomcat’s context.xml file.
The previous configuration will create a new SMTP resource in the Tomcat container and will be available for all web applications running on the servlet container.
This configuration is straightforward, but let’s look at how to view and modify the SMTP properties in the file generated by Roo.
The output of this command is shown in the following example:
You can do this by using the properties command with the set argument.
It shows the following message, which says that the properties file has been updated:
After you’ve modified the SMTP properties to fit your application requirements, you’re ready to create the SMTP message template.
You need to create the email template that the Spring framework will use to send the email messages.
The command email template setup configures a template for the SimpleMailMessage class using two parameters: from and subject.
This command adds the following two additional properties to the email.properties file:
This class has the attributes for the SMTP mail server B and Spring’s MailMessage implementation class C to abstract the email send logic.
You can now run the Eclipse command, perform eclipse, to refresh the project contents so the Roo project is refreshed with all of the code and configuration changes you’ve made so far.
You’ll create a test client class similar to the way you tested the JMS functionality to verify the registration notification functionality.
Now that we’ve covered the first two use cases in the Course Manager sample application, you know how to enable the JMS (pub/sub) and email features in Roo applications.
Let’s look at the step-by-step details for implementing point-to-point asynchronous messaging, which involves a queue (as opposed to a topic)
The course registration wait-list notification use case involves asynchronous messaging, where the main business process stops when a customer’s registration request is placed on the waiting list.
The program then notifies the first customer on the waiting list that there’s an open spot in the course and their registration has now been confirmed.
Let’s look at how you would implement this use case in a Roo application.
You’ll use the same JMS provider (ActiveMQ messaging server) you created in that use case and create a message queue on that JMS container.
This use case requires three steps, which include creating a new message queue, a JMS template, and a message listener class.
Listing 10.10 JUnit test class for course registration confirmation notification.
The first step in the JMS configuration for this use case is to create a message queue that will be used to post the course registration wait-list notification details.
The message queue configuration step adds a new amq:queue Spring bean in the JMS Spring configuration file.
Now for the final step: you need to add a listener class that acts as an asynchronous message consumer.
The following is the Roo command for the message listener configuration:
With the configuration steps complete, you’re now ready to test the new Java classes and configuration changes for the course registration wait-list notification use case.
Listing 10.11 JUnit test class for course registration wait-list notification.
Another good case for using JMS messaging is the certificate completion use case.
Let’s say the Course Manager application organization outsources the process of printing the course completion certificates and mailing them to the students.
This allows the course completion certificate with the student's information to be generated and sent to the student.
This is why it’s important to monitor these JMS components to see what’s going on behind the scenes of the application to be able to respond to any production problems and troubleshoot the messagingrelated issues.
This is what we’ll look at in the next section on how to monitor the Course Manager application using tools like VisualVM.
Now that you’ve implemented all of the use cases, let’s look at how to monitor your application to ensure that the various JMS resources you’ve installed and configured (JMS container, JMS topic, and JMS queue) are up and running, as well as how many messages they’re processing.
To turn on the monitoring capability in the ActiveMQ messaging broker, you’ll use the useJmx parameter (with a value of true) in the amq:broker element.
After you’ve enabled the JMX feature in the ActiveMQ broker, you can use a JMX client to monitor the messaging activity in the application in a server runtime environment.
The VisualVM tool comes bundled with the JDK installation, with the jvisualvm and jconsole executable files located in the%JAVA_HOME%/bin directory.
Note that JAVA_HOME is the folder where you installed JDK on your machine.
The JConsole module in VisualVM can be used for monitoring the MBean components.
Open a new command prompt and run the following commands to launch the VisualVM tool:
Figure 10.5 shows the MBean screen in the JConsole JMX client tool.
Another monitoring tool you can use in nonproduction environments is the new.
Figure 10.5 Messaging activity details using the JConsole JMX client.
Spring Insight provides a graphical look at an application's performance, responsetime charts, and histograms, providing developers with a dashboard view into the application's runtime environment to find where it’s spending most of its time in the program flow.
Spring Insight uses the AspectJ load-time weaving feature to add the tracing and monitoring statistics to web applications.
This means your sample application doesn’t require any additional code or configuration changes to use Spring Insight.
Also, Spring Insight collects the response data in memory and doesn’t require a backend database or a persistent data store.
If you’re using the STS tool, you already have Spring Insight available for you to monitor your application's performance and other server metrics.
At the time of this writing, Spring Insight doesn’t have a plug-in for JMS, but it’s on the feature list to be added in a future release.
You can still see the components that were triggered by a JMS message.
Let’s use the Spring Insight tool to monitor the activity in your application, including JMS messaging activity.
Open a web browser and navigate to the Spring Insight dashboard page using the previously mentioned URL.
Click on the Browse Resources tab and expand the web application node in the Resources pane under the application’s root node.
You’ve also learned how to implement asynchronous messaging for business use cases that require offline processing capability, such as the course catalog distribution and the course registration wait-list notification use cases.
You were able to do this by leveraging another Roo add-on, the JMS add-on, provided by the Roo framework.
In this and the next chapter, we explain how to install existing Roo add-ons from the central Roo add-on repository.
Then we show you how to write and install your own add-ons, beginning with the somewhat confusingly named simple add-on.
Finally, we discuss the advanced add-on and related infrastructure features woven into Roo.
When you write Spring Roo applications you use a modular add-on architecture.
Many of the core Roo components were written as add-ons, including the entity and field management commands, interactions with Maven, Java toString() and JavaBean method constructions, Spring MVC configurations, email, JMS, and more.
Without further ado, let’s roll up our sleeves and dig into Roo add-ons.
Roo was designed from the ground up to be extremely extensible.
All of the Roo features we discuss in this book are interrelated modules known as add-ons.
Each add-on can define a set of Roo commands, manipulate project configurations, and listen for changes in the file system, such as the addition or removal of a @RooToString annotation.
Add-ons provide features in the form of specific shell commands.
The downloaded file contains a list of all Roo add-ons registered with Roo-bot, a service available to Roo developers that exposes published add-ons to all Roo users.
We’ll experiment with this directory, and we’ll start by learning how to search for add-ons; then we’ll install and test an add-on; and, finally, we’ll remove an add-on.
The key thing to remember is that, unlike Grails or Rails, where the add-on is used at runtime, our add-ons are merely Roo shell extensions.
After we compile the project code, all effects of the add-on will result in standard Java EE code and web artifacts.
JasperReport support you give to the project the feature of.
These add-ons must be approved by the Roo team to gain the T code.
If an addon has more documentation, you can expand the number of rows to read the result.
Use this option to force a reload of the list.
You can also use the search command to locate a specific add-on.
The --requiresCommand option searches for the commands provided by the add-on:
More than one way to install a Roo add-on There are four ways to install an add-on to your Roo configuration:
Use the addon install command to install it from the central Roo add-on repository.
Use the osgi start command to install add-ons from a URL or a file.
You’ll use this technique later in this chapter when you write your own add-ons.
Use the osgi obr repository commands to mount an OSGi repository and install the add-on from that repository.
Useful in a corporate environment where your team needs to share company-wide add-ons.
Copy the add-on JAR file to the Roo installation’s bundles directory.
We discuss the osgi start and osgi obr commands in the next chapter.
The report format is a bit basic, but we hope to soon see an add-on portal website that displays this information in a more useful way.
The Roo add-on system is a great way to find and experiment with published and contributed add-ons.
You can also install your own add-on to this repository, further contributing to the Roo platform.
Now that you’ve learned how to search for add-ons, it’s time to install one and experiment.
The first is to use the search ID of a previously executed search:
The second is to use the bundle symbolic name, abbreviated as BSN in the previous addon info command:
This method works well when you’re putting together Roo script files for your developers to use in the future, and don’t want to rely on a search result ID.
It's time to use your add-on to set up a git repository.
You can check your shell to see the new command by hitting [TAB]:
Now the git command appears alongside the rest of the Roo shell commands.
You can set up a Git repository from a Roo project.
This command will issue a git init command in your project directory, if needed, and otherwise use your existing Git configuration.
It will then issue a git commit to record the change you’ve made.
Now, any change you make to your project configuration in the Roo shell will be followed by a commit to the Git repository:
You can also force a commit right from the shell:
There are more features of this add-on, so consult your addon info output and experiment.
You can use the addon upgrade command to search for and automatically install upgrades to Roo add-ons:
You’ll also lose any additional add-ons you’ve installed previously, so it’s a good idea to store your third-party add-on installation scripts in your version control system and update them whenever you add a new approved add-on.
By default, the upgrade engine searches for any version, including releases, release candidates, and milestone releases.
You can customize this, for example, by limiting to only release-level add-ons:
Or you can list only available add-ons for your Roo shell release level:
No add-ons / components are available for upgrade for level: RELEASE.
This setting is stored between restarts, so if you want to experiment, make sure to reset it before searching for upgrades.
You can permanently trust the keyholder of this key by issuing the pgp trust command:
This command, unlike pgp automatic trust, is a permanent decision and is kept within Roo’s configuration.
If you upgrade to a new version of Roo, you may have to redo your trust relationships.
This command is tabcompletion aware, so if you aren’t sure which add-on you want to remove, keep hitting [TAB] to autocomplete the bundleSymbolicName command-line property:
But nothing will keep it up to date, so you may want to use push-in refactoring to put the code under developer control again.
As the add-on developer, you may wish to provide a remove command so that you can clean up after yourself before developers uninstall your add-on.
This command removes the artifact from the Roo installation’s bundle cache directory.
We’ll begin this investigation of OSGi with a little terminology.
OSGi bundles are JAR, WAR, or EAR files that contain a special file, META-INF/ MANIFEST.MF, with some well-defined headers.
To see these headers, open a Roo shell and type in.
You’ll see a ton of output, broken up into sections by information about each bundle.
Here’s an excerpt of the contents of Roo’s entity OSGi bundle:
OSGi components export certain Java packages, using the Export-Package header.
They also require other packages to function, as detailed by the Import-Package header.
You’ll refer to the symbolic name wherever Roo asks you for a bundle’s ID.
All valid Felix command activities are valid here as well.
Keep in mind that you’re using OSGi only to expose and use components, so the utility of this command is limited.
OSGi bundles go through several lifecycle phases, including resolved, installed, started, and stopped.
You’ll learn how to use these commands when you create an OSGi bundle.
You can use the osgi ps shell command to show the status of the bundles and add-ons installed in the container.
Each OSGi bundle is listed in the previous output, along with an ID, state, starting level, and name.
You can install any OSGi JAR file, and you may need to if your Roo shell commands have to interact with a Java library that’s not already installed in your Roo shell, such as a JDBC driver.
If you’d rather update it from the latest source file, use osgi update, and tell it which bundle and what location to reload it from:
It’s easier to load and start in one step with osgi start.
If you accidentally installed a bundle using the install variant, you can start it by issuing the osgi start command.
Roo lets you create your own add-ons, using projects built using the Roo shell addon create command.
Table 11.1 outlines the differences between them, and their pros and cons.
Roo wrapper add-ons Table 11.1 Roo add-ons: using the addon create command (continued)
Watches code for changes and reacts when annotations are added or deleted.
Installs features needed by other plugins, such as a database driver for the reverse engineering add-on.
Command can also pull in transitory dependencies with some adjustments to the Maven POM file.
If you’re installing a Roo shell command that needs a feature in a Java library, such as a JDBC driver or an email service provider, this is the one option for installing the library.
All four add-on types will be covered in this two-chapter series.
In this chapter, we’ll get you started by covering how to wrap a standard JAR and provide it to the Roo shell using the OSGi wrapper add-on.
We’ll create an i18n add-on to provide a Norwegian translation of the Roo scaffold labels.
Then we’ll build a simple add-on that installs jQuery, jQuery UI, and some replacement tags in the Roo tag library.
Finally, in the next chapter, we’ll branch out and create an add-on to provide access to the CoffeeScript language, which we’ll use to simplify some of the JavaScript files.
A wrapper add-on takes a given Maven artifact and wraps it with the proper OSGi MANIFEST.MF entries, delivering it as a new JAR to be used by the Roo shell.
The JAR may then be started as an OSGi bundle with osgi start and accessed by other Roo add-ons.
For example, to wrap the Apache math library, you can search for the proper Maven artifact information on http://search.maven.org, as shown in figure 11.1
In our search, we found version 2.2 of Apache’s commons-math and will use it to construct our wrapper class.
Roo creates a new project that you can use to build your add-on.
The final artifact name will be the provided topLevelPackage parameter, coupled with the artifactId and version parameters, plus “.0001.” Now, you’ll create the wrapper artifact.
You can now install this bundle into the Roo shell:
In this example, Roo was able to look up the flag for Norway using a web service and download the norway.png file itself.
For unknown flags, you’ll have to find a legally distributable flag image, convert it to PNG format with a size of 16-by-11 pixels, and place it in the project root directory.
To use your add-on, switch back to your web project and issue this Roo command:
Before you create your own language add-on, use the public add-on searching feature to see if someone else has already provided one.
Many developers have embraced the more widely adopted jQuery library and a wide variety of components contained within it.
The Dojo form library poses a challenge for these developers, because it chooses both a JavaScript library and a widget library for them.
All of these tasks can be accomplished easily using a Roo add-on.
You can create an add-on project to hold your customizations and test them with a simple MVC project.
A commands class, JqueryuiCommands, which implements the CommandMarker interface and defines the commands exposed by the add-on.
A set of tags, located in the src/main/resources directory, for potential inclusion into the consuming project.
A legal license agreement file, which you can replace with the license your project will use.
An assembly.xml file, which provides the ability to package the entire project, including dependencies, into a zip file.
You’ll need to customize these files for your purposes, so that you install the proper commands to set up the add-on.
Now, take a moment to define your goals for the add-on.
After executing these commands, developers can use the jQuery and jQuery UI JavaScript libraries in their applications.
Let’s start by defining the operations that the add-on will perform.
When building this class, let your IDE find the imports for you to save time.
Your add-on operations class is an OSGi service, which makes it visible to Roo for inclusion into the system.
The class now extends AbstractOperations B, a helpful abstract class that provides some project management facilities.
You also injected references to two Roo OSGi services: instances of ProjectOperations and PathResolver, which you’ll use to access components that change your project configuration C.
Unless you have to add a class or a library to the Roo runtime path, such as a JDBC driver, you won’t need to restart after installing new Roo add-ons.
Let’s build the first Roo add-on command method—the one that installs jQuery itself.
You’ll use the pathResolver you set up at the top of your class to find the absolute path to the web application’s / js directory.
It uses Roo’s FileManager component to perform the copy operation.
You’ll need to download the jQuery library from http://jquery.org and place it in the previously mentioned directory for this to work.
This component has visibility into the currently running Roo shell, which gives you the proper OS path to the file.
This class will not compile yet; you must define a helper method next, buildAndAddJSNode, to install your JavaScript tags.
Next, you need to edit the load-script.tagx JSPX tag file, and use the HTML <script> tag to install the command.
You loaded the XML source for this file into a DOM Document instance in the previous installjQueryApi() method.
You’ll add a new <script> tag to the end of the document, which you access via the document’s DOM method getFirstChild()
This method emits the following tags to the end of the script tag file:
But there’s one more task for this command—defining whether it’s available or not at the time the user hits [TAB]
Each time someone uses tab completion, or the Roo shell changes the configuration in some way, all Roo components are asked whether their commands are available.
The add-on can conditionally expose their commands and hide them when they don’t make sense, such as when trying to add a web feature before the web framework is installed.
Now, if the shell user has installed jQuery before, the script file will be available in the ‘js’ directory of the web application, so it should return false.
Otherwise, it should return true, which will allow the command to become visible in the shell.
Now let’s look at the second level of JavaScript enhancements: installing the jQuery UI.
Some developers are happy working with Dojo for their user interface widgets, but they want jQuery for other purposes.
Others may want it all and will choose to install both.
You’ll configure another command, jquery UI setup, to install the UI library as well as assets such as stylesheets and graphics.
First, you’ll detect whether you’re able to install the command itself.
You have to check whether the application is a web application and then verify that you’ve installed the jQuery library itself.
This is a variant of the check for jQuery in section 11.8.6 earlier in this chapter:
You also need to add another helper method to this class—one that adds a CSS node to the load-script.tagx file:
You need to take one more step: you have to tell the Roo shell that these commands exist.
To make your commands visible to the shell, you need to define your add-on to the Roo shell system.
But your class will be bloated with methods for both types of operations, so unless the add-on is small, we recommend you separate the implementation of the add-on from exposure to commands by the add-on.
You’ll install your add-on and put it through its paces next.
Let’s take a look at the relevant sections in the pom.xml file:
For example, to exclude the export of org.w3c.dom from your add-on so that it doesn’t get installed in the container automatically, change the bundle to use the Export-Package tag:
This becomes important in more complex add-ons, because the Roo shell will take BND’s defaults and export all packages found in the source code.
To install your add-on, you’ll use the osgi start command:
You can verify the installation by using the osgi ps command; your add-on will appear at the bottom of the list:
You’ll also see your add-on in the [TAB] completion in the Roo shell, because it exposes the jquery commands.
Now for the piece de resistance: you’ll need to define a new application and install the add-on in the Roo shell for your jquery commands to appear.
You’ll start by creating a jqueryui-test Roo application: $ mkdir jqueryui-test.
Finally, tell the shell to set up your jQuery API and jQuery UI library:
You’ll see that jQuery and jQuery UI JavaScript entries have been added, and that the jQuery UI theme stylesheet has been mounted.
Your add-on worked, and it not only installed jQuery support, it also reconfigured the application to support it.
Let’s modify a tag in the generated Roo tag libraries to use a jQuery UI widget, instead of a Dojo one.
Replace the DIV section and the Dojo install script with the following code:
The elegance of jQuery is evident here: the $ method on the next line selects the DIV in the previous example by its id, and then applies the jQuery UI accordion function to it, which styles the component with a border.
For example, using the previous technique, you could replace all of the Roo standard tags with jQuery UI widgets, or even install other commands to provide and use other jQuery plug-ins.
You could then install those tags with a separate Roo shell command, such as the jquery tags setup.
In the next chapter, we’ll show you how to write advanced add-ons.
We’ll build an add-on to install the CoffeeScript language into your Maven build, and show you how to install it using an OSGi Bundle Repository and the Roo add-on service.
In this chapter, we’ll take a look at how to build advanced Roo add-ons.
We’ll delve into Roo’s key infrastructure beans such as the fileManager and projectOperations components, how to accept parameters, and how to register for and react to changes in class definitions.
We’ll wrap up by showing you how to deploy your add-on to the Roo add-on repository, also known as the RooBot.
Let’s begin by learning how to create an advanced add-on.
The advanced add-on template generates a few other key files:
You create the assembly by issuing the mvn assembly :assemble command.
This metadata can add and remove methods and properties from classes and generate ITDs.
With the advanced add-on, you can manipulate your entire project.
Let’s dive in and create an advanced add-on right now—one that will enable a feature to simplify your JavaScript programming.
Billed as a cross-compiler, CoffeeScript takes this simple language and turns it into a more complex JavaScript equivalent.
Don’t let the name fool you; building an advanced add-on isn’t as hard as it seems, especially if what you’re looking to do is configure additional Maven artifacts and plug-ins.
That’s all you have to do to install CoffeeScript, so let’s go.
For example, a data grid loading function in the Dojo JavaScript Toolkit API, which Roo uses to decorate standard HTML controls with client-side validation and rich internet features, may look something like this:
There are CoffeeScript compilers and interpreters available for a wide variety of languages, including a Maven plug-in.
Getting interested? Then let’s set up an add-on that installs a Maven CoffeeScript compiler plug-in into your application.
To create your add-on, you’ll use the advanced add-on creation command.
You’ll define two add-on shell commands: coffeescript setup and coffeescript remove, which will add and remove the Maven CoffeeScript compiler to your project.
Next, let’s define the Maven configuration setting changes so you can tell the add-on how to install the Maven CoffeeScript compiler.
The format is arbitrary; you fetch what you want using an XML parser.
Replace the contents of this file with the Maven plug-in definition, as shown in the next listing.
Maven users will immediately recognize the plugin instruction, which is how Maven installs additional build features.
This method will parse your XML configuration file and feed the defined plug-ins to your Roo add-on for addition to your pom.xml file.
This automatically turns the XML DOM Element into a form that the projectOperations instance can accept.
This makes managing the plug-in more flexible for more work in the future.
One final step remains before you can make the add-on run—defining your commands to the Roo shell.
This option is then sent to the operation method for use by your add-on code.
Note that you can specify a default value if the option isn’t passed, and hints for correct options such as true and false.
Although you could finish out the add-on implementation, let’s first take it for a spin.
You’ll build your add-on, install it in the Roo shell, and test it with a sample project.
To build your add-on, you drop to the command line and issue a Maven command:
To install the add-on, use the same osgi start command you used with the simple add-on (the ellipsis [...] represents the full path to the JAR file):
YOU’RE NOT INSTALLING THE ADD-ON FOR A SINGLE PROJECT Unlike a lot of other frameworks, Roo holds the add-ons within the shell itself, rather than at the project level.
Because your add-on adds commands to the Roo shell itself, the installation needs to occur at that level.
Once you use an add-on, you benefit from the operations it performs, regardless of the project you’re working on.
If an add-on misbehaves, you’ll need to remove it from the entire Roo shell using osgi uninstall.
If the start command worked, hit [TAB] and you should see both the coffeescript setup and coffeescript remove commands in your tab completion list.
Now, create an empty project directory, such as test-coffeescript, and fire up the Roo shell.
When inside the shell, create a simple project with a web application.
If you search for the coffee-mavenplugin entry, you’ll find your plugin definition, complete from the configuration .xml file.
You can test the plug-in with a simple CoffeeScript script.
To build and test your application from the operating system prompt, execute.
Next, start your Jetty web server to test the script:
Use your browser’s View Source command to view the script.
The more advanced Mavenites among this book’s readers will quickly begin to customize the plug-in, including adding steps to attach the coffee goal to a Maven lifecycle step, such as prepare-resources.
Now, let’s wrap up this section by adding implementations of the script detection methods and the removal command.
This is the inverse of the add command, so you’ll refactor, extracting the common code, and adding or removing the plug-ins based on the operation.
You can review the refactored code in the following listing.
Build the add-on using mvn package and then run the Roo shell osgi update command to replace the currently installed CoffeeScript add-on:
The command takes a bundleSymbolicName to reference the installed add-on, which is defined from the Maven artifactId of the CoffeeScript add-on’s pom.xml file.
To create an advanced add-on, you need Coffee(Script) Finally, try to issue the CoffeeScript remove method.
If it works, you’ll see that the pom.xml file no longer contains the CoffeeScript plug-in.
Experiment with your own add-on and see what additional features you might provide.
You need to provide commands that manipulate the visibility of your commands.
To find out what project type is attempting to access the coffeescript setup command, the isProjectWar() method fetches the web.xml file path for your project.
You then check whether this file exists, which would confirm that the project is a WAR.
You’ll express the next operation (checking that the CoffeeScript Maven plug-in is not installed) as a positive-logic check.
You need to ask the projectOperations object for all installed Maven plug-ins and iterate through them, looking for a hit B.
You also need to inject another support class, the FileManager, which you can do via another class-level member variable:
This step will only allow access to the command if the project is a WAR, and if the addon isn’t installed.
You also protect the command from appearing if the Roo shell hasn’t created a project yet.
Again, you don’t allow access to the command unless you’re working within a defined Roo project, and the project has to be set up as a WAR.
In addition, the project must contain an installed Maven CoffeeScript plug-in, so that you can then remove it.
Update your add-on, and remember the command to update it is osgi update:
Experiment with tab completion in your test project—if the add-on is already installed, you’ll see only the coffeescript remove command.
Conversely, if it’s not yet installed, you’ll see only the coffeescript setup command.
You’ll see the plug-in added and removed each time you run the relevant command.
Now we'll review some of the services and beans made available to add-on developers.
Key add-on beans and services 307 To get the most from your add-on system, you have to learn each of the OSGi services that Roo provides.
The following section details some of the major services and some snippets that you can experiment with in your own add-ons.
You can use the ProjectOperations service to manipulate your project in a number of ways.
Let's start by reviewing the ones that affect your Maven build.
Maven resources (properties files, XML descriptors, and the like): addResource(String moduleName, Resource resource)
There are more commands you can issues as well, although you need to cast to a more specific type of ProjectOperations to do so.
You could also create a project on your own within your add-on, potentially using a separate configuration:
You can also execute any valid Maven command with executeMvnCommand (String)
The PathResolver is a service that properly accesses your project files for you.
It provides complete file paths for your root project and any modules associated with it.
You can use the resolver to fetch various file path roots:
This would equate to the file path on your file system for the src/main/webapp and src/main/java directories of your currently focused module.
This points to the index file at the root of your web application.
You used the FileManager to copy files in chapter 11, so it's not completely foreign to you.
You can gain access to it from your ProjectOperations instance using injection as well: @Reference private FileManager fileManager;
The FileManager is a transactional engine that writes files after an add-on task has been committed.
If any RuntimeException is thrown, such as one thrown by the Apache commons-lang3 project's Validate annotation, the writes for all files manipulated via this manager won’t be performed.
As in chapter 11, you can also use it indirectly.
You'll also notice the use of the pathResolver in this fragment.
Let's put this together with a simple file writing example.
Let's say you want to create a new JavaScript file in the project's src/main/webapp/js directory:
You'll use the pathResolver to look up the proper path for the /js/myscript.js file within the webapp directory.
Then, instead of creating a standard Java file structure and writing to it directly, you ask the fileManager to create a reference to a mutable file, which is a virtual buffer for the file you wish to write.
You then write your information to the file and use the Apache Commons IOUtils class’s closeQuietly() method to properly close the file.
It waits until the Roo shell command that issued the changes completes, and then tells the file manager to write all of the file create, update, and delete operations at once.
While not 100% fail-safe, it will generally stop an add-on from half-modifying a given file.
You’re only scratching the surface of the key services and beans provided by Roo.
We haven’t even discussed the ITD services and type system, and unfortunately, space doesn’t allow it here.
We could write an entire book on Roo add-ons, so stay tuned for that.
Because the framework is under heavy refactoring for version 1.2, we decided that documenting the internal Roo services wouldn’t be useful at this time.
The team also removed their own Assert class in 1.2.1, replacing it with the Apache Commons Lang project's Verify method.
When you’ve finished writing your add-on, and you’ve tested it  with your team,  it’s time to publish it.
Roo gives you several options: the manual installation via a URL, deployment to a Maven repository as part of an OBR repository, and indexing with the SpringSource RooBot as part of the public Roo add-on repository.
Table 12.1 shows the approaches and their respective pros and cons.
Distribute the binary JAR file through a web download or other means.
Developers can use the osgi install command to install it.
Developers need to know URLs for each add-on you provide.
Contribute your add-on to the Roo add-on repository list as a publicly available add-on.
Contributes to the Roo add-on community and enriches Roo developers.
Let’s take a look at each of these approaches in detail.
Because you don’t use a key signing process to authenticate these add-ons, they should only be installed this way for development purposes, or inside your own organization.
Table 12.2 summarizes the commands used to publish and consume the add-on.
Shows the headers for all bundles, or a selected bundle.
You learned about using the OSGi commands osgi start and osgi uninstall during your jQueryUI add-on installation in chapter 11, so we can skip that technique and move on to deploying artifacts to an OBR Repository.
Remember, all Roo add-ons are OSGi bundles, so these commands will come in handy on a regular basis.
You’re probably thinking, “What’s an OBR?” It stands for OSGi Bundle Repository, which is a standard format for defining a collection of OSGi artifacts on a central server.
This file contains entries for all resources provided by the repository.
Let’s deploy your CoffeeScript Roo add-on to an OBR on the Google Code project hosting service.
To sign your OBR bundle, you’ll first need to set up a secure key, known as a PGP key pair.
An open source tool exists to do this: GPG, which stands for GnuPG.
When configured, you create a new public/private keypair using the gpg command:
After you’ve generated your keypair, write down your passphrase; you’ll need it every time you configure another machine.
You’ll also need to set the default passphrase when running the Maven build, and possibly your default GPG key.
To do this, you’ll create or edit a file named ~/.m2/ settings.xml.
The ‘~’ symbol refers to your home directory, which we’re referencing in Unix format.
Useful when deployment has failed due to an unexpected problem, such as a missing dependency or Java package.
The profile you installed, with the id of gpg, adds a property named gpg.passphrase.
You activate it using the activeProfiles tag, which turns the profile on by default.
To list your keys, you can use the gpg --list-keys command.
The results we saw on Ken's system were as follows:
Each time you release an update to your add-on, you'll need to upload a build to a source code repository.
You can choose any cloud-based hosting provider as long as pubic viewing of files is available.
You’ll need to follow the sign-up instructions, and you can choose between SVN and GIT hosting models.
As an alternative to this process, you can create a public repository on GitHub.
Next, you have to supply the proper SVN URL settings in the Maven pom.xml file.
First, we edited the <scm> section to set the Maven connection and URL variables:
Finally, we edited the Maven settings.xml file again (in ~/.m2) to add our credentials for the Google Code server:
After making these changes, you’re ready to develop and release your add-on.
During development, point your add-on developer team to the source tree and let them work with it using standard Subversion (or Git if you choose) commands.
At some point in the cycle, you’ll be ready to release your add-on.
The release of an add-on is generally performed by a designated member of the team.
This member will coordinate all check-ins, ensure that all unit and integration tests run properly, perform tests by installing and using the add-on, and ensure that none of the artifacts used by the Maven POM of the add-on are using unreleased (snapshot) versions of the libraries referenced.
You should read the Maven documentation on the plug-in for the most up-to-date details, but the general process involves two steps:
The release prepare process asks for three pieces of information: the name of the release version, the SCM tag for the release, and the new development version of the project (including the version of the release to deploy, the label to use for the release in the version control tag, and the next development version):
After answering these questions, Maven will build the code, tag the release with the release tag, and commit the tag to the version control system.
This marks the time of the release so that you can then perform the release itself:
Maven checks out the code tagged by the release:prepare step, which was tagged at the time the development coordinator felt the team was ready to release the code:
It also writes a pom.xml file in the release directory:
The repository has both signatures as well as copies of the artifacts, as shown in figure 12.1
Now you’ve got an official release, deployed on a Maven repository, which is OBRenabled.
To use this repository, you can use the osgi obr commands to attach to the OBR and install an add-on from it.
You will install the add-on for the Roo shell, not for a specific project.
And to start the add-on, we have the bonus feature of [TAB] completion:
The fun part is having to trust your own Roo encryption key before you install the add-on.
Now is a good time to refer back to the trust section in chapter 11 and install your key.
The key OSGi OBR commands are shown in table 12.3
Now that you’ve seen how to build, sign, upload, and release your OBR-based.
Roo add-on, it’s time to consider ‘going public’ and publishing it to the Roo central repository.
Shows all add-ons, optionally matching the text in the keywords option.
Use this when checking for updated versions of your add-on.
Using a GMail client, the email you send would look something like figure 12.2
After you send this email, the RooBot will wake up and process the request.
This URL may change in the future if the add-on submission procedure is adjusted.
If you get no messages in this URL, don't worry.
Try restarting the Roo shell, and use the add-on search command:
Now you can install it, provided you’ve removed the prior version with osgi uninstall.
Add-ons are a complex topic, worthy of their own book.
We suggest that add-on developers learn the basics of OSGi bundle development, get cozy with the stock Felix shell, understand as much as they can about the OBR and SCR technologies, and above all, read other add-on code, particularly the built-in Roo add-ons from the Roo source tree.
As the add-on framework continues to evolve and becomes more useful.
The following books and articles may be useful to you as you continue your journey.
In this final part of the book, we show you how to deploy Roo applications in the cloud where your application will run on a third-party hosting provider.
Cloud computing solutions offer flexibility in deploying applications without requiring any internal server infrastructure.
In this chapter, you’ll learn how to package and deploy the sample Roo application to an external hosting service using a new web application deployment paradigm called cloud computing (CC)
We’ll discuss this new paradigm and the cloud service offering from VMware1 called Cloud Foundry.
Roo includes an add-on component for Cloud Foundry to help developers with the tasks of deploying Roo applications to the cloud.
We’ll show you how to configure and deploy your Roo applications using the Cloud Foundry add-on.
Why are organizations turning to cloud computing? Scalability (for scaling up as well as down on demand) is one reason.
Another is that using cloud computing means no equipment, maintenance, or operational costs.
The parent company of the SpringSource team who created the Spring Roo framework.
In the previous two chapters, you learned how to write and install custom Roo addon components, both simple and advanced add-on types.
There are three types of service models in cloud computing.
The infrastructure as a service (IaaS) model helps organizations to outsource the.
The National Institute of Standards and Technology (NIST) defines2 cloud computing as follows:
Cloud computing as a model for enabling ubiquitous, convenient, on-demand network access to a shared pool of configurable computing resources (for example, networks, servers, storage, applications, and services) that can be rapidly provisioned and released with minimal management effort or service provider interaction.
This cloud model promotes availability and is composed of five essential characteristics, three service models, and four deployment models.
For more information on these characteristics refer to NIST Special Publication 800-145 that defines cloud computing and describes the different cloud computing models.
What is cloud computing? NIST defines the platform as a service model as follows:
The capability provided to the consumer is to deploy onto the cloud infrastructure.
Several PaaS cloud providers can deploy Java-based web applications to the cloud infrastructure, including Heroku, CloudBees, and Cloud Foundry.
Cloud Foundry, the third cloud provider we mentioned earlier in this section, will get more attention later in this chapter.
For information on other available PaaS cloud providers, review the list of websites in the Resources section at the end of this chapter.
First, we’ll look at how the Cloud Foundry product is different from other cloud solutions and what it offers to application developers and operations teams.
The Cloud Foundry application platform includes an application execution engine, an automation engine for application deployment and lifecycle management, and a scriptable command-line interface.
It provides integration with development tools like Spring Tool Suite (STS) to help with development and deployment processes.
It provides a multitenant PaaS that runs on the vSphere cloud platform.
It runs in a  virtual  machine on a developer’s Mac or PC.
Developers can use Micro Cloud Foundry to run a cloud on their own computers for development and testing purposes.
You can build cloud applications locally and deploy them to Cloud Foundry without changing the code.
Cloud Foundry supports the following program models for developing cloud-based applications:
As you can see, Cloud Foundry supports a diverse set of programming languages and runtime environments.
It also supports the following databases for data storage and persistence requirements:
MongoDB is one of the NoSQL databases (also known as nonrelational databases or NRDBMS), and it’s gaining in popularity for storing document-based, unstructured data.
PostgreSQL database support was added in Spring Roo 1.2 to provide another choice (in addition to MySQL) of open source relational database services offered by Cloud Foundry.
Messaging services such as RabbitMQ are also offered as part of the Cloud Foundry service infrastructure.
Messaging patterns play a significant role in developing loosely coupled application architectures, which is a big part of cloud computing models.
You can expect to see more integration and innovation in this area in future versions of cloud computing architectures.
The deployment process of moving a web application to Cloud server instances involves several steps.
These steps include uploading the web application to the server and binding various services—like database, messaging, scheduling, and monitoring services—to the application.
Performing these steps manually takes a great deal of time and effort because there are many environment variables that need to be set up correctly for the application to function as expected on remote servers.
It would be nice to take these steps in a more automated manner using simple commands.
Here is where the Cloud Foundry Roo add-on comes to the rescue.
The add-on makes it easy to deploy Java applications from the Roo console.
Let’s look at how to install the Cloud Foundry add-on so you can start issuing the commands provided by the add-on component.
This command takes a few minutes to download all of the required JAR files.
Now, type the pgp automatic trust command again to disable key trusting.
Here’s the output of this command showing the PGP key trusting is now disabled:
Automatic PGP key trusting disabled (this is the safest option)
Cloud Foundry also offers a command-line interface (CLI) called vmc, which allows you to interact with the Cloud Foundry instance from the command shell.
With the vmc tool you can deploy Java-, Ruby-, and Node.js-based web applications to the Cloud Foundry servers.
You can also configure the deployed applications to use the built-in services provided by the Cloud Foundry platform.
The interface is written in Ruby, so you’ll need Ruby and Ruby Gem installed before you can use the CLI commands.
The following list contains the vmc commands you can use to deploy and manage the applications in Cloud Foundry:
Deploying the Course Manager application to the cloud vmc frameworks.
For more information on the vmc tool, check the support page (http://mng.bz/ SfWG) on the Cloud Foundry community website.
You now have the add-on installed and ready for use.
Let’s see how to deploy the sample application using the new Cloud Foundry add-on commands.
To deploy the Roo application to the cloud, first log in to the Cloud Foundry site, which you can do by running the following command on the Roo command shell:
Alternatively, you can type the command cloud foundry list services to see the following output on the console.
The services command shows the name, description, and version of each system service available in the current release of Cloud Foundry:
The command you use to deploy applications to the Cloud Foundry instances is cloud foundry deploy.
The CREATE option in the previous example will trigger the Maven build commands to clean, compile, and package the application.
The deploy command will also move the WAR file to the Cloud Foundry instance.
If all of these steps complete successfully, you should see the following message at the end of the Maven build process:
Now, to verify that the coursemanager Roo application has been successfully deployed, let’s run the cloud foundry list apps command again to view all of the applications currently deployed.
Let’s start the application by issuing the command cloud foundry start app --appName coursemanager.
If you run the cloud foundry list apps command one more time, you’ll see that coursemanager has been started and is ready to receive web requests.
You can access Course Manager application running on the cloud by using the specified URL (http://coursemanager.cloudfoundry.com) as shown in figure 13.2
After you’ve deployed the application, you’ll need to check runtime statistics like the JVM-related information, add new services like a database, and bind them to your web application.
The following section covers these topics and shows how to perform them using the add-on commands.
Let’s take a look at the add-on command to get statistics, such as number of cores, memory, disk space, and uptime of the application.
The next step is to bind services provided by Cloud Foundry to your application.
As you saw earlier with the command cloud foundry list services, these services include databases (both relational and NoSQL databases) and messaging services.
To provision a new service, you use the following command by specifying the name and the type of the service.
Let’s create a new service to store and retrieve MongoDB from the NoSQL database, which is used to store document-based, unstructured data.
In this example, these values are mymongodb and mongodb, respectively:
Now you need to look at the list of available and provisioned services by running the list services command you ran before (cloud foundry list services)
Here’s the new output of this command showing the new MongoDB service you created:
To bind your application coursemanager to this new service, use the following command:
Application monitoring in the cloud 335 Let’s restart the application after binding the service using the following command:
The Cloud Foundry add-on provides some monitoring commands to keep an eye on how the application is performing, if it’s up and running, and other aspects.
If you want to see if your application had any crashes, you can run the command cloud foundry view crashes.
You can view the current memory setting of a cloud application, and update memory if you need to, from the cloud foundry view app memory --appName coursemanager command.
This command allows you to see the memory used by the application (256MB)
To change the allocated memory you can run cloud foundry update app memory --appName coursemanager with the new memory setting.
As you can see, the Cloud Foundry add-on commands are extensive and useful in deploying and monitoring cloud applications.
In this chapter, you learned about Cloud Foundry, the cloud computing product from VMware, and how to install the Cloud Foundry add-on in Roo.
You used the add-on commands to deploy to a Cloud Foundry instance.
You found out how to view the application logs, memory settings, and information on system crashes.
You also used the other add-on commands to perform tasks such as starting and stopping applications and binding services.
The next chapter builds on discussions from previous chapters and focuses on the integration Roo provides when working with Spring Integration.
This framework is used for Enterprise Service Bus (ESB) and workflow-based use cases.
In the previous chapter, you learned how to deploy Java applications to the cloud.
Using the Roo framework made it easier and faster to package and migrate your application from a local environment to the cloud server instance.
Enterprise application integration (see http://mng.bz/u7is) helps software architects and developers design and implement integration requirements in their applications.
These patterns are based on asynchronous messaging architectures that make the application design more modular and loosely coupled from other components within the application.
These EAI patterns are driven by design principles such as loose coupling, eventdriven architectures, and synchronous and asynchronous interaction models.
Two types of dependencies (or couplings) are involved—a component-level dependency and a system-level dependency.
A component- or type-level dependency deals with associating between various components in the application.
For example, a controller class may depend on a service class, which may in turn depend on a data access object (DAO) class.
These component-level dependencies can be reduced using the dependency injection (DI) principle.
Event-driven architecture (EDA) is another important component of enterprise application integration.
Another framework that works nicely with Spring Integration is Spring Batch, which can be used to design and implement batch (offline) applications.
Spring Batch enables the development of batch-based use cases that are common in the operations of enterprise systems.
A POJO-based framework, it provides reusable functions that are essential in processing large volumes of records, such as transaction management, job processing statistics, job restart, and resource management.
Currently, Roo has no add-on available for Spring Batch, making it a good add-on candidate because there are several commands in the batch framework and it would be easier to set up the jobs and other batch components using Roo commands.
If you’re interested in learning more about Spring Batch framework's features and API, refer to these additional resources: Spring Batch in Action (http://manning.com/ templier/), and the Spring Batch project website (http://mng.bz/F66T)
In this section, we’ll discuss the design details of the course registration use case with EIP patterns and Spring Integration in the mix.
In that solution design, the messaging infrastructure you set up didn’t allow the flexibility to add other steps in the process flow.
If you need the flexibility to add (or modify or remove) any components without having to write a lot of code to change the order of tasks, you can take advantage of the Spring Integration framework.
This alternative implementation of the course registration use case is the main focus of this chapter.
Let’s revisit the course registration use case, which includes multiple steps to process the course registration request before the last step of sending a confirmation email notification.
This is a good use case for a workflow-based solution.
The beauty of this solution is that you can implement a successful registration and a wait-list scenario within the same workflow.
This is one of the advantages to using a workflow approach.
It allows you to design a solution with different branches (forks) and subprocesses in the process flow.
The course registration process, using the Spring Integration solution, includes the following steps:
When a student submits the course registration request, you post a message with the course registration details in a message queue.
The Course Manager program performs all of the required updates and processing.
The diagram in figure 14.1 shows the various steps of the course registration process flow with two different scenarios—one for successfully registering for a course the user finds available, and the other for the wait-list scenario.
You’ll use some of the integration patterns in the implementation of the course registration use case.
Let’s take a look at these patterns in more detail.
Inbound Channel Adapter—This component in the workflow receives the course registration details from a message queue.
Content-Based Router—This component routes the registration request to the course registration confirmation or the wait-list step in the process, based on course availability.
Outbound Channel Adapter—This component sends an email notification to the customer after processing the course registration request.
Fortunately, an add-on component exists to create and manage Spring Integration components using Roo commands without having to write the code from scratch.
The Spring Integration add-on for Roo provides quick and simple configuration of Spring Integration flows.
The Spring Integration add-on’s current status is that of a work in progress, and at the time of this writing, it’s not in GA release.
The current version’s support is not comprehensive in that the add-on doesn’t persist the Spring configuration files after issuing the Roo commands.
But it does have good support for setting up the various Spring Integration components in the workflow.
The add-on also provides a focus command, similar to the Roo focus command, but it works on integration patterns rather than on Java classes.
You’ll perform the following steps to install the Spring Integration add-on:
Let’s look at each of these steps in more detail.
Let’s first check out the add-on source code from its Git repository location to a local directory on your machine.
You can use a Git client tool like SmartGit (http:// mng.bz/n5pg) to work with the Git repository, using a graphical user interface tool.
Now you need to clone the project using the add-on component’s Git repository URL.2
This will create two JAR files for the core and adapter modules, which you can deploy to the Roo environment, as discussed in the next section.
The Spring Integration add-on depends on the following four libraries:
If you try to deploy the Roo add-on without having these libraries installed first, the framework will throw the error shown in the following listing.
Listing 14.1 Error when deploying without the dependent Java libraries.
You can copy the required JAR files to the target folder in the PROJECT_HOME directory, or you can install these libraries using the OSGi commands.
To do this, first you create a new directory under target called RooAddOnLibraries and copy the zip file contents into this new folder.
Install these JAR files to the bundle folder under Roo’s installation directory using the osgi start command for each JAR file, as shown in this example:
If you need to uninstall a library, you can use the following command:
After installing the required libraries, type the following command to view all of the installed libraries and their current status (for example, whether they’re active or not):
The output of this command is shown in the next listing.
Listing 14.2 osgi ps command output showing all active OSGi bundles.
Another way to verify that the Spring Integration add-on components are installed correctly is to use the osgi log command.
Listing 14.3 osgi log output showing current status of OSGi bundles.
So far, you’ve downloaded, compiled, packaged, and deployed the Spring Integration add-on component source code along with the libraries on which the add-on depends.
Now you can start using the add-on to implement the course registration use case.
Before you do that, you need to quickly verify that you successfully installed the add-on and that there were no errors during deployment.
Listing 14.4 Spring Integration Roo commands to verify the add-on installation.
If you want context-sensitive help, you can type integration and press TAB:
Note that the exact syntax of these commands may change in more recent releases of the Spring Integration add-on, because the version of the add-on component is not in GA release at the time of this writing.
Before you can start creating the workflow components required for implementing the use case, you first need to set up the Spring Integration flow.
Let’s create a new project to see how the add-on sets up a Spring Integration project.
You can now type integration flow and press TAB twice to see what command options are available.
It will show the following output on the command shell window:
Because you didn’t create an existing Spring Integration flow yet, you need to use the start option with the integration flow command:
If you want to edit an existing Spring Integration workflow, use the command integration flow edit, specifying the name of the flow, as this example shows:
The output will say that the flow is ready for edits:
To see all of the available Spring Integration commands at this time, you can press TAB twice and it will display the following list of commands:
As you can see in the previous output example, there are several commands to create.
Note that the available commands are context sensitive, meaning that you see only.
Now that the base Spring Integration flow is set up, you’re ready to start adding the integration components you need to implement the course registration use case requirements.
The input channel adapter in this case is acting as a producer, so you need to run the produce command to set up the adapter component.
Type produce and press TAB twice to see the available options for the produce command.
If you do this a couple of times, you’ll see the command for setting up the channel adapter.
As you can see from the output in the following listing, a number of different adapter options are available, from ftp, jdbc, and jms to some new adapters that were added in recent releases of Roo, such as twitter and xmpp.
Listing 14.5 Variations of produce command for creating channel adapter component.
Here’s the full command to configure the JMS channel adapter:
You can now use the previously mentioned focus command to switch to a specific component in the workflow.
Let’s run the focus command with the --name parameter to see the list of different components available.
You can now use the focus command with the component ID to switch the focus to the inbound channel adapter.
After running the focus command, if you press TAB twice, it will display the list of available commands:
One of the commands listed is transform, which can be used to define a transformer component in the workflow.
Let’s run the transform command, which creates a data transformer and sets the focus to this new component.
Here’s output of the command after a transformer component has been added to the workflow:
Another command that’s available is the diagram command, which you can use for viewing Spring Integration workflow details, such as what Spring Integration components are defined and assembled so far in your use case.
The output of the diagram command showing the FLOW details with the channel adapter, message channel, and transformer components is shown here:
You only have two components defined so far in the process, so the diagram doesn’t have a lot of components.
You’ll run this command again later in this section after creating all of the components to show how the FLOW diagram will look after all of the workflow components are in place.
The next workflow component you need to define is a router that can be used to send the incoming messages to different steps in the process based on the predefined.
The last component you’ll create for your use case is the output channel adapter.
It’ll send the email notifications to customers after performing all of the steps in the course registration workflow.
Let’s add the Spring configuration file and Maven dependencies to test the Spring Integration components.
Listing 14.6 Configuration details for JMS components in course registration use case.
Listing 14.9 Test client for testing course registration with Spring Integration.
It improves productivity by enforcing correct coding practices and patterns and integrates with.
And, when you finish coding, it gets out of the way so there’s no runtime impact.
Spring Roo in Action teaches you to code Java more effi  ciently using Roo.
With the help of many examples, it shows you how to build application components from the database layer to the user interface.
The book takes a test-first approach and points out how Roo can help automate many of the mundane details of coding Java apps.
Along the way, you’ll address important topics like security, messaging, and cloud computing.
Ken Rimple is a veteran Java developer, trainer, mentor, and head of Chariot’s Education Services team, a VMWare training partner.
Srini Penchikala is a security architect with over 16 years of experience in software design and development.
Just Roo it with this book and increase your soft ware development productivity.” —Santosh Shanbhag, Monsanto “Helps you ‘quit the pouch’ and get beyond the basics.
Spring Roo in Action brief contents contents foreword preface acknowledgments about this book Learning by experimenting Roadmap Things you’ll need Notes on earlier versions of Roo Code conventions Source code Author Online.
Relationships, JPA, and advanced persistence 4.3.5 Putting the people in courses...
