O’Reilly books may be purchased for educational, business, or sales promotional use.
Building and Testing with Gradle, the image of a bush wren, and related trade dress are trademarks of O’Reilly Media, Inc.
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and O’Reilly Media, Inc.
While every precaution has been taken in the preparation of this book, the publisher and authors assume no responsibility for errors or omissions, or for damages resulting from the use of the information contained herein.
To my son, Zach, who plays the trumpet Psalm 150:3
This book is dedicated to my entire extended family who, in numerous ways, facilitated the creation of.
To my beautiful and supportive wife Madelaine for allowing me long.
My daughters Scarlette and Violette for playing rounds of Angry Birds while I made on-the-road.
My brother Jordan for promoting Gradle in his circle of Denver developers.
When I started writing Java code in 1996, there weren’t many options for compiling and building a project outside of javac and a custom build script.
In those days, many of us with a background in C configured makefiles to build Java, because that’s what we knew.
The challenge with this approach was that the idiom of make and the model it defined didn’t reflect the Java world very well.
Many teams would resort to creating a shell or batch script to build their project, so there was a huge vacuum at this time for a tool that would provide platform independent building and packaging.
The first tool to provide a successful solution to this problem and to realize significant adoption was Ant.
Ant provided a way to describe a Java build that was extensible and platform independent, which was a large part of its success.
Some of the downsides of Ant were its verbosity, its lack of conventions, and its lack of dependency management.
These deficiencies led to another popular tool, Maven, to be adopted by a number of development teams.
During the same timeframe, the industry’s maturity was growing in the area of software engineering discipline.
Many of these disciplines were captured in the Agile Manifesto and in the spirit of Extreme Programming.
These led to many changes, including more frequent builds on machines other than the developer’s workstation, often on different operating systems.
Many teams discovered that a successful compile was just a small measure of the quality of a project, leading to an increased demand on the build system, including unit and integration testing, static analysis tools such as FindBugs, and code coverage analysis.
This resulted in new build system pain points that needed to be addressed.
Instead of revisiting the model of the build tool, the common solution was to create plug-ins to existing build systems.
The continued growth in software engineering maturity today can be seen in the DevOps movement, climaxing with the publication last year of Jez Humble and David Farley’s book Continuous Delivery (AddisonWesley)
The discipline of continuous delivery encourages us to ask: how fast can we move a newly coded idea from development into production? The solution to the challenges of continuous delivery is automation.
What I have discovered over the years as a software engineer is that in order to solve a problem best, I have to understand the model.
The reason make wasn’t a great build tool for Java is that it didn’t have a way to express the model well.
Maven provided a stronger model, which is why so many people prefer it over Ant.
The challenge for Maven is that it provided “the one model to rule them all.” You’re able to express your build needs within that model and only that model.
Gradle provides a way of modeling a build system using a DSL with convention over configuration, yet allowing an enterprise to define its own model.
It goes deeper than this, as explained in this introductory book by Matthew and Tim, but modeling by convention is truly a game changer for enterprise software development.
I was excited to see that this book was being written by Matthew and Tim.
Matthew has a tremendous amount of experience in the software automation space, with years of practical hands-on consulting experience with Maven and being the top go-to guy for Git training.
Tim has been one of the top practicers and trainers in the Groovy and Grails space for years.
Together, they bring a tremendous amount of experience in software development and software automation to this book.
Additionally, I’ve known both these guys as part of the No Fluff Just Stuff software conference series, in addition to many other conferences, and I can attest to them being top-notch speakers, teachers, and trainers.
Tim and Matthew have a fantastic capacity to know very low-level technical details and can share that information with others in a very approachable way, which I feel is reflected well in this book.
This book is the first book to be focused solely on the subject of Gradle.
As one who is convinced that this technology is a game changer—so much so I joined the company behind it!—I’m convinced it will be well worth your time to understand and know this technology.
I can’t think of better people to write it than Matthew and Tim, and I know you’ll agree.
Introduction This book has a very clear aim: introduce you to the incredible simplicity and power of Gradle.
The best-of-breed features previously scattered among a set of tools are now made available via a unified Groovy DSL for scripting and Java API for tooling.
Gradle, even at the 1.0 milestone release current as of the time of this writing, already has a passionate following among some of the most respected enterprises and open source communities.
As we explore the tool’s capabilities, you’ll discover that Gradle is being heralded as more than just a build tool but also as a means of automating the compilation, test, and release process.
In this first official book on this open source project, we’ll showcase why the excitement around Gradle is on the rise and how it meets the challenge of these lofty build automation goals.
Future volumes will cover the Gradle plug-in ecosystem, how to extend Gradle with your own build logic, and even more advanced topics.
Conventions Used in This Book The following typographical conventions are used in this book:
Italic Indicates new terms, URLs, email addresses, filenames, and file extensions.
Constant width Used for program listings, as well as within paragraphs to refer to program elements such as variable or function names, databases, data types, environment variables, statements, and keywords.
Constant width bold Shows commands or other text that should be typed literally by the user.
Constant width italic Shows text that should be replaced with user-supplied values or by values determined by context.
Using Code Examples This book is here to help you get your job done.
In general, you may use the code in this book in your programs and documentation.
You do not need to contact us for permission unless you’re reproducing a significant portion of the code.
For example, writing a program that uses several chunks of code from this book does not require permission.
Selling or distributing a CD-ROM of examples from O’Reilly books does require permission.
Answering a question by citing this book and quoting example code does not require permission.
Incorporating a significant amount of example code from this book into your product’s documentation does require permission.
An attribution usually includes the title, author, publisher, and ISBN.
With a subscription, you can read any page and watch any video from our library online.
Access new titles before they are available for print, and get exclusive access to manuscripts in development and post feedback for the authors.
Copy and paste code samples, organize your favorites, download chapters, bookmark key sections, create notes, print out pages, and benefit from tons of other time-saving features.
To have full digital access to this book and others on similar topics from O’Reilly and other publishers, sign up for free at http://my.safaribooksonline.com.
How to Contact Us Please address comments and questions concerning this book to the publisher:
We have a web page for this book, where we list errata, examples, and any additional information.
Find us on Facebook: http://facebook.com/oreilly Follow us on Twitter: http://twitter.com/oreillymedia Watch us on YouTube: http://www.youtube.com/oreillymedia.
Acknowledgments from Tim Berglund I’m delighted to be a part of this, the first book on Gradle to be available to the marketplace.
It’s not every day that a game-changing technology comes along, and it’s exciting to be a small part of one when it does.
Gradle is just such an opportunity for everyone reading this book.
Writing a book is enormously difficult work, even when it’s a small one and you share the load with a coauthor.
I should start by thanking that coauthor, Matthew McCullough, for his organization, motivation, willingness to hold me accoutable, and of course his excellent contributions to this volume.
I would also like to thank Hans Dockter, Ken Sipe, Adam Murdoch, Peter Niederwieser, Szczepan Faber, and Luke Daley of the Gradleware team for their support in answering questions and providing feedback during the writing process.
The technical accuracy of this volume would be dramatically compromised without them.
Thanks to Mike Loukides for his confidence in Gradle as a technology and his help in publishing this book under O’Reilly’s name.
The book also would not have been possible without the support of Jay Zimmerman of the No Fluff Just Stuff conference series.
In five years, when Gradle has brought peace and order to all of your builds in ways you never could have anticipated, and you look back and realize you learned it all from these books, send Jay an email to say thanks.
He won’t know why you’re sending it, but you will.
I could have been called to other kinds of work which would have imposed less of a burden on her and conformed better to the assumptions she once made about what it is her husband would do, but instead she got this.
Nevertheless, she believes in me and supports me in my vocation, including things like the writing of this book.
The project of explaining Gradle continues, and these acknowledgments will follow it in the future volumes.
Acknowledgments from Matthew McCullough Rich Remington for his detailed book review and edits.
Chris Beams for his legitimizing of Gradle through SpringSource projects.
Hans Dockter for his edits, but equally for his coinvention of this incredible new tool and belief that it can be stretched even further.
Adam Murdoch for his coinvention and equally meaningful technical edits of the book.
Tim Berglund for his sharing of the effort on authoring this book.
Jay Zimmerman for his encouragement and multifacted support of this technological and educational endeavor we call Gradle.
Ant and Maven have occupied opposing positions on the build continuum, to the benefit and detriment of their users over the past decade.
Ant chooses to offer extreme flexibility to the user, imposing no conventions whatsoever, and not wanting to impose any heavyweight dependency management infrastructure on the build.
Apache Ivy later added badly needed dependency management to Java builds, but still didn’t address the lack of conventions inherent in Ant.
Maven, on the other hand, offered rigid standards and support for dependency management, but its standards were often overbearing, and deviating from them often proved more difficult than expected.
Ant and Maven have shared considerable success in the Java marketplace, despite important shortcomings in both tools.
On the one hand, Gradle presents itself as a sensible middle ground between both extremes, offering thoughtful conventions for your build to follow, and making it easy for you to extend or redefine those conventions when you want to.
Gradle provides out-of-the-box build conventions and at the same time realizes that no one set of standards can accurately reflect every build.
Gradle therefore intends to be a means of developing organization- and project-specific build standards.
It is best thought of not as a set of opinions on build standards, but as a toolkit for developing and extending those standards with a rich, descriptive language.
Gradle also gives you options in the way it handles build dependencies.
If your project’s idiom is to declare a few top-level dependencies by name and let your build tool determine what other libraries must be present to support your declared dependencies (“transitive dependency management”), Gradle will let you do that, interfacing with both Maven and Ivy repositories.
If you want to download JAR files and manage dependencies by hand in a local project directory, Gradle will not penalize you in any way.
This flexibility is important in many cases, but especially when migrating builds to Gradle: regardless of the legacy build’s opinions on dependency management, Gradle will not oppose them.
Gradle is rich in features, but is not such an opinionated framework that it will fight you when you want to do things your own way.
It offers conventions to those who want them, flexibility to those who need it, and a toolkit for turning that flexibility into domain-specific build standards that you can write on your own.
Build Files in Groovy A potentially complex build file demands an expressive format.
It seemed to be human-readable, and it was very easy to write code to parse it.
However, a decade of experience has shown that large and complex XML files are only easy for machines to read, not for humans.
Also, XML’s strictly hierarchical structure limits the expressiveness of the format.
It’s easy to show nesting relationships in XML, but it’s hard to express program flow and data access the way most common programming language idioms express them.
Ultimately, XML is the wrong format for a build file.
Groovy is a dynamic language of the JVM, similar in many respects to Java, but with some important differences.
As a beginning Gradle user, you don’t even need to be aware that you’re writing Groovy code, but as your needs become more sophisticated, the power of the Groovy language may become very important.
Unlike the build file formats of Ant and Maven, Gradle’s Groovy-based build files allow you to do general-purpose programming tasks in your build file.
This relieves much of the frustration developers have faced in lacking control flow in Ant or being forced into plug-in development in Maven to accomplish nonstandard tasks.
Domain-Specific Build Languages Every developer maintaining a complex build has wanted at some point to write just a little bit of code in the build file.
Sometime you just need an iterator, and other times you’d like to express a moderately complex conditional without resorting to major build file surgery.
But is the unlimited ability to code your way through a complex build a good thing? It might open broad new vistas of flexibility, but the result might ultimately be a catastrophe of maintainability.
Since Gradle build files are Groovy scripts, Gradle gives you the option to break into scripting mode at any point in your build, but doing this to excess is generally not encouraged.
Instead, Gradle intends to present the user not with mere Groovy, but with a domainspecific language (DSL) tailored to the task of building code.
A Gradle user could learn this language, not previously having known Groovy, and use Gradle effectively.
This DSL describes the build using idioms appropriate to the task of building software, not necessarily to general-purpose programming.
General-purpose coding is always available as a fallback, but Gradle gently nudges the user toward using the idioms of its DSL first, and coding second.
When the standard Gradle DSL doesn’t have the language to describe what you want your build to do, you can extend the DSL through plug-ins.
For example, Gradle out of the box contains the language needed to describe how to build Java code and create a WAR file from the output.
However, it doesn’t contain the language needed to run database migration scripts or deploy code to a set of cloud-based QA servers.
Through Gradle plug-ins, you can add new task definitions, change the behavior of existing tasks, add new objects, and create new keywords to describe tasks that depart from the standard Gradle categories.
Even through the simple mechanism of a custom Gradle task, you can introduce small pieces of build vocabulary, turning an otherwise undesirable chunk of imperative code into a clean declaration.
If you are coming from Maven, your understanding of a plug-in may be quite different from Gradle’s plug-in concept.
In Maven, a plug-in is a means of extending the tool with a particular, fine-grained action to be performed during your build, often associated with one or more phases in Maven’s elaborate lifecycle model.
In Gradle, a plugin may provide configurable build actions by introducing one or more tasks, but it is fundamentally a means of extending the build DSL to include the domain encompassed by the plug-in.
Using and extending the Gradle DSL are usually preferable to writing code in your build file.
While you are always free to solve problems in a locally optimized way by writing Groovy code inside your build, the most maintainable builds will eventually refactor this code into organized plug-ins that expose new build language idioms to the build files that use them.
Thus you can express the activities of your build in a high-level, declarative language that is meaningful in your business and technology domain.
Unzip the downloaded file into a directory of your choosing.
To install Gradle using brew, simply type the following from a Terminal window:
Brew will install and build any dependencies, then place the Gradle executable in your path.
Linux and MacOS Installation To install Gradle on *nix operating systems like Linux and MacOS, follow this command-line script:
You can also download the Gradle distribution directly from the Gradle web site and unzip that file.
Also, you may prefer another mechanism of setting environment variables on your installation.
Download the Gradle ZIP file from the Gradle web site and double-click on it to unzip.
In this example, we’ll assume you put it in C:\gradle-1.0
Next, right-click on the My Computer icon and select Properties.
In the Advanced System Settings dialog box (Figure 1-1), click on the Environment Variables button.
In the Environment Variables dialog box, click the New button under System Variables (Figure 1-2)
If you unzipped Gradle into a different directory, put that directory here.
In that same dialog box, select the Path variable under System Variables (Figure 1-3), then click Edit.
Add the text ;%GRADLE_HOME%\bin to the end of the Path variable value.
Let’s build the simplest build file that we possibly can to get an idea of the basics.
Unless otherwise noted, all of the examples in this book will assume that you are running Gradle from the command line.
See the installation procedures in “Getting Started” on page 3 for help getting started.
Create a file called build.gradle that looks like Example 1-1
You will see the following output as a result of the Hello World build: $ gradle -q helloWorld hello, world.
Note that the build file isn’t required to include anything, and doesn’t rely on any external dependencies.
It also doesn’t do much, other than printing out a message.
Before we move on to building some Java code, let’s try one more example.
This time, we’ll use two tasks plus a dependency to get the same work done (Example 1-2)
To run this build, we execute the second task, world.
Building a Java Program Of course, the Hello World example is contrived; nobody really wants to execute a build that only prints messages to the console.
Let’s have a look at how easy it can be to build Java code.
In the spirit of this introduction, we’ll make it a very simple Java program, just to showcase how simple Gradle can make a build if you are comfortable following its conventions.
Importantly, the directory layout of the project looks as shown in Example 1-5
This build file automatically introduces a number of tasks for us to run.
Just run gradle build, and you’ll see the output shown in Example 1-6
Notice not only that the Java code has been compiled and its class file placed in a directory we didn’t have to configure, but also that test report files have been generated (ready to receive actual unit test results when we write tests later), and a JAR has been built using the project directory name as the filename.
This is all a result of the conventions of Gradle’s Java plug-in.
We didn’t have to make a single decision or write a line of configuration.
And let it not go without saying that we can run our nascent Java application as shown in Example 1-7
There is a much longer story to tell about the Java plug-in, which will be covered in a separate volume.
If you want to get started now, you should also check out the online documentation.
If you had to write a real-world build file to build and run a Java program, you would want to use the application plug-in, which is a core plug-in available with every installation of Gradle.
The Gradle Command Line The preceding examples have shown Gradle running from the command line, and the majority of this book will continue that pattern.
Gradle is designed to support firstclass IDE integration at a deep architectural level, but the command line is anything but a second-class citizen.
In this book, we will work primarily from the command line.
We won’t go over all possible command line options, but here’s what you need to be productive right away:
This is a useful mechanism for passing parameters into a build from the command line.
This generates a lot of output, but can be quite useful for troubleshooting build problems.
Normally, stack trace logging is suppressed, so this is a helpful switch when debugging a broken build.
The stack trace is abbreviated by removing frames related to purely internal Groovy method calls.
These are usually not of interest to the build developer.
The Project object is an object representing the structure and state of the current build.
Note that plug-ins may introduce tasks of their own, so this list may be longer than the tasks you have defined.
Inside of a Gradle build file, the fundamental unit of build activity is the task.
Tasks are named collections of build instructions that Gradle executes as it performs a build.
You’ve already seen examples of tasks in Chapter 1, and they may seem like a familiar abstraction compared to other build systems, but Gradle provides a richer model than you may be used to.
Rather than bare declarations of build activity tied together with dependencies, Gradle tasks are first-class objects available to you to program if you desire.
Let’s take a look at the different ways of defining a task, the two key aspects of task definitions, and the task API we can use to perform our own customization.
Declaring a Task In the introduction, we saw how to create a task and assign it behavior all at the same time.
However, there’s an even simpler way to create a task.
You can see the results of this by running gradle tasks (Example 2-2)
Task Action However, executing this task with gradle hello will not produce any result, because we haven’t yet assigned the task an action.
Previously, we assigned an action to a task with the left-shift operator (Example 2-3)
In Groovy, operators like << (the “left-shift” operator from Java) can be overloaded to have different meanings depending upon the types of the objects they operate on.
In this case, Gradle has overloaded << to append a code block to the list of actions a task performs.
This is equivalent to the doLast() method we’ll cover later in the chapter.
However, we now have the flexibility of accruing action code in the task by referring to the task object we’ve created (Example 2-4)
Appending a task’s actions one at a time task hello.
Now we can recover our familiar build output (Example 2-5)
This is again trivial build behavior, but it exposes a powerful insight: tasks are not oneoff declarations of build activity, but are first-class objects in the Gradle programming environment.
And if we can accrue build actions to them over the course of the build file, there’s probably more we can do.
Task Configuration New users of Gradle commonly stumble over the configuration syntax when trying to define task actions.
Continuing our previous example, we can expand it to include a configuration block (Example 2-6)
Running this build file, we get what may seem to be a counterintuitive result (Example 2-7)
Groovy uses the term “closure” to refer to a block of code between two curly braces.
A closure functions like an object that can be passed as a parameter to a method or assigned to a variable, then executed later.
You’ll see closures all over in Gradle, since they’re a perfect fit for holding blocks of configuration code and build actions.
If the third closure had been just another snippet of build action, then we’d expect its message to print last, not first.
It turns out that the closure added to the task name without the left-shift operator doesn’t create additional task action code at all.
The configuration block of a task is run during Gradle’s configuration lifecycle phase, which runs before the execution phase, when task actions are executed.
Every time Gradle executes a build, it runs through three lifecycle phases: initialization, configuration, and execution.
Execution is the phase in which build tasks are executed in the order required by their dependency relationships.
Configuration is the phase in which those task objects are assembled into an internal object model, usually called the DAG (for directed acyclic graph)
Initialization is the phase in which Gradle decides which projects are to participate in the build.
Configuration closures are additive just like action closures, so we could have written the previous build file like so, and we would see the same output (Example 2-8)
The configuration block is the place to set up variables and data structures that will be needed by the task action when (and if) it runs later on in the build.
The configuration structure gives you the opportunity to turn your build’s tasks into a rich object model populated with information about the build, rather than a mere set of build actions to be executed in some sequence.
Without this distinction between configuration and action, you’d have to build additional complexity into your task dependency relationships, resulting in a more fragile build and a much less expressive means of communicating the build’s essential data structures.
All build configuration code runs every time you run a Gradle build file, regardless of whether any given task runs during execution.
Tasks Are Objects It may have occurred to you by now that Gradle is creating an internal object model of your build before executing it.
Every task you declare is actually a task object contained within the overall project.
A task object has properties and methods just like any other object.
We can even control the type of each task object, and access unique, type-specific functionality accordingly.
By default, each new task receives the type of DefaultTask.
Let’s take a look at the methods and properties each and every Gradle task has.
During the execution phase, the action block of every relevant task is executed.
The doFirst method allows you to add a bit of behavior to the beginning of an existing action, even if that action is defined by a build file or a plug-in you don’t control.
Calling doFirst multiple times keeps appending new blocks of action code to the beginning of the task’s execution sequence.
You can invoke the doFirst method directly on the task object, passing a closure to the method.
The closure contains the code to run before the task’s existing action.
As we’ve already mentioned, a closure is a block of Groovy code inside a pair of curly braces.
You can pass a closure around just like any other object.
You can also invoke doFirst from within the task’s configuration block.
Recall that the configuration block is a piece of executable code that runs before any task’s action runs, during the configuration phase of the build.
In our earlier discussion of task configuration, you may have been wondering how you might practically use the configuration block.
This example shows how you can call task methods from inside the configuration block, which makes a potentially very expressive format for modifying task behavior (Example 2-13)
Each previous call’s action code is retained, and the new closure is appended to the start of the list to be executed in order.
If we had to set up a database for integration testing (and wanted to do it a piece at a time), we might use the code shown in Example 2-14
Of course, it’s somewhat contrived to break one initialization sequence into three separate closures and calls to doFirst(), as we’ve done here.
However, sometimes the initial definition of a task isn’t immediately available to change as you see fit—for example, in cases in which the task is defined in another build file that is impossible or impractical for you to modify.
This kind of programmatic modification of that otherwise inaccessible build logic can be very powerful.
So far, our examples have used a very simple syntax, which makes the mechanics of Gradle more obvious, though at the expense of a lot of repetition.
In a real-world build (still relying on println statements in place of actual testing actions), we would be more likely to structure the task as done in Example 2-16
Note that we gather together the multiple calls to doFirst inside a single configuration block, and this occurs after the initial action is added to the world task.
If there was a block of code you wanted to run after an existing task was done executing, you might do as shown in Example 2-17:
Each succeeding call appends its closure to the end of the list to be executed in order (Example 2-18)
The value of the predicate is the value returned by the closure.
Using this method, you can disable the execution of a task which might otherwise run as a normal part of the build’s dependency chain.
In Groovy, the last statement of a closure is the closure’s return value, even if no return statement is given.
A Groovy method containing a single expression is a function that returns the value of that expression.
Using the onlyIf method, you can switch individual tasks on and off using any logic you can express in Groovy code, not just the simple System property tests we’ve used here.
You can read files, call web services, check security credentials, or just about anything else.
Not all tasks may set didWork upon completion, but some built-in tasks like Compile, Copy, and Delete do set it to reflect the success or failure of their actions.
For example, the current implementation of the Java Compiler returns didWork of true if at least one file successfully compiled.
You are able to set the didWork property in your own task actions to reflect the results of build code you write.
You can set any task’s enabled property to false to cause it not to run.
Its dependencies will still execute the way they would if the task were enabled.
The -b command line switch points Gradle to a nondefault build file.
By default, it looks for a file called build.gradle, but this switch lets us point it at a different file.
The leading colon indicates that the task is located in the top-level build file.
However, for a given build, not all tasks must be present in the top-level build file, since Gradle supports dependent subprojects, or nested builds.
The logging levels supported by the logger are as follows.
Setting the log level to one enables log output from all succeeding log levels, with the exception of WARN and QUIET as noted:
For high-volume logging messages which are of interest to the build developer, but should be suppressed during normal build execution.
When this log level is selected, Gradle automatically provides a richer log formatter, including the timestamp, log level, and logger name of each message.
All other log levels emit only the undecorated log message.
For lower-volume informative build messages which may be of optional interest during build execution.
Low-volume messages, usually from Gradle itself, about changes in the build lifecycle and the execution of the build tool.
When Gradle is executed without the -q command line option, this is the default logging level.
Calls to the println method emit log statements at this level.
Low-volume but important messages, alerting the executor of the build of potential problems.
When the log level is set to WARN, QUIET-level messages are not emitted.
Messages which should appear even if the quiet switch was specified on the Gradle command line.
Executing Gradle with the -q command line option causes this to be the default log level.
When the log level is set to QUIET, WARN-level messages are not emitted.
Rare but critically important log messages which should be emitted in all cases.
As illustrated in the discussion of the logger property, the logging.level property can be read and written to change the logging level in use by the build.
This directory is generally available to a task needing a temporary place in which to store intermediate results of any work, or to stage files for processing inside the task.
Dynamic Properties As we’ve seen, tasks come with a set of intrinsic properties which are indispensable to the Gradle user.
However, we can also assign any other properties we want to a task.
A task object functions like a hash map, able to contain whatever other arbitrary property names and values we care to assign to it (as long as the names don’t collide with the built-in property names)
Leaving our familiar “hello, world” example, let’s suppose we had a task called createArtifact that depended on a task called copyFiles.
The job of the copyFiles is to collect files from several sources and copy them into a staging directory, which the createArtifact task will later assemble into a deployment artifact.
The list of files may change depending on the parameters of the build, but the artifact must contain a manifest listing them, to satisfy some requirement of the deployed application.
Task Types As we discussed in “Tasks Are Objects” on page 16, every task has a type.
Besides the DefaultTask, there are task types for copying, archiving, executing programs, and many more.
Declaring a task type is a lot like extending a base class in an object-oriented programming language: you can get certain methods and properties available in your task for free.
This makes for very concise task definitions that can accomplish a lot.
A complete task reference is beyond the scope of this volume, but here are a few important types with an example of how to use each.
Copy A copy task copies files from one place into another (Example 2-33)
In its most basic form, it copies files from one directory into another, with optional restrictions on which file patterns are included or excluded.
The copy task will create the destination directory if it doesn’t already exist.
In this case, the copyFiles task will copy any files with the .xml, .properties, or .txt extensions from the resources directory to the target directory.
Note that the from, into, and include methods are inherited from the Copy.
Jar A Jar task creates a Jar file from source files (Example 2-34)
The Java plug-in creates a task of this type, called unsurprisingly jar.
It packages the main source set and resources together with a trivial manifest into a Jar bearing the project’s name in the build/libs directory.
A simple example of the Jar task in the jar-task example project apply plugin: 'java'
Note that the archive name and destination directory are easily configurable.
Likewise, the manifest can be populated with custom attributes using a readable Groovy map syntax.
The from method is identical to the one used in the CopyTask example, which reveals an interesting insight: the Jar task extends the Copy task.
Even before we’ve seen exhaustive documentation of the Gradle object model and DSL, these details hint at the richness and order of the underlying structure.
It would be natural just to assign a string to destinationDir, but the property expects an argument compatible with java.io.File.
The file() method, which is always available inside a Gradle build file, converts the string to a File object.
Complete documentation of the Jar task and its companion tasks is beyond the scope of this book.
JavaExec A JavaExec task runs a Java class with a main() method.
Command-line Java can be a hassle, but this task tries to take the hassle away and integrate command-line Java invocations into your build.
A Gradle task executing a command-line Java program (from the javaexec-task example) apply plugin: 'java'
A configuration is a collection of dependencies that have something in common.
In this case, the runtime configuration holds all dependencies which must be available to the program at runtime.
This is in contrast to dependencies which are needed only during compilation, or only while tests are running, or which are needed at compile time and runtime, but which are provided by a runtime environment like an application server.
The configuration property in Gradle is a collection of all configurations defined by the build, each of which is a collection of actual dependencies.
This build file declares an external dependency: the Apache Commons Codec library.
Normally, we’d have to compile our Java file, then concoct a java command line including the path to the compiled class files and the JAR dependency.
In this case, we may symbolically refer to the classes of the main sourceSet and all of the dependencies declared in the compile configuration.
Custom Task Types There will be occasions in which Gradle’s built-in task types will not quite do the job, and instead, the most expressive way to develop your build will be to create a custom task.
Custom Tasks Types in the Build File Suppose your build file needs to issue arbitrary queries against a MySQL database.
There are several ways to accomplish this in Gradle, but you decide a custom task is the most expressive way to do it.
The easiest way to introduce the task is simply to create it in your build script as shown here:
All custom tasks must extend this class or one of its descendants.
A custom task can extend any task types other than DefaultTask.
See Task Types for a description of the most important builtin task types.
It then declares a single method, runQuery(), which is annotated with the @TaskAction annotation.
The actual build tasks at the top of the build file all declare themselves to be of the MySqlTask type.
By doing this, they automatically inherit the properties and action of that task class.
Because most of the properties have defaults (some of which, like username and password, are obviously specific to the build), each invocation of the task has very little to configure.
The createDatabase and createUser tasks are able to configure just a single SQL query, and allow the defaults to take over from there.
The createTable task overrides the username, password, and database properties, since its task dependencies have created a new database and username separate from the default administrative settings.
The pattern of providing a useful default configuration which can be overridden when necessary is a recurring theme in Gradle.
Custom Tasks in the Source Tree Significant custom task logic will not fit well into a build file.
A few simple lines of scripting can pragmatically be inserted into a short task, as in the custom-task example.
However, at some point, a sophisticated task will develop a class hierarchy of its own, might develop a reliance on external APIs, and will need automated testing.
The build is code, and complex build code should be treated as a first-class citizen of the development world.
When custom task logic outgrows the build file, we can migrate it to the buildSrc directory at the project root.
This directory is automatically compiled and added to the build classpath.
Here is how we would alter the previous example to use the buildSrc directory.
Note that the task definition in the buildSrc directory is very similar to the code included in the build script in the previous example.
However, we now have a robust platform for elaborating on that simple task behavior, growing an object model, writing tests, and doing everything else we normally do when developing software.
You have four options for where to put your custom Gradle build code.
The first is in the build script itself, in a task action block.
The second is the buildSrc directory as we’ve shown here.
The third is in a separate build script file imported into the main build script.
The fourth is in a custom plug-in written in Java or Groovy.
Programming Gradle with custom plug-ins will be the topic of a separate volume.
Where Do Tasks Come From? So far, we’ve been creating tasks by coding them directly, either inside Gradle build scripts or in the buildSrc directory as Groovy code.
This is a great way to learn about tasks, because it’s easy to see all of the moving parts in great detail.
However, many of the tasks you use won’t be tasks you write; they’ll come from plug-ins.
You’ve already seen an example of this in the section on building Java code.
By applying the Java plug-in, the build script automatically inherits a set of tasks whose code you never directly see.
You can modify the behavior of these tasks using the task configuration, doFirst(), and doLast() methods we’ve covered in this chapter, but you don’t have to code them youself.
The fact that Gradle is providing you with rich, extensible task functionality whose code you never have to look at—code you invoke through the.
Gradle DSL, not through lots of literal Groovy code—is core to Gradle’s strategy of provding high extensibility with low complexity.
Gradle also has a few built-in tasks, like tasks and properties.
These aren’t provided by any plug-in or any imperative code you write, but are just a standard part of the Gradle DSL.
They are covered in the section on the Gradle command line.
Conclusion We’ve had a pretty thorough look at tasks in this chapter.
We’ve looked at how to configure them and how to script them, and gotten an idea of how Gradle divides up the work of configuration and execution between two lifecycle phases.
We’ve seen that tasks are first-class Groovy objects with a rich API of their own.
We’ve explored that API just enough to show you how to think about tasks as programmable entities.
We also looked at some standard class types that provide real functionality out of the box.
Finally we looked at how to write tasks of your own.
Gradle’s built-in tasks and plugins are enough for many users to script their builds without any custom code, but not always.
One of Gradle’s fundamental sensibilities is that it should be easy for you to extend your build without cluttering your build scripts with a lot of unmaintainable Groovy code.
Tasks are the basic unit of build activity in Gradle.
There is more to their story than an introduction can cover, but with this chapter under your belt, you’re well prepared to start using them and to continue learning about them.
When considering leveraging an existing investment in Apache Ant, or perhaps using the broad set of tasks that the Ant community has created, Gradle has a great story to tell.
In fact, it makes Gradle’s use of Ant simpler than directly using Ant, partly by leveraging Groovy’s AntBuilder functionality.
Gradle brings in everything from the Ant namespace into the Gradle namespace such that using a core Ant task is as easy as calling ant.<taskname>
Discussing the usage of Ant from Gradle provides a great bridge in terms of progressive migration to a pure Gradle strategy.
Over time though, we believe you’ll desire to standardize on the more powerful Gradle feature set by using native Gradle components or by wraping any Ant behavior in a Gradle plug-in.
With full awareness of the quantity of existing Ant infrastructure and value of leveraging it via the new build tool, Gradle ships with a full copy of Ant, thus making Ant’s default tasks available to every Gradle build.
To aid with this mind-set remapping, we’ll discuss how Gradle compares to Ant, providing parallels in the approaches to writing builds and to each tool’s unique terminology.
That would be the role that Gant fills, but Gradle has much more ambitious aims.
Gradle offers the flexibility of Ant, which many teams still cherish, but with the dependency management style of Ivy, the intelligent defaults of Maven, the speed and hashing of Git, and the metaprogramming power of Groovy.
That potent best-of-breed blend is an intrinsic motivator for joining the Gradle movement.
Gradle, like Ant, has a Directed Acyclic Graph (DAG) of tasks in its execution plan.
However, Gradle takes better advantage of this graph, and will, in the future, run tasks in parallel that are on discrete paths on the DAG.
Gradle also plans to leverage the value of holding this build DAG in memory to run certain graph paths of tasks in parallel.
A prototype visualization tool has even been produced that writes the DAG into a DOT format, as shown in Figure 3-1
Both Ant and Gradle use the word task, but with different meanings in each namespace.
Ant uses the word task to indicate one of its executable components (close to what many would call a plug-in in other systems), such as echo.
An Ant task can be executed within the context of a target.
Gradle defines task to refer to any step of the directed acyclic graph.
A property in Ant can be compared to a variable in Gradle.
In the more powerful Groovy language that Gradle provides, variables can be typeless (as in Ant) or typed, if desired.
Variables are available for reference in the parent Gradle project or any subprojects.
In Example 3-4, we took a simple string and supplied it to the message parameter of the echo Ant task.
It is useful to reiterate that no import-like plug-in statement was needed to make ant (a Groovy AntBuilder instance) available for invocation.
Further, no command was needed to make the echo task available for calls.
To fully discover which defined fields can be supplied with values, simply refer to the actual Ant Echo task documentation since Gradle provides a lightweight wrapper over the Ant implementation.
In Ant’s XML form (Example 3-5), this means that the greeting is put.
In Gradle (Example 3-6), the equivalent syntax is passing the greeting string directly into the echo() call without naming the field to which the value should be assigned.
This encompasses the basics of using Ant with Gradle, but hardly is the full breadth of such interoperation.
Let’s go a step further with the importing of custom Ant Tasks, configuration of complex nested Ant structures, and weaving of dependence between Gradle tasks and Ant targets.
Importing Custom Ant Tasks Using the core Ant tasks from Gradle was easy, but using a custom Ant task is nearly as simple.
Just use the taskdef method on the AntBuilder instance according to the same recipes that would be used for its Ant invocations.
For the first example, the Checkstyle Ant task will be loaded from a combination of a properties file and a set of local directory JARs.
In Example 3-7, the entire loading and execution of the custom Ant task happens within a single Gradle task.
The nested configurations via config and fileset directly correspond to the Checkstyle Ant equivalents as if this was being configured with Ant’s XML syntax.
As a contrasting example, a custom Ant Task can be loaded using a combination of a Gradle configuration, a declared dependency, and Maven Central repository connectivity.
In this more complex example of Example 3-9, we first establish a configuration for myPmd which is a preprocessing step prior to task executions.
The configurations closure declares a grouping named myPmd for our subsequent declaration of JAR requirements via the dependencies closure.
In the dependencies closure, we once address the myPmd grouping and indicate that it should download the PMD JAR as needed.
The source of the download is declared as the special repository mavenCentral() via the.
During the loading of the Ant task definition via ant.taskdef(///) call, the JAR downloaded as part of the myPmd configuration is added the myPmdTask classpath.
Complex Ant Configuration In more complex Ant configurations, there typically are several nested elements in the build.xml syntax.
Though Gradle provides a native class of tasks for archiving, and specifically a task type of Zip, a meaningful and straightforward example of using Ant’s zip task can display the native Ant XML configuration and the same independent configuration of said Ant task from within Gradle using the clearer AntBuilder notation.
In Example 3-10, a very common configuration for preparing a compressed archive using Ant’s zip task and XML configuration is shown.
Importing an Entire Ant Build File Up to this point, we’ve dealt with interoperability of Ant and Gradle on a fine-grained level, either calling existing Ant tasks, creating new Ant tasks on the fly, or manipulating the results of Ant task calls with Groovy.
But what if you want to bring everything in from an existing Ant build? Gradle handles that without even breaking a sweat.
First, we begin with our traditional Ant project in Example 3-3
Then, inside the Gradle build, we import the Ant targets into a Gradle task.
The result is an ability to treat the Ant build’s contents as a Gradle task from anywhere else in the Gradle ecosystem.
This is an implementation of the Facade pattern; all the utility of the Ant build is maintained, but all the value that Gradle brings to builds is additionally available to the buildmaster.
If we query Gradle for what Gradle tasks it knows about in Example 3-12, the answer will include the helloViaAttribute Ant target.
Task list from the imported Ant project $ gradle tasks :tasks.
To see all tasks and more detail, run with --all.
If we run the Gradle project requesting that the helloViaAttribute Gradle task be executed, we’ll get the bridged Ant behavior through a pure Gradle interface.
Sample run of the imported Ant project $ gradle helloViaAttribute :helloViaAttribute [ant:echo] hello from Ant.
Ant Target and Gradle Task Codependence Ant targets can even participate as a dependsOn of Gradle builds, as shown in Example 3-16
Likewise, Ant targets can point to Gradle tasks as depends fields, as shown in Example 3-15
The only requirement of the Ant and Gradle integration is that the more capable tool, Gradle, be the point of execution (see Example 3-17)
Gradle must drive the initiation of the build, say from from the command line, IDE, or GUI, but can be either the subordinate or dominate player in the actual XML and Gradle build script flow.
Define a task in Gradle that precedes the Ant target ant.importBuild 'build.xml'
Using AntBuilder The power of using Ant with Gradle isn’t limited to just the prescribed approaches given thus far.
Since the ant object is a full Groovy AntBuilder instance, existing paradigms and constructs from the Groovy language can be used here.
Though comprehensive knowledge of Groovy is not a prerequisite, any increased understanding of Groovy has a direct benefit to the authoring of Gradle build files since Gradle supports the gamut of Groovy syntax.
For example, to list the contents of a directory using an Ant FileScanner and Ant FileSet, just use the ant instance with Groovy closure nesting for Ant subelement access, as shown in Example 3-18
The power of Groovy’s operators can also be leveraged inside AntBuilder calls, such as using the regular expression matcher inside an evaluation of all System properties in Example 3-19
The spread *, elvis ?:, and other Groovy operators can all be applied directly or to subcomponents of the ant instance for a high code-to-effect ratio.
In the ultimate combination, a progressive migration from Ant to Gradle can be greatly aided by the ability to bring Ant classpaths into the Gradle space.
Use the Ant path references inside the Gradle build ant.importBuild 'build.xml'
The Gradle build file that injects the build paths into Ant ant.importBuild 'build.xml'
A Harmonic Duo Over the course of this chapter, the examples have demonstrated the simplicity of integrating Ant with Gradle.
The purpose of the cross-tool calls can either be that of a careful stepwise migration to Gradle, or the filling in for an absent Gradle plug-in with a well-established Ant equivalent.
Gradle’s build tool compatibility represents an understanding of the real world of software engineering: migrations don’t always happen overnight and bridges to legacy technologies make Gradle an option for many more teams and projects.
Up to this point, you’ve seen the very light footprint of Gradle.
You might be convinced it is the way to go for new projects.
However, only a very few of us are blessed with the wide-open choices afforded to a greenfield project.
The majority of us have an existing build system in place and the mandate to maintain continuity of the build.
We might even have downstream clients of our JAR, WAR, and EAR binary artifacts.
Gradle would only be a logical successor to Maven if it offered a very thoughtful path to both migration and integration from the world’s largest open source build system.
Cue Graven? First, let’s provide a bearing on the attitude of Gradle.
It is not just another Domain Specific Language (DSL) on top of the existing build tooling with which we are already familiar.
It is, in fact, a progression of selected ideas of our existing build tools.
Gradle brings only the best ideas forward and leaves behind the ones that fell short of their intended mark.
It would be easy to think of Polyglot Maven as an equivalent to Gradle, but alas, the constraints that apply to Maven apply to Polyglot Maven as well, just sans the angle brackets of XML.
Gradle aims to be something more powerful than its predecessor tools in the build space.
Gradle takes the convention over configuration and consistently named artifact concepts and brings them forward from the playbook of Maven.
Gradle also implements a strong domain model that is easily programmatically accessible.
Though often cited, it is debatable as to whether Maven actually has a strong model or merely a strong authoring language in the form of an XSD-compliant XML file.
Diving to a deeper level of precision, Gradle takes the coordinates, including groupId, artifactId, and version, in producing new build artifacts.
It also offers a bridge, in the form of a dependency management definition graph, to Maven and Ivy artifact repositories without demanding remote repositories.
This provides connectivity to opensource hosted binaries on sites like Maven Central, Java.net, and Clojars, just to name a few.
But the flexibility of Gradle also allows for the very valid use case in which dependency binaries are stored alongside the source in version control, whether for legal or technical reasons.
In the example of the ultimate flexibility allowed in Gradle, a default mapping is provided to the community-known dependency (classpath) scopes of Maven, but Gradle users can establish custom dependency scopes should the need arise.
That is a solid overview of what has been brought forward from the forge of the past decade of build tool experiments and field testing.
But what was intentionally omitted? Gradle leaves behind the expensive XML format.
We’ll also leave behind the strict, predefined lifecycle of Maven and the absence of a lifecycle with Ant.
Both are too far toward the ends of the spectrum of control and chaos, respectively.
Gradle will instead replace the strict Maven lifecycle with task defaults set via common plug-ins such as java.
Even with convenient defaults, Gradle offers a painless and lightweight way to extend the plug-in-supplied task sequence with additional steps that fit your build’s unique needs.
The Maven POM and Gradle Build With the big picture established, let’s take a piecewise approach to comparing Maven and Gradle.
We will start with a reminder of the appearance of a barest bones Maven POM.
While often desirable to have the formal vectors of groupId, artifactId, and version for a build, there are equally times where it is overkill.
We will use, as our first comparison with Maven, a Gradle build file in Example 4-2 that defines a few attributes and can produce a JAR, a common final product of a Java build.
That one line Gradle build file in Example 4-2, when executed with a mere gradle build from the command line, performed the following actions:
Compressed the .class files along with the MANIFEST.MF into a JAR in build/
The described actions taken by Gradle are made evident by examining the files in the structure of the output directory.
Maven Goals, Gradle Tasks The aforementioned minimalistic Gradle build also offered many of the tasks (nee Maven goals) we would have at our disposal with Maven.
Let’s examine the names of these tasks by asking Gradle what it can offer us by invoking the tasks task.
We see that tasks to clean, build, test, and JAR the project’s code are included via the simple inclusion of the java plug-in.
The Standard Maven Coordinates, Gradle Properties That comparison of a one line build.gradle to the most minimal pom.xml was valid, but not completely controlled in the metadata values for groupId, artifactId, and version.
In Gradle, the groupId is known just as group, the artifactId is known as name, and the version is identically version.
Formally, each of these kind of fields is known as a property in Gradle since we are saving state in POJO objects under the hood.
Growing our Gradle example to a more robust Maven POM equivalent, we’ll add the version field.
This is common in Gradle builds, even in the absence of the other group and artifact coordinates.
The version property is defined in the Gradle DSL reference and is present in every type of build, even without the java plug-in.
The archivesBase Name value is appended to the end of the produced JAR.
Recall that the artifact name defaults to the project’s directory name if no more precisely desired value is supplied as shown in Table 4-1
Directory listing of output from the version-specified Gradle build $ tree.
Note that the name field presented by the very foundation of Gradle is only mutable in the settings.gradle file, and if not supplied in settings.gradle, the archivesBaseName property is assigned a value instead.
The archivesBaseName property is brought into existence by the java plug-in.
Gradle 1.0 aims to simplify the field name mapping, doing away with archivesBaseName, and possibly providing a top level closure to configure the project’s Maven-equivalent coordinates.
Up to this point, we’ve only used the java plug-in.
Though many of these features look Maven-like in their naming and function, these are behaviors desired by nearly any Java project, even standalone single-JAR Java applications.
The consistent location of Gradle’s source directories (src/main/java) and the specification of the artifact’s group, name, and version metadata is useful, even without the aim of uploading an artifact to a remote repository.
The most visible Gradle win thus far is having the properties at the top level of the build file with slightly simplified property names rather than the XML nesting of Maven.
More Gradle Properties Having introduced one plug-in thus far, you might be wondering what range of properties are available to control.
Gradle offers an easy always-available task named properties to list the fields and values of the current build.
Let’s echo all the Gradle properties to the console with the -r or --properties flag.
Gradle Properties of a “hello world” build $ gradle properties.
The properties listed here have a wide range of rare to common in their frequency of being configured.
Many have sensible defaults, such as status being set to release, and are thus only occasionally tuned to an alternative value.
Adding the java plug-in as per the original sample build file introduces the additional properties shown in Example 4-8
Dependencies It is rare to see a project stand alone, independent of any third party or in-house library.
Gradle offers both an Ivy and Maven dependency and repository compatibility layer, allowing for very simplistic and flexible specification of dependencies and repositories.
A library is declared as a desired external dependency by a one-line listing in a closure named dependencies.
The most concise form of expressing this is a colon-separated list of fields in a single string.
A more verbose form preferred by some, but accomplishing the same thing, is a fieldby-field list.
What are these testCompile and compile phrases we see in Example 4-10? They are the scopes for which the declared external dependencies are to apply.
With the java plug-in introduced, there are six available scopes (or configurations to use the precise Gradle term) to which dependencies can be assigned.
However, unlike the fixed scopes of Maven, we have more flexibility with Gradle, to the objective of providing greater build flexibility.
New scopes, such as groovy, can be introduced by a plug-in.
Here we see an additional library being added to the groovy scope.
Displaying dependency assignment to scopes apply plugin: 'java' apply plugin: 'groovy'
The output of asking Gradle to list the dependencies shows that indeed, the new library lives beneath the groovy scope, but also scopes that logically need what was made available to groovy.
Gradle offers programmatic access to all elements of the model that represents the ultimate build plan.
A simple showcase of this access is the printing of the dependencies to screen in Example 4-13
Iterating through all dependencies can take simultaneous advantage of the dependencies object and the Groovy each method that accepts a closure.
The contents of the closure printlns the result, but could also perform manipulation or testing of the nodes, searching for a given pattern and conditionally acting on its inclusion.
Repositories The concept of retrieving libraries, source JARs, dependency metadata, and JavaDoc archives is an expected foundation of any modern build tool.
Ant, though the older of the JVM build tools, has been supplemented by the Ivy subproject to accomplish exactly this.
Ivy offers both a namesake format as well as compatibility with Maven repositories.
Gradle provides a bridge implementation to equally consume Ivy- or Maven-formatted repositories.
Gradle goes far beyond just offering an API bridge to Ivy and Maven.
It provides a Gradle-flavored DSL for both aforementioned dependency tools that make working with repositories quite simple.
The ever-important Maven Central has its own predefined method mavenCentral()
Since many organizations will need to additionally, or as a replacement, depend on a company-internal repository, that is equally easy with an addition of a URL to the mavenRepo configuration element of repositories in Example 4-15
If your project needs a true Ivy repository with resolution customization, then Gradle is up to the task with a convenient ivy closure syntax, as shown in Example 4-16
Lastly, what if you haven’t even begun your versioning and standardization of the names of your project’s artifacts? What if they are just a series of JARs in a single flat subdirectory? It should be no surprise by now that Gradle also has a convenient syntax for this requirement, called flat, as shown in Example 4-18
Unit Testing Unit testing is enabled as soon as the java plug-in is included in a Gradle build script.
There’s no additional effort to enable the testCompile dependency scope and test Classes task.
However, the selection of a particular testing framework library still needs to be stated via the dependencies section of the build.gradle file.
This facilitates compiled tests being able to reference JUnit or TestNG annotations or base classes.
Enabling compilation of unit tests apply plugin: 'java' apply plugin: 'maven'
The unit tests can be compiled via the testClasses task.
However, it is far more common to both compile and execute the tests in one seamless step.
A sample HTML report from this unit test is handsomely formatted as shown in Figure 4-1
This is one of those cases where constraints are helpful, right up to the point that you need to break them.
Then, Maven causes you great pain to circumvent the limitation for your possibly very valid engineering reason.
This is ultimately because the internal model of Maven is limited to just one source folder.
On the other hand, Gradle offers you the convention of a single source folder, named src/main/java, but lets you add more directories very easily, should your build’s design call for it.
A sourceSets entry named main is registered by default with the java plug-in and since that is a collection, we can simply modify it to give it an additional directory to scan during compilation, as shown in Example 4-23
They are more than just a convenience for the build user, but rather a means to communicate which task was intended by the author to be the primary function of this build.
Gradle has nearly the same facility, but has included support for multiple default tasks from the get-go.
The Maven Plug-in It isn’t until the point at which we need to publish a Maven pom.xml file for our project to participate in Maven-compatible dependency resolution that we need to involve Gradle’s Maven plug-in.
The archivesBaseName property introduced by the java plug-in can be consumed by the newly introduced maven plug-in in controlling the value written out as the artifactId in the generated pom.xml file.
If left empty, the project’s directory name is used, as per the defaults table.
A Gradle build file need only specify all the Maven coordinates if it wants precise control over each value.
The full set of coordinates will be generated into the pom.xml file no matter what, simply with default values if not explicitly set.
Gradle build that specifies all the usual Maven coordinates apply plugin: 'java' apply plugin: 'maven'
Alternatively, a configuration closure can be used to set the same information for the benefit of the generated pom.xml file.
Using Configuration to control the generated POM apply plugin: 'java' apply plugin: 'maven'
In either the approach of setting Gradle properties or authoring a configuration closure, we’ve simplified the setting of the standard Maven coordinates to their bare essence.
Both techniques equally shape the output of the JAR file’s name and the generated pom.xml file contents.
Installing to the Local Maven Repository (Cache) The Maven plug-in enabled Gradle to not only produce Maven-compatible pom.xml and JAR artifacts, but to install those to the local Maven repository.
The standard ~/.m2/repository location is used as the destination, just as it would be from Maven.
This install process, equivalent to mvn install, is guaranteed to be compatible with Maven because it actually uses the Maven Ant Tasks produced by the Maven team and hosted at Apache.
Publishing to a Maven Repository After a successful Gradle build, a binary artifact such as a JAR should be deployed to a binary repository manager such as Artifactory or Nexus for team-wide consumption.
Gradle again supports this as simply as its Maven predecessor would with a little configuration of the URL and transport, and then an equivalent to mvn deploy.
As seen in the previous section, the maven plug-in for Gradle offers pom.xml and metadata file generation in addition to local installation to the ~/.m2/repository directory.
This plug-in also offers an uploadArchives task that is the equivalent to mvn deploy.
Gradle build file that permits file:// repository uploads apply plugin: 'java' apply plugin: 'maven'
Protocols other than file:// require just slightly more configuration in that the protocol and wagon JAR that supplies that connectivity must be explicitly called out as shown for webdav in Example 4-34
Specifying a webdav protocol for artifact uploads apply plugin: 'java' apply plugin: 'maven'
It is still under active development on its path to going 1.0, and though young, is useful even in its current form.
Based on the utility’s knowledge of the constrained Maven vocabulary, it converts those instructions to Gradle equivalents.
Check the project’s README for details on tooling version requirements.
The tool outputs lightweight progress information as it works through the POM, settings, repositories, dependencies, and WAR natures, as shown in Example 4-36
At the conclusion of the tool’s execution, a build.gradle file and, as needed, a settings.gradle file are output to the current working directory.
The result of the maven2gradle conversion apply plugin: 'java' apply plugin: 'maven'
Taking the file exactly as output by maven2gradle would be short of the Gradle build’s full potential as it would miss out on some verbosity reductions that Gradle has to offer.
The resultant build.gradle file will function correctly, but the idea with Gradle is not just to have a functional equivalent in the Groovy language, but a better build than what we started with in Maven.
The output build.gradle can benefit from hand-tuning to leverage more Groovy idioms and Gradle plug-ins.
After all, Gradle’s aims are to provide you with great possibilities: a more expressive vocabulary and a more concise build file due to the ability to conform to your needs rather than the other way around.
Maven POM Import A second, and quite different question, is whether Gradle can directly import a Maven POM, capturing the existing behavior and converting it to equivalent Gradle behavior at runtime.
The short-term answer is “it’s a work in progress” named Gradle-M2Meta data-Plug-in.
The limited vocabulary of Maven makes this feasible, but mirroring the idiosyncrasies of Maven’s behavior for each combination of tags is a steep challenge.
Today, the source compatibility levels, dependencies, coordinates, and packaging can be brought across via a run-time import of a Maven pom.xml file’s contents.
To use this plug-in, add an apply and a configuration of the buildScript task that indicates where the plug-in’s JAR can be retrieved, as shown in Example 4-38
On the Maven side, the pom.xml is as traditional as a POM can be.
It defines coordinates and two dependencies which are used by the source code.
Conclusion Gradle, instead of starting anew from the things that we’ve learned and adopted in the Maven build space, promotes that it is okay to use something that already exists on the way to a better build.
The important twist is that Gradle is willing to be flexible where predecessors would be rigid.
This newfound flexibility exists while still facilitating the partial consumption of existing Maven build files for a gradual transition to a full Gradle build.
The discussion of testing with Gradle takes two primary directions.
The first is the simple testing of Java classes with existing test frameworks like JUnit and TestNG.
The second is a full automation of the testing pipeline, including separating integration tests from unit test and the leveraging of more advanced testing frameworks like Spock and Geb.
JUnit The simplest JUnit example is almost entirely supplied by the java Gradle plug-in.
It adds the test task to the build graph and needs only the appropriate JUnit JAR to be added to the classpath to fully activate test execution.
The report from the execution of the JUnit tests is quite handsome compared to its non-Gradle counterparts, as you can see in Figure 5-1
It offers a summary of the tests that were executed, succeeded, and failed.
When JUnit tests reach a certain level of proliferation within a project, there is a motivation to run them in parallel to get the results faster.
However, there would be a great overhead to running every unit test in its own JVM.
Gradle provides an intelligent compromise in that it offers a maxParallelForks that governs the maximum simultaneous JVMs that are spawned.
In the same area of testing, but with a different motivation, is the forkEvery setting.
Tests, in their quest to touch everything and exercise as much as possible, can cause unnatural pressure on the JVM’s memory allocation.
In short, it is what Java developers term a “leak”
It can merely be the loading of every class causing the problem.
This isn’t really a leak since the problem stems from the fact that loaded class definitions are not garbage collected but instead are loaded into permgen space.
The forkEvery setting causes a test-running JVM to close and be replaced by a brand new one after the specified number of tests have run under an instance.
Though these two settings have very different goals, they may often be seen used in combination when a project has a large battery of tests.
The use of forkEvery and maxParallelForks is shown in Example 5-2
Testing Java source with multiple JUnit threads apply plugin: 'java'
In Example 5-2, we leverage the test closure that was provided by the java plug-in as a scoping syntax for assignment of new values to the forkEvery and maxParallelForks variables.
Displaying the Gradle worker JVMs with the jps utility $ gradle test.
Displaying the Gradle worker JVMs with the jps utility $ jps.
We can see that five GradleWorkerMain instances are indeed busy, running tests as per our Example 5-2 specifications.
TestNG A more recent testing framework, TestNG, has been gaining traction in the Java space as of late.
It is also an easy testing framework to use with Gradle.
Only the modest addition of the useTestNG() call to the test closure is needed in addition to the refactoring of the unit test class.
Lastly, when tests start to bifurcate into both unit and integration tests, which among many differentiators, typically means short and long running respectively, a need to also have the tool respect those separations arises.
Gradle handles this with aplomb with a simple specification of a pattern of tests to include in each grouping as shown in Example 5-7
Separating tests into unit and integration tests apply plugin: 'java'
This same goal of separating unit and integration tests could also be accomplished with a different technique of separate sourceSet entries.
The sourceSet and configuration distinction (one for unitTest and one for integrationTest) has JAR dependency precision, but also more verbosity.
This is similar to the technique employed by the Gradle plug-in in that it has a distinct set of files (src/main/groovy) and dependencies (like the Groovy core library)
Spock Spock, as the homepage states, is a “testing and specification framework for Java and Groovy applications.” In a sea of similar tools, it distinguishes itself from the others by a very expressive DSL that reads nearly like natural English writing.
A Spock specification, since run under the umbrella of JUnit, can be executed by the mere addition of Spock’s JAR to Gradle’s dependencies.
Geb and EasyB Geb can be thought of as the furthest reaches of test automation on the JVM with Groovy-based control of web browsers for testing what is primarily thought of as a task for Selenium/WebDriver.
There are a growing number of developers writing about and demonstrating this powerful combination of driving a browser from JUnit all the way to specification formats like easyB.
Gradle can easily drive a Geb and easyB combination with just a few additional dependencies and an Ant task defintion, as shown in Example 5-10
The easyB specification file reads like plain English in its execution of web browser driving events and querying of the page responses.
And, at the end of the Geb via easyB execution, a very pleasant results page (Figure 5-3) describes the stories that were run, like a richer version of the JUnit test report.
Gradle’s Testing Focus The review and examples of testing with Gradle shows that the traditional JUnit testing approach is slightly less ceremonious than with other build tools.
However, Gradle truly shines in that the more advanced forms of separating integration tests, running Spock specifications, or driving the browser via Geb are handled with absolutely simplicity.
As more complex software, larger code bases, and increased automation drive developers toward these more advanced testing tools, Gradle is poised to offer the most convenient use.
This will continue to drive Gradle’s adoption as a software craftsperson’s build and automation tool.
Large projects are typically broken up into separate modules with independent build lifecycles.
Each subproject has some kind of life of its own, perhaps with a development team assigned to it alone, and certainly with a test suite of its own which is worthwhile to run apart from the project as a whole.
However, any large system that is broken into pieces must also be reintegrated together, implying the need for a master build that combines all subprojects into a single integration test suite and set of release artifacts or processes.
A next-generation build system will be equipped to provide a flexible framework for dealing with real-world project differentiation and integration.
Multiproject Build Structure A multiproject is generally hierarchical in nature: it typically has a master project with one or more subprojects.
The master project goes in a top-level directory, with subprojects arranged in subdirectories underneath.
The master project may add code, resources, tests, and build conventions of its own, or it may simply be build glue that holds the project tree together.
In the most intuitive case, Gradle allows you to define a build file for the top-level project and one for each subproject.
In a more interesting and potentially more useful case, it also lets you define the entire build from the top-level build file.
Alternatively, if neither a scattered set of individual build files nor a single, integrated build file suits you, you can also put some build configuration in the top-level build file and put project-specific details in the project-specific build files in their respective subdirectories.
As usual, Gradle wants to you give you the ability to define your own build conventions, rather than impose its opinions on you.
To tell Gradle which subdirectories of the root project actually contain projects (and not merely sources or build outputs), you must provide the settings.gradle file.
This is a build configuration file which is independent of build.gradle.
In the simplest case, settings.gradle simply lists the names of the subdirectories which contain subprojects, and nothing more.
When Gradle runs the Initialization lifecycle phase, it first looks for settings.gradle, and from it finds the list of subdirectories which contain subprojects.
If those subdirectories contain build.gradle files of their own, they are processed next and incorporated into the directed acyclic graph (DAG) that describes the build.
The fact that Gradle is building an internal project DAG reveals a compelling option: given the right Gradle syntax, we can actually do all of the multiproject build configuration from a single build.gradle file at the root level.
We can also distribute all of the configuration to the individual build files, or use a hybrid approach in which common configuration settings are in the master file, and project-specific settings reside in the individual build files.
Project-Specific Build Files Having a single, project-specific build file per subproject is easiest to digest for most new users.
There is a settings.gradle file at the project root, and a build.gradle file at the root and in each subproject directory.
Each subproject manages its own build affairs, and the top-level project combines the subproject build outputs into the integrated build outcome which is the ultimate goal of the build.
In our example, the root project is a command-line application that takes the name of a poet as a command line argument, then emits a few lines of that poet’s poetry to the console in an encoded form.
One of its dependencies is a project containing a simple API for generating the poems, including a Java interface, a factory class, and several implementations containing different poem fragments.
The other dependency is an API that encodes arbitrary strings first with the Metaphone algorithm, then the Base64 format.
The top-level application has the responsibility of calling both APIs to emit encoded poetry to the console.
This example illustrates two dependent subprojects, one of which is a completely standalone API, and one of has external JAR dependencies which must be fetched from an online repository and made available to the root-level project.
It simply names the subprojects by directory name, relative to the directory of the top-level project.
The settings.gra dle file is interpreted during the Initialization lifecycle phase, when the skeleton of the build graph is being constructed.
Consequently, a richer API than the include method is available.
In general, any part of the Gradle API that affects the structure of the build graph can be called in this file.
We haven’t looked in detail at what these API calls are yet, but later on in this chapter, we’ll look at some of them when we extract parts of the subproject build files into the top-level build file.
The top-level build file looks as shown in Example 6-2
This Groovy code declares a list of four strings (each of which is the name of a poet), then iterates over that list.
This line creates a dynamic task in the top-level project named after each poet.
The args parameter expects a List, so we use Groovy list literal syntax to wrap the poet variable.
There are a few things in this build file that we haven’t seen yet.
First of all, note that the dependencies aren’t vectors describing a JAR file in a repository, but they are projects.
The project() method queries the Gradle DAG and returns the project object belonging to a subproject.
The colon at the beginning of the project name indicates the root of the project tree, in a similar way that a forward slash indicates the root directory in a Unix filesystem, or a backslash indicates the root directory on Windows.
The project name following the colon is the project name as given in settings.gradle.
This top-level project’s dependencies block indicates that it depends on the codec and content subprojects.
Most importantly, each task’s classpath property is given two arguments: the runtimeClasspath of the top-level project, and the runtimeClasspath of the :codec project.
The codec project’s classpath must be added to the JavaExec task explicitly because the codec introduces a dependency of its own: namely, the Apache commons-codec library.
It is very typical for subprojects to have their own dependencies, either stored locally.
Finally, the first line of build.gradle introduces a method call we have not seen before.
This method call is necessary to enable the dependencies of the codec project to be available in the top-level project.
Calling this method will always force the named project to be evaluated first, so its contributions to the project graph will exist before the current project is evaluated.
The build file of the content project is trivial (Example 6-3)
It is a pure Java project with no external dependencies, following all of the conventions of the Java plug-in.
The code itself is only slightly more complex, having an interface, a factory class, and several concrete implementations of the interface.
These are all compiled and bundled into a JAR to be used by the top-level project.
The build file of the codec project contains only slightly more configuration (Example 6-4)
In addition to applying the Java plug-in, it also names Maven Central as a repository, and declares the Apache commons-codec library version 1.5 as a dependency.
The code itself declares a single class called Encoder, which exposes a method that calls both the Metaphone and Base64 codecs on a string argument.
Splitting a multiproject build into a parent project and multiple subprojects, and giving each subproject its own build file, is an easy-to-understand structure with much to recommend it as a standard approach to complex, composite Gradle projects.
However, the fact that Gradle converts the build files internally into a unified project DAG exposes a couple of other options for us when deciding how to organize multiproject builds.
Let’s look at how we might refactor this build to put all of the build configuration into one file.
One Master Build File The previous multiproject build can be expressed in a single build file in the root project.
The settings.gradle remains the same, naming the subprojects by their directories (Example 6-5)
However, the build.gradle files in the codec and content subproject directories go away entirely.
They are replaced with configuration in the master build file (Example 6-6)
This ensure that codec build objects will exist in the graph before the rest of this build file is evaluated.
The allprojects method passes all of its configuration to all projects in the build, including the root and all subprojects.
The project() method gives us direct access to the configuration of the codec subproject.
Using this syntax, we can configure any project in the graph.
In the unified build, all three projects need the Java plug-in, so we apply that plug-in inside the allprojects closure.
If we had configuration to apply only to subprojects, we could use the subprojects method instead.
The codec project has some individual configuration needs that don’t apply to the other two projects in the build, and we can apply this configuration by using the project() method.
Using this syntax, we can access the project graph of any configured subproject.
The power and flexibility of this syntax is difficult to overstate.
The object returned by project() is a Project object, which is implicitly the object being operated on by all of the methods normally called in a Gradle build file.
Just as repositories and dependencies are configured in this block, tasks could be created or modified, new Java SourceSets defined, plug-ins applied, or any other Gradle configuration operation performed.
The ability to access the Project object from the top-level build file gives us complete control over the structure of the entire build.
This feature is much more consequential than its ordinary-seeming syntax would suggest.
The rest of the build file is the same as what we saw in the individual build file example: the root project is made to depend on the two subprojects, and a set of tasks is dynamically created to call the CommandLine class with an appropriate argument.
This gives us the same functionality as the individual build file example.
A Hybrid Multiproject Build So far, we’ve seen two ways of expressing a multiproject build: splitting the build up into several project-specific build files, and combining all build configuration into one master build file.
As an alternative to these, you may find that the most expressive way to describe your build is to choose a hybrid approach in which some configuration is placed in the root build file and some is included in project-specific build files.
Let’s rework the build files from the previous two examples to reflect such a hybrid configuration.
The new root-level build file still contains an allprojects configuration, applying the Java plug-in to all projects.
Otherwise, it looks just like the root project build file from the individual build file example.
Since the dependency and repository configuration of the codec project were specific to that project, we push that configuration back down into its build file as shown in Example 6-8:
Note that we do not apply the Java plug-in in the code project’s build file, since the Java plug-in is a common configuration step that is done in the root-level build.gra dle file.
Because of this, there is no need to provide a build file for the content subproject, since that very simple build relies entirely on the defaults provided by the Java plug-in, which is applied by the root project.
Individual, Unified, or Hybrid? The three approaches we’ve explored here each have unique advantages.
Creating a single build file for each subproject project provides for a very clear separation of concerns, and is a very easy-to-understand approach for new users of Gradle.
Putting all configuration into a single build file puts the entire description of the build in one easyto-examine file.
A hybrid approach lets us put common configuration in one place, then to factor project-specific configuration into build files associated with their individual projects.
Each one of these approaches has something to recommend it.
Each is desirable for a reason of its own, but Gradle imposes no opinion on which approach is correct.
As a user of Gradle, you are free to structure your multiproject builds in whatever way best fits your circumstances and build sensibilities.
Multiproject Task Structure Gradle considers a multi-project build as a single graph of projects, tasks, and other configuration data structures.
As a result, running the build from inside the root project or any subproject gives you access to the entire graph of tasks.
If you’re in the directory of a subproject, you don’t have to change directories into another subproject to get access to that project’s tasks.
The task addressing scheme is similar to directory paths in the file system, except it uses colons instead of slashes as delimiters.
A colon at the beginning of a fully qualified task name indicates the root project.
If the colon is followed by the name of the task in the root project, then that fully qualified task name refers to that task in the root project —whether Gradle is being executed from within the root directory or from within a subproject directory.
If the text after the colon is a subproject name, then it should be followed by another colon and the name of a task within that subproject.
Again, this task can be invoked no matter what project directory in the tree you’re in when you run Gradle.
If you want to run the whole project build while in the directory of a subproject, you might use the command line shown in Example 6-9
If you want to build another subproject while in one subproject’s directory, you’d use the longer task syntax (Example 6-10)
This same syntax applies when you’re in the root project and want to run a subproject task directly, except that you may optionally omit the colon, since you’re already at the root level (Example 6-11)
Multiple Projects Your Way Gradle’s internal architecture lends itself to a very fluid way of dealing with multiproject builds.
It is a central fact of Gradle’s architecture that it converts all build.gradle files into a unified DAG that describes the dependencies and associated actions of a build.
The existence of this DAG gives you tremendous flexibility in how you want to represent the configuration of your multiproject build in your actual project files.
The individual, unified, and hybrid approaches—all of which are automatically integrated by the time the build executes—offer options that should appeal to all build developers regardless of project structure and developer preferences.
As usual, Gradle wants to provide you with the tools to create your own standards, rather than impose its standards on you.
About the Authors Tim is a full-stack generalist and passionate teacher who loves coding, presenting, and working with people.
He is founder and principal software developer at the August Technology Group, a technology consulting firm focused on the JVM.
He has recently been exploring build automation, nonrelational data stores, and abstract ideas like how to make software architecture look more like an ant colony.
He lives in Littleton, CO, with the wife of his youth and their three children.
Matthew is an energetic fifteen-year veteran of enterprise software development, worldtraveling open source educator, and co-founder of Ambient Ideas, LLC, a U.S.
His current topics of research center around project automation, including: build tools (Gradle, Leiningen, Maven, Ant), distributed version control (Git, Mercurial), testing frameworks (Geb, Spock, JUnit, TestNG, Mockito), continuous integration (Jenkins, Hudson, Bamboo) and code quality metrics (Sonar, CodeNarc, PMD)
Colophon The animal on the cover of Building and Testing with Gradle, first edition, is a bush wren.
Properties of DefaultTask didWork enabled path logger logging description temporaryDir.
