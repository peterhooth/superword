On Friday, you’ll be up and running with a new database.
On Saturday, you’ll see what it’s like under daily use.
By Sunday, you’ll have learned a few tricks that might even surprise the experts! And next week, you’ll vault to another database and have fun all over again.
Provides a great overview of several key databases that will multiply your data modeling options and skills.
Read if you want database envy seven times in a row.
This is by far the best substantive overview of modern databases.
Unlike the host of tutorials, blog posts, and documentation I have read, this book taught me why I would want to use each type of database and the ways in which I can use them in a way that made me easily understand and retain the information.
This is one of the best CouchDB introductions I have seen.
Seven Databases in Seven Weeks is an excellent introduction to all aspects of modern database design and implementation.
Even spending a day in each chapter will broaden understanding at all skill levels, from novice to expertthere’s something there for everyone.
In an ideal world, the book cover would have been big enough to call this book “Everything you never thought you wanted to know about databases that you can’t possibly live without.” To be fair, Seven Databases in Seven Weeks will probably sell better.
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and The Pragmatic Programmers, LLC was aware of a trademark claim, the designations have been printed in initial capital letters or in all capitals.
Every precaution was taken in the preparation of this book.
However, the publisher assumes no responsibility for errors or omissions, or for damages that may result from the use of information (including program listings) contained herein.
Our Pragmatic courses, workshops, and other products can help you and your team create better software and have more fun.
For more information, as well as the latest Pragmatic titles, please visit us at http://pragprog.com.
No endorsement by The Apache Software Foundation is implied by the use of these marks.
No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form, or by any means, electronic, mechanical, photocopying, recording, or otherwise, without the prior consent of the publisher.
Breckenridge made snow, and the slopes were immaculately groomed, but there was an inevitable sameness to the conditions on the mountain.
In 1994, as an employee of IBM’s database development lab in Austin, I had very much the same feeling.
I had studied object-oriented databases at the University of Texas at Austin because after a decade of relational dominance, I thought that object-oriented databases had a real chance to take root.
Still, the next decade brought more of the same relational models as before.
I watched dejectedly as Oracle, IBM, and later the open source solutions led by MySQL spread their branches wide, completely blocking out the sun for any sprouting solutions on the fertile floor below.
Over time, the user interfaces changed from green screens to client-server to Internet-based applications, but the coding of the relational layer stretched out to a relentless barrage of sameness, spanning decades of perfectly competent tedium.
At first, the dusting wasn’t even enough to cover this morning’s earliest tracks, but the power of the storm took over, replenishing the landscape and delivering the perfect skiing experience with the diversity and quality that we craved.
Just this past year, I woke up to the realization that the database world, too, is covered with a fresh blanket of snow.
Sure, the relational databases are there, and you can get a surprisingly rich experience with open source RDBMS software.
You can do clustering, full-text search, and even fuzzy searching.
I have not built a fully relational solution in a year.
Over that time, I’ve used a document-based database and a couple of keyvalue datastores.
The truth is that relational databases no longer have a monopoly on flexibility or even scalability.
For the kinds of applications that we build, there are more.
As a person who spent ten years at IBM Austin working on databases with our labs and customers, this development is simply stunning to me.
In Seven Databases in Seven Weeks, you’ll work through examples that cover a beautiful cross section of the most critical advances in the databases that back Internet development.
Within key-value stores, you’ll learn about the radically scalable and reliable Riak and the beautiful query mechanisms in Redis.
From the columnar database community, you’ll sample the power of HBase, a close cousin of the relational database models.
And from the document-oriented database stores, you’ll see the elegant solutions for deeply nested documents in the wildly scalable MongoDB.
You’ll also see Neo4J’s spin on graph databases, allowing rapid traversal of relationships.
You won’t have to use all of these databases to be a better programmer or database admin.
As Eric Redmond and Jim Wilson take you on this magical tour, every step will make you smarter and lend the kind of insight that is invaluable in a modern software professional.
You will know where each platform shines and where it is the most limited.
You will see where your industry is moving and learn the forces driving it there.
Acknowledgments A book with the size and scope of this one cannot be done by two mere authors alone.
It requires the effort of many very smart people with superhuman eyes spotting as many mistakes as possible and providing valuable insights into the details of these technologies.
We’d like to thank, in no particular order, all of the folks who provided their time and expertise:
Finally, thanks to Bruce Tate for his experience and guidance.
We’d also like to sincerely thank the entire team at the Pragmatic Bookshelf.
Thanks for entertaining this audacious project and seeing us through it.
Your patient feedback made this book what it is today.
Thanks to the whole team who worked so hard to polish this book and find all of our mistakes.
Last but not least, thanks to Frederic Dumont, Matthew Flower, Rebecca Skinner, and all of our relentless readers.
If it weren’t for your passion to learn, we wouldn’t have had this opportunity to serve you.
For anyone we missed, we hope you’ll accept our apologies.
From Eric: Dear Noelle, you’re not special; you’re unique, and that’s so much better.
Thanks also to the database creators and commiters for providing us something to write about and make a living at.
From Jim: First, I have to thank my family; Ruthy, your boundless patience and encouragement have been heartwarming.
Also a special thanks to all the unsung heroes who monitor IRC, message boards, mailing lists, and bug systems ready to help anyone who needs you.
Preface It has been said that data is the new oil.
If this is so, then databases are the fields, the refineries, the drills, and the pumps.
Data is stored in databases, and if you’re interested in tapping into it, then coming to grips with the modern equipment is a great start.
Databases are tools; they are the means to an end.
Each database has its own story and its own way of looking at the world.
The more you understand them, the better you will be at harnessing the latent power in the ever-growing corpus of data at your disposal.
As early as March 2010, we had wanted to write a NoSQL book.
The term had been gathering buzz, and although lots of people were talking about it, there seemed to be a fair amount of confusion around it too.
What exactly does the term NoSQL mean? Which types of systems are included? How is this going to impact the practice of making great software? These were questions we wanted to answer—as much for ourselves as for others.
The progressive style of introducing languages struck a chord with us.
We felt teaching databases in the same manner would provide a smooth medium for tackling some of these tough NoSQL questions.
This book is aimed at experienced developers who want a well-rounded understanding of the modern database landscape.
Prior database experience is not strictly required, but it helps.
After a brief introduction, this book tackles a series of seven databases chapter by chapter.
Each chapter is designed to be taken as a long weekend’s worth of work, split up into three days.
Each day ends with exercises that expand on the topics and concepts just introduced, and each chapter culminates in a wrap-up discussion that summarizes the good and bad points about the database.
You may choose to move a little faster or slower, but it’s important to grasp each day’s concepts before continuing.
We’ve tried to craft examples that explore each database’s distinguishing features.
To really understand what these databases have to offer, you have to spend some time using them, and that means rolling up your sleeves and doing some work.
Although you may be tempted to skip chapters, we designed this book to be read linearly.
Some concepts, such as mapreduce, are introduced in depth in earlier chapters and then skimmed over in later ones.
The goal of this book is to attain a solid understanding of the modern database field, so we recommend you read them all.
Before reading this book, you should know what it won’t cover.
Installing the databases in this book is sometimes easy, sometimes challenging, and sometimes downright ugly.
For some databases, you’ll be able to use stock packages, and for others, you’ll need to compile from source.
We’ll point out some useful tips here and there, but by and large you’re on your own.
Cutting out installation steps allows us to pack in more useful examples and a discussion of concepts, which is what you really want anyway, right?
Along the same lines of installation, this book will not cover everything you’d find in an administration manual.
Each of these databases has myriad options, settings, switches, and configuration details, most of which are well documented on the Web.
We’re more interested in teaching you useful concepts and full immersion than focusing on the day-to-day operations.
Though the characteristics of the databases can change based on operational settingsand we may discuss those characteristics—we won’t be able to go into all the nitty-gritty details of all possible configurations.
This book is inherently about choices, predominantly open source software on *nix platforms.
Microsoft environments tend to strive for an integrated environment, which limits many choices to a smaller predefined set.
As such, the databases we cover are open source and are developed by (and largely for) users of *nix systems.
This is not our own bias so much as a reflection of the current state of affairs.
Consequently, our tutorial-esque examples are presumed to be run in a *nix shell.
If you run Windows and want to give it a try anyway, we recommend setting up Cygwin1 to give you the best shot at success.
You may also want to consider running a Linux virtual machine.
In part, this is a consequence of the databases that we cover.
We’ve attempted to limit our choice of languages to Ruby/JRuby and JavaScript.
We prefer command-line tools to scripts, but we will introduce other languages to get the job done—like PL/pgSQL (Postgres) and Gremlin/Groovy (Neo4J)
We’ll also explore writing some server-side JavaScript applications with Node.js.
Except where noted, code listings are provided in full, usually ready to be executed at your leisure.
Samples and snippets are syntax highlighted according to the rules of the language involved.
The Pragmatic Bookshelf’s page for this book2 is a great resource.
There you’ll find downloads for all the source code presented in this book.
You’ll also find feedback tools such as a community forum and an errata submission form where you can recommend changes to future releases of the book.
Thanks for coming along with us on this journey through the modern database landscape.
Introduction This is a pivotal time in the database world.
For years the relational model has been the de facto option for problems big and small.
We don’t expect relational databases will fade away anytime soon, but people are emerging from the RDBMS fog to discover alternative options, such as schemaless or alternative data structures, simple replication, high availability, horizontal scaling, and new query methods.
These options are collectively known as NoSQL and make up the bulk of this book.
In this book, we explore seven databases across the spectrum of database styles.
In the process of reading the book, you will learn the various functionality and trade-offs each database has—durability vs.
The central question of Seven Databases in Seven Weeks is this: what database or combination of databases best resolves your problem? If you walk away understanding how to make that choice, given your particular needs and resources at hand, we’re happy.
But to answer that question, you’ll need to understand your options.
For that, we’ll take you on a deep dive into each of seven databases, uncovering the good parts and pointing out the not so good.
You’ll get your hands dirty with CRUD, flex your schema muscles, and find answers to these questions:
What type of datastore is this? Databases come in a variety of genres, such as relational, key-value, columnar, document-oriented, and graph.
We’ve specifically chosen databases to span these categories including one relational database (Postgres), two key-value stores (Riak, Redis), a column-oriented database (HBase), two document-oriented databases (MongoDB, CouchDB), and a graph database (Neo4J)
What was the driving force? Databases are not created in a vacuum.
They are designed to solve problems presented by real use cases.
On the other hand, column-oriented datastores were built to be well suited for storing large amounts of data across several machines, while data relationships took a backseat.
We’ll cover cases in which to use each database and related examples.
How do you talk to it? Databases often support a variety of connection options.
Whenever a database has an interactive command-line interface, we’ll start with that before moving on to other means.
Where programming is needed, we’ve stuck mostly to Ruby and JavaScript, though a few other languages sneak in from time to time—like PL/pgSQL (Postgres) and Gremlin (Neo4J)
At a lower level, we’ll discuss protocols like REST (CouchDB, Riak) and Thrift (HBase)
In the final chapter, we present a more complex database setup tied together by a Node.js JavaScript implementation.
What makes it unique? Any datastore will support writing data and reading it back out again.
What else it does varies greatly from one to the next.
Some support ad hoc queries; for others, queries must be planned.
Is schema a rigid framework enforced by the database or merely a set of guidelines to be renegotiated at will? Understanding capabilities and constraints will help you pick the right database for the job.
How does it perform? How does this database function and at what cost? Does it support sharding? How about replication? Does it distribute data evenly using consistent hashing, or does it keep like data together? Is this database tuned for reading, writing, or some other operation? How much control do you have over its tuning, if any?
Talking about scalability without the context of what you want to scale to is generally fruitless.
This book will give you the background you need to ask the right questions to establish that context.
While the discussion on how to scale each database will be intentionally light, in these pages you’ll find out.
Our goal is not to guide a novice to mastery of any of these databases.
A full treatment of any one of them could (and does) fill entire books.
But by the end you should have a firm grasp of the strengths of each, as well as how they differ.
Like music, databases can be broadly classified into one or more styles.
An individual song may share all of the same notes with other songs, but some are more appropriate for certain uses.
Similarly, some databases are better for some situations over others.
The question you must always ask yourself is not “Can I use this database to store and refine this data?” but rather, “Should I?”
In this section, we’re going to explore five main database genres.
We’ll also take a look at the databases we’re going to focus on for each genre.
It’s important to remember that most of the data problems you’ll face could be solved by most or all of the databases in this book, not to mention other databases.
The question is less about whether a given database style could be shoehorned to model your data and more about whether it’s the best fit for your problem space, your usage patterns, and your available resources.
You’ll learn the art of divining whether a database is intrinsically useful to you.
The relational model is generally what comes to mind for most people with database experience.
Relational database management systems (RDBMSs) are set-theory-based systems implemented as two-dimensional tables with rows and columns.
The canonical means of interacting with an RDBMS is by writing queries in Structured Query Language (SQL)
Data values are typed and may be numeric, strings, dates, uninterpreted blobs, or other types.
Importantly, tables can join and morph into new, more complex tables, because of their mathematical basis in relational (set) theory.
There are lots of open source relational databases to choose from, including MySQL, H2, HSQLDB, SQLite, and many others.
Battle-hardened PostgreSQL is by far the oldest and most robust database we cover.
With its adherence to the SQL standard, it will feel familiar to anyone who has worked with relational databases before, and it provides a solid point of comparison to the other databases we’ll work with.
We’ll also explore some of SQL’s unsung features and Postgres’s specific advantages.
There’s something for everyone here, from SQL novice to expert.
The key-value (KV) store is the simplest model we cover.
As the name implies, a KV store pairs keys to values in much the same way that a map (or hashtable) would in any popular programming language.
Some KV implementations permit complex value types such as hashes or lists, but this is not required.
Some KV implementations provide a means of iterating through the keys, but this again is an added bonus.
A filesystem could be considered a key-value store, if you think of the file path as the key and the file contents as the value.
Because the KV moniker demands so little, databases of this type can be incredibly performant in a number of scenarios but generally won’t be helpful when you have complex query and aggregation needs.
As with relational databases, many open source options are available.
Some of the more popular offerings include memcached (and its cousins memcachedb and membase), Voldemort, and the two we cover in this book: Redis and Riak.
It’s a faithful implementation of Amazon’s Dynamo, with advanced features such as vector clocks for conflict resolution.
Values in Riak can be anything, from plain text to XML to image data, and relationships between keys are handled by named structures called links.
One of the lesser known databases in this book, Riak, is rising in popularity, and it’s the first one we’ll talk about that supports advanced querying via mapreduce.
Redis provides for complex datatypes like sorted sets and hashes, as well as basic message patterns like publish-subscribe and blocking queues.
It also has one of the most robust query mechanisms for a KV store.
And by caching writes in memory before committing to disk, Redis gains amazing performance in exchange for increased risk of data loss in the case of a hardware failure.
This characteristic makes it a good fit for caching noncritical data and for acting as a message broker.
Columnar, or column-oriented, databases are so named because the important aspect of their design is that data from a given column (in the two-dimensional table sense) is stored together.
By contrast, a row-oriented database (like an RDBMS) keeps information about a row together.
The difference may seem inconsequential, but the impact of this design decision runs deep.
In columnoriented databases, adding columns is quite inexpensive and is done on a row-by-row basis.
Each row can have a different set of columns, or none at all, allowing tables to remain sparse without incurring a storage cost for null values.
With respect to structure, columnar is about midway between relational and key-value.
In the columnar database market, there’s somewhat less competition than in relational databases or key-value stores.
This column-oriented database shares the most similarities with the relational model of all the nonrelational databases we cover.
Using Google’s BigTable paper as a blueprint, HBase is built on Hadoop (a mapreduce engine) and designed for scaling horizontally on clusters of commodity hardware.
HBase makes strong consistency guarantees and features tables with rows and columns—which should make SQL fans feel right at home.
Out-of-the-box support for versioning and compression sets this database apart in the “Big Data” space.
In short, a document is like a hash, with a unique ID field and values that may be any of a variety of types, including more hashes.
The system imposes few restrictions on incoming data, as long as it meets the basic requirement of being expressible as a document.
Different document databases take different approaches with respect to indexing, ad hoc querying, replication, consistency, and other design decisions.
Choosing wisely between them requires understanding these differences and how they impact your particular use cases.
MongoDB is designed to be huge (the name mongo is extracted from the word humongous)
Mongo server configurations attempt to remain consistent—if you write something, subsequent reads will receive the same value (until the next update)
This feature makes it attractive to those coming from an RDBMS background.
It also offers atomic read-write operations such as incrementing a value and deep querying of nested document structures.
Using JavaScript for its query language, MongoDB supports both simple queries and complex mapreduce jobs.
CouchDB targets a wide variety of deployment scenarios, from the datacenter to the desktop, on down to the smartphone.
Written in Erlang, CouchDB has a distinct ruggedness largely lacking in other databases.
With nearly incorruptible data files, CouchDB remains highly available even in the face of intermittent connectivity loss or hardware failure.
Views consist of mapreduce functions, which are stored as documents and replicated between nodes like any other data.
One of the less commonly used database styles, graph databases excel at dealing with highly interconnected data.
A graph database consists of nodes and relationships between nodes.
The real strength of graph databases is traversing through the nodes by following relationships.
One operation where other databases often fall flat is crawling through selfreferential or otherwise intricately linked data.
The benefit of using a graph database is the ability to quickly traverse nodes and relationships to find relevant data.
Often found in social networking applications, graph databases are gaining traction for their flexibility, with Neo4j as a pinnacle implementation.
In the wild, databases are often used alongside other databases.
It’s still common to find a lone relational database, but over time it is becoming popular to use several databases together, leveraging their strengths to create an ecosystem that is more powerful, capable, and robust than the sum of its parts.
We’re in the midst of a Cambrian explosion of data storage options; it’s hard to predict exactly what will evolve next.
We can be fairly certain, though, that the pure domination of any particular strategy (relational or otherwise) is unlikely.
Instead, we’ll see increasingly specialized databases, each suited to a particular (but certainly overlapping) set of ideal problem spaces.
And just as there are jobs today that call for expertise specifically in administrating relational databases (DBAs), we are going to see the rise of their nonrelational counterparts.
Databases, like programming languages and libraries, are another set of tools that every developer should know.
And like any good builder, you can never hope to be a master without a familiarity of the many options at your disposal.
In this book, you’ll swing some hammers, spin some power drills, play with some nail guns, and in the end be able to build so much more than a birdhouse.
So, without further ado, let’s wield our first database: PostgreSQL.
It’s commonly understood, is often readily available, is sturdy, and solves a surprising number of problems if you swing hard enough.
No one can hope to be an expert builder without understanding this most common of tools.
PostgreSQL is a relational database management system, which means it’s a set-theory-based system, implemented as two-dimensional tables with data rows and strictly enforced column types.
Despite the growing interest in newer database trends, the relational style remains the most popular and probably will for quite some time.
The prevalence of relational databases comes not only from their vast toolkits (triggers, stored procedures, advanced indexes), their data safety (via ACID compliance), or their mind share (many programmers speak and think relationally) but also from their query pliancy.
Unlike some other datastores, you needn’t know how you plan to use the data.
PostgreSQL is the finest open source example of the relational database management system (RDBMS) tradition.
PostgreSQL is by far the oldest and most battle-tested database in this book.
It has plug-ins for natural-language parsing, multidimensional indexing, geographic queries, custom datatypes, and much more.
It has sophisticated transaction handling, has built-in stored procedures for a dozen languages, and runs on a variety of platforms.
PostgreSQL has built-in Unicode support, sequences, table inheritance, and subselects, and it is one of the most ANSI SQL–compliant relational databases on the market.
It’s fast and reliable, can handle terabytes of data, and has been proven to run in high-profile production.
PostgreSQL has existed in the current project incarnation since 1995, but its roots are considerably older.
The original project was written at Berkeley in the early 1970s and called the Interactive Graphics and Retrieval System, or “Ingres” for short.
It was later renamed to PostgreSQL in 1996 to denote its rather new SQL support and has remained so ever since.
Once you have Postgres installed, create a schema called book using the following command:
We’ll be using the book schema for the remainder of this chapter.
Next, run the following command to ensure your contrib packages have been installed correctly:
Seek out the online docs for more information if you receive an error message.
While we won’t assume you’re a relational database expert, we do assume you have confronted a database or two in the past.
We’ll start with creating our own schemas and populating them.
Then we’ll take a look at querying for values and finally what makes relational databases so special: the table join.
Like most databases we’ll read about, Postgres provides a back-end server that does all of the work and a command-line shell to connect to the running.
The server communicates through port 5432 by default, which you can connect to with the psql shell.
PostgreSQL prompts with the name of the database followed by a hash mark if you run as an administrator and by dollar sign as a regular user.
The shell also comes equipped with the best built-in documentation you will find in any console.
You can find usage details about each SQL command in the following way:
Before we dig too deeply into Postgres, it would be good to familiarize yourself with this useful tool.
It’s worth looking over (or brushing up on) a few common commands, like SELECT or CREATE TABLE.
PostgreSQL follows the SQL convention of calling relations TABLEs, attributes COLUMNs, and tuples ROWs.
For consistency we will use this terminology, though you may encounter the mathematical terms relations, attributes, and tuples.
PostgreSQL, being of the relational style, is a design-first datastore.
First you design the schema, and then you enter data that conforms to the definition of that schema.
Creating a table consists of giving it a name and a list of columns with types and (optional) constraint information.
Each table should also nominate a unique identifier column to pinpoint specific rows.
The SQL to create a countries table looks like this:
Implementations are much more practically minded than the names imply, despite sounding so mathematical.
So, why bring them up? We’re trying to make the point that relational databases are relational based on mathematics.
They aren’t relational because tables “relate” to each other via foreign keys.
Though much of the math is hidden from you, the power of the model is certainly in the math.
This magic allows users to express powerful queries and then lets the system optimize based on predefined patterns.
Imagining a relation as a physical table (an array of arrays, repeated in database introduction classes ad infinitum) can cause pain in practice, such as writing code that iterates over all rows.
Relational queries are much more declarative than that, springing from a branch of mathematics known as tuple relational calculus, which can be converted to relational algebra.
PostgreSQL and other RDBMSs optimize queries by performing this conversion and simplifying the algebra.
You can see that the SQL in the diagram below is the same as the previous diagram.
This new table will store a set of rows, where each is identified by a twocharacter code and the name is unique.
The PRIMARY KEY constrains the country_code column to disallow duplicate country codes.
We explicitly gave country_name a similar unique constraint, although it is not a primary key.
We can populate the countries table by inserting a few rows.
Attempting to add a duplicate country_name will cause our unique constraint to fail, thus disallowing insertion.
Constraints are how relational databases like PostgreSQL ensure kosher data.
According to any respectable map, Loompaland isn’t a real place—let’s remove it from the table.
We specify which row to remove by the WHERE clause.
With only real countries left in the countries table, let’s add a cities table.
To ensure any inserted country_code also exists in our countries table, we add the REFERENCES keyword.
Since the country_code column references another table’s key, it’s known as the foreign key constraint.
These generally correspond to inserting new records (creating), modifying existing records (updating), and removing records you no longer need (deleting)
All of the other operations you use a database for (any crazy query you can dream up) are read operations.
This time, we constrained the name in cities by disallowing NULL values.
Now let’s try another insert, this time with a U.S.
Figure 1—The REFERENCES keyword constrains fields to another table’s primary key.
Rather than delete and reinsert the value, we can update it inline.
All of the other databases we’ll read about in this book perform CRUD operations as well.
What sets relational databases like PostgreSQL apart is their ability to join tables together when reading them.
Joining, in essence, is an operation taking two separate tables and combining them in some way to return a single table.
It’s somewhat like shuffling up Scrabble pieces from existing words to make new words.
The basic form of a join is the inner join.
In the simplest form, you specify two columns (one from each table) to match by, using the ON keyword.
The join returns a single table, sharing all columns’ values of the cities table plus the matching country_name value from the countries table.
We can also join a table like cities that has a compound primary key.
To test a compound join, let’s create a new table that stores a list of venues.
A venue exists in both a postal code and a specific country.
The foreign key must be two columns that reference both cities primary key columns.
We make this identifier using the SERIAL keyword (MySQL has a similar construct called AUTO_INCREMENT)
Although we did not set a venue_id value, creating the row populated it.
Joining the venues table with the cities table requires both foreign key columns.
To save on typing, we can alias the table names by following the real table name directly with an alias, with an optional AS between (for example, venues v or venues AS v)
You can optionally request that PostgreSQL return columns after insertion by ending the query with a RETURNING statement.
In addition to inner joins, PostgreSQL can also perform outer joins.
Outer joins are a way of merging two tables when the results of one table must always be returned, whether or not any matching column values exist on the other table.
It’s easiest to give an example, but to do that, we’ll create a new table named events.
Let’s first craft a query that returns an event title and venue name as an inner join (the word INNER from INNER JOIN is not required, so leave it off here)
Retrieving all of the events, whether or not they have a venue, requires a LEFT OUTER JOIN (shortened to LEFT JOIN)
If you require the inverse, all venues and only matching events, use a RIGHT JOIN.
Finally, there’s the FULL JOIN, which is the union of LEFT and RIGHT; you’re guaranteed all values from each table, joined wherever columns match.
The speed of PostgreSQL (and any other RDBMS) lies in its efficient management of blocks of data, reducing disk reads, query optimization, and other techniques.
But those go only so far in fetching results fast.
If we select the title of Christmas Day from the events table, the algorithm must scan every row for a match to return.
Without an index, each row must be read from disk to know whether a query should return it.
An index is a special data structure built to avoid a full table scan when performing a query.
When running CREATE TABLE commands, you may have noticed a message like this:
PostgreSQL automatically creates an index on the primary key, where the key is the primary key value and where the value points to a row on disk, as shown in the graphic below.
Using the UNIQUE keyword is another way to force an index on a table column.
You can explicitly add a hash index using the CREATE INDEX command, where each value must be unique (like a hashtable or a map)
To index the starts column with a B-tree, use this:
Now our query over a range of dates will avoid a full table scan.
It makes a huge difference when scanning millions or billions of rows.
We can inspect our work with this command to list all indexes in the schema:
It’s worth noting that when you set a FOREIGN KEY constraint, PostgreSQL will automatically create an index on the targeted column(s)
We sped through a lot today and covered many terms.
A domain of values of a certain type, sometimes called an attribute.
An object comprised as a set of column values, sometimes called a tuple.
A set of rows with the same columns, sometimes called a relationTable.
Structured Query Language, the lingua franca of a relational database.
Combining two tables into one by some matching columns or NULL if nothing matches the left table.
A data structure to optimize selection of a specific set of columnsIndex.
A good standard index; values are stored as a balanced tree data structure; very flexible.
Relational databases have been the de facto data management strategy for forty years—many of us began our careers in the midst of their evolution.
So, we took a look at some of the core concepts of the relational model via basic SQL queries.
In the addresses FOREIGN KEY, find in the docs what MATCH FULL means.
Select all the tables we created (and only those) from pg_class.
Write a query that finds the country name of the LARP Club event.
Yesterday we saw how to define schemas, populate them with data, update and delete rows, and perform basic reads.
Today we’ll dig even deeper into the myriad ways that PostgreSQL can query data.
We’ll see how to group similar values, execute code on the server, and create custom interfaces using views and rules.
We’ll finish the day by using one of PostgreSQL’s contributed packages to flip tables on their heads.
An aggregate query groups results from several rows by some common criteria.
It can be as simple as counting the number of rows in a table or calculating the average of some numerical column.
They’re powerful SQL tools and also a lot of fun.
Let’s try some aggregate functions, but first we’ll need some more data in our database.
Enter your own country into the countries table, your own city into the cities table, and your own address as a venue (which we just named My Place)
Here’s a quick SQL tip: rather than setting the venue_id explicitly, you can sub-SELECT it using a more human-readable title.
If Moby is playing at the Crystal Ballroom, set the venue_id like this:
With our data set up, let’s try some aggregate queries.
The simplest aggregate function is count(), which is fairly self-explanatory.
To get the first start time and last end time of all events at the Crystal Ballroom, use min() (return the smallest value) and max() (return the largest value)
If we wanted to count all events at each venue, we could write the following for each venue ID:
This would be tedious (intractable even) as the number of venues grows.
With GROUP BY, you tell Postgres to place the rows into groups and then perform some aggregate function (such as count()) on those groups.
It’s a nice list, but can we filter by the count() function? Absolutely.
The GROUP BY condition has its own filter keyword: HAVING.
The following query SELECTs the most popular venues, those with two or more events:
FROM...GROUP BY on one column, you get all unique values.
This kind of grouping is so common that SQL has a shortcut in the DISTINCT keyword.
If you tried to run a SELECT with columns not defined under a GROUP BY in MySQL, you may be shocked to see that it works.
This originally made us question the necessity of window functions.
But when we more closely inspected the data MySQL returns, we found it will return only a random row of data along with the count, not all relevant results.
If you’ve done any sort of production work with a relational database in the past, you were likely familiar with aggregate queries.
Window functions, on the other hand, are not quite so common (PostgreSQL is one of the few open source databases to implement them)
Window functions are similar to GROUP BY queries in that they allow you to run aggregate functions across multiple rows.
The difference is that they allow you to use built-in aggregate functions without requiring every single field to be grouped to a single row.
If we attempt to select the title column without grouping by it, we can expect an error.
ERROR: column "events.title" must appear in the GROUP BY clause or \ be used in an aggregate function.
Whereas a GROUP BY clause will return one record per matching group value, a window function can return a separate record for each row.
Let’s see an example of the sweet spot that window functions attempt to hit.
Window functions return all matches and replicate the results of any aggregate function.
Figure 4—Window function results do not collapse results per group.
Or in SQL parlance, it returns the results of an aggregate function OVER a PARTITION of the result set.
Transactions ensure that every command of a set is executed.
If anything fails along the way, all of the commands are rolled back like they never happened.
PostgreSQL transactions follow ACID compliance, which stands for Atomic (all ops succeed or none do), Consistent (the data will always be in a good state—no inconsistent states), Isolated (transactions don’t interfere), and Durable (a committed transaction is safe, even after a server crash)
We can wrap any transaction within a BEGIN TRANSACTION block.
To verify atomicity, we’ll kill the transaction with the ROLLBACK command.
Up until now, every command we’ve executed in psql has been implicitly wrapped in a transaction.
When you restart the database server, that command will be rolled back.
Transactions are useful when you’re modifying two tables that you don’t want out of sync.
The classic example is a debit/credit system for a bank, where money is moved from one account to another:
If something happened between the two updates, this bank just lost five grand.
But when wrapped in a transaction block, the initial update is rolled back, even if the server explodes.
Every command we’ve seen until now has been declarative, but sometimes we need to run some code.
At this point, you must make a decision: execute code on the client side or execute code on the database side.
Stored procedures can offer huge performance advantages for huge architectural costs.
You may avoid streaming thousands of rows to a client application, but you have also bound your application code to this database.
The decision to use stored procedures should not be arrived at lightly.
Warnings aside, let’s create a procedure (or FUNCTION) that simplifies INSERTing a new event at a venue without needing the venue_id.
If the venue doesn’t exist, create it first and reference it in the new event.
Also, we’ll return a boolean indicating whether a new venue was added, as a nicety to our users.
When relational databases hit their heyday, they were the Swiss Army knife of technologies.
You could store nearly anything—even programming entire projects in them (for example, Microsoft Access)
The few companies that provided this software promoted use of proprietary differences and then took advantage of this corporate reliance by charging enormous license and consulting fees.
However, in their zeal to neuter the vendors, maxims arose such as no logic in the database.
This is a shame because relational databases are capable of so many varied data management options.
Many actions we investigate in this book are highly implementation specific.
However, it’s worth knowing how to use databases to their fullest extent before deciding to skip tools like stored procedures a priori.
Note: not an “error”, as in some programming languages RAISE NOTICE 'Venue found %', the_venue_id;
You can import this external file into the current schema by the following command-line argument (if you don’t feel like typing all that code)
Running it should return t (true), since this is the first use of the venue Run’s House.
This saves a client two round-trip SQL commands to the database (a select and then an insert) and instead does only one.
Covering the details of an entire programming language is beyond our scope, but you can read much more about it in the online PostgreSQL documentation.3
In addition to PL/pgSQL, Postgres supports three more core languages for writing procedures: Tcl, Perl, and Python.
People have written extensions for a dozen more including Ruby, Java, PHP, Scheme, and others listed in the public documentation.
The createlang command is also used to add new languages, which you can find online.4
Triggers automatically fire stored procedures when some event happens, like an insert or update.
They allow the database to enforce some required behavior in response to changing data.
Let’s create a new PL/pgSQL function that logs whenever an event is updated (we want to be sure no one changes an event and tries to deny it later)
A primary key isn’t necessary here, since it’s just a log.
Next, we build a function to insert old data into the log.
The OLD variable represents the row about to be changed (NEW represents an incoming row, which we’ll see in action soon enough)
Output a notice to the console with the event_id before returning.
This is the first of a number of places you’ll see this theme in this book: does the code belong in your application or in the database? It is a difficult decision—one that you’ll have to answer uniquely for every application.
The benefit is you’ll often improve performance by as much as an order of magnitude.
If the calculation involves many rows, a stored procedure will save you from moving thousands of rows instead of a single result.
The cost is splitting your application, your code, and your tests, across two different programming paradigms.
Finally, we create our trigger to log changes after any row is updated.
So, it turns out our party at Run’s House has to end earlier than we hoped.
Triggers can also be created before updates and before or after inserts.5
Wouldn’t it be great if you could use the results of a complex query just like any other table? Well, that’s exactly what VIEWs are for.
Unlike stored procedures, these aren’t functions being executed but rather aliased queries.
In our database, all holidays contain the word Day and have no venue.
So, creating a view is as simple as writing a query and prefixing it with CREATE VIEW some_view_name AS.
As proof, add Valentine’s Day on 201202-14 to events and query the holidays view.
Views are powerful tools for opening up complex queried data in a simple way.
The query may be a roiling sea of complexity underneath, but all you see is a table.
If you want to add a new column to the view, it will have to come from the underlying table.
Let’s alter the events table to have an array of associated colors.
Since holidays are to have colors associated with them, let’s update the VIEW query to contain the colors array.
Now it’s a matter of setting an array or color strings to the holiday of choice.
A RULE is a description of how to alter the parsed query tree.
Every time Postgres runs an SQL statement, it parses the statement into a query tree (generally called an abstract syntax tree)
Operators and values become branches and leaves in the tree, and the tree is walked, pruned, and in other ways edited before execution.
This tree is optionally rewritten by Postgres rules, before being sent on to the query planner (which also rewrites the tree in a way to run optimally), and sends this final command to be executed.
What’s more is that a VIEW such as holidays is a RULE.
We can prove this by taking a look at the execution plan of the holidays view using the EXPLAIN command (notice Filter is the WHERE clause, and Output is the column list)
Compare that to running EXPLAIN VERBOSE on the query we built the holidays VIEW from.
So, to allow updates against our holidays view, we need to craft a RULE that tells Postgres what to do with an UPDATE.
Our rule will capture updates to the holidays view and instead run the update on events, pulling values from the pseudorelations NEW and OLD.
With this rule in place, now we can update holidays directly.
Next let’s insert New Years Day on 2013-01-01 into holidays.
We’re going to move on from here, but if you’d like to play more with RULEs, try to add a DELETE RULE.
For our last exercise of the day, we’re going to build a monthly calendar of events, where each month in the calendar year counts the number of events in that month.
This kind of operation is commonly done by a pivot table.
These constructs “pivot” grouped data around some other output, in our case, a list of months.
Start by crafting a query to count the number of events per month, each year.
PostgreSQL provides an extract() function that returns some subfield from a date or timestamp, which aids in our grouping.
To use crosstab(), the query must return three columns: rowid, category, and value.
We’ll be using the year as an ID, which means the other fields are category (the month) and value (the count)
The crosstab() function needs another set of values to represent months.
This is how the function knows how many columns we need.
These are the values that become the columns (the table to pivot against)
So, let’s create a table to store a temporary list of numbers.
Now we’re ready to call crosstab() with our two queries.
ERROR: a column definition list is required for functions returning "record"
It may feel cryptic, but it’s saying the function is returning a set of records (rows), but it doesn’t know how to label them.
In fact, it doesn’t even know what datatypes they are.
Remember, the pivot table is using our months as categories, but those months are just integers.
We have one column year (which is the row ID) and twelve more columns representing the months.
Go ahead and add a couple more events on another year just to see next year’s event counts.
What we’re starting to see is that Postgres is more than just a server for storing vanilla datatypes and querying them; it is a data management engine that can reformat output data, store weird datatypes like arrays, execute logic, and provide enough power to rewrite incoming queries.
Find the list of aggregate functions in the PostgreSQL docs.
Find a GUI program to interact with PostgreSQL, such as Navicat.
A temporary table was not the best way to implement our event calendar pivot table.
The generate_series(a, b) function returns a set of records, from a to b.
Build a pivot table that displays every day in a single month, where each week of the month is a row and each day name forms a column across the top (seven days, starting with Sunday and ending with Saturday) like a standard month calendar.
Each day should contain a count of the number of events for that date or should remain blank if no event occurs.
We’ll spend Day 3 investigating the many tools at our disposal to build a movie query system.
We’ll begin with the many ways that PostgreSQL can search actor/movie names using fuzzy string matching.
Then we’ll discover the cube package by creating a movie suggestion system based on similar genres of movies we already like.
Since these are all contributed packages, the implementations are special to PostgreSQL and not part of the SQL standard.
Commonly, when designing a relational database schema, you’ll start with an entity diagram.
As a reminder, on Day 1 we installed several contributed packages.
It’s often good practice to create indexes on foreign keys to speed up reverse lookups (such as what movies this actor is involved in)
You should also set a UNIQUE constraint on join tables like movies_actors to avoid duplicate join values.
You can download the movies_data.sql file as a file alongside the book and populate the tables by piping the file into the database.
Any questions you may have about the genre cube will be covered later today.
Opening up a system to text searches means opening your system to inaccurate inputs.
It’s worth noting that as we progress, this kind of string matching blurs the lines between relational queries and searching frameworks like Lucene.6 Although some may feel features like fulltext search belong with the application code, there can be performance and administrative benefits of pushing these packages to the database, where the data lives.
PostgreSQL has many ways of performing text matches, but the two big default methods are LIKE and regular expressions.
If we want to be sure the substring stardust is not at the end of the string, we can use the underscore (_) character as a little trick.
This is useful in basic cases, but LIKE is limited to simple wildcards.
Regex A more powerful string-matching syntax is a regular expression (regex)
Regexes appear often throughout this book, because many databases support them.
There are entire books dedicated to writing powerful expressions—the topic is far too wide and complex to cover in depth.
So, to count all movies that do not begin with the, the following case-insensitive query will work.
You can index strings for pattern matching the previous queries by creating a text_pattern_ops operator class index, as long as the values are indexed in lowercase.
We used the text_pattern_ops because the title is of type text.
Levenshtein is a string comparison algorithm that compares how similar two strings are by how many steps are required to change one string into another.
Each replaced, missing, or added character counts as a step.
In PostgreSQL, the levenshtein() function is provided by the fuzzystrmatch contrib package.
Say we have the string bat and the string fads.
We can watch the distance close as we step closer (so to speak)
The total goes down until we get zero (the two strings are equal)
Changes in case cost a point too, so you may find it best to convert all strings to the same case when querying.
A trigram is a group of three consecutive characters taken from a string.
The pg_trgm contrib module breaks a string into as many trigrams as it can.
Finding a matching string is as simple as counting the number of matching trigrams.
The strings with the most matches are the most similar.
It’s useful for doing a search where you’re OK with either slight misspellings or even minor words missing.
The longer the string, the more trigrams and the more likely a match—they’re great for something like movie titles, since they have relatively similar lengths.
We’ll create a trigram index against movie names to start (we use Generalized Index Search Tree [GIST], a generic index API made available by the PostgreSQL engine)
Now you can query with a few misspellings and still get decent results.
Trigrams are an excellent choice for accepting user input, without weighing them down with wildcard complexity.
Next, we want to allow users to perform full-text searches based on matching words, even if they’re pluralized.
If a user wants to search for certain words in a movie title but can remember only some of them, Postgres supports simple natural-language processing.
Let’s look for a movie that contains the words night and day.
This is a perfect job for text search using the @@ full-text query operator.
The query returns titles like A Hard Day’s Night, despite the word Day being in possessive form, and the two words are out of order in the query.
The @@ operator converts the name field into a tsvector and converts the query into a tsquery.
A tsvector is a datatype that splits a string into an array (or a vector) of tokens, which are searched against the given query, while the tsquery represents a query in some language, like English or French.
The language corresponds to a dictionary (which we’ll see more of in a few paragraphs)
The previous query is equivalent to the following (if your system language is set to English):
You can take a look at how the vector and the query break apart the values by running the conversion functions on the strings outright.
The tokens on a tsvector are called lexemes and are coupled with their positions in the given phrase.
You may have noticed the tsvector for A Hard Day’s Night did not contain the lexeme a.
Moreover, simple English words like a are missing if you try to query by them.
NOTICE: text-search query contains only stop words or doesn’t \ contain lexemes, ignored.
Common words like a are called stop words and are generally not useful for performing queries.
The English dictionary was used by the parser to normalize our string into useful English components.
In your console, you can view the output of the stop words under the English tsearch_data directory.
We could remove a from the list, or we could use another dictionary like simple that just breaks up strings by nonword characters and makes them lowercase.
With simple, you can retrieve any movie containing the lexeme a.
Since Postgres is doing some natural-language processing here, it only makes sense that different configurations would be used for different languages.
All of the installed configurations can be viewed with this command:
Dictionaries are part of what Postgres uses to generate tsvector lexemes (along with stop words and other tokenizing rules we haven’t covered called parsers and templates)
You can test any dictionary outright by calling the ts_lexize() function.
Here we find the English stem word of the string Day’s.
Finally, the previous full-text commands work for other languages too.
Since was (what) and du (you) are common, they are marked as stop words in the German dictionary, while machst (doing) and gerade (now) are stemmed.
But if we don’t index our tables, it’s also slow.
The EXPLAIN command is a powerful tool for digging into how queries are internally planned.
That’s rarely a good sign in a query, because it means a whole table scan is taking place; each row will be read.
We’ll use Generalized Inverted iNdex (GIN)—like GIST, it’s an index API—to create an index of lexeme values we can query against.
The term inverted index may sound familiar to you if you’ve ever used a search engine like Lucene or Sphinx.
With our index in place, let’s try to search again.
It’s because our GIN index specifically uses the english configuration for building its tsvectors, but we aren’t specifying that vector.
We need to specify it in the WHERE clause of the query.
Levenshtein distance allows finding matches that contain minor misspellings but must ultimately be very close to the same string.
Trigrams are a good choice for finding reasonable misspelled matches.
Finally, full-text searching allows natural-language flexibility, in that it can ignore minor words like a and the and can deal with pluralization.
Sometimes we just don’t know how to spell words correctly but we know how they sound.
We love Bruce Willis and would love to see what movies he’s in.
Unfortunately, we can’t remember exactly how to spell his name, so we sound it out as best we can.
Even a trigram is no good here (using % rather than =)
Enter the metaphones, which are algorithms for creating a string representation of word sounds.
You can define how many characters are in the output string.
For example, the seven-character metaphone of the name Aaron Eckhart is ARNKHRT.
To find all films acted by someone sounding like Broos Wils, we can query against the metaphone output.
You can dissect the functions’ representations by selecting their output.
There is no single best function to choose, and the optimal choice depends on your dataset.
With all of our string searching ducks in a row, we’re ready to start combining them in interesting ways.
One of the most flexible aspects of metaphones is that their outputs are just strings.
This allows you to mix and match with other string matchers.
For example, we could use the trigram operator against metaphone() outputs and then order the results by the lowest Levenshtein distance.
This means “Get me names that sound the most like Robin Williams, in order.”
Unbridled exploitation of this flexibility can yield other funny results, so be careful.
We’ll use the cube datatype to map a movie’s genres as a multidimensional vector.
We will then use methods to efficiently query for the closest points within the boundary of a hypercube to give us a list of similar movies.
As you may have noticed in the beginning of Day 3, we created a column named genres of type cube.
Each value is a point in 18-dimensional space with each dimension representing a genre.
The genres table describes the position of each dimension in the vector.
We will find similar movies by finding the nearest points.
To understand why this works, we can envision two movies on a two-dimensional genre graph, like the graph shown below..
If your favorite movie is Animal House, you’ll probably want to see The 40 Year Old Virgin more than Oedipus—a story distinctly lacking in comedy.
In our two-dimensional universe, it’s a simple nearest-neighbor search to find likely matches.
The principle is the same: a nearest-neighbor match to the nearest points in genre space will yield the closest genre matches.
Here we can find the distance of all movies to the Star Wars genre vector, nearest first.
We created the movies_genres_cube cube index earlier when we created the tables.
However, even with an index, this query is still relatively slow, since it requires a full-table scan.
It computes the distance on every row and then sorts them.
Rather than compute the distance of every point, we can instead focus on likely points by way of a bounding cube.
Just like finding the closest five towns on a map will be faster on a state map than a world map, bounding reduces the points we need to look at.
With our bounding hypercube, we can use a special cube operator, @>, which means contains.
This query finds the distance of all points contained within a five-unit cube of the Star Wars genre point.
Using a subselect, we can get the genre by movie name and perform our calculations against that genre using a table alias.
This method of movie suggestion is not perfect, but it’s an excellent start.
We will see more dimensional queries in later chapters, such as two-dimensional geographic searches in MongoDB (see GeoSpatial Queries, on page 171)
Today we jumped headlong into PostgreSQL’s flexibility at string searches and used the cube package for multidimensional searching.
Most importantly, we caught a glimpse of the nonstandard extensions that puts PostgreSQL at the top of the open source RDBMS field.
There are dozens (if not hundreds) of more extensions at your disposal, from geographic storage to cryptographic functions, custom datatypes, and language extensions.
Beyond the core power of SQL, contrib packages are what makes PostgreSQL shine.
Find online POSIX regex documentation (it will also be handy for future chapters)
Expand the movies database to track user comments and extract keywords (minus English stopwords)
Cross-reference these keywords with actors’ last names, and try to find the most talked about actors.
If you haven’t spent much time with relational databases, we highly recommend digging deeper into PostgreSQL, or another relational database, before deciding to scrap it for a newer variety.
Relational databases have been the focus of intense academic research and industrial improvements for more than forty years, and PostgreSQL is one of the top open source relational databases to benefit from these advancements.
PostgreSQL’s strengths are as numerous as any relational model: years of research and production use across nearly every field of computing, flexible queryability, and very consistent and durable data.
Most programming languages have battle-tested driver support for Postgres, and many programming models, like object-relational mapping (ORM), assume an underlying relational database.
The crux of the matter is the flexibility of the join.
You needn’t know how you plan to actually query your model, since you can always perform some joins, filters, views, and indexes—odds are good you will always have the ability to extract the data you want.
PostgreSQL is fantastic for what we call “Stepford data” (named for The Stepford Wives, a story about a neighborhood where nearly everyone was consistent in style and substance), which is data that is fairly homogeneous and conforms well to a structured schema.
Furthermore, PostgreSQL goes beyond the normal open source RDBMS offerings, such as powerful schema constraint mechanisms.
You can write your own language extensions, customize indexes, create custom datatypes, and even overwrite the parsing of incoming queries.
And where other open source databases may have complex licensing agreements, PostgreSQL is open source in its purest form.
Anyone can do pretty much anything they want with the project (other than hold authors liable)
If you are a fan of free(dom) software or have a long bushy beard, you have to respect their general resistance to cashing in on an amazing product.
Although relational databases are undeniably the most successful style of database over the years, there are cases where it may not be a great fit.
Partitioning is not one of the strong suits of relational databases like PostgreSQL.
If you need to scale out rather than up (multiple parallel datastores rather than a single beefy machine or cluster), you may be better served looking elsewhere.
If your data requirements are too flexible to easily fit into the rigid schema requirements of a relational database or you don’t need the overhead of a full database, require very high-volume reads and writes as key values, or need to store only large blobs of data, then one of the other datastores might be a better fit.
A relational database is an excellent choice for query flexibility.
While PostgreSQL requires you to design your data up front, it makes no assumptions on how you use that data.
As long as your schema is designed in a fairly normalized way, without duplication or storage of computable values, you should generally be all set for any queries you might need to create.
And if you include the correct modules, tune your engine, and index well, it will perform amazingly well for multiple terabytes of data with very small resource consumption.
Finally, to those for whom data safety is paramount, PostgreSQL’s ACID-compliant transactions ensure your commits are completely atomic, consistent, isolated, and durable.
Riak Anyone who has worked construction knows that rebar is a steel beam used to reinforce concrete.
Just like Riak (“Ree-ahck”), you never use only one, but the multiple parts working together make the overall system durable.
Each component is cheap and expendable, but when used right, it’s hard to find a simpler or stronger structure upon which to build a foundation.
Riak is a distributed key-value database where values can be anything—from plain text, JSON, or XML to images or video clips—all accessible through a simple HTTP interface.
Servers can go up or down at any moment with no single point of failure.
Your cluster continues humming along as servers are added, removed, or (ideally not) crash.
Riak won’t keep you up nights worrying about your cluster—a failed node is not an emergency, and you can wait to deal with it in the morning.
As core developer Justin Sheehy once noted, “[The Riak team] focused so hard on things like write availability…to go back to sleep.”
Riak lacks robust support for ad hoc queries, and key-value stores, by design, have trouble linking values together (in other words, they have no foreign keys)
Riak attacks these problems on several fronts, which we’ll discover in the next few days.
Riak speaks web better than any other database we’ll see in this book (though CouchDB is a close second)
You query via URLs, headers, and verbs, and Riak returns assets and standard HTTP response codes.
Since the goal of this book is to investigate seven databases and their concepts, and not teach new programming languages, we try to avoid introducing new languages where possible.
Riak supplies an HTTP REST interface, so we’re going to interact with it via the URL tool cURL.
In production, you’ll almost always use a driver in your language of choice.
Using cURL allows us to peek at the underlying API without resorting to a particular driver or programming language.
Riak is a great choice for datacenters like Amazon that must serve many requests with low latency.
If every millisecond spent waiting is a potential customer loss, Riak is hard to beat.
It’s easy to manage, easy to set up, and can grow with your needs.
If you’ve ever used Amazon Web Services, like SimpleDB or S3, you may notice some similarities in form and function.
In this chapter, we’ll investigate how Riak stores and retrieves values and how to tie data together using Links.
Then we’ll explore a data-retrieval concept used heavily throughout this book: mapreduce.
We’ll see how Riak clusters its servers and handles requests, even in the face of server failure.
Finally, we’ll look at how Riak resolves conflict that arises from writing to distributed servers, and we’ll look at some extensions to the basic server.
You can download and install a build of Riak provided by Basho2 (the company that funds its development), but we actually prefer to build this one since you get some preconfigured examples.
If you really don’t want to build it, just install a prebuilt version, and then grab the source code and extract the example dev servers.
Building Riak from source requires three things: Erlang, the source code, and general Unix build tools like Make.
We get the Riak source from its repository (link available via the Basho website—if you don’t have Git or Mercurial installed, you can download a zipped package)
All of the examples in this chapter were run on version 1.0.2
The Riak creators played Santa Claus for us new users, slipping a cool toy into our stockings.
In the same directory you built Riak, run this command:
If you have a server fail to start because a port is in use, don’t panic.
We should now have three Erlang processes running named beam.smp, representing individual Riak nodes (server instances), unaware of each other’s presence.
To create a cluster, we need to join the nodes using each server’s riak-admin command named join and point them to any other cluster node.
It doesn’t really matter which servers we point them at—in Riak, all nodes are equal.
Verify your servers are healthy by checking their stats in a web browser: http://localhost:8091/stats.
It may prompt you to download the file, which contains lots of information about the cluster.
Look for the ring_members property—it should contain all our node names and will be the same for each server.
This should be a list of the other servers in the ring.
It sounds like a mouthful of jargon, but it has become the de facto architecture of web applications, so it’s worth knowing.
If you don’t already have it installed, install the HTTP client program cURL.
We use it as our REST interface, because it’s easy to specify verbs (like GET and PUT) and HTTP header information (like Content-Type)
With the curl command, we speak directly to the Riak server’s HTTP REST interface without the need for an interactive console or, say, a Ruby driver.
You can validate the curl command works with Riak by pinging a node.
I tells cURL that we want only the header response.
Since Riak leverages HTTP URLs and actions, it uses HTTP headers and error codes.
The -X PUT parameter tells cURL that we want to perform an HTTP PUT action to store and retrieve on an explicit key.
The -H attribute sets the following text as HTTP header information.
In this case, we set the MIME content type to HTML.
Everything passed to -d (also known as the body data) is what Riak will add as a new value.
If you navigate to http://localhost:8091/riak/favs/db in a browser, you’ll get a nice message from yourself.
Riak is a key-value store, so it expects you to pass in a key to retrieve a value.
Riak breaks up classes of keys into buckets to avoid key collisions—for example, a key for java the language will not collide with java the drink.
We’re going to create a system to keep track of animals in a dog hotel.
We’ll start by creating a bucket of animals that contain each furry guest’s details.
The -v (verbose) attribute in the curl command outputs this header line.
We can view our list of buckets that have been created.
Optionally, you can return the set results with the ?returnbody=true parameter, which we’ll test by adding another animal, Polly:
If we aren’t picky about our key name, Riak will generate one when using POST.
The generated key will be in the header under Location—also note the 201 success code in the header.
A GET request (cURL’s default if left unspecified) to that location will retrieve the value.
If we’ve forgotten any of our keys in a bucket, we can get them all with keys=true.
You can also get them as a stream with keys=stream, which can be a safer choice for huge datasets—it just keeps sending chunks of keys array objects and ends with an empty array.
Links are metadata that associate one key to other keys.
The key to where this value links is in pointy brackets (<…>), followed by a semicolon and then a tag describing how the link relates to this value (it can be whatever string we like)
Our little dog hotel has quite a few (large, comfortable, and humane) cages.
To keep track of which animal is in what cage, we’ll use a link.
Cage 1 contains Polly by linking to her key (this also creates a new bucket named cages)
The cage is installed in room 101, so we set that value as JSON data.
In effect, the cage we’ve just created knows that Polly is inside it, but no changes have been made to Polly.
We can confirm this by pulling up Polly’s data and checking that there have been no changes to the Link headers.
You can have as many metadata Links as necessary, separated by commas.
What makes Links special in Riak is link walking (and a more powerful variant, linked mapreduce queries, which we investigate tomorrow)
Getting the linked data is achieved by appending a link spec to the URL that is structured like this: /_,_,_
The underscores (_) in the URL represent wildcards to each of the link criteria: bucket, tag, keep.
If you’re not familiar with reading the multipart/mixed MIME type, the Content-Type definition describes a boundary string, which denotes the beginning and end of some HTTP header and body data.
In our case, the data is what cage 1 links to: Polly Purebred.
You may have noticed that the headers returned don’t actually display the link information.
This is OK; that data is still stored under the linked-to key.
When link walking, we can replace the underscores in the link spec to filter only values we want.
To specify only following the animals bucket, replace the first underscore with the bucket name.
Or follow the cages next to this one by populating the tag criteria.
It will return only Polly’s information, who is next to Ace’s cage.
Along with Links, you can store arbitrary metadata by using the X-Riak-Metaheader prefix.
If we wanted to keep track of the color of a cage but it wasn’t necessarily important in the day-to-day cage-managing tasks at hand, we could mark cage 1 as having the color pink.
Getting the URL’s header (the -I flag) will return your metadata name and value.
Riak stores everything as a binary-encoded value, just like normal HTTP.
The MIME type gives the binary data context—we’ve been dealing only with plain text up until now.
We’d like our dog hotel to keep images of our guests.
We need only use the data-binary flag on the curl command to upload an image to the server and specify the MIME type as image/jpeg.
We’ll add a link back to the /animals/polly key so we know who we are looking at.
First, create an image called polly_image.jpg and place it in the same directory you’ve been using to issue the curl commands.
Now visit the URL in a web browser, which will be delivered and rendered exactly as you’d expect any web client-server request to function.
Since we pointed the image to /animals/polly, we could link walk from the image key to Polly but not vice versa.
Unlike a relational database, there is no “has a” or “is a” rule concerning links.
If we believe our use case will require accessing image data from the animals bucket, a link should exist on that object instead (or in addition)
We hope you’re seeing a glimmer of Riak’s potential as a flexible storage option.
So far, we’ve covered only standard key-value practice with some links thrown in.
When designing a Riak schema, think somewhere in between a caching system and PostgreSQL.
You will break up your data into different logical classifications (buckets), and values can tacitly relate to each other.
But you will not go so far as to normalize into fine components like you would in a relational database, since Riak performs no sense of relational joins to recompose values.
Using PUT, update animals/polly to have a Link pointing to photos/polly.jpg.
Create a new bucket type called medicines, PUT a JPEG image value (with the proper MIME type) keyed as antibiotics, and link to the animal Ace (poor, sick puppy)
Today we’ll dive into the mapreduce framework to perform more powerful queries than the standard key-value paradigm can normally provide.
We’ll then expand on this power by including link walking with mapreduce.
Finally, we will investigate the server architecture of Riak and how it uses a novel server layout to provide flexibility in consistency or availability, even in the face of network partitions.
To achieve that, we’ll switch to an example using a different kind of hotel, one for people and not pets.
A quick populator script in Ruby will create data for a gigantic 10,000-room hotel.
If you are not familiar with Ruby, it is a popular general-purpose programming language.
It’s quite useful for writing quick scripts in a straightforward and readable manner.
Each room in our hotel will have a random capacity from one to eight people and be of a random style such as a single room or a suite.
One of Google’s greatest lasting contributions to computer science is the popularization of mapreduce as an algorithmic framework for executing jobs in parallel over several nodes.
It is described in Google’s seminal paper7 on the topic and has become a valuable tool for executing custom queries in the class of partition-tolerant datastores.
In one way, mapreduce is the opposite of how we normally run queries.
A Ruby on Rails system might grab data like this (via its ActiveRecord interface):
Room.all runs an SQL query against the backing database similar to this:
The database sends all of the results to the app server, and the app server code performs some action on that data.
In this case, we’re looping through each room in the hotel and then counting the total capacity for each room style (for example, the capacity of all the suites in the hotel may be 448 guests)
But as room count grows, the system slows as the database continues to stream each room’s data to the application.
Rather than grabbing data from the database and running it on a client (or app server), mapreduce is a pattern to pass an algorithm to all of the database nodes, which are then each responsible for returning a result.
Each object on the server is “mapped” to some common key that groups the data together, and then all matching keys are “reduced” into some single value.
The map function outputs feed into the reduce outputs and then to other reducers.
For Riak, that means the database servers are responsible for mapping and reducing the values on each node.
Those reduced values are passed around, where some other server (usually the requesting server) reduces those values further, until a final result is passed to the requesting client (or Rails application server, as the case may be)
This simple reversal is a powerful way to allow complex algorithms to run locally on each server and return a very small result to the calling client.
It’s faster to send the algorithm to the data and then send the data to the algorithm.
The results of map functions will populate reduce functions; however, a combination of the results of map and previous reduce function calls populate successive reduce functions.
We’ll revisit this idea in later chapters because it’s an important yet subtle component to the art of writing effective mapreduce queries.
Let’s create mapreduce functions for our Riak dataset that work like the previous hotel capacity counter.
A neat feature of Riak’s mapreduce is that you can run the map() function alone and see what all the results are mid-run (assuming you even want to run a reduce)
The map setting needs the language we’re using and the source code; only then do we actually write the JavaScript map function (the function is just a string, so we always need to escape any characters accordingly)
Using the @- command in cURL keeps the console’s standard input open until receiving CTRL+D.
This data will populate the HTTP body sent to the URL, which we post to the /mapred command (look carefully—the URL is /mapred, not /riak/mapred)
The /mapred command expects valid JSON, and here we specified the form of our mapreduce commands.
We choose the three rooms we want by setting the “inputs” value to be an array containing [bucket, key] pairs.
But the real meat of the settings is under the query value, which accepts an array of JSON objects containing objects, keyed by map, reduce, and/or links (more on links later)
We didn’t need to simply output the data as JSON.
We could have converted the value of each key value into anything we wanted.
We dug into the body data only but could have retrieved metadata, link information, the key, or data.
Anything is possible after that—we are mapping each key value into some other value.
If you feel up to it, you can return the maps of all 10,000 rooms by replacing the input-specific [bucket, key] arrays with the rooms bucket name, like this:
Finally, it’s worth mentioning that since Riak version 1.0, mapreduce functions are handled by a subsystem called Riak Pipe.
This should not affect you much as an end user, but it’s certainly a boost in speed and stability.
Another option Riak provides us with is to store the map function in a bucket value.
This is another example of moving the algorithm to the database.
This is a stored procedure or, more specifically, a user-defined function—of similar philosophy to those used in relational databases for years.
With your function safely stored, we’ll run the function by pointing to the new bucket and key containing the function.
You should receive the same results you received by putting the JavaScript source inline.
You can use some of Riak’s built-in functions attached to the JavaScript object Riak.
If you run the following code, your room objects will map the values into JSON and return them.
You can also use this syntax to call your own built-in functions, which is something we’ll investigate tomorrow.
Mapping is useful, but you’re limited to converting individual values into other individual values.
The SQL/Ruby example that we looked at earlier (in Introducing Mapreduce, on page 63) showed how each value could be iterated over and how capacity was totaled for each style of room.
We will perform this in our reduce function in JavaScript.
Most of the command we pass to /mapred will be the same.
Running this on all rooms should return total counts of capacity, keyed by room style.
Your totals won’t match the previous exactly, since we randomly generated room data.
A rather recent addition to Riak is the concept of key filters.
A key filter is a collection of commands that process each key before executing mapreduce.
It’s easier to write a reduce function if it follows the same pattern as your map function.
Since reducers can feed into other reducers, you don’t know whether the values you receive on any particular reduce function call will be populated by map output, reduce output, or a combination of both.
However, if they follow the same object pattern, you don’t need to care; they’re all the same! Otherwise, your reduce function must always check for the type of data it’s receiving and make a decision accordingly.
This shortcut saves the operation the pain of loading unwanted values.
In the following example, we’ll convert each room number key into an integer and check that it’s less than 1,000 (one of the first ten floors; any room over the tenth floor will be ignored)
You should notice two things: the query ran much faster (since we processed only the values we needed), and the totals were fewer (since we added only the first ten floors)
Mapreduce is a powerful tool for bundling data and performing some overarching analysis on it.
It’s a concept we’ll revisit often in this book, but the core concept is the same.
Riak has one slight tweak to the basic mapreduce form, and that’s the addition of links.
Today we’ll look at how to do the same thing using mapreduce.
The query section has one more value option along with map and reduce.
Let’s return to our cages bucket from yesterday’s dog hotel example and write a mapper that returns only cage 2 (remember, the one housing Ace the dog)
Both data and metadata (which would normally be returned in the HTTP header) appear under a values array.
Put map, reduce, link walking, and key filters together, and you can execute arbitrary queries on a wide array of Riak keys.
It’s considerably more efficient than scanning all data from a client.
Since these queries are generally run across several servers simultaneously, you should never have to wait long.
But if you really cannot wait, a query has one more option: timeout.
Riak server architecture removes single points of failure (all nodes are peers) and allows you to grow or shrink the cluster at will.
This is important when dealing with large-scale deployments, since it allows your database to remain available even if several nodes fail or are otherwise unresponsive.
Distributing data across several servers is saddled with an inherent problem.
If you want your database to continue running when a network partition occurs (meaning, some messages were lost), it means you must make a tradeoff.
Either you can remain available to server requests or you can refuse requests and ensure the consistency of your data.
It is not possible to create a distributed database that is fully consistent, available, and partition tolerant.
You can have only two (partition tolerant and consistent, partition tolerant and available, or consistent and available but not distributed)
This is known as the CAP theorem (Consistency, Availability, Partition tolerance)
The reality is that at any moment in time you cannot be consistent, available, and partition tolerant.
Riak takes advantage of this fact by allowing you to trade availability for consistency on a per-request basis.
We’ll first look at how Riak clusters its servers and then how to tune reads and writes to interact with the cluster.
The Riak team likes to represent this massive integer as a circle, which they call the ring.
When a key is hashed to a partition, the ring helps direct which Riak servers store the value.
One of the first decisions you’ll make when setting up a Riak cluster is how many partitions you’d like.
Let’s consider the case where you have 64 partitions (Riak’s default)
These vnodes are mapped to partitions of the 160-bit ring.
If you view the status of your three development servers.
Figure 8—“The Riak ring” of sixty-four vnodes, assigned across three physical nodes.
The second number of each object is the number of vnodes each node owns.
The benefit is that if we need to find which server the key lives on, Riak just hashes the key to find the corresponding vnode.
Specifically, Riak will convert the hash into a list of potential vnodes and use the first value.
Riak allows us to control reads and writes into the cluster by altering three values: N, W, and R.
If W is less than N, a write will be considered successful even while Riak is still copying the value.
Finally, R is the number of nodes required to read a value successfully.
If R is greater than the number of copies available, the request will fail.
This doesn’t mean we must wait for the value to replicate to all of those nodes in order to return.
Sometimes we just want our client to return immediately and let Riak replicate in the background.
Or sometimes we want to wait until Riak has replicated to all N nodes (just to be safe) before returning.
We can set the W value to the number of successful writes that must occur before our operation is considered a success.
Although we’re writing to four nodes eventually, if we set W to 2, a write operation will return after only two copies are made.
You can set a default R like we did earlier with n_val and w.
We may choose the number of nodes we want to read by setting an r parameter in the URL per request.
You may be asking yourself why we would ever need to read from more than one node.
After all, values we write will eventually be replicated to N nodes, and we can read from any of them.
You are free to set your R or W to any values between 1 and N but will generally want to stick with one, all, or a quorum.
These are such common values that R and W can accept string values representing them, defined in the following table:
Setting W or R means only one node need respond for the request to succeed.
Setting W or R to this means all replicated nodes must respond.
Setting W or R means most nodes must respond to succeed.
Whatever the W or R value is set for the bucket.
In addition to the previous values as valid bucket properties, you can also use them as query parameter values.
The danger with requiring reading from all nodes is that if one goes down, Riak may be unable to fulfill your request.
If your request cannot be fulfilled, you’ll get a 404 code (Object Not Found), which makes sense in the scope of the request.
That object cannot be found, because there aren’t enough copies to fulfill the URL request.
This isn’t a good thing, of course, so this kicks Riak to do a read repair: to request N replications of the key across the servers still available.
The online Riak docs have an excellent example8 using Erlang.
But a safer play is to require a quorum (data from most, but not all, vnodes)
As long as you write to a quorum, which you can force on a per-write basis, your reads should be consistent.
If you don’t want to wait for Riak to write to any nodes, you can set W to 0 (zero), which means “I trust you’ll write it, Riak; just return.”
All this power aside, much of the time you’ll want to stick with the default values unless you have a good reason.
Writes in Riak aren’t necessarily durable, meaning they aren’t immediately written to disk.
Although a node write may be considered successful, it’s still possible that a failure could occur where a node loses data; even if W=N, servers may fail and lose data.
A write is buffered in memory for a moment before being stored on disk, and that split millisecond is a danger zone.
The good news is Riak has provided us with a separate setting named DW for durable write.
Just like we did with writes, you can set this property on the bucket.
Here we’re setting dw to be one to be certain at least one node has stored our data.
Or, if you like, you can override this on a per-write basis using the dw query parameter in the URL.
Attempting to write to nodes that aren’t available still succeeds with a “204 No Content.” This is because Riak will write the value to a nearby node that holds that data until such a time that it can hand it to the unavailable node.
This is a fantastic safety net in the short-term, since if a server goes down, another Riak node will take over.
Of course, if all of server A’s requests get routed to server B, then server B is now dealing with double the load.
There is a danger this will cause B to fail, which might spread to C and D, and so on.
This is known as a cascading failure, and it’s rare but possible.
Consider this a fair warning not to tax every Riak server at full capacity, since you never know when one will have to pick up the slack.
Today you saw two of the biggest topics in Riak: the powerful mapreduce method and its flexible server clustering ability.
Find the Riak contrib functions repository, with lots of prebuilt mapreduce functions.
Find the online documentation for a complete list of key filters, which range from converting strings to_upper to finding numerical values between.
Today we delve into some of the edges of Riak.
We’ve seen how Riak is a simple key-value database across a cluster of servers.
When dealing with multiple nodes, data conflicts can occur, and sometimes we have to resolve them.
Riak provides a mechanism to sort out which writes happened most recently by way of vector clocks and sibling resolution.
We’ll also see how we can validate incoming data by way of pre- and postcommit hooks.
We’ll extend Riak into our own personal search engine with Riak search (with the SOLR interface) and faster queries with secondary indexing.
A vector clock11 is a token that distributed systems like Riak use to keep the order of conflicting key-value updates intact.
It’s important to keep track of which updates happen in what order, since several clients may connect to different servers, and while one client updates one server, another client updates another server (you can’t control which server you write to)
You may think “just timestamp the values and let the last value win,” but in a server cluster this works only if all server clocks are perfectly synchronous.
Riak makes no such requirement, since keeping clocks synchronized is at best difficult and in many cases an impossible requirement.
Using a centralized clock system would be anathema to the Riak philosophy, since it presents a single point of failure.
Vector clocks help by tagging each key-value event (create, update, or delete) with which client made the change, in which order.
This way, the clients, or application developer, can decide who wins in the case of conflict.
Let’s say that your dog hotel is doing well so you must start being more selective of the clientele.
To help make the best decision, you’ve gathered a panel of three animal experts to help decide which new dogs are a good fit.
All of these panelists—named Bob, Jane, and Rakshith—must reach a unanimous decision.
Each panelist has their own client connecting to a database server, and each client stamps a unique client ID onto each request.
This client ID is used to build the vector clock, as well as keep track of the last updating client in the object header.
Let’s look at a simple pseudocode example and later try the example in Riak.
Bob creates the object first, with a respectable score of 3 for a new puppy named Bruiser.
The vclock created for her update succeeded Bob’s, so her version 1 is added to the end of the vector.
Simultaneously, Rakshith pulled the version that Bob created but not Jane’s.
Later that day, Jane (as the panel chair) rechecks the scores.
Since Rakshith’s update vector did not occur after Jane’s but rather alongside hers, the updates are in conflict and need to be resolved.
She receives both values, and it’s up to her to resolve them.
Having been resolved, anyone who pulls a request after this point will get this most recent value.
For this example we want to see all conflicting versions so we can resolve them manually.
Let’s keep multiple versions by setting the allow_mult property on the animals bucket.
Here, Bob puts Bruiser in the system with his chosen score of 3 and a client ID of bob.
Jane and Rakshith both pull Bruiser’s data that Bob created (you’ll have much more header information; we’re just showing the vector clock here)
Note that Riak encoded Bob’s vclock, but under the covers it’s a client and a version (and timestamp, so yours will be different from the one shown)
Jane makes her update to score 2 and includes the most recent vector clock she received from Bob’s version.
This is a signal to Riak that her value is an update of Bob’s version.
Since Jane and Rakshith pulled Bob’s data at the same time, he also submits an update (of score 4) using Bob’s vector clock.
When Jane rechecks the score, she sees not a value, as expected, but rather an HTTP code for multiple choices and a body containing two “sibling” values.
Riak stored these versions in a multipart format, so she can retrieve the entire object by accepting that MIME type.
Now when Bob and Rakshith retrieve bruiser’s information, they’ll get the resolved score.
You may have noticed that the vector clock keeps growing as more clients update values.
This is a fundamental problem with vector clocks, which the Riak developers understood.
They extended vector clocks to be “pruned” over time, thus keeping their size small.
The rate at which Riak prunes old vector clock values are bucket properties, which can be viewed (along with all other properties) by reading the bucket.
You’ll see some of the following properties, which dictate how Riak will prune the clock before it gets too large.
You can read more about vector clocks and pruning online.12
Riak can transform data before or after saving an object, by way of hooks.
Pre- and post-commit hooks are simply JavaScript (or Erlang) functions that get executed before or after a commit occurs.
Pre-commit functions can modify the incoming object in some way (and even cause it to fail), while postcommits can respond to a successful commit (such as writing to a log or sending an email to something)
Each server has an app.config file, which needs to reference the location of any custom JavaScript code.
You’ll need to make this change in triplicate, once for each dev server.
Since we’re making core server changes, we need to restart all of the development servers using the restart argument.
Riak will scan for any files ending in .js and load those into memory.
You can now set a bucket’s precommit property to use the JavaScript function name (not the filename)
You’ll get a 403 Forbidden code, as well as a plain-text error message that was returned under the “fail” field.
Try setting the score to 2, and you’ll have more success.
Post-commit is similar to pre-commit but happens after the commit is successful.
We’re skipping it here, since you can write postcommit hooks only in Erlang.
If you’re an Erlang developer, the online docs can help guide you through installing your own modules.
But our Riak journey continues to other prebuilt modules and extensions.
Riak ships with several extensions that are turned off by default yet add new behaviors you may find useful.
Riak search scans data inside your Riak cluster and builds an inverted index against it.
You may recall the term inverted index from the PostgreSQL chapter (the GIN index stands for Generalized Inverted Index)
Just like GIN, the Riak index exists to make many varieties of string searching fast and efficient but in a distributed manner.
Using Riak search requires enabling it in your app.config files and setting the Riak search config to enabled, true.
If you’re familiar with search engine solutions such as Lucene, this part should be a cakewalk.
If not, it’s easy to get the hang of it.
We need to let the search know when we change values in the database by way of a pre-commit hook.
Calling curl http://localhost:8091/riak/animals will show that the hook has been added to the animals bucket’s precommit property.
Now, when you put data that is encoded as JSON or XML into the animals bucket, Riak search will index the field names and values.
There are several options for querying this data, but let’s use Riak’s HTTP Solr interface (which implements the Apache Solr13 search interface)
To search /animals, we access /solr, followed by the bucket name /animals and the /select command.
Here we select any breed that contains the word Shepherd.
If you prefer that the query returns JSON, add the parameter wt=json.
You can combine multiple parameters in the query by separating them with a space (or %20 in URL-encoded form) and setting the q.op parameter with the value and.
To find a breed with a nickname containing the word rin and a breed of shepherd, perform the following:
Riak search allows for more colorful query syntaxes, such as wildcards (using * to match multiple characters and using ? to match one character), though only at the end of the term.
More-complex queries based on boolean operators, grouping, and proximity searches are available.
Beyond that, you can specify custom data encodings, create custom indexes, and even choose between them when you search.
You can find other URL parameters in the following table:
There is plenty more to learn about the Riak search extension, far more than we can reasonably cover here.
It’s a clear choice if you plan to provide search functionality for a large web application, but it also deserves a second look if you need a lot of simple ad hoc querying.
These are similar to the indexes we saw in PostgreSQL but with a slight twist.
Rather than indexing on a specific column or columns of data, Riak allows you to index on metadata attached to the header of the object.
Once again, we must make a change to the app.config file.
Switch the storage back end from bitcask to eLevelDB, as shown here, and then restart the servers:
With our system ready to go, we can index any object with any number of header tags known as an index entries that define how an object is indexed.
To add Blue II, the Butler Bulldogs mascot, we’d like to index by the university name that this dog is a mascot for (butler), as well as the version number (Blue 2 is the second bulldog mascot)
You may have noticed that the indexes have nothing to do with the value stored in the key.
This is actually a powerful feature, since it allows us to index data orthogonal to any data we may store.
If you want to store a video as a value, you may still index it.
Though secondary indexing in Riak is a big step in the right direction, it still has a way to go.
If you want to index dates, for example, you must store a string that can be sorted in order—such as "YYYYMMDD"
But between mapreduce, Riak search, and now secondary indexing, Riak is providing many tools to loosen up the classic constraints of the key-value store design by other means of value access beyond simple keys.
We finished Riak with some of its more advanced concepts: how to deal with version conflicts by using vector clocks and how to ensure or modify incoming data with commit hooks.
We also dug into using a couple Riak extensions: activating Riak search and indexing data to allow for a little more query flexibility.
Find the Riak function contrib list repository (hint: it’s in GitHub)
Install the Google stock dataset, located on the Basho website.16
It is a distributed, datareplicating, enhanced key-value store without a single point of failure.
If your experience with databases until now has been only relational, Riak may seem like an alien beast.
There are keys, but linking between buckets is not at all like a table join, and mapreduce can be a daunting methodology to grok.
The trade-offs, however, are worth it for a certain class of problems.
Riak’s ability to scale out with more servers (rather than scale up with larger single servers) and its ease of use are excellent attempts at solving the unique scalability problems of the Web.
And rather than reinventing the wheel, Riak piggybacks on the HTTP structure, allowing maximum flexibility for any framework or web-enabled system.
If you want to design a large-scale ordering system a la Amazon, or in any situation where high availability is your paramount concern, you should consider Riak.
Hands down, one of Riak’s strengths lies in its focus on removing single points of failure in an attempt to support maximum uptime and grow (or shrink) to meet changing demands.
If you do not have complex data, Riak keeps things simple but still allows for some pretty sophisticated data diving should you need it.
There is currently support for about a dozen languages (which you can find on the Riak website) but is extendable to its core if you like to write in Erlang.
And if you require more speed than HTTP can handle, you can also try your hand at communicating via Protobuf,17 which is a more efficient binary encoding and transport protocol.
If you require simple queryability, complex data structures, or a rigid schema or if you have no need to scale horizontally with your servers, Riak is probably not your best choice.
One of our major gripes about Riak is it still lags in terms of an easy and robust ad hoc querying framework, although it is certainly on the right track.
Mapreduce provides fantastic and powerful functionality, but we’d like to see more built-in URL-based or other PUT query actions.
The addition of indexing was a major step in the right direction and a concept we’d love to see expanded upon.
Erlang, you may see a few limitations using JavaScript, such as the unavailability of post-commit or slower mapreduce execution.
However, the Riak team is working on these relatively minor hiccups.
Riak provides a clever way of circumventing the constraints that CAP places on all distributed databases.
How it dances around the problem is astounding, compared to a system like PostgreSQL that can (largely) only support strong write consistency.
Riak leverages the Amazon Dynamo paper’s insight that CAP can be changed on a per-bucket, or per-request, basis.
It’s a big step forward for robust and flexible open source database systems.
As you read about other databases in this book, keep Riak in mind, and you’ll continue to be impressed by its flexibility.
If you need to store a huge catalog of data, you could do worse than Riak.
Though relational databases have been researched and tweaked for more than forty years, not every problem needs ACID compliance or the ability to enforce a schema.
If you want to embed a database into a device or handle financial transactions, you should avoid Riak.
If you want to scale out or serve up loads of data on the Web, take a look.
HBase Apache HBase is made for big jobs, like a nail gun.
You would never use HBase to catalog your corporate sales list, just like you’d never use a nail gun to build a dollhouse.
If your data is not measured by many gigabytes, you probably need a smaller tool.
HBase, at first glance, looks a lot like a relational database—so much so that if you didn’t know any better, you might think that it is one.
The most challenging part of learning HBase isn’t the technology; it’s that many of the words used in HBase are coaxingly, deceptively familiar.
For example, HBase stores data in buckets it calls tables, which contain cells that appear at the intersection of rows and columns.
Wrong! In HBase, tables don’t behave like relations, rows don’t act like records, and columns are completely variable (not enforced by a schema description)
Schema design is still important, since it informs the performance characteristics of the system, but it won’t keep your house in order.
HBase is the evil twin, the bizarro, if you will, of RDBMS.
So, why would you use this database? Aside from scalability, there are a few reasons.
First, HBase has some built-in features that other databases lack, such as versioning, compression, garbage collection (for expired data), and in-memory tables.
Having these features available right out of the box means less code that you have to write when your requirements demand them.
HBase also makes strong consistency guarantees, making it easier to transition from relational databases.
For all of these reasons, HBase really shines as the cornerstone of an online analytics processing system.
While individual operations may be slower than equivalent operations in other databases, scanning through enormous datasets is something HBase takes to with relish.
This also explains why HBase is often employed at big companies to back logging and search systems.
HBase is a column-oriented database that prides itself on consistency and scaling out.
On the architecture front, HBase is designed to be fault tolerant.
Hardware failures may be uncommon for individual machines, but in a large cluster, node failure is the norm.
By using write-ahead logging and distributed configuration, HBase can quickly recover from individual server failures.
Additionally, HBase lives in an ecosystem that has its own complementary benefits.
HBase is built on Hadoop—a sturdy, scalable computing platform that provides a distributed file system and mapreduce capabilities.
Wherever you find HBase, you’ll find Hadoop and other infrastructural components that you can lever in your own applications.
It is actively used and developed by a number of high-profile companies for their “Big Data” problems.
Stumbleupon has been using HBase for real-time data storage and analytics for several years, serving various site features directly from HBase.
The parade of companies using HBase also includes the likes of eBay, Meetup, Ning, Yahoo!, and many others.
With all of this activity, new versions of HBase are coming out at a fairly rapid clip.
At the time of this writing, the current stable version is 0.90.3, so that’s what we’ll be using.
Today’s goal is to learn the nuts and bolts of working with HBase.
We’ll get a local instance of HBase running in stand-alone mode, and then we’ll use.
After that, we’ll explore how to perform some of those operations programmatically by using the HBase Java API in JRuby.
Along the way, we’ll uncover some HBase architectural concepts, such as the relationship between rows, column families, columns, and values in a table.
A fully operational, production-quality HBase cluster should really consist of no fewer than five nodes, or so goes the conventional wisdom.
Pseudodistributed mode is a single node pretending to be a cluster.
Fully distributed mode is a cluster of nodes working together.
For most of this chapter, we’ll be running HBase in stand-alone mode.
Even that can be a bit of a challenge, so although we won’t cover every aspect of installation and administration, we’ll give some relevant troubleshooting tips where appropriate.
You can add any number of property definitions to your configuration using this format:
By default, HBase uses a temporary directory to store its data files.
This means you’ll lose all your data whenever the operating system decides to reclaim the disk space.
To keep your data around, you should specify an involatile storage location.
Set the hbase.rootdir property to an appropriate path like so:
To start HBase, open a terminal (command prompt) and run this command:
To shut down HBase, use the stop-hbase.sh command in the same directory.
The HBase shell is a JRuby-based command-line program you can use to interact with HBase.
In the shell, you can add and remove tables, alter table schema, add or delete data, and do a bunch of other tasks.
Later we’ll explore other means of connecting to HBase, but for now the shell will be our home.
With HBase running, open a terminal and fire up the HBase shell:
To confirm that it’s working properly, try asking it for version information.
You can enter help at any time to see a list of available commands or to get usage information about a particular command.
Next, execute the status command to see how your HBase server is holding up.
If an error occurs for any of these commands or if the shell hangs, it could be a connection problem.
HBase does its best to automatically configure its services based on your network setup, but sometimes it gets it wrong.
A map is a key-value pair, like a hash in Ruby or a hashmap in Java.
By default, HBase tries to make its services available to external clients, but in our case, we simply need to connect from the same machine.
So, it might help to add some or all of the following properties to your hbase-site.xml file (your mileage may vary)
Note that the values in the following table will help only if you plan to connect locally and not remotely:
The properties tell HBase how to establish connections for the master server and region servers (both of which we’ll discuss later) and the zookeeper configuration service.
The properties with the value “lo” refer to the so-called loopback interface.
On *nix systems, the loopback interface is not a real network interface (like your Ethernet or wireless cards) but rather a software-only interface for the computer to use to connect to itself.
The bindAddress properties tell HBase what IP address to try to listen on.
In an HBase table, keys are arbitrary strings that each map to a row of data.
A row is itself a map, in which keys are called columns and values are uninterpreted arrays of bytes.
Columns are grouped into column families, so a column’s full name consists of two parts: the column family name and the column qualifier.
In this figure, we have a hypothetical table with two column families: color and shape.
The table has two rows—denoted by dashed boxes—identified by their row keys: first and second.
Looking at just the first row, we see that it has three columns in the color column family (with qualifiers red, blue, and yellow) and one column in the shape column family (square)
The combination of row key and column name (including both family and qualifier) creates an address for locating data.
In this example, the tuple first/color:red points us to the value '#F00'
Now let’s take what we’ve learned about table structure and use it to do something fun—we’re going to make a wiki!
Figure 13—HBase tables consist of rows, keys, column families, columns, and values.
There are lots of juicy info bits we might want to associate with a wiki, but we’ll start with the bare minimum.
A wiki contains pages, each of which has a unique title string and contains some article text.
Here, we’re creating a table called wiki with a single column family called text.
The table is currently empty; it has no rows and thus no columns.
Unlike a relational database, in HBase a column is specific to the row that contains it.
When we start adding rows, we’ll add columns to store data at the same time.
By our own convention, we expect each row to have exactly one column within the text family, qualified by the empty string ('')
So, the full column name containing the text of a page will be 'text:'
Of course, for our wiki table to be useful, it’s going to need content.
Our wiki needs a Home page, so we’ll start with that.
To add data to an HBase table, use the put command:
This command inserts a new row into the wiki table with the key 'Home', adding 'Welcome to the wiki!' to the column called 'text:'
We can query the data for the 'Home' row using get, which requires two parameters: the table name and the row key.
You can optionally specify a list of columns to return.
When a new value is written to the same cell, the old value hangs around, indexed by its timestamp.
Most databases require you to specifically handle historical data yourself, but in HBase, versioning is baked right in!
Facebook uses HBase as a principal component of its messaging infrastructure, both for storing message data and for maintaining an inverted index for search.
Column qualifiers are words that appear in that user’s messages.
Timestamps are message IDs of messages that contain that word.
Since messages between users are immutable, the index entries for a message are static as well.
For Facebook, manipulating the timestamp to match message IDs gives them another dimension for storing data.
The put and get commands allow you to specify a timestamp explicitly.
If using milliseconds since the epoch doesn’t strike your fancy, you can specify another integer value of your choice.
This gives you an extra dimension to work with if you need it.
If you don’t specify a timestamp, HBase will use the current time when inserting, and it will return the most recent version when reading.
In the rest of this chapter, we’ll continue to use the default timestamp interpretation.
So far, our wiki schema has pages with titles, text, and an integrated version history but nothing else.
In our wiki, a page is uniquely identified by its title.
A revision was made by an author, identified by name.
In this abstract representation of our requirements for a page, we see that each revision has an author, a commit comment, some article text, and a timestamp.
Our wiki table uses the title as the row key and will group other page data into two column families called text and revision.
The text column family is the same as before; we expect each row to have exactly one column, qualified by the empty string (''), to hold the article contents.
The job of the revision column family is to hold other revision-specific data, such as the author and commit comment.
We created the wiki table with no special options, so all the HBase default values were used.
One such default value is to keep only three VERSIONS of column values, so let’s increase that.
To make schema changes, first we have to take the table offline with the disable command.
Now we can modify column family characteristics using the alter command.
Here, we’re instructing HBase to alter the text column family’s VERSIONS attribute.
The hbase* line means that it’s a continuation of the previous line.
Operations that alter column family characteristics can be very expensive because HBase has to create a new column family with the chosen specifications and then copy all the data over.
For this reason, settling on column family options up front is a good thing.
With the wiki table still disabled, let’s add the revision column family, again using the alter command:
Just as before, with the text family, we’re only adding a revision column family to the table schema, not individual columns.
Though we expect each row to eventually contain a revision:author and revision:comment, it’s up to the client to honor this expectation; it’s not written into any formal schema.
If someone wants to add a revision:foo for a page, HBase won’t stop them.
Now that our wiki table has been modified to support our growing requirements list, we can start adding data to columns in the revision column family.
As we’ve seen, the HBase shell is great for tasks such as manipulating tables.
The put command only allows setting one column value at a time, and in our newly updated schema, we need to add multiple column values simultaneously so they all share the same timestamp.
The following script can be executed directly in the HBase shell, since the shell is also a JRuby interpreter.
When run, it adds a new version of the text for the Home page, setting the author and comment fields at the same time.
JRuby runs on the Java virtual machine (JVM), giving it access to the HBase Java code.
The import lines bring references to useful HBase classes into the shell.
This saves us from having to write out the full namespace later.
Next, the jbytes() function takes any number of arguments and returns an array converted to Java byte arrays, as the HBase API methods demand.
After that, we create a local variable (table) pointing to our wiki table, using the @hbase administration object for configuration information.
Next we stage a commit operation by creating and preparing a new instance of Put, which takes the row to be modified.
In this case, we’re sticking with the Home page we’ve been working with thus far.
Finally, we add() properties to our Put instance and then call on the table object to execute the put operation we’ve prepared.
You may be tempted to build your whole structure without column families; why not store all of a row’s data in a single column family? That solution would be simpler to implement.
But there are downsides to avoiding column families, namely, missing out on fine-grained performance tuning.
These settings affect things such as read and write speed and disk space consumption.
All operations in HBase are atomic at the row level.
No matter how many columns are affected, the operation will have a consistent view of the particular row being accessed or modified.
This design decision helps clients reason intelligently about the data.
Our put operation affects several columns and doesn’t specify a timestamp, so all column values will have the same timestamp (the current time in milliseconds)
As you can see, each column value listed previously has the same timestamp.
Today, we got a firsthand look at a running HBase server.
We learned how to configure it and monitor log files for troubleshooting.
Using the HBase shell, we performed basic administration and data manipulation tasks.
In modeling a wiki system, we explored schema design in HBase.
We learned how to create tables and manipulate column families.
Designing an HBase schema means making choices about column family options and, just as important, our semantic interpretation of features like timestamps and row keys.
We also started poking around in the HBase Java API by executing JRuby code in the shell.
In Day 2, we’ll take this a step further, using the shell to run custom scripts for big jobs like data import.
Ideally you’ve begun to shrug off some of the relational concepts that burden terms such as table, row, and column.
The difference between how HBase uses these terms and what they mean in other systems will become even starker as we explore deeper into HBase’s features.
HBase documentation online generally comes in two flavors: extremely technical and nonexistent.
This is slowly changing as “getting started” guides start to appear, but be prepared to spend some time trolling through Javadoc or source code to find answers.
Figure out how to use the shell to do the following:
Bookmark the HBase API documentation for the version of HBase you’re using.
Create a function called put_many() that creates a Put instance, adds any number of column-value pairs to it, and commits it to a table.
Define your put_many() function by pasting it in the HBase shell, and then call it like so:
With Day 1’s table creation and manipulation under our belts, it’s time to start adding some serious data to our wiki table.
Today, we’ll script against the HBase APIs, ultimately streaming Wikipedia content right into our wiki! Along the way, we’ll pick up some performance tricks for making faster import jobs.
Finally, we’ll poke around in HBase’s internals to see how it partitions data into regions, achieving both performance and disaster recovery goals.
One common problem people face when trying a new database system is how to migrate data into it.
Handcrafting Put operations with static strings, like we did in Day 1, is all well and good, but we can do better.
Fortunately, pasting commands into the shell is not the only way to execute them.
When you start the HBase shell from the command line, you can specify the name of a JRuby script to run.
HBase will execute that script as though it were entered directly into the shell.
Since we’re interested specifically in “Big Data,” let’s create a script for importing Wikipedia articles into our wiki table.
These dumps are in the form of enormous XML files.
Because we were so smart, this contains all the information we’ve already accounted for in our schema: title (row key), text, timestamp, and author.
So, we ought to be able to write a script to import revisions without too much trouble.
We’ll need to parse the huge XML files in a streaming (SAX) fashion, so let’s start with that.
The basic outline for parsing an XML file in JRuby, record by record, looks like this:
Breaking this down, there are a few parts worth mentioning.
Next, we set up a while loop, which will continuously pull out tokens from the XML stream until there are none left.
What to do depends on whether the token is the start of an XML tag, the end of a tag, or the text in between.
Now we can combine this basic XML processing framework with our previous exploration of the HTable and Put interfaces.
Most of it should look familiar, and we’ll discuss a few novel parts.
The first difference of note is the introduction of a few variables:
This allows us to batch up writes and execute them when it’s convenient for us.
If the start tag is a <page>, then reset document to an empty hash.
Otherwise, if it’s another tag we care about, reset buffer for storing its text.
We handle character data by appending it to the buffer.
For most closing tags, we just stash the buffered contents into the document.
If the closing tag is a </revision>, however, we create a new Put instance, fill it with the document’s fields, and submit it to the table.
After that, we use flushCommits() if we haven’t done so in a while and report progress to standard out (puts)
We’re almost ready to run the script; we just have one more bit of housecleaning to do first.
The text column family is going to contain big blobs of text content; it would benefit from some compression.
The HBase community highly recommends using LZO over Gzip, pretty much unilaterally, but here we’re using GZ.
While open source, it’s not compatible with Apache’s licensing philosophy, so LZO can’t be bundled with HBase.
Detailed instructions are available online for installing and configuring LZO support.
A Bloom filter is a really cool data structure that efficiently answers the question, “Have I ever seen this thing before?” Originally developed by Burton Howard Bloom in 1970 for use in spell-checking applications, Bloom filters have become popular in data storage applications for determining quickly whether a key exists.
The number of columns within a column family and the number of rows are both potentially unbounded.
Bloom filters offer a fast way of determining whether data exists before incurring an expensive disk read.
Remember that these files are enormous, so downloading and unzipping them is pretty much out of the question.
Fortunately, through the magic of *nix pipes, we can download, extract, and feed the XML into the script all at once.
These files contain all the most recent revisions of pages in the Main namespace.
That is, they omit user pages, discussion pages, and so on.
Plug in the URL and run it! You should see output like this (eventually):
Determining which bits to flip depends on generating a hash from the data and turning that hash into a set of bit positions.
Later, to test whether the filter has been presented with a particular blob in the past, the filter figures out which bits would have to be 1 and checks them.
This is the trade-off of using a Bloom filter as opposed to a simple hash.
A hash will never produce a false positive, but the space needed to store that data is unbounded.
Bloom filters use a constant amount of space but will occasionally produce false positives at a predictable rate based on saturation.
It’ll happily chug along as long as you let it or until it encounters an error, but you’ll probably want to shut it off after a while.
For now, though, let’s leave it running so we can take a peek under the hood and learn about how HBase achieves its horizontal scalability.
In HBase, rows are kept in order, sorted by the row key.
A region is a chunk of rows, identified by the starting key (inclusive) and ending key (exclusive)
Regions never overlap, and each is assigned to a specific region server in the cluster.
In our simplistic stand-alone server, there is only one region server, which will always be responsible for all regions.
A fully distributed cluster would consist of many region servers.
So, let’s take a look at your HBase server’s disk usage, which will give us insight into how the data is laid out.
You can inspect HBase’s disk usage by opening a command prompt to the hbase.rootdir location you specified earlier and executing the du command.
The -h option tells du to report numbers in human-readable form.
Here’s what ours looked like after about 12,000 pages had been inserted and the import was still running:
This output tells us a lot about how much space HBase is using and how it’s allocated.
The lines starting with /wiki describe the space usage for the wiki table.
Under that, the directories /text and /revision correspond to the text and revision column families, respectively.
Finally, the last line sums up all these values, telling us that HBase is using 365MB of disk space.
The first two lines at the top of output, starting with /.logs, show us the space used by the write-ahead log (WAL) files.
HBase uses writeahead logging to provide protection against node failures.
For instance, write-ahead logging in file systems is called journaling.
In HBase, logs are appended to the WAL before any edit operations (put and increment) are persisted to disk.
For performance reasons, edits are not necessarily written to disk immediately.
The system does much better when I/O is buffered and written to disk in chunks.
If the region server responsible for the affected region were to crash during this limbo period, HBase would use the WAL to determine which operations were successful and take corrective action.
Writing to the WAL is optional and enabled by default.
Edit classes like Put and Increment have a setter method called setWriteToWAL() that can be used to exclude the operation from being written to the WAL.
Generally you’ll want to keep the default option, but in some instances it might make sense to change it.
For example, if you’re running an import job that you can rerun.
If you let the script run long enough, you’ll see HBase split the table into multiple regions.
Here’s our du output again, after about 150,000 pages have been added:
In our stand-alone server, all the regions are served by our singular server, but in a distributed environment, these would be parceled out to the various region servers.
This raises a few questions, such as “How do the region servers know which regions they’re responsible for serving?” and “How can you find which region (and, by extension, which region server) is serving a given row?”
If we drop back into the HBase shell, we can query the .META.
Even for a small number of regions, you should get a lot of output.
Here’s a fragment of ours, formatted and truncated for readability:
The first region starts at the empty string row ('') and ends with 'Demographics of Macedonia'
The second region starts at 'Demographics of Macedonia' and goes to 'June 30'
So, if we were looking for the 'Demographics of Macedonia' row, we’d find it in the second region.
Since rows are kept in sorted order, we can use the information stored in .META.
To find out which servers have which parts of the .META.
The master server can also be a region server, performing both duties simultaneously.
When a region server fails, the master server steps in and reassigns responsibility for regions previously assigned to the failed node.
The new stewards of those regions would look to the WAL to see what, if any, recovery steps are needed.
If the master server fails, responsibility defers to any of the other region servers that step up to become the master.
Providing you’ve stopped the import script from running, we can move on to the next task: extracting information from the imported wiki contents.
Wiki syntax is filled with links, some of which link internally to other articles and some of which link to external resources.
Our goal is to capture the relationships between articles as directional links, pointing one article to another or receiving a link from another.
For example, if the text of the article on Star Wars contains the string "[[Yoda|jedi master]]", we want to store that relationship twice—once as an outgoing link from Star Wars and once as an incoming link to Yoda.
Storing the relationship twice means that it’s fast to look up both a page’s outgoing links and its incoming links.
The TABLE schema has been removed from the example output of regioninfo scans.
This reduces clutter, and we’ll be talking about performance-tuning options later.
If you’re dying to see the schema definition for a table, use the describe command.
To store this additional link data, we’ll create a new table.
In principle, we could have chosen to shove the link data into an existing column family or merely added one or more additional column families to the wiki table, rather than create a new one.
Creating a separate table has the advantage that the tables have separate regions.
This means that the cluster can more effectively split regions as necessary.
The general guidance for column families in the HBase community is to try to keep the number of families per table down.
You can do this either by combining more columns into the same families or by putting families in different tables entirely.
The choice is largely decided by whether and how often clients will need to get an entire row of data (as opposed to needing just a few column values)
In our wiki case, we need the text and revision column families to be on the same table so that when we put new revisions in, the metadata and the text share the same timestamp.
The links content, by contrast, will never have the same timestamp as the article from which the data came.
Further, most client actions will be interested either in the article text or in the extracted information about article links but probably not in both at the same time.
So, splitting out the to and from column families into a separate table makes sense.
With the links table created, we’re ready to implement a script that will scan all the rows of the wiki table.
Then, for each row, retrieve the wikitext and parse out the links.
The bulk of this script should be pretty familiar to you by now.
Most of the pieces are recycled, and we’ll discuss the few novel bits.
First, we grab a Scan object, which we’ll use to scan through the wiki table.
Extracting row and column data requires some byte wrangling but generally isn’t too bad either.
Each time the linkpattern appears in the page text, we extract the target article and text of the link and then use those values to add to our Put instances.
Finally, we tell the table to execute our accumulated Put operations.
It’s possible (though unlikely) for an article to contain no links at all, which is the reason for the if put_to clause.
Since this exercise is for educational purposes and since we could simply rerun the script if anything went wrong, we’ll take the speed bonus and accept our fate should the node fail.
If you’re ready to throw caution to the wind with reckless abandon, kick off the script.
As with the previous script, you can let it run as long as you like, even to completion.
You can monitor the disk usage of the script using du as we’ve done before.
You’ll see new entries for the links table we just created, and the size counts will increase as the script runs.
Couldn’t We Have Done This with Mapreduce? In the introduction, we explained that our examples would be in (J)Ruby and JavaScript.
JRuby does not play nice with Hadoop, but if you wanted to use mapreduce using Java, you’d have written this scanner code as a mapreduce job and sent it off to Hadoop.
Generally speaking, tasks like this are ideally suited for a mapreduce implementation.
There’s a bulk of input in a regular format to be handled by a mapper (scanning an HBase table) and a bulk of output operations to be executed in batches by a reducer (writing rows out to an HBase table)
The Hadoop architecture expects Job instances to be written in Java and wholly encapsulated (including all dependencies) into a jar file that can be sent out to all the nodes of the cluster.
Newer versions of JRuby can extend Java classes, but the version that ships with HBase can’t.
There are a few open source projects that provide a bridge for running JRuby on Hadoop but nothing yet that specifically works well with HBase.
There are rumors that in the future the HBase infrastructure will contain abstractions to make JRuby MR (mapreduce) jobs possible.
We just created a scanner programmatically to perform a sophisticated task.
Now we’ll use the shell’s scan command to simply dump part of a table’s contents to the console.
For each link the script finds in a text: blob, it will indiscriminately create both to and from entries in the links table.
To see the kinds of links being created, head over to the shell and scan the table.
Of course, you can use the get command to see the links for just a single article.
In the wiki table, the rows are very regular with respect to columns.
As you recall, each row has text:, revision:author, and revision:comment columns.
And the variety of column names is as diverse as the row keys themselves (titles of Wikipedia articles)
That’s OK! HBase is a so-called sparse data store for exactly this reason.
To find out just how many rows are now in your table, you can use the count command.
Because of its distributed architecture, HBase doesn’t immediately know how many rows are in each table.
To find out, it has to count them (by performing a table scan)
Fortunately, HBase’s region-based storage architecture lends itself to fast distributed scanning.
So, even if the operation at hand requires a table scan, we don’t have to worry quite as much as we would with other databases.
Whew, that was a pretty big day! We learned how to write an import script for HBase that parses data out of a stream of XML.
Then we used those techniques to stream Wikipedia dumps directly into our wiki table.
Along those lines, we discussed some HBase architectural features such as disaster recovery, provided via the write-ahead log.
Speaking of architecture, we discovered table regions and how HBase divvies up responsibility for them among the region servers in the cluster.
Finally, we discussed some of the performance implications of HBase’s sparse design.
In so doing, we touched on some community best practices regarding the use of columns, families, and tables.
Find a discussion or article describing the pros and cons of compression in HBase.
Find an article explaining how Bloom filters work in general and how they benefit HBase.
Aside from which algorithm to use, what other column family options relate to compression?
How does the type of data and expected usage patterns inform column family compression options?
Expanding on the idea of data import, let’s build a database containing nutrition facts.
Create a new table called foods with a single column family to store the facts.
What should you use for the row key? What column family options make sense for this data?
Create a new JRuby script for importing the food data.
Use the SAX parsing style we used earlier for the Wikipedia import script and tailor it for the food data.
Pipe the food data into your import script on the command line to populate the table.
Finally, using the HBase shell, query the foods table for information about your favorite foods.
Our experimentation so far has focused on accessing a single local server.
In reality, if you choose to use HBase, you’ll want to have a good sized cluster in order to realize the performance benefits of its distributed architecture.
Here in Day 3, we’ll turn our attention toward operating and interacting with a remote HBase cluster.
First we’ll develop a client application in Ruby and connect to our local server using a binary protocol called Thrift.
Then we’ll bring up a multinode cluster with a cloud service provider—Amazon EC2using a cluster management technology called Apache Whirr.
So far, we’ve been using the HBase shell, but HBase supports a number of protocols for client connectivity.
In the previous table, the connection method describes whether the protocol makes Java calls directly, shuttles data over HTTP, or moves data using a compact binary format.
All of them are production-grade, except for Avro, which is relatively new and should be treated as experimental.
Of all these options, Thrift is probably the most popular for developing client applications.
A mature binary protocol with little overhead, Thrift was originally developed and open sourced by Facebook, later to become an Apache Incubator project.
Like many things in the database realm, working with Thrift requires a little setup.
To connect to our HBase server via Thrift, we’ll need to do the following:
We’ll start by running the Thrift service, which is pretty easy.
The steps for this depend greatly on your particular environment and generally require compiling binaries.
To test whether you have this installed correctly, call it on the command line with the -version flag.
For the client language, we’ll use Ruby, although the steps are similar for other languages.
Install the Thrift Ruby gem on the command line like so:
To check whether the gem is installed correctly, we can run this Ruby oneliner:
If you see no output on the command line, that’s good! An error message stating “no such file to load” means you should stop here and troubleshoot before moving on.
These model files will be the glue that connects our specific HBase version with the particular Thrift version you have installed, so they have to be generated (rather than coming premade)
With the path identified, generate the model files with the following command, replacing your path as indicated:
This will create a new folder called gen-rb, which contains the following model files:
We’ll be using these files next as we build a simple client application.
Our program will connect to HBase over Thrift and then list any tables it finds along with their column families.
These would be the first steps toward building an administrative interface for HBase.
Unlike our previous examples, this script is meant to be run by good old normal Ruby, not JRuby.
It could be suitable for inclusion in a Ruby-based web application, for example.
In the previous code, the first thing we do is make sure Ruby can find the model files by adding gen-rb to the path and including thrift and hbase.
After that, we create a connection to the Thrift server and wire it up to an HBase client instance.
The client object will be our means for communicating with HBase.
After opening the transport, we iterate over the tables brought back by getTableNames()
Your output should look similar since we’re connecting to the local HBase server we started with earlier.
You’ll find that the Thrift API for HBase has most of the same functionality as the Java API we used previously, but many of the concepts are expressed differently.
For example, instead of creating a Put instance, in Thrift you create a Mutation to update a single column or a BatchMutation to update several columns in one transaction.
The Hbase.thrift file we used earlier to generate the model files—see Generate the Models, on page 123—has a lot of good inline documentation to describe the structures and methods available to you.
Setting up a functioning cluster using a cloud service used to be a lot of work.
Currently in the Apache Incubator program, Whirr provides tools for launching, connecting to, and destroying clusters of virtual machines.
Whirr currently supports setting up Hadoop, HBase, Cassandra, Voldemort, and ZooKeeper clusters, with support for more technologies like MongoDB and ElasticSearch on the way.
Though service providers like Amazon often supply some means of persisting data after virtual machines have been terminated, we won’t be using them.
For our purposes, it will suffice to have temporary clusters that lose all data.
If you decide to use HBase in a production capacity later, you may want to set up persistent storage.
If so, it’s worth considering whether dedicated hardware would better suit your needs.
Dynamic services like EC2 are great for horsepower on-the-fly, but you’ll generally get more bang for the buck out of a cluster of dedicated physical or virtual machines.
Before you use Whirr to power up a cluster, you’ll need to have an account with a supported cloud service provider.
In this chapter, we’ll describe how to use Amazon’s EC2, but you’re welcome to use another provider of your choice.
Go to the Apache Whirr site9 and download the latest version.
Unzip the downloaded file, and then open a command prompt in this directory.
We can test that Whirr is ready to roll by executing the version command.
Next, we’ll create some passwordless SSH keys for Whirr to use when launching instances (virtual machines)
With these details out of the way, it’s time to start configuring our cluster.
To specify details about a cluster, we’ll supply Whirr with a .properties file containing the relevant settings.
The first two sections identify the service provider and all relevant credentials —largely boilerplate—while the latter two sections are specific to the HBase cluster that we’re going to create.
In our case, we want one master and five region servers.
On the command line, in the Whirr directory, execute the launchcluster command, providing it with the properties file we just made.
This will produce a lot of output and may take a while.
You can monitor the progress of the launch by returning to the AWS EC2 console.
More information about the launch status is available in the whirr.log file in the Whirr directory.
Only secure traffic is allowed to the cluster by default, so to connect to HBase, we’ll need to open an SSH session.
First, we’ll need to know the name of a server in the cluster to connect to.
In here, you’ll find a tab-delimited file called instances that lists all of the cluster’s running Amazon instances.
The third column contains the publicly addressable domain names of the servers.
Take the first one and plug it into this command:
Once the shell has started up, you can check on the health of the cluster with the status command.
Connecting the sample Thriftbased client application to the cluster is left as an exercise in the homework.
Of course, one more thing is worth talking about before we finish out the day: destroying a cluster.
When you’re done with your remote HBase EC2 cluster, use Whirr’s destroycluster command to shut it down.
Note that you will lose any and all data that had been inserted into the cluster when you do so, since we have not configured the instances to use persistent storage.
At the command prompt, in the Whirr directory, run the following:
If anything goes wrong when shutting these things down, remember that you can still terminate them directly using the AWS console.
Today we stepped outside the HBase shell to look at other connection options, including a binary protocol called Thrift.
We developed a Thrifty client application, and then we created and administrated a remote cluster in Amazon EC2 using Apache Whirr.
Coming up in the homework, you’ll string these two things together, querying your remote EC2 cluster from your locally running Thrift app.
In today’s homework, you’ll connect your local Thrift application to a remotely running HBase cluster.
To do this, you’ll need to open your cluster to insecure incoming TCP connections.
If this were a production environment, a better first step would be to create a secure channel for Thrift—for example by setting up a virtual private network (VPN) with endpoints inside EC2 and our principal network.
Such a setup is outside the scope of this book; suffice it to say that we strongly recommend securing your traffic when it matters to do so.
With your EC2 cluster running, open an SSH session to a node, start the hbase shell, and then create a table with at least one column family.
Run the program and confirm that it displays the correct information about your newly created table.
The data storage model is pretty straightforward, with a few built-in schema constraints.
It doesn’t help, though, that many terms are overloaded with baggage from the relational world (for example, words like table and column)
Most of HBase schema design is deciding on the performance characteristics of your tables and columns.
Noteworthy features of HBase include a robust scale-out architecture and built-in versioning and compression capabilities.
HBase’s built-in versioning capability can be a compelling feature for certain use cases.
Keeping the version history of wiki pages is a crucial feature for policing and maintenance, for instance.
By choosing HBase, we don’t have to take any special steps to implement page history—we get it for free.
On the performance front, HBase is meant to scale out.
If you have huge amounts of data, measured in many gigabytes or terabytes, HBase may be for you.
HBase is rack-aware, replicating data within and between datacenter racks so that node failures can be handled gracefully and quickly.
Although a number of high-profile companies use HBase for their projects, there is no corporate HBase service provider.
This means the people of the HBase community do it for the love of the project and the common good.
Although HBase is designed to scale out, it doesn’t scale down.
The HBase community seems to agree that five nodes is the minimum number you’ll want to use.
Because it’s designed to be big, it can also be harder to administrate.
Solving small problems isn’t what HBase is about, and nonexpert documentation is tough to come by, which steepens the learning curve.
These include Hadoop (an implementation of Google’s MapReduce), the Hadoop distributed file system (HDFS), and Zookeeper (a headless service that aids internode coordination)
This ecosystem is both a strength and a weakness; it simultaneously affords a great deal of architectural sturdiness but also encumbers the administrator with the burden of maintaining it.
One noteworthy characteristic of HBase is that it doesn’t offer any sorting or indexing capabilities aside from the row keys.
Rows are kept in sorted order by their row keys, but no such sorting is done on any other field, such as column names and values.
So, if you want to find rows by something other than their key, you need to scan the table or maintain your own index.
All field values in HBase are treated as uninterpreted arrays of bytes.
There is no distinction between, say, an integer value, a string, and a date.
They’re all bytes to HBase, so it’s up to your application to interpret the bytes.
If a client succeeds in writing a value, other clients will receive the updated value on the next request.
Some databases, like Riak, allow you to tweak the CAP equation on a per-operation basis.
In the face of reasonable amounts of partitioning—for example, a node failingHBase will remain available, shunting the responsibility off to other nodes in the cluster.
However, in the pathological example, where only one node is left alive, HBase has no choice but to refuse requests.
The CAP discussion gets a little more complex when you introduce clusterto-cluster replication, an advanced feature we didn’t cover in this chapter.
A typical multicluster setup could have clusters separated geographically by some distance.
In this case, for a given column family, one cluster is the system of record, while the other clusters merely provide access to the replicated data.
As one of the first nonrelational databases we had ever encountered, HBase was quite a challenge for us.
The terminology can be deceptively reassuring, and the installation and configuration are not for the faint of heart.
On the plus side, some of the features HBase offers, such as versioning and compression, are quite unique.
These aspects can make HBase quite appealing for solving certain problems.
And of course, it scales out to many nodes of commodity hardware quite well.
All in all, HBase—like a nail gun—is a pretty big tool, so watch your thumbs.
MongoDB MongoDB is in many ways like a power drill.
Your ability to complete a task is framed largely by the components you choose to use (from drill bits of varying size to sander adapters)
MongoDB’s strength lies in versatility, power, ease of use, and ability to handle jobs both large and small.
Although it’s a much newer invention than the hammer, it is increasingly a tool builders reach for quite often.
First publicly released in 2009, MongoDB is a rising star in the NoSQL world.
It was designed as a scalable database—the name Mongo comes from “humongous”—with performance and easy data access as core design goals.
It is a document database, which allows data to persist in a nested state, and importantly, it can query that nested data in an ad hoc fashion.
It enforces no schema (similar to Riak but unlike Postgres), so documents can optionally contain fields or types that no other document in the collection contains.
But don’t think that MongoDB’s flexibility makes it a toy.
There are some huge production MongoDB (often just called Mongo) deployments out there, like Foursquare, bit.ly, and CERN, for collecting Large Hadron Collider data.
Mongo hits a sweet spot between the powerful queryability of a relational database and the distributed nature of other datastores like Riak or HBase.
Project founder Dwight Merriman has said that MongoDB is the database he wishes he’d had at DoubleClick, where as the CTO he had to house largescale data while still being able to satisfy ad hoc queries.
Mongo is a JSON document database (though technically data is stored in a binary form of JSON known as BSON)
A Mongo document can be likened to a relational table row without a schema, whose values can nest to an arbitrary.
Mongo is an excellent choice for an ever-growing class of web projects with large-scale data storage requirements but very little budget to buy big-iron hardware.
Thanks to its lack of structured schema, Mongo can grow and change along with your data model.
If you’re in a web startup with dreams of enormity or are already large with the need to scale servers horizontally, consider MongoDB.
We’ll spend today working on some CRUD operations and finish up with performing nested queries in MongoDB.
As usual, we won’t walk you through the installation steps, but if you visit the Mongo website,1 you can download a build for your OS or find instructions on how to build from source.
If you have OS X, we recommend installing via Homebrew (brew install mongodb)
If you use some Debian/Ubuntu variant, try Mongodb.org’s own apt-get package.
On the Fence I was on the fence about using a document datastore before making the switch in my own production code.
Coming from the relational database world, I found Mongo to be an easy move with its ad hoc queries.
And its ability to scale out mirrored my own web-scale dreams.
They readily admitted that Mongo wasn’t perfect, but their clear plans (and general adherence to those plans) were based on general web infrastructure use cases, rather than idyllic debates on scalability and replication.
This pragmatic focus on usability should shine as you use MongoDB.
A trade-off of this evolutionary behavior is that there are several paths to performing any given function in Mongo.
To prevent typos, Mongo requires you to first create the directory where mongod will store its data.
Ensure the user you run the server under has permission to read and write to this directory.
If it’s not already running, you can fire up the Mongo service by running mongod.
To create a new database named book, first run this command in your terminal.
We’re currently in the book database, but you can view others via show dbs and switch databases with the use command.
Creating a collection (similar to a bucket in Riak nomenclature) in Mongo is as easy as adding an initial record to the collection.
Since Mongo is schemaless, there is no need to define anything up front; merely using it is enough.
What’s more, our book database doesn’t really exist until we first add values into it.
With the show collections command, you can verify the collection now exists.
We can list the contents of a collection via find()
We formatted the output here for readability, but yours may just output as a single wrapped line.
Unlike a relational database, Mongo does not support server-side joins.
A single JavaScript call will retrieve a document and all of its nested content, free of charge.
You may have noticed that the JSON output of your newly inserted town contains an _id field of ObjectId.
This is akin to SERIAL incrementing a numeric primary key in PostgreSQL.
What’s great about this autonumbering scheme is that each process on every machine can handle its own ID generation without colliding with other mongod instances.
This design choice gives a hint of Mongo’s distributed nature.
Mongo’s native tongue is JavaScript, be it as complex as mapreduce queries or as simple as asking for help.
These commands will list available functions related to the given object.
If you want to inspect the source code for a function, call it without parameters or parentheses (think more Python than Ruby)
Let’s populate a few more documents into our towns collection by creating our own JavaScript function.
Earlier we called the find() function without params to get all documents.
To access a specific one, you only need to set an _id property.
The find() function also accepts an optional second parameter: a fields object we can use to filter which fields are retrieved.
To retrieve all fields except name, set name to 0 (or false or null)
Like PostgreSQL, in Mongo you can construct ad hoc queries by field values, ranges, or a combination of criteria.
The good news about the query language being JavaScript is you can construct operations as you would objects.
We are not limited to number ranges but can also retrieve date ranges.
But the true power of Mongo stems from its ability to dig down into a document and return the results of deeply nested subdocuments.
To query a subdocument, your field name is a string separating nested layers with a dot.
The previous queries are great if you want to find documents with a single matching field, but what if we need to match several fields of a subdocument?
This time we’ll override each _id to be a string of our choosing.
Let’s find a country that not only exports bacon but exports tasty bacon.
Mongo returned Canada because it exports bacon and exports tasty syrup.
It specifies that if a document (or nested document) matches all of our criteria, the document counts as a match.
You can find any country that exports a tasty food that also has a condiment label:
So far, all of our criteria are implicitly and operations.
If you try to find a country with the name United States and an _id of mx, Mongo will yield no results.
However, searching for one or the other with $or will return two results.
Think of this layout like prefix notation: OR A B.
There are so many operators we can’t cover them all here, but we hope this has given you a taste of MongoDB’s powerful query ability.
The following is is not a complete list of the commands but a good chunk of them.
Match by any PCRE-compliant regular expression string (or just use the // delimiters as shown earlier)
You can find all the commands on the MongoDB online documentation or grab a cheat sheet from the Mongo website.
New York and Punxsutawney are unique enough, but did we add Portland, Oregon, or Portland, Maine (or Texas or the others)? Let’s update our towns collection to add some U.S.
The first is a criteria query—the same sort of object you would pass to find()
The second parameter is either an object whose fields will replace the matched document(s) or a modifier operation.
In this case, the modifier is to $set the field state with the string OR.
You may wonder why the $set operation is even required.
Mongo doesn’t think in terms of attributes; it has only an internal, implicit understanding of attributes for optimization reasons.
You will rarely want something like this (notice the lack of $set operation):
We can verify our update was successful by finding it (note our use of findOne() to retrieve only one matching object)
There are more directives than this, such as the $ positional operator for arrays.
New operations are added frequently and are updated in the online documentation.
Then, to retrieve the town’s country, you can query the countries collection using the stored $id.
Better yet, in JavaScript, you can ask the town document the name of the collection stored in the fields reference.
The last two queries are equivalent; the second is just a bit more data-driven.
Merely replace the find function with a call to remove(), and all matched criteria will be removed.
Mongo is not very friendly when it comes to misspellings.
If you haven’t run across this problem yet, you probably will at some point, so be warned.
You can draw parallels between static and dynamic programming languages.
Documents are schemaless, so Mongo has no way of knowing if you intended on inserting pipulation into your city or meant to querying on lust_census; it will happily insert those fields or return no matching values.
We recommend running find() to verify your criteria before running remove()
Let’s remove all countries that export bacon that isn’t tasty.
Now when you run count(), verify we are left with only two countries.
Let’s close out this day with one more interesting query option: code.
You can request that MongoDB run a decision function across your documents.
We placed this last because it should always be a last resort.
These queries run quite slowly, you can’t index them, and Mongo can’t optimize them.
But sometimes it’s hard to beat the power of custom code.
You can run custom code with other criteria using the $where clause.
In this example, the query also filters for towns famous for groundhogs.
A word of warning: Mongo will brutishly run this function against each document, and there is no guarantee that the given field exists.
For example, if you assume a population field exists and population is missing in even a single document, the entire query will fail, since the JavaScript cannot properly execute.
Be careful when you write custom JavaScript functions, and be comfortable using JavaScript before attempting custom code.
Today we took a peek at our first document database, MongoDB.
We saw how we can store nested structured data as JSON objects and query that data at any depth.
You learned that a document can be envisioned as a schemaless row in the relational model, keyed by a generated _id.
A set of documents is called a collection in Mongo, similar to a table in PostgreSQL.
Unlike the previous styles we’ve encountered, with collections of sets of simple datatypes, Mongo stores complex, denormalized documents, stored and retrieved as collections of arbitrary JSON structures.
Mongo tops off this flexible storage strategy with a powerful query mechanism not constrained by any predefined schema.
Its denormalized nature makes a document datastore a superb choice for storing data with unknown qualities, while other styles (such as relational or columnar) prefer you know in advance and require schema migrations to add or edit fields.
Select a town via a case-insensitive regular expression containing the word new.
Find all cities whose names contain an e and are famous for food or beer.
Create a new database named blogger with a collection named articlesinsert a new article with an author name and email, creation date, and text.
Update the article with an array of comments, containing a comment with an author and text.
Increasing MongoDB’s query performance is the first item on today’s docket, followed by some more powerful and complex grouped queries.
Finally, we’ll round out the day with some data analysis using mapreduce, similar to what we did with Riak.
MongoDB provides several of the best data structures for indexing, such as the classic B-tree, and other additions such as two-dimensional and spherical GeoSpatial indexes.
For now we’re going to do a little experiment to see the power of MongoDB’s B-tree index by populating a series of phone numbers with a random country prefix (feel free to replace this code with your own country code)
Whenever a new collection is created, Mongo automatically creates an index by the _id.
Most queries will include more fields than just the _id, so we need to make indexes on those fields.
We’re going to create a B-tree index on the display field.
But first, let’s verify that the index will improve speed.
To do this, we’ll first check a query without an index.
The explain() method is used to output details of a given operation.
Your output will not equal ours, but note the millis field—milliseconds to complete the query—will likely be double digits.
The fields parameter is an object containing the fields to be indexed against.
The options parameter describes the type of index to make.
In this case, we’re building a unique index on display that should just drop duplicate entries.
Now try find() again, and check explain() to see whether the situation improves.
Also notice the cursor changed from a Basic to a B-tree cursor (it’s called a cursor because it points to where values are stored; it doesn’t contain them)
Mongo is no longer doing a full collection scan but instead walking the tree to retrieve the value.
If you need to profile in a normal test or production environment, you’ll need the system profiler.
This will create a new object in the system.profile collection, which you can read as any other table.
If we find() all of the system indexes for our phones collection, the new one should appear last.
The first index is always automatically created to quickly look up by _id, and the second is the unique index we made previously.
We should close this section by noting that creating an index on a large collection can be slow and resource-intensive.
You should always consider these impacts when building an index by creating indexes off-peak times, running index creation in the background, and running them manually rather than using automated index creation.
There are plenty more indexing tricks and tips online, but these are the basics that are good to know.
The queries we investigated yesterday are useful for basic extraction of data, but any post-processing would be up to you to handle.
For example, say we wanted to count the phone numbers greater than 559–9999; we would prefer the database perform such a count on the back end.
It takes a query and returns a number (of matches)
To see the power of the next few aggregating queries, let’s add another 100,000 phone numbers to our phones collection, this time with a different area code.
Aggregated queries return a structure other than the individual documents we’re used to.
Even mapreduce generally takes a bit of effort to retrieve objects that resemble your internal stored documents.
The distinct() command returns each matching value (not a full document) where one or more exists.
We can get the distinct component numbers that are less than 5,550,005 in this way:
The group() aggregate query is akin to GROUP BY in SQL.
We can count all phone numbers greater than 5,599,999 and group the results into different buckets keyed by area code.
Remember mapreduce from the Riak chapter? Our data is already mapped into our existing collection of documents.
You can easily replicate the count() function with the following group() call.
The first thing we did here was set an initial object with a field named count set to 0—fields created here will appear in the output.
Next we describe what to do with this field by declaring a reduce function that adds one for every document we encounter.
Finally, we gave group a condition restricting which documents to reduce over.
Our result was the same as count() because our condition was the same.
We left off a key, since we want every document encountered added to our list.
For performance sake, we’ll start by creating an object to store the numbers as fields (we’re effectively creating an ad hoc set)
In the reduce function (which is run for each matching document), we just set the value to 1 as a placeholder (it’s the field we want)
However, if we want to really replicate distinct(), we should return an array of integers.
So, we add a finalize(out) method that is run one last time before returning a value to convert the object into an array of field values.
The function then converts those number strings into integers (if you really want to see the sausage being made, run the following without the finalize function set)
The group() function is powerful—like SQL’s GROUP BY—but Mongo’s implementation has a downside, too.
First, you are limited to a result of 10,000 documents.
Moreover, if you shard your Mongo collection (which we will tomorrow) group() won’t work.
There are also much more flexible ways of crafting queries.
For these and other reasons, we’ll dive into MongoDB’s version of mapreduce in just a bit.
But first, we’ll touch on the boundary between clientside and server-side commands, which is a distinction that has important consequences for your applications.
If you were to run the following function through a command line (or through a driver), the client will pull each phone locally, all 100,000 of them, and save each phone document one by one to the server.
However, the Mongo db object provides a command named eval(), which passes the given function to the server.
This dramatically reduces chatter between the client and server since the code is executed remotely.
In addition to evaluating JavaScript functions, there are several other prebuilt commands in Mongo, most of which are executed on the server, although some require executing only under the admin database (which you can access by entering use admin)
The top command will output access details about all collections on the server.
On running listCommands(), you may notice a lot of commands we’ve used.
In fact, you can execute many common commands through the runCommand() method, such as counting the number of phones.
The number (n) returned is correct (100,000), but the format is an object with an ok field.
Remember that we can play detective on how a function like count() works by leaving off the calling parentheses.
But look in the code, and after a bunch of setup, you’ll find lines like this:
Double interesting! count() executes runCommand() and returns the value from the n field.
And while we’re digging into how methods work, let’s take a look at the runCommand() function.
It turns out that runCommand() is also a helper function that wraps a call to a collection named $cmd.
You can execute any command using a call directly to this collection.
This is bare-metal and how drivers generally communicate to the Mongo server.
To drive home the idea that most of the magic you execute on the mongo console is executed on the server, not the client, which just provides convenient wrapper functions.
We can leverage the concept of executing server-side code for our own gain to create something in MongoDB that’s similar to the stored procedures we saw in PostgreSQL.
Any JavaScript function can be stored in a special collection named system.js.
This is a normal collection; you just save the function by setting the name as the _id, and value is the function object.
What we normally would do next is execute it on the server directly.
The eval() function passes the string to the server, evaluates it as JavaScript code, and returns the results.
It’s worth mentioning that eval() blocks the mongod as it runs, so it’s mainly useful for quick one-offs and tests, not common production procedures.
You can use this function inside $where and mapreduce, too.
We have the last weapon in our arsenal to begin executing mapreduce in MongoDB.
The Mongo mapreduce pattern is similar to Riak’s, with a few small differences.
Rather than the map() function returning a converted value, Mongo requires your mapper to call an emit() function with a key.
The benefit here is that you can emit more than once per document.
The reduce() function accepts a single key and a list of values that were emitted to that key.
Finally, Mongo provides an optional third step called finalize(), which is executed only once per mapped value after the reducers are run.
This allows you to perform any final calculations or cleanup you may need.
Since we already know the basics of mapreduce, we’ll skip the intro wadingpool example and go right to the high-dive.
Let’s generate a report that counts all phone numbers that contain the same digits for each country.
First we’ll store a helper function that extracts an array of all distinct numbers (understanding how this helper works is not imperative to understanding the overall mapreduce)
If the file exists in the same directory you launched mongo from, you need only the filename; otherwise, a full path is required.
With all that in, we can do a quick test (if you have some trouble, don’t feel shy about adding a smattering of print() functions)
Our goal is to simply count these values, so we emit the value 1 (each document represents one item to count)
The reducer’s job is to sum all those 1s together.
It’s a materialized view that you can see in the show tables list.
Note the unique emitted keys are under the field _ids, and all of the data returned from the reducers are under the field value.
Recall from the Riak chapter that reducers can have either mapped (emitted) results or other reducer results as inputs.
Each server must run its own map() and reduce() functions and then push those results to be merged with the service that initiated the call, gathering them up.
If we had renamed the output of the reducer to total instead of count, we would have needed to handle both cases in the loop, as shown here:
However, Mongo predicted that you might need to perform some final changes, such as rename a field or some other calculations.
If we really need the output field to be total, we can implement a finalize() function, which works the same way as the finalize function under group()
On Day 2 we’ve expanded our query power by including several aggregate queries: count(), distinct(), and topped off by group()
To speed up the response time of these queries, we used MongoDB’s indexing options.
When more power is required, the ever-present mapReduce() is available.
Implement a finalize method to output the count as the total.
Install a Mongo driver for a language of your choice, and connect to the database.
Populate a collection through it, and index one of the fields.
Mongo has a powerful ability to store and query data in a variety of ways.
What makes document databases unique is their ability to efficiently handle arbitrarily nested, schemaless data documents.
What makes Mongo special in the realm of document stores is its ability to scale across several servers, by replicating (copying data to other servers) or sharding collections (splitting a collection into pieces) and performing queries in parallel.
Mongo was built to scale out, not to run stand-alone.
It was built for data consistency and partition tolerance, but sharding data has a cost: if one part of a collection is lost, the whole thing is compromised.
What good is querying against a collection of countries that contains only the western hemisphere? Mongo deals with this implicit sharding weakness in a simple manner: duplication.
You should rarely run a single Mongo instance in production but rather replicate the stored data across multiple services.
Rather than muck with our existing database, today we’ll start from scratch and spawn a few new servers.
Mongo’s default port is 27017, so we’ll start up each server on other ports.
Recall you must create the data directories first, so create three of them:
This time we’ll add the replSet flag with the name book and specify the ports.
While we’re at it, let’s turn on the REST flag so we can use the web interface.
Open another terminal window, and run the next command, which launches another server, pointing to a different directory, available on another port.
Then open a third terminal to start the third server.
Notice that you get a lot of this noise on the output.
That’s a good thing; we’ve yet to initialize our replica set, and Mongo is letting us know that.
Fire up a mongo shell to one of the servers, and execute the rs.initiate() function.
Notice we’re using a new object called rs (replica set)
Like other objects, it has a help() method you can call.
Running the status() command will let us know when our replica set is running, so just keep checking the status for completion before continuing.
If you watch the three server outputs, you should see that one server outputs this line:
After the insert, exit the console, and then let’s test that our change has been replicated by shutting down the master node; pressing CTRL+C is sufficient.
Open a console into that machine (for us it was localhost:27012), and db.echo.find() should contain your value.
The message not master is letting us know that we cannot write to a secondary node.
There is only one master per replica set, and you must interact with it.
Replicating data has its own issues not found in single-source databases.
In the Mongo setup, one problem is deciding who gets promoted when a master node goes down.
Mongo deals with this by giving each mongod service a vote, and the one with the freshest data is elected the new master.
Right now you should still have two mongod services running.
Remember, when we did this with three nodes, one of the others just got promoted to be the new master.
The output of the last remaining server will be something like this:
This comes down to the Mongo philosophy of server setups and the reason we should always have an odd number of servers (three, five, and so on)
Go ahead and relaunch the other servers and watch the logs.
When the nodes are brought back up, they go into a recovery state and attempt to resync their data with the new master node.
A write in a Mongo replica set isn’t considered successful until most nodes have a copy of the data.
The concept of replication is easy enough to grasp: you write to one MongoDB server, and that data is duplicated across others within the replica set.
If one server is unavailable, then one of the others can be promoted and serve requests.
But there are more ways a server can be unavailable than a server crash.
In that case, Mongo dictates that a majority of nodes that can still communicate make up the network.
MongoDB expects an odd number of total nodes in the replica set.
If connection issues split it into a threenode fragment and a two-node fragment, the larger fragment has a clear majority and can elect a master and continue servicing requests.
To see why an odd number of nodes is preferred, consider what might happen to a four-node replica set.
Say a network partition causes two of the servers to lose connectivity from the other two.
One set will have the original master, but since it can’t see a clear majority of the network, the master steps down.
The other set will similarly be unable to elect a master because it too can’t communicate with a clear majority of nodes.
Both sets are now unable to process requests and the system is effectively down.
Having an odd number of total nodes would have made this particular scenario—a fragmented network where each fragment has less than a clear majority—less likely to occur.
Some databases (e.g., CouchDB) are built to allow multiple masters, but Mongo is not, and so it isn’t prepared to resolve data updates between them.
MongoDB deals with conflicts between multiple masters by simply not allowing them.
Unlike, say, Riak, Mongo always knows the most recent value; the client needn’t decide.
Mongo’s concern is strong consistency on writes, and preventing a multimaster scenario is not a bad method for achieving it.
One of the central reasons for Mongo to exist is to safely and quickly handle very large datasets.
The clearest method of achieving this is through horizontal sharding by value ranges—or just sharding for brevity.
Rather than a single server hosting all values in a collection, some range of values are split (or in other words, sharded) onto other servers.
Mongo makes this easier by autosharding, managing this division for you.
Like replica sets, there’s a special parameter necessary to be considered a shard server (which just means this server is capable of sharding)
Now we need a server to actually keep track of our keys.
Imagine we created a table to store city names alphabetically.
Finally, we need to run a fourth server called mongos, which is the single point of entry for our clients.
The mongos server will connect to the mongoconfig config server to keep track of the sharding information stored there.
Our chunkSize is 1MB, which is the smallest value allowed.
This is just for our small dataset, so we can watch sharding.
You may wonder why Mongo separates configuration and the mongos point of entry into two different servers.
This is because in production environments they will generally live on different physical servers.
The config server (itself replicated) manages the sharded information for other sharded servers, while mongos will likely live on your local application server where clients can easily connect (without needing to manage which shards to connect to)
In production you’d use the default or a much bigger number.
We point mongos to the config server:port with the --configdb flag.
A neat thing about mongos is that it is a lightweight clone of a full mongod server.
Nearly any command you can throw at a mongod, you can throw at a mongos, which makes it the perfect go-between for clients to connect to multiple sharded servers.
Now let’s jump into the mongos server console on the admin database.
With that set up, now we have to give it the database and collection to shard and the field to shard by (in our case, the city name)
With all that setup out of the way, let’s load some data.
Download that file, and run the following import script that imports the data into our mongos server:
From the mongos console, type use test to go back to the test environment from the admin environment.
Although we’ve focused on server setups today, no day would be complete without a little bit of razzle-dazzle, and that’s Mongo’s ability to quickly perform geospatial queries.
If we were not dealing with a sharded collection, we could easily query for cities at or near a location.
However, the following will work only with nonsharded collections in our current version of Mongo.
This should be patched in future versions for sharded collections.
But in the meantime, to query a sharded cities collection for other cities near a location, use the geoNear() command.
It returns a gold mine of useful information such as distance from the queried point, average and max distance of the returned set, and index information.
One downside of a distributed system can be the lack of a single coherent filesystem.
Say you operate a website where users can upload images of themselves.
If you run several web servers on several different nodes, you must manually replicate the uploaded image to each web server’s disk or create some alternative central system.
Mongo handles this scenario by its own distributed filesystem called GridFS.
Mongo comes bundled with a command-line tool for interacting with the GridFS.
The great thing is we don’t have to set up anything special to use it.
If we list the files in the mongos managed shards using the command mongofiles, we get an empty list.
And voila! If we list the contents of mongofiles, we’ll find the uploaded name name.
Back in our mongo console, we can see the collections Mongo stores the data in.
Since they’re just plain old collections, they can be replicated or queried like any other.
Today we focused on how Mongo enhances data durability with replica sets and supports horizontal scaling with sharding.
We looked at good server configurations and how Mongo provides the mongos server to act as a relay for handling autosharding between multiple nodes.
Finally, we toyed with some of Mongo’s built-in tools, such as geospatial queries and GridFS.
Read the full replica set configuration options in the online docs.
Mongo has support for bounding shapes (namely, squares and circles)
Run six servers: three servers in a replica set, and each replica set is one of two shards.
We hope this taste of MongoDB has piqued your fancy and showed you how it earns the moniker of the “humongous” database.
We covered a lot in a single chapter, but as usual, we only clawed at the surface.
Mongo’s primary strength lies in its ability to handle huge amounts of data (and huge amounts of requests) by replication and horizontal scaling.
But it also has an added benefit of a very flexible data model, since you needn’t ever conform to a schema and can simply nest any values you would generally join using SQL in an RDBMS anyway.
You may have noticed the similarity between Mongo commands and SQL database concepts (minus the server-side joins)
This is not by accident and is one reason Mongo is gaining so much mind share from former object-relational model (ORM) users.
It’s different enough to scratch a lot of developer itches but not so different it becomes a wholly different and scary monster.
How Mongo encourages denormalization of schemas (by not having any) might be a bit too much for some to swallow.
Some developers find the cold, hard constraints of a relational database reassuring.
It can be dangerous to insert any old value of any type into any collection.
A single typo can cause hours of headache if you don’t think to look at field names and collection names as a possible culprit.
Mongo’s flexibility is generally not important if your data model is already fairly mature and locked down.
Because Mongo is focused on large datasets, it works best in large clusters, which can require some effort to design and manage.
Mongo is an excellent choice if you are currently using a relational database to store your data through an ORM out of habit.
Adding new fields to a document is as easy as adding a new field to your data model, and Mongo will happily accept the new terms.
We find Mongo to be a much more natural answer to many common problem scopes for application-driven datasets than relational databases.
CouchDB Ratchet wrenches are light and convenient tools you carry around for a range of big and small jobs.
Like power drills, you can swap out variously sized bits like sockets or screws.
Unlike a power drill that needs to be plugged into 120 volts of AC power, however, a wrench is happy to rest in your pocket and run on elbow grease.
Able to scale down as well as up, CouchDB fits problem spaces of varying size and complexity with ease.
First released in 2005, CouchDB was designed with the Web in mind and all the innumerable flaws, faults, failures, and glitches that come with it.
Consequently, CouchDB offers a robustness unmatched by most other databases.
Whereas other systems tolerate occasional network drops, CouchDB thrives even when connectivity is only rarely available.
Somewhat like MongoDB, CouchDB stores documents—JSON objects consisting of key-value pairs where values may be any of several types, including other objects nested to any depth.
There is no ad hoc querying, though; indexed views produced by incremental mapreduce are the principal way you find documents.
Instead of focusing only on big-iron cluster installations, CouchDB aims to support a variety of deployment scenarios from the datacenter down to the smartphone.
You can run CouchDB on your Android phone, on your MacBook, and in your datacenter.
Written in Erlang, CouchDB is heartily built—the only way to shut it down is to kill the process! With its append-only storage model, your data is virtually incorruptible and easy to replicate, back up, and restore.
CouchDB is document-oriented, using JSON as its storage and communication language.
Like Riak, all calls to CouchDB happen over its REST interface.
Replication can be one-way or bidirectional and ad hoc or continuous.
CouchDB gives you a lot of flexibility to decide how to structure, protect, and distribute your data.
They’re both document-oriented datastores with an affinity for JavaScript that use JSON for data transport.
There are many differences, though, ranging from project philosophy to implementation to scalability characteristics.
We’ll cover many of these as we explore the beautiful simplicity of CouchDB.
During our three-day tour we’ll explore many of CouchDB’s compelling features and design choices.
We’ll start, as always, with individual CRUD commands and then move on to indexing through mapreduce views.
As we’ve done with other databases, we’ll import some structured data and then use it to explore some advanced concepts.
Finally, we’ll develop some simple event-driven client-side applications using Node.js and learn how CouchDB’s mastermaster replication strategy deals with conflicting updates.
Today we’re going to kick-start our CouchDB exploration by using CouchDB’s friendly Futon web interface to perform basic CRUD operations.
All libraries and drivers for CouchDB end up sending REST requests under the hood, so it makes sense to start by understanding how they work.
Once you have CouchDB installed and running, open a web browser to http://localhost:5984/_utils/
Before we can start working with documents, we need to create a database to house them.
We’re going to create a database to store musicians along with.
From here, we can create new documents or open existing ones.
On the music database’s page, click the New Document button.
In Futon, you may notice the warning at the bottom of the right column explaining that everyone is an admin.
Were this destined to become a production server, your next step would be to click the “Fix this” link and create an admin user to restrict who can do what.
In our case, leaving it open is fine for now and will make our other tasks easier.
Just as in MongoDB, a document consists of a JSON object containing keyvalue pairs called fields.
All documents in CouchDB have an _id field, which must be unique and can never be changed.
You can specify an _id explicitly, but if you don’t, CouchDB will generate one for you.
In our case, the default is fine, so click Save Document to finish.
Immediately after saving the document, CouchDB will assign it an additional field called _rev.
The _rev field will get a new value every time the document changes.
The format for the revision string consists of an integer followed by a dash and then a pseudorandom unique string.
If either of these do not match, CouchDB will reject the operation.
This is how it prevents conflicts—by ensuring only the most recent document revisions are modified.
By requiring a matching _rev, CouchDB ensures that the document you think you’re modifying hasn’t been altered behind your back while you weren’t looking.
With the document page still open, click the Add Field button.
In the Field column, enter name, and in the Value column, enter The Beatles.
Click the green check mark next to the value to ensure it sticks, and then click the Save Document button.
It can handle any JSON structure nested to any depth.
This time, set Field to albums, and for Value enter the following (this is not an exhaustive list):
There’s more relevant information about an album than just its name, so let’s add some.
Modify the albums field and replace the value you just set with this:
After you save the document, this time you should be able to expand the albums value to expose the nested documents underneath.
Clicking the Delete Document button would do what you might expect; it would remove the document from the music database.
Instead, let’s drop down to the command line and take a look at how to communicate with CouchDB over REST.
All communication with CouchDB is REST-based, and this means issuing commands over HTTP.
CouchDB isn’t the first database we’ve talked about with this quality.
And like we did with Riak, we can communicate with CouchDB using the command-line tool cURL.
Here we’ll perform some basic CRUD operations before moving on to the topic of views.
To start, open a command prompt and run the following:
Issuing GET requests (cURL’s default) retrieves information about the thing indicated in the URL.
Accessing the root as you just did merely informs you that CouchDB is up and running and what version is installed.
Next let’s get some information about the music database we created earlier (output formatted here for readability):
This returns some information about how many documents are in the database, how long the server has been up, and how many operations have been performed.
To retrieve a specific document, append its _id to the database URL like so:
CouchDB won’t make any changes to documents as the result of a GET.
To make changes, you have to use other HTTP commands like PUT, POST, and DELETE.
Make sure to specify a Content-Type header with the value application/json; otherwise, CouchDB will refuse the request.
The HTTP response code 201 Created tells us that our creation request was successful.
The PUT command is used to update an existing document or create a new one with a specific _id.
Just like GET, the URL for a PUT URL consists of the database URL followed by the document’s _id.
Unlike MongoDB, in which you modify documents in place, with CouchDB you always overwrite the entire document to make any change.
The Futon web interface we saw earlier may have made it look like you could modify a.
To see how, try executing the same PUT operation again.
You’ll get an HTTP 409 Conflict response with a JSON object describing the problem.
Finally, we can use the DELETE operation to remove a document from the database.
The DELETE operation will supply a new revision number, even though the document is gone.
It’s worth noting that the document wasn’t really removed from disk, but rather a new empty document was appended, flagging the document as deleted.
Just like with an update, CouchDB does not modify documents in place.
Now that we’ve learned how to do basic CRUD operations in Futon and cURL, we’re about ready to move onto more advanced topics.
Use curl to create a new database with a name of your choice, and then delete that database also via cURL.
Again using cURL, create a new document that contains a text document as an attachment.
Lastly, craft and execute a cURL request that will return just that document’s attachment.
In CouchDB, a view is a window into the documents contained in a database.
Today, we’ll discover how to create the functions that make up a view.
We’ll also learn how to perform ad hoc queries against views using cURL.
Finally, we’ll import music data, which will make the views more salient and demonstrate how to use couchrest, a popular Ruby library for working with CouchDB.
A view consists of mapper and reducer functions that are used to generate an ordered list of key-value pairs.
It is provided out of the box for all databases and contains an entry for each document in the database, keyed by its string _id.
To retrieve all the things in the database, issue a GET request for the _all_docs view.
You can see in the previous output the one document we’ve created so far.
The response is a JSON object that contains an array of rows.
In the case of _all_docs, the id and key fields match, but for custom views this will almost never be the case.
By default, views won’t include all of each document’s content in the value returned.
To retrieve all of the document’s fields, add the include_docs=true URL parameter.
Here you can see that the other properties name and albums have been added to the value object in the output.
With this basic structure in mind, let’s make our own views.
Now that we’ve gotten a rough overview of how views work, let’s try creating our own views.
To start, we’ll reproduce the behavior of the _all_docs view, and after that, we’ll make increasingly complex views to extract deeper information from our documents for indexing.
In the upper-right corner of the music database’s page, choose “Temporary view...” from the View dropdown.
The code in the left Map Function box should look like this:
If you click the Run button underneath the map function, CouchDB will execute this function once for each document in the database, passing in that document as the doc parameter each time.
This will generate a table with a single row of results resembling the following:
The secret to this output, and all views, is the emit() function (this works just like the MongoDB function of the same name)
In the previous case, the map function emits the key-value pair null/doc.
As we see in the output table, the key is indeed null, and the value is the same object we saw in Day 1 when we requested it directly from cURL.
To make a mapper that achieves the same thing as _all_docs, we need to emit something a little different.
With that in mind, change the Map Function code to the following, and then click Run.
The output table should now resemble the following table, echoing the same key-value pair we saw earlier when enumerating records via _all_docs:
Note that you don’t have to use Futon to execute temporary views.
You may also send a POST request to the _temp_view handler.
In this case, you pass in your map function as a JSON object in the request body.
The response is now identical to what we’d expect from _all_docs.
But what happens when we add the include_docs=true parameter? Let’s find out!
This time, instead of integrating additional fields into the value object, a separate property called doc is added to the row result containing the full document.
Providing a separate doc property prevents problems that might otherwise arise with combining the row value with the document.
Next, let’s see how to save a view so that CouchDB can index the results.
When CouchDB executes a temporary view, it must execute the provided map function for each and every document in the database.
For production, you should store your views in design documents.
A design document is a real document in the database, just like the Beatles document we created earlier.
As such, it can show up in views and be replicated to other CouchDB servers in the usual fashion.
To save a temporary view as a design document in Futon, click the Save As...
Design documents always have IDs that start with _design/ and contain one or more views.
The view name distinguishes this view from others housed in the same design document.
As a general rule, you should group views based on what they do relative to your data.
We’ll see examples of this as we create more interesting views.
Recall that our music database stores artist information, including a name field that contains the band’s name.
In Futon, head back to the Temporary View page, enter the following Map Function code, and click Run.
This function checks whether the current document has a name field and, if so, emits the name and document _id as the relevant key-value pair.
Finding artists by name is pretty useful, but we can do more.
This time, let’s make a view that lets us find albums.
This will be the first example where the map function will emit more than one result per document.
Again return to the Temporary View page; then enter the following mapper:
This function checks whether the current document has a name field and an albums field.
If so, it emits a key-value pair for each album where the key is the album’s title or name and the value is a compound object containing the artist’s name and the original album object.
This time, for Design Document, enter albums, and for View Name enter by_ name.
Now that we have a couple of custom design documents saved, let’s jump back to the command line and query them with the curl command.
In our case, we’re querying the by_name view in the artists design document of the music database.
No surprise here that the output includes our one document, keyed by the band name.
CouchDB will ensure that the records are presented in alphanumerical order by the emitted keys.
When designing your views, it’s important to pick emitted keys that will make sense when ordered.
Requesting a view in this fashion returns the whole set, but what if we want just a subset? One way to do that is to use the key URL parameter.
When you specify a key, only rows with that exact key are returned.
The total_rows field counts the total number of records in the view, not just the subset returned for this request.
The offset field tells us how far into that full set the first record presented appears.
Based on these two numbers and the length of the rows, we can calculate how many more records there are in the view on both sides.
Requests for views can be sliced a few other ways beyond the keys parameter, but to really see them in action, we’re going to need more data.
Importing data is a recurring problem that you’ll face no matter what database you end up using.
In this section, we’ll use Ruby to import structured data into our music database.
Through this you’ll see how to perform bulk imports into CouchDB, and it’ll also give us a nice pool of data to work with when we create more advanced views.
We’ll use music data from Jamendo.com,2 a site devoted to hosting freely licensed music.
Jamendo provides all their artist, album, and track data in.
To parse Jamendo’s XML file, we’ll use the libxml-ruby gem.
Rather than writing our own Ruby-CouchDB driver or issuing HTTP requests directly, we’ll use a popular Ruby gem called couchrest that wraps these calls into a convenient Ruby API.
We’ll be using only a few methods from the API, but if you want to continue using this driver for your own projects, the documentation is quite good.5
To kick things off, we bring in the rubygems module and the specific gems that we need.
The standard way to use LibXML is by defining a callbacks class.
Here we define a JamendoCallbacks class to encapsulate our SAX handlers for various events.
The first thing our class does during initialization is connect to our local CouchDB server using the CouchRest API and then create the music database (if it doesn’t exist already)
After that, it sets up some instance variables for storing state information during the parse.
Once parsing has started, the on_start_element() method will handle any opening tags.
Whenever the parser encounters character data, we buffer it to be added as a property to the current container element (the end of @stack)
Much of the interesting stuff happens in the on_end_element() method.
Here, we close out the current container element by popping it off the stack.
For any container element, we also add a random property containing a freshly generated random number.
We’ll use this later when selecting a random track, album, or artist.
Ruby’s ARGF stream combines standard input and any files specified on the command line.
We feed this into LibXML and specify an instance of our JamendoCallbacks class to handle the tokens—start tags, end tags, and character data—as they’re encountered.
To run the script, pipe the unzipped XML content into the import script:
When the import has finished, drop back down to the command line, and we’ll see how our views look.
The limit URL parameter specifies that we want only that number of documents in the response (or less)
The previous request started at the very beginning of the list of artists.
To jump to the middle, we can use the startkey parameter:
Previously, we started with artists whose names began with C.
Specifying an endkey provides another way to limit the returned content.
Here we specify that we want artists only between C and D:
To get the rows in reverse order, use the descending URL parameter.
Be sure to reverse your startkey and endkey as well.
A number of other URL parameters are available for modifying view requests, but these are the most common and are the ones you’ll reach for most often.
Some of the URL parameters have to do with grouping, which comes from the reducer part of CouchDB mapreduce views.
We learned how to create basic views in CouchDB and save them into design documents.
We explored different ways of querying views to get subsets of the indexed content.
Using Ruby and a popular gem called couchrest, we imported structured data and used it to support our views.
Leading into tomorrow, we’ll expand on these ideas by creating more advanced views by adding reducers and then move on to other APIs that CouchDB supports.
Find a list of available URL parameters (like limit and startkey) that can be appended to view requests and what they do.
Create a mapper function that will emit key-value pairs where the key is the random number and the value is the band’s name.
Save this in a new design document named _design/random with the view name artist.
Craft a cURL request that will retrieve a random artist.
The import script also added a random property for each album, track, and tag.
Create three additional views in the _design/random design document with the view names album, track, and tag to match the earlier artist view.
Building on this experience, today we’ll take a closer look at views, dissecting the reduce part of the mapreduce equation.
After that, we’ll develop some Node.js applications in JavaScript to leverage CouchDB’s unique Changes API.
Lastly, we’ll discuss replication and how CouchDB handles conflicting data.
Mapreduce-based views provide the means by which we can harness CouchDB’s indexing and aggregation facilities.
In Day 2, all our views consisted of only mappers.
One great thing about the Jamendo data is its depth.
We’ll now turn our attention to tags to see whether we can write a deep inspecting view to collect and count them.
First, return to the Temporary View page, and then enter the following map function:
This function digs into the artist document and then down into each album, each track, and finally each tag.
With the map function in place, enter the following under Reduce Function:
This code merely sums the numbers in the values list—which we’ll talk about momentarily once we’ve run the view.
The value is always 1 as we indicated in the mapper, and the Key fields exhibit as much repetition as there is in the tracks themselves.
Notice, however, the Reduce checkbox in the top-right corner of the output table.
Check that box, and then look at the table again.
What happened? In short, the reducer reduced the output by combining like mapper rows in accordance with our Reducer Function.
Specifically, here’s a high-level outline of the steps CouchDB takes to build a view:
Send chunks of rows with the same keys to the reduce function.
If there was too much data to handle all reductions in a single call, call the reduce function again but with previously reduced values.
Repeat recursive calls to the reduce function as necessary until no duplicate keys remain.
Reduce functions in CouchDB take three arguments: key, values, and rereduce.
The first argument, key, is an array of tuples—two element arrays containing the key emitted by the mapper and the _id of the document that produced it.
The second argument, values, is an array of values corresponding to the keys.
The third argument, rereduce, is a boolean value that will be true if this invocation is a rereduction.
That is, rather than being sent keys and values that were emitted from mapper calls, this call is sent the products of previous reducer calls.
Let’s work through an example based on the output we just saw.
Consider documents (artists) with tracks that have been tagged as “ambient.” The mappers run on the documents and emit key-value pairs of the form “ambient”/1
At some point, enough of these have been emitted that CouchDB invokes a reducer.
Recall that in our reducer function we take the sum() of values.
Since they’re all 1, the sum will simply be the length—effectively a count of how many tracks have the “ambient” tag.
Some time later, after CouchDB has run these kinds of calls several times, it decides to combine the intermediate reducer results by executing a rereduce:
They go on as long as there is reduction to be done, until all the intermediate values have been combined into one.
Most mapreduce systems, including the ones used by other databases we’ve covered in this book like Riak and MongoDB, throw away the output of mappers and reducers after the work is done.
In those systems, mapreduce is seen as a means to an end—something to be executed whenever the need arises, each time starting from scratch.
Once a view is codified into a design document, CouchDB will keep the intermediate mapper and reducer values until a change to a document would invalidate the data.
At that time, CouchDB will incrementally run mappers and reducers to correct for the updated data.
CouchDB is able to use mapreduce as its primary indexing mechanism by not tossing away intermediate data values.
CouchDB’s incremental approach to mapreduce is an innovative feature, to be sure; it’s one of many that set CouchDB apart from other databases.
This interface provides mechanisms for watching a database for changes and getting updates instantly.
The Changes API makes CouchDB a perfect candidate for a system of record.
Examples might include a search engine backed by Lucene or ElasticSeach or a caching layer implemented on memcached or Redis.
You could have different maintenance scripts kick off in response to changes too —performing tasks such as database compaction and remote backups.
In short, this simple API opens up a world of possibilities.
Because Node.js is event-driven and code for it is written in JavaScript, it’s a natural fit for integrating with CouchDB.
If you don’t already have Node.js, head over to the Node.js site and install the latest stable version (we use version 0.6)
The three flavors of the Changes API are polling, long-polling, and continuous.
As always, we’ll start with cURL to get close to the bare metal and then follow up with a programmatic approach.
The first and simplest way to access the Changes API is through the polling interface.
Head to the command line, and try the following (the output was truncated for brevity; yours may differ):
When you send a GET request for _changes with no other parameters, CouchDB will respond with everything it has.
Just like accessing views, you can specify a limit parameter to request just a subset of the data, and adding include_docs=true will cause full documents to be returned.
Typically you won’t want all the changes from the beginning of time.
You’re more likely to want the changes that have occurred since you last checked.
If you specify a since value that’s higher than the last sequence number, you’ll get an empty response:
Polling is a fine solution if your need for up-to-date changes can suffer delays between updates.
If updates are relatively rare, this would be the case.
For example, if you were pulling blog entries, polling every five minutes might be just fine.
If you want updates quicker, without incurring the overhead of reopening connections, then longpolling is a better option.
When you specify the URL parameter feed=longpoll, CouchDB will leave the connection open for some time, waiting for changes to happen before finishing the response.
You should see the beginning of a JSON response but nothing else.
If you leave the terminal open long enough, CouchDB will eventually close the connection by finishing it:
From a development perspective, writing a driver that watches CouchDB for changes using polling is equivalent to writing one for longpolling.
The difference is essentially just how long CouchDB is willing to leave the connection open.
Now let’s turn our attention to writing a Node.js application that watches and uses the change feed.
Node.js is a strongly event-driven system, so our CouchDB watcher will adhere to this principle as well.
Our driver will watch the changes feed and emit change events whenever CouchDB reports changed documents.
To get started, we’ll look at a skeletal outline of our driver, talk about the major pieces, and then fill in the feed-specific details.
Without further ado, here’s the outline of our watcher program, as well as a brief discussion of what it does:
Adding the createWatcher() method to exports makes it available to other Node.js scripts that might want to use this as a library.
The options argument allows the caller to specify which database to watch as well as override other connection settings.
The relevant capabilities of an EventEmitter is that you can listen to events by calling its on() method and trigger events by calling its emit() method.
When changes to documents happen, watcher should emit them as change events.
All of the feed-specific implementation details will be in here.
The last chunk of code at the bottom specifies what the script should do if it’s called directly from the command line.
In this case, the script will invoke the createWatcher() method and then set up listeners on the returned object that dump results to standard output.
Which database to connect to and what sequence ID number to start from can be set via commandline arguments.
So far, there’s nothing specific to CouchDB at all in this code.
This code may look foreign to you, especially if you haven’t developed with an event-driven server technology before, but it’s one we’ll be using increasingly in this book going forward.
With the skeleton in place, let’s add the code to connect to CouchDB via longpolling and emit events.
The following is just the code that goes inside the watcher.start() method.
The first thing this script does is set up the http_options configuration object in preparation for the request.
After that, the script calls http.get(), a Node.js library method that fires off a GET request according to our settings.
The second parameter to http.get is a callback that will receive an HTTPResponse.
The response object emits data events as the content is streamed back, which we add to the buffer.
Finally, when the response object emits an end event, we parse the buffer (which should contain JSON)
From this we learn the new last_seq value, emit a change event, and then reinvoke watcher.start() to wait for the next change.
To run this script in command-line mode, execute it like this (output truncated for brevity):
Hurrah, our app works! After outputting a record for each document, the process will keep running, polling CouchDB for future changes.
Next we’ll see how to go full-steam ahead and use the continuous feed to get even snappier updates.
The polling and longpolling feeds produced by the _changes service both produce proper JSON results.
Instead of combining all available changes into a results array and closing the stream afterward, it sends each change separately and keeps the connection open.
This way, it’s ready to return more JSON serialized change notification objects as changes become available.
To see how this works, try the following (output truncated for readability):
Eventually, if no changes have happened for a while, CouchDB will close the connection after outputting a line like this:
The benefit of this method over polling or longpolling is the reduced overhead that accompanies leaving the connection open.
On the other hand, the output isn’t straight JSON, which means it’s a bit more of a chore to parse.
Also, it’s not a good fit if your client is a web browser.
A browser downloading the feed asynchronously might not receive any of the data until the entire connection finishes (better to use longpolling in this case)
As we’ve just seen, the Changes API provides a unique window into the goings on of a CouchDB database.
On the plus side, it provides all the changes in a single stream.
However, sometimes you may want just a subset of changes, rather than the fire hose of everything that has ever changed.
For example, you may be interested only in document deletions or maybe only in documents that have a particular quality.
A filter is a function that takes in a document (and request information) and makes a decision as to whether that document ought to be allowed through the filter.
Considering our music database, most artist documents we’ve been inserting have a country property that contains a three-letter code.
Say we were interested only in bands from Russia (RUS)
If we added this to a design document under the key filters, we’d be able to specify it when issuing requests for _changes.
Rather than always wanting Russian bands, it’d be better if we could parameterize the input so the country could be specified in the URL.
Notice this time how we’re comparing the document’s country property to a parameter of the same name passed in the request’s query string.
To see this in action, let’s create a new design document just for geography-based filters and add it:
Using filters, you have the power to set up a sort of pseudosharding, where only a subset of records are replicated between nodes.
It’s not quite the same as truly sharded systems like MongoDB or HBase, but it does afford a means of splitting the responsibility of servicing certain kinds of requests.
For instance, your main CouchDB server might have separate filters for users, orders, messages, and inventory.
Separate CouchDB servers could replicate changes based on these filters, each supporting a different aspect of the business.
Since filter functions may contain arbitrary JavaScript, more sophisticated logic can be put into them.
Testing for deeply nested fields would be similar to what we did for creating views.
You could also use regular expressions for testing properties or compare them mathematically (for example, filtering by a date range)
There’s even a user context property on the request object (req.userCtx) you can use to find out more about the credentials provided with the request.
For now, though, it’s time to move on to the last distinguishing feature of CouchDB we’re going to cover: replication.
CouchDB’s approach makes sense in a lot of use cases.
It certainly fills a niche that the other databases we’ve discussed largely don’t address.
On the other hand, sometimes it’s nice to selectively replicate data between nodes in order to capitalize on available disk space.
That is, instead of having all nodes have all the data, keep only a certain number of copies.
This isn’t a feature that CouchDB offers out of the box, but don’t worry! BigCouch has you covered.
Developed and maintained by Cloudant, BigCouch offers a CouchDBcompatible interface (with only a few minor differencesa)
Under the surface, though, it implements the sharding and replication strategy of a Dynamo-inspired database like Riak.
Installing BigCouch is quite a chore—much harder than vanilla CouchDB—but may be worth it if your deployment scenario consists of a big-iron datacenter.
According to CouchDB, the safest place to store your data is everywhere, and it gives you the tools to do it.
Some other databases we’ve looked at maintain a single master node to guarantee consistency.
Still others ensure it with a quorum of agreeing nodes.
CouchDB does neither of these; instead, it supports something called multi-master or master-master replication.
Each CouchDB server is equally able to receive updates, respond to requests, and delete data, regardless of whether it’s able to connect to any other server.
In this model, changes are selectively replicated in one direction, and all data is subject to replication in the same way.
Servers participating in replication will all have all of the data.
Replication is the last major topic in CouchDB that we’ll be discussing.
First we’ll see how to set up ad hoc and continuous replication between databases.
Then we’ll work through the implications of conflicting data and how to make applications capable of handling these cases gracefully.
To begin, click the Replicator link in the Tools menu on the right side of the page.
In the “Replicate changes from” dialog, choose music from the left drop-down menu and enter music-repl in the right-side slot.
This should produce an event message in the event log below the form.
To confirm that the replication request worked, go back to the Futon Overview page.
There should now be a new database called music-repl with the same number of documents as the music database.
If it has fewer, give it some time and refresh the page—CouchDB may be in the process of catching up.
Don’t be concerned if the Update Seq values don’t match.
That’s because the original music database had deletions and updates to documents, whereas the musicrepl database had only insertions to bring it up to speed.
Next we’ll create a conflict and then explore how to deal with it.
Keep the Replicator page handy because we’re going to be triggering ad hoc replication between music and music-repl frequently.
Drop back to the command line, and enter this to create a document in the music database:
On the Replicator page, click Replicate to trigger another synchronization.
We can confirm that the document was successfully replicated by retrieving it from the music-repl database.
Next, let’s update it in music-repl by adding an album called Conflicts of Interest.
And create a conflicting update in music proper by adding a different album: Conflicting Opinions.
At this point, both the music and music-repl databases have a document with an _id value of theconflicts.
Now the question is, what happens when we try to replicate between them?
With our document now in a conflicting state between the two databases, head back to the Replicator page and kick off another replication.
It turns out that CouchDB basically just picks one and calls that one the winner.
Using a deterministic algorithm, all CouchDB nodes will pick the same winner when a conflict is detected.
CouchDB stores the unselected “loser” documents as well so that a client application can review the situation and resolve it at a later date.
To find out which version of our document won during the last replication, we can request it using the normal GET request channel.
By adding the conflicts=true URL parameter, CouchDB will also include information about the conflicting revisions.
It contains a list of other revisions that conflicted with the chosen one.
By adding a rev parameter to a GET request, we can pull down those conflicting revisions and decide what to do about them.
The takeaway here is that CouchDB does not try to intelligently merge conflicting changes.
In our case, combining the two albums arrays by concatenating them makes sense, but one could easily think of scenarios where the appropriate action is not obvious.
For example, consider you’re maintaining a database of calendar events.
One copy is on your smartphone; another is on your laptop.
You get a text message from a party planner specifying the venue for the party you’re hosting, so you.
Later, back at the office, you receive another email from the planner specifying a different venue.
So, you update your laptop database and then replicate between them.
CouchDB has no way of knowing which of the two venues is correct.
The best it can do is make them consistent, keeping the old value around so you can verify which of the conflicting values should be kept.
It would be up to the application to determine the right user interface for presenting this situation and asking for a decision.
After that, we took a deep dive into the Changes API, including a jaunt into the world of event-driven server-side JavaScript development with Node.js.
Lastly, we took a brief look at how CouchDB achieves its master-master replication strategy and how client applications can detect and correct for conflicts.
How can you filter the changes coming out of the _changes API on the server side?
How can you use the _replicator database to persist replication relationships?
Implement watcher.start() such that it monitors the continuous _changes feed.
Hint: If you get stuck, you can find an example implementation in the downloads that accompany this book.
Create a view that emits conflicting revisions and maps them to the doc _id.
Through this chapter we’ve seen how to do a pretty wide range of tasks with CouchDB, from performing basic CRUD operations to building views out of mapreduce functions.
We saw how to watch for changes, and we explored developing nonblocking event-driven client applications.
Finally, we learned how to perform ad hoc replication between databases and how to detect and resolve conflicts.
Despite all of this content, there’s still a lot we didn’t cover, but now it’s time to wrap things up before heading off to our next database.
CouchDB is a robust and stable member of the NoSQL community.
Built on the philosophy that networks are unreliable and hardware failure is imminent, CouchDB offers a heartily decentralized approach to data storage.
Small enough to live in your smartphone and big enough to support the enterprise, CouchDB affords a variety of deployment situations.
In this chapter, we focused on the canonical Apache CouchDB project, but there are an increasing number of alternative implementations and CouchDB service providers built on hybrid back ends.
Because CouchDB is made “of the Web, for the Web,” it’s fairly straightforward to layer in web technologies—such as load balancers and caching layers—and still end up with something that’s true to CouchDB’s APIs.
CouchDB’s mapreduce-based views, while novel, can’t perform all the fancy data slicing you’d expect from a relational database.
In fact, you shouldn’t be running ad hoc queries at all in production.
CouchDB replication is all or nothing, meaning all replicated servers will have the same contents.
There is no sharding to distribute content around the datacenter.
The principal reason for adding more CouchDB nodes is not to spread the data around so much as to increase throughput for read and write operations.
CouchDB’s attention to robustness in the face of uncertainty makes it a great choice if your system must stand up to the harsh realities of the wild Internet.
By leveraging standard webisms like HTTP/REST and JSON, CouchDB fits in easily wherever web technologies are prevalent, which is increasingly everywhere.
Inside the walled garden of a datacenter, CouchDB can still make sense if you commit to managing conflicts when they arise or if you pursue an alternative implementation like BigCouch, but don’t expect to get sharding right out of the box.
There are plenty of other features that make CouchDB unique and special that we didn’t have time to cover.
A short list would include ease of backups, binary attachments to documents, and CouchApps—a system for developing and deploying web apps directly through CouchDB with no other middleware.
Having said that, we hope we’ve provided enough of an overview to whet your appetite for more.
Try CouchDB for your next data-driven web app; you won’t be disappointed!
Bungee cord is used to tie things together —no matter how awkwardly shaped the objects may be.
If your ability to tie a table to a column to a pickup truck in the most organic way is of the utmost importance, this is your go-to tool.
Neo4j is a new type of NoSQL datastore called a graph database.
As the name implies, it stores data as a graph (in the mathematical sense)
It’s known for being “whiteboard friendly,” meaning if you can draw a design as boxes and lines on a whiteboard, you can store it in Neo4j.
Neo4j focuses more on the relationships between values than on the commonalities among sets of values (such as collections of documents or tables of rows)
In this way, it can store highly variable data in a natural and straightforward way.
Neo4j is small enough to be embedded into nearly any application.
On the other end of the spectrum, Neo4j can store tens of billions of nodes and as many edges.
And with its cluster support with master-slave replication across many servers, it can handle most any sized problem you can throw at it.
Imagine you must create a wine suggestion engine where wines have different varieties, regions, wineries, vintages, and designations.
Perhaps you need to keep track of articles by authors describing wines.
A relational model may create a category table and a many-to-many relationship between a single winery’s wine and some combination of categories and other data.
Compare these two figures: Figure 30, Wine suggestion schema in relational UML, on.
There’s an old saying in the relational database world: on a long enough timeline, all fields become optional.
Neo4j handles this implicitly by providing values and structure only where necessary.
If a wine blend has no vintage, instead add a bottle year and point the vintages to the blend node.
Over the next three days we’ll learn how to interact with Neo4j through a console and then through REST and search indexes.
Most of the actions we perform can actually use the GPL Community edition, but we’ll require some enterprise functionality for Day 3: high availability.
Today we’re really going to jump in with both feet.
In addition to exploring the Neo4j web interface, we’ll get deep into graph database terminology and CRUD.
Much of today will be learning how to query a graph database through a process called walking.
The concepts here differ significantly from other databases we’ve looked at so far, which have largely taken a document- or record-based view of the world.
But before we get to all that, let’s start with the web interface to see how Neo4j represents data in graph form and how to walk around that graph.
After you’ve downloaded and unzipped the Neo4j package, cd into the directory and start up the server with this:
To make sure you’re up and running, try curling this URL:
Like CouchDB, the default Neo4j package comes equipped with a substantial web administration tool and data browser, which is excellent for playing with toy commands.
If that weren’t enough, it has one of the coolest graph data browsers we’ve ever seen.
This is perfect for getting started, since graph traversal can feel very awkward at first try.
Launch a web browser, and navigate to the administration page.
You’ll be greeted by a colorful yet empty graph like the one pictured in Figure Browser option at the top.
A node in a graph database is not entirely unlike the nodes we talked about in prior chapters.
Previously, when we spoke of a node, we meant a physical server in a network.
If you viewed the entire network as a huge interconnected.
In Neo4j, a node is conceptually similar; it’s a vertex between edges that may hold data, as a set of key-values.
Click the + Property button and set the key to name and value to Prancing Wolf Ice Wine 2007 to represent a specific wine and vintage.
To the new node, add the property name with a value of Wine Expert Monthly (we’ll write it in shorthand like this: [name : "Wine Expert Monthly"])
Now we have two nodes sitting out there but nothing connecting them.
Since Wine Expert reported on the Prancing Wolf wine, we need to relate the two by creating an edge.
Click the + Add Property button and enter the property [rating : 92] so we can keep track of what score the wine received.
This particular ice wine is created from the riesling grape, so let’s add that information too.
We could add the property directly to the wine node, but riesling is a general category that could apply to other wines, so let’s create a new node and set its property to [name : "riesling"]
Although the web interface is an easy way to make a few edits, we need a more powerful interface for production work.
There are several languages that interoperate with Neo4j: Java code, REST, Cypher, Ruby console, and others.
The one we’ll use today is called Gremlin, which is a graph traversal language written in the Groovy programming language.
You needn’t actually know Groovy to use Gremlin, however, so think of it as just another declarative domain-specific language, like SQL.
Like other consoles we’ve explored, Gremlin provides access to the underlying language infrastructure on which it’s based.
This means you can use Groovy constructs and Java libraries in Gremlin.
We found it a powerful and more natural way of interacting with graphs than Neo4j’s native Java code.
And even better, the Gremlin console is available in the Web Admin; just click the Console link at the top, and choose Gremlin.
As a matter of convention, g is a variable that represents the graph object.
Since Gremlin is a general-purpose graph traversal language, it uses general mathematic graph terms.
Where Neo4j calls a graph data point a node, Gremlin prefers vertex, and rather than relationship, Gremlin calls it an edge.
Figure 33—A graph of nodes related to the current one.
To access all of the vertices in this graph, there is a property simply named V for vertices.
You can grab a particular vertex by passing a node number into the v (lowercase) method.
To make sure you have the correct vertex, you can list its properties via the map() method.
Once you have a vertex, you can get the outgoing edges by calling outE() on the returned vertex.
Incoming edges are retrieved by inE(), and both incoming and outgoing are called by bothE()
Note that in Groovy, like Ruby, method parentheses are optional for methods, so calling outE is fine too.
From the out edges, you can walk to incoming vertices with inV—that is, the vertices into which the edges point.
Then retrieve the name property by calling it on the vertex.
The expression outE.inV asks for any vertices to which the input vertices have edges.
The reverse operation (asking for all vertices that have edges into the input vertices) is achieved with inE.outV.
Because these two operations are so common, Gremlin has shorthand versions of both.
The expression out is short for outE.inV, and in is short for inE.outV.
A winery makes more than one wine, so if we plan to add more, we should add the winery as a joining node and add an edge to the Prancing Wolf.
From here we’ll add a couple more rieslings: Kabinett and Spatlese.
Let’s wrap up this little graph by adding some edges from the riesling vertex to the newly added vertices.
We’ll set the riesling variable by filtering the riesling node; next() is necessary to grab the first vertex out of the pipelinesomething we will go over in more detail shortly.
The Spatlese can be pointed to riesling in a similar way, but with the style set to spatlese.
You can think of Gremlin operations as a series of pipes.
Each pipe takes a collection as input and pushes a collection as output.
A collection may have one item, many items, or no items at all.
For example, the outE pipe takes in a collection of vertices and sends out a collection of edges.
The series of pipes is called a pipeline and expresses declaratively what the problem is.
Contrast this with a typical imperative programming approach, which would require you to describe the steps to solve the problem.
Using pipes is one of the most concise ways to query a graph database.
At its heart, Gremlin is a language to build these pipes.
Specifically, it is built on top of a Java project named Pipes.
To explore the pipe concept, let’s return to our wine graph.
Suppose we want to find wines that are similar to a given wine—that is, they have the same type.
We can follow an ice wine that also shares a grape_type edge with other out nodes (ignoring the initial wine node)
Figure 35—A graph of nodes after adding data with Gremlin.
If you’ve worked in Smalltalk or Rails with scopes, this style of method chaining will seem familiar to you.
But compare the previous to using the standard Neo4j Java API shown next, where a node’s relationships must be iterated through in order to access the varietal nodes.
Rather than nesting and iterating as shown earlier, the Pipes project designed a way to declare incoming and outgoing vertices.
You create a sequence of in and out pipes, filters, and request values from the pipeline.
Then iteratively call the pipeline’s hasNext() method, which returns the next matching node.
In other words, the pipeline walks the tree for you.
Until the pipeline is requested, you’re simply declaring how the walk will occur.
To illustrate, here’s another implementation of the same_variety() method, which uses Pipes rather than explicitly looping:
One way to do that in jQuery is with code like this:
Next, consider what a Gremlin query might look like for a similar data set, imagining that each parent node has an edge pointing to each of its children.
To grab a collection containing just one specific vertex, we can filter it from the list of all nodes.
This is what we have been doing when we call, for.
Cypher Language Cypher is the other graph query language supported by Neo4j, based on pattern matching and a SQL-like syntax.
The clauses feel familiar, making it easy to understand what’s going on.
Particularly, the MATCH clause is very intuitive, resulting in ASCII art–like expressions.
At first I didn’t like Cypher’s verbosity, but over time as my eyes adjusted to reading its grammar, I’ve become a fan.
Look at this Cypher equivalent of our “similar wines” query:
The MATCH clause uses identifiers within parentheses to indicate nodes and typed “arrows” like -[:grape_type]-> for directional relationships.
I actually like this construct, because it’s easy to visualize the node walk.
This is a more real-world style example—every bit as powerful and wordy as SQL.
While I chose to focus on Gremlin in the main chapter, the two languages are natural complements and happily coexist.
In day-to-day work, you’ll find reasons to use either, depending on how you think about the problem at hand.
If you look at the class constructed by calling the filter’s class property, notice it returns GremlinPipeline.
Compare that to the class of the next node from the pipeline.
Although the console conveniently lists the nodes retrieved from the pipeline, it remains a pipeline until you retrieve something from it.
Creating a social aspect to the graph is as easy as adding more nodes.
Suppose we want to add three people—two who know each other and one stranger, each with their own wine preferences.
Alice has a bit of a sweet tooth and so is a big ice wine fan.
Tom loves Kabinett and ice wine and trusts anything written by Wine Expert Monthly.
Patty is friends with both Tom and Alice but is new to wine and has yet to choose any favorites.
Without changing any fundamental structure of our existing graph, we were able to superimpose behavior beyond our original intent.
The new nodes are related, as visualized in the following:
We’ve looked at a few core Gremlin steps, or Pipe-processing units.
Let’s take a look at more of these building blocks that not only walk the graph but also transform objects, filter steps, and produce side effects like counting nodes grouped by criteria.
We’ve seen inE, outE, inV, and outV, which are transform steps for retrieving the incoming and outgoing edges and vertices.
Two other types are bothE and bothV, which just follow an edge, regardless of whether it is directed in or out.
We’ll tack name to the end to get each vertice’s name property.
Since we don’t care which direction the friend edge goes, we’ll use bothE and bothV.
If we don’t want Alice, the except() filter lets us pass in a list of nodes we don’t want, and it walks the rest.
The opposite of except() is retain(), which, as you may have guessed, walks only matching nodes.
Another option is to instead filter the last vertex with a code block, where the current step is not equal to the alice vertex.
What if you wanted to know friends of Alice’s friends? You could just repeat the steps like so:
In the same fashion, we could get friends of Alice’s friends’ friends by adding more bothE/bothV/except calls to the chain.
But that’s a lot of typing, and it’s not possible to write this for a variable number of steps in this manner.
It repeats some number of previous steps and continues while the given closure is still true.
The following code will loop the previous three steps by counting periods back from the loop call.
So, except is one, bothV is two, and bothE is three.
That’s because one matches Patty as a friend of Alice, and the other matches because she is friends with Tom.
So, now we need a way to filter out duplicate objects, which the dedup() (de-duplicate) filter provides.
To get more insight into the path taken to arrive at these values, you can follow the friend->friend path by using the paths() transform.
All traversals you’ve done so far have been to walk forward through a graph.
Sometimes you need to take two steps forward and two steps back.
Starting with the Alice node, we walk out two steps and then back two, which returns us to the Alice node.
The last commonly used step we’ll investigate is groupCount(), which walks through the nodes and counts duplicate values, capturing them in a map.
Consider this example that collects all the name properties of all vertices in the graph and counts how many of each there are:
Next, let’s count up the number of wines liked by each person in our system.
We can get all of the liked vertices and count up the numbers per name.
As we should expect, Alice liked one wine, and Tom liked two.
Besides the Gremlin steps, we also get the wide array of Groovy language constructs and methods.
Groovy has a map function (a la mapreduce) named collect() and a reduce function named inject()
Consider the case where we want to count how many wines have not yet been rated.
We can do this by first mapping out a list of true/false values indicating whether each wine has been rated.
Then, we can run that list through a reducer to count up all the trues and falses.
Only wines will have this type of edge, so we have our list of all wines in the system.
The toList() call forces the pipeline to become a true list, which we can then test for emptiness.
The rated_list produced by this code will be a list of true and false values.
To count how many wines have not been rated, we can run that list through a reducer using the inject() method.
In Groovy, the arrow operator (->) separates the input arguments for a closure from the body of the closure.
In our reducer, we need to keep track of the accumulated count and process whether the current wine has been rated or not, which is the reason for count and is_rated.
Then, within the body of the closure function, we either return the current count if the wine has already been rated or return that value plus 1 if it hasn’t been rated.
The final output will be the number of false values in the list (that is, the count of unrated wines)
So, it turns out that two of our wines are as yet unrated.
With all these tools available, you can craft many powerful combinations of graph traversals and transformations.
Suppose we want to find all of the pairs of friends in our graph.
To do that, first we need to find all edges with a friends type and then output the names of both people who share that edge by using the transform operation.
In the previous code, the return value of the transform closure is an array literal ([...]) with two elements: the output and input vertices to the friend edge.
To find all people and the wines they like, we transform our output of people (identified as vertices with friends) into a list with two elements: the name of the person and a list of wines they like.
Gremlin definitely takes a little getting used to, especially if you haven’t done much Groovy programming before.
Once you get the hang of it, you’ll find it’s an expressive and powerful way to perform queries against Neo4j.
Graph traversal is nice, but businesses and organizations tend to converse in domain-specific languages.
For example, we wouldn’t normally ask “What is the vertex with the incoming edge of grape_type sharing the outgoing edge of this wine’s vertex?” but rather “What varietal is this wine?”
Gremlin is already a language specific to the domain of querying graph databases, but what about making the language even more specific? Gremlin lets us do this by creating new steps that are semantically meaningful to the data stored in the graph.
Let’s start by creating a new step named varietal that seeks to answer the question posed before.
When varietal() is called on a vertex, it will look for outgoing edges of type grape_type and step to those related vertices.
We’re getting into a bit of Groovy-foo here, so we’ll first look at our code to create the step and then describe it line by line.
First we tell the Gremlin engine we’re adding a new step called varietal.
The second line tells Gremlin that this new step should attach to both Vertex and Pipe classes (when in double, just use both)
Effectively, this creates a closure that contains the code this step should execute.
From this object, we walk to any neighbor nodes related by a grape_type edge—that is, the varietal node.
Calling our new step is just like any other step.
For example, the following gets the name of the ice wine’s varietal:
This time we’re making a step for a commonly requested action: get all friends’ favorite wines.
Now we’re cooking with pipes! We can call this new step as we normally would.
Since varietal and friendsuggest are just normal Pipe-building steps, you can chain them together to make more interesting queries.
The following finds the varietals that Patty’s friends like best:
Using Groovy metaprogramming to create new steps is a powerful force for crafting domain-specific languages.
But like Gremlin itself, the practice can take some getting used to.
You’ve inserted and stepped through a graph, but what about updating and deleting data? It’s easy enough, once you find the vertex or edge you want to alter.
Before we call it a day and go into some homework, we should cover how to clean up our database.
Don’t run these commands until you’ve finished the homework for the day!
The graph object has functions to remove vertices and edges, removeVertex and removeEdge, respectively.
We could destroy our graph by removing all vertices and edges.
You can validate they are gone by calling g.V and g.E.
Or you can achieve the same thing with the ridiculously dangerous clear() method.
If you’re running your own Gremlin instance (outside of the web interface), it’s a good idea to cleanly shut down the graph connection with the shutdown() method.
But usually it will just yell at you the next time you connect to the graph.
Today we got to peek at the graph database Neo4j—and what a different beast it is.
Although we didn’t cover specific design patterns, our brains were buzzing with possibilities when we first began working with Neo4j.
If you can draw it on a whiteboard, you can store it in a graph database.
We’ll create nodes and relationships using REST and then use REST to index and execute a full-text search.
We’ll then look at a plug-in that lets us execute Gremlin queries on the server through REST, freeing our code from the confines of the Gremlin console—or even running Java at all in our application server or clients.
One of the reasons all of these databases support REST is because it allows language-agnostic interactions in a standard connection interface.
We can connect to Neo4j—which requires Java to work—from a separate machine with no trace of Java whatsoever.
And with the Gremlin plug-in, we’ll see how to gain the power of its terse query syntax over REST.
First you might want to check that the REST server is running by issuing a GET against the base URL, which retrieves the root node.
It runs on the same port as the web admin tool you used yesterday, at the /db/data/ path.
We’ll use our trusty friend curl to issue the REST commands.
It will return a nice JSON object describing the URLs of other commands, like node actions or indices.
It’s as easy to create nodes and relationships in Neo4j REST as in CouchDB or Riak.
Creating a node is a POST to the /db/data/node path with JSON data.
This makes viewing any node’s information easy: just call name.
When posted, you’ll get the node path in the header and a body of metadata about the node (both are truncated here for brevity)
All of this data is retrievable by calling GET on the given header Location value (or the self property in the metadata)
If you just want the node properties (not the metadata), you can GET that by appending /properties to the node URL or even an individual property by further appending the property name.
One node doesn’t do us much good, so go ahead and create another one with the properties ["name" : "Jeeves Takes Charge", "style" : "short story"]
Wodehouse wrote the short story “Jeeves Takes Charge,” we can make a relationship between them.
In this way, the REST interfaces tend to be mutually discoverable.
Through the REST interface, you can find the path between two nodes by posting the request data to the starting node’s /paths URL.
The POST request data must be a JSON string denoting the node you want the path to, the type of relationships you want to follow, and the path-finding algorithm to use.
The other path algorithm choices are allPaths, allSimplePaths, and dijkstra.
Details on these algorithms can be found in the online documentation,1 but covering them in detail is outside the scope of this book.
Like other databases we’ve seen, Neo4j supports fast data lookups by constructing indexes.
Unlike other database indexes where you perform queries in much the same way as without one, Neo4j indexes have a different path.
This is because the indexing service is actually a separate service.
You key the index by some node data, and the value is a REST URL, which points to the node in the graph.
You can have as many indexes as you like, so we’ll name this one “authors.” The end of the URL will contain the author name we want to index and pass in node 1 as the value (or whatever your Wodehouse node was)
Retrieving the node is simply a call to the index, which you’ll notice doesn’t return the URL we set but instead the actual node data.
Besides key-value, Neo4j provides a full-text search inverted index, so you can perform queries like this: “Give me all books that have names beginning with ’Jeeves.’” To build this index, we need to build it against the entire dataset, rather than our one-offs earlier.
Like Riak, Neo4j incorporates Lucene to build our inverted index.
The POST will return a JSON response containing information about the newly added index.
Now if we add Wodehouse to the full-text index, we get this:
Then a search is as easy as a Lucene syntax query on the index URL.
Indexes can also be built on edges like earlier; just replace the instances of node in the URLs with relationship, for example http://localhost:7474/db/data/index/relationship/published/date/1916-11-28
We spent much of Day 1 using Gremlin and the first half of today using the REST interface.
This allows you the power and flexibility of both tools in production.
This is a great combination, since Gremlin is better geared toward powerful queries, where REST is geared toward deployment and language flexibility.
You only need to send the data to the plug-in URL as a JSON string value, under the field script.
Although code samples from here on out will use Gremlin, bear in mind that you could instead choose to use REST.
Up until now we’ve dealt with very small data sets, so now it’s time to see what Neo4j can do with some big data.
Let’s explore some movie data by grabbing a dataset from Freebase.com.
We’ll be using the “performance” tab-separated set.3 Download the file and use the following script, which iterates through each line and creates a relationship between new or existing nodes (matches are found by name in the index)
Be warned, this dataset contains a vast amount of movie information, from blockbusters to foreign films to, well, adult entertainment.
You will need the json and faraday Ruby gems installed to run this script.
With everything set up, just run the script and point it to the downloaded performance.tsv file.
This can take hours to run the whole dataset, but you can stop the process at any time for a partial movie/actor list.
With our big movie dataset, it’s time to hang up our REST interface for a while and jump back into Gremlin.
Let’s have a little fun implementing one of the more famous graph algorithms in existence: the Kevin Bacon algorithm.
This algorithm is based on a game to find the shortest distance between any actor and Kevin Bacon through commonly acted movies.
Before continuing, fire up your Gremlin console and start up the graph.
Then we’ll create the costars custom step with the following code.
It finds the costars of an actor node (actors who share an edge with the initial actor’s movies)
In Neo4j you don’t so much “query” for a set of values as you “walk” the graph.
The nice thing about this concept is that generally the first node walked to will be the closest to your starting node (in terms of raw edge/node distance, not of weighted distance)
We start by finding an actor’s costars’ costars’ costars…the classic stopping distance is six degrees, but practically we can stop at four (if you don’t find a match, you can try again)
Here we can loop through the graph four times, which finds all actors with “four degrees of separation.” We’ll use the costars step we just created.
Only vertices that end with Bacon are to be retained.
Just to ensure we don’t want to continue looping back to the Kevin Bacon node for a second pass, hitting the bacon node short-circuits the loop.
Or, in other words, loop as long as the loop hasn’t occurred four times and we are not on the bacon node.
Then we can output the paths taken to arrive at each bacon node.
With that, we only need to pop the first path off the top of the list of possible paths—the shortest path will be arrived at first.
The >> nomenclature just pops the first item off the list of all nodes.
Finally, we get the name of each vertex and filter out any null edge data using the Groovy grep command.
We didn’t know who Roddy McDowall was, but that’s the beauty of our graph database.
We didn’t have to know to get a good answer.
Feel free to sharpen your Groovy-foo if you want the output to be fancier than our simple list, but the data is all there.
When looking for good sample from a large data set, a useful trick is the “random walk.” You start with a random number generator.
Then you filter out some target ratio of the total.
The count should be somewhere around twenty random titles from the Bacon canon.
Taking a second-degree step away from Kevin Bacon, his costars’ costars, creates quite a list (more than 300,000 in our data set)
But if you need only about 1 percent of that list, add a filter.
Also note the filter is itself a step, so you’ll need to add one more to your loop number.
We received Elijah Wood, who we can run through our Bacon path algorithm and reasonably expect two steps (Elijah Wood acted in Deep Impact with Ron Eldard, who was in Sleepers with Kevin Bacon)
Centrality is a measure of individual nodes against a full graph.
For example, if we wanted to measure how important each node in a network is based on its distance to all the other nodes, that would require a centrality algorithm.
The most famous centrality algorithm is probably Google’s PageRank, but there are several styles.
We’ll execute a simple version called eigenvector centrality, which just counts the number of in or out edges related to a node.
We’re going to give each actor a number related to how many roles they have played.
We need a map for groupCount() to populate and a count to set a maximum number or loops.
The role_count map will be keyed by vertices, with values of the count of edges the vertex has.
The easiest way to read the output is by sorting the map.
Writing your own algorithms is fine, but most of this work has already been done for you.
The Java Universal Network/Graph (JUNG) Framework is a collection of common graph algorithms and other tools for modeling and visualizing graphs.
Thanks to the Gremlin/Blueprint project, it’s easy to access JUNG’s algorithms, such as PageRank, HITS, Voltage, centrality algorithms, and graph-as-a-matrix tools.
We recommend the latter option for this project, since it will save you the hassle of hunting down several Java archive files (jars)
Assuming you’ve downloaded the gremlin console, shut down your neo4j server and start up Gremlin.
You’ll have to create the Neo4jGraph object and point it to your installation’s data/graph directory.
The Neo4jGraph object needs to be wrapped in a GraphJung object, which we’ll call j.
Part of the reason Kevin Bacon was chosen as the ultimate path destination is his relative closeness to other actors.
To be important, he didn’t need to be in many roles himself but simply be connected to those who are well connected.
This raises the question: can we find a better actor than Kevin Bacon, in terms of distance from other actors?
If Kevin Bacon is indeed the best choice, we would expect his score to be the lowest, meaning he is “closest” to all other actors.
Our JUNG algorithm should apply only to actors, so we construct a transformer to filter only actor nodes.
Next, we need to import the algorithm itself, passing in our GraphJung and transformer.
With that, we can get the BarycenterScorer score of any node.
Once we have Kevin Bacon’s score, we can go through every vertex and store any that have a score lower than his.
It could take a really long time to execute the BarycenterScorer score for each actor in our database.
So, instead, let’s just run the algorithm against each of Kevin’s costars.
This may take a few minutes, depending on your hardware.
BarycenterScorer is fast, but executing over each of Bacon’s costars adds up.
All of the keys that exist in the connected map represent a better choice than Kevin Bacon.
But it’s good to have a name we recognize, so let’s output them all and pick one we like.
Your output will vary from ours, since the public movie dataset is always in flux.
Donald Sutherland appeared in the list with a respectable ~0.00925
So, hypothetically, the Six Degrees of Donald Sutherland should be an easier game to play with your friends than the traditional Six Degrees of Kevin Bacon.
With our j graph we can now run any JUNG algorithm on our dataset, for example PageRank.
The full list of JUNG algorithms can be found in their online Javadoc API.
More are added all the time, so it’s a good place to look before implementing your own.
We saw how, using the Gremlin plug-in, we can execute Gremlin code on the server and have the REST interface return results.
We played around with a larger dataset and finally finished up with a handful of algorithms for diving into that data.
Bookmark the API for the JUNG project and the algorithms it implements.
Find a binding or REST interface for your favorite programming language.
Choose and run one of the many JUNG algorithms on a node (or the data set, if the API demands it)
Install your driver of choice, and use it to manage your company graph with the people and the roles they play, with edges describing their interactions (reports to, works with)
Find the most well-connected person in the organization by closest distance to all other nodes.
We’ll see how Neo4j keeps data stable via ACID-compliant transactions.
Then we’ll install and configure a Neo4j high availability (HA) cluster to improve availability when serving high-read traffic.
Then we’re going to look into backup strategies to ensure our data remains safe.
This makes it a good option for important data you may have otherwise picked a relational database for.
Just like transactions we’ve seen before, Neo4j transactions are all-or-nothing operations.
When a transaction starts, every following operation will succeed or fail as an atomic unit—failure of one means failure of all.
The details of how transactions are handled goes beyond Gremlin into the underlying Neo4j wrapper project called Blueprint.
If you’re using a different version of either, you can find the specifics in the Blueprint API Javadocs.
Just like PostgreSQL, basic one-line functions are automatically wrapped in an implicit transaction.
To demonstrate multiline transactions, we need to flag the graph object to turn off automatic transaction mode, letting Neo4j.
When you stop the transaction, you also need to mark whether the transaction was successful.
If not, Neo4j can roll back all commands executed since the start.
It’s a good idea to wrap the transaction within a try/catch block to ensure that any exceptions will trigger a rollback.
You may have to use this style if you write Java code or use a language that is Java under the covers—like JRuby.
Even system failure will ensure any writes are rolled back when the server is fired back up.
High availability mode is Neo4j’s answer to the question, “Can a graph database scale?” Yes, but with some caveats.
A write to one slave is not immediately synchronized with all other slaves, so there is a danger of losing consistency (in the CAP sense) for a brief moment (making it eventually consistent)
It’s for this reason that Neo4j HA is touted as a solution largely for increasing capacity for reads.
Just like Mongo, the servers in the cluster will elect a master that is the gold copy of data.
Slave writes will synchronize with the master node, which then propagates those changes to the other slaves.
To use Neo4j HA, we must first set up a cluster.
Zookeeper is yet another excellent project to arise from the Apache Hadoop project.
Happily, Neo4j Enterprise comes bundled with Zookeeper as well as some files to help us configure a cluster.
You can download a copy from the website for your operating system (be sure you select the correct edition)5 and then unzip it and create two more copies of the directory.
Normally you would unpack one copy per server and configure the cluster to be aware of the other servers.
But since we’re running them locally, we’ll instead run them on different directories using different ports.
We will follow five steps to create our cluster, starting by configuring the Zookeeper cluster coordinators and then the Neo4j servers.
Configure each coordinator server to communicate with the other servers and its hosted Neo4j server.
Configure each Neo4j server to run in HA mode, give them unique ports, and make them aware of the coordinator cluster.
Zookeeper tracks each server by way of an ID unique to the cluster.
We must also indicate some communication settings internal to the cluster.
Building the Cluster A Zookeeper quorum is a group of servers in the cluster and the ports they communicate through (this should not to be confused with a Riak quorum, which is a minimal majority for enforcing consistency)
The master election port is used when the master goes down—this special port is used so the.
Finally, we must set the public port to which Neo4j may connect.
If any of these ports are in use on your machine, feel free to change this as necessary, but we’ll assume the previous ports are in use for the remaining steps.
Coordinate We start up the Zookeeper coordinator with a handy script provided by the Neo4j team.
Run the following command in each of the three server directories:
This sets Neo4j to run in high availability mode; up until now we’ve been running in SINGLE mode.
While we’re in this file, let’s set the web server port to a unique number.
Finally, we set each Neo4j instance to connect to one of the coordinator servers.
These are high availability settings that convey three things: the current cluster machine number, the list of.
Again, the server ports needn’t change when you run them on separate machines.
Generally, you won’t go this low, but it lets us see updates for the example data we’ll soon insert.
With our Neo4j HA servers configured, it’s time to start them up.
Just like the coordinator server startup script, start the neo4j server in each install directory.
You can watch the server output by tailing the log file.
Click the Server Info link at the top and then High Availability on the side menu.6
The properties under High Availability list information about this cluster.
If this server is the master server, the property will be true.
If not, you can find which server has been elected master by looking under InstancesInCluster.
This lists each connected server, its machine ID, whether it is the master server, and other info.
With our cluster up and running, you can verify that your servers are replicating correctly.
If all goes according to plan, any writes to a slave should propagate to the master node and then eventually to the other slave server.
If you open the web consoles for each of the three servers, you can use the built-in Gremlin consoles in the web admin.
To test our servers, we’re going to populate our new graph with some nodes containing the names of some famous paradoxes.
In one of the slave consoles, let’s set the root node to store Zeno’s paradox.
Now let’s switch to the master server’s console and output the vertex paradox values.
Now if you switch to the other slave server and add Russell’s paradox, a quick look at our list will reveal both nodes exist in the second slave, having added only one directly to this server.
If one of your slave servers does not yet have the changes propagated to it, you can go back to the Server Info, High Availability screen.
When these values are equal, the system data is consistent.
The lower the number, the older the version of data in that server.
If you shut down the master server and refresh the server info in one of the remaining servers, you will see that another server has been elected the new master.
Starting the server again will add it back to the cluster, but now the old master will remain a slave (until another server goes down)
High availability allows very read-heavy systems to deal with replicating a graph across multiple servers and thus sharing the load.
With the right tools, planning, and a good setup, you can build a graph database large enough to handle billions of nodes and edges and nearly any number of requests you may need.
Just add regular backups, and you have the recipe for a solid production system.
Backups are a necessary aspect of any professional database use.
Although backups are effectively built in when using replication, nightly backups that are stored off-site are always a good idea for disaster recovery.
It’s hard to plan for a server room fire or an earthquake shaking a building to rubble.
The most powerful method when running an HA server is to craft a full backup command to copy the database file from the cluster to a date-stamped file on a mounted drive.
Pointing the copy to every server in the cluster will ensure you get the most recent data available.
If you need to recover, just replace each installation’s data directory with the backup directory, and you’re ready to go.
Here we back up our HA cluster to a directory that ends with today’s date (uses the *nix date command)
If you’re not running in HA mode, just change the mode in the URI to single.
Once you have done a full backup, you can choose to do an incremental backup that will store changes only since the last backup.
If we want to do a full backup on a single server at midnight and then grab the incremental changes every two hours, you could execute this command:
But keep in mind incremental works only on a fully backed-up directory, so ensure the previous command is run on the same day.
Today we spent some time keeping Neo4j data stable via ACID-compliant transactions, high availability, and backup tools.
It’s important to note that all of the tools we used today require the Neo4j Enterprise edition, and so use a dual license—GPL/AGPL.
If you want to keep your server closed source, you should look into switching to the Community edition or getting an OEM from Neo Technology (the company behind Neo4j)
Set up a load balancer using a web server like Apache or Nginx, and connect to the cluster using the REST interface.
Neo4j is a top open source implementation of the (relatively rare) class of graph databases.
Graph databases focus on the relationships between data, rather than the commonalities among values.
You just create nodes and relationships between them and optionally hang key-value pairs from them.
Querying is as easy as declaring how to walk the graph from a starting node.
Neo4j is one of the finest examples of open source graph databases.
Graph databases are perfect for unstructured data, in many ways even more so than document datastores.
Not only is Neo4j typeless and schemaless, but it puts no constraints on how data is related.
The Neo4j distributions provide several tools for fast lookups with Lucene and easy-to-use (if sometimes cryptic) language extensions like Gremlin and the REST interface.
Like data is only a node step away, rather than joining values in bulk and filtering the desired results—as most of the databases we’ve seen operate.
It doesn’t matter how large the graph becomes; moving from node A to node B is always one step if they share a relationship.
Finally, the Enterprise edition provides for highly available and high readtraffic sites by way of Neo4j HA.
Edges in Neo4j cannot direct a vertex back on itself.
We also found its choice of nomenclature (node rather than vertex, and relationship rather than edge) to add complexity when communicating.
Although HA is excellent at replication, it can only replicate a full graph to other servers.
It cannot currently shard subgraphs, which still places a limit on graph size (though, to be fair, that limit measures in the tens of billions)
Finally, if you are looking for a business-friendly open source license (like MIT), Neo4j may not be for you.
Where the Community edition (everything we used in the first two days) is GPL, if you want to run a production environment using the Enterprise tools (which includes HA and backups), you’ll probably need to purchase a license.
If you choose to distribute, the name “high availability” cluster should give away their strategy.
Each slave will return only what it currently has, which may be out of sync with the master node temporarily.
Although you can reduce the update latency by increasing a slave’s pull interval, it’s still technically eventually consistent.
This is why Neo4j HA is recommended for read-mostly requirements.
Neo4j’s simplicity can be off-putting if you’re not used to modeling graph data.
It provides a powerful open source API with years of production use and yet still has relatively few users.
We chalk this up to lack of knowledge, since graph databases mesh so naturally with how humans tend to conceptualize data.
We imagine our families as trees, or our friends as graphs; most of us don’t imagine personal relationships as self-referential datatypes.
For certain classes of problems, like social networks, Neo4j is an obvious choice.
But you should give it some serious consideration for nonobvious problems as wellit just may surprise you how powerful and easy it is.
It’s most often used to lubricate moving parts and keep them working smoothly by reducing friction and speeding up their overall function.
Whatever the machinery of your system, it could very well be improved with a bit poured over it.
Sometimes the answer to your problem is simply a judicious use of more Redis.
First released in 2009, Redis (REmote DIctionary Service) is a simple-to-use key-value store with a sophisticated set of commands.
And when it comes to speed, Redis is hard to beat.
Reads are fast, and writes are even faster, handling upwards of 100,000 SET operations per second by some benchmarks.
Redis creator Salvatore Sanfilippo refers to his project as a “data structure server” to capture its nuanced handling of complex datatypes and other features.
It can be a bit difficult to classify exactly what Redis is.
At a basic level, it’s a key-value store, of course, but that simple label doesn’t really do it justice.
Redis supports advanced data structures, though not to the degree that a document-oriented database would.
It supports set-based query operations but not with the granularity or type support you’d find in a relational database.
And, of course, it’s fast, trading durability for raw speed.
In addition to being an advanced data structure server, Redis is a blocking queue (or stack) and a publish-subscribe system.
It features configurable expiry policies, durability levels, and replication options.
All of this makes Redis more of a toolkit of useful data structure algorithms and processes than a member of any specific database genre.
Redis’ expansive list of client libraries makes it a drop-in option for many programming languages.
Starting with simple CRUD operations like always, we’ll quickly move on to more advanced operations involving more powerful data structures: lists, hashes, sets, and sorted sets.
We’ll use Redis to create a simple message queue and explore its publish-subscribe functionality.
Databases are often and increasingly used in concert with each other.
Redis is introduced last in this book so that we can use it in just such a manner.
Of primary importance is its sophisticated datatypes and how they can query in more ways than simply “retrieve the value of this key.”
Once you have it installed, you can start up the server by calling this:
It won’t run in the background by default, but you can make that happen by appending &, or you can just open another terminal.
Next run the commandline tool, which should connect to the default port 6379 automatically.
Type help followed by a space and then start typing any command.
If you don’t know any Redis commands, just start pressing Tab to cycle through your options.
Today we’re going to use Redis to build the back end for a URL shortener, like tinyurl.com or bit.ly.
A URL shortener is a service that takes a really long URL and maps it to a shorter version on their own domain—like mapping http://www.myveryververylongdomain.com/somelongpath.php to http://bit.ly/VLD.
Visiting that short URL redirects users to the longer mapped URL, saves the visitors from text messaging long strings, and also provides the short URL creator some statistics like a count of visits.
In Redis we can use SET to key a short code like 7wks to a value like http://www.sevenweeks.org.
Retrieving the value just needs GET and the key name.
To reduce traffic, we can also set multiple values with MSET, like any number of key-value pairs.
Here we map Google.com to gog and Yahoo.com to yah.
Correlatively, MGET grabs multiple keys and returns values as an ordered list.
Although Redis stores strings, it recognizes integers and provides some simple operations for them.
If we want to keep a running total of how many short keys are in our dataset, we can create a count and then increment it with the INCR command.
Although GET returns count as a string, INCR recognized it as an integer and added one to it.
If the value can’t be resolved to an integer, Redis rightly complains.
You can also increment by any integer (INCRBY) or decrement (DECR, DECRBY)
We’ve seen transactions in previous databases (Postgres and Neo4j), and Redis’ MULTI block atomic commands are a similar concept.
Wrapping two operations like SET and INCR in a single block will complete either successfully or not at all.
But you will never end up with a partial operation.
Let’s key another short code to a URL and also increment the count all in one transaction.
We begin the transaction with the MULTI command and execute it with EXEC.
When using MULTI, the commands aren’t actually executed when we define them (similar to Postgres transactions)
Similar to ROLLBACK in SQL, you can stop a transaction with the DISCARD command, which will clear the transaction queue.
Unlike ROLLBACK, it won’t revert the database; it will simply not run the transaction at all.
Storing string and integer values under keys—even as transactions—is all fine and good, but most programming and data storage problems deal with many types of data.
Storing lists, hashes, sets, and sorted sets natively helps explain Redis’ popularity, and after exploring the complex operations you can enact on them, you may find you agree.
That’s more than enough for all Facebook accounts to live as a list under a single key.
While some Redis commands may appear cryptic, they generally follow a good pattern.
List commands generally start with either an L (for left) or an R (for right), depending on the direction of the operation (such as LPUSH)
Hashes are like nested Redis objects that can take any number of key-value pairs.
Let’s use a hash to keep track of users who sign up for our URLshortening service.
Hashes are nice because they help you avoid storing data with artificial key prefixes.
This is a valid character that often logically separates a key into segments.
It’s merely a matter of convention, with no deeper meaning in Redis.
Instead of separate keys, we can create a hash that contains its own keyvalue pairs.
We need only keep track of the single Redis key to retrieve all values of the hash.
Or we can get a single value, by passing in the Redis key, followed by the hash key.
Unlike the document datastores Mongo and CouchDB, hashes in Redis cannot nest (nor can any other complex datatype such as lists)
More commands exist to delete hash fields (HDEL), increment an integer field value by some count (HINCRBY), or retrieve the number of fields in a hash (HLEN)
Lists contain multiple ordered values that can act both as queues (first value in, first value out) and as stacks (last value in, first value out)
They also have more sophisticated actions for inserting somewhere in the middle of a list, constraining list size, and moving values between lists.
Since our URL-shortening service can now track users, we want to allow them to keep a wishlist of URLs they’d like to visit.
To create a list of short-coded websites we’d like to visit, we set the key to USERNAME:wishlist and push any number of values to the right (end) of the list.
Like most collection value insertions, the Redis command returns the number of values pushed.
You can get the list length at any time with LLEN.
Using the list range command LRANGE, we can retrieve any part of the list by specifying the first and last positions.
A negative position means the number of steps from the end.
It also requires a number to know how many matches to remove.
Setting the count to 0 as we do here just removes them all:
Setting the count greater than 0 will remove only that number of matches, and setting the count to a negative number will remove that number of matches but scan the list from the end (right side)
To remove and retrieve each value in the order we added them (like a queue), we can pop them off from the left (head) of the list.
To act as a stack, after you RPUSH the values, you would RPOP from the end of the list.
On the previous combination of commands, you can use LPUSH and RPOP to similar effect (a queue) or LPUSH and LPOP to be a stack.
Suppose we wanted to remove values from our wishlist and move them to another list of visited sites.
To execute this move atomically, we could wrap pop and push actions within a multiblock.
In Ruby these steps might look something like this (you can’t use the CLI here because you must save the popped value, so we used the redis-rb gem):
But Redis provides a single command for popping values from the tail of one list and pushing to the head of another.
If you find the range of the wishlist, prag will be gone; it now lives under visited.
If you looked through the Redis docs to find RPOPRPUSH, LPOPLPUSH, and LPOPRPUSH commands, you may be dismayed to learn they don’t exist.
Blocking Lists Now that our URL shortener is taking off, let’s add some social activities—like a real-time commenting system—where people can post about the websites they have visited.
Let’s write a simple messaging system where multiple clients can push comments and one client (the digester) pops messages from the queue.
We’d like the digester to just listen for new comments and pop them as they arrive.
Redis provides a few blocking commands for this sort of purpose.
The command to block until a value exists to pop is BRPOP.
It requires the key to pop a value from and a timeout in seconds, which we’ll set to five minutes.
Then switch back to the first console and push a message to comments.
If you switch back to the digester console, two lines will be returned: the key and the popped value.
The console will also output the length of time it spent blocking.
There’s also a blocking version of left pop (BLPOP) and right pop, left push (BRPOPLPUSH)
Our URL shortener is shaping up nicely, but it would be nice to group common URLs in some way.
Sets are unordered collections with no duplicate values and are an excellent choice for performing complex operations between two or more key values, such as unions or intersections.
If we wanted to categorize sets of URLs with a common key, we can add multiple values with SADD.
We can retrieve the full set, in no particular order, via SMEMBERS.
To find the intersection of websites that both provide news and are technology focused, we use the SINTER command.
Just as easily, we can remove any matching values in one set from another.
To find all news sites that are not tech sites, use SDIFF:
We can also build a union of websites that are either news or tech.
That set of values can also be stored directly into a new set (SUNIONSTORE destination key [key …])
This also provides a useful trick for cloning a single key’s values to another key, such as SUNIONSTORE news_copy news.
Similar commands exist for storing intersections (SINTERSTORE) and diffs (SDIFFSTORE)
Just like RPOPLPUSH moved values from one list to another, SMOVE does the same for sets; it’s just easier to remember.
And like LLEN finds the length of a list, SCARD (set cardinality) counts the set; it’s just harder to remember.
Since sets are not ordered, there are no left, right, or other positional commands.
Popping a random value from a set just requires SPOP key, and removing values is SREM key value [value …]
Whereas other Redis datatypes we’ve looked at so far easily map to common programming language constructs, sorted sets take something from each of the previous datatypes.
They are ordered like lists and are unique like sets.
They have field-value pairs like hashes, but rather than string fields, they are.
You can think of sorted sets as like a random access priority queue.
Internally, sorted sets keep values in order, so inserts can take log(N) time to insert (where N is the size of the set), rather than the constant time complexity of hashes or lists.
Next we want to keep track of the popularity of specific shortcodes.
Every time someone visits a URL, the score gets increased.
Like a hash, adding a value to a sorted set requires two values after the Redis key name: the score and the member.
To increment a score, we can either re-add it with the new score, which just updates the score but does not add a new value, or increment by some number, which will return the new value.
You can decrement also by setting a negative number for ZINCRBY.
Ranges To get values from our visits set, we can issue a range command, ZRANGE, which returns by position, just like the list datatype’s LRANGE command.
Except in the case of a sorted set, the position is ordered by score from lowest to highest.
So, to get the top two scoring visited sites (zero-based), use this:
To get the scores of each element as well, append WITHSCORES to the previous code.
To get them in reverse, insert the word REV, as in ZREVRANGE.
But if we’re using a sorted set, it’s more likely we want to range by score, rather than by position.
Since the low and high range numbers are inclusive by default, we.
We can also range by both positive and negative values, including infinities.
Along with retrieving a range of values by rank (index) or score, ZREMRANGEBYRANK and ZREMRANGEBYSCORE, respectively, remove values by rank or score.
Unions Just like the set datatype, we can create a destination key that contains the union or intersection of one or more keys.
This is one of the more complex commands in Redis, since it must not only join the keys—a relatively simple operation—but also merge (possibly) differing scores.
Finally, aggregate is the optional rule for resolving each weighted score and summing by default, but you can also choose the min or max between many scores.
Let’s use this command to measure the importance of a sorted set of shortcodes.
First we’ll create another key that scores our short codes by votes.
Each visitor to a site can vote if they like the site or not, and each vote adds a point.
We want to figure out the most important websites in our system, as some combination of votes and visits.
Votes are important, but to a lesser extent, website visits also carry some weight (perhaps people are so enchanted by the website, they simply forget to vote)
For example, if we need to double all scores of a set, we can union a single key with a weight of 2 and store it back into itself.
A common use case for a key-value system like Redis is as a fast-access cache for data that’s more expensive to retrieve or compute.
Expiration helps keep the total key set from growing unbounded, by tasking Redis to delete a keyvalue after a certain time has passed.
Marking a key for expiration requires the EXPIRE command, an existing key, and a time to live in seconds.
Here we set a key and set it to expire in ten seconds.
We can check whether the key EXISTS within ten seconds and it returns a 1 (true)
If we wait to execute, it will eventually return a 0 (false)
Setting and expiring keys is so common that Redis provides a shortcut command called SETEX.
You can query the time a key has to live with TTL.
Setting ice to expire as shown earlier and checking its TTL will return the number of seconds left.
At any moment before the key expires, you can remove the timeout by running PERSIST key.
In other words, EXPIREAT is for absolute timeouts, and EXPIRE is for relative timeouts.
A common trick for keeping only recently used keys is to update the expire time whenever you retrieve a value.
This is the most recently used (MRU) caching algorithm to ensure your most recently used keys will remain in Redis, while the neglected keys will just expire as normal.
Just like buckets in Riak, sometimes we need to separate keys by namespace.
For example, if you wrote an internationalized key-value store, you could store different translated responses in different namespaces.
The key greeting could be set to “guten tag” in a German namespace and “bonjour” in French.
When a user selects their language, the application just pulls all values from the namespace assigned.
In Redis nomenclature, a namespace is called a database and is keyed by number.
But if we switch to another database via the SELECT command, that key is unavailable.
And setting a value to this database’s namespace will not affect the value of the original.
Since all databases are running in the same server instance, Redis lets us shuffle keys around with the MOVE command.
This can be useful for running different applications against a single Redis server but still allow these multiple applications to trade data between each other.
Redis has plenty of other commands for actions such as renaming keys (RENAME), determining the type of a key’s value (TYPE), and deleting a key-value (DEL)
There’s also the painfully dangerous FLUSHDB, which removes all keys from this Redis database, and its apocalyptic cousin, FLUSHALL, which removes all keys from all Redis databases.
Check out the online documentation for the full list of Redis commands.
It has a built-in ability to expire keys, which is useful as a cache.
Find Find the complete Redis commands documentation, as well as the Big-O notated (O(x)) time complexity under the command details.
Using your driver of choice, create a program that reads a blocking list and outputs somewhere (console, file, Socket.io, and so on) and another that writes to the same list.
Day 1 introduced us to Redis as a data structure server.
Today we’ll build on that foundation by looking at some of the advanced functions provided by Redis, such as pipelining, the publish-subscribe model, system configuration, and replication.
Beyond that, we’ll look at how to create a Redis cluster, store a lot of data quickly, and use an advanced technique introducing Bloom filters.
At 20,000 lines of source code, Redis is a fairly simple project.
But beyond code size, it has a simple interface that accepts the very strings we have been writing in the console.
We can interact without the command-line interface by streaming commands through TCP on our own via telnet and terminating the command with a carriage return line feed (CRLF, or \r\n)
We can see that our input is the same as we provided to the console, but the console cleaned up the responses a bit.
Redis streams the OK status prefixed by a + sign.
Before it returned the string hello, it sent $5, which means “the following string is five characters.”
The number 2 after we add two set items to the test key is prefixed by : to represent an integer (two values were added successfully)
Finally, when we requested two items, the first line returned begins with an asterisk and the number 2—meaning there are two complex values about to be returned.
We can also stream our own strings one at a time by using the BSD netcat (nc) command, which you may find is already installed on many Unix machines.
With netcat, we must specifically end a line with CRLF (telnet did this for us implicitly)
We also sleep for a second after the echo command has finished.
Some nc implementations have a -q option, thus negating the need for a sleep, but not all do, so feel free to try it.
We can take advantage of this level of control by pipelining our commands, or streaming multiple commands in a single request.
This can be far more efficient than pushing a single command at a time and should always be considered if it makes sense to do so—especially in transactions.
Just be sure to end every command with \r\n, which is a required delimiter for the server.
Yesterday we were able to implement a rudimentary blocking queue using the list datatype.
We queued data that could be read by a blocking pop command.
Using that queue, we made a very basic publish-subscribe model.
Any number of messages could be pushed to this queue, and a single queue reader would pop messages as they were available.
Let’s improve on the commenting mechanism we made yesterday using blocking lists, by allowing a user to post a comment to multiple subscribers (as opposed to just one)
We start with some subscribers that connect to a key, known as a channel in pub-sub nomenclature.
Let’s start two more clients and subscribe to the comments channel.
With two subscribers, we can publish any string we want as a message to the comments channel.
The PUBLISH command will return the integer 2, meaning two subscribers received it.
Both of the subscribers will receive a multibulk reply (a list) of three items: the string “message,” the channel name, and the published message value.
When your clients want to no longer receive correspondence, they can execute the UNSUBSCRIBE comments command to disconnect from the comments channel or simply UNSUBSCRIBE alone to disconnect from all channels.
However, note in redis-cli that you will have to press CTRL+C to break the connection.
Before getting into changing Redis’s system settings, it’s worth taking a quick look at the INFO command, since changing settings values will alter some of these values as well.
You may want to revisit this command again in this chapter, because it provides a useful snapshot of this server’s global information and settings.
It even provides information on durability, memory fragmentation, and replication server status.
So far, we’ve only used Redis out of the box.
Much of Redis’s power comes from its configurability, allowing you to tailor settings to your use case.
The redis.conf file that comes with the distribution—found in /etc/redis on *nix systems —is fairly self-explanatory, so we’re going to cover only a portion of the file.
We’ll go through a few of the common settings in order.
By default daemonize is set to no, which is why the server always starts up in the foreground.
This is nice for testing but not very production friendly.
Changing this value to yes will run the server in the background while setting the server’s process ID in a pid file.
This can be especially useful when running multiple Redis servers on a single machine.
First is no persistence at all, which will simply keep all values in main memory.
If you’re running a basic caching server, this is a reasonable choice since durability always increases latency.
One of the things that sets Redis apart from other fast-access caches like memcached2 is its built-in support for storing values to disk.
You can run the LASTSAVE command to get a Unix timestamp of the last time a Redis disk write succeeded, or you can read the last_save_time field from the server INFO output.
You can force durability by executing the SAVE command (or BGSAVE, to asynchronously save in the background)
If you read the redis-server log, you will see lines similar to this:
Another durability method is to alter the snapshotting settings in the configuration file.
Snapshotting We can alter the rate of storage to disk by adding, removing, or altering one of the save fields.
By default there are three, prefixed by the save keyword followed by a time in seconds and a minimum number of keys that must change before a write to disk occurs.
You can add as many or few save lines as necessary to specify precise thresholds.
Append-Only File Redis is eventually durable by default, in that it asynchronously writes values to disk in intervals defined by our save settings, or it is forced to write by.
This is acceptable for a second-level cache or session server but is insufficient for storing data you need to be durable, like financial data.
If a Redis server crashes, our users might not appreciate having lost money.
Redis provides an append-only file (appendonly.aof) that keeps a record of all write commands.
If the server crashes before a value is saved, it executes the commands on startup, restoring its state; appendonly must be enabled by setting it to yes in the redis.conf file.
Then we must decide how often a command is appended to the file.
Setting always is the more durable, since every command is saved.
It’s also slow, which often negates the reason people have for using Redis.
By default everysec is enabled, which saves up and writes commands only once a second.
This is a decent trade-off, since it’s fast enough, and worst case you’ll lose only the last one second of data.
Finally, no is an option, which just lets the OS handle flushing.
It can be fairly infrequent, and you’re often better off skipping the append-only file altogether rather than choosing it.
Append-only has more detailed parameters, which may be worth reading about in the config file when you need to respond to specific production issues.
Although Redis is not natively built to be a fully secure server, you may run across the requirepass setting and AUTH command in the Redis documentation.
These can be safely ignored, since they are merely a scheme for setting a plain-text password.
Since a client can try nearly 100,000 passwords a second, it’s almost a moot point, beyond the fact that plain-text passwords are inherently unsafe anyway.
If you want Redis security, you’re better off with a good firewall and SSH security.
Interestingly, Redis provides command-level security through obscurity, by allowing you to hide or suppress commands.
If we attempt to execute FLUSHALL against this server, we’ll be hit with an error.
Or better yet, we can disable the command entirely by setting it to a blank string.
You can set any number of commands to a blank string, allowing you a modicum of customization over your command environment.
There are several more advanced settings for speeding up slow query logs, encoding details, making latency tweaks, and importing external config files.
Keep in mind, though, that if you run across some documentation about Redis virtual memory, you’re best to avoid it if possible.
It’s been deprecated in Redis 2.4 and may be removed in future versions.
To aid in testing your server configuration, Redis provides an excellent benchmarking tool.
Other commands are tested as well, like SADD and LRANGE; the more complex ones generally taking more time.
Just like other NoSQL databases we’ve seen (such as MongoDB and Neo4j), Redis supports master-slave replication.
Data will be replicated to any number of slave servers.
The file will remain largely the same but with the following changes:
If all went according to plan, you should see something similar to the following in the slave server’s log when you start it:
And you should see the string 1 slaves output in the master log.
If we connect the command line to our slave, we should receive our meeting list.
In production, you’ll generally want to implement replication for availability or backup purposes and thus have Redis slaves on different machines.
So far, we’ve talked a lot about how fast Redis is, but it’s hard to get a feel for it without playing with a bit more data.
You can keep the slave running if you like, but a laptop or desktop might run quicker if you have just a single master server.
There are several ways to go about inserting a large dataset, and they get progressively faster but more complex.
The simplest method is to simply iterate through a list of data and execute SET for each value using the standard redis-rb client.
If you want to speed up insertion and are not running JRuby, you can optionally install the hiredis gem.
It’s a C driver that is considerably faster than the native Ruby driver.
Then uncomment the hiredis require line in order to load the driver.
You may not see a large improvement for this type of CPU-bound operation, but we highly recommend hiredis for production Ruby use.
Here we batch 1,000 lines at a time and pipeline their insertion.
It reduced our insertion time by more than 300 percent.
This reduces the number of Redis connections required, but building the pipelined dataset has some overhead of its own.
You should experiment with different numbers of batched operations when pipelining in production.
Beyond simple replication, many Redis clients provide an interface for building a simple ad hoc distributed Redis cluster.
You may recall consistent hashing from the Riak chapter, where nodes can be added and dropped without having to expire most keys.
This is the same idea, only managed via a client rather than by the servers themselves.
Unlike the master-slave setup, both of our servers will take the master (default) configuration.
Bridging between two or more servers requires only some minor changes to our existing ISBN client.
First we need to require the redis/distributed file from the redis gem.
Then replace the Redis client with Redis::Distributed and pass in an array of server URIs.
Each URI requires the redis scheme, server (localhost), and port.
But a lot more work is being done by the client, since it handles computing which keys are stored on which servers.
You can validate that keys are stored on separate servers by attempting to retrieve the same ISBN key from each server through the CLI.
But as long as you retrieve keys set through the same Redis::Distributed configuration, the client will access the values from the correct servers.
Owning a unique term is an excellent strategy for making something easily findable online.
If you were to write a book named The Jabbyredis, you would be fairly certain any search engine would link to you.
Let’s write a script that lets someone quickly check whether a word is unique against all words used in all titles in the ISBN catalog.
We can use a Bloom filter to test whether a word is used.
Although it can return a false positive, it cannot return a false negative.
This is a useful when you need to quickly discover whether a value does not exist in a system.
Bloom filters succeed at discovering nonexistence by converting a value to a very sparse sequence of bits and comparing that to a union of every value’s bits.
In other words, when a new value is added, it is OR’d against the current Bloom filter bit sequence.
When you want to check whether the value is already in the system, you perform an AND against the Bloom filter’s sequence.
If the value has any true bits that aren’t also true in the Bloom filter’s corresponding buckets, then the value was never added.
In other words, this value is definitely not in the Bloom filter.
Let’s write a program that loops through a bunch of ISBN book data, extracts and simplifies each book’s title works, and splits them into individual words.
Each new word encountered is checked against the Bloom filter.
If the Bloom filter returns false, meaning the word does not exist in our Bloom filter, then go ahead and add it.
Just to follow along, we can output any new word that’s added.
Ruby wunderkind Ilya Grigorik created this Redis-backed Bloom filter, but the concepts are transferable to any language.
Running the client uses the same ISBN file but needs only the book titles.
At the start of the output you should see plenty of common words, like and and the.
Near the end of the set, the words become increasingly esoteric, like unindustria.
The upside with this approach is the ability to detect duplicate words.
The downside is that a few false positives will seep through—the Bloom filter may flag a word we have never seen before.
This is why in a real-world use case you would perform some secondary check, such as a slower database query to a system of record, which should happen only a small percentage of the time, presuming a large enough filter size, which is computable.4
As we mentioned earlier, Bloom filters function by flipping certain bits in a sparse binary field.
The Redis Bloom filter implementation we just used takes advantage of two relatively recent Redis commands that perform just such actions: SETBIT and GETBIT.
It’s a common use case for high-performance multivariate flagging—it’s faster to flip a few bits than write a set of descriptive strings.
So, a hamburger with only mustard and onion could be represented as 0110 and set in the command line:
Later, a process can check whether my burger should have lettuce or mustard.
If zero is returned, the answer is false—one if true.
The Bloom filter implementation takes advantage of this behavior by hashing a value as a multibit value.
Bloom filters are excellent for reducing unnecessary traffic to a slower underlying system, be it a slower database, limited resource, or network request.
If you have a slower database of IP addresses and you want to track all new users to your site, you can use a Bloom filter to first check whether the IP address exists in your system.
If the Bloom filter returns false, you know the IP address has yet to be added and can respond accordingly.
If the Bloom filter returns true, this IP address may or may not exist on the back end and requires a secondary lookup to be sure.
This is why computing the correct size is important—a well-sized Bloom filter can reduce (but not eliminate) the error rate or the likelihood of a false positive.
Today we rounded out our Redis investigation by moving beyond simple operations into squeezing every last bit of speed out of a very fast system.
Redis provides for fast and flexible data structure storage and simple manipulations as we saw in Day 1 but is equally adept at more complex behaviors by way of built-in publish-subscribe functions and bit operations.
It’s also highly configurable, with many durability and replication settings that conform to whatever your needs may be.
It also supports some nice thirdparty enhancements, like Bloom filters and clustering.
This also concludes major operations for the Redis data structure store.
Tomorrow we’re going to do something a bit different, by using Redis as the cornerstone of a polyglot persistence setup along with CouchDB and Neo4j.
Find Find out what messaging patterns are, and discover how many Redis can implement.
Then try running with appendfsync set to always, marking the speed difference.
Using your favorite programming language’s web framework, try to build a simple URL-shortening service backed by Redis with an input box for the URL and a simple redirect based on the URL.
Back it up with a Redis master-slave replicated cluster across multiple nodes as your back end.
Today we’re wrapping up our final database chapter by inviting some previous databases to play.
Yet Redis will hold a starring role by making our interaction with other databases faster and easier.
We’ve learned throughout this book that different databases have different strengths, so many modern system designs have moved toward a polyglot persistence model, where many databases each play a role in the system.
You’ll learn how to build one of these projects using CouchDB as the system of record (the canonical data source), Neo4j to handle data relationships, and Redis to help with data population and caching.
Note that this project is not the authors’ endorsement of any specific set of databases, languages, or frameworks over another but rather a showcase of how multiple databases can work together, leveraging the capabilities of each in pursuit of a single goal.
Our polyglot persistence service will act as a front end to a band information service.
We want to store a list of musical band names, the artists who performed in those bands, and any number of roles each artist played in the band, from lead singer to backup keytar player.
Each of three databasesRedis, CouchDB, and Neo4j—will handle a different aspect of our band management system.
Redis plays three important roles in our system: to assist in data populating CouchDB, as a cache for recent Neo4j changes, and as a quick lookup for partial value searches.
Its speed and ability to store multiple data formats make it well suited for population, and its built-in expiry policies are perfect for handling cached data.
CouchDB is our system of record (SOR), or authoritative data source.
CouchDB’s document structure is an easy way to store band data with nested artist and role information, and we will take advantage of the Changes API in CouchDB to keep our third data source in sync.
Although querying the CouchDB SOR directly is perfectly reasonable, a graph datastore allows us a simplicity and speed in walking node relationships that other databases have a difficult time matching.
We’ll store relationships between bands, band members, and the roles the members play.
Like the growing phenomenon of polyglot programming, polyglot persistence is now gaining ground.
If you are unfamiliar with the practice, polyglot programming is whereby a team uses more than one programming language in a single project.
Contrast this with the convention of using one general-purpose language throughout a project.
This is useful because of the different inherent strengths of languages.
A framework like Scala may be better suited for server-side stateless transactions on the Web, but a language like Ruby may be friendlier for business logic.
A polyglot language system like this was famously used at Twitter.
Some of the databases we’ve seen themselves support polyglot programming—Riak supports both JavaScript and Erlang when writing mapreduce, and a single request can execute both.
Similar to its language-centric cousin, polyglot persistence is where you can leverage the strengths of many kinds of databases in the same system, as opposed to the currently familiar practice of a single database, probably a relational style.
A basic variant of this is already common: using a key-value store (like Redis) that acts as a cache for relatively slower relational database (like PostgreSQL) queries.
Relational, as we’ve seen in previous chapters, is suboptimally suited for a growing host of problems, such as graph traversal.
But even these new databases shine only as a few stars in the full galaxy of requirements.
Why the sudden interest in polyglot? Martin Fowler noteda that having a single central database where multiple applications could integrate was a common pattern in software design.
This once popular database integration pattern has given way to a middleware layer pattern, where multiple applications instead communicate to a service layer over HTTP.
This frees up the middleware service itself to rely on any number of databases or, in the case of polyglot persistence, any type.
Each database has a specific role to play in our system, but they don’t natively communicate.
We use the Node.js JavaScript framework to populate the databases, communicate between them, and act as a simple front-end server.
Since gluing multiple databases together requires a bit of code, this last day will have much more code than we have seen so far in this book.
The first item of business is to populate our datastores with the necessary data.
We take a two-phased approach here, by first populating Redis and then populating our CouchDB SOR.
As in earlier sections, we download a dataset from Freebase.com.
For example, John Cooper played in the band Skillet as the Lead vocalist, Acoustic guitar player, and Bassist.
Ultimately we want to structure John Cooper and the other members of Skillet into a single CouchDB document like the following, stored at the URL http://localhost:5984/bands/Skillet:
That’s not many, but it’s a good starting point to build your own system.
This is an incomplete dataset, but we can deal with that later.
You may wonder why we bother populating Redis and not just dive right into populating CouchDB.
Acting as an intermediary, Redis adds structure to the flat TSV data so that subsequent insertion into another database is fast.
Since our plan is to create a single record per band name, Redis allows us to make a single pass through our TSV file (which lists the same band for each band member—each band member is represented in a line)
Adding single members directly to CouchDB for each line in the file can cause update thrashing, where two band member lines attempt to create/update the same band document at the same time, forcing the system to reinsert when one of them fails CouchDB’s version check.
With our data file in hand, ensure you have Node.js installed as well as the Node Package Manager (npm)
Once that’s all done, we need to install three NPM projects: redis, csv, and hiredis (the optional Redis C-driver we learned about yesterday that can greatly speed up Redis interactions)
Then, check that your Redis server is running on the default port 6379, or alter each script’s createClient() function to point to your Redis port.
All of the JavaScript files we’ll look at are fairly verbose, so we don’t show them in their entirety.
All of the code can be downloaded from the Pragmatic Bookshelf website.
Here we’ll just stick to the meat of each file.
This script basically iterates through each line of the TSV and extracts the artist name, the band name, and the roles they play in that band.
Then it adds those values to Redis (skipping any blank values)
The format of each Redis band key is "band:Band Name"
The script will add this artist name to the set of artist names.
The artist keys will also contain the band name and similarly contain a set of roles.
The other code just keeps track of how many lines we’ve processed and outputs the results to the screen.
You can test that the code has been populating Redis by launching redis-cli and executing RANDOMKEY.
We should expect a key prefixed by band: or artist:…any value but (nil) is good.
Now that Redis is populated, proceed immediately to the next section.
Turning off Redis could lose data, unless you chose to set a higher durability than the default or initiated a SAVE command.
CouchDB will play the role of our system of record (SOR)
A good SOR should contain all of the data necessary to rebuild any other data source in its domain.
Redis should also still be running from the previous section.
Since phase 1 was all about pulling data from a TSV and populating Redis, this phase is all about pulling data from Redis and populating CouchDB.
We don’t use any special drivers for CouchDB, since it’s a simple REST interface and Node.js has a simple built-in HTTP library.
Nonblocking Code Before starting this book, we were only passingly familiar with writing event-driven nonblocking applications.
Nonblocking means precisely that: rather than waiting for a long-running process to complete, the main code will continue executing.
Whatever you need to do in response to a blocking event you put inside a function or code block to be executed later.
This can be by spawning a separate thread or, in our case, implementing a reactor pattern event-driven approach.
In a blocking program, you can write code that queries a database, waits, and loops through the results.
In a event-driven program, you would pass in the loop as a function/code block.
While the databases is doing its thing, the rest of the program can continue running.
Only after the database returns the result does the function/code block get executed.
It took us quite some time to realize the benefits here.
The rest of the program can run rather than sitting idle while it waits on the database, sure, but is this common? Apparently so, because when we began coding in this style, we noticed an order-ofmagnitude decrease in latency.
We try to keep the code as simple as we can, but interacting with databases in a nonblocking way is an inherently complex process.
But as we learned, it’s generally a very good method when dealing with databases.
Nearly every popular programming language has some sort of nonblocking library.
In the following block of code, we perform a Redis KEYS bands:* to get a list of all band names in our system.
If we had a really big dataset, we could add more scoping (for example, bands:A* to get only band names starting with a, and so on)
Then for each of those bands we fetch the set of artists and extract the band name from the key, by removing the prefix bands: from the key string.
Next we get all of the roles for every artist in this band, which Redis returns as an array of arrays (each artists role is its own array)
We can do this by batching up Redis SMEMBERS commands into an array called roleBatch and executing them in a single MULTI batch.
Effectively, that would be executing a single pipelined request like this:
From there, a batch of 50 CouchDB documents are made.
With the population of the bands database, we now have in a single location all of the data our system requires.
We know the names of many bands, the artists who performed in them, and the roles they played in those bands.
Next on the docket is our Neo4j service that we’ll use to track relationships between artists and the roles they play.
We could certainly query CouchDB outright by creating views, but we are rather limited on complex queries based on relationships.
If Wayne Coyne from the Flaming Lips loses his theremin before a show, he could ask Charlie Clouser from Nine Inch Nails, who also plays a theremin.
Or we could discover artists who have many overlapping talents, even if they performed different roles in different bands—all with a simple node walk.
With our initial data in place, now we need to keep Neo4j in sync with CouchDB should any data ever change on our system of record.
So, we’ll kill two birds by crafting a service that populates Neo4j on any changes to CouchDB since the database was created.
We also want to populate Redis with keys for our bands, artists, and role so we can quickly access this data later.
Happily, this includes all data that we’ve already populated in CouchDB, thus saving us a separate initial Neo4j and Redis population step.
This file will continue running until you shut it down.
This server just uses the continuous polling example we saw in the CouchDB chapter to track all CouchDB changes.
Whenever a change is detected, we do two things: populate Redis and populate Neo4j.
It just uses Node.js’s HTTP library to connect to the Neo4j REST interface with a bit of rate-limiting built in so the client doesn’t open too many connections at once.
Our driver also uses Redis to keep track of changes made to the Neo4j graph without having to initiate a separate query.
This is our third separate use for Redis—the first being as a data transformation step for populating CouchDB, and the second we just saw earlier, to quickly search for band values.
This code creates band nodes (if they need to be created), then artist nodes (if they need to be created), and then roles.
Each step along the way creates a new relationship, so The Beatles node will relate to John, Paul, George, and Ringo nodes, who in turn each relate to the roles they play.
Every update to CouchDB that adds a new artist or role to an existing artist will trigger a new relationship in Neo4j and potentially new keys in Redis.
As long as this service runs, they should be in sync.
Then fire up the Neo4j console and try finding any new connections in the graph.
If you added a new band member, they should now have a relationship with the band node or new role if that was altered.
We’re going to create a simple web application that allows users to search for a band.
Any band in the system will list all of the band members as links, and any clicked band member link will list some information about the artist—namely, the roles they play.
In addition, each role the artist plays will list every other artist in the system who also plays that role.
Clicking Jimmy Page will list that he plays guitar and also many other artists who play guitar, like The Edge from U2
To simplify our web app creation a bit, we’ll need two more node packages: bricks (a simple web framework) and mustache (a templating library)
Like in the previous sections, ensure you have all of the databases running, and then start up the server.
Let’s take a look at the code that will build a web page that lists band information.
Each URL performs a separate function in our little HTTP server.
The first is at http://localhost:8080/band and accepts any band name as a parameter.
If you enter in the band Nirvana in the search form, your URL request will be http://localhost:8080/band?name=Nirvana.
This function will render an HTML page (the overall template is in an external file named template.html)
This web page lists all artists in a band, which it pulls directly from CouchDB.
It also lists some suggested bands, which it retrieves from a Gremlin query against the Neo4j graph.
Or in other words, from the Nirvana node, get all unique names whose members are connected to Nirvana members.
For example, Dave Grohl played in Nirvana and the Foo Fighters, so Foo Fighters will be returned in this list.
This first outputs all roles a member plays, and the second is a list of bands that person played in.
For example, Jeff Ward (http://localhost:8080/artist?name=Jeff%20Ward) would be listed as playing the role Drummer and in the bands Nine Inch Nails and Ministry.
A cool feature of the previous two pages is that we render links between these values.
The artist list in the /bands page links to the chosen /artist page, and vice versa.
Here we just pull all keys from Redis that match the first part of the string, such as "Bea*" as described previously.
The template.html file links to the jQuery code necessary to make this function as an autocomplete feature on the rendered search box.
You may also note that we do not have a form where someone can update band information.
If you enjoy playing with this kind of polyglot persistence, you could take this even further.
You could add a PostgreSQL data warehouse6 to transform this data into a star schema—allowing for different dimensions of analysis, such.
You could add a Riak server to store samples of bands’ music, an HBase server to build a messaging system where users can keep track of their historical likes/dislikes, or a MongoDB extension to add a geographic element to this service.
Or, redesign this project entirely with a different language, web framework, or dataset.
There are as many opportunities to extend this project as there are combinations of databases and technologies to create it—a Cartesian product of all open source.
Today was a big day—so big, in fact, we wouldn’t be surprised if it took several days to complete.
But this is a little taste of the future of data management systems, as the world strolls away from the one large relational database model to a several specialized databases model.
We also glued these databases together with some nonblocking code, which, though not a focus of this book, also seems to be where database interaction is headed in the development space.
The importance of Redis in this model should not be missed.
Redis certainly doesn’t provide any functionality these databases don’t supply individually, but it does supply speedy data structures.
We were able to organize a flat file into a series of meaningful data structures, which is an integral part of both data population and transportation.
And it did this in a fast and simple-touse way.
Even if you’re not sold on the whole polyglot persistence model, you should certainly consider Redis for any system.
Add MongoDB into the mix by storing a few music samples into GridFS, whereby users can hear a song or two related to a band.
If any songs exists for a band, add a link to the web app.
The Redis key-value (or data structure) store is light and compact, with a variety of uses.
It’s akin to one of those multitools composed of a knife, can opener, and other bits and bobs like a corkscrew—Redis is good to have around for solving a variety of odd tasks.
Above all, Redis is fast, simple, and as durable as you choose.
While rarely a stand-alone database, Redis is a perfect complement to any polyglot ecosystem as an ever-present helper for transforming data, caching requests, or managing messages by way of its blocking commands.
The obvious strength of Redis is speed, like so many key-value stores of its ilk.
But more than most key-value stores, Redis provides the ability to store complex values like lists, hashes, and sets, and retrieve them based through operations specific to those datatypes.
Beyond even a data structure store, however, Redis’s durability options allow you to trade speed for data safety up to a fairly fine point.
Built-in master-slave replication is another nice way of ensuring better durability without requiring the slowness of syncing an append-only file to disk on every operation.
Some may consider this cheating, since of course a database that never hits the disk will be fast.
A main memory database has an inherent durability problem; namely, if you shut down the database before a snapshot occurs, you can lose data.
Even if you set the append-only file to disk sync on every operation, you run a risk with playing back expiry values, since time-based events can never be counted on to replay in exactly the same manner—though in fairness this case is more hypothetical than practical.
Redis also does not support datasets larger than your available RAM (Redis is removing virtual memory support), so its size has a practical limitation.
Although there is a Redis Cluster currently in development to grow beyond a single-machine’s RAM requirements, anyone wanting to cluster Redis must currently roll their own with a client that supports it (like the Ruby driver we used in Day 2)
Redis is already becoming an integral part of many systems.
Several open source projects rely on Redis, from Resque, a Ruby-based asynchronous job queueing service, to session management in the Node.js project SocketStream.
Regardless of the database you choose as your SOR, you should certainly add Redis to the mix.
Wrapping Up Now that we’ve made it through the databases, congratulations are in order!
We hope you’ve gained an appreciation for these seven databases.
If you use one in a project, we’ll be happy.
And if you decide to use multiple databases, like we saw at the end of the Redis chapter, we’ll be ecstatic.
We believe the future of data management lies in the polyglot persistence model (using more than one database in a project)—while the worldview of the general-purpose RDBMS fog drifts away.
Let’s take this opportunity to see where our seven databases fit together in the greater database ecosystem.
By this point, we have explored the details of each and mentioned a few commonalities and differences.
We’ll see how they contribute to the vast and expanding landscape of data storage options.
We’ve seen that how databases store their data can be largely divided into five genres: relational, key-value, columnar, document, and graph.
Let’s take a moment and recap their differences and see what each style is good for and not so good for—when you’d want to use them and when to avoid them.
Relational database management systems (RDBMSs) are set-theory-based systems implemented as two-dimensional tables with rows and columns.
Relational databases strictly enforce type and are generally numeric, strings, dates, and uninterpreted blobs, but as we saw, PostgreSQL provided extensions such as array or cube.
Because of the structured nature of relational databases, they make sense when the layout of the data is known in advance but how you plan to use that data later may not be.
Or, in other words, you pay the organizational complexity up front to achieve query flexibility later.
Many business problems are aptly modeled this way, from orders to shipments and from inventory to shopping carts.
You may not know in advance how you’ll want to query the data later—how many orders did we process in February?—but the data is quite regular in nature, so enforcing that regularity is helpful.
When your data is highly variable or deeply hierarchical, relational databases aren’t the best fit.
Because you must specify a schema up front, data problems that exhibit a high degree of record-to-record variation will be problematic.
Consider developing a database to describe all the creatures in nature.
Creating a full list of all features to account for (hasHair, numLegs, laysEggs, and so on) would be intractable.
In such a case, you’d want a database that makes less restrictions in advance on what you can put into it.
The key-value (KV) store was the simplest model we covered.
Because of their relative simplicity, this genre of database has the most flexibility of implementation.
Hash lookups are fast, so in the case of Redis, speed was its primary concern.
Hash lookups are also easily distributed, and so Riak took advantage of this fact for focusing on simple-to-manage clusters.
Of course, its simplicity can be a downside for any data with complex modeling requirements.
With little or no need to maintain indexes, key-value stores are often designed to be horizontally scalable, extremely fast, or both.
They’re particularly suited for problems where the data are not highly related.
For example, in a web application, users’ session data meet this criteria; each user’s session activity will be different and largely unrelated to the activity of other users.
Often lacking indexes and scanning capabilities, KV stores won’t help you if you need to be able to perform queries on your data, other than basic CRUD operations (Create, Read, Update, Delete)
Columnar databases (aka column-oriented, aka column family) share many similarities with both KV and RDBMS stores.
Like with a key-value database, values are queried by matching keys.
Like relational, their values are groups of zero or more columns, though each row is capable of populating however many it wants.
Unlike either, columnar databases store like data by columns, rather than keeping data together by rows.
Columns are inexpensive to add, versioning is trivial, and there is no real storage cost for unpopulated values.
We saw how HBase is a classic implementation of this genre.
Columnar databases have been traditionally developed with horizontal scalability as a primary design goal.
As such, they’re particularly suited to “Big Data” problems, living on clusters of tens, hundreds, or thousands of nodes.
They also tend to have built-in support for features such as compression and versioning.
The canonical example of a good columnar data storage problem is indexing web pages.
Pages on the Web are highly textual (benefits from compression), somewhat interrelated, and change over time (benefits from versioning)
Different columnar databases have different features and therefore different drawbacks.
But one thing they have in common is that it’s best to design your schema based on how you plan to query the data.
This means you should have some idea in advance of how your data will be used, not just what it’ll consist of.
If data usage patterns can’t be defined in advance—for example, fast ad hoc reporting—then a columnar database may not be the best fit.
Document databases allow for any number of fields per object and even allow objects to be nested to any depth as values of other fields.
The common representation of these objects is as JavaScript Object Notation (JSON), adhered to by both MongoDB and CouchDB—though this is by no means a conceptual requirement.
Since documents don’t relate to each other like relational databases, they are relatively easy to shard and replicate across several servers, making distributed implementations fairly common.
MongoHQ tends to tackle availability by supporting the creation of datacenters that manage huge datasets for the Web.
Meanwhile, CouchDB focuses on being simple and durable, where availability is achieved by master-master replication of fairly autonomous nodes.
Document databases are suited to problems involving highly variable domains.
When you don’t know in advance what exactly your data will look like, document databases are a good bet.
Also, because of the nature of documents, they often map well to object-oriented programming models.
This means less impedance mismatch when moving data between the database model and application model.
If you’re used to performing elaborate join queries on highly normalized relational database schemas, you’ll find the capabilities of document databases lacking.
A document should generally contain most or all of the relevant information required for normal use.
So while in a relational database you’d naturally normalize your data to reduce or eliminate copies that can get out of sync, with document databases, denormalized data is the norm.
Graph databases are an emerging class of database that focuses more on the free interrelation of data than the actual values.
Neo4j, as our open source example, is growing in popularity for many social network applications.
Unlike other database styles that group collections of like objects into common buckets, graph databases are more free-form—queries consist of following edges shared by two nodes or, namely, traversing nodes.
As more projects use them, graph databases are growing the straightforward social examples to occupy more nuanced use cases, such as recommendation engines, access control lists, and geographic data.
The prototypical example is a social network, where nodes represent users who have various kinds of relationships to each other.
Modeling this kind of data using any of the other styles is often a tough fit, but a graph database would accept it with relish.
If you can model your data on a whiteboard, you can model it in a graph.
Because of the high degree of interconnectedness between nodes, graph databases are generally not suitable for network partitioning.
It’s likely that if you use a graph database, it’ll be one piece of a larger system, with the bulk of the data stored elsewhere and only the relationships maintained in the graph.
As we said at the beginning, data is the new oil.
We sit upon a vast ocean of data, yet until it’s refined into information, it’s unusable (and with a more crude comparison, there’s a lot of money in data these days)
The ease of collecting and ultimately storing, mining, and refining the data out there starts with the database you choose.
Deciding which database to choose is often more complex than merely considering which genre maps best to a given domain’s data.
Though a social graph may seem to clearly function best with a graph database, if you’re Facebook, you simply have far too much data to choose one.
You are more likely going to choose a “Big Data” implementation, such as HBase or Riak.
This will force your hand into choosing a columnar or key-value store.
In other cases, though you may believe a relational database is clearly the best option for bank transactions, it’s worth knowing that Neo4j also supports ACID transactions, expanding your options.
These examples serve to point out that there are other avenues beyond genre to consider when choosing which database—or databases—best serve your problem scope.
As a general rule, as the size of data increases, the capacity of certain database styles wane.
Column-oriented datastore implementations are often built to scale across datacenters and support the largest “Big Data” sets, while graphs generally support the smallest.
Riak is a large-scale key-value store meant to shard data across hundreds or thousands of nodes, while Redis was built to run on one—with the possibility of a few master-slave replicas or client-managed shards.
There are several more dimensions to consider when choosing a database, such as durability, availability, consistency, scalability, and security.
You have to decide whether ad hoc queryability is important or if mapreduce will suffice.
Do you prefer to use an HTTP/REST interface, or are you willing to require a driver for a custom binary protocol? Even smaller scope concerns, such as the existence of bulk data loaders, might be important for you to think about.
The table is not meant to be an exhaustive list of features.
These features change in the blink of an eye, so we highly recommend double-checking these values for more recent versions.
Modern application scaling problems now fall largely in the realm of data management.
We’ve reached a point in application evolution where programming language, framework, and operating system choice—even hardware and operations (thanks to virtual machine hosts and “the cloud”)—are becoming so cheap and easy as to become largely trivial problems driven as much by preference as necessity.
If you want to scale your application in this age, you should think quite a bit about which database, or databases, you chooseit’s more than likely your true bottleneck.
Helping you make this choice correctly was a leading purpose of this book.
Although the book has come to a close, we trust your interest in polyglot persistence is wide open.
The next steps from here are to pursue in detail the databases that piqued your interest or continue learning about other options like Cassandra, Drizzle, or OrientDB.
In the pages that follow, you’ll find tables that tally up these databases along a number of dimensions to present an overview of what’s covered in more detail elsewhere in the book.
Although the tables are not a replacement for a true understanding, they should provide you with an at-a-glance sense of what each database is capable of, where it falls short, and how it fits into the modern database landscape.
The CAP Theorem Understanding the five database genres is an important selection criterion, but it’s not the only one.
Another recurring theme in this book is the CAP theorem, which lays bare an unsettling truth about how distributed database systems behave in the face of network instability.
In other words, you can create a distributed database system that is consistent and partition tolerant, a system that is available and partition tolerant, or a system that is consistent and available (but not partition tolerant—which basically means not distributed)
But it is not possible to create a distributed database that is consistent and available and partition tolerant at the same time.
The CAP theorem is pertinent when considering a distributed database, since you must decide what you are willing to give up.
Partition tolerance is strictly an architectural decision (will the database be distributed or not)
It’s important to understand the CAP theorem to fully grok your options.
The trade-offs made by the database implementations in this book are largely influenced by it.
Distributed databases must be partition tolerant, so the choice between availability and consistency can be difficult.
All of the land in the world contains information about certain topics, and as long as you’re somewhere near people or technology, you can find an answer to your questions.
You can answer the question with the most recent value you have (which is now five years old)
Or, you can decline to answer the question, knowing since you are partitioned, your answer may not be consistent with the rest of the world.
The captain won’t get his answer, but the state of the world remains consistent (if he sails back home, he can get the correct answer)
As your role of queried node, you can either help keep the world’s data consistent or be available, but not both.
The idea behind eventual consistency is that each node is always available to serve requests.
As a trade-off, data modifications are propagated in the background to other nodes.
This means that at any time the system may be inconsistent, but the data is still largely accurate.
The Internet’s Domain Name Service (DNS) is a prime example of an eventually consistent system.
You register a domain, and it may take a few days to propagate to all DNS servers across the Internet.
But at no time is any particular DNS server unavailable (assuming you can connect to it, that is)
Some partition-tolerant databases can be tuned to be more or less consistent or available on a per-request basis.
Riak works like this, allowing clients to decide at request time what level of consistency they require.
The other databases in this book largely occupy one corner or another of the CAP tradeoff triangle.
You’ve been on the island for three years at this point, and you spot a bottle in the sand—precious contact with the outside world.
You uncork it and rejoice! You’ve just received an integral piece of knowledge…
The story ends with the captain rescuing you, and you return home to find her new album and live happily ever after.
As long as you remain on land, you needn’t be partition tolerant and can remain consistent and available until the end of your days.
It’s worth noting that most of these databases can be configured to change CAP type (Mongo can be CA, CouchDB can be CP), but here we’ve noted their default or common behaviors.
There is more to distributed database system design than CAP, however.
For example, low latency (speed) is a chief concern for many architects.
If you read the Amazon Dynamo1 paper, you’ll notice a lot of talk about availability.
For a certain class of applications, even a small latency change can translate to a large costs.
Yahoo’s PNUTS database famously gives up both availability on normal operation and consistency on partitions in order to squeeze a lower latency out of its design.2 It’s important to consider CAP when dealing with distributed databases, but it’s equally important to be aware that distributed database theory does not stop there.
Learn a New Language This Year Want to be a better programmer? Each new programming language you learn teaches you something new about computing.
You should learn a programming language every year, as recommended by The Pragmatic Programmer.
Whether or not your favorite language is on that list, you’ll broaden your perspective of programming by examining these languages side-by-side.
You’ll learn something new from each, and best of all, you’ll learn how to learn a language quickly.
Bill Karwin has helped thousands of people write better SQL and build stronger relational databases.
Now he’s sharing his collection of antipatterns—the most common errors he’s identified out of those thousands of requests for help.
Most developers aren’t SQL experts, and most of the SQL that gets used is inefficient, hard to maintain, and sometimes just plain wrong.
This book shows you all the common mistakes, and then leads you through the best fixes.
What’s more, it shows you what’s behind these fixes, so you’ll learn a lot about relational databases along the way.
Long live the command line! Use tmux for incredible mouse-free productivity, and learn how to create profession command-line apps.
The time you spend context switching between your editor and your consoles eats away at your productivity.
Take control of your environment with tmux, a terminal multiplexer that you can tailor to your workflow.
Learn how to customize, script, and leverage tmux’s unique abilities and keep your fingers on your keyboard’s home row.
With its simple commands, flags, and parameters, a well-formed commandline application is the quickest way to automate a backup, a build, or a deployment and simplify your life.
It provides all of JavaScript’s functionality wrapped in a cleaner, more succinct syntax.
In the first book on this exciting new language, CoffeeScript guru Trevor Burnham shows you how to hold onto all the power and flexibility of JavaScript while writing clearer, cleaner, and safer code.
Sass is just like CSS, but with a whole lot of extra power so you can get more done, more quickly.
Build better web pages today with Pragmatic Guide to Sass.
These concise, easy-to-digest tips and techniques are the shortcuts experienced CSS developers need to start developing in Sass today.
Be Agile Don’t just “do” agile; you want to be agile.
The best agile book isn’t a book: Agile in a Flash is a unique deck of index cards that fit neatly in your pocket.
These cards are meant to be used, not just read.
There is always more to do than time and money will allow.
But you can deal with those facts (and more) by becoming a fierce software-delivery professional, capable of dispatching the most dire of software projects and the toughest delivery schedules with ease and grace.
The titles continue the well-known Pragmatic Programmer style and continue to garner awards and rave reviews.
As development gets more and more difficult, the Pragmatic Programmers will be there with more titles and products to help you stay on top of your game.
Register for Updates http://pragprog.com/updates Be notified when updates and new books become available.
Join the Community http://pragprog.com/community Read our weblogs, join our online discussions, participate in our mailing list, interact with our wiki, and benefit from the experience of other Pragmatic Programmers.
New and Noteworthy http://pragprog.com/news Check out the latest pragmatic developments, new titles and other offerings.
Buy the Book If you liked this eBook, perhaps you'd like to have a paper copy of the book.
