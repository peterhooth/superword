Programming in Scala is probably one of the best programming books I’ve ever read.
I like the writing style, the brevity, and the thorough explanations.
The book seems to answer every question as it enters my mind—it’s always one step ahead of me.
The authors don’t just give you some code and take things for granted.
They give you the meat so you really understand what’s going on.
Programming in Scala is clearly written, thorough, and easy to follow.
It has enabled our organization to ramp up on the Scala language quickly and efficiently.
This book is great for any programmer who is trying to wrap their head around the flexibility and elegance of the Scala language.
The Programming in Scala book serves as an excellent tutorial to the Scala language.
Working through the book, it flows well with each chapter building on concepts and examples described in earlier ones.
The book takes care to explain the language constructs in depth, often providing examples of how the language differs from Java.
As well as the main language, there is also some coverage of libraries such as containers and actors.
I have found the book really easy to work through, and it is probably one of the better written technical books I have read recently.
I really would recommend this book to any programmer wanting to find out more about the Scala language.
I am amazed by the effort undertaken by the authors of Programming in Scala.
This book is an invaluable guide to what I like to call Scala the Platform: a vehicle to better coding, a constant inspiration for scalable software design and implementation.
To all readers: No matter what your programming background is, I feel you will find programming in Scala liberating and this book will be a loyal friend in the journey.
Programming in Scala is a superb in-depth introduction to Scala, and it’s also an excellent reference.
I’d say that it occupies a prominent place on my bookshelf, except that I’m still carrying it around with me nearly everywhere I go.
I would recommend it to both seasoned programmers and newbies.
The book Programming in Scala is not only about how, but more importantly, why to develop programs in this new programming language.
The book’s pragmatic approach in introducing the power of combining objectoriented and functional programming leaves the reader without any doubts as to what Scala really is.
This is a great introduction to functional programming for OO programmers.
Learning about FP was my main goal, but I also got acquainted with some nice Scala surprises like case classes and pattern matching.
Scala is an intriguing language and this book covers it well.
There’s always a fine line to walk in a language introduction book between giving too much or not enough information.
I find Programming in Scala to achieve a perfect balance.
I bought an early electronic version of the Programming in Scala book, by Odersky, Spoon, and Venners, and I was immediately a fan.
In addition to the fact that it contains the most comprehensive information about the language, there are a few key features of the electronic format that impressed me.
I have never seen links used as well in a PDF, not just for bookmarks, but also providing active links from the table of contents and index.
I don’t know why more authors don’t use this feature, because it’s really a joy for the reader.
Another feature which I was impressed with was links to the forums (“Discuss”) and a way to send comments (“Suggest”) to the authors via email.
The comments feature by itself isn’t all that uncommon, but the simple inclusion of a page number in what is generated to send to the authors is valuable for both the authors and readers.
I contributed more comments than I would have if the process would have been more arduous.
Read Programming in Scala for the content, but if you’re reading the electronic version, definitely take advantage of the digital features that the authors took the care to build in!
Lucidity and technical completeness are hallmarks of any well-written book, and I congratulate Martin Odersky, Lex Spoon, and Bill Venners on a job indeed very well done! The Programming in Scala book starts by setting a strong foundation with the basic concepts and ramps up the user to an intermediate level & beyond.
This book is certainly a must buy for anyone aspiring to learn Scala.
This is one of those wellwritten technical books that provide deep and comprehensive coverage of the subject in an exceptionally concise and elegant manner.
The book is organized in a very natural and logical way.
It is equally well suited for a curious technologist who just wants to stay on top of the current trends and a professional seeking deep understanding of the language core features and its design rationales.
I highly recommend it to all interested in functional programming in general.
I’ve never read a tutorial-style book before that accomplishes to be introductory yet comprehensive: in their (misguided) attempt to be approachable and not “confuse” the reader, most tutorials silently ignore aspects of a subject that are too advanced for the current discussion.
This leaves a very bad taste, as one can never be sure as to the understanding one has achieved.
There is always some residual “magic” that hasn’t been explained and cannot be judged at all by the reader.
This book never does that, it never takes anything for granted: every detail is either sufficiently explained or a reference to a later explanation is given.
Indeed, the text is extensively cross-referenced and indexed, so that forming a complete picture of a complex topic is relatively easy.
Programming in Scala by Martin Odersky, Lex Spoon, and Bill Venners: in times where good programming books are rare, this excellent introduction for intermediate programmers really stands out.
You’ll find everything here you need to learn this promising language.
Martin Odersky is the creator of the Scala language and a professor at EPFL in Lausanne, Switzerland.
Lex Spoon worked on Scala for two years as a post-doc with Martin Odersky.
No part of this publication may be reproduced, modified, distributed, stored in a retrieval system, republished, displayed, or performed, for commercial or noncommercial purposes or for compensation of any kind without prior written permission from Artima, Inc.
All information and materials in this book are provided "as is" and without warranty of any kind.
The term “Artima” and the Artima logo are trademarks or registered trademarks of Artima, Inc.
All other company and/or product names may be trademarks or registered trademarks of their owners.
I’m not sure where I first came across the Scala language.
Maybe on a forum for programming language enthusiasts such as Lambda the Ultimate, or maybe in more pedestrian quarters: Reddit, or the like.
Although I was intrigued at first blush, I owe my deeper exploration and enthusiasm for the language to two individuals: David Pollak, creator of the Lift web framework, and Steve Jenson, a former colleague at Twitter and generally brilliant programmer.
Following David and Steve, I arrived to Scala in the late-middle stage of the language’s history to date.
By 2008, Scala had spent five years evolving from its initial release, and had formed around it a tight-knit community of academics, tinkerers, and even a few consultants.
The mailing lists were full of spirited debates, announcements of exciting libraries, and a general camaraderie and shared joy for seeing what this powerful new tool could do.
What Scala lacked, at that point, was a collection of success stories around major production deployments.
The decision to use Scala at Twitter, where I then worked, was not an easy one to make.
Our infrastructure was buckling under the weight of extreme growth.
Picking a relative unknown as our language of choice for building the high-performance distributed systems that would keep our fledgling service alive was risky.
Still, the benefits that Scala offered were (and are) compelling, and our engineers were quickly able to produce prototypes that proved out the language’s effectiveness.
In the intervening time, I’ve seen a heartening number of companies large and small adopting Scala.
In that time, too, the question of Scala’s complexity has been raised.
From the outside, Scala’s many features might appear to be a kind of complexity.
To understand Scala, though, is to understand its goal of being a scalable language.
You can be writing real-world code in Scala in an afternoon.
You won’t understand the full power of its type system by the end of your first day.
You won’t understand the zen of objects being functions and functions being objects in your first week.
Each feature of the language is another light bulb waiting to switch on over your head.
I’m certain you’ll enjoy the experience of being gradually illuminated as you read this book and write code.
I’ve watched programmers learn Scala on the job and succeed.
As Scala programmers like me have grown to better understand what this powerful language can do, so too has Scala evolved to meet programmers’ needs.
Scala 2.8 smoothes out some rough spots in the collection libraries and adds useful features like named and default arguments to methods.
While Scala has been a perfectly productive language to work with for some time, as of 2.8 it feels even more solid and polished.
In my experience, Scala was ready for production deployments two years ago.
Today, it’s even better, and I can’t imagine building a new system without it.
For me, Scala has gone from being a risky gamble to a trusted tool in two short years.
I look forward to taking advantage of the latest features in Scala 2.8, and to using this book as the definitive reference for it, direct from the creator of the language I’ve grown to depend on.
Martin Odersky made a huge impact on the Java world with his design of the Pizza language.
Although Pizza itself never became popular, it demonstrated that object-oriented and functional language features, when combined with skill and taste, form a natural and powerful combination.
Pizza’s design became the basis for generics in Java, and Martin’s GJ (Generic Java) compiler was Sun Microsystem’s standard compiler starting in 1.3 (though with generics disabled)
I had the pleasure of maintaining this compiler for a number of years, so I can report from first-hand experience that Martin’s skill in language design extends to language implementation.
Since that time, we at Sun tried to simplify program development by extending the language with piecemeal solutions to particular problems, like the for-each loop, enums, and autoboxing.
Meanwhile, Martin continued his work on more powerful orthogonal language primitives that allow programmers to provide solutions in libraries.
Lately, there has been a backlash against statically typed languages.
Experience with Java has shown that programming in a static language results in an abundance of boilerplate.
The common wisdom is that one must abandon static typing to eliminate the boilerplate, and there is a rising interest in dynamic languages such as Python, Ruby, and Groovy.
This common wisdom is debunked by the existence of Martin’s latest brainchild, Scala.
Scala is a tastefully typed language: it is statically typed, but explicit types appear in just the right places.
Scala takes powerful features from object-oriented and functional languages, and combines them with a few novel ideas in a beautifully coherent whole.
The syntax is so lightweight, and its primitives so expressive, that APIs can be used with virtually no syntactic overhead at all.
Examples can be found in standard libraries such as parser combinators and actors.
Will Scala be the next great language? Only time will tell.
Martin Odersky’s team certainly has the taste and skill for the job.
One thing is sure: Scala sets a new standard against which future languages will be measured.
Many people have contributed to this book and to the material it covers.
George Berger has worked tremendously to make the build process and the web presence for the book work smoothly.
As a result this project has been delightfully free of technical snafus.
Many people gave us valuable feedback on early versions of the text.
This book is a tutorial for the Scala programming language, written by people directly involved in the development of Scala.
Our goal is that by reading this book, you can learn everything you need to be a productive Scala programmer.
All examples in this book compile with Scala version 2.8.1
The main target audience for this book is programmers who want to learn to program in Scala.
If you want to do your next software project in Scala, then this is the book for you.
In addition, the book should be interesting to programmers wishing to expand their horizons by learning new concepts.
If you’re a Java programmer, for example, reading this book will expose you to many concepts from functional programming as well as advanced objectoriented ideas.
We believe learning about Scala, and the ideas behind it, can help you become a better programmer in general.
While Scala is a fine first programming language, this is not the book to use to learn programming.
On the other hand, no specific knowledge of programming languages is required.
Even though most people use Scala on the Java platform, this book does not presume you know anything about Java.
However, we expect many readers to be familiar with Java, and so we sometimes compare Scala to Java to help such readers understand the differences.
Because the main purpose of this book is to serve as a tutorial, the recommended way to read this book is in chapter order, from front to back.
We have tried hard to introduce one topic at a time, and explain new topics only.
Thus, if you skip to the back to get an early peek at something, you may find it explained in terms of concepts you don’t quite understand.
To the extent you read the chapters in order, we think you’ll find it quite straightforward to gain competency in Scala, one step at a time.
If you see a term you do not know, be sure to check the glossary and the index.
Many readers will skim parts of the book, and that is just fine.
The glossary and index can help you backtrack whenever you skim over something too quickly.
After you have read the book once, it should also serve as a language reference.
There is a formal specification of the Scala language, but the language specification tries for precision at the expense of readability.
Although this book doesn’t cover every detail of Scala, it is quite comprehensive and should serve as an approachable language reference as you become more adept at programming in Scala.
You will learn a lot about Scala simply by reading this book from cover to cover.
You can learn Scala faster and more thoroughly, though, if you do a few extra things.
First of all, you can take advantage of the many program examples included in the book.
Typing them in yourself is a way to force your mind through each line of code.
Trying variations is a way to make them more fun and to make sure you really understand how they work.
That way, you and other Scala enthusiasts can help each other.
There are numerous mailing lists, discussion forums, a chat room, a wiki, and multiple Scala-specific article feeds.
Take some time to find ones that fit your information needs.
You will spend a lot less time stuck on little problems, so you can spend your time on deeper, more important questions.
Finally, once you have read enough, take on a programming project of your own.
Work on a small program from scratch, or develop an add-in to a larger program.
This book is available in both paper and PDF eBook form.
The eBook is not simply an electronic copy of the paper version of the book.
While the content is the same as in the paper version, the eBook has been carefully designed and optimized for reading on a computer screen.
The first thing to notice is that most references within the eBook are hyperlinked.
If you select a reference to a chapter, figure, or glossary entry, your PDF viewer should take you immediately to the selected item so that you do not have to flip around to find it.
Additionally, at the bottom of each page in the eBook are a number of navigation links.
The “Cover,” “Overview,” and “Contents” links take you to the front matter of the book.
The “Glossary” and “Index” links take you to reference parts of the book.
Finally, the “Discuss” link takes you to an online forum where you discuss questions with other readers, the authors, and the larger Scala community.
If you find a typo, or something you think could be explained better, please click on the “Suggest” link, which will take you to an online web application where you can give the authors feedback.
Although the same pages appear in the eBook as the printed book, blank pages are removed and the remaining pages renumbered.
The pages are numbered differently so that it is easier for you to determine PDF page numbers when printing only a portion of the eBook.
The pages in the eBook are, therefore, numbered exactly as your PDF viewer will number them.
The first time a term is used, it is italicized.
Small code examples, such as x + 1, are written inline with a mono-spaced font.
Larger code examples are put into mono-spaced quotation blocks like this:
When interactive shells are shown, responses from the shell are shown in a lighter font:
Chapter 1, “A Scalable Language,” gives an overview of Scala’s design as well as the reasoning, and history, behind it.
Chapter 2, “First Steps in Scala,” shows you how to do a number of basic programming tasks in Scala, without going into great detail about how they work.
The goal of this chapter is to get your fingers started typing and running Scala code.
Chapter 3, “Next Steps in Scala,” shows you several more basic programming tasks that will help you get up to speed quickly in Scala.
After completing this chapter, you should be able to start using Scala for simple scripting tasks.
Chapter 4, “Classes and Objects,” starts the in-depth coverage of Scala with a description of its basic object-oriented building blocks and instructions on how to compile and run a Scala application.
Chapter 5, “Basic Types and Operations,” covers Scala’s basic types, their literals, the operations you can perform on them, how precedence and associativity works, and what rich wrappers are.
Chapter 6, “Functional Objects,” dives more deeply into the objectoriented features of Scala, using functional (i.e., immutable) rational numbers as an example.
Chapter 7, “Built-in Control Structures,” shows you how to use Scala’s built-in control structures: if, while, for, try, and match.
Chapter 8, “Functions and Closures,” provides in-depth coverage of functions, the basic building block of functional languages.
Chapter 9, “Control Abstraction,” shows how to augment Scala’s basic control structures by defining your own control abstractions.
Chapter 10, “Composition and Inheritance,” discusses more of Scala’s support for object-oriented programming.
The topics are not as fundamental as those in Chapter 4, but they frequently arise in practice.
Chapter 11, “Scala’s Hierarchy,” explains Scala’s inheritance hierarchy and discusses its universal methods and bottom types.
The chapter shows how traits work, describes common uses, and explains how traits improve on traditional multiple inheritance.
Chapter 13, “Packages and Imports,” discusses issues with programming in the large, including top-level packages, import statements, and access control modifiers like protected and private.
Chapter 14, “Assertions and Unit Testing,” shows Scala’s assertion mechanism and gives a tour of the various tools available for writing tests in Scala.
Chapter 15, “Case Classes and Pattern Matching,” introduces twin constructs that support you when writing regular, non-encapsulated data structures.
Case classes and pattern matching are particularly helpful for tree-like recursive data.
Chapter 16, “Working with Lists,” explains in detail lists, which are probably the most commonly used data structure in Scala programs.
Chapter 17, “Collections,” shows you how to use the basic Scala collections, such as lists, arrays, tuples, sets, and maps.
Chapter 18, “Stateful Objects,” explains stateful (i.e., mutable) objects, and the syntax Scala provides to express them.
The chapter concludes with a case study on discrete event simulation, which shows some stateful objects in action.
The chapter builds up to a description of variance of type parameters and how it interacts with information hiding.
Chapter 20, “Abstract Members,” describes all kinds of abstract members that Scala supports.
Not only methods, but also fields and types can be declared abstract.
Chapter 21, “Implicit Conversions and Parameters,” covers two constructs that can help you omit tedious details from source code, letting the compiler supply them instead.
Chapter 22, “Implementing Lists,” describes the implementation of class List.
It is important to understand how lists work in Scala, and furthermore the implementation demonstrates the use of several of Scala’s features.
Chapter 23, “For Expressions Revisited,” shows how for expressions are translated to invocations of map, flatMap, filter, and foreach.
Chapter 24, “The Scala Collections API,” gives a detailed tour of the collections library.
Chapter 25, “The Architecture of Scala Collections,” shows how the collection library is built and how you can implement your own collections.
Chapter 26, “Extractors,” shows how to pattern match against arbitrary classes, not just case classes.
Chapter 27, “Annotations,” shows how to work with language extension via annotation.
The chapter describes several standard annotations and shows you how to make your own.
Chapter 28, “Working with XML,” explains how to process XML in Scala.
The chapter shows you idioms for generating XML, parsing it, and processing it once it is parsed.
Chapter 29, “Objects As Modules,” shows how Scala’s objects are rich enough to remove the need for a separate modules system.
Chapter 30, “Object Equality,” points out several issues to consider when writing an equals method.
Chapter 31, “Combining Scala and Java,” discusses issues that arise when combining Scala and Java together in the same project, and suggests ways to deal with them.
Chapter 32, “Actors and Concurrency,” shows you how to use Scala’s actors concurrency library.
Although you can use the Java Platform’s concurrency primitives and libraries from Scala programs, actors can help you avoid the deadlocks and race conditions that plague the traditional “threads and locks” approach to concurrency.
Chapter 33, “Combinator Parsing,” shows how to build parsers using Scala’s library of parser combinators.
Chapter 34, “GUI Programming,” gives a quick tour of a Scala library that simplifies GUI programming with Swing.
Chapter 35, “The SCells Spreadsheet,” ties everything together by showing a complete spreadsheet application written in Scala.
At http://www.scala-lang.org, the main website for Scala, you’ll find the latest Scala release and links to documentation and community resources.
For a more condensed page of links to Scala resources, visit this book’s website: http://booksites.artima.com/programming_in_scala_2ed.
To interact with other readers of this book, check out the Programming in Scala Forum, at: http://www.artima.com/forums/forum.jsp?forum=282
Although this book has been heavily reviewed and checked, errors will inevitably slip through.
For a (hopefully short) list of errata for this book, visit http://booksites.artima.com/programming_in_scala_2ed/errata.
If you find an error, please report it at the above URL, so that we can be sure to fix it in a future printing or edition of this book.
The name Scala stands for “scalable language.” The language is so named because it was designed to grow with the demands of its users.
You can apply Scala to a wide range of programming tasks, from writing small scripts to building large systems.1
It runs on the standard Java platform and interoperates seamlessly with all Java libraries.
It’s quite a good language for writing scripts that pull together Java components.
But it can apply its strengths even more when used for building large systems and frameworks of reusable components.
Technically, Scala is a blend of object-oriented and functional programming concepts in a statically typed language.
The fusion of object-oriented and functional programming shows up in many different aspects of Scala; it is probably more pervasive than in any other widely used language.
The two programming styles have complementary strengths when it comes to scalability.
Scala’s functional programming constructs make it easy to build interesting things quickly from simple parts.
Its object-oriented constructs make it easy to structure larger systems and to adapt them to new demands.
The combination of both styles in Scala makes it possible to express new kinds of programming patterns and component abstractions.
It also leads to a legible and concise programming style.
And because it is so malleable, programming in Scala can be a lot of fun.
This initial chapter answers the question, “Why Scala?” It gives a highlevel view of Scala’s design and the reasoning behind it.
After reading the chapter you should have a basic feel for what Scala is and what kinds of.
Although this book is a Scala tutorial, this chapter isn’t really part of the tutorial.
Programs of different sizes tend to require different programming constructs.
Indeed, the feel is that of a modern “scripting” language like Perl, Python, or Ruby.
One common characteristic of these languages, which is relevant for the example above, is that they each support an “associative map” construct in the syntax of the language.
Associative maps are very useful because they help keep programs legible and concise.
However, sometimes you might not agree with their “one size fits all” philosophy, because you need to control the properties of the maps you use in your program in a more fine-grained way.
Scala gives you this fine-grained control if you need it, because maps in Scala are not language syntax.
They are library abstractions that you can extend and adapt.
In the above program, you’ll get a default Map implementation, but you can easily change that.
You could for example specify a particular implementation, such as a HashMap or a TreeMap, or you could specify that the map should be thread-safe, by mixing in a SynchronizedMap trait.
You could specify a default value for the map, or you could override any other method of the map you create.
In each case, you can use the same easy access syntax for maps as in the example above.
Please bear with us if you don’t understand all details of this program.
This example shows that Scala can give you both convenience and flexibility.
Scala has a set of convenient constructs that help you get started quickly and let you program in a pleasantly concise style.
At the same time, you have the assurance that you will not outgrow the language.
You can always tailor the program to your requirements, because everything is based on library modules that you can select and adapt as needed.
Eric Raymond introduced the cathedral and bazaar as two metaphors of software development.3 The cathedral is a near-perfect building that takes a long time to build.
The bazaar, by contrast, is adapted and extended each day by the people working in it.
In Raymond’s work the bazaar is a metaphor for open-source software development.
Guy Steele noted in a talk on “growing a language” that the same distinction can be applied to language design.4 Scala is much more like a bazaar than a cathedral, in the sense that it is designed to be extended and adapted by the people programming in it.
Instead of providing all constructs you might ever need in one “perfectly complete” language, Scala puts the tools for building such constructs into your hands.
Many applications need a type of integer that can become arbitrarily large without overflow or “wrap-around” of arithmetic operations.
Here is the definition of a method using that type, which calculates the factorial of a passed integer value:5
BigInt looks like a built-in type, because you can use integer literals and operators such as * and - with values of that type.
But the result is not nearly as pleasant, because although Java allows you to create new types, those types don’t feel much like native language support:
BigInt is representative of many other number-like types—big decimals, complex numbers, rational numbers, confidence intervals, polynomials—the list goes on.
For instance, Lisp, Haskell, and Python implement big integers; Fortran and Python implement complex numbers.
But any language that attempted to implement all of these abstractions at the same time would simply become too big to be manageable.
What’s more, even if such a language were to exist, some applications would surely benefit from other numberlike types that were not supplied.
So the approach of attempting to provide everything in one language doesn’t scale very well.
Instead, Scala allows users to grow and adapt the language in the directions they need by defining easy-to-use libraries that feel like native language support.
The previous example demonstrates that Scala lets you add new types that can be used as conveniently as built-in types.
This kind of extensibility is illustrated by Scala’s API for “actor-based” concurrent programming.
Scala comes with a standard library, some of which will be covered in this book.
For more information, you can also consult the library’s Scaladoc documentation, which is available in the distribution and online at http://www.scala-lang.org.
As multicore processors proliferate in the coming years, achieving acceptable performance may increasingly require that you exploit more parallelism in your applications.
Often, this will mean rewriting your code so that computations are distributed over several concurrent threads.
Unfortunately, creating dependable multi-threaded applications has proven challenging in practice.
Java’s threading model is built around shared memory and locking, a model that is often difficult to reason about, especially as systems scale up in size and complexity.
It is hard to be sure you don’t have a race condition or deadlock lurking—something that didn’t show up during testing, but might just show up in production.
An arguably safer alternative is a message passing architecture such as the “actors” approach used by the Erlang programming language.
Scala programs can use it like any other Java API.
However, Scala also offers an additional library that essentially implements Erlang’s actor model.
Actors are concurrency abstractions that can be implemented on top of threads.
An actor can perform two basic operations, message send and receive.
Here’s an example in which the actor is named recipient:
A send is asynchronous; that is, the sending actor can proceed immediately, without waiting for the message to be received and processed.
Every actor has a mailbox in which incoming messages are queued.
An actor handles messages that have arrived in its mailbox via a receive block:
A receive block consists of a number of cases that each query the mailbox with a message pattern.
The first message in the mailbox that matches any of the cases is selected, and the corresponding action is performed on it.
If the mailbox does not contain any messages that match one of the given cases, the actor suspends and waits for further incoming messages.
As an example, here is a simple Scala actor implementing a checksum calculator service:
This actor first defines a local variable named sum with initial value zero.
It then repeatedly waits in a loop for messages, using a receive statement.
If it receives a Data message, it adds a hash of the sent bytes to the sum variable.
If it receives a GetSum message, it sends the current value of sum back to the requester using the message send requester ! sum.
The requester field is embedded in the GetSum message; it usually refers to the actor that made the request.
We don’t expect you to understand fully the actor example at this point.
Even though actor, loop, and receive look and act very much like built-in control constructs such as while or for loops, they are in fact methods defined in Scala’s actors library.
Likewise, even though ‘!’ looks like a built-in operator, it too is just a method defined in the actors library.
All four of these constructs are completely independent of the Scala programming language.
Scala also implements most of Erlang’s other concurrent programming constructs, such as monitoring failed actors and time-outs.
All in all, actors have turned out to be a very pleasant means for expressing concurrent and distributed computations.
Even though they are defined in a library, actors feel like an integral part of the Scala language.
This example illustrates that you can “grow” the Scala language in new directions even as specialized as concurrent programming.
To be sure, you need good architects and programmers to do this.
Scalability is influenced by many factors, ranging from syntax details to component abstraction constructs.
If we were forced to name just one aspect of Scala that helps scalability, though, we’d pick its combination of object-oriented and functional programming (well, we cheated, that’s really two aspects, but they are intertwined)
Scala goes further than all other well-known languages in fusing objectoriented and functional programming into a uniform language design.
For instance, where other languages might have objects and functions as two different concepts, in Scala a function value is an object.
Function types are classes that can be inherited by subclasses.
This might seem nothing more than an academic nicety, but it has deep consequences for scalability.
In fact the actor concept shown previously could not have been implemented without this unification of functions and objects.
This section gives an overview of Scala’s way of blending object-oriented and functional concepts.
While there is not a precise definition of what object-oriented means, there is clearly something about objects that appeals to programmers.
In principle, the motivation for object-oriented programming is very simple: all but the most trivial programs need some sort of structure.
The most straightforward way to do this is to put data and operations into some form of containers.
The great idea of object-oriented programming is to make these containers fully general, so that they can contain operations as well as data, and that they are themselves values that can be stored in other containers, or passed as parameters to operations.
Alan Kay, the inventor of Smalltalk, remarked that in this way the simplest object has the same construction principle as a full computer: it combines data with.
Even though object-oriented programming has been mainstream for a long time, there are relatively few languages that have followed Smalltalk in pushing this construction principle to its logical conclusion.
For instance, many languages admit values that are not objects, such as the primitive values in Java.
Or they allow static fields and methods that are not members of any object.
These deviations from the pure idea of object-oriented programming look quite harmless at first, but they have an annoying tendency to complicate things and limit scalability.
By contrast, Scala is an object-oriented language in pure form: every value is an object and every operation is a method call.
You can define methods with operator-like names that clients of your API can then use in operator notation.
This is how the designer of Scala’s actors API enabled you to use expressions such as requester ! sum shown in the previous example: ‘!’ is a method of the Actor class.
Scala is more advanced than most other languages when it comes to composing objects.
Traits are like interfaces in Java, but they can also have method implementations and even fields.
Objects are constructed by mixin composition, which takes the members of a class and adds the members of a number of traits to them.
In this way, different aspects of classes can be encapsulated in different traits.
This looks a bit like multiple inheritance, but differs when it comes to the details.
Unlike a class, a trait can add some new functionality to an unspecified superclass.
In particular, it avoids the classical “diamond inheritance” problems of multiple inheritance, which arise when the same class is inherited via several different paths.
In addition to being a pure object-oriented language, Scala is also a fullblown functional language.
The ideas of functional programming are older than (electronic) computers.
Their foundation was laid in Alonzo Church’s lambda calculus, which he developed in the 1930s.
The first functional programming language was Lisp, which dates from the late 50s.
For a long time, functional programming has been a bit on the sidelines, popular in academia, but not that widely used in industry.
However, recent years have seen an increased interest in functional programming languages and techniques.
In a functional language, a function is a value of the same status as, say, an integer or a string.
You can pass functions as arguments to other functions, return them as results from functions, or store them in variables.
You can also define a function inside another function, just as you can define an integer value inside a function.
Functions that are first-class values provide a convenient means for abstracting over operations and creating new control structures.
This generalization of functions provides great expressiveness, which often leads to very legible and concise programs.
As an example, the receive construct shown previously in the actor example is an invocation of a method that takes a function as argument.
The code inside the receive construct is a function that is passed unexecuted into the receive method.
In most traditional languages, by contrast, functions are not values.
Languages that do have function values often relegate them to second-class status.
For example, the function pointers of C and C++ do not have the same status as non-functional values in those languages: function pointers can only refer to global functions, they do not allow you to define first-class nested functions that refer to some values in their environment.
Nor do they allow you to define unnamed function literals.
The second main idea of functional programming is that the operations of a program should map input values to output values rather than change data in place.
To see the difference, consider the implementation of strings in Ruby and in Java.
For instance you can change a semicolon character in a string to a period inside the same string object.
In Java and Scala, on the other hand, a string is a sequence of characters in the mathematical sense.
Replacing a character in a string using an expression like s.replace(';', '.') yields a new string object, which is different from s.
Another way of expressing this is that strings are immutable in Java.
So looking at just strings, Java is a functional language, whereas Ruby is not.
Immutable data structures are one of the cornerstones of functional programming.
The Scala libraries define many more immutable data types on top of those found in the Java APIs.
For instance, Scala has immutable lists, tuples, maps, and sets.
Another way of stating this second idea of functional programming is that methods should not have any side effects.
They should communicate with their environment only by taking arguments and returning results.
For instance, the replace method in Java’s String class fits this description.
It takes a string and two characters and yields a new string where all occurrences of one character are replaced by the other.
Methods like replace are called referentially transparent, which means that for any given input the method call could be replaced by its result without affecting the program’s semantics.
Functional languages encourage immutable data structures and referentially transparent methods.
When you want to, you can write in an imperative style, which is what programming with mutable data and side effects is called.
But Scala generally makes it easy to avoid imperative constructs when you want, because good functional alternatives exist.
Is Scala for you? You will have to see and decide for yourself.
We have found that there are actually many reasons besides scalability to like programming in Scala.
Four of the most important aspects will be discussed in this section: compatibility, brevity, high-level abstractions, and advanced static typing.
Scala doesn’t require you to leap backwards off the Java platform to step forward from the Java language.
It allows you to add value to existing code—to build on what you already have—because it was designed for seamless interoperability with Java.8 Scala programs compile to JVM bytecodes.
Their run-time performance is usually on par with Java programs.
There is also a Scala variant that runs on the .NET platform, but the JVM variant currently has better support.
None of this requires special syntax, explicit interface descriptions, or glue code.
In fact, almost all Scala code makes heavy use of Java libraries, often without programmers being aware of this fact.
Another aspect of full interoperability is that Scala heavily re-uses Java types.
Scala’s Ints are represented as Java primitive integers of type int, Floats are represented as floats, Booleans as booleans, and so on.
Scala also re-uses many of the standard Java library types.
Scala not only re-uses Java’s types, but also “dresses them up” to make them nicer.
For instance, Scala’s strings support methods like toInt or toFloat, which convert the string to an integer or floating-point number.
How can this be achieved without breaking interoperability? Java’s String class certainly has no toInt method! In fact, Scala has a very general solution to solve this tension between advanced library design and interoperability.
Scala lets you define implicit conversions, which are always applied when types would not normally match up, or when non-existing members are selected.
In the case above, when looking for a toInt method on a string, the Scala compiler will find no such member of class String, but it will find an implicit conversion that converts a Java String to an instance of the Scala class StringOps, which does define such a member.
The conversion will then be applied implicitly before performing the toInt operation.
This is sometimes a bit more subtle, because Scala is a richer language than Java, so some of Scala’s more advanced features need to be encoded before they can be mapped to Java.
There are several factors that contribute to this reduction in lines of code.
First, Scala’s syntax avoids some of the boilerplate that burdens Java programs.
For instance, semicolons are optional in Scala and are usually left out.
There are also several other areas where Scala’s syntax is less noisy.
As an example, compare how you write classes and constructors in Java and Scala.
In Java, a class with a constructor often looks like this:
Given this code, the Scala compiler will produce a class that has two private instance variables, an Int named index and a String named name, and a constructor that takes initial values for those variables as parameters.
The code of this constructor will initialize the two instance variables with the values passed as parameters.
In short, you get essentially the same functionality as the more verbose Java version.9 The Scala class is quicker to write, easier to read, and most importantly, less error prone than the Java class.
Scala’s type inference is another factor that contributes to its conciseness.
Repetitive type information can be left out, so programs become less cluttered and more readable.
But probably the most important key to compact code is code you don’t have to write because it is done in a library for you.
Scala gives you many tools to define powerful libraries that let you capture and factor out common behavior.
For instance, different aspects of library classes can be separated.
The only real difference is that the instance variables produced in the Scala case will be final.
You’ll learn how to make them non-final in Section 10.6
Or, library methods can be parameterized with operations, which lets you define constructs that are, in effect, your own control structures.
Together, these constructs allow the definition of libraries that are both high-level and flexible to use.
To program productively, you must understand the code on which you are working.
Overly complex code has been the downfall of many a software project.
Such complexity can’t be avoided; it must instead be managed.
Scala helps you manage complexity by letting you raise the level of abstraction in the interfaces you design and use.
As an example, imagine you have a String variable name, and you want to find out whether or not that String contains an upper case character.
The Java code treats strings as low-level entities that are stepped through character by character in a loop.
The Scala code treats the same strings as higher-level sequences of characters that can be queried with predicates.
Clearly the Scala code is much shorter and—for trained eyes—easier to understand than the Java code.
So the Scala code weighs less heavily on the total complexity budget.
It describes a function that takes a character argument (represented by the underscore character), and tests whether it is an upper case letter.11
In principle, such control abstractions are possible in Java as well.
You’d need to define an interface that contains a method with the abstracted functionality.
For instance, if you wanted to support querying over strings, you might invent an interface, named CharacterProperty, which has just one method, hasProperty:
With that interface you could formulate a method exists in Java: It takes a string and CharacterProperty and returns true if there’s a character in the string that satisfies the property.
So heavy, in fact, that most Java programmers would not bother.
They would just write out the loops and live with the increased complexity in their code.
On the other hand, function literals in Scala are really lightweight, so they are used frequently.
As you get to know Scala better you’ll find more and more opportunities to define and use your own control abstractions.
You’ll find that this helps avoid code duplication and thus keeps your programs shorter and clearer.
A static type system classifies variables and expressions according to the kinds of values they hold and compute.
A function literal can be called a predicate if its result type is Boolean.
This use of the underscore as a placeholder for arguments is described in Section 8.5
Starting from a system of nested class types much like Java’s, it allows you to parameterize types with generics, to combine types using intersections, and to hide details of types using abstract types.12 These give a strong foundation for building and composing your own types, so that you can design interfaces that are at the same time safe and flexible to use.
If you like dynamic languages such as Perl, Python, Ruby, or Groovy, you might find it a bit strange that Scala’s static type system is listed as one of its strong points.
After all, the absence of a static type system has been cited by some as a major advantage of dynamic languages.
The most common arguments against static types are that they make programs too verbose, prevent programmers from expressing themselves as they wish, and make impossible certain patterns of dynamic modifications of software systems.
However, often these arguments do not go against the idea of static types in general, but against specific type systems, which are perceived to be too verbose or too inflexible.
For instance, Alan Kay, the inventor of the Smalltalk language, once remarked: “I’m not against types, but I don’t know of any type systems that aren’t a complete pain, so I still like dynamic typing.”13
We hope to convince you in this book that Scala’s type system is far from being a “complete pain.” In fact, it addresses nicely two of the usual concerns about static typing: verbosity is avoided through type inference and flexibility is gained through pattern matching and several new ways to write and compose types.
With these impediments out of the way, the classical benefits of static type systems can be better appreciated.
Among the most important of these benefits are verifiable properties of program abstractions, safe refactorings, and better documentation.
Static type systems can prove the absence of certain run-time errors.
For instance, they can prove properties like: booleans are never added to integers; private variables are not accessed from outside their class; functions are applied to the right number of arguments; only strings are ever added to a set of strings.
Other kinds of errors are not detected by today’s static type systems.
For instance, they will usually not detect non-terminating functions, array.
Kay, in an email on the meaning of object-oriented programming.
Static type systems have therefore been dismissed by some as not being very useful.
The argument goes that since such type systems can only detect simple errors, whereas unit tests provide more extensive coverage, why bother with static types at all? We believe that these arguments miss the point.
Although a static type system certainly cannot replace unit testing, it can reduce the number of unit tests needed by taking care of some properties that would otherwise need to be tested.
After all, as Edsger Dijkstra said, testing can only prove the presence of errors, never their absence.14 So the guarantees that static typing gives may be simple, but they are real guarantees of a form no amount of testing can deliver.
A static type system provides a safety net that lets you make changes to a codebase with a high degree of confidence.
Consider for instance a refactoring that adds an additional parameter to a method.
In a statically typed language you can do the change, re-compile your system and simply fix all lines that cause a type error.
Once you have finished with this, you are sure to have found all places that need to be changed.
The same holds for many other simple refactorings like changing a method name, or moving methods from one class to another.
In all cases a static type check will provide enough assurance that the new system works just like the old.
Static types are program documentation that is checked by the compiler for correctness.
Unlike a normal comment, a type annotation can never be out of date (at least not if the source file that contains it has recently passed a compiler)
Furthermore, compilers and integrated development environments can make use of type annotations to provide better context help.
For instance, an integrated development environment can display all the members available for a selection by determining the static type of the expression on which the selection is made and looking up all members of that type.
Even though static types are generally useful for program documentation, they can sometimes be annoying when they clutter the program.
On the other hand, at least one of the two annotations in the following example is annoying:
Clearly, it should be enough to say just once that x is a HashMap with Ints as keys and Strings as values; there’s no need to repeat the same phrase twice.
Scala has a very sophisticated type inference system that lets you omit almost all type information that’s usually considered annoying.
In the previous example, the following two less annoying alternatives would work just as well:
In fact, it’s not uncommon for user code to have no explicit types at all.
Therefore, Scala programs often look a bit like programs written in a dynamically typed scripting language.
This holds particularly for client application code, which glues together prewritten library components.
It’s less true for the library components themselves, because these often employ fairly sophisticated types to allow flexible usage patterns.
After all, the type signatures of the members that make up the interface of a reusable component should be explicitly given, because they constitute an essential part of the contract between the component and its clients.
Scala’s design has been influenced by many programming languages and ideas in programming language research.
In fact, only a few features of Scala are genuinely new; most have been already applied in some form in other languages.
Scala’s innovations come primarily from how its constructs are put together.
In this section, we list the main influences on Scala’s design.
The list cannot be exhaustive—there are simply too many smart ideas around in programming language design to enumerate them all here.
At the surface level, Scala adopts a large part of the syntax of Java and C#, which in turn borrowed most of their syntactic conventions from C and C++
Expressions, statements, and blocks are mostly as in Java, as is the syntax of classes, packages and imports.15 Besides syntax, Scala adopts other elements of Java, such as its basic types, its class libraries, and its execution model.
Its uniform object model was pioneered by Smalltalk and taken up subsequently by Ruby.
Its idea of universal nesting (almost every construct in Scala can be nested inside any other construct) is also present in Algol, Simula, and, more recently in Beta and gbeta.
Its uniform access principle for method invocation and field selection comes from Eiffel.
Its approach to functional programming is quite similar in spirit to the ML family of languages, which has SML, OCaml, and F# as prominent members.
Many higher-order functions in Scala’s standard library are also present in ML or Haskell.
Scala’s implicit parameters were motivated by Haskell’s type classes; they achieve analogous results in a more classical object-oriented setting.
Scala is not the first language to emphasize scalability and extensibility.
The specific idea of treating an infix operator as a function can be traced back to Iswim and Smalltalk.
Another important idea is to permit a function literal (or block) as a parameter, which enables libraries to define control structures.
Smalltalk and Lisp both have a flexible syntax that has been applied extensively for building internal domain-specific languages.
C++ is another scalable language that can be adapted and extended.
The major deviation from Java concerns the syntax for type annotations—it’s “variable: Type” instead of “Type variable” in Java.
The main reason for this deviation has to do with type inference, which often lets you omit the type of a variable or the return type of a method.
Using the “variable: Type” syntax this is easy—just leave out the colon and the type.
But in C-style “Type variable” syntax you cannot simply leave off the type—there would be no marker to start the definition anymore.
Such an alternative keyword feels more ad-hoc and less regular than Scala’s approach.
Scala is also not the first language to integrate functional and objectoriented programming, although it probably goes furthest in this direction.
Other languages that have integrated some elements of functional programming into OOP include Ruby, Smalltalk, and Python.
On the Java platform, Pizza, Nice, and Multi-Java have all extended a Java-like core with functional ideas.
There are also primarily functional languages that have acquired an object system; examples are OCaml, F#, and PLT-Scheme.
Scala has also contributed some innovations to the field of programming languages.
These innovations have been presented in papers at programming language conferences in recent years.17
In this chapter, we gave you a glimpse of what Scala is and how it might help you in your programming.
To be sure, Scala is not a silver bullet that will magically make you more productive.
To advance, you will need to apply Scala artfully, and that will require some learning and practice.
If you’re coming to Scala from Java, the most challenging aspects of learning Scala may involve Scala’s type system (which is richer than Java’s) and its support for functional programming.
The goal of this book is to guide you gently up Scala’s learning curve, one step at a time.
We think you’ll find it a rewarding intellectual experience that will expand your horizons and make you think differently about program design.
Hopefully, you will also gain pleasure and inspiration from programming in Scala.
In the next chapter, we’ll get you started writing some Scala code.
Before we start on the in-depth Scala tutorial, we put in two chapters that will give you the big picture of Scala, and most importantly, get you writing code.
We encourage you to actually try out all the code examples presented in this chapter and the next as you go.
The best way to start learning Scala is to program in it.
To run the examples in this chapter, you should have a standard Scala installation.
To get one, go to http://www.scala-lang.org/downloads and follow the directions for your platform.
If you are a veteran programmer new to Scala, the next two chapters should give you enough understanding to enable you to start writing useful programs in Scala.
If you are less experienced, some of the material may seem a bit mysterious to you.
To get you up to speed quickly, we had to leave out some details.
Everything will be explained in a less “fire hose” fashion in later chapters.
In addition, we inserted quite a few footnotes in these next two chapters to point you to later sections of the book where you’ll find more detailed explanations.
The easiest way to get started with Scala is by using the Scala interpreter, an interactive “shell” for writing Scala expressions and programs.
Simply type an expression into the interpreter and it will evaluate the expression and print.
We tested the examples in this book with Scala version 2.8.1
You use it by typing scala at a command prompt:2
The type Int names the class Int in the package scala.
Packages in Scala are similar to packages in Java: they partition the global namespace and provide a mechanism for information hiding.3 Values of class Int correspond to Java’s int values.
More generally, all of Java’s primitive types have corresponding classes in the scala package.
And when you compile your Scala code to Java bytecodes, the Scala compiler will use Java’s primitive types where possible to give you the performance benefits of the primitive types.
If you’re not familiar with Java packages, you can think of them as providing a full name for classes.
Because Int is a member of package scala, “Int” is the class’s simple name, and “scala.Int” is its full name.
To print the necessary, but not sufficient, Hello, world! greeting, type:
A val is similar to a final variable in Java.
A var, by contrast, is similar to a non-final variable in Java.
This statement introduces msg as a name for the string "Hello, world!"
This example illustrates type inference, Scala’s ability to figure out types you leave off.
In this case, because you initialized msg with a string literal, Scala inferred the type of msg to be String.
When the Scala interpreter (or compiler) can infer types, it is often best to let it do so rather than fill the code with unnecessary, explicit type annotations.
You can, however, specify a type explicitly if you wish, and sometimes you probably should.
An explicit type annotation can both ensure the Scala compiler infers the type you intend, as well as serve as useful documentation for future readers of the code.
In contrast to Java, where you specify a variable’s type before its name, in Scala you specify a variable’s type after its name, separated by a colon.
Or, since java.lang types are visible with their simple names4 in Scala programs, simply:
Going back to the original msg, now that it is defined, you can use it as you’d expect, for example:
What you can’t do with msg, given that it is a val, not a var, is reassign it.5 For example, see how the interpreter complains when you attempt the following:
If reassignment is what you want, you’ll need to use a var, as in:
Since greeting is a var not a val, you can reassign it later.
If you are feeling grouchy later, for example, you could change your greeting to:
To enter something into the interpreter that spans multiple lines, just keep typing after the first line.
If the code you typed so far is not complete, the interpreter will respond with a vertical bar on the next line.
If you realize you have typed something wrong, but the interpreter is still waiting for more input, you can escape by pressing enter twice:
In the rest of the book, we’ll leave out the vertical bars to make the code easier to read (and easier to copy and paste from the PDF eBook into the interpreter)
Now that you’ve worked with Scala variables, you’ll probably want to write some functions.
The function’s name, in this case max, is followed by a comma-separated list of parameters in parentheses.
A type annotation must follow every function parameter, preceded by a colon, because the Scala compiler (and interpreter, but from now on we’ll just say compiler) does not infer function parameter types.
In this example, the function named max takes two parameters, x and y, both of type Int.
After the close parenthesis of max’s parameter list you’ll find another “: Int” type annotation.
This one defines the result type of the max function itself.6 Following the.
In Java, the type of the value returned from a method is its return type.
In this case, the body contains a single if expression, which selects either x or y, whichever is greater, as the result of the max function.
As demonstrated here, Scala’s if expression can result in a value, similar to Java’s ternary operator.
The equals sign that precedes the body of a function hints that in the functional world view, a function defines an expression that results in a value.
The basic structure of a function is illustrated in Figure 2.1
Sometimes the Scala compiler will require you to specify the result type of a function.
If the function is recursive,7 for example, you must explicitly specify the function’s result type.
In the case of max however, you may leave the result type off and the compiler will infer it.8 Also, if a function consists of just one statement, you can optionally leave off the curly braces.
Thus, you could alternatively write the max function like this:
Such type annotations can make the code easier to read, because the reader need not study the function body to figure out the inferred result type.
Once you have defined a function, you can call it by name, as in:
Here’s the definition of a function that takes no parameters and returns no interesting result:
When you define the greet() function, the interpreter will respond with greet: ()Unit.
A result type of Unit indicates the function returns no interesting value.
Scala’s Unit type is similar to Java’s void type, and in fact every void-returning method in Java is mapped to a Unit-returning method in Scala.
Methods with the result type of Unit, therefore, are only executed for their side effects.
In the case of greet(), the side effect is a friendly greeting printed to the standard output.
In the next step, you’ll place Scala code in a file and run it as a script.
If you wish to exit the interpreter, you can do so by entering :quit or :q.
Although Scala is designed to help programmers build very large-scale systems, it also scales down nicely to scripting.
A script is just a sequence of statements in a file that will be executed sequentially.
You can run scripts without typing “scala” on Unix and Windows using a “poundbang” syntax, which is shown in Appendix A.
Command line arguments to a Scala script are available via a Scala array named args.
In Scala, arrays are zero based, and you access an element by specifying an index in parentheses.
To try this out, type the following into a new file named helloarg.scala:
In this command, "planet" is passed as a command line argument, which is accessed in the script as args(0)
This example also shows Strings being concatenated with the + operator.
The expression "Hello, "+"world!" will result in the string "Hello, world!".10
To try out a while, type the following into a file named printargs.scala:
You can also put spaces around the plus operator, as in "Hello, " + "world!"
In this book, however, we’ll leave the space off between ‘+’ and string literals.
Note Although the examples in this section help explain while loops, they do not demonstrate the best Scala style.
In the next section, you’ll see better approaches that avoid iterating through arrays with indexes.
The while construct on the next line causes the block (the code between the curly braces) to be repeatedly executed until the boolean expression i < args.length is false.
The block contains two statements, each indented two spaces, the recommended indentation style for Scala.
The first statement, println(args(i)), prints out the ith command line argument.
The second statement, i += 1, increments i by one.
Note that Java’s ++i and i++ don’t work in Scala.
For even more fun, type the following code into a new file with the name echoargs.scala:
In this version, you’ve replaced the println call with a print call, so that all the arguments will be printed out on the same line.
To make this readable, you’ve inserted a single space before each argument except the first via the.
Since i != 0 will be false the first time through the while loop, no space will get printed before the initial argument.
Lastly, you’ve added one more println to the end, to get a line return after printing out all the arguments.
Note that in Scala, as in Java, you must put the boolean expression for a while or an if in parentheses.
Another similarity to Java is that if a block has only one statement, you can optionally leave off the curly braces, as demonstrated by the if statement in echoargs.scala.
And although you haven’t seen any of them, Scala does use semicolons to separate statements as in Java, except that in Scala the semicolons are very often optional, giving some welcome relief to your right little finger.
If you had been in a more verbose mood, therefore, you could have written the echoargs.scala script as follows:
Although you may not have realized it, when you wrote the while loops in the previous step, you were programming in an imperative style.
Scala enables you to program imperatively, but as you get to know Scala better, you’ll likely often find yourself programming in a more functional style.
In fact, one of the main aims of this book is to help you become as comfortable with the functional style as you are with imperative style.
One of the main characteristics of a functional language is that functions are first class constructs, and that’s very true in Scala.
For example, another (far more concise) way to print each command line argument is:
In this code, you call the foreach method on args, and pass in a function.
In this case, you’re passing in a function literal that takes one parameter named arg.
If you type the above code into a new file named pa.scala, and execute with the command:
In the previous example, the Scala interpreter infers the type of arg to be String, since String is the element type of the array on which you’re calling foreach.
If you’d prefer to be more explicit, you can mention the type name, but when you do you’ll need to wrap the argument portion in parentheses (which is the normal form of the syntax anyway):
Running this script has the same behavior as the previous one.
If a function literal consists of one statement that takes a single argument, you need not explicitly name and specify the argument.11 Thus, the following code also works:
This shorthand, called a partially applied function, is described in Section 8.6
To summarize, the syntax for a function literal is a list of named parameters, in parentheses, a right arrow, and then the body of the function.
Now, by this point you may be wondering what happened to those trusty for loops you have been accustomed to using in imperative languages such as Java or C.
In an effort to guide you in a functional direction, only a functional relative of the imperative for (called a for expression) is available in Scala.
While you won’t see their full power and expressiveness until you reach (or peek ahead to) Section 7.3, we’ll give you a glimpse here.
To the left of <- is “arg”, the name of a val, not a var.
Because it is always a val, you just write “arg” by itself, not “val arg”
Although arg may seem to be a var, because it will get a new value on each iteration, it really is a val: arg can’t be reassigned inside the body of the for expression.
Instead, for each element of the args array, a new arg val will be created and initialized to the element value, and the body of the for will be executed.
You’d read for (arg <- args), therefore, as “for arg in args.”
Scala’s for expression can do much more than this, but this example is enough to get you started.
In this chapter, you learned some Scala basics and, hopefully, took advantage of the opportunity to write a bit of Scala code.
In the next chapter, we’ll continue this introductory overview and get into more advanced topics.
When you complete this chapter, you should have enough knowledge to enable you to start writing useful scripts in Scala.
As with the previous chapter, we recommend you try out these examples as you go.
The best way to get a feel for Scala is to start writing Scala code.
In Scala, you can instantiate objects, or class instances, using new.
When you instantiate an object in Scala, you can parameterize it with values and types.
You parameterize an instance with values by passing objects to a constructor in parentheses.
You parameterize an instance with types by specifying one or more types in square brackets.
If you run the code in Listing 3.1 as a script, you’ll see yet another Hello, world! greeting.
Note that when you parameterize an instance with both a type and a value, the type comes first in its square brackets, followed by the value in parentheses.
Note Although the code in Listing 3.1 demonstrates important concepts, it does not show the recommended way to create and initialize an array in Scala.
Had you been in a more explicit mood, you could have specified the type of greetStrings explicitly like this:
Given Scala’s type inference, this line of code is semantically equivalent to the actual first line of Listing 3.1
But this form demonstrates that while the type parameterization portion (the type names in square brackets) forms part of the type of the instance, the value parameterization part (the values in parentheses) does not.
The next three lines of code in Listing 3.1 initialize each element of the greetStrings array:
As mentioned previously, arrays in Scala are accessed by placing the index inside parentheses, not square brackets as in Java.
These three lines of code illustrate an important concept to understand about Scala concerning the meaning of val.
When you define a variable with val, the variable can’t be reassigned, but the object to which it refers could potentially still be changed.
But you can change the elements of that Array[String] over time, so the array itself is mutable.
The final two lines in Listing 3.1 contain a for expression that prints out each greetStrings array element in turn:
The first line of code in this for expression illustrates another general rule of Scala: if a method takes only one parameter, you can call it without a dot or parentheses.
The to in this example is actually a method that takes one Int argument.
Scala doesn’t technically have operator overloading, because it doesn’t actually have operators in the traditional sense.
Instead, characters such as +, -, *, and / can be used in method names.
Another important idea illustrated by this example will give you insight into why arrays are accessed with parentheses in Scala.
Arrays are simply instances of classes like any other class in Scala.
When you apply parentheses surrounding one or more values to a variable, Scala will transform the code into an invocation of a method named apply on that variable.
Thus accessing an element of an array in Scala is simply a method call like any other.
This principle is not restricted to arrays: any application of an object to some arguments in parentheses will be transformed to an apply method call.
Of course this will compile only if that type of object actually defines an apply method.
So it’s not a special case; it’s a general rule.
Similarly, when an assignment is made to a variable to which parentheses and one or more arguments have been applied, the compiler will transform that into an invocation of an update method that takes the arguments in parentheses as well as the object to the right of the equals sign.
Thus, the following is semantically equivalent to the code in Listing 3.1:
Scala achieves a conceptual simplicity by treating everything, from arrays to expressions, as objects with methods.
You don’t have to remember special cases, such as the differences in Java between primitive and their corresponding wrapper types, or between arrays and regular objects.
The Scala compiler uses Java arrays, primitive types, and native arithmetic where possible in the compiled code.
Although the examples you’ve seen so far in this step compile and run just fine, Scala provides a more concise way to create and initialize arrays that you would normally use.
This code creates a new array of length three, initialized to the passed strings, "zero", "one", and "two"
The compiler infers the type of the array to be Array[String], because you passed strings to it.
What you’re actually doing in Listing 3.2 is calling a factory method, named apply, which creates and returns the new array.
This apply method takes a variable number of arguments2 and is defined on the Array companion object.
If you’re a Java programmer, you can think of this as calling a static method named apply on class Array.
A more verbose way to call the same apply method is:
One of the big ideas of the functional style of programming is that methods should not have side effects.
A method’s only act should be to compute and return a value.
Some benefits gained when you take this approach are that methods become less entangled, and therefore more reliable and reusable.
Another benefit (in a statically typed language) is that everything that goes into and out of a method is checked by a type checker, so logic errors are more likely to manifest themselves as type errors.
Applying this functional philosophy to the world of objects means making objects immutable.
As you’ve seen, a Scala array is a mutable sequence of objects that all share the same type.
Variable-length argument lists, or repeated parameters, are described in Section 8.8
Although you can’t change the length of an array after it is instantiated, you can change its element values.
For an immutable sequence of objects that share the same type you can use Scala’s List class.
Scala’s List, scala.List, differs from Java’s java.util.List type in that Scala Lists are always immutable (whereas Java Lists can be mutable)
More generally, Scala’s List is designed to enable a functional style of programming.
For example, List has a method named ‘:::’ for list concatenation.
Perhaps the most common operator you’ll use with lists is ‘::’, which is pronounced “cons.” Cons prepends a new element to the beginning of an existing list, and returns the resulting list.
You don’t need to say new List because “List.apply()” is defined as a factory method on the scala.List companion object.
Note In the expression “1 :: twoThree”, :: is a method of its right operand, the list, twoThree.
If the method name ends in a colon, the method is invoked on the right operand.
Operator associativity will be described in more detail in Section 5.8
Scala’s List is packed with useful methods, many of which are shown in Table 3.1
Why not append to lists? Class List does offer an “append” operation —it’s written :+ and is explained in Chapter 24— but this operation is rarely used, because the time it takes to append to a list grows linearly with the size of the list, whereas prepending with :: takes constant time.
Your options if you want to build a list efficiently by appending elements is to prepend them, then when you’re done call reverse; or use a ListBuffer, a mutable list that does offer an append operation, and when you’re done call toList.
The reason you need Nil at the end is that :: is defined on class List.
List("Cool", "tools", "rule") Creates a new List[String] with the three values "Cool", "tools", and "rule"
Creates a new List[String] with the three values "Will", "fill", and "until"
List("a", "b") ::: List("c", "d") Concatenates two lists (returns a new List[String] with values "a", "b", "c", and "d")
Indicates whether all elements in the thrill list end with the letter "l" (returns true)
Returns a list containing all elements of the thrill list in alphabetical order of the first character lowercased (returns List("fill", "until", "Will"))
Like lists, tuples are immutable, but unlike lists, tuples can contain different types of elements.
Whereas a list might be a List[Int] or a List[String], a tuple could contain both an integer and a string at the same time.
Tuples are very useful, for example, if you need to return multiple objects from a method.
Whereas in Java you would often create a JavaBean-like class to hold the multiple return values, in Scala you can simply return a tuple.
And it is simple: to instantiate a new tuple that holds some objects, just place the objects in parentheses, separated by commas.
Once you have a tuple instantiated, you can access its elements individually with a dot, underscore, and the one-based index of the element.
Scala infers the type of the tuple to be Tuple2[Int, String], and gives that type to the variable pair as well.
The “.” in the second line is the same dot you’d use to access a field or invoke a method.
In this case you are accessing a field named _1
The actual type of a tuple depends on the number of elements it contains and the types of those elements.
Although conceptually you could create tuples of any length, currently the Scala library only defines them up to Tuple22
Accessing the elements of a tuple You may be wondering why you can’t access the elements of a tuple like the elements of a list, for example, with “pair(0)”
Because Scala aims to help you take advantage of both functional and imperative styles, its collections libraries make a point to differentiate between mutable and immutable collections.
For example, arrays are always mutable; lists are always immutable.
Scala also provides mutable and immutable alternatives for sets and maps, but uses the same simple names for both versions.
For sets and maps, Scala models mutability in the class hierarchy.
For example, the Scala API contains a base trait for sets, where a trait is similar to a Java interface.
Scala then provides two subtraits, one for mutable sets and another for immutable sets.
As you can see in Figure 3.2, these three traits all share the same simple name, Set.
Their fully qualified names differ, however, because each resides in a different package.
Concrete set classes in the Scala API, such as the HashSet classes shown in Figure 3.2, extend either the mutable or immutable Set trait.
Although in Java you “implement” interfaces, in Scala you “extend” or “mix in” traits.
Thus, if you want to use a HashSet, you can choose between mutable and immutable varieties depending upon your needs.
The default way to create a set is shown in Listing 3.5:
In the first line of code in Listing 3.5, you define a new var named.
As this example shows, you can create sets in Scala similarly to how you create lists and arrays: by invoking a factory method named apply on a Set companion object.
The Scala compiler infers jetSet’s type to be the immutable Set[String]
To add a new element to a set, you call + on the set, passing in the new element.
Both mutable and immutable sets offer a + method, but their behavior differs.
Whereas a mutable set will add the element to itself, an immutable set will create and return a new set with the element added.
In Listing 3.5, you’re working with an immutable set, thus the + invocation will yield a brand new set.
Although mutable sets offer an actual += method, immutable sets do not.
In this case, the second line of code, “jetSet += "Lear"”, is essentially a shorthand for:
Thus, in the second line of Listing 3.5, you reassign the jetSet var with a new set containing "Boeing", "Airbus", and "Lear"
If you want a mutable set, you’ll need to use an import, as shown in Listing 3.6:
In the first line of Listing 3.6 you import the mutable Set.
As with Java, an import statement allows you to use a simple name, such as Set, instead of the longer, fully qualified name.
On that line, you initialize movieSet with a new mutable set that contains the strings "Hitch" and "Poltergeist"
The subsequent line adds "Shrek" to the mutable set by calling the += method on the set, passing in the string "Shrek"
As mentioned previously, += is an actual method defined on mutable sets.
Although the default set implementations produced by the mutable and immutable Set factory methods shown thus far will likely be sufficient for most situations, occasionally you may want an explicit set class.
Simply import that class you need, and use the factory method on its companion object.
For example, if you need an immutable HashSet, you could do this:
As with sets, Scala provides mutable and immutable versions of Map, using a class hierarchy.
Because the set in Listing 3.6 is mutable, there is no need to reassign movieSet, which is why it can be a val.
By contrast, using += with the immutable set in Listing 3.5 required reassigning jetSet, which is why it must be a var.
Implementations of Map, such as the HashMaps shown in the class hierarchy in Figure 3.3, extend either the mutable or immutable trait.
You can create and initialize maps using factory methods similar to those used for arrays, lists, and sets.
For example, Listing 3.7 shows a mutable map in action.
On the first line of Listing 3.7, you import the mutable Map.
You then define a val named treasureMap and initialize it with an empty mutable Map that has integer keys and string values.
Finally, the last line prints the value that corresponds to the key 2 in the treasureMap.
If you prefer an immutable map, no import is necessary, as immutable is the default map.
You pass five key/value tuples to the map’s factory method, which returns an immutable Map containing the passed key/value pairs.
If you run the code in Listing 3.8 it will print “IV”
The explicit type parameterization, “[Int, String]”, is required in Listing 3.7 because without any values passed to the factory method, the compiler is unable to infer the map’s type parameters.
By contrast, the compiler can infer the type parameters from the values passed to the map factory shown in Listing 3.8, thus no explicit type parameters are needed.
As mentioned in Chapter 1, Scala allows you to program in an imperative style, but encourages you to adopt a more functional style.
If you are coming to Scala from an imperative background—for example, if you are a Java programmer—one of the main challenges you may face when learning Scala is figuring out how to program in the functional style.
We realize this style might be unfamiliar at first, and in this book we try hard to guide you through the transition.
It will require some work on your part, and we encourage you to make the effort.
If you come from an imperative background, we believe that learning to program in a functional style will not only make you a better Scala programmer, it will expand your horizons and make you a better programmer in general.
The first step is to recognize the difference between the two styles in code.
One telltale sign is that if code contains any vars, it is probably in an imperative style.
If the code contains no vars at all—i.e., it contains only vals—it is probably in a functional style.
One way to move towards a functional style, therefore, is to try to program without vars.
If you’re coming from an imperative background, such as Java, C++, or C#, you may think of var as a regular variable and val as a special kind of variable.
On the other hand, if you’re coming from a functional background, such as Haskell, OCaml, or Erlang, you might think of val as a regular variable and var as akin to blasphemy.
The Scala perspective, however, is that val and var are just two different tools in your toolbox, both useful, neither inherently evil.
Scala encourages you to lean towards vals, but ultimately reach for the best tool given the job at hand.
Even if you agree with this balanced philosophy, however, you may still find it challenging at first to figure out how to get rid of vars in your code.
Consider the following while loop example, adapted from Chapter 2, which uses a var and is therefore in the imperative style:
You can transform this bit of code into a more functional style by getting rid of the var, for example, like this:
This example illustrates one benefit of programming with fewer vars.
The refactored (more functional) code is clearer, more concise, and less error-prone than the original (more imperative) code.
The reason Scala encourages a functional style, in fact, is that the functional style can help you write more understandable, less error-prone code.
The refactored printArgs method is not purely functional, because it has side effects—in this case, its side effect is printing to the standard output stream.
The telltale sign of a function with side effects is that its result type is Unit.
If a function isn’t returning any interesting value, which is what a result type of Unit means, the only way that function can make a difference in the world is through some kind of side effect.
A more functional approach would be to define a method that formats the passed args for printing, but just returns the formatted string, as shown in Listing 3.9:
Now you’re really functional: no side effects or vars in sight.
The mkString method, which you can call on any iterable collection (including arrays, lists, sets, and maps), returns a string consisting of the result of calling toString on each element, separated by the passed string.
Thus if args contains three elements "zero", "one", and "two", formatArgs will return "zero\none\ntwo"
Every useful program is likely to have side effects of some form, because otherwise it wouldn’t be able to provide value to the outside world.
Preferring methods without side effects encourages you to design programs where side-effecting code is minimized.
One benefit of this approach is that it can help make your programs easier to test.
For example, to test any of the three printArgs methods shown earlier in this section, you’d need to redefine println, capture the output passed to it, and make sure it is what you expect.
By contrast, you could test the formatArgs function simply by checking its result:
Scala’s assert method checks the passed Boolean and if it is false, throws AssertionError.
If the passed Boolean is true, assert just returns quietly.
That said, bear in mind that neither vars nor side effects are inherently evil.
Scala is not a pure functional language that forces you to program everything in the functional style.
You may find that in some situations an imperative style is a better fit for the problem at hand, and in such cases you should not hesitate to use it.
A balanced attitude for Scala programmers Prefer vals, immutable objects, and methods without side effects.
Use vars, mutable objects, and methods with side effects when you have a specific need and justification for them.
Scripts that perform small, everyday tasks often need to process lines in files.
In this section, you’ll build a script that reads lines from a file and prints them out prepended with the number of characters in each line.
This script starts with an import of a class named Source from package scala.io.
It then checks to see if at least one argument was specified on the command line.
If so, the first argument is interpreted as a filename to open and process.
The getLines method returns an Iterator[String], which provides one line on each iteration, excluding the end-of-line character.
The for expression iterates through these lines and prints for each the length of the line, a space, and the line itself.
If there were no arguments supplied on the command line, the final else clause will print a message to the standard error stream.
Although the script in its current form prints out the needed information, you may wish to line up the numbers, right adjusted, and add a pipe character, so that the output looks instead like:
To accomplish this, you can iterate through the lines twice.
The first time through you’ll determine the maximum width required by any line’s character count.
The second time through you’ll print the output, using the maximum width calculated previously.
Because you’ll be iterating through the lines twice, you may as well assign them to a variable:
The final toList is required because the getLines method returns an iterator.
By transforming it into a list via the toList call, you gain the ability to iterate as many times as you wish, at the cost of storing all lines from the file in memory at once.
The lines variable, therefore, references a list of strings that contains the contents of the file specified on the command line.
Next, because you’ll be calculating the width of each line’s character count twice, once per iteration, you might factor that expression out into a small function, which calculates the character width of the passed string’s length:
With this function, you could calculate the maximum width like this:
The max method, which you can invoke on any Int, returns the greater of the value on which it was invoked and the value passed to it.
Alternatively, if you prefer to find the maximum without vars, you could first find the longest line like this:
The reduceLeft method applies the passed function to the first two elements in lines, then applies it to the result of the first application and the next element in lines, and so on, all the way through the list.
Given this result, you can calculate the maximum width by passing the longest line to widthOfLength:
All that remains is to print out the lines with proper formatting.
In this for expression, you once again iterate through the lines.
For each line, you first calculate the number of spaces required before the line length and assign it to numSpaces.
Finally, you print out the information with the desired formatting.
With the knowledge you’ve gained in this chapter, you should already be able to get started using Scala for small tasks, especially scripts.
In future chapters, we will dive into more detail in these topics, and introduce other topics that weren’t even hinted at here.
You’ve already seen the basics of classes and objects in Scala in the previous two chapters.
You’ll learn more about classes, fields, and methods, and get an overview of semicolon inference.
You’ll learn more about singleton objects, including how to use them to write and run a Scala application.
If you are familiar with Java, you’ll find the concepts in Scala are similar, but not exactly the same.
So even if you’re a Java guru, it will pay to read on.
Once you define a class, you can create objects from the class blueprint with the keyword new.
Inside a class definition, you place fields and methods, which are collectively called members.
Fields, which you define with either val or var, are variables that refer to objects.
The fields hold the state, or data, of an object, whereas the methods use that data to do the computational work of the object.
The image of the objects in memory might look like:
One thing to notice about this picture is that there are two sum variables, one in the object referenced by acc and the other in the object referenced.
Fields are also known as instance variables, because every instance gets its own set of the variables.
Collectively, an object’s instance variables make up the memory image of the object.
You can see this illustrated here not only in that you see two sum variables, but also that when you changed one, the other was unaffected.
Another thing to note in this example is that you were able to mutate the object acc referred to, even though acc is a val.
What you can’t do with acc (or csa), given that they are vals, not vars, is reassign a different object to them.
One important way to pursue robustness of an object is to ensure that the object’s state—the values of its instance variables—remains valid during its entire lifetime.
The first step is to prevent outsiders from accessing the fields directly by making the fields private.
Because private fields can only be accessed by methods defined in the same class, all the code that can update the state will be localized to the class.
To declare a field private, you place a private access modifier in front of the field, like this:
Note The way you make members public in Scala is by not explicitly specifying any access modifier.
Put another way, where you’d say “public” in Java, you simply say nothing in Scala.
Now that sum is private, the only code that can access sum is code defined inside the body of the class itself.
Any parameters to a method can be used inside the method.
One important characteristic of method parameters in Scala is that they are vals, not vars.1 If you attempt to reassign a parameter inside a method in Scala, therefore, it won’t compile:
First, the return at the end of the checksum method is superfluous and can be dropped.
In the absence of any explicit return statement, a Scala method returns the last value computed by the method.
The recommended style for methods is in fact to avoid having explicit, and especially multiple, return statements.
Instead, think of each method as an expression that yields one value, which is returned.
This philosophy will encourage you to make methods quite small, to factor larger methods.
The reason parameters are vals is that vals are easier to reason about.
You needn’t look further to determine if a val is reassigned, as you must do with a var.
On the other hand, design choices depend on the design context, and Scala makes it easy to write methods that have multiple, explicit returns if that’s what you desire.
Because all checksum does is calculate a value, it does not need an explicit return.
Another shorthand for methods is that you can leave off the curly braces if a method computes only a single result expression.
If the result expression is short, it can even be placed on the same line as the def itself.
A side effect is generally defined as mutating state somewhere external to the method or performing an I/O action.
In add’s case, for example, the side effect is that sum is reassigned.
Another way to express such methods is to leave off the result type and the equals sign, and enclose the body of the method in curly braces.
In this form, the method looks like a procedure, a method that is executed only for its side effects.
One puzzler to watch out for is that whenever you leave off the equals sign before the body of a function, its result type will definitely be Unit.
This is true no matter what the body contains, because the Scala compiler can convert any type to Unit.
For example, if the last result of a method is a String, but the method’s result type is declared to be Unit, the String will be converted to Unit and its value lost.
In this example, the String is converted to Unit because Unit is the declared result type of function f.
The Scala compiler treats a function defined in the procedure style, i.e., with curly braces but no equals sign, essentially the same as a function that explicitly declares its result type to be Unit:
The puzzler occurs, therefore, if you intend to return a non-Unit value, but forget the equals sign.
To get what you want, you’ll need to insert the missing equals sign:
In a Scala program, a semicolon at the end of a statement is usually optional.
You can type one if you want but you don’t have to if the statement appears by itself on a single line.
On the other hand, a semicolon is required if you write multiple statements on a single line:
If you want to enter a statement that spans multiple lines, most of the time you can simply enter it and Scala will separate the statements in the correct place.
For example, the following is treated as one four-line statement:
Occasionally, however, Scala will split a statement into two parts against your wishes:
If you intend it to parse as one statement x + y, you can always wrap it in parentheses:
Alternatively, you can put the + at the end of a line.
For just this reason, whenever you are chaining an infix operation such as +, it is a common Scala style to put the operators at the end of the line instead of the beginning:
The rules of semicolon inference The precise rules for statement separation are surprisingly simple for how well they work.
In short, a line ending is treated as a semicolon unless one of the following conditions is true:
The line in question ends in a word that would not be legal as the end of a statement, such as a period or an infix operator.
The next line begins with a word that cannot start a statement.
As mentioned in Chapter 1, one way in which Scala is more object-oriented than Java is that classes in Scala cannot have static members.
A singleton object definition looks like a class definition, except instead of the keyword class you use the keyword object.
When a singleton object shares the same name with a class, it is called that class’s companion object.
You must define both the class and its companion object in the same source file.
The class is called the companion class of the singleton object.
A class and its companion object can access each other’s private members.
We used a cache here to show a singleton object with a field.
A cache such as this is a performance optimization that trades off memory for computation time.
Otherwise, it executes the else clause, which calculates the checksum.
After the for expression completes, the next line of the method invokes checksum on acc, which gets the checksum for the passed String, and stores it into a val named cs.
In the next line, cache += (s -> cs), the passed string key is mapped to the integer checksum value, and this keyvalue pair is added to the cache map.
The last expression of the method, cs, ensures the checksum is the result of the method.
If you are a Java programmer, one way to think of singleton objects is as the home for any static methods you might have written in Java.
You can invoke methods on singleton objects using a similar syntax: the name of the singleton object, a dot, and the name of the method.
A singleton object is more than a holder of static methods, however.
You can think of a singleton object’s name, therefore, as a “name tag” attached to the object:
Defining a singleton object doesn’t define a type (at the Scala level of abstraction)
However, singleton objects extend a superclass and can mix in traits.
Given each singleton object is an instance of its superclasses and.
One difference between classes and singleton objects is that singleton objects cannot take parameters, whereas classes can.
Because you can’t instantiate a singleton object with the new keyword, you have no way to pass parameters to it.
Each singleton object is implemented as an instance of a synthetic class referenced from a static variable, so they have the same initialization semantics as Java statics.4 In particular, a singleton object is initialized the first time some code accesses it.
A singleton object that does not share the same name with a companion class is called a standalone object.
You can use standalone objects for many purposes, including collecting related utility methods together, or defining an entry point to a Scala application.
To run a Scala program, you must supply the name of a standalone singleton object with a main method that takes one parameter, an Array[String], and has a result type of Unit.
Any standalone object with a main method of the proper signature can be used as the entry point into an application.
The name of the synthetic class is the object name plus a dollar sign.
The name of the singleton object in Listing 4.3 is Summer.
Its main method has the proper signature, so you can use it as an application.
This import statement allows you to use the method’s simple name in the rest of the file.5 The body of the main method simply prints out each argument and the checksum for the argument, separated by a colon.
Note Scala implicitly imports members of packages java.lang and scala, as well as the members of a singleton object named Predef, into every Scala source file.
Predef, which resides in package scala, contains many useful methods.
For example, when you say println in a Scala source file, you’re actually invoking println on Predef.
Predef.println turns around and invokes Console.println, which does the real work.
To run the Summer application, place the code from Listing 4.3 into a file named Summer.scala.
In general in the case of non-scripts, however, it is recommended style to name files after the classes they contain as is done in Java, so that programmers can more easily locate classes by looking at file names.
A script, by contrast, must end in a result expression.
One difference in Scala, however, is that you can import members from any object, not just singleton objects.
Instead, you’ll need to actually compile these files with the Scala compiler, then run the resulting class files.
One way to do this is to use scalac, which is the basic Scala compiler, like this:
This compiles your source files, but there may be a perceptible delay before the compilation finishes.
The reason is that every time the compiler starts up, it spends time scanning the contents of jar files and doing other initial work before it even looks at the fresh source files you submit to it.
For this reason, the Scala distribution also includes a Scala compiler daemon called fsc (for fast Scala compiler)
The first time you run fsc, it will create a local server daemon attached to a port on your computer.
It will then send the list of files to compile to the daemon via the port, and the daemon will compile the files.
The next time you run fsc, the daemon will already be running, so fsc will simply send the file list to the daemon, which will immediately compile the files.
Using fsc, you only need to wait for the Java runtime to startup the first time.
If you ever want to stop the fsc daemon, you can do so with fsc -shutdown.
Running either of these scalac or fsc commands will produce Java class files that you can then run via the scala command, the same command you used to invoke the interpreter in previous examples.
However, instead of giving it a filename with a .scala extension containing Scala code to interpret as you did in every previous example,6 in this case you’ll give it the name of a standalone object containing a main method of the proper signature.
You will see checksums printed for the two command line arguments:
The actual mechanism that the scala program uses to “interpret” a Scala source file is that it compiles the Scala source code to Java bytecodes, loads them immediately via a class loader, and executes them.
Although we haven’t yet covered everything you’ll need to understand exactly how this trait works, we figured you’d want to know about it now anyway.
To use the trait, you first write “extends Application” after the name of your singleton object.
Then instead of writing a main method, you place the code you would have put in the main method directly between the curly braces of the singleton object.
You can compile and run this application just like any other.
The way this works is that trait Application declares a main method of the appropriate signature, which your singleton object inherits, making it usable as a Scala application.
The code between the curly braces is collected into a primary constructor of the singleton object, and is executed when the class is initialized.
Don’t worry if you don’t understand what all this means.
It will be explained in later chapters, and in the meantime you can use the trait without fully understanding the details.
Inheriting from Application is shorter than writing an explicit main method, but it also has some shortcomings.
First, you can’t use this trait if you need to access command-line arguments, because the args array isn’t available.
For example, because the Summer application uses command-line arguments, it must be written with an explicit main method, as shown in Listing 4.3
Second, because of some restrictions in the JVM threading model, you need an explicit main method if your program is multi-threaded.
Finally, some implementations of the JVM do not optimize the initialization code of an object which is executed by the Application trait.
So you should inherit from Application only when your program is relatively simple and single-threaded.
This chapter has given you the basics of classes and objects in Scala, and shown you how to compile and run applications.
In the next chapter, you’ll learn about Scala’s basic types and how to use them.
Now that you’ve seen classes and objects in action, it’s a good time to look at Scala’s basic types and operations in more depth.
If you’re familiar with Java, you’ll be glad to find that Java’s basic types and operators have the same meaning in Scala.
However there are some interesting differences that will make this chapter worthwhile reading even if you’re an experienced Java developer.
Because some of the aspects of Scala covered in this chapter are essentially the same in Java, we’ve inserted notes indicating what Java developers can safely skip, to expedite your progress.
You’ll learn the operations you can perform on these types, including how operator precedence works in Scala expressions.
You’ll also learn how implicit conversions can “enrich” variants of these basic types, giving you additional operations beyond those supported by Java.
Several fundamental types of Scala, along with the ranges of values instances of these types may have, are shown in Table 5.1
The integral types plus Float and Double are called numeric types.
However, given that all the members of package scala and java.lang are automatically imported into every Scala source file, you can just use the simple names (i.e., names like Boolean, Char, or String) everywhere.
Savvy Java developers will note that Scala’s basic types have the exact same ranges as the corresponding types in Java.
This enables the Scala compiler to transform instances of Scala value types, such as Int or Double, down to Java primitive types in the bytecodes it produces.
All of the basic types listed in Table 5.1 can be written with literals.
A literal is a way to write a constant value directly in code.
Fast track for Java programmers The syntax of most literals shown in this section are exactly the same as in Java, so if you’re a Java master, you can safely skip much of this section.
Integer literals for the types Int, Long, Short, and Byte come in three forms: decimal, hexadecimal, and octal.
Note that the Scala shell always prints integer values in base 10, no matter what literal form you may have used to initialize it.
Of course, you don’t need to take our word for it.
A good way to start getting a feel for the language is to try these statements out in the interpreter as you read this chapter.
If the number begins with a non-zero digit, and is otherwise undecorated, it is decimal (base 10)
If an integer literal ends in an L or l, it is a Long, otherwise it is an Int.
If an Int literal is assigned to a variable of type Short or Byte, the literal is treated as if it were a Short or Byte type so long as the literal value is within the valid range for that type.
Floating point literals are made up of decimal digits, optionally containing a decimal point, and optionally followed by an E or e and an exponent.
Note that the exponent portion means the power of 10 by which the other portion is multiplied.
If a floating-point literal ends in an F or f, it is a Float, otherwise it is a Double.
Optionally, a Double floating-point literal can end in D or d.
That last value expressed as a Double could take these (and other) forms:
Character literals are composed of any Unicode character between single quotes, such as:
In addition to providing an explicit character between the single quotes, you can provide an octal or hex number for the character code point preceded by a backslash.
For example, the Unicode character code point for the letter A is 101 octal.
A character literal can also be given as a general Unicode character consisting of four hex digits and preceded by a \u, as in:
In fact, such Unicode characters can appear anywhere in a Scala program.
For instance you could also write an identifier like this:
This identifier is treated as identical to BAD, the result of expanding the two Unicode characters in the code above.
In general, it is a bad idea to name identifiers like this, because it is hard to read.
Rather, this syntax is intended to allow Scala source files that include non-ASCII Unicode characters to be represented in ASCII.
Finally, there are also a few character literals represented by special escape sequences, shown in Table 5.2
A string literal is composed of characters surrounded by double quotes:
The syntax of the characters within the quotes is the same as with character literals.
Because this syntax is awkward for strings that contain a lot of escape sequences or strings that span multiple lines, Scala includes a special syntax for raw strings.
The interior of a raw string may contain any characters whatsoever, including newlines, quotation marks, and special characters, except of course three quotes in a row.
For example, the following program prints out a message using a raw string:
Running this code does not produce quite what is desired, however:
The issue is that the leading spaces before the second line are included in the string! To help with this common situation, you can call stripMargin on strings.
To use this method, put a pipe character (|) at the front of each line, and then call stripMargin on the whole string:
A symbol literal is written 'ident, where ident can be any alphanumeric identifier.
Such literals are mapped to instances of the predefined class scala.Symbol.
Specifically, the literal 'cymbal will be expanded by the compiler to a factory method invocation: Symbol("cymbal")
Symbol literals are typically used in situations where you would use just an identifier in a dynamically typed language.
For instance, you might want to define a method that updates a record in a database:
The method takes as parameters a symbol indicating the name of a record field and a value with which the field should be updated in the record.
In a dynamically typed language, you could invoke this operation passing an undeclared field identifier to the method, but in Scala this would not compile:
Instead, and almost as concisely, you can pass a symbol literal:
There is not much you can do with a symbol, except find out its name:
If you write the same symbol literal twice, both expressions will refer to the exact same Symbol object.
Scala provides a rich set of operators for its basic types.
As mentioned in previous chapters, these operators are actually just a nice syntax for ordinary method calls.
In other words, class Int contains a method named + that takes an Int and returns an Int result.
This + method is invoked when you add two Ints:
To prove this to yourself, you can write the expression explicitly as a method invocation:
In fact, Int contains several overloaded + methods that take different parameter types.3 For example, Int has another method, also named +, that takes and returns a Long.
If you add a Long to an Int, this alternate + method will be invoked, as in:
The + symbol is an operator—an infix operator to be specific.
Operator notation is not limited to methods like + that look like operators in other languages.
For example, class String has a method, indexOf, that takes one Char parameter.
The indexOf method searches the string for the first occurrence of the specified character, and returns its index or -1 if it doesn’t find the character.
Overloaded methods have the same name but different argument types.
In addition, String offers an overloaded indexOf method that takes two parameters, the character for which to search and an index at which to start.
The other indexOf method, shown previously, starts at index zero, the beginning of the String.
Even though this indexOf method takes two arguments, you can use it in operator notation.
But whenever you call a method that takes multiple arguments using operator notation, you have to place those arguments in parentheses.
For example, here’s how you use this other indexOf form as an operator (continuing from the previous example):
Any method can be an operator In Scala operators are not special language syntax: any method can be an operator.
What makes a method an operator is how you use it.
But when you write “s indexOf 'o'”, indexOf is an operator, because you’re using it in operator notation.
Scala also has two other operator notations: prefix and postfix.
In postfix notation, you put the method after the object, for example, the “toLong” in “7 toLong”
In contrast to the infix operator notation—in which operators take two operands, one to the left and the other to the right—prefix and postfix operators are unary: they take just one operand.
In prefix notation, the operand is to the right of the operator.
As with the infix operators, these prefix operators are a shorthand way of invoking methods.
In this case, however, the name of the method has “unary_” prepended to the operator character.
You can demonstrate this to yourself by typing the method call both via operator notation and explicitly:
The only identifiers that can be used as prefix operators are +, -, !, and ~
Thus, if you define a method named unary_!, you could invoke that method on a value or variable of the appropriate type using prefix operator notation, such as !p.
Postfix operators are methods that take no arguments, when they are invoked without a dot or parentheses.
In Scala, you can leave off empty parentheses on method calls.
The convention is that you include parentheses if the method has side effects, such as println(), but you can leave them off if the method has no side effects, such as toLowerCase invoked on a String:
In this latter case of a method that requires no arguments, you can alternatively leave off the dot and use postfix operator notation:
In this case, toLowerCase is used as a postfix operator on the operand s.
To see what operators you can use with Scala’s basic types, therefore, all.
Given that this is a Scala tutorial, however, we’ll give you a quick tour of most of these methods in the next few sections.
There is an extremely slight chance your program with the *p might compile as C++
Fast track for Java programmers Many aspects of Scala described in the remainder of this chapter are the same as in Java.
You can invoke arithmetic methods via infix operator notation for addition (+), subtraction (-), multiplication (*), division (/), and remainder (%), on any numeric type.
When both the left and right operands are integral types (Int, Long, Byte, Short, or Char), the / operator will tell you the whole number portion of the quotient, excluding any remainder.
The % operator indicates the remainder of an implied integer division.
The floating-point remainder you get with % is not the one defined by the IEEE 754 standard.
The IEEE 754 remainder uses rounding division, not truncating division, in calculating the remainder, so it is quite different from.
If you really want an IEEE 754 remainder, you can call IEEEremainder on scala.math, as in:
If you don’t specify a unary + or -, a literal number is interpreted as positive.
Unary + exists solely for symmetry with unary -, but has no effect.
The unary - can also be used to negate a variable.
The logical-and and logical-or operations are short-circuited as in Java: expressions built from these operators are only evaluated as far as needed to determine the result.
In other words, the right-hand side of logical-and and logical-or expressions won’t be evaluated if the left-hand side determines the result.
For example, if the left-hand side of a logical-and expression evaluates to false, the result of the expression will definitely be false, so the right-hand side is not evaluated.
Likewise, if the left-hand side of a logical-or expression evaluates to true, the result of the expression will definitely be true, so the right-hand side is not evaluated.
In the first expression, pepper and salt are invoked, but in the second, only salt is invoked.
Given salt returns false, there’s no need to call pepper.
Note You may be wondering how short-circuiting can work given operators are just methods.
Normally, all arguments are evaluated before entering a method, so how can a method avoid evaluating its second argument? The answer is that all Scala methods have a facility for delaying the evaluation of their arguments, or even declining to evaluate them at all.
The facility is called by-name parameters and is discussed in Section 9.5
The shift methods, when used in infix operator notation, shift the integer value on the left of the operator by the amount specified by the integer value on the right.
Shift left and unsigned shift right fill with zeroes as they shift.
Shift right fills with the highest bit (the sign bit) of the left-hand value as it shifts.
If you want to compare two objects for equality, you can use either ==, or its inverse !=
The leftmost bit in an integer type is the sign bit.
If the leftmost bit is 1, the number is negative.
These operations actually apply to all objects, not just basic types.
Going further, you can compare two objects that have different types:
You can even compare against null, or against things that might be null.
As you see, == has been carefully crafted so that you get just the equality comparison you want in most cases.
This is accomplished with a very simple rule: first check the left side for null, and if it is not null, call the equals method.
Since equals is a method, the precise comparison you get depends on the type of the left-hand argument.
Since there is an automatic null check, you do not have to do the check yourself.7
The automatic check does not look at the right-hand side, but any reasonable equals method should return false if its argument is null.
This kind of comparison will yield true on different objects, so long as their contents are the same and their equals method is written to be based on contents.
For example, here is a comparison between two strings that happen to have the same five letters in them:
How Scala’s == differs from Java’s In Java, you can use == to compare both primitive and reference types.
On primitive types, Java’s == compares value equality, as in Scala.
On reference types, however, Java’s == compares reference equality, which means the two variables point to the same object on the JVM’s heap.
Scala provides a facility for comparing reference equality, as well, under the name eq.
However, eq and its opposite, ne, only apply to objects that directly map to Java objects.
Also, see Chapter 30 on how to write a good equals method.
Operator precedence determines which parts of an expression are evaluated before the other parts.
Thus the multiplication part of the expression is evaluated before the addition part.
You can of course use parentheses in expressions to clarify evaluation order or to override precedence.
For example, if you really wanted the result of the expression above to be 28, you could write the expression like this:
Given that Scala doesn’t have operators, per se, just a way to use methods in operator notation, you may be wondering how operator precedence works.
Scala decides precedence based on the first character of the methods used in operator notation (there’s one exception to this rule, which will be discussed below)
If the method name starts with a *, for example, it will.
Table 5.3 shows the precedence given to the first character of a method in decreasing order of precedence, with characters on the same line having the same precedence.
The higher a character is in this table, the higher the precedence of methods that start with that character.
Since the first characters are the same as in the previous example, the methods will be invoked in the same order.
First the + method will be invoked, then the << method.
The one exception to the precedence rule, alluded to above, concerns assignment operators, which end in an equals character.
That is, it is lower than the precedence of any other operator.
When multiple operators of the same precedence appear side by side in an expression, the associativity of the operators determines the way operators are grouped.
The associativity of an operator in Scala is determined by its last character.
Methods that end in any other character are the other way around.
They are invoked on their left operand, passing in the right operand.
No matter what associativity an operator has, however, its operands are always evaluated left to right.
So if a is an expression that is not just a simple reference to an immutable value, then a ::: b is more precisely treated as the following block:
In this block a is still evaluated before b, and then the result of this evaluation is passed as an operand to b’s ::: method.
This associativity rule also plays a role when multiple operators of the same precedence appear side by side.
If the methods end in ‘:’, they are grouped right to left; otherwise, they are grouped left to right.
You can invoke many more methods on Scala’s basic types than were described in the previous sections.
All you need to know for now is that for each basic type described in this chapter, there is also a “rich wrapper” that provides several additional methods.
To see all the available methods on the basic types, therefore, you should look at the API documentation on the rich wrapper for each basic type.
The main take-aways from this chapter are that operators in Scala are method calls, and that implicit conversions to rich variants exist for Scala’s basic types that add even more useful methods.
In the next chapter, we’ll show you what it means to design objects in a functional style that gives new implementations of some of the operators that you have seen in this chapter.
With the understanding of Scala basics you gained in previous chapters, you’re ready to see how to design more full-featured classes in Scala.
The emphasis in this chapter is on classes that define functional objects, that is, objects that do not have any mutable state.
As a running example, we’ll create several variants of a class that models rational numbers as immutable objects.
Along the way, we’ll show you more aspects of object-oriented programming in Scala: class parameters and constructors, methods and operators, private members, overriding, checking preconditions, overloading, and self references.
A rational number is a number that can be expressed as a ratio nd , where n and d are integers, except that d cannot be zero.
Compared to floating-point numbers, rational numbers have the advantage that fractions are represented exactly, without rounding or approximation.
The class we’ll design in this chapter must model the behavior of rational numbers, including allowing them to be added, subtracted, multiplied, and divided.
To add two rationals, you must first obtain a common denominator, then add the two numerators.
You divide by swapping the numerator and denominator of the right operand and then multiplying.
One, maybe rather trivial, observation is that in mathematics, rational numbers do not have mutable state.
You can add one rational number to another, but the result will be a new rational number.
The original numbers will not have “changed.” The immutable Rational class we’ll design in this chapter will have the same property.
Each rational number will be represented by one Rational object.
When you add two Rational objects, you’ll create a new Rational object to hold the sum.
This chapter will give you a glimpse of some of the ways Scala enables you to write libraries that feel like native language support.
For example, at the end of this chapter you’ll be able to do this with class Rational:
A good place to start designing class Rational is to consider how client programmers will create a new Rational object.
Given we’ve decided to make Rational objects immutable, we’ll require that clients provide all data needed by an instance (in this case, a numerator and a denominator) when they construct the instance.
One of the first things to note about this line of code is that if a class doesn’t have a body, you don’t need to specify empty curly braces (though you could, of course, if you wanted to)
The identifiers n and d in the parentheses after the class name, Rational, are called class parameters.
The Scala compiler will gather up these two class parameters and create a primary constructor that takes the same two parameters.
Immutable object trade-offs Immutable objects offer several advantages over mutable objects, and one potential disadvantage.
First, immutable objects are often easier to reason about than mutable ones, because they do not have complex state spaces that change over time.
Second, you can pass immutable objects around quite freely, whereas you may need to make defensive copies of mutable objects before passing them to other code.
Third, there is no way for two threads concurrently accessing an immutable to corrupt its state once it has been properly constructed, because no thread can change the state of an immutable.
If a mutable object is mutated after it is placed into a HashSet, for example, that object may not be found the next time you look into the HashSet.
The main disadvantage of immutable objects is that they sometimes require that a large object graph be copied where otherwise an update could be done in place.
In some cases this can be awkward to express and might also cause a performance bottleneck.
As a result, it is not uncommon for libraries to provide mutable alternatives to immutable classes.
For example, class StringBuilder is a mutable alternative to the immutable String.
In Java, classes have constructors, which can take parameters, whereas in Scala, classes can take parameters directly.
The Scala notation is more concise—class parameters can be used directly in the body of the class; there’s no need to define fields and write assignments that copy constructor parameters into fields.
This can yield substantial savings in boilerplate code, especially for small classes.
The Scala compiler will compile any code you place in the class body, which isn’t part of a field or a method definition, into the primary constructor.
For example, you could print a debug message like this:
Given this code, the Scala compiler would place the call to println into Rational’s primary constructor.
The println call will, therefore, print its debug message whenever you create a new Rational instance:
When we created an instance of Rational in the previous example, the interpreter printed “Rational@90110a”
The interpreter obtained this somewhat funny looking string by calling toString on the Rational object.
The result of toString is primarily intended to help programmers by providing information that can be used in debug print statements, log messages, test failure reports, and interpreter and debugger output.
The result currently provided by toString is not especially helpful, because it doesn’t give any clue about the rational number’s value.
A more useful implementation of toString would print out the values of the Rational’s numerator and denominator.
You can override the default implementation by adding a method toString to class Rational, like this:
Since Rational numbers will display nicely now, we removed the debug println statement we put into the body of previous version of class Rational.
You can test the new behavior of Rational in the interpreter:
As a next step, we will turn our attention to a problem with the current behavior of the primary constructor.
As mentioned at the beginning of this chapter, rational numbers may not have a zero in the denominator.
Currently, however, the primary constructor accepts a zero passed as d:
One of the benefits of object-oriented programming is that it allows you to encapsulate data inside objects so that you can ensure the data is valid throughout its lifetime.
In the case of an immutable object such as Rational, this means that you should ensure the data is valid when the object is constructed.
Given that a zero denominator is an invalid state for a Rational number, you should not let a Rational be constructed if a zero is passed in the d parameter.
The best way to approach this problem is to define as a precondition of the primary constructor that d must be non-zero.
A precondition is a constraint on values passed into a method or constructor, a requirement which callers must fulfill.
One way to do that is to use require,1 like this:
If the passed value is true, require will return normally.
Now that the primary constructor is properly enforcing its precondition, we will turn our attention to supporting addition.
To do so, we’ll define a public add method on class Rational that takes another Rational as a parameter.
To keep Rational immutable, the add method must not add the passed.
As mentioned in Section 4.4, Predef’s members are imported automatically into every Scala source file.
Rather, it must create and return a new Rational that holds the sum.
Although class parameters n and d are in scope in the code of your add method, you can only access their value on the object on which add was invoked.
Thus, when you say n or d in add’s implementation, the compiler is happy to provide you with the values for these class parameters.
But it won’t let you say that.n or that.d, because that does not refer to the Rational object on which add was invoked.2 To access the numerator and denominator on that, you’ll need to make them into fields.
Actually, you could add a Rational to itself, in which case that would refer to the object on which add was invoked.
But because you can pass any Rational object to add, the compiler still won’t let you say that.n.
In Section 10.6 you’ll find out about parametric fields, which provide a shorthand for writing the same code.
Even though n and d are used in the body of the class, given they are only used inside constructors, the Scala compiler will not emit fields for them.
Thus, given this code the Scala compiler will generate a class with two Int fields, one for numer and one for denom.
One other thing you can do now that you couldn’t do before is access the numerator and denominator values from outside the object.
Simply access the public numer and denom fields, like this:
The keyword this refers to the object instance on which the currently executing method was invoked, or if used in a constructor, the object instance.
As an example, consider adding a method, lessThan, which tests whether the given Rational is smaller than a parameter:
Here, this.numer refers to the numerator of the object on which lessThan was invoked.
You can also leave off the this prefix and write just numer; the two notations are equivalent.
As an example where you can’t do without this, consider adding a max method to class Rational that returns the greater of the given rational number and an argument:
You could have equally well left it off and written: lessThan(that)
But the second this represents the result of the method in the case where the test returns false; were you to omit it, there would be nothing left to return!
In Scala, constructors other than the primary constructor are called auxiliary constructors.
For example, a rational number with a denominator of 1 can be written more succinctly as simply the numerator.
The body of Rational’s auxiliary constructor merely invokes the primary constructor, passing along its lone argument, n, as the numerator and 1 as the denominator.
You can see the auxiliary constructor in action by typing the following into the interpreter:
In Scala, every auxiliary constructor must invoke another constructor of the same class as its first action.
The invoked constructor is either the primary constructor (as in the Rational example), or another auxiliary constructor that comes textually before the calling constructor.
The net effect of this rule is that every constructor invocation in Scala will end up eventually calling the primary constructor of the class.
The primary constructor is thus the single point of entry of a class.
Note If you’re familiar with Java, you may wonder why Scala’s rules for constructors are a bit more restrictive than Java’s.
In Java, a constructor must either invoke another constructor of the same class, or directly invoke a constructor of the superclass, as its first action.
In a Scala class, only the primary constructor can invoke a superclass constructor.
The increased restriction in Scala is really a design trade-off that needed to be paid in exchange for the greater conciseness and simplicity of Scala’s constructors compared to Java’s.
In the previous version of Rational, we simply initialized numer with n and denom with d.
As a result, the numerator and denominator of a Rational can be larger than needed.
To normalize in this way, you need to divide the numerator and denominator by their greatest common divisor.
In this version of Rational, we added a private field, g, and modified the initializers for numer and denom.
Because g is private, it can be accessed inside the body of the class, but not outside.
We also added a private method, gcd, which calculates the greatest common divisor of two passed Ints.
As you saw in Section 4.1, to make a field or method private you simply place the private keyword in front of its definition.
The purpose of the private “helper method” gcd is to factor out code needed by some other part of the class, in this case, the primary constructor.
To ensure g is always positive, we pass the absolute value of n and d, which we obtain by invoking abs on them, a method you can invoke on any Int to get its absolute value.
The Scala compiler will place the code for the initializers of Rational’s three fields into the primary constructor in the order in which they appear in the source code.
Thus, g’s initializer, gcd(n.abs, d.abs), will execute before the other two, because it appears first in the source.
Field g will be initialized with the result, the greatest common divisor of the absolute value of the class parameters, n and d.
Field g is then used in the initializers of numer and denom.
By dividing n and d by their greatest common divisor, g, every Rational will be constructed in its normalized form:
The current implementation of Rational addition is OK, but could be made more convenient to use.
In a mathematical sense they are even more natural than, say, floating-point numbers.
Why should you not use the natural arithmetic operators on them? In Scala you can do this.
In the rest of this chapter, we’ll show you how.
The first step is to replace add by the usual mathematical symbol.
This is straightforward, as + is a legal identifier in Scala.
We can simply define a method with + as its name.
While we’re at it, you may as well implement a method named * that performs multiplication.
With class Rational defined in this manner, you can now write:
As always, the operator syntax on the last input line is equivalent to a method call.
In other words, expressions involving + and * operations on Rationals will behave as expected.
You have now seen the two most important ways to form an identifier in Scala: alphanumeric and operator.
Besides the two forms you have seen there are also two others.
All four forms of identifier formation are described in this section.
An alphanumeric identifier starts with a letter or underscore, which can be followed by further letters, digits, or underscores.
The ‘$’ character also counts as a letter, however it is reserved for identifiers generated by the Scala compiler.
Identifiers in user programs should not contain ‘$’ characters, even though it will compile; if they do this might lead to name clashes with identifiers generated by the Scala compiler.
Scala follows Java’s convention of using camel-case5 identifiers, such as toString and HashSet.
Camel-case names of fields, method parameters, local variables, and functions should start with lower case letter, for example: length, flatMap, and s.
The compiler will think you are trying to declare a val named “name_:”
One way in which Scala’s conventions depart from Java’s involves constant names.
In Scala, the word constant does not just mean val.
Even though a val does remain constant after it is initialized, it is still a variable.
For example, method parameters are vals, but each time the method is called those vals can hold different values.
For example, scala.math.Pi is defined to be the double value closest to the real value of pi , the ratio of a circle’s circumference to its diameter.
This value is unlikely to change ever, thus, Pi is clearly a constant.
You can also use constants to give names to values that would otherwise be magic numbers in your code: literal values with no explanation, which in the worst case appear in multiple places.
You may also want to define constants for use in pattern matching, a use case that will be described in Section 15.2
In Java, the convention is to give constants names that are all upper case, with underscores separating the words, such as MAX_VALUE or PI.
In Scala, the convention is merely that the first character should be upper case.
Thus, constants named in the Java style, such as X_OFFSET, will work as Scala constants, but the Scala convention is to use camel case for constants, such as XOffset.
An operator identifier consists of one or more operator characters.
In Section 16.5, you’ll see that sometimes you may want to give a special kind of class known as a case class a name consisting solely of operator characters.
For example, the Scala API contains a class named ::, which facilitates pattern matching on Lists.
The Scala compiler will internally “mangle” operator identifiers to turn them into legal Java identifiers with embedded $ characters.
If you ever wanted to access this identifier from Java code, you’d need to use this internal representation.
Because operator identifiers in Scala can become arbitrarily long, there is a small difference between Java and Scala.
If you want the first interpretation, you need to separate the < and the - characters by a space.
This is unlikely to be a problem in practice, as very few people would write x<-y in Java without inserting spaces or parentheses between the operators.
A mixed identifier consists of an alphanumeric identifier, which is followed by an underscore and an operator identifier.
For example, unary_+ used as a method name defines a unary + operator.
Or, myvar_= used as method name defines an assignment operator.
The idea is that you can put any string that’s accepted by the runtime as an identifier between back ticks.
This works even if the name contained in the back ticks would be a Scala reserved word.
A typical use case is accessing the static yield method in Java’s Thread class.
You cannot write Thread.yield() because yield is a reserved word in Scala.
However, you can still name the method in back ticks, e.g., Thread.`yield`()
With the latest changes, you can now do addition and multiplication operations in a natural style on rational numbers.
For instance, you cannot multiply a rational number by an integer, because the operands of * always have to be Rationals.
To make Rational even more convenient, we’ll add new methods to the class that perform mixed addition and multiplication on rational numbers and integers.
While we’re at it, we’ll add methods for subtraction and division too.
There are now two versions each of the arithmetic methods: one that takes a rational as its argument and another that takes an integer.
In other words, each of these method names is overloaded, because each name is now being used by multiple methods.
For example, the name + is used by one method that takes a Rational and another that takes an Int.
In a method call, the compiler picks the version of an overloaded method that correctly matches the types of the arguments.
For instance, if the argument y in x.+(y) is a Rational, the compiler will pick the method + that takes a Rational parameter.
But if the argument is an integer, the compiler will pick the method + that takes an Int parameter instead.
You’ll see that the * method invoked is determined in each case by the type of the right operand.
Note Scala’s process of overloaded method resolution is very similar to Java’s.
In every case, the chosen overloaded version is the one that best matches the static types of the arguments.
Sometimes there is no unique best matching version; in that case the compiler will give you an “ambiguous reference” error.
But the Int class contains no multiplication method that takes a Rational argument—it couldn’t because class Rational is not a standard class in the Scala library.
However, there is another way to solve this problem in Scala: You can create an implicit conversion that automatically converts integers to rational numbers when needed.
The implicit modifier in front of the method tells the compiler to apply it automatically in a number of situations.
With the conversion defined, you can now retry the example that failed before:
Note that for an implicit conversion to work, it needs to be in scope.
If you place the implicit method definition inside class Rational, it won’t be in scope in the interpreter.
For now, you’ll need to define it directly in the interpreter.
As you can glimpse from this example, implicit conversions are a very powerful technique for making libraries more flexible and more convenient to use.
Because they are so powerful, they can also be easily misused.
As this chapter has demonstrated, creating methods with operator names and defining implicit conversions can help you design libraries for which client code is concise and easy to understand.
Scala gives you a great deal of power to design such easy-to-use libraries, but please bear in mind that with power comes responsibility.
If used unartfully, both operator methods and implicit conversions can give rise to client code that is hard to read and understand.
Because implicit conversions are applied implicitly by the compiler, not explicitly written down in the source code, it can be non-obvious to client programmers what implicit conversions are being applied.
And although operator methods will usually make client code more concise, they will only make it more readable to the extent client programmers will be able to recognize and remember the meaning of each operator.
The goal you should keep in mind as you design libraries is not merely enabling concise client code, but readable, understandable client code.
Conciseness will often be a big part of that readability, but you can take conciseness too far.
By designing libraries that enable tastefully concise and at the same time understandable client code, you can help those client programmers work productively.
In this chapter, you saw more aspects of classes in Scala.
You saw how to add parameters to a class, define several constructors, define operators as methods, and customize classes so that they are natural to use.
Maybe most importantly, you saw that defining and using immutable objects is a quite natural way to code in Scala.
In Chapter 21, you’ll learn how to place implicit method definitions in a companion object for Rational, so they can be more easily placed into scope when client programmers are working with Rationals.
The only control structures are if, while, for, try, match, and function calls.
The reason Scala has so few is that it has included function literals since its inception.
Instead of accumulating one higher-level control structure after another in the base syntax, Scala accumulates them in libraries.
This chapter will show those few control structures that are built in.
One thing you will notice is that almost all of Scala’s control structures result in some value.
This is the approach taken by functional languages, in which programs are viewed as computing a value, thus the components of a program should also compute values.
You can also view this approach as the logical conclusion of a trend already present in imperative languages.
In imperative languages, function calls can return a value, even though having the called function update an output variable passed as an argument would work just as well.
In addition, imperative languages often have a ternary operator (such as the ?: operator of C, C++, and Java), which behaves exactly like if, but results in a value.
Scala adopts this ternary operator model, but calls it if.
In other words, Scala’s if can result in a value.
Scala then continues this trend by having for, try, and match also result in values.
Programmers can use these result values to simplify their code, just as they use return values of functions.
Without this facility, the programmer must create temporary variables just to hold results that are calculated inside a control structure.
Removing these temporary variables makes the code a little simpler, and it also prevents many bugs where you set the variable in one branch but forget to set it in another.
Overall, Scala’s basic control structures, minimal as they are, are sufficient to provide all of the essentials from imperative languages.
Further, they allow you to shorten your code by consistently having result values.
To show you how all of this works, this chapter takes a closer look at each of Scala’s basic control structures.
It tests a condition and then executes one of two code branches depending on whether the condition holds true.
Here is a common example, written in an imperative style:
This code declares a variable, filename, and initializes it to a default value.
It then uses an if expression to check whether any arguments were supplied to the program.
If so, it changes the variable to hold the value specified in the argument list.
If no arguments were supplied, it leaves the variable set to the default value.
Listing 7.1 shows how you can accomplish the same effect as the previous example, but without using any vars:
If args is not empty, the initial element, args(0), is chosen.
The if expression results in the chosen value, and the filename variable is initialized with that value.
This code is slightly shorter, but its real advantage is that it uses a val instead of a var.
Using a val is the functional style, and it helps you in much the same way as a final variable in Java.
A second advantage to using a val instead of a var is that it better supports equational reasoning.
The introduced variable is equal to the expression that computes it, assuming that expression has no side effects.
Thus, any time you are about to write the variable name, you could instead write the expression.
Instead of println(filename), for example, you could just as well write this:
Using vals helps you safely make this kind of refactoring as your code evolves over time.
They can make your code both easier to read and easier to refactor.
It has a condition and a body, and the body is executed over and over as long as the condition holds true.
This works like the while loop except that it tests the condition after the loop body instead of before.
Listing 7.3 shows a Scala script that uses a do-while to echo lines read from the standard input, until an empty line is entered:
The while and do-while constructs are called “loops,” not expressions, because they don’t result in an interesting value.
It turns out that a value (and in fact, only one value) exists whose type is Unit.
It is called the unit value and is written ()
The existence of () is how Scala’s Unit differs from Java’s void.
Because no equals sign precedes its body, greet is defined to be a procedure with a result type of Unit.
This is confirmed in the next line: comparing the greet’s result for equality with the unit value, (), yields true.
One other construct that results in the unit value, which is relevant here, is reassignment to vars.
For example, were you to attempt to read lines in Scala using the following while loop idiom from Java (and C and C++), you’ll run into trouble:
When you compile this code, Scala will give you a warning that comparing values of type Unit and String using != will always yield true.
Whereas in Java, assignment results in the value assigned, in this case a line from the standard input, in Scala assignment always results in the unit value, ()
Thus, the value of the assignment “line = readLine()” will always be () and never be ""
As a result, this while loop’s condition will never be false, and the loop will, therefore, never terminate.
Because the while loop results in no value, it is often left out of pure functional languages.
Scala includes the while loop nonetheless, because sometimes an imperative solution can be more readable, especially to programmers with a predominantly imperative background.
For example, if you want to code an algorithm that repeats a process until some condition changes, a while loop can express it directly while the functional alternative, which likely uses recursion, may be less obvious to some readers of the code.
The difference between these two approaches is that gcdLoop is written in an imperative style, using vars and and a while loop, whereas gcd is written in a more functional style that involves recursion (gcd calls itself) and requires no vars.
In general, we recommend you challenge while loops in your code in the same way you challenge vars.
In fact, while loops and vars often go hand in hand.
Because while loops don’t result in a value, to make any kind of difference to your program, a while loop will usually either need to update vars or perform I/O.
You can see this in action in the gcdLoop example shown previously.
As that while loop does its business, it updates vars a and b.
Thus, we suggest you be a bit suspicious of while loops in your code.
The main difference is that instead of Ints the gcd of Listing 7.4 works with Longs.
If there isn’t a good justification for a particular while or do-while loop, try to find a way to do the same thing without it.
Scala’s for expression is a Swiss army knife of iteration.
It lets you combine a few simple ingredients in different ways to express a wide variety of iterations.
Simple uses enable common tasks such as iterating through a sequence of integers.
More advanced expressions can iterate over multiple collections of different kinds, can filter out elements based on arbitrary conditions, and can produce new collections.
The simplest thing you can do with for is to iterate through all the elements of a collection.
For example, Listing 7.5 shows some code that prints out all files in the current directory.
First, we create a java.io.File on the current directory, ".", and call its listFiles method.
This method returns an array of File objects, one per directory and file contained in the current directory.
With the “file <- filesHere” syntax, which is called a generator, we iterate through the elements of filesHere.
In each iteration, a new val named file is initialized with an element value.
The compiler infers the type of file to be File, because filesHere is an Array[File]
For each iteration, the body of the for expression, println(file), will be executed.
Because File’s toString method yields the name of the file or directory, the names of all the files and directories in the current directory will be printed.
The for expression syntax works for any kind of collection, not just arrays.2 One convenient special case is the Range type, which you briefly.
If you don’t want to include the upper bound of the range in the values that are iterated over, use until instead of to:
Iterating through integers like this is common in Scala, but not nearly as much as in other languages.
In other languages, you might use this facility to iterate through an array, like this:
For each setting of i, the i’th element of filesHere is extracted and processed.
The reason this kind of iteration is less common in Scala is that you can just as well iterate over the collection directly.
If you do, your code becomes shorter and you sidestep many of the off-by-one errors that can arise when iterating through arrays.
Sometimes you do not want to iterate through a collection in its entirety.
You can do this with a for expression by adding a filter: an if clause inside the for’s parentheses.
For example, the code shown in Listing 7.6 lists only those files in the current directory whose names end with “.scala”:
You could alternatively accomplish the same goal with this code:
This code yields the same output as the previous code, and likely looks more familiar to programmers with an imperative background.
The imperative form, however, is only an option because this particular for expression is executed for its printing side-effects and results in the unit value ()
As will be demonstrated later in this section, the for expression is called an “expression” because it can result in an interesting value, a collection whose type is determined by the for expression’s <- clauses.
For example, to be extra defensive, the code in Listing 7.7 prints only files and not directories.
It does so by adding a filter that checks the file’s isFile method.
The outer loop iterates through filesHere, and the inner loop iterates through fileLines(file) for any file that ends with .scala.
If you prefer, you can use curly braces instead of parentheses to surround the generators and filters.
One advantage to using curly braces is that you can leave off some of the semicolons that are needed when you use parentheses, because as explained in Section 4.2, the Scala compiler will not infer semicolons while inside parentheses.
This is a non-trivial computation, so you might want to only compute it once.
You can do this by binding the result to a new variable using an equals sign (=)
The bound variable is introduced and used just like a val, only with the val keyword left out.
In Listing 7.9, a variable named trimmed is introduced halfway through the for expression.
The rest of the for expression then uses the new variable in two places, once in an if and once in println.
While all of the examples so far have operated on the iterated values and then forgotten them, you can also generate a value to remember for each iteration.
To do so, you prefix the body of the for expression by the keyword yield.
For example, here is a function that identifies the .scala files and stores them in an array:
Each time the body of the for expression executes it produces one value, in this case simply file.
When the for expression completes, the result will include all of the yielded values contained in a single collection.
The type of the resulting collection is based on the kind of collections processed in the iteration clauses.
In this case the result is an Array[File], because filesHere is an array and the type of the yielded expression is File.
Be careful, by the way, where you place the yield keyword.
For example, the for expression shown in Listing 7.10 first transforms the Array[File] named filesHere, which contains all files in the current directory, to one that contains only .scala files.
For each of these it generates an Iterator[String] (the result of the fileLines method, whose definition is shown in Listing 7.8)
An Iterator offers methods next and hasNext that allow you to iterate over a collection of elements.
This initial iterator is transformed into another Iterator[String] containing only trimmed lines that include the substring "for"
Finally, for each of these, an integer length is yielded.
The result of this for expression is an Array[Int] containing those lengths.
At this point, you have seen all the major features of Scala’s for expression.
Instead of returning a value in the normal way, a method can terminate by throwing an exception.
The exception propagates in this way, unwinding the call stack, until a method handles it or there are no more methods left.
You create an exception object and then you throw it with the throw keyword:
Although it may seem somewhat paradoxical, in Scala, throw is an expression that has a result type.
Here is an example in which that result type matters:
What happens here is that if n is even, half will be initialized to half of n.
If n is not even, an exception will be thrown before half can be initialized to anything at all.
Because of this, it is safe to treat a thrown exception as any kind of value whatsoever.
Any context that tries to use the return from a throw will never get to do so, and thus no harm will come.
You can use a throw as an expression even though it will never actually evaluate to anything.
This little bit of technical gymnastics might sound weird, but is frequently useful in cases like the previous example.
One branch of an if computes a value, while the other throws an exception and computes Nothing.
The type of the whole if expression is then the type of that branch which does compute something.
You catch exceptions using the syntax shown in Listing 7.11 The syntax for catch clauses was chosen for its consistency with an important part of Scala: pattern matching.
The behavior of this try-catch expression is the same as in other languages with exceptions.
The body is executed, and if it throws an exception, each catch clause is tried in turn.
If it is of type IOException, the second clause will execute.
If the exception is of neither type, the try-catch will terminate and the exception will propagate further.
Note One difference from Java that you’ll quickly notice in Scala is that unlike Java, Scala does not require you to catch checked exceptions, or declare them in a throws clause.
You can declare a throws clause if you wish with the @throws annotation, but it is not required.
You can wrap an expression with a finally clause if you want to cause some code to execute no matter how the expression terminates.
For example, you might want to be sure an open file gets closed even if a method exits by throwing an exception.
Note Listing 7.12 shows the idiomatic way to ensure a non-memory resource, such as a file, socket, or database connection is closed.
Then you start a try block in which you use the resource.
This idiom is the same in Scala as in Java, however, in Scala you can alternatively employ a technique called the loan pattern to achieve the same goal more concisely.
As with most other Scala control structures, try-catch-finally results in a value.
For example, Listing 7.13 shows how you can try to parse a URL but use a default value if the URL is badly formed.
The result is that of the try clause if no exception is thrown, or the relevant catch clause if an exception is thrown and caught.
If an exception is thrown but not caught, the expression has no result at all.
The value computed in the finally clause, if there is one, is dropped.
Usually finally clauses do some kind of clean up such as closing a file; they should not normally change the value computed in the main body or a catch clause of the try.
If you’re familiar with Java, it’s worth noting that Scala’s behavior differs from Java only because Java’s try-finally does not result in a value.
As in Java, if a finally clause includes an explicit return statement, or throws an exception, that return value or exception will “overrule” any previous one that originated in the try block or one of its catch clauses.
Both of these functions exhibit behavior that could surprise most programmers, thus it’s usually best to avoid returning values from finally clauses.
The best way to think of finally clauses is as a way to ensure some side effect happens, such as closing an open file.
Scala’s match expression lets you select from a number of alternatives, just like switch statements in other languages.
For now, just consider using match to select among a number of alternatives.
As an example, the script in Listing 7.14 reads a food name from the argument list and prints a companion to that food.
This match expression examines firstArg, which has been set to the first argument out of the argument list.
If it is the string "salt", it prints "pepper", while if it is the string "chips", it prints "salsa", and so on.
The default case is specified with an underscore (_), a wildcard symbol frequently used in Scala as a placeholder for a completely unknown value.
There are a few important differences from Java’s switch statement.
One is that any kind of constant, as well as other things, can be used in.
Another difference is that there are no breaks at the end of each alternative.
Instead the break is implicit, and there is no fall through from one alternative to the next.
The common case—not falling through—becomes shorter, and a source of errors is avoided because programmers can no longer fall through by accident.
The most significant difference from Java’s switch, however, may be that match expressions result in a value.
In the previous example, each alternative in the match expression prints out a value.
It would work just as well to yield the value rather than printing it, as shown in Listing 7.15
The value that results from this match expression is stored in the friend variable.
Aside from the code getting shorter (in number of tokens, anyway), the code now disentangles two separate concerns: first it chooses a food, and then it prints it.
You may have noticed that there has been no mention of break or continue.
Scala leaves out these commands because they do not mesh well with function literals, a feature described in the next chapter.
It is clear what continue means inside a while loop, but what would it mean inside a function literal? While Scala supports both imperative and functional styles of programming, in this case it leans slightly towards functional programming in exchange for simplifying the language.
There are many ways to program without break and continue, and if you take advantage of function literals, those alternatives can often be shorter than the original code.
The simplest approach is to replace every continue by an if and every break by a boolean variable.
The boolean variable indicates whether the enclosing while loop should continue.
For example, suppose you are searching through an argument list for a string that ends with “.scala” but does not start with a hyphen.
In Java you could—if you were quite fond of while loops, break, and continue—write the following:
To transliterate this Java code directly to Scala, instead of doing an if and then a continue, you could write an if that surrounds the entire remainder of the while loop.
To get rid of the break, you would normally add a boolean variable indicating whether to keep going, but in this case you can reuse foundIt.
Using both of these tricks, the code ends up looking as shown in Listing 7.16
This Scala code in Listing 7.16 is quite similar to the original Java code.
All the basic pieces are still there and in the same order.
Inside the loop, there is a test that i is less than args.length, a check for "-", and a check for ".scala"
If you wanted to get rid of the vars in Listing 7.16, one approach you could try is to rewrite the loop as a recursive function.
You could, for example, define a searchFrom function that takes an integer as an input, searches forward from there, and then returns the index of the desired argument.
Using this technique the code would look as shown in Listing 7.17:
The version in Listing 7.17 gives a human-meaningful name to what the function does, and it uses recursion to substitute for looping.
Each continue is replaced by a recursive call with i + 1 as the argument, effectively skipping to the next integer.
Many people find this style of programming easier to understand, once they get used to the recursion.
Note The Scala compiler will not actually emit a recursive function for the code shown in Listing 7.17
Because all of the recursive calls are in tail-call position, the compiler will generate code similar to a while loop.
Each recursive call will be implemented as a jump back to the beginning of the function.
If after all this discussion you still feel the need to use break, there’s help in Scala’s standard library.
Here an example how this library-supplied break method could be applied:
This will repeatedly read non-empty lines from the standard input.
Once the user enters an empty line, control flow exits from the enclosing breakable, and with it the while loop.
The Breaks class implements break by throwing an exception that is caught by an enclosing application of the breakable method.
Therefore, the call to break does not need to be in the same method as the call to breakable.
Now that you’ve seen Scala’s built-in control structures, we’ll use them in this section to explain how scoping works in Scala.
Fast track for Java programmers If you’re a Java programmer, you’ll find that Scala’s scoping rules are almost identical to Java’s.
One difference between Java and Scala exists, however, in that Scala allows you to define variables of the same name in nested scopes.
If you’re a Java programmer, therefore, you may wish to at least skim this section.
Variable declarations in Scala programs have a scope that defines where you can use the name.
You can then use the name i for the remainder of the function.
You can use i here because it is still in scope.
Because the variable j was defined inside the open curly brace of the while loop, it can be used only within that while loop.
If you were to attempt to do something with j after the closing curly brace of this while loop, after the comment that says j, prod, and k are out of scope, your program would not compile.
All variables defined in this example—i, j, prod, and k—are local variables.
Such variables are “local” to the function in which they are defined.
Each time a function is invoked, a new set of its local variables is used.
There are a few exceptions to this rule, because in Scala you can sometimes use curly braces in place of parentheses.
One example of this kind of curly-brace use is the alternative for expression syntax described in Section 7.3
The printMultiTable function shown in Listing 7.18 is written in an imperative style.
We’ll refactor it into a functional style in the next section.
Once a variable is defined, you can’t define a new variable with the same name in the same scope.
For example, the following script with two variables named a in the same scope would not compile:
You can, on the other hand, define a variable in an inner scope that has the same name as a variable in an outer scope.
In a Scala program, an inner variable is said to shadow a like-named outer variable, because the outer variable becomes invisible in the inner scope.
You might have already noticed something that looks like shadowing in the interpreter:
In the interpreter, you can reuse variable names to your heart’s content.
Among other things, this allows you to change your mind if you made a mistake when you defined a variable the first time in the interpreter.
The reason you can do this is that, conceptually, the interpreter creates a new nested scope for each new statement you type in.
Thus, you could visualize the previous interpreted code like this:
Keep in mind that such code can be very confusing to readers, because variable names adopt new meanings in nested scopes.
It is usually better to choose a new, meaningful variable name rather than to shadow an outer variable.
To help you gain insight into the functional style, in this section we’ll refactor the imperative approach to printing a multiplication table shown in Listing 7.18
The imperative style reveals itself in Listing 7.18 in two ways.
First, invoking printMultiTable has a side effect: printing a multiplication table to the standard output.
In Listing 7.19, we refactored the function so that it returns the multiplication table as a string.
Since the function no longer prints, we renamed it multiTable.
As mentioned previously, one advantage of side-effect-free functions is they are easier to unit test.
To test printMultiTable, you would need to somehow redefine print and println so you could check the output for correctness.
You could test multiTable more easily, by checking its string result.
The other telltale sign of the imperative style in printMultiTable is its while loop and vars.
By contrast, the multiTable function uses vals, for expressions, helper functions, and calls to mkString.
Returns table as a string with one row per line.
We factored out the two helper functions, makeRow and makeRowSeq, to make the code easier to read.
The body of this for calculates the product of row and column, determines the padding needed for the product, and yields the result of concatenating the padding and product strings.
The result of the for expression will be a sequence (some subclass of scala.Seq) containing these yielded strings as elements.
The other helper function, makeRow, simply invokes mkString on the result returned by makeRowSeq.
This string is yielded, thus the result of this for expression will be a sequence of row strings.
The only remaining task is to convert the sequence of strings into a single string.
The call to mkString accomplishes this, and because we pass "\n", we get an end of line character inserted between each string.
Scala’s built-in control structures are minimal, but they do the job.
They act much like their imperative equivalents, but because they tend to result in a value, they support a functional style, too.
Just as important, they are careful in what they omit, thus leaving room for one of Scala’s most powerful features, the function literal, which will be described in the next chapter.
When programs get larger, you need some way to divide them into smaller, more manageable pieces.
For dividing up control flow, Scala offers an approach familiar to all experienced programmers: divide the code into functions.
In fact, Scala offers several ways to define functions that are not present in Java.
Besides methods, which are functions that are members of some object, there are also functions nested within functions, function literals, and function values.
This chapter takes you on a tour through all of these flavors of functions in Scala.
The most common way to define a function is as a member of some object.
As an example, Listing 8.1 shows two methods that together read a file with a given name and print out all lines whose length exceeds a given width.
Every printed line is prefixed with the name of the file it appears in.
The processFile method takes a filename and width as parameters.
It creates a Source object from the file name and, in the generator of the for expression, calls getLines on the source.
The for expression processes each of these lines by calling the helper method, processLine.
The processLine method takes three parameters: a filename, a width, and a line.
It tests whether the length of the line is greater than the given width, and, if so, it prints the filename, a colon, and the line.
To use LongLines from the command line, we’ll create an application that expects the line width as the first command-line argument, and interprets subsequent arguments as filenames:1
Here’s how you’d use this application to find the lines in LongLines.scala that are over 45 characters in length (there’s just one):
In this book, we usually won’t check command-line arguments for validity in example applications, both to save trees and reduce boilerplate code that can obscure the example’s important code.
The trade-off is that instead of producing a helpful error message when given bad input, our example applications will throw an exception.
So far, this is very similar to what you would do in any object-oriented language.
However, the concept of a function in Scala is more general than a method.
Scala’s other ways to express functions will be explained in the following sections.
The construction of the processFile method in the previous section demonstrated an important design principle of the functional programming style: programs should be decomposed into many small functions that each do a well-defined task.
The advantage of this style is that it gives a programmer many building blocks that can be flexibly composed to do more difficult things.
Each building block should be simple enough to be understood individually.
One problem with this approach is that all the helper function names can pollute the program namespace.
In the interpreter this is not so much of a problem, but once functions are packaged in reusable classes and objects, it’s desirable to hide the helper functions from clients of a class.
They often do not make sense individually, and you often want to keep enough flexibility to delete the helper functions if you later rewrite the class a different way.
In Java, your main tool for this purpose is the private method.
This private-method approach works in Scala as well, as is demonstrated in Listing 8.1, but Scala offers an additional approach: you can define functions inside other functions.
Just like local variables, such local functions are visible only in their enclosing block.
In this example, we refactored the original LongLines version, shown in Listing 8.1, by transforming private method, processLine, into a local function of processFile.
To do so we removed the private modifier, which can only be applied (and is only needed) for methods, and placed the definition of processLine inside the definition of processFile.
As a local function, processLine is in scope inside processFile, but inaccessible outside.
Now that processLine is defined inside processFile, however, another improvement becomes possible.
Notice how filename and width are passed unchanged into the helper function? This is not necessary, because local functions can access the parameters of their enclosing function.
You can just use the parameters of the outer processLine function, as shown in Listing 8.2:
Simpler, isn’t it? This use of an enclosing function’s parameters is a common and useful example of the general nesting Scala provides.
The nesting and scoping described in Section 7.7 applies to all Scala constructs, including functions.
It’s a simple principle, but very powerful, especially in a language with first-class functions.
Not only can you define functions and call them, but you can write down functions as unnamed literals and then pass them around as values.
A function literal is compiled into a class that when instantiated at runtime is a function value.2 Thus the distinction between function literals and values is that function literals exist in the source code, whereas function values exist as objects at runtime.
The distinction is much like that between classes (source code) and objects (runtime)
Here is a simple example of a function literal that adds one to a number:
Function values are objects, so you can store them in variables if you like.
They are functions, too, so you can invoke them using the usual parentheses function-call notation.
Because increase, in this example, is a var, you can reassign it a different function value later on.
Each FunctionN trait has an apply method used to invoke the function.
If you want to have more than one statement in the function literal, surround its body by curly braces and put one statement per line, thus forming a block.
Just like a method, when the function value is invoked, all of the statements will be executed, and the value returned from the function is whatever the expression on the last line generates.
So now you have seen the nuts and bolts of function literals and function values.
For example, a foreach method is available for all collections.3 It takes a function as an argument and invokes that function on each of its elements.
Here is how it can be used to print out all of the elements of a list:
As another example, collection types also have a filter method.
This method selects those elements of a collection that pass a test the user sup3A foreach method is defined in trait Traversable, a common supertrait of List, Set, Array, and Map.
This function maps positive integers to true and all others to false.
Methods like foreach and filter are described further later in the book.
Scala provides a number of ways to leave out redundant information and write function literals more briefly.
Keep your eyes open for these opportunities, because they allow you to remove clutter from your code.
One way to make a function literal more brief is to leave off the parameter types.
Thus, the previous example with filter could be written like this:
The Scala compiler knows that x must be an integer, because it sees that you are immediately using the function to filter a list of integers (referred to by someNumbers)
The precise details of target typing are not important to study.
You can simply start by writing a function literal without the argument type, and, if the compiler gets confused, add in the type.
Over time you’ll get a feel for which situations the compiler can and cannot puzzle out.
A second way to remove useless characters is to leave out parentheses around a parameter whose type is inferred.
In the previous example, the parentheses around x are unnecessary:
To make a function literal even more concise, you can use underscores as placeholders for one or more parameters, so long as each parameter appears only one time within the function literal.
You can think of the underscore as a “blank” in the expression that needs to be “filled in.” This blank will be filled in with an argument to the function each time the function is invoked.
Sometimes when you use underscores as placeholders for parameters, the compiler might not have enough information to infer missing parameter types.
In such cases, you can specify the types using a colon, like this:
This is why you can use this short form only if each parameter appears.
Multiple underscores mean multiple parameters, not reuse of a single parameter repeatedly.
The first underscore represents the first parameter, the second underscore the second parameter, the third underscore the third parameter, and so on.
Although the previous examples substitute underscores in place of individual parameters, you can also replace an entire parameter list with an underscore.
Scala treats this short form exactly as if you had written the following:
Thus, the underscore in this case is not a placeholder for a single parameter.
Remember that you need to leave a space between the function name and the underscore, because otherwise the compiler will think you are referring to a different symbol, such as for example, a method named println_, which likely does not exist.
When you use an underscore in this way, you are writing a partially applied function.
In Scala, when you invoke a function, passing in any needed arguments, you apply that function to the arguments.
A partially applied function is an expression in which you don’t supply all of the arguments needed by the function.
Instead, you supply some, or none, of the needed arguments.
For example, to create a partially applied function expression involving sum, in which you supply none of the three required.
The resulting function can then be stored in a variable.
Given this code, the Scala compiler instantiates a function value that takes the three integer parameters missing from the partially applied function expression, sum _, and assigns a reference to that new function value to the variable a.
When you apply three arguments to this new function value, it will turn around and invoke sum, passing in those same three arguments:
Here’s what just happened: The variable named a refers to a function value object.
This function value is an instance of a class generated automatically by the Scala compiler from sum _, the partially applied function expression.
This apply method, defined in the class generated automatically by the Scala compiler from the expression sum _, simply forwards those three missing parameters to sum, and returns the result.
Another way to think about this kind of expression, in which an underscore is used to represent an entire parameter list, is as a way to transform a def into a function value.
For example, if you have a local function, such as sum(a: Int, b: Int, c: Int): Int, you can “wrap” it in a function value whose apply method has the same parameter list and result types.
When you apply this function value to some arguments, it in turn applies sum to.
The generated class extends trait Function3, which declares a three-arg apply method.
Although you can’t assign a method or nested function to a variable, or pass it as an argument to another function, you can do these things if you wrap the method or nested function in a function value by placing an underscore after its name.
Now, although sum _ is indeed a partially applied function, it may not be obvious to you why it is called this.
It has this name because you are not applying that function to all of its arguments.
In the case of sum _, you are applying it to none of its arguments.
But you can also express a partially applied function by supplying some but not all of the required arguments.
In this case, you’ve supplied the first and last argument to sum, but the middle argument is missing.
Since only one argument is missing, the Scala compiler generates a new function class whose apply method takes one argument.
If you are writing a partially applied function expression in which you.
For example, instead of printing out each of the numbers in someNumbers (defined on page 189) like this:
This last form is allowed only in places where a function is required, such as the invocation of foreach in this example.
The compiler knows a function is required in this case, because foreach requires that a function be passed as an argument.
In situations where a function is not required, attempting to use this form will cause a compilation error.
So far in this chapter, all the examples of function literals have referred only to passed parameters.
This function adds “more” to its argument, but what is more? From the point of view of this function, more is a free variable, because the function literal does not itself give a meaning to it.
The x variable, by contrast, is a bound variable, because it does have a meaning in the context of the function: it is defined as the function’s lone parameter, an Int.
If you try using this function literal by itself, without any more defined in its scope, the compiler will complain:
Why the trailing underscore? Scala’s syntax for partially applied functions highlights a difference in the design trade-offs of Scala and classical functional languages such as Haskell or ML.
In these languages, partially applied functions are considered the normal case.
Furthermore, these languages have a fairly strict static type system that will usually highlight every error with partial applications that you can make.
Scala bears a much closer relation to imperative languages such as Java, where a method that’s not applied to all its arguments is considered an error.
Furthermore, the object-oriented tradition of subtyping and a universal root type accepts some programs that would be considered erroneous in classical functional languages.
For instance, say you mistook the drop(n: Int) method of List for tail(), and you therefore forgot you need to pass a number to drop.
Had Scala adopted the classical functional tradition that partially applied functions are OK everywhere, this code would type check.
However, you might be surprised to find out that the output printed by this println statement would always be <function>! What would have happened is that the expression drop would have been treated as a function object.
Because println takes objects of any type, this would have compiled OK, but it would have given an unexpected result.
To avoid situations like this, Scala normally requires you to specify function arguments that are left out explicitly, even if the indication is as simple as a ‘_’
Scala allows you to leave off even the _ only when a function type is expected.
On the other hand, the same function literal will work fine so long as there is something available named more:
The function value (the object) that’s created at runtime from this function literal is called a closure.
The name arises from the act of “closing” the function literal by “capturing” the bindings of its free variables.
But any function literal with free variables, such as (x: Int) => x + more, is an open term.
Therefore, any function value created at runtime from (x: Int) => x + more will by definition require that a binding for its free variable, more, be captured.
The resulting function value, which will contain a reference to the captured more variable, is called a closure, therefore, because the function value is the end product of the act of closing the open term, (x: Int) => x + more.
This example brings up a question: what happens if more changes after the closure is created? In Scala, the answer is that the closure sees the change.
Changes made by a closure to a captured variable are visible outside the closure.
By contrast, Java’s inner classes do not allow you to access modifiable variables in surrounding scopes at all, so there is no difference between capturing a variable and capturing its currently held value.
This example uses a roundabout way to sum the numbers in a List.
Variable sum is in a surrounding scope from the function literal sum += _, which adds numbers to sum.
Even though it is the closure modifying sum at runtime, the resulting total, -11, is still visible outside the closure.
What if a closure accesses some variable that has several different copies as the program runs? For example, what if a closure uses a local variable of some function, and the function is invoked many times? Which instance of that variable gets used at each access?
Only one answer is consistent with the rest of the language: the instance used is the one that was active at the time the closure was created.
For example, here is a function that creates and returns “increase” closures:
Each time this function is called it will create a new closure.
Each closure will access the more variable that was active when the closure was created.
When you apply these closures to arguments (in this case, there’s just one argument, x, which must be passed in), the result that comes back depends on how more was defined when the closure was created:
It makes no difference that the more in this case is a parameter to a method call that has already returned.
The Scala compiler rearranges things in cases like this so that the captured parameter lives out on the heap, instead of the.
This rearrangement is all taken care of automatically, so you don’t have to worry about it.
Most functions and function calls you encounter will be as you have seen so far in this chapter.
The function will have a fixed number of parameters, the call will have an equal number of arguments, and the arguments will be specified in the same order and number as the parameters.
Since function calls are so central to programming in Scala, however, a few special forms of function definitions and function calls have been added to the language to address some special needs.
Scala allows you to indicate that the last parameter to a function may be repeated.
This allows clients to pass variable length argument lists to the function.
To denote a repeated parameter, place an asterisk after the type of the parameter.
Defined this way, echo can be called with zero to many String arguments:
Inside the function, the type of the repeated parameter is an Array of the declared type of the parameter.
Thus, the type of args inside the echo function, which is declared as type “String*” is actually Array[String]
Nevertheless, if you have an array of the appropriate type, and you attempt to pass it as a repeated parameter, you’ll get a compiler error:
To accomplish this, you’ll need to append the array argument with a colon and an _* symbol, like this:
This notation tells the compiler to pass each element of arr as its own argument to echo, rather than all of it as a single argument.
In a normal function call, the arguments in the call are matched one by one in the order of the parameters of the called function:
Named arguments allow you to pass arguments to a function in a different order.
The syntax is simply that each argument is preceded by a parameter name and an equals sign.
For example, the following call to speed is equivalent to speed(100,10):
Called with named arguments, the arguments can be reversed without changing the meaning:
It is also possible to mix positional and named arguments.
Named arguments are most frequently used in combination with default parameter values.
The argument for such a parameter can optionally be omitted from a function call, in which case the corresponding argument will be filled in with the default.
Function printTime has one parameter, out, and it has a default value of Console.out.
If you call the function as printTime(), thus specifying no argument to be used for out, then out will be set to its default value of Console.out.
You could also call the function with an explicit output stream.
Default parameters are especially helpful when used in combination with named parameters.
Using named arguments, however, either one of the parameters can be specified while leaving the other as the default.
In Section 7.2, we mentioned that to transform a while loop that updates vars into a more functional style that uses only vals, you may sometimes need to use recursion.
Here’s an example of a recursive function that approximates a value by repeatedly improving a guess until it is good enough:
A function like this is often used in search problems, with appropriate implementations for isGoodEnough and improve.
If you want the approximate function to run faster, you might be tempted to write it with a while loop to try and speed it up, like this:
Which of the two versions of approximate is preferable? In terms of brevity and var avoidance, the first, functional one wins.
But is the imperative approach perhaps more efficient? In fact, if we measure execution times it turns.
However, in the case of approximate above, the Scala compiler is able to apply an important optimization.
Note that the recursive call is the last thing that happens in the evaluation of function approximate’s body.
Functions like approximate, which call themselves as their last action, are called tail recursive.
The Scala compiler detects tail recursion and replaces it with a jump back to the beginning of the function, after updating the function parameters with the new values.
The moral is that you should not shy away from using recursive algorithms to solve your problem.
Often, a recursive solution is more elegant and concise than a loop-based one.
If the solution is tail recursive, there won’t be any runtime overhead to be paid.
A tail-recursive function will not build a new stack frame for each call; all calls will execute in a single frame.
This may surprise a programmer inspecting a stack trace of a program that failed.
For example, this function calls itself some number of times then throws an exception:
This function is not tail recursive, because it performs an increment operation after the recursive call.
If you now modify boom so that it does become tail recursive:
The compiled code for approximate is essentially the same as the compiled code for approximateLoop.
Both functions compile down to the same thirteen instructions of Java bytecodes.
If you look through the bytecodes generated by the Scala compiler for the tail recursive method, approximate, you’ll see that although both isGoodEnough and improve are invoked in the body of the method, approximate is not.
This time, you see only a single stack frame for bang.
You might think that bang crashed before it called itself, but this is not the case.
If you think you might be confused by tail-call optimizations when looking at a stack trace, you can turn them off by giving the following argument to the scala shell or to the scalac compiler:
With that option specified, you will get a longer stack trace:
The use of tail recursion in Scala is fairly limited, because the JVM instruction set makes implementing more advanced forms of tail recursion very difficult.
Scala only optimizes directly recursive calls back to the same function making the call.
If the recursion is indirect, as in the following example of two mutually recursive functions, no optimization is possible:
You also won’t get a tail-call optimization if the final call goes to a function value.
The funValue variable refers to a function value that essentially wraps a call to nestedFun.
When you apply the function value to an argument, it turns around and applies nestedFun to that same argument, and returns the result.
You might hope, therefore, the Scala compiler would perform a tail-call optimization, but in this case it would not.
Thus, tail-call optimization is limited to situations in which a method or nested function calls itself directly as its last operation, without going through a function value or some other intermediary.
This chapter has given you a grand tour of functions in Scala.
In addition to methods, Scala provides local functions, function literals, and function values.
In addition to normal function calls, Scala provides partially applied functions and functions with repeated parameters.
When possible, function calls are implemented as optimized tail calls, and thus many nice-looking recursive functions run just as quickly as hand-optimized versions that use while loops.
The next chapter will build on these foundations and show how Scala’s rich support for functions helps you abstract over control.
In Chapter 7, we pointed out that Scala doesn’t have many built-in control abstractions, because it gives you the ability to create your own.
In this chapter, we’ll show you how to apply function values to create new control abstractions.
Along the way, you’ll also learn about currying and by-name parameters.
All functions are separated into common parts, which are the same in every invocation of the function, and non-common parts, which may vary from one function invocation to the next.
The common parts are in the body of the function, while the non-common parts must be supplied via arguments.
When you use a function value as an argument, the non-common part of the algorithm is itself some other algorithm! At each invocation of such a function, you can pass in a different function value as an argument, and the invoked function will, at times of its choosing, invoke the passed function value.
One benefit of higher-order functions is they enable you to create control abstractions that allow you to reduce code duplication.
For example, suppose you are writing a file browser, and you want to provide an API that allows users to search for files matching some criterion.
First, you add a facility to search for files whose names end in a particular string.
This would enable your users to find, for example, all files with a “.scala” extension.
You could provide such an API by defining a public filesEnding method inside.
The filesEnding method obtains the list of all files in the current directory using the private helper method filesHere, then filters them based on whether each file name ends with the user-specified query.
Given filesHere is private, the filesEnding method is the only accessible method defined in FileMatcher, the API you provide to your users.
So far so good, and there is no repeated code yet.
Later on, though, you decide to let people search based on any part of the file name.
You go back to work and add this function to your FileMatcher API:
It searches filesHere, checks the name, and returns the file if the name matches.
The only difference is that this function uses contains instead of endsWith.
The months go by, and the program becomes more successful.
Eventually, you give in to the requests of a few power users who want to search based on regular expressions.
These sloppy guys have immense directories with thousands of files, and they would like to do things like find all “pdf” files that have “oopsla” in the title somewhere.
Experienced programmers will notice all of this repetition and wonder if it can be factored into a common helper function.
You would like to be able to do the following:
This approach would work in some dynamic languages, but Scala does not allow pasting together code at runtime like this.
While you cannot pass around a method name as a value, you can get the same effect by passing around a function value that calls the method for you.
In this case, you could add a matcher parameter to the method whose sole purpose is to check a file name against a query:
In this version of the method, the if clause now uses matcher to check the file name against the query.
Precisely what this check does depends on what is specified as the matcher.
Take a look, now, at the type of matcher itself.
It is a function, and thus has a => in the type.
This function takes two string arguments—the file name and the query—and returns a boolean, so the type of this function is (String, String) => Boolean.
Given this new filesMatching helper method, you can simplify the three searching methods by having them call the helper method, passing in an appropriate function:
The function literals shown in this example use the placeholder syntax, introduced in the previous chapter, which may not as yet feel very natural to you.
Thus, here’s a clarification of how placeholders are used in this example.
The function literal _.endsWith(_), used in the filesEnding method, means the same thing as:
Because filesMatching takes a function that requires two String arguments, however, you need not specify the types of the arguments.
Since the parameters are each used only once in the body of the function, and since the first parameter, fileName, is used first in the body, and the second parameter, query, is used second, you can use the placeholder syntax: _.endsWith(_)
The first underscore is a placeholder for the first parameter, the file name, and the second underscore a placeholder for the second parameter, the query string.
This code is already simplified, but it can actually be even shorter.
Notice that the query gets passed to filesMatching, but filesMatching does nothing with the query except to pass it back to the passed matcher function.
This passing back and forth is unnecessary, because the caller already knew the query to begin with! You might as well simply remove the query parameter from filesMatching and matcher, thus simplifying the code as shown in Listing 9.1
This example demonstrates the way in which first-class functions can help you eliminate code duplication where it would be very difficult to do so without them.
In Java, for example, you could create an interface containing a method that takes one String and returns a Boolean, then create and pass anonymous inner class instances that implement this interface to filesMatching.
Although this approach would remove the code duplication you are trying to eliminate, it would at the same time add as much or more new code.
Thus the benefit is not worth the cost, and you may as well live with the duplication.
Moreover, this example demonstrates how closures can help you reduce code duplication.
Both variables used in the expression, _.endsWith(_), for example, are represented by underscores, which means they are taken from arguments.
Thus, _.endsWith(_) uses two bound variables, and no free variables.
It is only because Scala supports closures that you were able to remove the query parameter from filesMatching in the most recent example, thereby simplifying the code even further.
The previous example demonstrated that higher-order functions can help reduce code duplication as you implement an API.
Another important use of higher-order functions is to put them in an API itself to make client code more concise.
These special-purpose looping methods are defined in trait Traversable, which is extended by List, Set, and Map.
Consider exists, a method that determines whether a passed value is contained in a collection.
You could of course search for an element by having a var initialized to false, looping through the collection checking each item, and setting the var to true if you find what you are looking for.
Here’s a method that uses this approach to determine whether a passed List contains a negative number:
If you define this method in the interpreter, you can call it like this:
A more concise way to define the method, though, is by calling the higherorder function exists on the passed List, like this:
This version of containsNeg yields the same results as the previous:
It is a special-purpose looping construct provided by the Scala library rather than being built into the Scala language like while or for.
In the previous section, the higherorder function, filesMatching, reduces code duplication in the implementation of the object FileMatcher.
The exists method provides a similar benefit, but because exists is public in Scala’s collections API, the code.
If exists didn’t exist, and you wanted to write a containsOdd method, to test whether a list contains odd numbers, you might write it like this:
If you compare the body of containsNeg with that of containsOdd, you’ll find that everything is repeated except the test condition of an if expression.
The body of the code in this version is again identical to the body of the corresponding containsNeg method (the version that uses exists), except the condition for which to search is different.
Yet the amount of code duplication is much smaller because all of the looping infrastructure is factored out into the exists method itself.
There are many other looping methods in Scala’s standard library.
As with exists, they can often shorten your code if you recognize opportunities to use them.
In Chapter 1, we said that Scala allows you to create new control abstractions that “feel like native language support.” Although the examples you’ve seen so far are indeed control abstractions, it is unlikely anyone would mistake them for native language support.
To understand how to make control abstractions that feel more like language extensions, you first need to understand the functional programming technique called currying.
A curried function is applied to multiple argument lists, instead of just one.
Listing 9.2 shows a regular, non-curried function, which adds two Int parameters, x and y.
By contrast, Listing 9.3 shows a similar function that’s curried.
Instead of one list of two Int parameters, you apply this function to two lists of one Int parameter each.
What’s happening here is that when you invoke curriedSum, you actually get two traditional function invocations back to back.
The first function invocation takes a single Int parameter named x, and returns a function value for the second function.
Here’s a function named first that does in spirit what the first traditional function invocation of curriedSum would do:
These first and second functions are just an illustration of the currying process.
Nevertheless, there is a way to get an actual reference to curriedSum’s “second” function.
You can use the placeholder notation to use curriedSum in a partially applied function expression, like this:
And here’s how you’d get a function that adds two to its sole Int argument:
In languages with first-class functions, you can effectively make new control structures even though the syntax of the language is fixed.
All you need to do is create methods that take functions as arguments.
For example, here is the “twice” control structure, which repeats an operation two times and returns the result:
In the previous chapter, when the placeholder notation was used on traditional methods, like println _, you had to leave a space between the name and the underscore.
The type of op in this example is Double => Double, which means it is a function that takes one Double as an argument and returns another Double.
Any time you find a control pattern repeated in multiple parts of your code, you should think about implementing it as a new control structure.
Earlier in the chapter you saw filesMatching, a very specialized control pattern.
Consider now a more widely used coding pattern: open a resource, operate on it, and then close the resource.
You can capture this in a control abstraction using a method like the following:
Given such a method, you can use it like this:
The advantage of using this method is that it’s withPrintWriter, not user code, that assures the file is closed at the end.
For instance, withPrintWriter in the previous example loans a PrintWriter to the function, op.
When the function completes, it signals that it no longer needs the “borrowed” resource.
The resource is then closed in a finally block, to ensure it is indeed closed, regardless of whether the function completes by returning normally or throwing an exception.
One way in which you can make the client code look a bit more like a built-in control structure is to use curly braces instead of parentheses to surround the argument list.
In any method invocation in Scala in which you’re passing in exactly one argument, you can opt to use curly braces to surround the argument instead of parentheses.
In the second example, you used curly braces instead of parentheses to surround the arguments to println.
This curly braces technique will work, however, only if you’re passing in one argument.
Because you are attempting to pass in two arguments to substring, you get an error when you try to surround those arguments with curly braces.
The purpose of this ability to substitute curly braces for parentheses for passing in one argument is to enable client programmers to write function literals between curly braces.
This can make a method call feel more like a control abstraction.
In its most recent form, withPrintWriter takes two arguments, so you can’t use curly braces.
Nevertheless, because the function passed to withPrintWriter is the last argument in the list, you can use currying to pull the first argument, the File, into a separate argument list.
This will leave the function as the lone parameter of the second argument list.
The new version differs from the old one only in that there are now two parameter lists with one parameter each instead of one parameter list with.
In the previous version of withPrintWriter, shown on page 216, you see.
Given the above definition, you can call the method with a more pleasing syntax:
In this example, the first argument list, which contains one File argument, is written surrounded by parentheses.
The second argument list, which contains one function argument, is surrounded by curly braces.
The withPrintWriter method shown in the previous section differs from built-in control structures of the language, such as if and while, in that the code between the curly braces takes an argument.
What if you want to implement something more like if or while, however, where there is no value to pass into the code between the curly braces? To help with such situations, Scala provides by-name parameters.
As a concrete example, suppose you want to implement an assertion construct called myAssert.3 The myAssert function will take a function value as input and consult a flag to decide what to do.
If the flag is set, myAssert will invoke the passed function and verify that it returns true.
If the flag is turned off, myAssert will quietly do nothing at all.
Without using by-name parameters, you could write myAssert like this:
The definition is fine, but using it is a little bit awkward:
You would really prefer to leave out the empty parameter list and => symbol in the function literal and write the code like this:
By-name parameters exist precisely so that you can do this.
Now you can leave out the empty parameter in the property you want to assert.
The result is that using byNameAssert looks exactly like using a built-in control structure:
You’ll call this myAssert, not assert, because Scala provides an assert of its own, which will be described in Section 14.1
A by-name type, in which the empty parameter list, (), is left out, is only allowed for parameters.
There is no such thing as a by-name variable or a by-name field.
Now, you may be wondering why you couldn’t simply write myAssert using a plain old Boolean for the type of its parameter, like this:
This formulation is also legal, of course, and the code using this version of boolAssert would still look exactly as before:
Nevertheless, one difference exists between these two approaches that is important to note.
The difference between the two approaches, therefore, is that if assertions are disabled, you’ll see any side effects that the expression inside the parentheses may have in boolAssert, but not in byNameAssert.
But attempting to assert on the same code in byNameAssert’s case will not yield an exception:
This chapter has shown you how to build on Scala’s rich function support to build control abstractions.
You can use functions within your code to factor out common control patterns, and you can take advantage of higherorder functions in the Scala library to reuse control patterns that are common across all programmers’ code.
This chapter has also shown how to use currying and by-name parameters so that your own higher-order functions can be used with a concise syntax.
In the previous chapter and this one, you have seen quite a lot of information about functions.
The next few chapters will go back to discussing more object-oriented features of the language.
This chapter will pick up where Chapter 6 left off and dive with much greater detail into Scala’s support for object-oriented programming.
We’ll compare two fundamental relationships between classes: composition and inheritance.
Composition means one class holds a reference to another, using the referenced class to help it fulfill its mission.
In addition to these topics, we’ll discuss abstract classes, parameterless methods, extending classes, overriding methods and fields, parametric fields, invoking superclass constructors, polymorphism and dynamic binding, final members and classes, and factory objects and methods.
As a running example in this chapter, we’ll create a library for building and rendering two-dimensional layout elements.
For convenience, the library will provide factory methods named “elem” that construct new elements from passed data.
For example, you’ll be able to create a layout element containing a string using a factory method with the following signature:
As you can see, elements will be modeled with a type named Element.
You’ll be able to call above or beside on an element, passing in a second element, to get a new element that combines the two.
Layout elements are a good example of a system in which objects can be constructed from simple parts with the aid of composing operators.
In this chapter, we’ll define classes that enable element objects to be constructed from arrays, lines, and rectangles—the simple parts.
Such composing operators are also often called combinators because they combine elements of some domain into new elements.
Thinking in terms of combinators is generally a good way to approach library design: it pays to think about the fundamental ways to construct objects in an application domain.
What are the simple objects? In what ways can more interesting objects be constructed out of simpler ones? How do combinators hang together? What are the most general combinations? Do they satisfy any interesting laws? If you have good answers to these questions, your library design is on track.
Our first task is to define type Element, which represents layout elements.
Since elements are two dimensional rectangles of characters, it makes sense to include a member, contents, that refers to the contents of a layout element.
The contents can be represented as an array of strings, where each string represents a line.
Hence, the type of the result returned by contents will be Array[String]
In this class, contents is declared as a method that has no implementation.
In other words, the method is an abstract member of class Element.
A class with abstract members must itself be declared abstract, which is done by writing an abstract modifier in front of the class keyword:
The abstract modifier signifies that the class may have abstract members that do not have an implementation.
If you try to do so, you’ll get a compiler error:
Later in this chapter you’ll see how to create subclasses of class Element, which you’ll be able to instantiate because they fill in the missing definition for contents.
Note that the contents method in class Element does not carry an abstract modifier.
A method is abstract if it does not have an implementation (i.e., no equals sign or body)
Unlike Java, no abstract modifier is necessary (or allowed) on method declarations.
Class Element declares the abstract method contents, but currently defines no concrete methods.
In the next section, however, we’ll enhance Element by defining some concrete methods.
As a next step, we’ll add methods to Element that reveal its width and height, as shown in Listing 10.2
The height method returns the number of lines in contents.
The width method returns the length of the first line, or, if there are no lines in the element, zero.
This means you cannot define an element with a height of zero and a non-zero width.
Note that none of Element’s three methods has a parameter list, not even an empty one.
By contrast, methods defined with empty parentheses, such as def height(): Int, are called empty-paren methods.
The recommended convention is to use a parameterless method whenever there are no parameters and the method accesses mutable state only by reading fields of the containing object (in particular, it does not change mutable state)
This convention supports the uniform access principle,1 which says that client code should not be affected by a decision to implement an attribute as a field or method.
For instance, we could have chosen to implement width and height as fields instead of methods, simply by changing the def in each definition to a val:
The two pairs of definitions are completely equivalent from a client’s point of view.
The only difference is that field accesses might be slightly faster than method invocations, because the field values are pre-computed when the.
On the other hand, the fields require extra memory space in each Element object.
So it depends on the usage profile of a class whether an attribute is better represented as a field or method, and that usage profile might change over time.
The point is that clients of the Element class should not be affected when its internal implementation changes.
In particular, a client of class Element should not need to be rewritten if a field of that class gets changed into an access function so long as the access function is pure, i.e., it does not have any side effects and does not depend on mutable state.
But there’s still a slight complication that has to do with the way Java handles things.
The problem is that Java does not implement the uniform access principle.
So it’s string.length() in Java, not string.length (even though it’s array.length, not array.length())
To bridge that gap, Scala is very liberal when it comes to mixing parameterless and empty-paren methods.
In particular, you can override a parameterless method with an empty-paren method, and vice versa.
You can also leave off the empty parentheses on an invocation of any function that takes no arguments.
For instance, the following two lines are both legal in Scala:
In principle it’s possible to leave out all empty parentheses in Scala function calls.
However, it is recommended to still write the empty parentheses when the invoked method represents more than a property of its receiver object.
For instance, empty parentheses are appropriate if the method performs I/O, or writes reassignable variables (vars), or reads vars other than the receiver’s fields, either directly or indirectly by using mutable objects.
That way, the parameter list acts as a visual clue that some interesting computation is triggered by the call.
To summarize, it is encouraged style in Scala to define methods that take no parameters and have no side effects as parameterless methods, i.e., leaving off the empty parentheses.
So your clients might be surprised to see the side effects.
Similarly, whenever you invoke a function that has side effects, be sure to include the empty parentheses when you write the invocation.
Another way to think about this is if the function you’re calling performs an operation, use the parentheses, but if it merely provides access to a property, leave the parentheses off.
We still need to be able to create new element objects.
You have already seen that “new Element” cannot be used for this because class Element is abstract.
To instantiate an element, therefore, we will need to create a subclass that extends Element and implements the abstract contents method.
Just like in Java, you use an extends clause after the class name to express this:
Such an extends clause has two effects: it makes class ArrayElement inherit all non-private members from class Element, and it makes the type ArrayElement a subtype of the type Element.
Given ArrayElement extends Element, class ArrayElement is called a subclass of class Element.
Second, a member of a superclass is not inherited if a member with the same name and parameters is already implemented in the subclass.
In that case we say the member of the subclass overrides the member of the superclass.
If the member in the subclass is concrete and the member of the superclass is abstract, we also say that the concrete member implements the abstract one.
For example, the contents method in ArrayElement overrides (or, alternatively: implements) abstract method contents in class Element.2 By contrast, class ArrayElement inherits the width and height methods from class Element.
For example, given an ArrayElement ae, you can query its width using ae.width, as if width were defined in class ArrayElement:
One flaw with this design is that because the returned array is mutable, clients could change it.
For the book we’ll keep things simple, but were ArrayElement part of a real project, you might consider returning a defensive copy of the array instead.
Another problem is we aren’t currently ensuring that every String element of the contents array has the same length.
This could be solved by checking the precondition in the primary constructor, and throwing an exception if it is violated.
Subtyping means that a value of the subclass can be used wherever a value of the superclass is required.
Variable e is defined to be of type Element, so its initializing value should also be an Element.
This is OK, because class ArrayElement extends class Element, and as a result, the type ArrayElement is compatible with the type Element.3
Figure 10.1 also shows the composition relationship that exists between ArrayElement and Array[String]
This relationship is called composition because class ArrayElement is “composed” out of class Array[String], in that the Scala compiler will place into the binary class it generates for ArrayElement a field that holds a reference to the passed conts array.
We’ll discuss some design considerations concerning composition and inheritance later in this chapter, in Section 10.11
The uniform access principle is just one aspect where Scala treats fields and methods more uniformly than Java.
Another difference is that in Scala, fields and methods belong to the same namespace.
This makes it possible for a field to override a parameterless method.
For instance, you could change the implementation of contents in class ArrayElement from a method to a field without having to modify the abstract method definition of contents in class Element, as shown in Listing 10.4:
Field contents (defined with a val) in this version of ArrayElement is a perfectly good implementation of the parameterless method contents (declared with a def) in class Element.
For more perspective on the difference between subclass and subtype, see the glossary entry for subtype.
On the other hand, in Scala it is forbidden to define a field and method with the same name in the same class, whereas it is allowed in Java.
Generally, Scala has just two namespaces for definitions in place of Java’s four.
The reason Scala places fields and methods into the same namespace is precisely so you can override a parameterless method with a val, something you can’t do with Java.4
Consider again the definition of class ArrayElement shown in the previous section.
It has a parameter conts whose sole purpose is to be copied into the contents field.
The name conts of the parameter was chosen just so that.
The reason that packages share the same namespace as fields and methods in Scala is to enable you to import packages in addition to just importing the names of types, and the fields and methods of singleton objects.
This is a “code smell,” a sign that there may be some unnecessary redundancy and repetition in your code.
You can avoid the code smell by combining the parameter and the field in a single parametric field definition, as shown in Listing 10.5:
Note that now the contents parameter is prefixed by val.
This is a shorthand that defines at the same time a parameter and field with the same name.
Specifically, class ArrayElement now has an (unreassignable) field contents, which can be accessed from outside the class.
The field is initialized with the value of the parameter.
It’s as if the class had been written as follows, where x123 is an arbitrary fresh name for the parameter:
You can also prefix a class parameter with var, in which case the corresponding field would be reassignable.
Finally, it is possible to add modifiers such as private, protected,5 or override to these parametric fields, just as you can do for any other class member.
Tiger’s definition is a shorthand for the following alternate class definition with an overriding member dangerous and a private member age:
The important thing was that they not clash with any other name in scope.
You now have a complete system consisting of two classes: an abstract class Element, which is extended by a concrete class ArrayElement.
You might also envision other ways to express an element.
For example, clients might want to create a layout element consisting of a single line given by a string.
Object-oriented programming makes it easy to extend a system with new data-variants.
For example, Listing 10.6 shows a LineElement class that extends ArrayElement:
Since LineElement extends ArrayElement, and ArrayElement’s constructor takes a parameter (an Array[String]), LineElement needs to pass an argument to the primary constructor of its superclass.
To invoke a superclass constructor, you simply place the argument or arguments you want to pass in parentheses following the name of the superclass.
For example, class LineElement passes Array(s) to ArrayElement’s primary constructor by placing it in parentheses after the superclass ArrayElement’s name:
With the new subclass, the inheritance hierarchy for layout elements now looks as shown in Figure 10.2
Note that the definitions of width and height in LineElement carry an override modifier.
In Section 6.3, you saw this modifier in the definition of a toString method.
Scala requires such a modifier for all members that override a concrete member in a parent class.
The modifier is optional if a member implements an abstract member with the same name.
The modifier is forbidden if a member does not override or implement some other member in a base class.
Since height and width in class LineElement override concrete definitions in class Element, override is required.
This rule provides useful information for the compiler that helps avoid some hard-to-catch errors and makes system evolution safer.
For instance, if you happen to misspell the method or accidentally give it a different parameter list, the compiler will respond with an error message:
The override convention is even more important when it comes to system evolution.
You made it publicly available, and it is widely used.
In the next version of the library you want to add to your base class Shape a new method with this signature:
Your new method will be used by various drawing methods to determine whether a shape needs to be drawn.
This could lead to a significant speedup, but you cannot do this without the risk of breaking client code.
After all, a client could have defined a subclass of Shape with a different implementation of hidden.
Perhaps the client’s method actually makes the receiver object disappear instead of testing whether the object is hidden.
Because the two versions of hidden override each other, your drawing methods would end up making objects disappear, which is certainly not what you want! These “accidental overrides” are the most common manifestation of what is called the “fragile base class” problem.
The problem is that if you add new members to base classes (which we usually call superclasses) in a class hierarchy, you risk breaking client code.
Scala cannot completely solve the fragile base class problem, but it improves on the situation compared to Java.6 If the drawing library and its clients were written in Scala, then the client’s original implementation of hidden could not have had an override modifier, because at the time there was no other method with that name.
Once you add the hidden method to the second version of your shape class, a recompile of the client would give an error like the following:
That is, instead of wrong behavior your client would get a compile-time error, which is usually much preferable.
You saw in Section 10.4 that a variable of type Element could refer to an object of type ArrayElement.
The name for this phenomenon is polymorphism, which means “many shapes” or “many forms.” In this case, Element objects can have many forms.7 So far, you’ve seen two such forms: ArrayElement and LineElement.
You can create more forms of Element by defining new Element subclasses.
For example, here’s how you could define a new form of Element that has a given width and height and is filled everywhere with a given character:
The inheritance hierarchy for class Element now looks as shown in Figure 10.3
As a result, Scala will accept all of the following assignments, because the assigning expression’s type conforms to the type of the defined variable:
If you check the inheritance hierarchy, you’ll find that in each of these four val definitions, the type of the expression to the right of the equals sign is below the type of the val being initialized to the left of the equals sign.
The other half of the story, however, is that method invocations on variables and expressions are dynamically bound.
This means that the actual method implementation invoked is determined at run time based on the class of the object, not the type of the variable or expression.
We’ll override demo in ArrayElement and LineElement, but not in UniformElement:
If you enter this code into the interpreter, you can then define this method.
If you pass an ArrayElement to invokeDemo, you’ll see a message indicating ArrayElement’s implementation of demo was invoked, even though the type of the variable, e, on which demo was invoked is Element:
Similarly, if you pass a LineElement to invokeDemo, you’ll see a message that indicates LineElement’s demo implementation was invoked:
The behavior when passing a UniformElement may at first glance look suspicious, but it is correct:
Because UniformElement does not override demo, it inherits the implementation of demo from its superclass, Element.
Thus, Element’s implementation is the correct implementation of demo to invoke when the class of the object is UniformElement.
Sometimes when designing an inheritance hierarchy, you want to ensure that a member cannot be overridden by subclasses.
In Scala, as in Java, you do this by adding a final modifier to the member.
For example, you could place a final modifier on ArrayElement’s demo method, as shown in Listing 10.7
Given this version of ArrayElement, an attempt to override demo in its subclass, LineElement, would not compile:
You may also at times want to ensure that an entire class not be subclassed.
To do this you simply declare the entire class final by adding a final modifier to the class declaration.
For example, Listing 10.8 shows how you would declare ArrayElement final:
With this version of ArrayElement, any attempt at defining a subclass would fail to compile:
We’ll now remove the final modifiers and demo methods, and go back to the earlier implementation of the Element family.
We’ll focus our attention in the remainder of this chapter to completing a working version of the layout library.
Composition and inheritance are two ways to define a new class in terms of another existing class.
If what you’re after is primarily code reuse, you should in general prefer composition to inheritance.
Only inheritance suffers from the fragile base class problem, in which you can inadvertently break subclasses by changing a superclass.
One question you can ask yourself about an inheritance relationship is whether it models an is-a relationship.8 For example, it would be reasonable to say that ArrayElement is-an Element.
Another question you can ask is whether clients will want to use the subclass type as a superclass type.9 In the case of ArrayElement, we do indeed expect clients will want to use an ArrayElement as an Element.
If you ask these questions about the inheritance relationships shown in Figure 10.3, do any of the relationships seem suspicious? In particular, does it seem obvious to you that a LineElement is-an ArrayElement? Do you think clients would ever need to use a LineElement as an ArrayElement? In fact, we defined LineElement as a subclass of ArrayElement primarily to reuse ArrayElement’s definition of contents.
Perhaps it would be better, therefore, to define LineElement as a direct subclass of Element, like this:
In the previous version, LineElement had an inheritance relationship with ArrayElement, from which it inherited contents.
Class ArrayElement also has a composition relationship with Array, because its parametric contents field holds a reference to an array of strings.
As a next step, we’ll implement method above in class Element.
Putting one element above another means concatenating the two contents values of the elements.
So a first draft of method above could look like this:
Arrays in Scala are represented as Java arrays, but support many more methods.
Specifically, arrays in Scala can be converted to instances of a class scala.Seq, which represents sequence-like structures and contains a number of methods for accessing and transforming sequences.
In fact, the code shown previously is not quite sufficient, because it does not permit you to put elements of different widths on top of each other.
To keep things simple in this section, however, we’ll leave this as is and only pass elements of the same length to above.
In Section 10.14, we’ll make an enhancement to above so that clients can use it to combine elements of different widths.
To put two elements beside each other, we’ll create a new element in which every line results from concatenating corresponding lines of the two elements.
As before, to keep things simple we’ll start by assuming the two elements have the same height.
The beside method first allocates a new array, contents, and fills it with the concatenation of the corresponding array elements in this.contents and that.contents.
It finally produces a new ArrayElement containing the new contents.
Although this implementation of beside works, it is in an imperative style, the telltale sign of which is the loop in which we index through arrays.
Here, the two arrays this.contents and that.contents are transformed into an array of pairs (as Tuple2s are called) using the zip operator.
The zip method picks corresponding elements in its two arguments and forms an array of pairs.
If one of the two operand arrays is longer than the other, zip will drop the remaining elements.
In the expression above, the third element of the left operand, 3, does not form part of the result, because it does not have a corresponding element in the right operand.
The zipped array is then iterated over by a for expression.
The for expression has a yield part and therefore yields a result.
The result is of the same kind as the expression iterated over, i.e., it is an array.
So the end result of this code is the same as in the first version of beside, but because it avoids explicit array indexing, the result is obtained in a less error-prone way.
As usual, this is done by defining a toString method that returns an element formatted as a string.
The implementation of toString makes use of mkString, which is defined for all sequences, including arrays.
As you saw in Section 7.8, an expression like “arr mkString sep” returns a string consisting of all elements of the array arr.
Each element is mapped to a string by calling its toString method.
A separator string sep is inserted between consecutive element strings.
So the expression, “contents mkString "\n"” formats the contents array as a string, where each array element appears on a line by itself.
Note that toString does not carry an empty parameter list.
This follows the recommendations for the uniform access principle, because toString is a pure method that does not take any parameters.
With the addition of these three methods, class Element now looks as shown in Listing 10.9
You now have a hierarchy of classes for layout elements.
This hierarchy could be presented to your clients “as is.” But you might also choose to hide the hierarchy behind a factory object.
Clients would then use these factory methods for object construction rather than constructing the objects directly with new.
An advantage of this approach is that object creation can be centralized and the details of how objects are represented with classes can be hidden.
This hiding will both make your library simpler for clients to understand, because.
The first task in constructing a factory for layout elements is to choose where the factory methods should be located.
Should they be members of a singleton object or of a class? What should the containing object or class be called? There are many possibilities.
A straightforward solution is to create a companion object of class Element and make this be the factory object for layout elements.
That way, you need to expose only the class/object combo of Element to your clients, and you can hide the three implementation classes ArrayElement, LineElement, and UniformElement.
Listing 10.10 is a design of the Element object that follows this scheme.
The Element companion object contains three overloaded variants of an elem method.
With the advent of these factory methods, it makes sense to change the implementation of class Element so that it goes through the elem factory methods rather than creating new ArrayElement instances explicitly.
To call the factory methods without qualifying them with Element, the name of the.
In other words, instead of invoking the factory methods with Element.elem inside class Element, we’ll import Element.elem so we can just call the factory methods by their simple name, elem.
Listing 10.11 shows what class Element will look like after these changes.
In addition, given the factory methods, the subclasses ArrayElement, LineElement and UniformElement could now be private, because they need no longer be accessed directly by clients.
In Scala, you can define classes and singleton objects inside other classes and singleton objects.
One way to make the Element subclasses private, therefore, is to place them inside the Element singleton object and declare them private there.
The classes will still be accessible to the three elem factory methods, where they are needed.
The version of Element shown in Listing 10.11 is not quite sufficient, because it does not allow clients to place elements of different widths on top of each other, or place elements of different heights beside each other.
For example, evaluating the following expression would not work correctly, because the second line in the combined element is longer than the first:
Similarly, evaluating the following expression would not work properly, because the first ArrayElement has a height of two, and the second a height of only one:
Listing 10.13 shows a private helper method, widen, which takes a width and returns an Element of that width.
The result contains the contents of this Element, centered, padded to the left and right by any spaces needed to achieve the required width.
Listing 10.13 also shows a similar method, heighten, which performs the same function in the vertical direction.
The widen method is invoked by above to ensure that Elements placed above each other have the same width.
Similarly, the heighten method is invoked by beside to ensure that elements placed beside each other have the same height.
With these changes, the layout library is ready for use.
A fun way to exercise almost all elements of the layout library is to write a program that draws a spiral with a given number of edges.
This Spiral program, shown in Listing 10.14, will do just that:
Because Spiral is a standalone object with a main method with the proper signature, it is a Scala application.
For example, you could draw a six-edge spiral as shown below on the left, and larger spirals as shown to the right:
In this section, you saw more concepts related to object-oriented programming in Scala.
Among others, you encountered abstract classes, inheritance and subtyping, class hierarchies, parametric fields, and method overriding.
You should have developed a feel for constructing a non-trivial class hierarchy in Scala.
Now that you’ve seen the details of class inheritance in the previous chapter, it is a good time to take a step back and look at Scala’s class hierarchy as a whole.
In Scala, every class inherits from a common superclass named Any.
Because every class is a subclass of Any, the methods defined in Any are “universal” methods: they may be invoked on any object.
Scala also defines some interesting classes at the bottom of the hierarchy, Null and Nothing, which essentially act as common subclasses.
For example, just as Any is a superclass of every other class, Nothing is a subclass of every other class.
In this chapter, we’ll give you a tour of Scala’s class hierarchy.
At the top of the hierarchy is class Any, which defines methods that include the following:
Because every class inherits from Any, every object in a Scala program can be compared using ==, !=, or equals; hashed using ## or hashCode; and formatted using toString.
The equality and inequality methods, == and !=, are declared final in class Any, so they cannot be overridden in subclasses.
The == method is essentially the same as equals and != is always the negation of equals.1 So individual classes can tailor what == or != means by overriding the equals method.
The root class Any has two subclasses: AnyVal and AnyRef.
AnyVal is the parent class of every built-in value class in Scala.
The first eight of these correspond to Java’s primitive types, and their values are represented at run time as Java’s primitive values.
The instances of these classes are all written as literals in Scala.
For example, 42 is an instance of Int, 'x' is an instance of Char, and false an instance of Boolean.
This is enforced by the “trick” that value classes are all defined to be both abstract and final.
The other value class, Unit, corresponds roughly to Java’s void type; it is used as the result type of a method that does not otherwise return an interesting result.
Unit has a single instance value, which is written (), as discussed in Section 7.2
As explained in Chapter 5, the value classes support the usual arithmetic and boolean operators as methods.
The only cases where == is does not directly call equals is for Java’s boxed numeric classes such as Integer or Long.
Since Scala is a more regular language than Java it was necessary correct this discrepancy by special-casing the == method for these classes.
Likewise, the ## method provides a Scala version of hashing that is the same as Java’s hashCode, except for boxed numeric types, where it works consistently with ==
Note that the value class space is flat; all value classes are subtypes of scala.AnyVal, but they do not subclass each other.
Instead there are implicit conversions between different value class types.
For example, an instance of class scala.Int is automatically widened (by an implicit conversion) to an instance of class scala.Long when required.
As mentioned in Section 5.9, implicit conversions are also used to add more functionality to value types.
For instance, the type Int supports all of the operations below:
The conversion is applied whenever a method is invoked on an Int that is undefined in Int but defined in RichInt.
Similar “booster classes” and implicit conversions exist for the other value classes.
The other subclass of the root class Any is class AnyRef.
This is the base class of all reference classes in Scala.
Thus, although you can use Object and AnyRef interchangeably in Scala programs on the Java platform, the recommended style is to use AnyRef everywhere.
Scala classes are different from Java classes in that they also inherit from a special marker trait called ScalaObject.
How is all this implemented? In fact, Scala stores integers in the same way as Java: as 32-bit words.
This is important for efficiency on the JVM and also for interoperability with Java libraries.
Standard operations like addition or multiplication are implemented as primitive operations.
This happens for instance when invoking the toString method on an integer number or when assigning an integer to a variable of type Any.
All this sounds a lot like auto-boxing in Java 5 and it is indeed quite similar.
There’s one crucial difference, though, in that boxing in Scala is much less visible than boxing in Java.
You will find that you get false! What happens is that the number 421 gets boxed twice, so that the arguments for x and y are two different objects.
Because == means reference equality on reference types, and Integer is a reference type, the result is false.
This is one aspect where it shows that Java is not a pure object-oriented language.
There is a difference between primitive types and reference types that can be clearly observed.
In fact, the equality operation == in Scala is designed to be transparent with respect to the type’s representation.
For value types, it is the natural (numeric or boolean) equality.
For reference types other than Java’s boxed numeric types, == is treated as an alias of the equals method inherited from Object.
That method is originally defined as reference equality, but is overridden by many subclasses to implement their natural notion of equality.
This also means that in Scala you never fall into Java’s well-known trap concerning string comparisons.
In Java, the result of comparing x with y would be false.
The programmer should have used equals in this case, but it is easy to forget.
However, there are situations where you need reference equality instead of user-defined equality.
For example, in some situations where efficiency is paramount, you would like to hash cons with some classes and compare their instances with reference equality.3 For these cases, class AnyRef defines an additional eq method, which cannot be overridden and is implemented as reference equality (i.e., it behaves like == in Java for reference types)
There’s also the negation of eq, which is called ne.
At the bottom of the type hierarchy in Figure 11.1 you see the two classes scala.Null and scala.Nothing.
These are special types that handle some “corner cases” of Scala’s object-oriented type system in a uniform way.
Class Null is the type of the null reference; it is a subclass of every reference class (i.e., every class that itself inherits from AnyRef)
You cannot, for example, assign a null value to an integer variable:
You hash cons instances of a class by caching all instances you have created in a weak collection.
Then, any time you want a new instance of the class, you first check the cache.
If the cache already has an element equal to the one you are about to create, you can reuse the existing instance.
As a result of this arrangement, any two instances that are equal with equals() are also equal with reference equality.
Type Nothing is at the very bottom of Scala’s class hierarchy; it is a subtype of every other type.
Why does it make sense to have a type without values? As discussed in Section 7.4, one use of Nothing is that it signals abnormal termination.
For instance there’s the error method in the Predef object of Scala’s standard library, which is defined like this:
The return type of error is Nothing, which tells users that the method will not return normally (it throws an exception instead)
Because Nothing is a subtype of every other type, you can use methods like error in very flexible ways.
The “then” branch of the conditional, x / y, has type Int, whereas the else branch, the call to error, has type Nothing.
Because Nothing is a subtype of Int, the type of the whole conditional is Int, as required.
In this chapter we showed you the classes at the top and bottom of Scala’s class hierarchy.
Now that you’ve gotten a good foundation on class inheritance in Scala, you’re ready to understand mixin composition.
Traits are a fundamental unit of code reuse in Scala.
A trait encapsulates method and field definitions, which can then be reused by mixing them into classes.
Unlike class inheritance, in which each class must inherit from just one superclass, a class can mix in any number of traits.
This chapter shows you how traits work and shows two of the most common ways they are useful: widening thin interfaces to rich ones, and defining stackable modifications.
It also shows how to use the Ordered trait and compares traits to the multiple inheritance of other languages.
A trait definition looks just like a class definition except that it uses the keyword trait.
It does not declare a superclass, so like a class, it has the default superclass of AnyRef.
It’s a simple trait, just enough to show how traits work.
Once a trait is defined, it can be mixed in to a class using either the extends or with keywords.
Scala programmers “mix in” traits rather than inherit from them, because mixing in a trait has important differences from the multiple inheritance found in many other languages.
For example, Listing 12.2 shows a class that mixes in the Philosophical trait using extends:
You can use the extends keyword to mix in a trait; in that case you implicitly inherit the trait’s superclass.
For instance, in Listing 12.2, class Frog subclasses AnyRef (the superclass of Philosophical) and mixes in Philosophical.
Methods inherited from a trait can be used just like methods inherited from a superclass.
Here’s an example in which Philosophical is used as a type:
Thus, variable phil could have been initialized with any object whose class mixes in Philosophical.
If you wish to mix a trait into a class that explicitly extends a superclass, you use extends to indicate the superclass and with to mix in the trait.
If you want to mix in multiple traits, you add more with clauses.
For example, given a trait HasLegs, you could mix both Philosophical and HasLegs into Frog as shown in Listing 12.4
In the examples you’ve seen so far, class Frog has inherited an implementation of philosophize from trait Philosophical.
The syntax looks the same as overriding a method declared in a superclass.
Because this new definition of Frog still mixes in trait Philosophical, you can still use it from a variable of that type.
But because Frog overrides Philosophical’s implementation of philosophize, you’ll get a new behavior when you call it:
At this point you might philosophize that traits are like Java interfaces with concrete methods, but they can actually do much more.
In fact, you can do anything in a trait definition that you can do in a class definition, and the syntax looks exactly the same, with only two exceptions.
First, a trait cannot have any “class” parameters, i.e., parameters passed to the primary constructor of a class.
In other words, although you could define a class like this:
The following attempt to define a trait would not compile:
You’ll find out in Section 20.5 how to work around this restriction.
If you write “super.toString” in a class, you know exactly which method implementation will be invoked.
When you write the same thing in a trait, however, the method implementation to invoke for the super call is undefined when you define the trait.
Rather, the implementation to invoke will be determined anew each time the trait is mixed into a concrete class.
This curious behavior of super is key to allowing traits to work as stackable modifications, which will be described in Section 12.5
The rules for resolving super calls will be given in Section 12.6
One major use of traits is to automatically add methods to a class in terms of methods the class already has.
That is, traits can enrich a thin interface, making it into a rich interface.
Thin versus rich interfaces represents a commonly faced trade-off in object-oriented design.
The trade-off is between the implementers and the clients of an interface.
A rich interface has many methods, which make it convenient for the caller.
Clients can pick a method that exactly matches the functionality they need.
A thin interface, on the other hand, has fewer methods, and thus is easier on the implementers.
Clients calling into a thin interface, however, have to write more code.
For example, interface CharSequence, which was introduced in Java 1.4, is a thin interface common to all string-like classes that hold a sequence of characters.
Although most of the dozens of methods in class String would apply to any CharSequence, Java’s CharSequence interface declares only four methods.
Had CharSequence instead included the full String interface, it would have placed a large burden on implementers of CharSequence.
Every programmer that implemented CharSequence in Java would have had to define dozens more methods.
Because Scala traits can contain concrete methods, they make rich interfaces far more convenient.
Adding a concrete method to a trait tilts the thin-rich trade-off heavily towards rich interfaces.
Unlike in Java, adding a concrete method to a Scala trait is a one-time effort.
You only need to implement the method once, in the trait itself, instead of needing to reimplement it for every class that mixes in the trait.
Thus, rich interfaces are less work to provide in Scala than in a language without traits.
To enrich an interface using traits, simply define a trait with a small number of abstract methods—the thin part of the trait’s interface—and a potentially large number of concrete methods, all implemented in terms of the abstract methods.
Then you can mix the enrichment trait into a class, implement the thin portion of the interface, and end up with a class that has all of the rich interface available.
To make these rectangular objects convenient to use, it is nice if the library provides geometric queries such as width, height, left, right, topLeft, and so on.
However, many such methods exist that would be nice to have, so it can be a large burden on library writers to provide all of them for all rectangular objects in a Java library.
If such a library were written in Scala, by contrast, the library writer could use traits to easily supply all of these convenience methods on all the classes they’d like.
To see how, first imagine what the code would look like without traits.
There would be some basic geometric classes like Point and Rectangle:
This Rectangle class takes two points in its primary constructor: the coordinates of the top-left and bottom-right corners.
It then implements many convenience methods such as left, right, and width by performing simple calculations on these two points.
Another class a graphics library might have is a 2-D graphical widget:
Notice that the definitions of left, right, and width are exactly the same in the two classes.
They will also be the same, aside from minor variations, in any other classes for rectangular objects.
The trait will have two abstract methods: one that returns the top-left coordinate of the object, and another that returns the bottom-right coordinate.
Class Component can mix in this trait to get all the geometric methods provided by Rectangular:
Given these definitions, you can create a Rectangle and call geometric methods such as width and left on it:
Comparison is another domain where a rich interface is convenient.
Whenever you compare two objects that are ordered, it is convenient if you use a single method call to ask about the precise comparison you want.
A rich interface would provide you with all of the usual comparison operators, thus allowing you to directly write things like “x <= y”
Before looking at Ordered, imagine what you might do without it.
Suppose you took the Rational class from Chapter 6 and added comparison operations to it.
First, notice that three of the comparison operators are defined in terms of the first one.
In a comparison context, <= is always used to mean “less than or equals.” Overall, there is quite a lot of.
This problem is so common that Scala provides a trait to help with it.
To use it, you replace all of the individual comparison methods with a single compare method.
Thus, trait Ordered allows you to enrich a class with comparison methods by implementing only one method, compare.
Here is how it looks if you define comparison operations on Rational by using the Ordered trait:
First, this version of Rational mixes in the Ordered trait.
Unlike the traits you have seen so far, Ordered requires you to specify a type parameter when you mix it in.
Type parameters are not discussed in detail until Chapter 19, but for now all you need to know is that when you mix in Ordered, you must actually mix in Ordered[C], where C is the class whose elements you compare.
The second thing you need to do is define a compare method for comparing two objects.
This method should compare the receiver, this, with the object passed as an argument to the method.
It should return an integer that is zero if the objects are the same, negative if receiver is less than the argument, and positive if the receiver is greater than the argument.
In this case, the comparison method of Rational uses a formula based on converting the fractions to a common denominator and then subtracting the resulting numerators.
Given this mixin and the definition of compare, class Rational now has all four comparison methods:
Any time you implement a class that is ordered by some comparison, you should consider mixing in the Ordered trait.
If you do, you will provide the class’s users with a rich set of comparison methods.
Beware that the Ordered trait does not define equals for you, because it is unable to do so.
The problem is that implementing equals in terms of compare requires checking the type of the passed object, and because of type erasure, Ordered itself cannot do this test.
Thus, you need to define equals yourself, even if you inherit Ordered.
You have now seen one major use of traits: turning a thin interface into a rich one.
Now we’ll turn to a second major use: providing stackable modifications to classes.
Traits let you modify the methods of a class, and they do so in a way that allows you to stack those modifications with each other.
As an example, consider stacking modifications to a queue of integers.
The queue will have two operations: put, which places integers in the queue, and get, which takes them back out.
Queues are first-in, first-out, so get should return the integers in the same order they were put in the queue.
Given a class that implements such a queue, you could define traits to perform modifications such as these:
Doubling: double all integers that are put in the queue.
Incrementing: increment all integers that are put in the queue.
These three traits represent modifications, because they modify the behavior of an underlying queue class rather than defining a full queue class themselves.
You can select any of the three you like, mix them into a class, and obtain a new class that has all of the modifications you chose.
IntQueue has a put method that adds new integers to the queue and a get method that removes and returns them.
A basic implementation of IntQueue that uses an ArrayBuffer is shown in Listing 12.7
Class BasicIntQueue has a private field holding an array buffer.
The get method removes an entry from one end of the buffer, while the put method adds elements to the other end.
Now take a look at using traits to modify this behavior.
Listing 12.8 shows a trait that doubles integers as they are put in the queue.
This declaration means that the trait can only be mixed into a class that also extends IntQueue.
Thus, you can mix Doubling into BasicIntQueue, but not into Rational.
The second funny thing is that the trait has a super call on a method declared abstract.
Such calls are illegal for normal classes, because they will certainly fail at run time.
For a trait, however, such a call can actually succeed.
Since super calls in a trait are dynamically bound, the super call in trait Doubling will work so long as the trait is mixed in after another trait or class that gives a concrete definition to the method.
This arrangement is frequently needed with traits that implement stackable modifications.
To tell the compiler you are doing this on purpose, you must mark such methods as abstract override.
This combination of modifiers is only allowed for members of traits, not classes, and it means that the trait must be mixed into some class that has a concrete definition of the method in question.
There is a lot going on with such a simple trait, isn’t there! Here’s how it looks to use the trait:
In the first line in this interpreter session, we define class MyQueue, which extends BasicIntQueue and mixes in Doubling.
It simply identifies a class and mixes in a trait.
In this situation, you could supply “BasicIntQueue with Doubling” directly to new instead of defining a named class.
To see how to stack modifications, we need to define the other two modification traits, Incrementing and Filtering.
Given these modifications, you can now pick and choose which ones you want for a particular queue.
For example, here is a queue that both filters negative numbers and adds one to all numbers that it keeps:
The order of mixins is significant.2 The precise rules are given in the following section, but, roughly speaking, traits further to the right take effect first.
When you call a method on a class with mixins, the method in the trait furthest to the right is called first.
If that method calls super, it invokes the method in the next trait to its left, and so on.
In the previous example, Filtering’s put is invoked first, so it removes integers that were negative to begin with.
Incrementing’s put is invoked second, so it adds one to those integers that remain.
If you reverse the order, first integers will be incremented, and then the integers that are still negative will be discarded:
Overall, code written in this style gives you a great deal of flexibility.
You can define sixteen different classes by mixing in these three traits in different combinations and orders.
That’s a lot of flexibility for a small amount of code, so you should keep your eyes open for opportunities to arrange code as stackable modifications.
Traits are a way to inherit from multiple class-like constructs, but they differ in important ways from the multiple inheritance present in many languages.
Once a trait is mixed into a class, you can alternatively call it a mixin.
With traits, the method called is determined by a linearization of the classes and traits that are mixed into a class.
This is the difference that enables the stacking of modifications described in the previous section.
Before looking at linearization, take a moment to consider how to stack modifications in a language with traditional multiple inheritance.
Imagine the following code, but this time interpreted as multiple inheritance instead of trait mixin:
The first question is, which put method would get invoked by this call? Perhaps the rule would be that the last superclass wins, in which case Doubling would get called.
Doubling would double its argument and call super.put, and that would be it.
No incrementing would happen! Likewise, if the rule were that the first superclass wins, the resulting queue would increment integers but not double them.
You might also entertain the possibility of allowing programmers to identify exactly which superclass method they want when they say super.
For example, imagine the following Scala-like code, in which super appears to be explicitly invoked on both Incrementing and Doubling:
The verbosity of this attempt is the least of its problems.
What would happen is that the base class’s put method would get called twice—once with an incremented value and once with a doubled value, but neither time with an incremented, doubled value.
There is simply no good solution to this problem using multiple inheritance.
You would have to back up in your design and factor the code differently.
You simply mix in Incrementing and Doubling, and Scala’s special treatment of super in traits makes it all work out.
Something is clearly different here from traditional multiple inheritance, but what?
When you instantiate a class with new, Scala takes the class and all of its inherited classes and traits and puts them in a single, linear order.
Then, whenever you call super inside one of those classes, the invoked method is the next one up the chain.
If all of the methods but the last call super, the net result is stackable behavior.
The precise order of the linearization is described in the language specification.
It is a little bit complicated, but the main thing you need to know is that, in any linearization, a class is always linearized before all of its superclasses and mixed in traits.
Thus, when you write a method that calls super, that method is definitely modifying the behavior of the superclasses and mixed in traits, not the other way around.
Note The remainder of this section describes the details of linearization.
You can safely skip the rest of this section if you are not interested in understanding those details right now.
The main properties of Scala’s linearization are illustrated by the following example: Say you have a class Cat, which inherits from a superclass Animal and two traits Furry and FourLegged.
Class Cat’s inheritance hierarchy and linearization are shown in Figure 12.1
Inheritance is indicated using traditional UML notation:3 arrows with white, triangular arrowheads indicate inheritance, with the arrowhead.
The darkened arrowheads point in the direction in which super calls will be resolved.
The linearization of Cat is computed from back to front as follows.
The last part of the linearization of Cat is the linearization of its superclass, Animal.
Because Animal doesn’t explicitly extend a superclass or mix in any supertraits, it by default extends AnyRef, which extends Any.
The second to last part is the linearization of the first mixin, trait Furry, but all classes that are already in the linearization of Animal are left out now, so that each class appears only once in Cat’s linearization.
This is preceded by the linearization of FourLegged, where again any classes that have already been copied in the linearizations of the superclass or the first mixin are left out:
Finally, the first class in the linearization of Cat is Cat itself:
When any of these classes and traits invokes a method via super, the implementation invoked will be the first implementation to its right in the linearization.
Whenever you implement a reusable collection of behavior, you will have to decide whether you want to use a trait or an abstract class.
There is no firm rule, but this section contains a few guidelines to consider.
If the behavior will not be reused, then make it a concrete class.
If it might be reused in multiple, unrelated classes, make it a trait.
Only traits can be mixed into different parts of the class hierarchy.
If you want to inherit from it in Java code, use an abstract class.
Since traits with code do not have a close Java analog, it tends to be awkward to inherit from a trait in a Java class.
Inheriting from a Scala class, meanwhile, is exactly like inheriting from a Java class.
As one exception, a Scala trait with only abstract members translates directly to a Java interface, so you should feel free to define such traits even if you expect Java code to inherit from it.
See Chapter 31 for more information on working with Java and Scala together.
If you plan to distribute it in compiled form, and you expect outside groups to write classes inheriting from it, you might lean towards using an abstract class.
The issue is that when a trait gains or loses a member, any classes that inherit from it must be recompiled, even if they have not changed.
If outside clients will only call into the behavior, instead of inheriting from.
If efficiency is very important, lean towards using a class.
Traits get compiled to interfaces and therefore may pay a slight performance overhead.
However, you should make this choice only if you know that the trait in question constitutes a performance bottleneck and have evidence that using a class instead actually solves the problem.
If you still do not know, after considering the above, then start by making it as a trait.
You can always change it later, and in general using a trait keeps more options open.
This chapter has shown you how traits work and how to use them in several common idioms.
You saw that traits are similar to multiple inheritance, but because they interpret super using linearization, they both avoid some of the difficulties of traditional multiple inheritance, and allow you to stack behaviors.
You also saw the Ordered trait and learned how to write your own enrichment traits.
Now that you have seen all of these facets, it is worth stepping back and taking another look at traits as a whole.
Traits do not merely support the idioms described in this chapter.
They are a fundamental unit of code that is reusable through inheritance.
Because of this nature, many experienced Scala programmers start with traits when they are at the early stages of implementation.
Each trait can hold less than an entire concept, a mere fragment of a concept.
As the design solidifies, the fragments can be combined into more complete concepts through trait mixin.
When working on a program, especially a large one, it is important to minimize coupling—the extent to which the various parts of the program rely on the other parts.
Low coupling reduces the risk that a small, seemingly innocuous change in one part of the program will have devastating consequences in another part.
One way to minimize coupling is to write in a modular style.
You divide the program into a number of smaller modules, each of which has an inside and an outside.
When working on the inside of a module—its implementation—you need only coordinate with other programmers working on that very same module.
Only when you must change the outside of a module—its interface—is it necessary to coordinate with developers working on other modules.
This chapter shows several constructs that help you program in a modular style.
It shows how to place things in packages, make names visible through imports, and control the visibility of definitions through access modifiers.
Scala code resides in the Java platform’s global hierarchy of packages.
The example code you’ve seen so far in this book has been in the unnamed package.
You can place code into named packages in Scala in two ways.
First, you can place the contents of an entire file into a package by putting a package clause at the top of the file, as shown in Listing 13.1
Presumably, this is the navigation software developed by Bob’s Rockets, Inc.
In this chapter, however, we’ll leave off the “com.” to make the examples easier to understand.
The other way you can place code into packages in Scala is more like C# namespaces.
You follow a package clause by a section in curly braces that contains the definitions that go into the package.
For such simple examples, you might as well use the syntactic sugar shown in Listing 13.1
However, one use of the more general notation is to have different parts of a file in different packages.
For example, you might include a class’s tests in the same file as the original code, but put the tests in a different package, as shown in Listing 13.3
When code is divided into a package hierarchy, it doesn’t just help people browse through the code.
It also tells the compiler that code in the same.
First, as you would expect, a class can be accessed from within its own package without needing a prefix.
Second, a package itself can be accessed from its containing package without needing a prefix.
In Listing 13.4, look at how class Navigator is instantiated.
Third, when using the curly-braces packaging syntax, all names accessible in scopes outside the packaging are also available inside it.
An example in Listing 13.4 is the way addShip() creates a new Ship.
Since Ship is accessible in the outer packaging, it can be referenced from within addShip()
Note that this kind of access is only available if you explicitly nest the packagings.
If you stick to one package per file, then—like in Java—the only names available will be the ones defined in the current package.
Since it is no longer enclosed in a packaging for bobsrockets, names from bobsrockets are not immediately in scope.
This style of multiple package clauses without braces is called chained package clauses.
Sometimes, you end up coding in a heavily crowded scope where package names are hiding each other.
Thus, you can refer to the first booster class as simply launch.Booster1
That leaves the question of the third booster class, however.
How can you access Booster3, considering that a nested launch package shadows the top-level one?
To help in this situation, Scala provides a package named _root_ that is outside any package a user can write.
Put another way, every top-level package you can write is treated as a member of package _root_
In Scala, packages and their members can be imported using import clauses.
Imported items can then be accessed by a simple name like File, as opposed to requiring a qualified name like java.io.File.
An import clause makes members of a package or object available by their names alone without needing to prefix them by the package or object name.
The first of these corresponds to Java’s single type import, the second to Java’s on-demand import.
The third import clause above corresponds to Java’s import of static class fields.
These three imports give you a taste of what imports can do, but Scala imports are actually much more general.
For one, imports in Scala can appear anywhere, not just at the beginning of a compilation unit.
For instance, the import shown in Listing 13.8 is possible:
Method showFruit imports all members of its parameter fruit, which is of type Fruit.
The subsequent println statement can refer to name and color directly.
Scala’s flexible imports Scala’s import clauses are quite a bit more flexible than Java’s.
Another way Scala’s imports are flexible is that they can import packages themselves, not just their non-package members.
This is only natural if you think of nested packages being contained in their surrounding package.
This is done with an import selector clause enclosed in braces, which follows the object from which members are imported.
This imports just members Apple and Orange from object Fruits.
This imports the two members Apple and Orange from object Fruits.
This imports the SQL date class as SDate, so that you can simultaneously import the normal Java date class as simply Date.
This imports the java.sql package as S, so that you can write things like S.Date.
This imports all members from object Fruits but renames Apple to McIntosh.
In a sense, renaming something to ‘_’ means hiding it altogether.
Say you have two packages, Fruits and Notebooks, which both define a class Apple.
If you want to get just the notebook named Apple, and not the fruit, you could still use two imports on demand like this:
This would import all Notebooks and all Fruits except for Apple.
These examples demonstrate the great flexibility Scala offers when it comes to importing members selectively and possibly under different names.
In summary, an import selector can consist of the following:
This makes the member named x visible under the name y.
This imports all members except those members mentioned in a preceding clause.
If a catch-all is given, it must come last in the list of import selectors.
In essence, it is as if the following three import clauses had been added to the top of every source file with extension “.scala”:
It is always implicitly imported on the JVM implementation of Scala.
The .NET implementation would import package system instead, which is the .NET analogue of java.lang.
As you have no doubt realized by now, the scala package contains the standard Scala library, with many common classes and objects.
Because scala is imported implicitly, you can write List instead of scala.List, for instance.
The Predef object contains many definitions of types, methods, and implicit conversions that are commonly used on Scala programs.
For example, because Predef is imported implicitly, you can write assert instead of Predef.assert.
The three import clauses above are treated a bit specially in that later imports overshadow earlier ones.
For instance, the StringBuilder class is defined both in package scala and, from Java version 1.5 on, also in package java.lang.
Members of packages, classes, or objects can be labeled with the access modifiers private and protected.
These modifiers restrict accesses to the members to certain regions of code.
Scala’s treatment of access modifiers roughly follows Java’s but there are some important differences which are explained in this section.
A member labeled private is visible only inside the class or object that contains the member definition.
In Scala, the access (new Inner).f() is illegal because f is declared private in Inner and the access is not from within class Inner.
By contrast, the first access to f in class InnerMost is OK, because that access.
Java would permit both accesses because it lets an outer class access private members of its inner classes.
Access to protected members is also a bit more restrictive than in Java.
In Scala, a protected member is only accessible from subclasses of the class in which the member is defined.
In Java such accesses are also possible from other classes in the same package.
In Scala, there is another way to achieve this effect, as described below, so protected is free to be left as is.
In Listing 13.11, the access to f in class Sub is OK because f is declared protected in Super and Sub is a subclass of Super.
By contrast the access to f in Other is not permitted, because Other does not inherit from Super.
In Java, the latter access would be still permitted because Other is in the same package as Sub.
A modifier of the form private[X] or protected[X] means that access is private or protected “up to” X, where X designates some enclosing package, class or singleton object.
Qualified access modifiers give you very fine-grained control over visibility.
In particular they enable you to express Java’s accessibility notions such as package private, package protected, or private up to outermost class, which are not directly expressible with simple modifiers in Scala.
But they also let you express accessibility rules that cannot be expressed in Java.
Listing 13.12 presents an example with many access qualifiers being used.
This means that this class is visible in all classes and objects that are contained in package bobsrockets.
In particular, the access to Navigator in object Vehicle is permitted, because Vehicle is contained in package launch, which is contained in bobsrockets.
On the other hand, all code outside the package bobsrockets cannot access class Navigator.
This technique is quite useful in large projects that span several packages.
It allows you to define things that are visible in several sub-packages of your project but that remain hidden from clients external to your project.
There, once a definition escapes its immediate package boundary, it is visible to the world at large.
Of course, the qualifier of a private may also be the directly enclosing package.
An example is the access modifier of guide in object Vehicle in Listing 13.12
Such an access modifier is equivalent to Java’s packageprivate access.
All qualifiers can also be applied to protected, with the same meaning as private.
That is, a modifier protected[X] in a class C allows access to the labeled definition in all subclasses of C and also within the enclosing package, class, or object X.
For instance, the useStarChart method in Listing 13.12 is accessible in all subclasses of Navigator and also in all code contained in the enclosing package navigation.
It thus corresponds exactly to the meaning of protected in Java.
The qualifiers of private can also refer to an enclosing class or object.
This gives the same access capabilities as for private members of inner classes in Java.
A private[C] where C is the outermost enclosing class is the same as just private in Java.
Thus the accesses “speed” and “this.speed” would be legal from within Navigator.
The following access, though, would not be allowed, even if it appeared inside class Navigator:
Marking a member private[this] is a guarantee that it will not be seen from other objects of the same class.
It also sometimes lets you write more general variance annotations (see Section 19.7 for details)
Each line shows a qualified private modifier and what it would mean if such a modifier were attached to the distance variable declared in class LegOfJourney in Listing 13.12
In Java, static members and instance members belong to the same class, so access modifiers apply uniformly to them.
You have already seen that in Scala there are no static members; instead you can have a companion object that contains members that exist only once.
For instance, in Listing 13.13 object Rocket is a companion of class Rocket.
Scala’s access rules privilege companion objects and classes when it comes to private or protected accesses.
A class shares all its access rights with its companion object and vice versa.
In particular, an object can access all private members of its companion class, just as a class can access all private members of its companion object.
For instance, the Rocket class above can access method fuel, which is declared private in object Rocket.
Analogously, the Rocket object can access the private method canGoHomeAgain in class Rocket.
One exception where the similarity between Scala and Java breaks down concerns protected static members.
A protected static member of a Java class C can be accessed in all subclasses of C.
By contrast, a protected member in a companion object makes no sense, as singleton objects don’t have any subclasses.
Listing 13.13: Accessing private members of companion classes and objects.
So far, the only code you have seen added to packages are classes, traits, and standalone objects.
These are by far the most common definitions that are placed at the top level of a package, but Scala doesn’t limit you to just those.
Any kind of definition that you can put inside a class, you can also put at the top level of a package.
If you have some helper method you’d like to be in scope for an entire package, go ahead and put it right at the top level of the package.
To do so, put the definitions in a package object.
Any definitions placed in a package object are considered members of the package itself.
Syntactically, a package object looks much like one of the curly-braces packagings shown earlier in the chapter.
The only difference is that it includes the object keyword.
The contents of the curly braces can include any definitions you like.
In this case, the package object includes the showFruit utility method from Listing 13.8
Given that definition, any other code in any package can import the method just like it would import a class.
For example, Listing 13.14 also shows the standalone object PrintMenu, which is located in a different package.
PrintMenu can import the utility method showFruit in the same way it would import the class Fruit.
Looking ahead, there are other uses of package objects for kinds of definitions you haven’t seen yet.
The top-level scala package has a package object, and its definitions are available to all Scala code.
Package objects are compiled to class files named package.class that are the located in the directory of the package that they augment.
It’s useful to keep the same convention for source files.
So you would typically put the source file of the package object bobsdelights of Listing 13.14 into a file named package.scala that resides in the bobsdelights directory.
In this chapter, you saw the basic constructs for dividing a program into packages.
This gives you a simple and useful kind of modularity, so that you can work with very large bodies of code without different parts of the code trampling on each other.
This system is the same in spirit as Java’s packages, but there are some differences where Scala chooses to be more consistent or more general.
Looking ahead, Chapter 29 describes a more flexible module system than division into packages.
In addition to letting you separate code into several namespaces, that approach allows modules to be parameterized and to inherit from each other.
In the next chapter, we’ll turn our attention to assertions and unit testing.
Two important ways to check that the behavior of the software you write is as you expect are assertions and unit tests.
In this chapter, we’ll show you several options you have in Scala to write and run them.
Assertions in Scala are written as calls of a predefined method assert.1 The expression assert(condition) throws an AssertionError if condition does not hold.
The expression assert(condition, explanation) tests condition, and, if it does not hold, throws an AssertionError that contains the given explanation.
The type of explanation is Any, so you can pass any object as the explanation.
The assert method will call toString on it to get a string explanation to place inside the AssertionError.
Another way you might choose to do this is to check the widths at the end of the widen method, right before you return the value.
You can accomplish this by storing the result in a val, performing an assertion on the result, then mentioning the val last so the result is returned if the assertion succeeds.
The assert method is defined in the Predef singleton object, whose members are automatically imported into every Scala source file.
The ensuring method can be used with any result type because of an implicit conversion.
Although it looks in this code as if we’re invoking ensuring on widen’s result, which is type Element, we’re actually invoking ensuring on a type to which Element is implicitly converted.
The ensuring method takes one argument, a predicate function that takes a result type and returns Boolean.
If the predicate returns true, ensuring will return the result.
The underscore is a placeholder for the one argument passed to the predicate, the Element result of the widen method.
If the width passed as w to widen is less than or equal to the width of the result Element, the predicate will result in true, and ensuring will result in the Element on which it was invoked.
Because this is the last expression of the widen method, widen itself will then result in the Element.
Assertions (and ensuring checks) can be enabled and disabled using the JVM’s -ea and -da command-line flags.
When enabled, each assertion serves as a little test that uses the actual data encountered as the software runs.
In the remainder of this chapter, we’ll focus on the writing of external unit tests, which provide their own test data and run independently from the application.
You have many options for unit testing in Scala, from established Java tools, such as JUnit and TestNG, to new tools written in Scala, such as ScalaTest, specs, and ScalaCheck.
In the remainder of this chapter, we’ll give you a quick tour of these tools.
Although ScalaTest includes a Runner application, you can also run a Suite directly from the Scala interpreter by invoking execute on it.
Trait Suite’s execute method uses reflection to discover its test methods and invokes them.
ScalaTest facilitates different styles of testing, because execute can be overridden in Suite subtypes.
For example, ScalaTest offers a trait called FunSuite, which overrides execute so that you can define tests as function values rather than methods.
You specify the name of the test as a string between the parentheses, and the test code itself between curly braces.
The test code is a function passed as a by-name parameter to test, which registers it for later execution.
One benefit of FunSuite is you need not name all your tests starting with “test”
In addition, you can more easily give long names to your tests, because you need not encode them in camel case, as you must do with test methods.2
Were this assertion to fail, you would see a message that indicated an assertion failed.
You’d be given a line number, but wouldn’t know the two values that were unequal.
You could find out by placing a string message in the assertion that includes both values, but a more concise approach is to use the triple-equals operator, which ScalaTest provides for this purpose:
The triple-equals operator does not differentiate between the actual and expected result.
It just indicates that the left operand did not equal the right operand.
If you wish to emphasize this distinction, you could alternatively use ScalaTest’s expect method, like this:
If you want to check that a method throws an expected exception, you can use ScalaTest’s intercept method, like this:
If the code between the curly braces completes abruptly with an instance of the passed exception class, intercept will return the caught exception, in case you want to inspect it further.
Most often, you’ll probably only care that the expected exception was thrown, and ignore the result of intercept, as is done in this example.
The goal of ScalaTest’s === operator and its expect and intercept methods is to help you write assertion-based tests that are clear and concise.
In the next section, we’ll show you how to use this syntax in JUnit and TestNG tests written in Scala.
The most popular unit testing framework on the Java platform is JUnit, an open source tool written by Kent Beck and Erich Gamma.
Once you compile this class, JUnit will run it like any other TestCase.
Trait JUnit3Suite extends TestCase, so once you compile this class, JUnit will run it just fine, even though it uses ScalaTest’s more concise assertion syntax.
Moreover, because JUnit3Suite mixes in ScalaTest’s trait Suite, you can alternatively run this test class with ScalaTest’s runner.
The goal is to provide a gentle migration path to enable JUnit users to start writing JUnit tests in Scala that take advantage of the conciseness afforded by Scala.
ScalaTest also has a JUnitWrapperSuite, which enables you to run existing JUnit tests written in Java with ScalaTest’s runner.
If you prefer to use ScalaTest’s assertion syntax in your TestNG tests, however, you can extend trait TestNGSuite, as shown in Listing 14.6:
As with JUnit3Suite, you can run a TestNGSuite with either TestNG or ScalaTest, and ScalaTest also provides a TestNGWrapperSuite that enables you to run existing TestNG tests written in Java with ScalaTest.
In the behavior-driven development (BDD) testing style, the emphasis is on writing human-readable specifications of the expected behavior of code, and accompanying tests that verify the code has the specified behavior.
ScalaTest includes several traits—Spec, WordSpec, FlatSpec, and FeatureSpecwhich facilitate this style of testing.
An example of a FlatSpec is shown in Listing 14.7
You start by writing a name for the subject under test as a string ("A UniformElement" in Listing 14.7), then should (or must or can), then a string that specifies a bit of behavior required of the subject, then in.
In the curly braces following in, you write code that tests the specified behavior.
When a FlatSpec is executed, it will run each specifier clause as a ScalaTest test.
FlatSpec (and ScalaTest’s other specification traits) generate output that reads more like a specification when run.
For example, here’s what the output will look like if you run ElementSpec from Listing 14.7 in the interpreter:
If the last assertion failed, you’d see an error message similar to:
The specs testing framework, an open source tool written in Scala by Eric Torreborre, also supports the BDD style of testing but with a different syntax.
For example, you could use specs to write the test shown in Listing 14.8:
You can use specs standalone, but it is also integrated with ScalaTest and JUnit, so you can run specs tests with those tools as well.3
Another useful testing tool for Scala is ScalaCheck, an open source framework written by Rickard Nilsson.
ScalaCheck enables you to specify properties that the code under test must obey.
For each property, ScalaCheck will generate test data and run tests that check whether the property holds.
Listing 14.9 show an example of using ScalaCheck from a ScalaTest WordSpec that mixes in trait Checkers:
WordSpec is a ScalaTest trait that provides syntax similar to a specs Specification.
The Checkers trait provides several check methods that allow you to mix ScalaCheck property-based tests with traditional assertion3You can download specs from http://code.google.com/p/specs/
In this example, we check two properties that the elem factory should obey.
ScalaCheck properties are expressed as function values that take as parameters the required test data, which will be generated by ScalaCheck.
In the first property shown in Listing 14.9, the test data is an integer named w that represents a width.
Inside the body of the function, you see this code:
It implies that whenever the left hand expression is true, the expression on the right must hold true.
The right-hand expression in this case will yield true if the width passed to the elem factory is the same as the width of the Element returned by the factory.
With this small amount of code, ScalaCheck will generate possibly hundreds of values for w and test each one, looking for a value for which the property doesn’t hold.
If the property holds true for every value ScalaCheck tries, the test will pass.
Otherwise, the test will complete abruptly with an AssertionError that contains information including the value that caused the failure.
Each framework mentioned in this chapter provides some mechanism for organizing and running tests.
In this section, we’ll give a quick overview of ScalaTest’s approach.
To get the full story on any of these frameworks, however, you’ll need to consult their documentation.
In ScalaTest, you organize large test suites by nesting Suites inside Suites.
When a Suite is executed, it will execute its nested Suites as well as its tests.
The nested Suites will in turn execute their nested Suites, and so on.
A large test suite, therefore, is represented as a tree of Suite objects.
When you execute the root Suite in the tree, all Suites in the tree will be executed.
To nest manually, you either override the nestedSuites method on your Suites, or pass the Suites you want to nest to the constructor of class SuperSuite, which ScalaTest provides for this purpose.
You can invoke ScalaTest’s Runner application from the command line or an ant task.
You must specify which suites you want to run, either by naming the suites explicitly or indicating name prefixes with which you want Runner to perform automatic discovery.
You can optionally specify a runpath, a list of directories and JAR files from which to load class files for the tests and the code they exercise.4 You can also specify one or more reporters, which will determine how test results will be presented.
For example, the ScalaTest distribution includes the suites that test ScalaTest itself.
You can run one of these suites, SuiteSuite,5 with the following command:
With -cp you place ScalaTest’s JAR file on the class path.
Tests can be anywhere on the runpath or classpath, but typically you would keep your tests separate from your production code, in a separate directory hierarchy that mirrors your source tree’s directory hierarchy.
SuiteSuite is so-named because it is a suite of tests that test trait Suite itself.
Scala will run this application and pass the remaining tokens as command line arguments.
Because you don’t explicitly specify a reporter, you will by default get the graphical reporter.
In this chapter you saw examples of mixing assertions directly in production code as well as writing them externally in unit tests.
You saw that as a Scala programmer, you can take advantage of popular testing tools from the Java community, such as JUnit and TestNG, as well as newer tools designed explicitly for Scala, such as ScalaTest, ScalaCheck, and specs.
Both in-code assertions and unit testing can help you achieve your software quality goals.
We felt that these techniques are important enough to justify the short detour from the Scala tutorial that this chapter represented.
In the next chapter, however, we’ll return to the language tutorial and cover a very useful aspect of Scala: pattern matching.
This chapter introduces case classes and pattern matching, twin constructs that support you when writing regular, non-encapsulated data structures.
These two constructs are particularly helpful for tree-like recursive data.
If you have programmed in a functional language before, then you will probably recognize pattern matching.
Case classes are Scala’s way to allow pattern matching on objects without requiring a large amount of boilerplate.
In the common case, all you need to do is add a single case keyword to each class that you want to be pattern matchable.
This chapter starts with a simple example of case classes and pattern matching.
It then goes through all of the kinds of patterns that are supported, talks about the role of sealed classes, discusses the Option type, and shows some non-obvious places in the language where pattern matching is used.
Finally, a larger, more realistic example of pattern matching is shown.
Before delving into all the rules and nuances of pattern matching, it is worth looking at a simple example to get the general idea.
Let’s say you need to write a library that manipulates arithmetic expressions, perhaps as part of a domain-specific language you are designing.
A first step to tackle this problem is the definition of the input data.
To keep things simple, we’ll concentrate on arithmetic expressions consisting of variables, numbers, and unary and binary operations.
This is expressed by the hierarchy of Scala classes shown in Listing 15.1
The other noteworthy thing about the declarations of Listing 15.1 is that each subclass has a case modifier.
Using the modifier makes the Scala compiler add some syntactic conveniences to your class.
First, it adds a factory method with the name of the class.
This means you can write say, Var("x") to construct a Var object instead of the slightly longer new Var("x"):
The factory methods are particularly nice when you nest them.
Because there are no noisy new keywords sprinkled throughout the code, you can take in the expression’s structure at a glance:
The second syntactic convenience is that all arguments in the parameter list of a case class implicitly get a val prefix, so they are maintained as fields:
Instead of an abstract class, we could have equally well chosen to model the root of that class hierarchy as a trait.
Modeling it as an abstract class may be slightly more efficient.
Third, the compiler adds “natural” implementations of methods toString, hashCode, and equals to your class.
They will print, hash, and compare a whole tree consisting of the class and (recursively) all its arguments.
Since == in Scala always delegates to equals, this means that elements of case classes are always compared structurally:
Finally, the compiler adds a copy method to your class for making modified copies.
This method is useful for making a new instance of the class that is the same as another one except that one or two attributes are different.
The method works by using named and default parameters (Section 8.8)
You specify the changes you’d like to make by using named parameters.
For any parameter you don’t specify, the value from the old object is used.
As an example, here is how you can make an operation just like op except that the operator has changed:
All these conventions add a lot of convenience, at a small price.
The price is that you have to write the case modifier and that your classes and objects become a bit larger.
They are larger because additional methods are generated and an implicit field is added for each constructor parameter.
However, the biggest advantage of case classes is that they support pattern matching.
Say you want to simplify arithmetic expressions of the kinds just presented.
Using pattern matching, these rules can be taken almost as they are to form the core of a simplification function in Scala, as shown in Listing 15.2
The right-hand side of simplifyTop consists of a match expression.
A pattern match includes a sequence of alternatives, each starting with the keyword case.
Each alternative includes a pattern and one or more expressions, which will be evaluated if the pattern matches.
An arrow symbol => separates the pattern from the expressions.
A match expression is evaluated by trying each of the patterns in the order they are written.
The first pattern that matches is selected, and the part following the arrow is selected and executed.
A constant pattern like "+" or 1 matches values that are equal to the constant with respect to ==
The variable then refers to that value in the right hand side of the case clause.
In this example, note that the first three examples evaluate to e, a variable that is bound within the associated pattern.
The wildcard pattern (_) also matches every value, but it does not introduce a variable name to refer to that value.
In Listing 15.2, notice how the match ends with a default case that does nothing to the expression.
Instead, it just results in expr, the expression matched upon.
This pattern matches all values of type UnOp whose first argument matches "-" and whose second argument matches e.
Note that the arguments to the constructor are themselves patterns.
This allows you to write deep patterns using a concise notation.
Imagine trying to implement this same functionality using the visitor design pattern!2 Almost as awkward, imagine implementing it as a long sequence of if statements, type tests, and type casts.
Match expressions can be seen as a generalization of Java-style switches.
A Java-style switch can be naturally expressed as a match expression where each pattern is a constant and the last pattern may be a wildcard (which represents the default case of the switch)
First, match is an expression in Scala, i.e., it always results in a value.
Second, Scala’s alternative expressions never “fall through” into the next case.
Third, if none of the patterns match, an exception named MatchError is thrown.
This means you always have to make sure that all cases are covered, even if it means adding a default case where there’s nothing to do.
The second case is necessary in Listing 15.3, because otherwise the match expression would throw a MatchError for every expr argument that is not a BinOp.
In this example, no code is specified for that second case, so if that case runs it does nothing.
The result of either case is the unit value ‘()’, which is also, therefore, the result of the entire match expression.
The previous example showed several kinds of patterns in quick succession.
The syntax of patterns is easy, so do not worry about that too much.
For instance, given the hierarchy of Listing 15.1, the pattern Var(x) matches any variable expression, binding x to the name of the variable.
Used as an expression, Var(x)—exactly the same syntax—recreates an equivalent object, assuming x is already bound to the variable’s name.
Since the syntax of patterns is so transparent, the main thing to pay attention to is just what kinds of patterns are possible.
You have already seen it used as a default, catch-all alternative, like this:
Wildcards can also be used to ignore parts of an object that you do not care about.
For example, the previous example does not actually care what the elements of a binary operation are.
It just checks whether it is a binary operation at all.
Thus the code can just as well use the wildcard pattern for the elements of the BinOp, as shown in Listing 15.4:
For example, 5, true, and "hello" are all constant patterns.
Also, any val or singleton object can be used as a constant.
For example, Nil, a singleton object, is a pattern that matches only the empty list.
Here is how the pattern match shown in Listing 15.5 looks in action:
A variable pattern matches any object, just like a wildcard.
Unlike a wildcard, Scala binds the variable to whatever the object is.
You can then use this variable to act on the object further.
For example, Listing 15.6 shows a pattern match that has a special case for zero, and a default case for all other values.
The default case uses a variable pattern so that it has a name for the value, no matter what it is.
You saw this already when we used Nil as a pattern.
As expected, E does not match Pi, so the “strange math” case is not used.
How does the Scala compiler know that Pi is a constant imported from.
To see the difference, create a lowercase alias for pi and try with that:
Here the compiler will not even let you add a default case at all.
Since pi is a variable pattern, it will match all inputs, and so no cases following it can be reached:
First, if the constant is a field of some object, you can prefix it with a qualifier.
For instance, pi is a variable pattern, but this.pi or obj.pi are constants even though they start with lowercase letters.
If that does not work (because pi is a local variable, say), you can alternatively enclose the variable name in back ticks.
For instance, `pi` would again be interpreted as a constant, not as a variable:
As you can see, the back-tick syntax for identifiers is used for two different purposes in Scala to help you code your way out of unusual circumstances.
Here you see that it can be used to treat a lowercase identifier as a constant in a pattern match.
It consists of a name (BinOp) and then a number of patterns within parentheses: "+", e, and Number(0)
Assuming the name designates a case class, such a pattern means to first check that the object is a member of the named case class, and then to check that the constructor parameters of the object match the extra patterns supplied.
These extra patterns mean that Scala patterns support deep matches.
Such patterns not only check the top-level object supplied, but also check the contents of the object against further patterns.
Since the extra patterns can themselves be constructor patterns, you can use them to check arbitrarily deep into an object.
This pattern is one line long yet checks three levels deep.
You can match against sequence types like List or Array just like you match against case classes.
Use the same syntax, but now you can specify any number of elements within the pattern.
For example, Listing 15.8 shows a pattern that checks for a three-element list starting with zero:
If you want to match against a sequence without specifying how long it can be, you can specify _* as the last element of the pattern.
This funnylooking pattern matches any number of elements within a sequence, including zero elements.
Listing 15.9 shows an example that matches any list that starts with zero, regardless of how long the list is.
A pattern like (a, b, c) matches an arbitrary 3-tuple.
If you load the tupleDemo method shown in Listing 15.10 into the interpreter, and pass to it a tuple with three elements, you’ll see:
You can use a typed pattern as a convenient replacement for type tests and type casts.
Here are a few examples of using the generalSize method in the Scala interpreter:
The generalSize method returns the size or length of objects of various types.
Its argument is of type Any, so it could be any value.
If the argument is a String, the method returns the string’s length.
The pattern “s: String” is a typed pattern; it matches every (non-null) instance of String.
Note that, even though s and x refer to the same value, the type of x is Any, but the type of s is String.
So you can write s.length in the alternative expression that corresponds to the pattern, but you could not write x.length, because the type Any does not have a length member.
An equivalent but more long-winded way that achieves the effect of a match against a typed pattern employs a type test followed by a type cast.
To test whether an expression expr has type String, say, you write:
To cast the same expression to type String, you use:
Using a type test and cast, you could rewrite the first case of the previous match expression as shown in Listing 15.12
The operators isInstanceOf and asInstanceOf are treated as predefined methods of class Any which take a type parameter in square brackets.
As you will have noted by now, writing type tests and casts is rather verbose in Scala.
You are usually better off using a pattern match with a typed pattern.
That’s particularly true if you need to do both a type test and a type cast, because both operations are then rolled into a single pattern match.
This pattern matches any value that is a Map of some arbitrary key and value types and lets m refer to that value.
Therefore, m.size is well typed and returns the size of the map.
The underscores in the type pattern are like wildcards in other patterns.
Can you also test for a map with specific element types? This would be handy, say for testing whether a given value is a map from type Int to type Int.
The interpreter emitted an “unchecked warning.” You can find out details by starting the interpreter again with the -unchecked command-line option:
Scala uses the erasure model of generics, just like Java does.
This means that no information about type arguments is maintained at runtime.
Consequently, there is no way to determine at runtime whether a given Map object has been created with two Int arguments, rather than with arguments of different types.
All the system can do is determine that a value is a Map of some arbitrary type parameters.
You can verify this behavior by applying isIntIntMap to arguments of different instances of class Map:
The first application returns true, which looks correct, but the second application also returns true, which might be a surprise.
To alert you to the possibly non-intuitive runtime behavior, the compiler emits unchecked warnings like the one shown above.
The only exception to the erasure rule is arrays, because they are handled specially in Java as well as in Scala.
The element type of an array is stored with the array value, so you can pattern match on it.
In addition to the standalone variable patterns, you can also add a variable to any other pattern.
You simply write the variable name, an at sign (@), and then the pattern.
The meaning of such a pattern is to perform the pattern match as normal, and if the pattern succeeds, set the variable to the matched object just as with a simple variable pattern.
As an example, Listing 15.13 shows a pattern match that looks for the absolute value operation being applied twice in a row.
Such an expression can be simplified to only take the absolute value one time.
If the entire pattern match succeeds, then the portion that matched the UnOp("abs", _) part is made available as variable e.
As the code is written, e then gets returned as is.
However, you can re-formulate the match with a pattern guard, as shown in Listing 15.14:
A pattern guard comes after a pattern and starts with an if.
The guard can be an arbitrary boolean expression, which typically refers to variables in the pattern.
If a pattern guard is present, the match succeeds only if the guard evaluates to true.
Hence, the first case above would only match binary operations with two equal operands.
Patterns are tried in the order in which they are written.
The version of simplify shown in Listing 15.15 presents an example where the order of the cases matters:
The version of simplify shown in Listing 15.15 will apply simplification rules everywhere in an expression, not just at the top, as simplifyTop did.
It can be derived from simplifyTop by adding two more cases for general unary and binary expressions (cases four and five in Listing 15.15)
In this example, it is important that the catch-all cases come after the more specific simplification rules.
If you wrote them in the other order, then the catch-all case would be run in favor of the more specific rules.
In many cases, the compiler will even complain if you try.
For example, here’s a match expression that won’t compile because the first case will match anything that would be matched by the second case:
Whenever you write a pattern match, you need to make sure you have covered all of the possible cases.
Sometimes you can do this by adding a default case at the end of the match, but that only applies if there is a sensible default behavior.
What do you do if there is no default? How can you ever feel safe that you covered all the cases?
In fact, you can enlist the help of the Scala compiler in detecting missing combinations of patterns in a match expression.
To be able to do this, the compiler needs to be able to tell which are the possible cases.
In general, this is impossible in Scala, because new case classes can be defined at any time and in arbitrary compilation units.
For instance, nothing would prevent you from adding a fifth case class to the Expr class hierarchy in a different compilation unit from the one where the other four cases are defined.
The alternative is to make the superclass of your case classes sealed.
A sealed class cannot have any new subclasses added except the ones in the same file.
This is very useful for pattern matching, because it means you only need to worry about the subclasses you already know about.
If you match against case classes that inherit from a sealed class, the compiler will flag missing combinations of patterns with a warning message.
Therefore, if you write a hierarchy of classes intended to be pattern matched, you should consider sealing them.
Simply put the sealed keyword in front of the class at the top of the hierarchy.
Programmers using your class hierarchy will then feel confident in pattern matching against it.
The sealed keyword, therefore, is often a license to pattern match.
Listing 15.16 shows an example in which Expr is turned into a sealed class.
Now define a pattern match where some of the possible cases are left out:
Such a warning tells you that there’s a risk your code might produce a MatchError exception because some possible patterns (UnOp, BinOp) are not handled.
The warning points to a potential source of runtime faults, so it is usually a welcome help in getting your program right.
However, at times you might encounter a situation where the compiler is too picky in emitting the warning.
For instance, you might know from the context that you will only ever apply the describe method above to expressions that are either Numbers or Vars.
So you know that in fact no MatchError will be produced.
To make the warning go away, you could add a third catch-all case to the method, like this:
You will probably not be very happy that you were forced to add code that will never be executed (or so you think), just to make the compiler shut up.
A more lightweight alternative is to add an @unchecked annotation to the selector expression of the match.
In general, you can add an annotation to an expression in the same way you add a type: follow the expression with a colon and the name of the annotation (preceded by an at sign)
The @unchecked annotation has a special meaning for pattern matching.
If a match’s selector expression carries this annotation, exhaustivity checking for the patterns that follow will be suppressed.
Scala has a standard type named Option for optional values.
It can be of the form Some(x) where x is the actual value.
Or it can be the None object, which represents a missing value.
Optional values are produced by some of the standard operations on Scala’s collections.
For instance, the get method of Scala’s Map produces Some(value) if a value corresponding to a given key has been found, or None if the given key is not defined in the Map.
The most common way to take optional values apart is through a pattern match.
Compare this to the dominant idiom in Java of using null to indicate no value.
This approach works for Java, but is error prone, because it is difficult in practice to keep track of which variables in a program are allowed to be null.
If a variable is allowed to be null, then you must remember to check it for null every time you use it.
Because such exceptions may not happen very often, it can be difficult to discover the bug during testing.
For Scala, the approach would not work at all, because it is possible to store value types in hash maps, and null is not a legal element for a value type.
For instance, a HashMap[Int, Int] cannot return null to signify “no element.”
By contrast, Scala encourages the use of Option to indicate an optional value.
This approach to optional values has several advantages over Java’s.
First, it is far more obvious to readers of code that a variable whose type is Option[String] is an optional String than a variable of type String, which may sometimes be null.
If a variable is of type Option[String] and you try to use it as a String, your Scala program will not compile.
Patterns are allowed in many parts of Scala, not just in standalone match expressions.
Take a look at some other places you can use patterns.
Any time you define a val or a var, you can use a pattern instead of a simple identifier.
For example, you can use this to take apart a tuple and assign each of its parts to its own variable, as shown in Listing 15.17:
This construct is quite useful when working with case classes.
If you know the precise case class you are working with, then you can deconstruct it with a pattern.
A sequence of cases (i.e., alternatives) in curly braces can be used anywhere a function literal can be used.
Essentially, a case sequence is a function literal, only more general.
Instead of having a single entry point and list of parameters, a case sequence has multiple entry points, each with their own list of parameters.
Each case is an entry point to the function, and the parameters are specified with the pattern.
The body of each entry point is the right-hand side of the case.
The first case matches a Some, and returns the number inside the Some.
The second case matches a None, and returns a default value of zero.
It passes a pattern match directly to the react method:
One other generalization is worth noting: a sequence of cases gives you a partial function.
If you apply such a function on a value it does not support, it will generate a run-time exception.
For example, here is a partial function that returns the second element of a list of integers:
When you compile this, the compiler will correctly complain that the match is not exhaustive:
This function will succeed if you pass it a three-element list, but not if you pass it an empty list:
If you want to check whether a partial function is defined, you must first tell the compiler that you know you are working with partial functions.
The type List[Int] => Int includes all functions from lists of integers to integers, whether or not the functions are partial.
Here is the second function again, this time written with a partial function type:
Partial functions have a method isDefinedAt, which can be used to test whether the function is defined at a particular value.
In this case, the function is defined for any list that has at least two elements:
This translation takes effect whenever the declared type of a function literal is PartialFunction.
If the declared type is just Function1, or is missing, the function literal is instead translated to a complete function.
In general, you should try to work with complete functions whenever possible, because using partial functions allows for runtime errors that the compiler cannot help you with.
You might be sure that an unhandled value will never be supplied.
Alternatively, you might be using a framework that expects partial functions and so will always check isDefinedAt before calling the function.
An example of the latter is the react example given above, where the argument is a partially defined function, defined precisely for those messages that the caller wants to handle.
You can also use a pattern in a for expression, as shown in Listing 15.18
This for expression retrieves all key/value pairs from the capitals map.
Each pair is matched against the pattern (country, city), which defines the two variables country and city.
The pair pattern shown in Listing 15.18 was special because the match against it can never fail.
Indeed, capitals yields a sequence of pairs, so you can be sure that every generated pair can be matched against a pair pattern.
But it is equally possible that a pattern might not match a generated value.
Listing 15.19 shows an example where that is the case:
After having learned the different forms of patterns, you might be interested in seeing them applied in a larger example.
The proposed task is to write an expression formatter class that displays an arithmetic expression in a twodimensional layout.
Divisions such as “x / (x + 1)” should be printed vertically, by placing the numerator on top of the denominator, like this:
We’ll also use the Expr family of case classes you saw previously in this chapter, and place both Chapter 10’s layout library and this chapter’s expression formatter into named packages.
A useful first step is to concentrate on horizontal layout.
Note that parentheses are mandatory around x + y, but would be optional around (x + y) * z.
To keep the layout as legible as possible, your goal should be to omit parentheses wherever they are redundant, while ensuring that all necessary parentheses are present.
To know where to put parentheses, the code needs to know about the relative precedence of each operator, so it’s a good idea to tackle this first.
You could express the relative precedence directly as a map literal of the following form:
However, this would involve some amount of pre-computation of precedences on your part.
A more convenient approach is to just define groups of operators of increasing precedence and then calculate the precedence of each operator from that.
It is calculated using a for expression with two generators.
The first generator produces every index i of the opGroups array.
For each such operator the for expression yields an association from the operator op to its index i.
Hence, the relative position of an operator in the array is taken to be its precedence.
Associations are written with an infix arrow, e.g., op -> i.
So far you have seen associations only as part of map constructions, but they are also values in their own right.
In fact, the association op -> i is nothing else but the pair (op, i)
Now that you have fixed the precedence of all binary operators except /, it makes sense to generalize this concept to also cover unary operators.
The precedence of a unary operator is higher than the precedence of every binary operator.
The precedence of a fraction is treated differently from the other operators because fractions use vertical layout.
After these preparations, you are ready to write the main format method.
This method takes two arguments: an expression e, of type Expr, and the precedence enclPrec of the operator directly enclosing the expression e (if there’s no enclosing operator, enclPrec should be zero)
The method yields a layout element that represents a two-dimensional array of characters.
Listing 15.21 shows the remainder of class ExprFormatter, which includes three methods.
The first method, stripDot, is a helper method.The next method, the private format method, does most of the work to format expressions.
The last method, also named format, is the lone public method in the library, which takes an expression to format.
The private format method does its work by performing a pattern match on the kind of expression.
If the expression is a variable, the result is an element formed from the variable’s name.
If the expression is a number, the result is an element formed from the number’s value.
The stripDot function cleans up the display of a floating-point number by stripping any ".0" suffix from a string.
If the expression is a unary operation UnOp(op, arg) the result is formed from the operation op and the result of formatting the argument arg with the highest-possible environment precedence.3 This means that if arg is a binary operation (but not a fraction) it will always be displayed in parentheses.
The value of unaryPrecedence is the highest possible precedence, because it was initialized to one more than the precedence of the * and % operators.
If the expression is a fraction, an intermediate result frac is formed by placing the formatted operands left and right on top of each other, separated by an horizontal line element.
The width of the horizontal line is the maximum of the widths of the formatted operands.
This intermediate result is also the final result unless the fraction appears itself as an argument of another fraction.
In the latter case, a space is added on each side of frac.
To see the reason why, consider the expression “(a / b) / c”
The problem with this layout is evident—it’s not clear where the top-level fractional bar is.
The expression above could mean either “(a / b) / c” or “a / (b / c)”
To disambiguate, a space should be added on each side to the layout of the nested fraction “a / b”
To format such a binary operation, one needs to format first its operands left and right.
The precedence parameter for formatting the left operand is the precedence opPrec of the operator op, while for the right operand it is one more than that.
This scheme ensures that parentheses also reflect the correct associativity.
The intermediate result oper is then formed by placing the formatted left and right operands sideby-side, separated by the operator.
If the precedence of the current operator is smaller than the precedence of the enclosing operator, r is placed between parentheses, otherwise it is returned as is.
The only remaining method is the public format method, which allows client programmers to format a top-level expression without passing a precedence argument.
Note that, even though this program does not define a main method, it is still a runnable application because it inherits from the Application trait.
As mentioned in Section 4.5, trait Application simply defines an empty main method that gets inherited by the Express object.
The actual work in the Express object gets done as part of the object’s initialization, before the main method is run.
That’s why you can apply this trick only if your program does not take any command-line arguments.
Once there are arguments, you need to write the main method explicitly.
In this chapter, you learned about Scala’s case classes and pattern matching in detail.
Using them, you can take advantage of several concise idioms not normally available in object-oriented languages.
Scala’s pattern matching goes further than this chapter describes, however.
In the next chapter, however, we’ll turn our attention to lists.
Lists are probably the most commonly used data structure in Scala programs.
It presents many common operations that can be performed on lists.
It also teaches some important design principles for programs working on lists.
You saw lists already in the preceding chapters, so you know that a list containing the elements 'a', 'b', and 'c' is written List('a', 'b', 'c')
Lists are quite similar to arrays, but there are two important differences.
That is, elements of a list cannot be changed by assignment.
Second, lists have a recursive structure (i.e., a linked list),1
Like arrays, lists are homogeneous: the elements of a list all have the same type.
The type of a list that has elements of type T is written List[T]
For instance, here are the same four lists with explicit types added:
This means that for each pair of types S and T, if S is a subtype of T, then List[S] is a subtype of List[T]
This is natural because every list of strings can also be seen as a list of objects.2
You saw in Section 11.3 that Nothing is the bottom type in Scala’s class hierarchy.
Because lists are covariant, it follows that List[Nothing] is a subtype of List[T], for any type T.
So the empty list object, which has type List[Nothing], can also be seen as an object of every other list type of the form List[T]
All lists are built from two fundamental building blocks, Nil and :: (pronounced “cons”)
The infix operator, ::, expresses list extension at the front.
Chapter 19 gives more details on covariance and other kinds of variance.
Hence, the previous list values could also have been defined as follows:
Because it ends in a colon, the :: operation associates to the right: A :: B :: C is interpreted as A :: (B :: C)
Therefore, you can drop the parentheses in the previous definitions.
All operations on lists can be expressed in terms of the following three:
The head and tail methods are defined only for non-empty lists.
When selected from an empty list, they throw an exception.
As an example of how lists can be processed, consider sorting the elements of a list of numbers into ascending order.
One simple way to do so is insertion sort, which works as follows: To sort a non-empty list x :: xs, sort the.
Expressed as Scala code, the insertion sort algorithm looks like:
The pattern List(a, b, c) matches lists of length 3, and binds the three elements to the pattern variables a, b, and c.
If you don’t know the number of list elements beforehand, it’s better to match with :: instead.
For instance, the pattern a :: b :: rest matches lists of length 2 or greater:
The “cons” pattern x :: xs is a special case of an infix operation pattern.
You know already that, when seen as an expression, an infix operation is equivalent to a method call.
For patterns, the rules are different: When seen as a pattern, an infix operation such as p op q is equivalent to op(p, q)
That is, the infix operator op is treated as a constructor pattern.
In particular, a cons pattern such as x :: xs is treated as ::(x, xs)
This hints that there should be a class named :: that corresponds to the pattern constructor.
It is named scala.:: and is exactly the class that builds nonempty lists.
So :: exists twice in Scala, once as a name of a class in package scala, and again as a method in class List.
The effect of the method :: is to produce an instance of the class scala.::
Taking lists apart with patterns is an alternative to taking them apart with the basic methods head, tail, and isEmpty.
For instance, here’s insertion sort again, this time written with pattern matching:
Often, pattern matching over lists is clearer than decomposing them with methods, so pattern matching should be a part of your list processing toolbox.
This is all you need to know about lists in Scala to be able to use them correctly.
However, there are also a large number of methods that capture common patterns of operations over lists.
These methods make list processing programs more concise and often clearer.
The next two sections present the most important methods defined in the List class.
This section explains most first-order methods defined in the List class.
A method is first-order if it does not take any functions as arguments.
The section also introduces by means of two examples some recommended techniques to structure programs that operate on lists.
An operation similar to :: is list concatenation, written ‘:::’
The result of xs ::: ys is a new list that contains all the elements of xs, followed by all the elements of ys.
Concatenation (:::) is implemented as a method in class List.
It would also be possible to implement concatenation “by hand,” using pattern matching on lists.
It’s instructive to try to do that yourself, because it shows a common way to implement algorithms using lists.
First, we’ll settle on a signature for the concatenation method, which we’ll call append.
In order not to mix things up too much, assume that append is defined outside the List class.
So it will take the two lists to be concatenated as parameters.
These two lists must agree on their element type, but that element type can be arbitrary.
This can be expressed by giving append a type parameter3 that represents the element type of the two input lists:
To design the implementation of append, it pays to remember the “divide and conquer” design principle for programs over recursive data structures such as lists.
Many algorithms over lists first split an input list into simpler cases using a pattern match.
If the result is a non-empty list, some of its parts may be constructed by recursive invocations of the same algorithm.
To apply this principle to the implementation of the append method, the first question to ask is on which list to match.
This is less trivial in the case of append than for many other methods because there are two choices.
However, the subsequent “conquer” phase tells you that you need to construct a list consisting of all elements of both input lists.
Since lists are constructed from the back towards the front, ys can remain intact whereas xs will need to be taken apart and prepended to ys.
Thus, it makes sense to concentrate on xs as a source for a pattern match.
The most common pattern match over lists simply distinguishes an empty from a non-empty list.
So this gives the following outline of an append method:
All that remains is to fill in the two places marked with “??”
The first such place is the alternative where the input list xs is empty.
The second place left open is the alternative where the input list xs consists of some head x followed by a tail xs1
In this case the result is also a nonempty list.
To construct a non-empty list you need to know what the head and the tail of that list should be.
You know that the first element of the result list is x.
As for the remaining elements, these can be computed by appending the rest of the first list, xs1, to the second list ys.
The computation of the second alternative illustrated the “conquer” part of the divide and conquer principle: Think first what the shape of the desired output should be, then compute the individual parts of that shape, using recursive invocations of the algorithm where appropriate.
On lists, unlike arrays, length is a relatively expensive operation.
It needs to traverse the whole list to find its end and therefore takes time proportional to the number of elements in the list.
The result of the two tests are equivalent, but the second one is slower, in particular if the list xs is long.
You know already the basic operations head and tail, which respectively take the first element of a list, and the rest of the list except the first element.
They each have a dual operation: last returns the last element of a (nonempty) list, whereas init returns a list consisting of all elements except the last one:
Like head and tail, these methods throw an exception when applied to an empty list:
Unlike head and tail, which both run in constant time, init and last need to traverse the whole list to compute their result.
They therefore take time proportional to the length of the list.
It’s a good idea to organize your data so that most accesses are at the head of a list, rather than the last element.
If at some point in the computation an algorithm demands frequent accesses to the end of a list, it’s sometimes better to reverse the list first and work with the result instead.
Note that, like all other list operations, reverse creates a new list rather than changing the one it operates on.
Since lists are immutable, such a change would not be possible, anyway.
To verify this, check that the original value of abcde is unchanged after the reverse operation:
The reverse, init, and last operations satisfy some laws that can be used for reasoning about computations and for simplifying programs.
Reverse could be implemented using concatenation (:::), like in the following method, rev:
However, this method is less efficient than one would hope for.
To study the complexity of rev, assume that the list xs has length n.
List concatenation xs ::: ys takes time proportional to the length of its first argument xs.
The drop and take operations generalize tail and init in that they return arbitrary prefixes or suffixes of a list.
The expression “xs take n” returns the first n elements of the list xs.
If n is greater than xs.length, the whole list xs is returned.
The operation “xs drop n” returns all elements of the list xs except the first n ones.
If n is greater than xs.length, the empty list is returned.
The splitAt operation splits the list at a given index, returning a pair of two lists.4 It is defined by the equality:
Random element selection is supported through the apply method; however it is a less common operation for lists than it is for arrays.
As for all other types, apply is implicitly inserted when an object appears in the function position in a method call, so the line above can be shortened to:
One reason why random element selection is less popular for lists than for arrays is that xs(n) takes time proportional to the index n.
In fact, apply is simply defined by a combination of drop and head:
This definition also makes clear that list indices range from 0 up to the length of the list minus one, the same as for arrays.
The indices method returns a list consisting of all valid indices of a given list:
The flatten method takes a list of lists and flattens it out to a single list:
It can only be applied to lists whose elements are all lists.
Trying to flatten any other list will give a compilation error:
The zip operation takes two lists and forms a list of pairs:
If the two lists are of different length, any unmatched elements are dropped:
A useful special case is to zip a list with its index.
This is done most efficiently with the zipWithIndex method, which pairs every element of a list with the position where it appears in the list.
Any list of tuples can also be changed back to a tuple of lists by using the unzip method:
The zip and unzip methods provide one way to operate on multiple lists together.
See Section 16.9, later in the chapter, for a way that is sometimes more concise.
The toString operation returns the canonical string representation of a list:
If you want a different representation you can use the mkString method.
The operation xs mkString (pre, sep, post) involves four operands: the list xs to be displayed, a prefix string pre to be displayed in front of all elements, a separator string sep to be displayed between successive elements, and a postfix string post to be displayed at the end.
The mkString method has two overloaded variants that let you drop some or all of its arguments.
There are also variants of the mkString methods called addString which append the constructed string to a StringBuilder object,5 rather than returning them as a result:
The mkString and addString methods are inherited from List’s super trait Traversable, so they are applicable to all other collections, as well.
To convert data between the flat world of arrays and the recursive world of lists, you can use method toArray in class List and toList in class Array:
There’s also a method copyToArray, which copies list elements to successive array positions within some destination array.
You must ensure that the destination array arr is large enough to hold the list in full.
Finally, if you need to access list elements via an iterator, you can use the iterator method:
The insertion sort presented earlier is concise to write, but it is not very efficient.
Its average complexity is proportional to the square of the length of the input list.
The fast track This example provides another illustration of the divide and conquer principle and currying, as well as a useful discussion of algorithmic complexity.
If you prefer to move a bit faster on your first pass through this book, however, you can safely skip to Section 16.7
Merge sort works as follows: First, if the list has zero or one elements, it is already sorted, so the list can be returned unchanged.
Longer lists are split into two sub-lists, each containing about half the elements of the original list.
Each sub-list is sorted by a recursive call to the sort function, and the resulting two sorted lists are then combined in a merge operation.
For a general implementation of merge sort, you want to leave open the type of list elements to be sorted, and also want to leave open the function to be used for the comparison of elements.
You obtain a function of maximal generality by passing these two items as parameters.
The complexity of msort is order (n log(n)), where n is the length of the input list.
To see why, note that splitting a list in two and merging two sorted lists each take time proportional to the length of the argument list(s)
Each recursive call of msort halves the number of elements in its input, so there are about log(n) consecutive recursive calls until the base case of lists of length 1 is reached.
However, for longer lists each call spawns off two further calls.
Adding everything up we obtain that at each of the log(n) call levels, every element of the original lists takes part in one split operation and in one merge operation.
Hence, every call level has a total cost proportional to n.
Since there are log(n) call levels, we obtain an overall cost proportional to n log(n)
That cost does not depend on the initial distribution of elements.
This property makes merge sort an attractive algorithm for sorting lists.
The msort function is a classical example of the currying concept discussed in Section 9.3
Currying makes it easy to specialize the function for particular comparison functions.
The intSort variable refers to a function that takes a list of integers and sorts them in numerical order.
As described in Section 8.6, an underscore stands for a missing argument list.
As another example, here’s how you could define a function that sorts a list of integers in reverse numerical order:
Because you provided the comparison function already via currying, you now need only provide the list to sort when you invoke the intSort or reverseIntSort functions.
Some examples are: transforming every element of a list in some way, verifying whether a property holds for all elements of a list, extracting from a list elements satisfying a certain criterion, or combining the elements of a list using some operator.
In Java, such patterns would usually be expressed by idiomatic combinations of for or while loops.
In Scala, they can be expressed more concisely and directly using higher-order operators,6 which are implemented as methods in class List.
The operation xs map f takes as operands a list xs of type List[T] and a function f of type T => U.
It returns the list resulting from applying the function f to each list element in xs.
By higher-order operators, we mean higher-order functions used in operator notation.
As mentioned in Section 9.1, higher-order functions are functions that take other functions as parameters.
The flatMap operator is similar to map, but it takes a function returning a list of elements as its right operand.
It applies the function to each list element and returns the concatenation of all function results.
The difference between map and flatMap is illustrated in the following example:
You see that where map returns a list of lists, flatMap returns a single list in which all element lists are concatenated.
List.range is a utility method that creates a list of all integers in some range.
The map in this expression generates a list of tuples (i, j) where j < i.
Note that the same list can alternatively be constructed with a for expression:
Unlike map and flatMap, however, foreach takes a procedure (a function with result type Unit) as right operand.
The result of the operation itself is again Unit; no list of results is assembled.
As an example, here is a concise way of summing up all numbers in a list:
The operation “xs filter p” takes as operands a list xs of type List[T] and a predicate function p of type T => Boolean.
It yields the list of all elements x in xs for which p(x) is true.
The partition method is like filter, but it returns a pair of lists.
One list contains all elements for which the predicate is true, while the other list contains all elements for which the predicate is false.
The find method is also similar to filter but it returns the first element satisfying a given predicate, rather than all such elements.
The operation xs find p takes a list xs and a predicate p as operands.
If there is an element x in xs for which p(x) is true, Some(x) is returned.
Otherwise, p is false for all elements, and None is returned.
The takeWhile and dropWhile operators also take a predicate as their right operand.
The operation xs takeWhile p takes the longest prefix of list xs such that every element in the prefix satisfies p.
Analogously, the operation xs dropWhile p removes the longest prefix from list xs such that every element in the prefix satisfies p.
The span method combines takeWhile and dropWhile in one operation, just like splitAt combines take and drop.
It returns a pair of two lists, defined by the equality:
The operation xs forall p takes as arguments a list xs and a predicate p.
Its result is true if all elements in the list satisfy p.
Conversely, the operation xs exists p returns true if there is an element in xs that satisfies the predicate p.
For instance, to find out whether a matrix represented as a list of lists has a row with only zeroes as elements:
Another common kind of operation combines the elements of a list with some operator.
A fold left operation “(z /: xs) (op)” involves three objects: a start value z, a list xs, and a binary operation op.
The result of the fold is op applied between successive elements of the list prefixed by z.
To concatenate all words in a list of strings with spaces between them and in front, you can write this:
To remove the space, you can use this slight variation:
The /: operator produces left-leaning operation trees (its syntax with the slash rising forward is intended to be a reflection of that)
The operator has :\ as an analog that produces right-leaning trees.
It involves the same three operands as fold left, but the first two appear in reversed order: The first operand is the list to fold, the second is the start value.
For associative operations, fold left and fold right are equivalent, but there might be a difference in efficiency.
Consider for instance an operation corresponding to the flatten method, which concatenates all elements in a list of lists.
This could be implemented with either fold left or fold right:
Note that both versions of flatten require a type annotation on the empty list that is the start value of the fold.
This is due to a limitation in Scala’s type inferencer, which fails to infer the correct type of the list automatically.
If you try to leave out the annotation, you get the following:
Lastly, although the /: and :\ operators have the advantage that the direction of the slash resembles the graphical depiction of their respective left or right-leaning trees, and the associativity of the colon character places the start value in the same position in the expression as it is in the tree, some may find the resulting code less than intuitive.
If you prefer, you can alternatively use the methods named foldLeft and foldRight, which are also defined on class List.
Earlier in the chapter you saw an implementation of method reverse, named rev, whose running time was quadratic in the length of the list to be reversed.
Here is now a different implementation of reverse that has linear cost.
The idea is to use a fold left operation based on the following scheme:
It only remains to fill in the startvalue and operation parts.
In fact, you can try to deduce these parts from some simple examples.
To deduce the correct value of startvalue, you can start with the smallest possible list, List(), and calculate as follows:
To deduce the second operand, you can pick the next smallest list as an example case.
You know already that startvalue is List(), so you can calculate as follows:
Hence, operation(List(), x) equals List(x), which can also be written as x :: List()
This suggests taking as operation the :: operator with its operands exchanged.
This operation is sometimes called “snoc,” in reference to ::, which is called cons.
Again, the type annotation in List[T]() is necessary to make the type inferencer work.
Hence, the complexity of reverseLeft is linear, as hoped for.
The operation xs sortWith before, where “xs” is a list and “before” is a function that can be used to compare two elements, sorts the elements of list xs.
The expression x before y should return true if x should come before y in the intended ordering for the sort.
Note that sortWith performs a merge sort similar to the msort algorithm shown in the last section, but sortWith is a method of class List whereas msort was defined outside lists.
So far, all operations you have seen in this chapter are implemented as methods of class List, so you invoke them on individual list objects.
There are also a number of methods in the globally accessible object scala.List, which is the companion object of class List.
Some of these operations are factory methods that create lists.
Others are operations that work on lists of some specific shape.
Both kinds of methods will be presented in this section.
The range method, which you saw briefly earlier in the chapter in the discussion of map and flatmap, creates a list consisting of a range of numbers.
Its simplest form is List.range(from, until), which creates a list of all numbers starting at from and going up to until minus one.
So the end value, until, does not form part of the range.
There’s also a version of range that takes a step value as third parameter.
This operation will yield list elements that are step values apart, starting at from.
The fill method creates a list consisting of zero or more copies of the same element.
It takes two parameters: the length of the list to be created, and the element to be repeated.
If fill is given more than two arguments, then it will make multidimensional lists.
That is, it will make lists of lists, lists of lists of lists, etc.
The tabulate method creates a list whose elements are computed according to a supplied function.
Its arguments are just like those of List.fill: the first argument list gives the dimensions of the list to create, and the second describes the elements of the list.
The only difference is that instead of the elements being fixed, they are computed from a function:
The lists to be concatenated are supplied as direct arguments to concat:
The zipped method on tuples generalizes several common operations to work on multiple lists instead of just one.
The map method for two zipped lists maps pairs of elements rather than individual elements.
One pair is for the first element of each list, another pair is for the second element of each list, and so on—as many pairs as the lists are long.
Notice that the third element of the second list is discarded.
The zipped method zips up only as many elements as appear in all the lists together.
They are just like the single-list versions of those methods except they operate on elements from multiple lists instead of just one:
The fast track In the next (and final) section of this chapter, we provide insight into Scala’s type inference algorithm.
One difference between the previous uses of sortWith and msort concerns the admissible syntactic forms of the comparison function.
Of course, you could also use the first, longer form of comparison with sortWith.
To understand why, you need to know some details of Scala’s type inference algorithm.
In a method application m(args), the inferencer first checks whether the method m has a known type.
If it has, that type is used to infer the expected type of the arguments.
Since the parameter types of the function arguments are thus known, they need not be written explicitly.
The type of msort is a curried, polymorphic method type that takes an argument of type (T, T) => Boolean to a function from List[T] to List[T] where T is some as-yet unknown type.
The msort method needs to be instantiated with a type parameter before it can be applied to its arguments.
Because the precise instance type of msort in the application is not yet known, it cannot be used to infer the type of its first argument.
The type inferencer changes its strategy in this case; it first type checks method arguments to determine the proper instance type of the method.
One way to resolve the problem is to pass an explicit type parameter to msort, as in:
Because the correct instance type of msort is now known, it can be used to infer the type of the arguments.
Another possible solution is to rewrite the msort method so that its parameters are swapped:
What has happened is that the inferencer used the known type of the first parameter abcde to determine the type parameter of msortSwapped.
Generally, when tasked to infer the type parameters of a polymorphic method, the type inferencer consults the types of all value arguments in the first parameter list but no arguments beyond that.
Since msortSwapped is a curried method with two parameter lists, the second argument (i.e., the function value) did not need to be consulted to determine the type parameter of the method.
This inference scheme suggests the following library design principle: When designing a polymorphic method that takes some non-function arguments and a function argument, place the function argument last in a curried parameter list by its own.
That way, the method’s correct instance type can be inferred from the non-function arguments, and that type can in turn be used to type check the function argument.
The net effect is that users of the method will be able to give less type information and write function literals in more compact ways.
Now to the more complicated case of a fold operation.
Why is there the need for an explicit type parameter in an expression like the body of the flattenRight method shown on page 367?
The type of the fold-right operation is polymorphic in two type variables.
The type of xs must be a list of some arbitrary type A, say xs: List[A]
The start value z can be of some other type B.
The operation op must then take two arguments of type A and B and must return a result of type B, i.e., op: (A, B) => B.
Because the type of z is not related to the type of the list xs, type inference has no context information for z.
Now consider the expression in the erroneous version of flattenRight, also shown on page 367:
The start value z in this fold is an empty list, List(), so without additional type information its type is inferred to be a List[Nothing]
Hence, the inferencer will infer that the B type of the fold is List[Nothing]
This is indeed a possible type for the operation in that fold but it is not a very useful one! It says that the operation always takes an empty list as second argument and always produces an empty list as result.
In other words, the type inference settled too early on a type for List(), it should have waited until it had seen the type of the operation op.
So the (otherwise very useful) rule to only consider the first argument section in a curried method application for determining the method’s type is at the root of the problem here.
On the other hand, even if that rule were relaxed, the inferencer still could not come up with a type for op because its parameter types are not given.
Hence, there is a Catch-22 situation that can only be resolved by an explicit type annotation from the programmer.
This example highlights some limitations of the local, flow-based type inference scheme of Scala.
It is not present in the more global HindleyMilner style of type inference used in functional languages such as ML or Haskell.
However, Scala’s local type inference deals much more gracefully with object-oriented subtyping than the Hindley-Milner style does.
Fortunately, the limitations show up only in some corner cases, and are usually easily fixed by adding an explicit type annotation.
Adding type annotations is also a useful debugging technique when you get confused by type error messages related to polymorphic methods.
If you are unsure what caused a particular type error, just add some type arguments or other type annotations, which you think are correct.
Then you should be able to quickly see where the real problem is.
Now you have seen many ways to work with lists.
You have seen the basic operations like head and tail, the first-order operations like reverse, the higher-order operations like map, and the utility methods in the List object.
Along the way, you learned a bit about how Scala’s type inference works.
Lists are a real work horse in Scala, so you will benefit from knowing how to use them.
For that reason, this chapter has delved deeply into how to use lists.
Lists are just one kind of collection that Scala supports, however.
The next chapter is broad, rather than deep, and shows you how to use a variety of Scala’s collection types.
This chapter gives a tour of the most commonly used collection types and operations, showing just the parts you will use most frequently.
Sequences types let you work with groups of data lined up in order.
Because the elements are ordered, you can ask for the first element, second element, 103rd element, and so on.
In this section, we’ll give you a quick tour of the most important sequences.
Perhaps the most important sequence type to know about is class List, the immutable linked-list described in detail in the previous chapter.
Lists support fast addition and removal of items to the beginning of the list, but they do not provide fast access to arbitrary indexes because the implementation must iterate through the list linearly.
Here’s a short example showing how to initialize a list and access its head and tail:
Lists will also be discussed in Chapter 22, which provides insight into how lists are implemented in Scala.
Arrays allow you to hold a sequence of elements and efficiently access an element at an arbitrary position, both to get or update the element, with a zero-based index.
Here’s how you create an array whose size you know, but for which you don’t yet know the element values:
Here’s how you initialize an array when you do know the element values:
As mentioned previously, arrays are accessed in Scala by placing an index in parentheses, not square brackets as in Java.
Here’s an example of both accessing and updating an array element:
Scala arrays are represented in the same way as Java arrays.
So, you can seamlessly use existing Java methods that return arrays.1
The difference in variance of Scala and Java’s arrays—i.e., whether Array[String] is a subtype of Array[AnyRef]—will be discussed in Section 19.3
You have seen arrays in action many times in previous chapters.
Several examples of iterating through the elements of an array with a for expression are shown in Section 7.3
Class List provides fast access to the head of the list, but not the end.
Thus, when you need to build a list by appending to the end, you should consider building the list backwards by prepending elements to the front, then when you’re done, calling reverse to get the elements in the order you need.
Another alternative, which avoids the reverse operation, is to use a ListBuffer.
You append elements with the += operator, and prepend them with the +=: operator.
When you’re done building, you can obtain a List by invoking toList on the ListBuffer.
Another reason to use ListBuffer instead of List is to prevent the potential for stack overflow.
If you can build a list in the desired order by.
You’ll see ListBuffer being used in this way in Section 22.2
An ArrayBuffer is like an array, except that you can additionally add and remove elements from the beginning and end of the sequence.
All Array operations are available, though they are a little slower due to a layer of wrapping in the implementation.
The new addition and removal operations are constant time on average, but occasionally require linear time due to the implementation needing to allocate a new array to hold the buffer’s contents.
To use an ArrayBuffer, you must first import it from the mutable collections package:
When you create an ArrayBuffer, you must specify a type parameter, but need not specify a length.
The ArrayBuffer will adjust the allocated space automatically as needed:
You can append to an ArrayBuffer using the += method:
For example, you can ask an ArrayBuffer its length, or you can retrieve an element by its index:
One other sequence to be aware of is StringOps, which implements many sequence methods.
Because Predef has an implicit conversion from String to StringOps, you can treat any string like a sequence.
In this example, the exists method is invoked on the string named s in the hasUpperCase method body.
Because no method named “exists” is declared in class String itself, the Scala compiler will implicitly convert s to StringOps, which has the method.
The exists method treats the string as a sequence of characters, and will return true if any of the characters are upper case.2
In this section, we’ll give more insight into their use and show you a few more examples.
As mentioned previously, the Scala collections library offers both mutable and immutable versions of sets and maps.
As these diagrams show, the simple names Set and Map are used by three traits each, residing in different packages.
By default when you write “Set” or “Map” you get an immutable object.
If you want the mutable variant, you need to do an explicit import.
Scala gives you easier access to the immutable variants, as a gentle encouragement to prefer them over their mutable counterparts.
The easy access is provided via the Predef object, which is implicitly imported into every Scala source file.
The “type” keyword is used in Predef to define Set and Map as aliases for the longer fully qualified names of the immutable set and map traits.3
The vals named Set and Map are initialized to refer to the singleton objects for the immutable Set and Map.
This holds both for the Map type and Map object.
If you want to use both mutable and immutable sets or maps in the same source file, one approach is to import the name of the package that contains the mutable variants:
You can continue to refer to the immutable set as Set, as before, but can now refer to the mutable set as mutable.Set.
The type keyword will be explained in more detail in Section 20.6
The key characteristic of sets is that they will ensure that at most one of each object, as determined by ==, will be contained in the set at any one time.
As an example, we’ll use a set to count the number of different words in a string.
The split method on String can separate a string into words, if you specify spaces and punctuation as word separators.
The regular expression “[ !,.]+” will suffice: it indicates the string should be split at each place that one or more space and/or punctuation characters exist:
To count the distinct words, you can convert them to the same case and then add them to a set.
Because sets exclude duplicates, each distinct word will appear exactly one time in the set.
First, you can create an empty set using the empty method provided on the Set companion objects:
Then, just iterate through the words with a for expression, convert each word to lower case, and add it to the mutable set with the += operator:
Thus, the text contained exactly three distinct words: spot, run, and see.
The most commonly used methods on both mutable and immutable sets are shown in Table 17.1
Maps let you associate a value with each element of the collection.
Using a map looks similar to using an array, except that instead of indexing with.
Note that when you create a map, you must specify two types.
The first type is for the keys of the map, the second for the values.
In this case, the keys are strings and the values are integers.
Setting entries in a map looks similar to setting entries in an array:
Likewise, reading a map is similar to reading an array:
Putting it all together, here is a method that counts the number of times each word occurs in a string:
Given these counts, you can see that this text talks a lot about running, but not so much about seeing.
The way this code works is that a mutable map, named counts, maps each word to the number of times it occurs in the text.
For each word in the text, the word’s old count is looked up, that count is incremented by one, and the new count is saved back into counts.
Note the use of contains to check whether a word has been seen yet or not.
Many of the most commonly used methods on both mutable and immutable maps are shown in Table 17.2
The implementations provided by these factories use a fast lookup algorithm, usually involving a hash table, so they can quickly decide whether or not an object is in the collection.
The story for immutable sets and maps is a bit more involved.
For sets with fewer than five elements, a special class devoted exclusively to sets of each particular size is used, to maximize performance.
Once you request a set that has five or more elements in it, however, the factory method will return an implementation that uses hash tries.
As with sets, for immutable maps with fewer than five elements, a special class devoted exclusively to maps of each particular size is used, to maximize performance.
Once a map has five or more key-value pairs in it, however, an immutable HashMap is used.
On occasion you may need a set or map whose iterator returns elements in a particular order.
For this purpose, the Scala collections library provides traits SortedSet and SortedMap.
These traits are implemented by classes TreeSet and TreeMap, which use a red-black tree to keep elements (in the case of TreeSet) or keys (in the case of TreeMap) in order.
The order is determined by the Ordered trait, which the element type of the set, or key type of the map, must either mix in or be implicitly convertible to.
For some problems, mutable collections work better, and for others, immutable collections work better.
When in doubt, it is better to start with an immutable collection and change it later if you need to, because immutable collections can be easier to reason about than mutable ones.
It can also sometimes be worthwhile to go the opposite way.
If you find some code that uses mutable collections becoming complicated and hard to reason about, consider whether it would help to change some of the collections to immutable alternatives.
In particular, if you find yourself worrying about making copies of mutable collections in just the right places, or thinking a lot about who “owns” or “contains” a mutable collection, consider switching some of the collections to their immutable counterparts.
Besides being potentially easier to reason about, immutable collections can usually be stored more compactly than mutable ones if the number of elements stored in the collection is small.
An empty immutable Map is a single object that’s shared between all references, so referring to it essentially costs just a single pointer field.
Given that many collections are small, switching them to be immutable can give important space savings and performance advantages.
To make it easier to switch from immutable to mutable collections, and vice versa, Scala provides some syntactic sugar.
Even though immutable sets and maps do not support a true += method, Scala gives a useful alternate interpretation to +=
Whenever you write a += b, and a does not support a method named +=, Scala will try interpreting it as a = a + b.
For example, immutable sets do not support a += operator:
First, a new collection will be created, and then people will be reassigned to refer to the new collection:
After this series of statements, the people variable refers to a new immutable set, which contains the added string, "Bob"
The same idea applies to any method ending in =, not just the += method.
Here’s the same syntax used with the -= operator, which removes an element from a set, and the ++= operator, which adds a collection of elements to a set:
To see how this is useful, consider again the following Map example from Section 1.1:
If you want to try using mutable collections instead, all that is necessary is to import the mutable version of Map, thus overriding the default import of the immutable Map:
Not all examples are quite that easy to convert, but the special treatment of methods ending in an equals sign will often reduce the amount of code that needs changing.
By the way, this syntactic treatment works on any kind of value, not just collections.
For example, here it is being used on floating-point numbers:
The effect of this expansion is similar to Java’s assignment operators +=, -=, *=, etc., but it is more general because every operator ending in = can be converted.
As you’ve seen previously, the most common way to create and initialize a collection is to pass the initial elements to a factory method on the companion object of your chosen collection.
You just place the elements in parentheses after the companion object name, and the Scala compiler will transform that to an invocation of an apply method on that companion object:
Although most often you can let the Scala compiler infer the element type of a collection from the elements passed to its factory method, sometimes you may want to create a collection but specify a different type from the one the compiler would choose.
The problem here is that stuff was given an element type of Int.
If you want it to have an element type of Any, you need to say so explicitly by putting the element type in square brackets, like this:
Another special situation is if you want to initialize a collection with another collection.
For example, imagine you have a list, but you want a TreeSet containing the elements in the list.
You cannot pass the colors list to the factory method for TreeSet:
Instead, you’ll need to create an empty TreeSet[String] and add to it the elements of the list with the TreeSet’s ++ operator:
If you need to initialize a list or array with another collection, on the other hand, it is quite straightforward.
As you’ve seen previously, to initialize a new list with another collection, simply invoke toList on that collection:
Note that although the original colors list was not sorted, the elements in the list produced by invoking toList on the TreeSet are in alphabetical order.
When you invoke toList or toArray on a collection, the order of the elements in the resulting list or array will be the same as the order of elements produced by an iterator obtained by invoking elements on that collection.
Because a TreeSet[String]’s iterator will produce strings in alphabetical order, those strings will appear in alphabetical order in the list resulting from invoking toList on that TreeSet.
Keep in mind, however, that conversion to lists or arrays usually requires copying all of the elements of the collection, and thus may be slow for large collections.
Sometimes you need to do it, though, due to an existing API.
Further, many collections only have a few elements anyway, in which case there is only a small speed penalty.
Another situation that arises occasionally is the need to convert a mutable set or map to an immutable one, or vice versa.
To accomplish this, you can use the technique shown on the previous page to initialize a TreeSet with the elements of a list.
Create a collection of the new type using the empty method and then add the new elements using either ++ or ++=, whichever is appropriate for the target collection type.
Here’s how you’d convert the immutable TreeSet from the previous example to a mutable set, and back again to an immutable one:
You can use the same technique to convert between mutable and immutable maps:
Unlike an array or list, a tuple can hold objects with different types.
Here is an example of a tuple holding an integer, a string, and the console:
Tuples save you the tedium of defining simplistic data-heavy classes.
Even though defining a class is already easy, it does require a certain minimum effort, which sometimes serves no purpose.
Tuples save you the effort of choosing a name for the class, choosing a scope to define the class in, and choosing names for the members of the class.
Because tuples can combine objects of different types, tuples do not inherit from Traversable.
If you find yourself wanting to group exactly one integer and exactly one string, then you want a tuple, not a List or Array.
A common application of tuples is returning multiple values from a method.
For example, here is a method that finds the longest word in a collection and also returns its index:
The longestWord function here computes two items: word, the longest word in the array, and idx, the index of that word.
To keep things simple, the function assumes there is at least one word in the list, and it breaks ties by choosing the word that comes earlier in the list.
Once the function has chosen which word and index to return, it returns both of them together using the tuple syntax (word, idx)
Additionally, you can assign each element of the tuple to its own variable,5 like this:
By the way, if you leave off the parentheses you get a different result:
Each variable is initialized with its own evaluation of the expression on the right-hand side.
That the expression evaluates to a tuple in this case does not matter.
Both variables are initialized to the tuple in its entirety.
See Chapter 18 for some examples where multiple definitions are convenient.
As a note of warning, tuples are almost too easy to use.
Tuples are great when you combine data that has no meaning beyond “an A and a B.” However, whenever the combination has some meaning, or you want to add some.
For example, do not use a 3-tuple for the combination of a month, a day, and a year.
It makes your intentions explicit, which both clears up the code for human readers and gives the compiler and language opportunities to help you catch mistakes.
This chapter has given an overview of the Scala collections library and the most important classes and traits in it.
With this foundation you should be able to work effectively with Scala collections, and know where to look in Scaladoc when you need more information.
For now, in the next chapter, we’ll turn our attention from the Scala library back to the language and discuss Scala’s support for mutable objects.
In previous chapters, we put the spotlight on functional (immutable) objects.
We did so because the idea of objects without any mutable state deserves to be better known.
However, it is also perfectly possible to define objects with mutable state in Scala.
Such stateful objects often come up naturally when you want to model objects in the real world that change over time.
This chapter explains what stateful objects are, and what Scala provides in terms of syntax to express them.
The second part of this chapter introduces a larger case study on discrete event simulation, which involves stateful objects as well as building an internal domain specific language (DSL) for defining digital circuits to simulate.
You can observe the principal difference between a purely functional object and a stateful one even without looking at the object’s implementation.
When you invoke a method or dereference a field on some purely functional object, you will always get the same result.
This is the case even if there is an arbitrary number of operations on the list cs between the point where it is defined and the point where the access cs.head is made.
For a stateful object, on the other hand, the result of a method call or field access may depend on what operations were previously performed on the.
A good example of a stateful object is a bank account.
The BankAccount class defines a private variable, bal, and three public methods: balance returns the current balance; deposit adds a given amount to bal; and withdraw tries to subtract a given amount from bal while assuring that the remaining balance won’t be negative.
The return value of withdraw is a Boolean indicating whether the requested funds were successfully withdrawn.
Even if you know nothing about the inner workings of the BankAccount class, you can still tell that BankAccounts are stateful objects:
Note that the two final withdrawals in the previous interaction returned different results.
The first withdraw operation returned true because the bank account contained sufficient funds to allow the withdrawal.
The second operation, although the same as the first one, returned false, because the balance of the account had been reduced so that it no longer covered the requested funds.
So, clearly bank accounts have mutable state, because the same operation can return different results at different times.
You might think that the statefulness of BankAccount is immediately apparent because it contains a var definition.
State and vars usually go hand in hand, but things are not always so clear-cut.
For instance, a class might be stateful without defining or inheriting any vars because it forwards method calls to other objects that have mutable state.
The reverse is also possible: A class might contain vars and still be purely functional.
An example would be a class that caches the result of an expensive operation in a field for optimization purposes.
To pick an example, assume the following unoptimized class Keyed with an expensive operation computeKey:
Provided that computeKey neither reads nor writes any vars, you can make Keyed more efficient by adding a cache:
Using MemoKeyed instead of Keyed can speed up things, because the second time the result of the computeKey operation is requested, the value stored in the keyCache field can be returned instead of running computeKey once again.
But except for this speed gain, the behavior of class Keyed and MemoKeyed is exactly the same.
Consequently, if Keyed is purely functional, then so is MemoKeyed, even though it contains a reassignable variable.
You can perform two fundamental operations on a reassignable variable: get its value or set it to a new value.
In libraries such as JavaBeans, these operations are often encapsulated in separate getter and setter methods, which need to be defined explicitly.
In Scala, every var that is a non-private member of some object implicitly defines a getter and a setter method with it.
These getters and setters are named differently from the Java convention, however.
The getter of a var x is just named “x”, while its setter is named “x_=”
For example, if it appears in a class, the var definition:
The field is always marked private[this], which means it can be accessed only from the object that contains it.
The getter and setter, on the other hand, get the same visibility as the original var.
If the var definition is public, so are its getter and setter, if it is protected they are also protected, and so on.
For instance, consider the class Time shown in Listing 18.2, which defines two public vars named hour and minute:
This implementation is exactly equivalent to the class definition shown in Listing 18.3
In the definitions shown in Listing 18.3, the names of the local fields h and m are arbitrarily chosen so as not to clash with any names already in use.
Some languages have a special syntactic construct for these variablelike quantities that are not plain variables in that their getter or setter can be redefined.
Scala’s convention of always interpreting a variable as a pair of setter and getter methods gives you in effect the same capabilities as C# properties without.
In the example shown in Listing 18.4, the setters enforced an invariant, thus protecting the variable from being assigned illegal values.
You could also use a property to log all accesses to getters or setters of a variable.
Or you could integrate variables with events, for instance by notifying some subscriber methods each time a variable is modified (you’ll see examples of this in Chapter 35)
It is also possible, and sometimes useful, to define a getter and a setter without an associated field.
An example is the following class Thermometer, which encapsulates a temperature variable that can be read and updated.
The class below allows you to get and set the temperature in either measure.
The first line in the body of this class defines a var, celsius, which will contain the temperature in degrees Celsius.
The celsius variable is initially set to a default value by specifying ‘_’ as the “initializing value” of the variable.
More precisely, an initializer “= _” of a field assigns a zero value to that field.
It is 0 for numeric types, false for booleans, and null for reference types.
This is the same as if the same variable was defined in Java without an initializer.
Note that you cannot simply leave off the “= _” initializer in Scala.
The celsius variable definition is followed by a getter, “fahrenheit”, and a setter, “fahrenheit_=”, which access the same temperature, but in degrees Fahrenheit.
There is no separate field that contains the current temperature value in Fahrenheit.
Instead the getter and setter methods for Fahrenheit values automatically convert from and to degrees Celsius, respectively.
The rest of this chapter shows by way of an extended example how stateful objects can be combined with first-class function values in interesting ways.
You’ll see the design and implementation of a simulator for digital circuits.
This task is decomposed into several subproblems, each of which is interesting individually: First, you’ll see a little language for digital circuits.
The definition of this language will highlight a general method for embedding domain-specific languages in a host language like Scala.
Second, we’ll present a simple but general framework for discrete event simulation.
The main task of this framework will be to keep track of actions that are performed in simulated time.
Finally, we’ll show how discrete simulation programs can be structured and built.
The idea of such simulations is to model physical objects by simulated objects, and to use the simulation framework to model physical time.
The example is taken from the classic textbook Structure and Interpretation of Computer Programs by Abelson and Sussman [Abe96]
What’s different here is that the implementation language is Scala instead of Scheme, and that the various aspects of the example are structured into four software.
Each layer is expressed as a class, and more specific layers inherit from more general ones.
The fast track Understanding the discrete event simulation example presented in this chapter will take some time.
If you feel you want to get on with learning more Scala instead, it’s safe to skip ahead to the next chapter.
We’ll start with a “little language” to describe digital circuits.
A digital circuit is built from wires and function boxes.
Signals are represented by booleans: true for signal-on and false for signal-off.
An and-gate, which sets its output to the conjunction of its inputs.
An or-gate, which sets its output to the disjunction of its inputs.
These gates are sufficient to build all other function boxes.
Gates have delays, so an output of a gate will change only some time after its inputs change.
We’ll describe the elements of a digital circuit by the following set of Scala classes and functions.
Second, there are three procedures which “make” the basic gates we need:
What’s unusual, given the functional emphasis of Scala, is that these procedures construct the gates as a side-effect, instead of returning the constructed gates as a result.
For instance, an invocation of inverter(a, b) places an inverter between the wires a and b.
It turns out that this side-effecting construction makes it easier to construct complicated circuits gradually.
Also, although methods most often have verb names, these have noun names that indicate which gate they are making.
This reflects the declarative nature of the DSL: it should describe a circuit, not the actions of making one.
More complicated function boxes can be built from the basic gates.
For instance, the method shown in Listing 18.6 constructs a half-adder.
A diagram of the half-adder is shown in Figure 18.2
Note that halfAdder is a parameterized function box just like the three methods that construct the primitive gates.
Class Wire and functions inverter, andGate, and orGate represent a little language with which users can define digital circuits.
It’s a good example of an internal DSL, a domain specific language defined as a library in a host language instead of being implemented on its own.
The implementation of the circuit DSL still needs to be worked out.
Since the purpose of defining a circuit in the DSL is simulating the circuit, it makes sense to base the DSL implementation on a general API for discrete event simulation.
The next two sections will present first the simulation API and then the implementation of the circuit DSL on top of it.
Concrete simulation libraries inherit this class and augment it with domain-specific functionality.
The elements of the Simulation class are presented in this section.
A discrete event simulation performs user-defined actions at specified times.
The actions, which are defined by concrete simulation subclasses, all share a common type:
This statement defines Action to be an alias of the type of procedure that takes an empty parameter list and returns Unit.
You can think of it as a more readable name for type () => Unit.
Type members will be described in detail in Section 20.6
The time at which an action is performed is simulated time; it has nothing to do with the actual “wall clock” time.
The current simulated time is kept in a private variable:
The variable has a public accessor method, which retrieves the current time:
This combination of private variable with public accessor is used to make sure that the current time cannot be modified outside the Simulation class.
After all, you don’t usually want your simulation objects to manipulate the current time, except possibly if your simulation models time travel.
An action that needs to be executed at a specified time is called a work item.
We made the WorkItem class a case class because of the syntactic conveniences this entails: you can use the factory method, WorkItem, to create instances of the class, and you get accessors for the constructor parameters time and action for free.
Note also that class WorkItem is nested inside class Simulation.
The Simulation class keeps an agenda of all remaining work items that have not yet been executed.
The work items are sorted by the simulated time at which they have to be run:
The agenda list will be kept in the proper sorted order by the insert method, which updates it.
You can see insert being called from afterDelay, which is the only way to add a work item to the agenda:
As the name implies, this method inserts an action (given by block) into the agenda so that it is scheduled for execution delay time units after the current simulation time.
For instance, the following invocation would create a new work item to be executed at the simulated time, currentTime + delay:
The code to be executed is contained in the method’s second argument.
The formal parameter for this argument has type “=> Unit”, i.e., it is a computation of type Unit which is passed by name.
Recall that by-name parameters are not evaluated when passed to a method.
So in the call above, count would be incremented only when the simulation framework calls the action stored in the work item.
It’s a good example of the principle set forward in Section 9.5 that currying can be used to make method calls look more like built-in syntax.
The created work item still needs to be inserted into the agenda.
This is done by the insert method, which maintains the invariant that the agenda is time-sorted:
The core of the Simulation class is defined by the run method:
This method repeatedly takes the first item in the agenda, removes it from the agenda and executes it.
It does this until there are no more items left in the agenda to execute.
Each step is performed by calling the next method, which is defined as follows:
The next method decomposes the current agenda with a pattern match into a front item, item, and a remaining list of work items, rest.
It removes the front item from the current agenda, sets the simulated time curtime to the work item’s time, and executes the work item’s action.
Note that next can be called only if the agenda is non-empty.
There’s no case for an empty list, so you would get a MatchError exception if you tried to run next on an empty agenda.
In fact, the Scala compiler would normally warn you that you missed one of the possible patterns for a list:
In this case, the missing case is not a problem, because you know that next is called only on a non-empty agenda.
That’s why the Simulation code uses “(agenda: @unchecked) match”, not “agenda match”
You might wonder how this framework could possibly support interesting simulations, if all it does is execute a list of work items? In fact the power of the simulation framework comes from the fact that actions stored in work items can themselves install further work items into the agenda when they are executed.
That makes it possible to have long-running simulations evolve from simple beginnings.
The next step is to use the simulation framework to implement the domainspecific language for circuits shown in Section 18.4
Recall that the circuit DSL consists of a class for wires and methods that create and-gates, orgates, and inverters.
The idea is that all action procedures attached to some wire will be executed every time the signal of the wire changes.
Typically actions are added to a wire by components connected to the wire.
An attached action is executed once at the time it is added to a wire, and after that, every time the signal of the wire changes.
The names of these “delay” methods start with a capital letter because they represent constants.
They are methods so they can be overridden in subclasses.
You’ll find out how to do the same thing with vals in Section 20.3
Two private variables make up the state of a wire.
The variable sigVal represents the current signal, and the variable actions represents the action procedures currently attached to the wire.
The only interesting method implementation is the one for setSignal: When the signal of a wire changes, the new value is stored in the variable sigVal.
The only effect of creating an inverter is that an action is installed on its input wire.
This action is invoked once at the time the action is installed, and thereafter every time the signal on the input changes.
The effect of the action is that the value of the inverter’s output value is set (via setSignal) to the inverse of its input value.
Since inverter gates have delays, this change should take effect only InverterDelay units of simulated time after the input value has changed and the action was executed.
The effect of the inverter method is to add invertAction to the input wire.
This action, when invoked, gets the input signal and installs another action that inverts the output signal into the simulation agenda.
This other action is to be executed after InverterDelay units of simulated time.
Note how the method uses the afterDelay method of the simulation framework to create a new work item that’s going to be executed in the future.
The implementation of and-gates is analogous to the implementation of inverters.
The purpose of an and-gate is to output the conjunction of its input signals.
This should happen at AndGateDelay simulated time units after any one of its two inputs changes.
This action, when invoked, gets both input signals and installs another action that sets the output signal to the conjunction of both input signals.
This other action is to be executed after AndGateDelay units of simulated time.
Note that the output has to be recomputed if either of the input wires changes.
The orGate method is implemented similarly, except it performs a logical-or instead of a logical-and.
To run the simulator, you need a way to inspect changes of signals on wires.
To accomplish this, you can simulate the action of putting a probe on a wire:
The effect of the probe procedure is to install a probeAction on a given wire.
As usual, the installed action is executed every time the wire’s signal changes.
In this case it simply prints the name of the wire (which is passed as first parameter to probe), as well as the current simulated time and the wire’s new value.
After all these preparations, it’s time to see the simulator in action.
To define a concrete simulation, you need to inherit from a simulation framework class.
This class, which we’ll call CircuitSimulation, is shown in Listing 18.11:
A concrete circuit simulation will be an object that inherits from class CircuitSimulation.
The object still needs to fix the gate delays according to the circuit implementation technology that’s simulated.
Finally, you will also need to define the concrete circuit that’s going to be simulated.
You can do these steps interactively in the Scala interpreter:
Define an object (call it MySimulation) that provides some numbers:
Because you are going to access the members of the MySimulation object repeatedly, an import of the object keeps the subsequent code shorter:
Define four wires, and place probes on two of them:
This is a consequence of the fact that every action installed on a wire is executed a first time when the action is installed.
Finally, set the signals, one after another, on the two input wires to true and run the simulation:
This chapter has brought together two techniques that seem at first disparate: mutable state and higher-order functions.
Mutable state was used to simulate physical entities whose state changes over time.
Higher-order functions were used in the simulation framework to execute actions at specified points in simulated time.
They were also used in the circuit simulations as triggers that associate actions with state changes.
Along the way, you saw a simple way to define a domain specific language as a library.
If you feel like staying a bit longer, you might want to try more simulation examples.
You can combine half-adders and full-adders to create larger circuits, or design new circuits from the basic gates defined so far and simulate them.
In the next chapter, you’ll learn about type parameterization in Scala, and see another example in which a combination of functional and imperative approaches yields a good solution.
In this chapter, we’ll explain the details of type parameterization in Scala.
Along the way we’ll demonstrate some of the techniques for information hiding introduced in Chapter 13 by means of a concrete example: the design of a class for purely functional queues.
We’re presenting type parameterization and information hiding together, because information hiding can be used to obtain more general type parameterization variance annotations.
Type parameterization allows you to write generic classes and traits.
For example, sets are generic and take a type parameter: they are defined as Set[T]
As a result, any particular set instance might be a Set[String], a Set[Int], etc.—but it must be a set of something.
Unlike Java, which allows raw types, Scala requires that you specify type parameters.
Variance defines inheritance relationships of parameterized types, such as whether a Set[String], for example, is a subtype of Set[AnyRef]
The first part develops a data structure for purely functional queues.
The second part develops techniques to hide internal representation details of this structure.
The final part explains variance of type parameters and how it interacts with information hiding.
A functional queue is a data structure with three operations:
Unlike a mutable queue, a functional queue does not change its contents when an element is appended.
Instead, a new queue is returned that contains the element.
The goal of this chapter will be to create a class, which we’ll name Queue, that works like this:
But for a functional queue, the appended value shows up only in the result, q1, not in the queue, q, being operated on.
Both are so called fully persistent data structures, where old versions remain available even after extensions or modifications.
But where a list is usually extended at the front, using a :: operation, a queue is extended at the end, using enqueue.
How can this be implemented efficiently? Ideally, a functional (immutable) queue should not have a fundamentally higher overhead than an imperative (mutable) one.
That is, all three operations head, tail, and enqueue should operate in constant time.
One simple approach to implement a functional queue would be to use a list as representation type.
Then head and tail would just translate into the same operations on the list, whereas enqueue would be concatenation.
The problem with this implementation is in the enqueue operation.
It takes time proportional to the number of elements stored in the queue.
Now enqueue is constant time, but head and tail are not.
They now take time proportional to the number of elements stored in the queue.
Looking at these two examples, it does not seem easy to come up with an implementation that’s constant time for all three operations.
In fact, it looks doubtful that this is even possible! However, by combining the two operations you can get very close.
The idea is to represent a queue by two lists, called leading and trailing.
The leading list contains elements towards the front, whereas the trailing list contains elements towards the back of the queue in reversed order.
Now, to append an element, you just cons it to the trailing list using the :: operator, so enqueue is constant time.
This means that, when an initially empty queue is constructed from successive enqueue operations, the trailing list will grow whereas the leading list will stay empty.
Then, before the first head or tail operation is performed on an empty leading list, the whole trailing list is copied to leading, reversing the order of the elements.
Listing 19.1 shows an implementation of queues that uses this approach.
What is the complexity of this implementation of queues? The mirror operation might take time proportional to the number of queue elements, but only if list leading is empty.
Because head and tail call mirror, their complexity might be linear in the size of the queue, too.
However, the longer the queue gets, the less often mirror is called.
Indeed, assume a queue of length n with an empty leading list.
Then mirror has to reverse-copy a list of length n.
However, the next time mirror will have to do any work is once the leading list is empty again, which will be the case after n tail operations.
This means you can “charge” each of these n tail operations with one n’th of the complexity.
Assuming that head, tail, and enqueue operations appear with about the same frequency, the amortized complexity is hence constant for each operation.
So functional queues are asymptotically just as efficient as mutable ones.
Now, there are some caveats that need to be attached to this argument.
First, the discussion only was about asymptotic behavior, the constant factors might well be somewhat different.
Second, the argument rested on the fact that head, tail and enqueue are called with about the same frequency.
If head is called much more often than the other two operations, the argument is not valid, as each call to head might involve a costly re-organization of the list with mirror.
The second caveat can be avoided; it is possible to design functional queues so that in a sequence of successive head operations only the first one might require a re-organization.
You will find out at the end of this chapter how this is done.
The implementation of Queue shown in Listing 19.1 is now quite good with regards to efficiency.
You might object, though, that this efficiency is paid for by exposing a needlessly detailed implementation.
The Queue constructor, which is globally accessible, takes two lists as parameters, where one is reversed—hardly an intuitive representation of a queue.
What’s needed is a way to hide this constructor from client code.
In this section, we’ll show you some ways to accomplish this in Scala.
In Java, you can hide a constructor by making it private.
In Scala, the primary constructor does not have an explicit definition; it is defined implicitly by the class parameters and body.
Nevertheless, it is still possible to hide the primary constructor by adding a private modifier in front of the class parameter list, as shown in Listing 19.2:
The private modifier between the class name and its parameters indicates that the constructor of Queue is private: it can be accessed only from within the class itself and its companion object.
The class name Queue is still public, so you can use it as a type, but you cannot call its constructor:
One possibility is to add an auxiliary constructor, like this:
The auxiliary constructor shown in the previous example builds an empty queue.
As a refinement, the auxiliary constructor could take a list of initial queue elements:
Another possibility is to add a factory method that builds a queue from such a sequence of initial elements.
A neat way to do this is to define an object Queue that has the same name as the class being defined and contains an apply method, as shown in Listing 19.3:
By placing this object in the same source file as class Queue, you make the object a companion object of the class.
You saw in Section 13.5 that a companion object has the same access rights as its class.
Because of this, the apply method in object Queue can create a new Queue object, even though the constructor of class Queue is private.
As a result, Queue looks to clients as if it was a globally defined factory method.
In reality, Scala has no globally visible methods; every method must be contained in an object or a class.
However, using methods named apply inside global objects, you can support usage patterns that look like invocations of global methods.
Private constructors and private members are one way to hide the initialization and representation of a class.
Another, more radical way is to hide the class itself and only export a trait that reveals the public interface of the.
There’s a trait Queue, which declares the methods head, tail, and enqueue.
All three methods are implemented in a subclass QueueImpl, which is itself a private inner class of object Queue.
This exposes to clients the same information as before, but using a different technique.
Instead of hiding individual constructors and methods, this version hides the whole implementation class.
Queue, as defined in Listing 19.4, is a trait, but not a type.
Queue is not a type because it takes a type parameter.
As a result, you cannot create variables of type Queue:
Thus, Queue is a trait, and Queue[String] is a type.
Queue is also called a type constructor, because with it you can construct a type by specifying a type parameter.
This is analogous to constructing an object instance with a plain-old constructor by specifying a value parameter.
The type constructor Queue “generates” a family of types, which includes Queue[Int], Queue[String], and Queue[AnyRef]
You can also say that Queue is a generic trait.
Classes and traits that take type parameters are “generic,” but the types they generate are “parameterized,” not generic.
The term “generic” means that you are defining many specific types with one generically written class or trait.
For example, trait Queue in Listing 19.4 defines a generic queue.
The combination of type parameters and subtyping poses some interesting questions.
For example, are there any special subtyping relationships between members of the family of types generated by Queue[T]? More specifically, should a Queue[String] be considered a subtype of Queue[AnyRef]?
Or more generally, if S is a subtype of type T, then should Queue[S] be considered a subtype of Queue[T]? If so, you could say that trait Queue is covariant (or “flexible”) in its type parameter T.
Or, since it just has one type parameter, you could say simply that Queues are covariant.
Covariant Queues would mean, for example, that you could pass a Queue[String] to the doesCompile method shown previously, which takes a value parameter of type Queue[AnyRef]
Intuitively, all this seems OK, since a queue of Strings looks like a special case of a queue of AnyRefs.
In Scala, however, generic types have by default nonvariant (or, “rigid”) subtyping.
That is, with Queue defined as in Listing 19.4, queues with different element types would never be in a subtype relationship.
However, you can demand covariant (flexible) subtyping of queues by changing the first line of the definition of class Queue like this:
Prefixing a formal type parameter with a + indicates that subtyping is covariant (flexible) in that parameter.
By adding this single character, you are telling Scala that you want Queue[String], for example, to be considered a subtype of Queue[AnyRef]
The compiler will check that Queue is defined in a way that this subtyping is sound.
Besides +, there is also a prefix -, which indicates contravariant subtyping.
Whether a type parameter is covariant, contravariant, or nonvariant is called the parameter’s variance.
The + and - symbols you can place next to type parameters are called variance annotations.
In a purely functional world, many types are naturally covariant (flexible)
To find out why, consider the simple type of one-element cells that can be read or written, shown in Listing 19.5
The Cell type of Listing 19.5 is declared nonvariant (rigid)
For the sake of argument, assume for a moment that Cell was declared covariant instead—i.e., it was declared class Cell[+T]—and that this passed the.
Seen by itself, each of these four lines looks OK.
The first line creates a cell of strings and stores it in a val named c1
This is OK, since Cells are assumed to be covariant.
Finally, the last line assigns the element value of c1 into a string.
Nothing strange here, as both the sides are of the same type.
But taken together, these four lines end up assigning the integer 1 to the string s.
Which operation is to blame for the runtime fault? It must be the second one, which uses covariant subtyping.
Thus, a Cell of String is not also a Cell of Any, because there are things you can do with a Cell of Any that you cannot do with a Cell of String.
You cannot use set with an Int argument on a Cell of String, for example.
In fact, were you to pass the covariant version of Cell to the Scala compiler, you would get a compile-time error:
It’s interesting to compare this behavior with arrays in Java.
In principle, arrays are just like cells except that they can have more than one element.
You can try an example analogous to the cell interaction above with Java arrays:
If you try out this example, you will find that it compiles, but executing the program will cause an ArrayStore exception to be thrown when a2[0] is assigned to an Integer:
What happens here is that Java stores the element type of the array at runtime.
Then, every time an array element is updated, the new element value is checked against the stored type.
If it is not an instance of that type, an ArrayStore exception is thrown.
You might ask why Java adopted this design, which seems both unsafe and expensive.
When asked this question, James Gosling, the principal inventor of the Java language, answered that they wanted to have a simple means to treat arrays generically.
For instance, they wanted to be able to write a method to sort all elements of an array, using a signature like the following that takes an array of Object:
Covariance of arrays was needed so that arrays of arbitrary reference types could be passed to this sort method.
Of course, with the arrival of Java generics, such a sort method can now be written with a type parameter, so the covariance of arrays is no longer necessary.
For compatibility reasons, though, it has persisted in Java to this day.
Scala tries to be purer than Java in not treating arrays as covariant.
Here’s what you get if you translate the first two lines of the array example to Scala:
What happened here is that Scala treats arrays as nonvariant (rigid), so an Array[String] is not considered to conform to an Array[Any]
However, sometimes it is necessary to interact with legacy methods in Java that use an Object array as a means to emulate a generic array.
For instance, you might want to call a sort method like the one described previously with an array of Strings as argument.
To make this possible, Scala lets you cast an array of Ts to an array of any supertype of T:
The cast is always legal at compile-time, and it will always succeed at runtime, because the JVM’s underlying run-time model treats arrays as covariant, just as Java the language does.
But you might get ArrayStore exceptions afterwards, again just as you would in Java.
Now that you have seen some examples where variance is unsound, you may be wondering which kind of class definitions need to be rejected and which can be accepted.
So far, all violations of type soundness involved some reassignable field or array element.
The purely functional implementation of queues, on the other hand, looks like a good candidate for covariance.
However, the following example shows that you can “engineer” an unsound situation even if there is no reassignable field.
To set up the example, assume that queues as defined in Listing 19.4 are covariant.
Then, create a subclass of queues that specializes the element type to Int and overrides the enqueue method:
The enqueue method in StrangeIntQueue prints out the square root of its (integer) argument before doing the append proper.
The first of these two lines is valid, because StrangeIntQueue is a subclass of Queue[Int], and, assuming covariance of queues, Queue[Int] is a subtype of Queue[Any]
The second line is valid because you can append a String to a Queue[Any]
However, taken together these two lines have the effect of applying a square root method to a string, which makes no sense.
Clearly it’s not just mutable fields that make covariant types unsound.
It turns out that as soon as a generic parameter type appears as the type of a method parameter, the containing class or trait may not be covariant in that type parameter.
Running a modified queue class like the one above through a Scala compiler would yield:
Reassignable fields are a special case of the rule that disallows type parameters annotated with + from being used as method parameter types.
As you can see, the setter method has a parameter of the field’s type T.
The fast track In the rest of this section, we’ll describe the mechanism by which the Scala compiler checks variance annotations.
If you’re not interested in such detail right now, you can safely skip to Section 19.5
The most important thing to understand is that the Scala compiler will check any variance annotations you place on type parameters.
For example, if you try to declare a type parameter to be covariant (by adding a +), but that could lead to potential runtime errors, your program won’t compile.
To verify correctness of variance annotations, the Scala compiler classifies all positions in a class or trait body as positive, negative, or neutral.
A “position” is any location in the class (or trait, but from now on we’ll just write “class”) body where a type parameter may be used.
Every method value parameter is a position, for example, because a method value parameter has a type, and therefore a type parameter could appear in that position.
The compiler checks each use of each of the class’s type parameters.
Type parameters annotated with + may only be used in positive positions, while type parameters annotated with - may only be used in negative positions.
A type parameter with no variance annotation may be used in any position, and is, therefore, the only kind of type parameter that can be used in neutral positions of the class body.
To classify the positions, the compiler starts from the declaration of a type parameter and then moves inward through deeper nesting levels.
Positions at the top level of the declaring class are classified as positive.
By default, positions at deeper nesting levels are classified the same as that at enclosing levels, but there are a handful of exceptions where the classification changes.
Method value parameter positions are classified to the flipped classification relative to positions outside the method, where the flip of a positive classification is negative, the flip of a negative classification is positive, and the flip of a neutral classification is still neutral.
Besides method value parameter positions, the current classification is also flipped at the type parameters of methods.
If C’s type parameter is annotated with a + then the classification stays the same.
If C’s type parameter is annotated with a -, then the current classification is flipped.
If C’s type parameter has no variance annotation then the current classification is changed to neutral.
The positions of the type parameter, W, and the two value parameters, volume and listener, are all negative.
Looking at the result type of meow, the position of the first Cat[U, T] argument is negative, because Cat’s first type parameter, T, is annotated with a -
The type U inside this argument is again in positive position (two flips), whereas the type T inside that argument is still in negative position.
You see from this discussion that it’s quite hard to keep track of variance positions.
That’s why it’s a welcome relief that the Scala compiler does this job for you.
Once the variances are computed, the compiler checks that each type parameter is only used in positions that are classified appropriately.
In this case, T is only used in negative positions, and U is only used in positive positions.
You saw that the previous definition of Queue[T] shown in Listing 19.4 cannot be made covariant in T because T appears as a type of a parameter of the enqueue method, and that’s a negative position.
Fortunately, there’s a way to get unstuck: you can generalize enqueue by making it polymorphic (i.e., giving the enqueue method itself a type parameter) and using a lower bound for its type parameter.
Listing 19.6 shows a new formulation of Queue that implements this idea.
The new definition gives enqueue a type parameter U, and with the syntax, “U >: T”, defines T as the lower bound for U.
As a result, U is required to be a supertype of T.1 The parameter to enqueue is now of type U instead of type T, and the return value of the method is now Queue[U] instead of Queue[T]
As an example, suppose there is a class Fruit with two subclasses, Apple and Orange.
With the new definition of class Queue, it is possible to append an Orange to a Queue[Apple]
Intuitively, if T is a more specific type than expected (for example, Apple instead of Fruit), a call to enqueue will still work, because U (Fruit) will still be a supertype of T (Apple).2
The new definition of enqueue is arguably better than the old, because it is more general.
Unlike the old version, the new definition allows you to append an arbitrary supertype U of the queue element type T.
Together with queue covariance, this gives the right kind of flexibility for modeling queues of different element types in a natural way.
This shows that variance annotations and lower bounds play well together.
They are a good example of type-driven design, where the types of an interface guide its detailed design and implementation.
In the case of queues, you would probably not have thought of the refined implementation of enqueue with a lower bound, but you might have decided to make queues covariant.
In that case, the compiler would have pointed out the variance error for enqueue.
Correcting the variance error by adding a lower bound makes enqueue more general and queues as a whole more usable.
Supertype and subtype relationships are reflexive, which means a type is both a supertype and a subtype of itself.
Even though T is a lower bound for U, you could still pass in a T to enqueue.
Technically, what happens is a flip occurs for lower bounds.
This observation is also the main reason that Scala prefers declarationsite variance over use-site variance as it is found in Java’s wildcards.
With use-site variance, you are on your own designing a class.
It will be the clients of the class that need to put in the wildcards, and if they get it wrong, some important instance methods will no longer be applicable.
Variance being a tricky business, users usually get it wrong, and they come away thinking that wildcards and generics are overly complicated.
With definition-side variance, you express your intent to the compiler, and the compiler will double check that the methods you want available will indeed be available.
So far in this chapter, all examples you’ve seen were either covariant or nonvariant.
For instance, consider the trait of output channels shown in Listing 19.7:
So an output channel of AnyRefs, say, is a subtype of an output channel of Strings.
The only supported operation is writing a String to it.
This reasoning points to a general principle in type system design: it is safe to assume that a type T is a subtype of a type U if you can substitute a value of type T wherever a value of type U is required.
The principle holds if T supports the same operations as U and all of T’s operations require less and provide more.
Sometimes covariance and contravariance are mixed in the same type.
This satisfies the Liskov substitution principle, because arguments are something that’s required, whereas results are something that’s provided.
As an example, consider the application shown in Listing 19.9
In this example, class Publication contains one parametric field, title, of type String.
Class Book extends Publication and forwards its string title parameter to the constructor of its superclass.
The Library singleton object defines a set of books and a method printBookList, which takes a function, named info, of type Book => AnyRef.
In other words, the type of the lone parameter to printBookList is a function that takes one Book argument and returns an AnyRef.
The Customer application defines a method, getTitle, which takes a Publication as its lone parameter and returns a String, the title of the passed Publication.
Now take a look at the last line in Customer.
This line invokes Library’s printBookList method and passes getTitle, wrapped in a function value:
If you look inside the body of printBookList, you can get a glimpse of why this makes sense.
The printBookList method iterates through its book list, and invokes the passed function on each book.
It passes the AnyRef result returned by info to println, which invokes toString on it and prints the result.
This activity will work with String as well as any other subclass of AnyRef, which is what covariance of function result types means.
Now consider the parameter type of the function being passed to the printBookList method.
Although printBookList’s parameter type is declared as Book, the getTitle we’re passing in takes a Publication, a supertype of Book.
The reason this works is that since printBookList’s parameter type is Book, the body of the printBookList method will only be allowed to pass a Book into the function.
And because getTitle’s parameter type is Publication, the body of that function will only be able to access on its parameter, p, members that are declared in class Publication.
Because any method declared in Publication is also available on its subclass Book, everything should work, which is what contravariance of function parameter.
Because the result type of a Function1 is defined as covariant, the inheritance relationship of the two result types, shown at the right of the diagram, is in the same direction as that of the two functions shown in the center.
By contrast, because the parameter type of a Function1 is defined as contravariant, the inheritance relationship of the two parameter types, shown at the left of the diagram, is in the opposite direction as that of the two functions.
The Queue class seen so far has a problem in that the mirror operation might repeatedly copy the trailing into the leading list if head is called several times in a row on a list where leading is empty.
The wasteful copying could be avoided by adding some judicious side effects.
Listing 19.10 presents a new implementation of Queue, which performs at most one trailing to leading adjustment for any sequence of head operations.
What’s different with respect to the previous version is that now leading and trailing are reassignable variables, and mirror performs the reverse copy from trailing to leading as a side-effect on the current queue instead of returning a new queue.
This side-effect is purely internal to the implementation of the Queue operation; since leading and trailing are private variables, the effect is not visible to clients of Queue.
So by the terminology established in Chapter 18, the new version of Queue still defines purely functional objects, in spite of the fact that they now contain reassignable fields.
You might wonder whether this code passes the Scala type checker.
Is this not a violation of the variance rules? It would be indeed, except for the detail that leading and trailing have a private[this] modifier and are thus declared to be object private.
As mentioned in Section 13.5, object private members can be accessed only from within the object in which they are defined.
It turns out that accesses to variables from the same object in which they are defined do not cause problems with variance.
The intuitive explanation is that, in order to construct a case where variance would lead to type errors, you need to have a reference to a containing object that has a statically weaker type than the type the object was defined with.
Scala’s variance checking rules contain a special case for object private.
Such definitions are omitted when it is checked that a type parameter with either a + or - annotation occurs only in positions that have the same variance classification.
On the other hand, if you had left out the [this] qualifiers from the two private modifiers, you would see two type errors:
Another way you might want to organize such a sort function is by requiring the type of the list to mix in the Ordered trait.
For example, Listing 19.11 shows Ordered being mixed into a Person class.
As a result, you can compare two persons like this:
To require that the type of the list passed to your new sort function mixes in Ordered, you need to use an upper bound.
With the “T <: Ordered[T]” syntax, you indicate that the type parameter, T, has an upper bound, Ordered[T]
This means that the element type of the list passed to orderedMergeSort must be a subtype of Ordered.
Thus, you could pass a List[Person] to orderedMergeSort, because Person mixes in Ordered.
Because the element type of this list, Person, mixes in (and is therefore a subtype of) Ordered[People], you can pass the list to orderedMergeSort:
Now, although the sort function shown in Listing 19.12 serves as a useful illustration of upper bounds, it isn’t actually the most general way in Scala to design a sort function that takes advantage of the Ordered trait.
For example, you couldn’t use the orderedMergeSort function to sort a list of integers, because class Int is not a subtype of Ordered[Int]:
In Section 21.6, we’ll show you how to use implicit parameters and view bounds to achieve a more general solution.
In this chapter you saw several techniques for information hiding: private constructors, factory methods, type abstraction, and object private members.
You also learned how to specify data type variance and what it implies for class implementation.
Finally, you saw two techniques which help in obtaining flexible variance annotations: lower bounds for method type parameters, and private[this] annotations for local fields and methods.
A member of a class or trait is abstract if the member does not have a complete definition in the class.
Abstract members are intended to be implemented in subclasses of the class in which they are declared.
Scala also lets you declare such methods, as you saw in Section 10.2
But Scala goes beyond that and implements the idea in its full generality: besides methods, you can also declare abstract fields and even abstract types as members of classes and traits.
In this chapter we’ll describe all four kinds of abstract member: vals, vars, methods, and types.
Along the way we’ll discuss pre-initialized fields, lazy vals, path-dependent types, and enumerations.
The following trait declares one of each kind of abstract member: an abstract type (T), method (transform), val (initial), and var (current):
A concrete implementation of Abstract needs to fill in definitions for each of its abstract members.
The implementation gives a concrete meaning to the type name T by defining it as an alias of type String.
The transform operation concatenates a given string with itself, and the initial and current values are both set to "hi"
This example gives you a rough first idea of what kinds of abstract members exist in Scala.
The remainder of the chapter will present the details and explain what the new forms of abstract members, as well as type members in general, are good for.
As you can see from the example in the previous section, the term abstract type in Scala means a type declared (with the “type” keyword) to be a member of a class or trait, without specifying a definition.
Classes themselves may be abstract, and traits are by definition abstract, but neither of these are what are referred to as abstract types in Scala.
An abstract type in Scala is always a member of some class or trait, such as type T in trait Abstract.
You can think of a non-abstract (or, “concrete”) type member, such as type T in class Concrete, as a way to define a new name, or alias, for a type.
In class Concrete, for example, the type String is given the alias T.
As a result, anywhere T appears in the definition of class Concrete, it means String.
This includes the parameter and result types of transform, initial, and current, which mention T when they are declared in supertrait Abstract.
Thus, when class Concrete implements these methods, those Ts are interpreted to mean String.
One reason to use a type member is to define a short, descriptive alias for a type whose real name is more verbose, or less obvious in meaning, than the alias.
Such type members can help clarify the code of a class or trait.
The other main use of type members is to declare abstract types that must.
This use, which was demonstrated in the previous section, will be described in detail later in this chapter.
It gives a name and type for a val, but not its value.
This value has to be provided by a concrete val definition in a subclass.
You use an abstract val declaration in a class when you do not know the correct value in the class, but you do know that the variable will have an unchangeable value in each instance of the class.
An abstract val declaration resembles an abstract parameterless method declaration such as:
Client code would refer to both the val and the method in exactly the same way, i.e., obj.initial.
However, if initial is an abstract val, the client is guaranteed that obj.initial will yield the same value every time it is referenced.
If initial were an abstract method, that guarantee would not hold, because in that case initial could be implemented by a concrete method that returns a different value every time it’s called.
In other words, an abstract val constrains its legal implementation: any implementation must be a val definition; it may not be a var or a def.
Abstract method declarations, on the other hand, may be implemented by both concrete method definitions and concrete val definitions.
Given the abstract class Fruit shown in Listing 20.1, class Apple would be a legal subclass implementation, but class BadApple would not.
Like an abstract val, an abstract var declares just a name and a type, but not an initial value.
For instance, Listing 20.2 shows a trait AbstractTime, which declares two abstract variables named hour and minute:
What is the meaning of abstract vars like hour and minute? You saw in Section 18.2 that vars declared as members of classes come equipped with getter and setter methods.
If you declare an abstract var named hour, for example, you implicitly declare an abstract getter method, hour, and an abstract setter method, hour_=
There’s no reassignable field to be defined—that will come in subclasses that define the concrete implementation of the abstract var.
Abstract vals sometimes play a role analogous to superclass parameters: they let you provide details in a subclass that are missing in a superclass.
This is particularly important for traits, because traits don’t have a constructor to which you could pass parameters.
So the usual notion of parameterizing a trait works via abstract vals that are implemented in subclasses.
The Rational class from Chapter 6 had two parameters: n for the numerator of the rational number, and d for the denominator.
The RationalTrait trait given here defines instead two abstract vals: numerArg and denomArg.
To instantiate a concrete instance of that trait, you need to implement the abstract val definitions.
Here the keyword new appears in front of a trait name, RationalTrait, which is followed by a class body in curly braces.
This expression yields an instance of an anonymous class that mixes in the trait and is defined by the body.
There’s a subtle difference concerning the order in which expressions are initialized.
So the values of numerArg and denomArg are not available during the initialization of RationalTrait (more precisely, a selection of either value would yield the default value for type Int, 0)
For the definition of RationalTrait given previously, this is not a problem, because the trait’s initialization does not make use of values numerArg or denomArg.
However, it does become a problem in the variant of RationalTrait shown in Listing 20.4, which defines normalized numerators and denominators:
If you try to instantiate this trait with some numerator and denominator expressions that are not simple literals, you’ll get an exception:
The exception in this example was thrown because denomArg still had its default value of 0 when class RationalTrait was initialized, which caused the require invocation to fail.
This example demonstrates that initialization order is not the same for class parameters and abstract fields.
A class parameter argument is evaluated before it is passed to the class constructor (unless the parameter is by-name)
An implementing val definition in a subclass, by contrast, is evaluated only after the superclass has been initialized.
Now that you understand why abstract vals behave differently from parameters, it would be good to know what can be done about this.
Is it possible to define a RationalTrait that can be initialized robustly, without fearing errors due to uninitialized fields? In fact, Scala offers two alternative solutions to this problem, pre-initialized fields and lazy vals.
The first solution, pre-initialized fields, lets you initialize a field of a subclass before the superclass is called.
To do this, simply place the field definition in braces before the superclass constructor call.
As an example, Listing 20.5 shows another attempt to create an instance of RationalTrait.
As you see from this example, the initialization section comes before the mention of the supertrait RationalTrait.
Pre-initialized fields are not restricted to anonymous classes; they can also be used in objects or named subclasses.
As you can see from these examples, the preinitialization section comes in each case after the extends keyword of the defined object or class.
Class RationalClass, shown in Listing 20.7, exemplifies a general schema of how class parameters can be made available for the initialization of a supertrait.
Because pre-initialized fields are initialized before the superclass constructor is called, their initializers cannot refer to the object that’s being constructed.
Consequently, if such an initializer refers to this, the reference goes to the object containing the class or object that’s being constructed, not the constructed object itself.
Once more, pre-initialized fields behave in this respect like class constructor arguments.
You can use pre-initialized fields to simulate precisely the initialization behavior of class constructor arguments.
Sometimes, however, you might prefer to let the system itself sort out how things should be initialized.
This can be achieved by making your val definitions lazy.
If you prefix a val definition with a lazy modifier, the initializing expression on the right-hand side will only be evaluated the first time the val is used.
For an example, define an object Demo with a val as follows:
As you can see, the moment you use Demo, its x field becomes initialized.
The initialization of x forms part of the initialization of Demo.
The situation changes, however, if you define the x field to be lazy:
The initialization of x will be deferred until the first time x is used.
This is similar to the situation where x is defined as a parameterless method, using a def.
However, unlike a def a lazy val is never evaluated more than once.
In fact, after the first evaluation of a lazy val the result of the evaluation is stored, to be reused when the same val is used subsequently.
Looking at this example, it seems that objects like Demo themselves behave like lazy vals, in that they are also initialized on demand, the first time they are used.
In fact an object definition can be seen as a shorthand for the definition of a lazy val with an anonymous class that describes the object’s contents.
Using lazy vals, you could reformulate RationalTrait as shown in Listing 20.8
In the new trait definition, all concrete fields are defined lazy.
Another change with respect to the previous definition of RationalTrait, shown in Listing 20.4, is that the require clause was moved from the body of the trait to the initializer of the private field, g, which computes the greatest common divisor of numerArg and denomArg.
With these changes, there’s nothing that remains to be done when LazyRationalTrait is initialized; all initialization code is now part of the right-hand side of a lazy val.
Therefore, it is safe to initialize the abstract fields of LazyRationalTrait after the class is defined.
It’s instructive to trace the sequence of initializations that lead to the string 1/2 to be printed in the code above:
First, a fresh instance of LazyRationalTrait gets created, and the initialization code of LazyRationalTrait is run.
This initialization code is empty—none of the fields of LazyRationalTrait is as yet initialized.
Next, the primary constructor of the anonymous subclass defined by the new expression is executed.
Next, the toString method is invoked on the constructed object by the interpreter, so that the resulting value can be printed.
Next, the numer field is accessed for the first time by the toString method in trait LazyRationalTrait, so its initializer is evaluated.
The initializer of numer accesses the private field, g, so g is evaluated next.
Next, the toString method accesses the value of denom, which causes denom’s evaluation.
The evaluation of denom accesses the values of denomArg and g.
Note that the definition of g comes textually after the definitions of numer and denom in class LazyRationalTrait.
Nevertheless, because all three values are lazy, g gets initialized before the initialization of numer and denom is completed.
This shows an important property of lazy vals: the textual order of their definitions does not matter, because values get initialized on demand.
Therefore, lazy vals can free you as a programmer from having to think hard how to arrange val definitions to ensure that everything is defined when it is needed.
However, this advantage holds only as long as the initialization of lazy vals neither produces side effects nor depends on them.
In the presence of side effects, initialization order starts to matter.
And then it can be quite difficult to trace in what order initialization code is run, as the previous example has demonstrated.
So lazy vals are an ideal complement to functional objects, where the order of initializations does not matter, as long as everything gets initialized eventually.
They are less well suited for code that’s predominantly imperative.
Lazy functional languages Scala is by no means the first language to have exploited the perfect match of lazy definitions and functional code.
In fact, there is a category of “lazy functional programming languages” in which every value and parameter is initialized lazily.
The best known member of this class of languages is Haskell [SPJ02]
In the beginning of this chapter, you saw, “type T”, an abstract type declaration.
The rest of this chapter discusses what such an abstract type declaration means and what it’s good for.
Like all other abstract declarations, an abstract type declaration is a placeholder for something that will be defined concretely in subclasses.
In this case, it is a type that will be defined further down the class hierarchy.
So T above refers to a type that is at yet unknown at the point where it is declared.
Here is a well-known example where abstract types show up naturally.
Suppose you are given the task of modeling the eating habits of animals.
You might start with a class Food and a class Animal with an eat method:
You might then attempt to specialize these two classes to a class of Cows that eat Grass:
However, if you tried to compile the new classes, you’d get the following compilation errors:
What happened is that the eat method in class Cow does not override the eat method in class Animal, because its parameter type is different—it’s Grass in class Cow vs.
Some people have argued that the type system is unnecessarily strict in refusing these classes.
They have said that it should be OK to specialize a parameter of a method in a subclass.
However, if the classes were allowed as written, you could get yourself in unsafe situations very quickly.
For instance, the following script would pass the type checker:
The program would compile if the restriction were eased, because Cows are Animals and Animals do have an eat method that accepts any kind of Food, including Fish.
But surely it would do a cow no good to eat a fish!
What you need to do instead is apply some more precise modeling.
Animals do eat Food, but what kind of Food each Animal eats depends on the Animal.
This can be neatly expressed with an abstract type, as shown in Listing 20.9:
With the new class definition, an Animal can eat only food that’s suitable.
What food is suitable cannot be determined at the level of the Animal class.
The type has an upper bound, Food, which is expressed by the “<: Food” clause.
This means that any concrete instantiation of SuitableFood (in a subclass of Animal) must be a subclass of Food.
For example, you would not be able to instantiate SuitableFood with class IOException.
With Animal defined, you can now progress to cows, as shown in Listing 20.10
Class Cow fixes its SuitableFood to be Grass and also defines a concrete eat method for this kind of food.
So this shows that objects in Scala can have types as members.
The word “path” here means a reference to an object.
As the term “path-dependent type” says, the type depends on the path: in general, different paths give rise to different types.
For instance, say you defined classes DogFood and Dog, like this:
If you attempted to feed a dog with food fit for a cow, your code would not compile:
Because Dog’s SuitableFood type is defined to be an alias for class DogFood, the SuitableFood types of two Dogs are in fact the same.
As a result, the Dog instance named lassie could actually eat the suitable food of a different Dog instance (which we’ll name bootsie):
A path-dependent type resembles the syntax for an inner class type in Java, but there is a crucial difference: a path-dependent type names an outer object, whereas an inner class type names an outer class.
Java-style inner class types can also be expressed in Scala, but they are written differently.
In Scala, the inner class is addressed using the expression Outer#Inner instead of Java’s Outer.Inner.
For example, imagine you instantiate two objects of type Outer, like this:
Both of these types conform to (are subtypes of) the more general type Outer#Inner, which represents the Inner class with an arbitrary outer object of type Outer.
In Scala, as in Java, inner class instances hold a reference to an enclosing outer class instance.
This allows an inner class, for example, to access members of its outer class.
Thus you can’t instantiate an inner class without in some way specifying an outer class instance.
One way to do this is to instantiate the inner class inside the body of the outer class.
In this case, the current outer class instance (referenced from this) will be used.
For example, because the type, o1.Inner, names a specific outer object, you can instantiate it:
The resulting inner object will contain a reference to its outer object, the object referenced from o1
By contrast, because the type Outer#Inner does not name any specific instance of Outer, you can’t create an instance of it:
When a class inherits from another, the first class is said to be a nominal subtype of the other one.
It’s a nominal subtype because each type has a name, and the names are explicitly declared to have a subtyping relationship.
Scala additionally supports structural subtyping, where you get a subtyping relationship simply because two types have the same members.
To get structural subtyping in Scala, use Scala’s refinement types.
Nominal subtyping is usually more convenient, so you should try nominal types first with any new design.
A name is a single short identifier and thus is more concise than an explicit listing of member types.
Further, structural subtyping is often more flexible than you want.
A widget can draw(), and a Western cowboy can draw(), but they aren’t really substitutable.
You’d typically prefer to get a compilation error if you tried to substitute a cowboy for a widget.
One is that sometimes there really is no more to a type than its members.
For example, suppose you want to define a Pasture class that can contain animals that eat grass.
Simply write the base type, Animal, followed by a sequence of members listed in curly braces.
The members in the curly braces further specifyor refine, if you will—the types of members from the base class.
Here is how you write the type, “animal that eats grass”:
Given this type, you can now write the pasture class like this:
Another place structural subtyping is helpful is if you want to group together a number of classes that were written by someone else.
For example, suppose you want to generalize the loan pattern example from Section 9.4
The original example worked only for type PrintWriter, and you might want to have it work for any type with a close method.
That is, one caller might use the routine to clean up an open file:
Another caller, meanwhile, might want to clean up an open socket:
The method performs an operation and then closes an object, so it must take two arguments: the operation and the object.
The operation is a function from any type to any other type, so using must have two type parameters as well.
This attempt almost works, but it will get a type error where close() is called.
The problem is that, as written, T can be any type at all.
To indicate that it only really supports types with close() methods, the <: notation can.
Note two small differences in this refinement type from the one for animals that eat grass.
If no base type is specified, Scala uses AnyRef automatically.
The other difference is that the close method does not appear at all in the base type.
Technically speaking, that means the second type is a structural type.
An interesting application of path-dependent types is found in Scala’s support for enumerations.
Some other languages, including Java and C#, have enumerations as a built-in language construct to define new types.
To create a new enumeration, you define an object that extends this class, as in the following example, which defines a new enumeration of Colors:
Scala lets you also shorten several successive val or var definitions with the same right-hand side.
This object definition provides three values: Color.Red, Color.Green, and Color.Blue.
But what is the type of these values? Enumeration defines an inner class named Value, and the same-named parameterless Value method returns a fresh instance of that class.
This means that a value such as Color.Red is of type Color.Value.
Color.Value is the type of all enumeration values defined in object Color.
It’s a path-dependent type, with Color being the path and Value being the dependent type.
What’s significant about this is that it is a completely new type, different from all other types.
In particular, if you would define another enumeration, such as:
Scala’s Enumeration class also offers many other features found in the enumeration designs of other languages.
You can associate names with enumeration values by using a different overloaded variant of the Value method:
You can iterate over the values of an enumeration via the set returned by the enumeration’s values method:
Values of an enumeration are numbered from 0, and you can find out the number of an enumeration value by its id method:
It’s also possible to go the other way, from a non-negative integer number to the value that has this number as id in an enumeration:
This should be enough to get you started with enumerations.
The rest of this chapter presents a case study that explains how abstract types can be used in Scala.
A typical instance of Currency would represent an amount of money in dollars, euros, yen, or some other currency.
It should be possible to do some arithmetic on currencies.
For instance, you should be able to add two amounts of the same currency.
Or you should be able to multiply a currency amount by a factor representing an interest rate.
These thoughts lead to the following first design for a currency class:
The amount of a currency is the number of currency units it represents.
This is a field of type Long so that very large amounts of money such as the market capitalization of Google or Microsoft can be represented.
It’s left abstract here, waiting to be defined when a subclass talks about concrete amounts of money.
The designation of a currency is a string that identifies it.
The toString method of class Currency indicates an amount and a designation.
Finally, there are methods +, for adding currencies, and *, for multiplying a currency with a floating-point number.
You can create a concrete currency value by supplying concrete amount and designation values, like this:
This design would be OK if all we wanted to model was a single currency such as only dollars or only euros.
But it fails once we need to deal with several currencies.
Assume you model dollars and euros as two subclasses of class currency:
The result of such an addition would be of type Currency.
But it would be a funny currency that was made up of a mix of euros and dollars.
What you want instead is a more specialized version of the + method: when implemented in class Dollar, it should take Dollar arguments and yield a Dollar result; when implemented in class Euro, it should take Euro arguments and yield a Euro result.
So the type of the addition method would change depending on which class you are in.
Nonetheless, you would like to write the addition method just once, not each time a new currency is defined.
In Scala, there’s a simple technique to deal with situations like this: if something is not known at the point where a class is defined, make it abstract in the class.
In the case of currencies, the exact argument and result type of the addition method are not known, so it is a good candidate for an abstract type.
This would lead to the following sketch of class AbstractCurrency:
The only differences from the previous situation are that the class is now called AbstractCurrency, and that it contains an abstract type Currency, which represents the real currency in question.
Each concrete subclass of AbstractCurrency would need to fix the Currency type to refer to the concrete subclass itself, thereby “tying the knot.”
For instance, here is a new version of class Dollar, which now extends class AbstractCurrency:
This design is workable, but it is still not perfect.
One problem is hidden by the ellipses that indicate the missing method definitions of + and * in class AbstractCurrency.
In particular, how should addition be implemented in this class? It’s easy enough to calculate the correct amount of the new currency as this.amount + that.amount, but how would you convert the amount into a currency of the right type? You might try something like:
One of the restrictions of Scala’s treatment of abstract types is that you can neither create an instance of an abstract type, nor have an abstract type as a.
However, you can work around this restriction using a factory method.
Instead of creating an instance of an abstract type directly, declare an abstract method that does it.
Then, wherever the abstract type is fixed to be some concrete type, you also need to give a concrete implementation of the factory method.
A design like this could be made to work, but it looks rather suspicious.
Why place the factory method inside class AbstractCurrency? This looks dubious, for at least two reasons.
First, if you have some amount of currency (say, one dollar), you also hold in your hand the ability to make more of the same currency, using code such as:
In the age of color copying this might be a tempting scenario, but hopefully not one which you would be able to do for very long without being caught.
The second problem with this code is that you can make more Currency objects if you already have a reference to a Currency object, but how do you get the first object of a given Currency? You’d need another creation method, which does essentially the same job as make.
So you have a case of code duplication, which is a sure sign of a code smell.
The solution, of course, is to move the abstract type and the factory method outside class AbstractCurrency.
You need to create another class that contains the AbstractCurrency class, the Currency type, and the make factory method.
There’s some promising recent research on virtual classes, which would allow this, but virtual classes are not currently supported in Scala.
An example concrete CurrencyZone is the US, which could be defined as:
It defines a class Dollar, which is a subclass of AbstractCurrency.
So the type of money in this zone is US.Dollar.
The US object also fixes the type Currency to be an alias for Dollar, and it gives an implementation of the make factory method to return a dollar amount.
So far, every currency was measured in a single unit: dollars, euros, or yen.
However, most currencies have subunits: for instance, in the US, it’s dollars and cents.
The most straightforward way to model cents is to have the amount field in US.Currency represent cents instead of dollars.
To convert back to dollars, it’s useful to introduce a field CurrencyUnit into class CurrencyZone, which contains the amount of one standard unit in that currency:
The US object could define the quantities Cent, Dollar, and CurrencyUnit as shown in Listing 20.11
This definition is just like the previous definition of the US object, except that it adds three new fields.
So the US object now defines the name Dollar in two ways.
The type Dollar (defined by the abstract inner class named Dollar) represents the generic name of the Currency valid in the US currency zone.
By contrast, the value Dollar (referenced from the val field named Dollar) represents a single US dollar, analogous to a one-dollar bill.
The third field definition of CurrencyUnit specifies that the standard currency unit in the US zone is the Dollar (i.e., the value Dollar, referenced from the field, not the type Dollar)
The toString method in class Currency also needs to be adapted to take subunits into account.
For instance, the sum of ten dollars and twenty three cents should print as a decimal number: 10.23 USD.
To achieve this, you could implement Currency’s toString method as follows:
The syntax of format strings passed to formatted is the same as that of Java’s String.format method.
For instance, the format string %.2f formats a number with two decimal digits.
This method returns the number of decimal digits of a decimal power minus one.
As another refinement you can add a currency conversion feature to the model.
As a first step, you could write a Converter object that contains applicable exchange rates between currencies, as shown in Listing 20.13
Then, you could add a conversion method, from, to class Currency, which converts from a given source currency into the current Currency object:
It produces its result by multiplying the amount of the other currency with the exchange rate between the other and the current currency.3
The final version of the CurrencyZone class is shown in Listing 20.14
You can test the class in the Scala command shell.
Scala uses rich wrappers, described in Section 5.9, to make formatted available.
Thus, 1.211 is the exchange rate between US cents to Japanese yen.
The first step is to import everything in this package into the command shell:
The fact that we obtain almost the same amount after three conversions implies that these are some pretty good exchange rates!
You can also add up values of the same currency:
On the other hand, you cannot add amounts of different currencies:
By preventing the addition of two values with different units (in this case, currencies), the type abstraction has done its job.
Failures to convert correctly between different units may seem like trivial bugs, but they have caused many serious systems faults.
An example is the crash of the Mars Climate Orbiter.
If units had been coded in the same way as currencies are coded in this chapter, this error would have been detected by a simple compilation run.
Instead, it caused the crash of the orbiter after a near ten-month voyage.
Scala offers systematic and very general support for object-oriented abstraction.
It enables you to not only abstract over methods, but also over values, variables, and types.
This chapter has shown how to take advantage of abstract members.
They support a simple yet effective principle for systems structuring: when designing a class, make everything that is not yet known into an abstract member.
The type system will then drive the development of your model, just as you saw with the currency case study.
It does not matter whether the unknown is a type, method, variable or value.
There’s a fundamental difference between your own code and libraries of other people: you can change or extend your own code as you wish, but if you want to use someone else’s libraries, you usually have to take them as they are.
A number of constructs have sprung up in programming languages to alleviate this problem.
Ruby has modules, and Smalltalk lets packages add to each other’s classes.
These are very powerful, but also dangerous, in that you modify the behavior of a class for an entire application, some parts of which you might not know.
These can make existing libraries much more pleasant to deal with by letting you leave out tedious, obvious details that obscure the interesting parts of your code.
Used tastefully, this results in code that is focused on the interesting, non-trivial parts of your program.
This chapter shows you how implicits work, and it presents some of the most common ways they are used.
Before delving into the details of implicit conversions, take a look at a typical example of their use.
Implicit conversions are often helpful for working with two bodies of software that were developed without each other in mind.
Each library has its own way to encode a concept that is essentially the same thing.
Implicit conversions help by reducing the number of explicit conversions that.
If Swing had been written with Scala in mind, event listeners would probably have been represented by a function type.
Callers could then use the function literal syntax as a lightweight way to specify what should happen for a certain class of events.
Since Java doesn’t have function literals, Swing uses the next best thing, an inner class that implements a one-method interface.
In the case of action listeners, the interface is ActionListener.
Without the use of implicit conversions, a Scala program that uses Swing must use inner classes just like in Java.
Here’s an example that creates a button and hooks up an action listener to it.
The action listener is invoked whenever the button is pressed, at which point it prints the string "pressed!":
The fact that this listener is an ActionListener, the fact that the callback method is named actionPerformed, and the fact that the argument is an ActionListener are all implied for any argument to addActionListener.
The only new information here is the code to be performed, namely the call to println.
Someone reading this code must have an eagle’s eye to pick through the noise and find the informative part.
A more Scala-friendly version would take a function as an argument, greatly reducing the amount of boilerplate.
The addActionListener method wants an action listener but is getting a function.
With implicit conversions, however, this code can be made to work.
The first step is to write an implicit conversion between the two types.
Here is an implicit conversion from functions to action listeners:
This is a one-argument method that takes a function and returns an action listener.
Like any other one-argument method, it can be called directly and have its result passed on to another expression:
This much is already an improvement on the version with the inner class.
Note how arbitrary amounts of boilerplate end up replaced by a function literal and a call to a method.
The way this code works is that the compiler first tries to compile it as is, but it sees a type error.
Before giving up, it looks for an implicit conversion that can repair the problem.
It tries that conversion method, sees that it works, and moves on.
The compiler works hard here so that the developer can ignore one more fiddly detail.
Action listener? Action event function? Either one will work—use the one that’s more convenient.
This section has shown you some of the power of implicit conversions, and how they let you dress up existing libraries.
In the next sections you’ll learn the rules that determine when implicit conversions are tried and how they are found.
Implicit definitions are those that the compiler is allowed to insert into a program in order to fix any of its type errors.
For example, if x + y does not type check, then the compiler might change it to convert(x) + y, where convert is some available implicit conversion.
If convert changes x into something that has a + method, then this change might fix a program so that it type checks and runs correctly.
If convert really is just a simple conversion function, then leaving it out of the source code can be a clarification.
The implicit keyword is used to mark which declarations the compiler may use as implicits.
You can use it to mark any variable, function, or object definition.
The compiler will only change x + y to convert(x) + y if convert is marked as implicit.
This way, you avoid the confusion that would result if the compiler picked random functions that happen to be in scope and inserted them as “conversions.” The compiler will only select among the definitions you have explicitly marked as implicit.
Scope Rule: An inserted implicit conversion must be in scope as a single identifier, or be associated with the source or target type of the conversion.
The Scala compiler will only consider implicit conversions that are in scope.
To make an implicit conversion available, therefore, you must in some way bring it into scope.
Moreover, with one exception, the implicit conversion must be in scope as a single identifier.
Variables and singleton objects marked implicit can be used as implicit parameters.
This use case will be described later in this chapter.
Once imported, the compiler would be free to apply it as convert(x) + y.
In fact, it is common for libraries to include a Preamble object including a number of useful implicit conversions.
Code that uses the library can then do a single “import Preamble._” to access the library’s implicit conversions.
The compiler will also look for implicit definitions in the companion object of the source or expected target types of the conversion.
For example, if you’re attempting to pass a Dollar object to a method that takes a Euro, the source type is Dollar and the target type is Euro.
You could, therefore, package an implicit conversion from Dollar to Euro in the companion object of either class, Dollar or Euro.
Here’s an example in which the implicit definition is placed in Dollar’s companion object:
In this case, the conversion dollarToEuro is said to be associated to the type Dollar.
The compiler will find such an associated conversion every time it needs to convert from an instance of type Dollar.
There’s no need to import the conversion separately into your program.
When you read code in a file, the only things you need to consider from other files are those that are either imported or are explicitly referenced through a fully qualified name.
This benefit is at least as important for implicits as for explicitly written code.
If implicits took effect system-wide, then to understand a file you would have to know about every implicit introduced anywhere in the program!
Doing so would cause compile times to increase dramatically on erroneous code, and it would increase the difference between what the programmer writes and what the program actually does.
For sanity’s sake, the compiler does not insert further implicit conversions when it is already in the middle of trying another implicit.
However, it’s possible to circumvent this restriction by having implicits take implicit parameters, which will be described later in this chapter.
Explicits-First Rule: Whenever code type checks as it is written, no implicits are attempted.
A corollary of this rule is that you can always replace implicit identifiers by explicit ones, thus making the code longer but with less apparent ambiguity.
You can trade between these choices on a case-by-case basis.
Whenever you see code that seems repetitive and verbose, implicit conversions can help you decrease the tedium.
Whenever code seems terse to the point of obscurity, you can insert conversions explicitly.
The amount of implicits you leave the compiler to insert is ultimately a matter of style.
The name of an implicit conversion matters only in two situations: if you want to write it explicitly in a method application, and for determining which implicit conversions are available at any place in the program.
To illustrate the second point, say you have an object with two implicit conversions:
In your application, you want to make use of the stringWrapper conversion, but you don’t want integers to be converted automatically to strings by means of the intToString conversion.
You can achieve this by importing only one conversion, but not the other:
In this example, it was important that the implicit conversions had names, because only that way could you selectively import one and not the other.
There are three places implicits are used in the language: conversions to an expected type, conversions of the receiver of a selection, and implicit parameters.
Implicit conversions to an expected type let you use one type in a context where a different type is expected.
For example, you might have a String and want to pass it to a method that requires an IndexedSeq[Char]
Conversions of the receiver let you adapt the receiver of a method call, i.e., the object on which a method is invoked, if the method is not applicable on the original type.
Implicit parameters, on the other hand, are usually used to provide more information to the called function about what the caller wants.
Implicit parameters are especially useful with generic functions, where the called function might otherwise know nothing at all about the type of one or more arguments.
Each of the following three sections will discuss one of these three kinds of implicits.
Implicit conversion to an expected type is the first place the compiler will use implicits.
Whenever the compiler sees an X, but needs a Y, it will look for an implicit function that converts X to Y.
For example, normally a double cannot be used as an integer, because it loses precision:
What happens here is that the compiler sees a Double, specifically 3.5, in a context where it requires an Int.
Before giving up, though, it searches for an implicit conversion from Double to Int.
In this case, it finds one: doubleToInt, because doubleToInt is in scope as a single identifier.
Outside the interpreter, you might bring doubleToInt into scope via an import or possibly through inheritance.
Instead, you marked doubleToInt as an available implicit conversion by bringing it into scope as a single identifier, and then the compiler automatically used it when it needed to convert from a Double to an Int.
Converting Doubles to Ints might raise some eyebrows, because it’s a dubious idea to have something that causes a loss in precision happen invisibly.
It makes much more sense to go the other way, from some more constrained type to a more general one.
For instance, an Int can be converted without loss of precision to a Double, so an implicit conversion from Int to Double makes sense.
The scala.Predef object, which is implicitly imported into every Scala program, defines implicit conversions that convert “smaller” numeric types to “larger” ones.
For instance, you will find in Predef the following conversion:
That’s why in Scala Int values can be stored in variables of type Double.
There’s no special rule in the type system for this; it’s just an implicit conversion that gets applied.2
Implicit conversions also apply to the receiver of a method call, the object on which the method is invoked.
First, receiver conversions allow smoother integration of a new class into an existing class hierarchy.
And second, they support writing domainspecific languages (DSLs) within the language.
The Scala compiler backend will treat the conversion specially, however, translating it to a special “i2d” bytecode.
So the compiled image is the same as in Java.
To see how it works, suppose you write down obj.doIt, and obj does not have a member named doIt.
The compiler will try to insert conversions before giving up.
In this case, the conversion needs to apply to the receiver, obj.
The compiler will act as if the expected “type” of obj were “has a member named doIt.” This “has a doIt” type is not a normal Scala type, but it is there conceptually and is why the compiler will insert an implicit conversion in this case.
As mentioned previously, one major use of receiver conversions is allowing smoother integration of new with existing types.
In particular, they allow you to enable client programmers to use instances of existing types as if they were instances of your new type.
Class Rational has two overloaded variants of the + method, which take Rationals and Ints, respectively, as arguments.
So you can either add two rational numbers or a rational number and an integer:
To allow this kind of mixed arithmetic, you need to define an implicit conversion from Int to Rational:
With the conversion in place, converting the receiver does the trick:
What happens behind the scenes here is that Scala compiler first tries to type check the expression 1 + oneHalf as it is.
This fails because Int has several + methods, but none that takes a Rational argument.
Next, the compiler searches for an implicit conversion from Int to another type that has a + method which can be applied to a Rational.
In this case, the compiler found the implicit conversion function because you entered its definition into the interpreter, which brought it into scope for the remainder of the interpreter session.
The other major use of implicit conversions is to simulate adding new syntax.
Recall that you can make a Map using syntax like this:
The preamble also defines an implicit conversion from Any to ArrowAssoc.
This “rich wrappers” pattern is common in libraries that provide syntax-like extensions to the language, so you should be ready to recognize the pattern when you see it.
Whenever you see someone calling methods that appear not to exist in the receiver class, they are probably using implicits.
Similarly, if you see a class named RichSomething, e.g., RichInt or RichBoolean, that class is likely adding syntax-like methods to type Something.
As you can now see, these rich wrappers apply more widely, often letting you get by with an internal DSL defined as a library where programmers in other languages might feel the need to develop an external DSL.
The remaining place the compiler inserts implicits is within argument lists.
The compiler will sometimes replace someCall(a) with someCall(a)(b), or new SomeClass(a) with new SomeClass(a)(b), thereby adding a missing parameter list to complete a function call.
It is the entire last curried parameter list that’s supplied, not just the last parameter.
For example, if someCall’s missing last parameter list takes three parameters, the compiler might replace someCall(a) with someCall(a)(b, c, d)
For this usage, not only must the inserted identifiers, such as b, c, and d in (b, c, d), be.
Also, suppose you have a Greeter object with a greet method, which takes two parameter lists.
The first parameter list takes a string user name, and the second parameter list takes a PreferredPrompt:
The last parameter list is marked implicit, which means it can be supplied implicitly.
But you can still provide the prompt explicitly, like this:
To let the compiler supply the parameter implicitly, you must first define a variable of the expected type, which in this case is PreferredPrompt.
You could do this, for example, in a preferences object:
If it wasn’t, the compiler would not use it to supply the missing parameter list.
It will also not use it if it isn’t in scope as a single identifier.
Once you bring it into scope via an import, however, it will be used to supply the missing parameter list:
Note that the implicit keyword applies to an entire parameter list, not to individual parameters.
Listing 21.1 shows an example in which the last parameter list of Greeter’s greet method, which is again marked implicit, has two parameters: prompt (of type PreferredPrompt) and drink (of type PreferredDrink):
Singleton object JoesPrefs in Listing 21.1 declares two implicit vals, prompt of type PreferredPrompt and drink of type PreferredDrink.
As before, however, so long as these are not in scope as single identifiers, they won’t be used to fill in a missing parameter list to greet:
You can bring both implicit vals into scope with an import:
Because both prompt and drink are now in scope as single identifiers, you can use them to supply the last parameter list explicitly, like this:
But while you work, why not enjoy a cup of tea?
And because all the rules for implicit parameters are now met, you can alternatively let the Scala compiler supply prompt and drink for you by leaving off the last parameter list:
But while you work, why not enjoy a cup of tea?
One thing to note about the previous examples is that we didn’t use String as the type of prompt or drink, even though ultimately it was a String that each of them provided through their preference fields.
Because the compiler selects implicit parameters by matching types of parameters against types of values in scope, implicit parameters usually have “rare” or “special” enough types that accidental matches are unlikely.
For example, the types PreferredPrompt and PreferredDrink in Listing 21.1 were defined solely to serve as implicit parameter types.
Another thing to know about implicit parameters is that they are perhaps most often used to provide information about a type mentioned explicitly in an earlier parameter list, similar to the type classes of Haskell.
As an example, consider the maxListUpBound function shown in Listing 21.2, which returns the maximum element of the passed list:
As mentioned at the end of Section 19.8, one weakness with this approach is that you can’t use the function with lists whose element type isn’t already a subtype of Ordered.
For example, you couldn’t use the maxListUpBound function to find the maximum of a list of integers, because class Int is not a subtype of Ordered[Int]
Another, more general way to organize maxListUpBound would be to require a separate, second argument, in addition to the List[T] argument: a function that converts a T to an Ordered[T]
In this example, the second argument, orderer, is placed in a separate argument list and marked implicit.
The orderer parameter in this example is used to describe the ordering of Ts.
In the body of maxListImpParm, this ordering is used in two places: a recursive call to maxListImpParm, and an if expression that checks whether the head of the list is larger than the maximum element of the rest of the list.
The maxListImpParm function, shown in Listing 21.3, is an example of an implicit parameter used to provide more information about a type mentioned explicitly in an earlier parameter list.
To be specific, the implicit parameter orderer, of type T => Ordered[T], provides more information about type T—in this case, how to order Ts.
Type T is mentioned in List[T], the type of parameter elements, which appears in the earlier parameter list.
Because elements must always be provided explicitly in any invocation of maxListImpParm, the compiler will know T at compile time, and can therefore determine whether an implicit definition of type T => Ordered[T] is in scope.
If so, it can pass in the second parameter list, orderer, implicitly.
This pattern is so common that the standard Scala library provides implicit “orderer” methods for many common types.
You could therefore use this maxListImpParm method with a variety of types:
In the first case, the compiler inserted an orderer function for Ints; in the second case, for Doubles; in the third case, for Strings.
A style rule for implicit parameters As a style rule, it is best to use a custom named type in the types of implicit parameters.
For example, the types of prompt and drink in the previous example was not String, but PreferredPrompt and PreferredDrink, respectively.
As a counterexample, consider that the maxListImpParm function could just as well have been written with the following type signature:
To use this version of the function, though, the caller would have to supply an orderer parameter of type (T, T) => Boolean.
This is a fairly generic type that includes any function from two Ts to a Boolean.
It does not indicate anything at all about what the type is for; it could be an equality test, a lessthan test, a greater-than test, or something else entirely.
The actual code for maxListImpParm, given in Listing 21.3, shows better style.
It uses an orderer parameter of type T => Ordered[T]
The word Ordered in this type indicates exactly what the implicit parameter is used for: it is for ordering elements of T.
Because this orderer type is more explicit, it becomes no trouble to add implicit conversions for this type in the standard library.
To contrast, imagine the chaos that would ensue if you added an implicit of type (T, T) => Boolean in the standard library, and the compiler started sprinkling it around in people’s code.
You would end up with code that compiles and runs, but that does fairly arbitrary tests against pairs of items!
Thus the style rule: use at least one role-determining name within the type of an implicit parameter.
The previous example had an opportunity to use an implicit but did not.
Note that when you use implicit on a parameter, then not only will the compiler try to supply that parameter with an implicit value, but the compiler will also use that parameter as an available implicit in the body of the method! Thus, both uses of orderer within the body of the method can be left out.
When the compiler examines the code in Listing 21.4, it will see that the types do not match up.
It will first look for implicit conversions to repair the code.
In this case, it will notice that orderer is available, so it can convert the code to orderer(x) > maxRest.
After these two insertions of implicits, the method fully type checks.
There is not a single mention of the orderer parameter in the text of the method.
The implicit parameter is used only for conversions, and so it can itself be used implicitly.
Now, because the parameter name is never used explicitly, the name could have been anything.
For example, maxList would behave identically if you left its body alone but changed the parameter name:
Because this pattern is common, Scala lets you leave out the name of this parameter and shorten the method header by using a view bound.
For example, even though class Int is not a subtype of Ordered[Int], you could still pass a List[Int] to maxList so long as an implicit conversion from Int to Ordered[Int] is available.
Moreover, if type T happens to already be an Ordered[T], you can still pass a List[T] to maxList.
The compiler will use an implicit identity function, declared in Predef:
In this case, the conversion is a no-op; it simply returns the object it is given.
But maxList of Listing 21.5 can work with many more types.
It can happen that multiple implicit conversions are in scope that would each work.
For the most part, Scala refuses to insert a conversion in such a case.
Implicits work well when the conversion left out is completely obvious and thus is pure boilerplate.
If multiple conversions apply, then the choice isn’t so obvious after all.
There is a method that takes a sequence, a conversion that turns an integer into a range, and a conversion that turns an integer into an array of digits:
Converting an integer to a sequence of digits is completely different from converting it to a range.
In this case, the programmer should specify which one is intended and be explicit.
Up through Scala 2.7, that was the end of the story.
Whenever multiple implicit conversions applied, the compiler refused to choose between them.
If you try to call foo(null), and there are two different foo overloads that accept null, the compiler will refuse.
It will say that the method call’s target is ambiguous.
If one of the available conversions is strictly more specific than the others, then the compiler will choose the more specific one.
The idea is that whenever there is a reason to believe a programmer.
Continuing the previous example, if one of the available foo methods takes a String while the other takes an Any, then choose the String version after all.
To be more precise, one implicit conversion is more specific than another if one of the following applies:
The argument type of the former is a subtype of the latter’s.
Both conversions are methods, and the enclosing class of the former extends the enclosing class of the latter.
The motivation to revisit this issue and revise the rule was to improve interoperation between Java collections, Scala collections, and strings.
What is the type inferred for cba? Intuitively, the type should be String.
Reversing a string should yield another string, right? However, in Scala 2.7, what happened is that "abc" was converted to a Scala collection.
Reversing a Scala collection yields a Scala collection, so the type of cba would be a collection.
There’s also an implicit conversion back to a string, but that didn’t patch up every problem.
The old implicit conversion to a Scala collection (now named WrappedString) is retained.
However, there is a more specific conversion supplied from String to a new type called StringOps.
StringOps has many methods such as reverse, but instead of returning a collection, they return a String.
Whenever a choice exists between these two conversions, the compiler chooses the conversion to StringOps, because it’s defined in a subclass of the class where the other conversion is defined.
Implicits are an powerful feature in Scala, but one which is sometimes difficult to get right.
Sometimes you might wonder why the compiler did not find an implicit conversion that you think should apply.
In that case it helps to write the conversion out explicitly.
If that also gives an error message, you then know why the compiler could not apply your implicit.
For instance, assume that you mistakenly took wrapString to be a conversion from Strings to Lists, instead of IndexedSeqs.
You would wonder why the following code does not work:
On the other hand, it’s also possible that inserting the conversion explicitly will make the error go away.
In that case you know that one of the other rules (such as the Scope Rule) was preventing the implicit conversion from being applied.
When you are debugging a program, it can sometimes help to see what implicit conversions the compiler is inserting.
The -Xprint:typer option to the compiler is useful for this.
If you run scalac with this option, then the compiler will show you what your code looks like after all implicit conversions have been added by the type checker.
If you look at the last statement in each of these listings, you’ll see that the second parameter list to enjoy, which was.
If you are brave, try scala -Xprint:typer to get an interactive shell that prints out the post-typing source code it uses internally.
If you do so, be prepared to see an enormous amount of boilerplate surrounding the meat of your code.
This chapter has shown you Scala’s rules about implicits, and it has shown you several common programming situations where you can profit from using implicits.
As a word of warning, implicits can make code confusing if they are used too frequently.
Thus, before adding a new implicit conversion, first ask whether you can achieve a similar effect through other means, such as inheritance, mixin composition, or method overloading.
If all of these fail, however, and you feel like a lot of your code is still tedious and redundant, then implicits might just be able to help you out.
Class List is probably the most commonly used structured data type in Scala.
This chapter “opens up the covers” and explains a bit how lists are implemented in Scala.
Knowing the internals of the List class is useful for several reasons.
You gain a better idea of the relative efficiency of list operations, which will help you in writing fast and compact code using lists.
You also learn a toolbox of techniques that you can apply in the design of your own libraries.
Finally, the List class is a sophisticated application of Scala’s type system in general and its genericity concepts in particular.
So studying class List will deepen your knowledge in these areas.
Lists are not “built-in” as a language construct in Scala; they are defined by an abstract class List in the scala package, which comes with two subclasses for :: and Nil.
In the following we present a quick tour through class List.
This section presents a somewhat simplified account of the class, compared to its real implementation in the Scala standard library, which is covered in Section 22.3
Because of this property, you can assign a value of type List[Int], say, to a variable of type List[Any]:
All list operations can be defined in terms of three basic methods:
They are defined in the subobject Nil and the subclass ::
Because of covariance, this means that Nil is compatible with every instance of the List type.
The three abstract methods of class List are implemented in the Nil object in a straightforward way: the isEmpty method returns true and the head and tail methods both throw an exception.
Note that throwing an exception is not only reasonable, but practically the only possible thing to do for head: Because Nil is a List of Nothing, the result type of head must be Nothing.
Since there is no value of this type, this means that head cannot return a normal value.
It’s named that way in order to support pattern matching with the infix ::
You have seen in Section 16.5 that every infix operation in a pattern is treated as a constructor application of the infix operator to its arguments.
So the pattern x :: xs is treated as ::(x, xs) where :: is a case class.
It takes two parameters hd and tl, representing the head and the tail of the list to be constructed.
To be precise, the types would also permit for head to always go into an infinite loop instead of throwing an exception, but this is clearly not what’s wanted.
The definitions of the head and tail method simply return the corresponding parameter.
In fact, this pattern can be abbreviated by letting the parameters directly implement the head and tail methods of the superclass List, as in the following equivalent but shorter definition of the :: class:
This works because every case class parameter is implicitly also a field of the class (it’s like the parameter declaration was prefixed with val)
Recall from Section 20.3 that Scala allows you to implement an abstract parameterless method such as head or tail with a field.
So the code above directly uses the parameters head and tail as implementations of the abstract methods head and tail that were inherited from class List.
All other List methods can be written using the basic three.
Because they end in a colon, they are bound to their right operand.
That is, an operation such as x :: xs is treated as the method call xs.::(x), not x.::(xs)
In fact, x.::(xs) would not make sense, as x is of the list element type, which can be arbitrary, so we cannot assume that this type would have a :: method.
For this reason, the :: method should take an element value and yield a new list.
What is the required type of the element value? You might be tempted to say, it should be the same as the list’s element type, but in fact this is more restrictive than necessary.
Listing 22.2 shows what happens when you construct lists of fruit:
The apples value is treated as a List of Apples, as expected.
However, the definition of fruits shows that it’s still possible to add an element of a different type to that list.
The element type of the resulting list is Fruit, which is the most precise common supertype of the original list element type (i.e., Apple) and the type of the element to be added (i.e., Orange)
This flexibility is obtained by defining the :: method (cons) as shown in Listing 22.3:
Note that the method is itself polymorphic—it takes a type parameter named U.
Furthermore, U is constrained in [U >: T] to be a supertype of the.
The element to be added is required to be of type U and the result is a List[U]
The lower-bound constraint of U is satisfied, because the list apples has type List[Apple] and Fruit is a supertype of Apple.
The argument to the :: is new Orange, which conforms to type Fruit.
Therefore, the method application is typecorrect with result type List[Fruit]
In fact, the polymorphic definition of :: with the lower bound T is not only convenient; it is also necessary to render the definition of class List type-correct.
Assume for a moment that we had defined :: like this:
You saw in Chapter 19 that method parameters count as contravariant positions, so the list element type T is in contravariant position in the definition above.
The lower bound [U >: T] thus kills two birds with one stone: it removes a typing problem, and it leads to a :: method that’s more flexible to use.
The list concatenation method ::: is defined in a similar way to ::, as shown in Listing 22.4
The result type is “widened” as necessary to include the types of all list elements.
Note also that again the order of the arguments is swapped between an infix operation and an explicit method call.
Because both ::: and :: end in a colon, they both bind to the right and are both right associative.
For instance, the else part of the definition of ::: shown in Listing 22.4 contains infix operations of both :: and :::
These infix operations can be expanded to equivalent method calls as follows:
For instance, to increment every element of a list without using map you could write:
How do you write a version of incAll that can work on lists of arbitrary size (as much as heap-capacity allows)? One approach is to use a loop:
But what should go in the loop body? Note that where incAll above constructs the list by prepending elements to the result of the recursive call, the loop needs to append new elements at the end of the result list.
One, very inefficient possibility is to use :::, the list append operator:
Because ::: takes time proportional to the length of its first operand, the whole operation takes time proportional to the square of the length of the list.
List buffers let you accumulate the elements of a list.
To do this, you use an operation such as “buf += elem”, which appends the element elem at the end of the list buffer buf.
Once you are done appending elements, you can turn the buffer into a list using the toList operation.
To use the simple name only, you can import ListBuffer from its package:
Using a list buffer, the body of incAll can now be written as follows:
In fact, the list buffer implementation is organized so that both the append operation (+=) and the toList operation take (very short) constant time.
The implementations of list methods given in Section 22.1 are concise and clear, but suffer from the same stack overflow problem as the non-tail recursive implementation of incAll.
Therefore, most methods in the real implementation of class List avoid recursion and use loops with list buffers instead.
For example, Listing 22.5 shows the real implementation of map in class List:
This revised implementation traverses the list with a simple loop, which is highly efficient.
A tail recursive implementation would be similarly efficient, but a general recursive implementation would be slower and less scalable.
But what about the operation b.toList at the end? What is its complexity? In fact, the call to the toList method takes only a small number of cycles, which is independent of the length of the list.
To understand why, take a second look at class ::, which constructs nonempty lists.
In practice, this class does not quite correspond to its idealized definition given previously in Section 22.1
There’s one peculiarity: the tl argument is a var! This means that it is possible to modify the tail of a list after the list is constructed.
However, because the variable tl has the modifier private[scala], it can be accessed only from within package scala.
Client code outside this package can neither read nor write tl.
In fact the elements of a list buffer are represented as a list and appending new elements involves a modification of tl field of the last :: cell in that list.
It returns the list of elements referred to by start and also sets exported to true if that list is nonempty.
So toList is very efficient, because it does not copy the list which is stored in a ListBuffer.
But what happens if the list is further extended after the toList operation? Of course, once a list.
However, appending to the last0 element will modify the list which is referred to by start.
To maintain the correctness of the list buffer operations, you need to work on a fresh list instead.
This is achieved by the first line in the implementation of the += operation:
You see that += copies the list pointed to by start if exported is true.
If you want to go from lists which can be extended at the end to immutable lists, there needs to be some copying.
However, the implementation of ListBuffer is such that copying is necessary only for list buffers that are further extended after they have been turned into lists.
Most use cases of list buffers add elements incrementally and then do one toList operation at the end.
The previous section showed key elements of the implementation of Scala’s List and ListBuffer classes.
You saw that lists are purely functional on the “outside” but have an imperative implementation using list buffers on the “inside.” This is a typical strategy in Scala programming: trying to combine purity with efficiency by carefully delimiting the effects of impure operations.
You might ask, why insist on purity? Why not just open up the definition of lists, making the tail field, and maybe also the head field, mutable? The disadvantage of such an approach is that it would make programs.
Note that constructing lists with :: re-uses the tail of the constructed list.
This is essential for efficiency; if the list xs was copied every time you added a new element onto it, this would be much slower.
Because sharing is pervasive, changing list elements, if it were possible, would be quite dangerous.
For instance, taking the code above, if you wanted to truncate list ys to its first two elements by writing:
Clearly, it would be quite difficult to keep track of what gets changed.
That’s why Scala opts for pervasive sharing and no mutation for lists.
The ListBuffer class still allows you to build up lists imperatively and incrementally, if you wish to.
But since list buffers are not lists, the types keep mutable buffers and immutable lists separate.
The design of Scala’s List and ListBuffer is quite similar to what’s done in Java’s pair of classes String and StringBuffer.
In both situations the designers wanted to maintain a pure immutable data structure but also wanted to provide an efficient way to construct this structure incrementally.
For Java and Scala strings, StringBuffers (or, in Java 5, StringBuilders) provide a way to construct a string incrementally.
For Scala’s lists, you have a choice: You can either construct lists incrementally by adding elements to the beginning of a list using ::, or you use a list buffer for adding elements to the end.
Usually, :: lends itself well to recursive algorithms in the divide-and-conquer style.
List buffers are often used in a more traditional loop-based style.
In this chapter, you saw how lists are implemented in Scala.
List is one of the most heavily used data structures in Scala, and it has a refined implementation.
List’s two subclasses, Nil and ::, are both case classes.
ListBuffer, in turn, is carefully implemented so that it can efficiently build lists without allocating extraneous memory.
It is functional on the outside, but uses mutation internally to speed up the common case where a buffer is discarded after toList is been called.
After studying all of this, you now know the list classes inside and out, and you might have learned an implementation trick or two.
Chapter 16 demonstrated that higher-order functions such as map, flatMap, and filter provide powerful constructions for dealing with lists.
But sometimes the level of abstraction required by these functions makes a program a bit hard to understand.
Say you are given a list of persons, each defined as an instance of a class Person.
Class Person has fields indicating the person’s name, whether (s)he is male, and his/her children.
Now, say you want to find out the names of all pairs of mothers and their children in that list.
Using map, flatMap and filter, you can formulate the following query:
You could optimize this example bit by using a withFilter call instead of filter.
This would avoid the creation of an intermediate data structure for male persons:
These queries do their job, but they are not exactly trivial to write or understand.
Remember the for expressions in Section 7.3? Using a for expression, the same example can be written as follows:
The result of this expression is exactly the same as the result of the previous expression.
What’s more, most readers of the code would likely find the for expression much clearer than the previous query, which used the higherorder functions, map, flatMap, and withFilter.
However, the last two queries are not as dissimilar as it might seem.
In fact, it turns out that the Scala compiler will translate the second query into the first one.
More generally, all for expressions that yield a result are translated by the compiler into combinations of invocations of the higher-order methods map, flatMap, and withFilter.
All for loops without yield are translated into a smaller set of higher-order functions: just withFilter and foreach.
In this chapter, you’ll find out first about the precise rules of writing for expressions.
After that, you’ll see how they can make combinatorial problems easier to solve.
Finally, you’ll learn how for expressions are translated, and how as a result, for expressions can help you “grow” the Scala language into new application domains.
Here, seq is a sequence of generators, definitions, and filters, with semicolons between successive elements.
This for expression contains one generator, one definition, and one filter.
The expression expr typically returns a list, even though you will see later that this can be generalized.
The pattern pat gets matched one-by-one against all elements of that list.
In the most common case, the pattern pat is just a variable x, as in x <- expr.
In that case, the variable x simply iterates over all elements returned by expr.
This definition binds the pattern pat to the value of expr.
So it has the same effect as a val definition:
The most common case is again where the pattern is a simple variable x, e.g., x = expr.
This defines x as a name for the value expr.
The filter drops from the iteration all elements for which expr returns false.
If there are several generators in a for expression, later generators vary more rapidly than earlier ones.
You can verify this easily with the following simple test:
An imperative solution to this problem would place queens one by one, moving them around on the board.
But it looks difficult to come up with a scheme that really tries all possibilities.
A more functional approach represents a solution directly, as a value.
A solution consists of a list of coordinates, one for each queen placed on the.
Note, however, that a full solution can not be found in a single step.
It needs to be built up gradually, by occupying successive rows with queens.
Now, to place the next queen in row k+ 1, generate all possible extensions of each previous solution by one more queen.
This yields another list of solution lists, this time of length k+1
Continue the process until you have obtained all solutions of the size of the chess-board N.
The outer function queens in the program above simply calls placeQueens with the size of the board n as its argument.
The task of the function application placeQueens(k) is to generate all partial solutions of length k in a list.
Every element of the list is one solution, represented by a list of length k.
If the parameter k to placeQueens is 0, this means that it needs to generate all solutions of placing zero queens on zero rows.
So if k is zero, placeQueens returns List(List()), a list consisting of a single element that is the empty list.
Note that this is quite different from the empty list List()
If placeQueens returns List(), this means no solutions, instead of a single solution consisting of no placed queens.
In the other case, where k is not zero, all the work of placeQueens is done in a for expression.
The first generator of that for expression iterates through all solutions of placing k - 1 queens on the board.
The second generator iterates through all possible columns on which the k’th queen might be placed.
The third part of the for expression defines the newly considered queen position to be the pair consisting of row k and each produced column.
The fourth part of the for expression is a filter which checks with isSafe whether the new queen is safe from check of all previous queens (the definition of isSafe will be discussed a bit later)
If the new queen is not in check from any other queens, it can form part of a partial solution, so placeQueens generates with queen :: queens a new solution.
If the new queen is not safe from check, the filter returns false, so no solution is generated.
The only remaining bit is the isSafe method, which is used to check whether a given queen is in check from any other element in a list of queens.
The isSafe method expresses that a queen is safe with respect to some other queens if it is not in check from any other queen.
If the two queens are on the same diagonal, i.e., the difference between their rows and the difference between their columns are the same.
The first case, that the two queens have the same row coordinate, cannot happen in the application because placeQueens already takes care to place each queen in a different row.
So you could remove the test without changing the functionality of the program as a whole.
The for notation is essentially equivalent to common operations of database query languages.
For instance, say you are given a database named books, represented as a list of books, where Book is defined as follows:
Here is a small example database, represented as an in-memory list:
Then, to find the titles of all books whose author’s last name is “Gosling”:
Or, to find the titles of all books that have the string “Program” in their title:
Or, to find the names of all authors that have written at least two books in the database:
The last solution is not yet perfect, because authors will appear several times in the list of results.
You still need to remove duplicate authors from result lists.
It’s worth noting that the last expression in method removeDuplicates can be equivalently expressed using a for expression:
Every for expression can be expressed in terms of the three higher-order functions map, flatMap, and withFilter.
This section describes the translation scheme, which is also used by the Scala compiler.
Translating for expressions starting with a generator and a filter.
Now, consider for expressions that combine a leading generator with some other elements.
This translation gives another for expression that is shorter by one element than the original, because an if element is transformed into an application of withFilter on the first generator expression.
The translation then continues with this second expression, so in the end you obtain:
The same translation scheme also applies if there are further elements following the filter.
If seq is an arbitrary sequence of generators, definitions and filters, then:
Then translation continues with the second expression, which is again shorter by one element than the original one.
The next case handles for expressions that start with two generators, as in:
Again, assume that seq is an arbitrary sequence of generators, definitions and filters.
In fact, seq might also be empty, and in that case there would not be a semicolon after expr2
The for expression above is translated to an application of flatMap:
This time, there is another for expression in the function value passed to flatMap.
That for expression (which is again simpler by one element than the original) is in turn translated with the same rules.
The three translation schemes given so far are sufficient to translate all for expressions that contain just generators and filters, and where generators bind only simple variables.
Take for instance the query, “find all authors who have published at least two books,” from Section 23.3:
The translation scheme presented so far does not yet handle generators that bind whole patterns instead of simple variables.
These two aspects will be explained in the next two sub-sections.
The translation scheme becomes more complicated if the left hand side of generator is a pattern, pat, other than a simple variable.
Still relatively easy to handle is the case where the for expression binds a tuple of variables.
In that case, almost the same scheme as for single variables applies.
Things become a bit more involved if the left hand side of the generator is an arbitrary pattern pat instead of a single variable or a tuple.
That is, the generated items are first filtered and only those that match pat are mapped.
Therefore, it’s guaranteed that a pattern-matching generator will never throw a MatchError.
The scheme above only treated the case where the for expression contains a single pattern-matching generator.
Analogous rules apply if the for expression contains other generators, filters, or definitions.
Because these additional rules don’t add much new insight, they are omitted from discussion here.
If you are interested, you can look them up in the Scala Language Specification [Ode08]
The last missing situation is where a for expression contains embedded definitions.
Assume again that seq is a (possibly empty) sequence of generators, definitions, and filters.
So you see that expr2 is evaluated each time there is a new x value being generated.
This re-evaluation is necessary, because expr2 might refer to x and so needs to be re-evaluated for changing values of x.
For you as a programmer the conclusion is that it’s probably not a good idea to have definitions embedded in for expressions that do not refer to variables bound by some preceding generator, because re-evaluating such expressions would be wasteful.
The previous subsections showed how for expressions that contain a yield are translated.
What about for loops that simply perform a side effect without returning anything? Their translation is similar, but simpler than for expressions.
In principle, wherever the previous translation scheme used a map or a flatMap in the translation, the translation scheme for for loops uses just a foreach.
For example, the following expression sums up all elements of a matrix represented as a list of lists:
The previous section showed that for expressions can be translated into applications of the higher-order functions map, flatMap, and withFilter.
In fact, you could equally well go the other way: every application of a map, flatMap, or filter can be represented as a for expression.
Here are implementations of the three methods in terms of for expressions.
The methods are contained in an object Demo, to distinguish them from the standard operations on Lists.
To be concrete, the three functions all take a List as parameter, but the translation scheme would work just as well with other collection types:
Not surprisingly, the translation of the for expression used in the body of Demo.map will produce a call to map in class List.
Similarly, Demo.flatMap and Demo.filter translate to flatMap and withFilter in class List.
So this little demonstration has shown that for expressions really are equivalent in their expressiveness to applications of the three functions map, flatMap, and withFilter.
Because the translation of for expressions only relies on the presence of methods map, flatMap, and withFilter, it is possible to apply the for notation to a large class of data types.
You have already seen for expressions over lists and arrays.
These are supported because lists, as well as arrays, define operations map, flatMap, and withFilter.
Because they define a foreach method as well, for loops over these data types are also possible.
Besides lists and arrays, there are also many other types in the Scala standard library that support the same four methods and therefore allow for expressions.
Examples are ranges, iterators, streams, and all implementations of sets.
It’s also perfectly possible for your own data types to support for expressions by defining the necessary methods.
To support the full range of for expressions and for loops, you need to define map, flatMap, withFilter, and foreach as methods of your data type.
But it’s also possible to define a subset of these methods, and thereby support a subset of all possible for expressions or loops.
If your type defines just map, it allows for expressions consisting of a single generator.
If it defines flatMap as well as map, it allows for expressions consisting of several generators.
If it defines foreach, it allows for loops (both with single and multiple generators)
If it defines withFilter, it allows for filter expressions starting with an if in the for expression.
This allows for maximal flexibility, because it is only required that the result of expanding a for expression type checks.
Scala defines no typing rules for the for expressions themselves, and does not require that methods map, flatMap, withFilter, or foreach to have any particular type signatures.
Nevertheless, there is a typical setup that captures the most common intention of the higher order methods to which for expressions translate.
Say you have a parameterized class, C, which typically would stand for some sort of collection.
Then it’s quite natural to pick the following type signatures for map, flatMap, withFilter, and foreach:
That is, the map function takes a function from the collection’s element type A to some other type B.
It produces a new collection of the same kind C, but with B as the element type.
The flatMap method takes a function f from A to some C-collection of Bs and produces a C-collection of Bs.
The withFilter method takes a predicate function from the collection’s element type A to Boolean.
It produces a collection of the same type as the one on which it is invoked.
Finally, the foreach method takes a function from A to Unit, and produces a Unit result.
In class C above, the withFilter method produces a new collection of the same class.
That means that every invocation of withFilter creates a new C object, just the same as filter would work.
Now, in the translation of for expressions, any calls to withFilter are always followed by calls to one of the other three methods.
If objects of class C are large (think long sequences), you might want to avoid the creation of such an intermediate object.
A standard technique is to let withFilter return not a C object but just a wrapper object that “remembers” that elements need to be filtered before being processed further.
Concentrating on just the first three functions of class C, the following facts are noteworthy.
In functional programming, there’s a general concept called a monad, which can explain a large number of types with computations, ranging from collections, to computations with state and I/O, backtracking computations, and transactions, to name but a few.
You can formulate functions map, flatMap, and withFilter on a monad, and, if you do, they end up having exactly the types given above.
Furthermore, you can characterize every monad by map, flatMap, and withFilter, plus a “unit” constructor that produces a monad from an element value.
In an objectoriented language, this “unit” constructor is simply an instance constructor or a factory method.
Therefore, map, flatMap and withFilter can be seen as an object-oriented version of the functional concept of monad.
Because for expressions are equivalent to applications of these three methods, they can be seen as syntax for monads.
All this suggests that the concept of for expression is more general than just iteration over a collection, and indeed it is.
For instance, for expressions also play an important role in asynchronous I/O, or as an alternative notation for optional values.
Watch out in the Scala libraries for occurrences of map, flatMap, and withFilter—when they are present, for expressions suggest themselves as a concise way of manipulating elements of the type.
In this chapter, you were given a peek under the hood of for expressions and for loops.
You learned that they translate into applications of a standard set of higher-order methods.
As a consequence of this, you saw that for expressions are really much more general than mere iterations over collections, and that you can design your own classes to support them.
In the eyes of many, the new collections framework is the most significant change in Scala 2.8
Scala had collections before (and in fact the new framework is largely compatible with them)
But it’s only 2.8 that provides a common, uniform, and all-encompassing framework for collection types.
Even though the additions to collections are subtle at first glance, the changes they can provoke in your programming style can be profound.
In fact, quite often it’s as if you work on a higher level with the basic building blocks of a program being whole collections instead of their elements.
Fortunately, the adaptation is helped by several nice properties of the new Scala collections.
They are easy to use, concise, safe, fast, and universal.
Easy to use: A small vocabulary of twenty to fifty methods is enough to solve most collection problems in a couple of operations.
No need to wrap your head around complicated looping structures or recursions.
Persistent collections and side-effect-free operations mean that you need not worry about accidentally corrupting existing collections with new data.
Concise: You can achieve with a single word what used to take one or several loops.
You can express functional operations with lightweight syntax and combine operations effortlessly, so that the result feels like a custom algebra.
Safe: This one has to be experienced to sink in.
The statically typed and functional nature of Scala’s collections means that the overwhelming.
The reason is that (1) the collection operations themselves are heavily used and therefore well tested.
These explicit inputs and outputs are subject to static type checking.
The bottom line is that the large majority of misuses will manifest themselves as type errors.
It’s not at all uncommon to have programs of several hundred lines run at first try.
Fast: Collection operations are tuned and optimized in the libraries.
You might be able to do a little bit better with carefully hand-tuned data structures and operations, but you might also do a lot worse by making some suboptimal implementation decisions along the way.
What’s more, collections are currently being adapted to parallel execution on multi-cores.
Parallel collections will support the same operations as sequential ones, so no new operations need to be learned and no code needs to be rewritten.
You will be able to turn a sequential collection into a parallel one simply by invoking the par method.
Universal: Collections provide the same operations on any type where it makes sense to do so.
So you can achieve a lot with a fairly small vocabulary of operations.
For instance, a string is conceptually a sequence of characters.
This chapter describes in depth the APIs of the Scala 2.8 collection classes from a user perspective.
This chapter takes you on a more detailed tour, showing all the collection classes and all the methods they define, so it includes everything you need to know to use Scala collections.
Looking ahead, Chapter 25 will concentrate on the architecture and extensibility aspects of the library, for people implementing new collection types.
As is now familiar to you, Scala collections systematically distinguish between mutable and immutable collections.
A mutable collection can be updated or extended in place.
You still have operations that simulate additions, removals, or updates, but those operations will in each case return a new collection and leave the old collection unchanged.
All collection classes are found in the package scala.collection or one of its subpackages: mutable, immutable, and generic.
Most collection classes needed by client code exist in three variants, each of which has different characteristics with respect to mutability.
Such a collection will never change after it is created.
Therefore, you can rely on the fact that accessing the same collection value repeatedly at different points in time will always yield a collection with the same elements.
These operations let you write code to mutate the collection yourself.
However, you must be careful to understand and defend against any updates performed by other parts of the code base.
A collection in package scala.collection can be either mutable or immutable.
Generally, the root collections in package scala.collection define the same interface as the immutable collections.
The difference between root collections and immutable collections is that clients of an immutable collection have a guarantee that nobody can mutate the collection, whereas clients of a root collection only know that they can’t change the collection themselves.
Even though the static type of such a collection provides no operations for modifying the collection, it might still be possible that the run-time type is a mutable collection that can be changed by other clients.
For instance, if you just write Set without any prefix or without having imported anything, you get an immutable set, and if you write Iterable you get an immutable.
Typically, collection classes defer the implementations of some of their operations to classes in generic.
Everyday users of the collection framework on the other hand should need to refer to classes in generic only in exceptional circumstances.
The most important collection classes are shown in Figure 24.1
There is quite a bit of commonality shared by all these classes.
For instance, every kind of collection can be created by the same uniform syntax, writing the collection class name followed by its elements:
The toString methods for all collections produce output written as above, with a type name followed by the elements of the collection in parentheses.
All collections support the API provided by Traversable, but their methods all return their own class rather than the root class Traversable.
For instance, the map method on List has a return type of List, whereas the map method on Set has a return type of Set.
Thus the static return type of these methods is fairly precise:
Equality is also organized uniformly for all collection classes; more on this in Section 24.14
Most of the classes in Figure 24.1 exist in three variants: root, mutable, and immutable.
The only exception is the Buffer trait, which only exists as a mutable collection.
In the remainder of this chapter, we will review these classes one by one.
At the top of the collection hierarchy is trait Traversable.
Collection classes implementing Traversable just need to define this method; all other methods can be inherited from Traversable.
The foreach method is meant to traverse all elements of the collection, and apply the given operation, f, to each element.
The type of the operation is Elem => U, where Elem is the type of the collection’s elements and U is an arbitrary result type.
The invocation of f is done for its side effect only; in fact any function result of f is discarded by foreach.
Addition ++, which appends two traversables together, or appends all elements of an iterator to a traversable.
Map operations map, flatMap, and collect, which produce a new collection by applying some function to collection elements.
Conversions toIndexedSeq, toIterable, toStream, toArray, toList, toSeq, toSet, and toMap, which turn a Traversable collection into a more specific collection.
All these conversions return the receiver object if it already matches the demanded collection type.
For instance, applying toList to a list will yield the list itself.
As their names imply, these copy collection elements to a buffer or array, respectively.
An example of an infinite traversable collection is the stream of natural numbers Stream.from(0)
The method hasDefiniteSize indicates whether a collection is possibly infinite.
If it returns false, the collection might be infinite, in which case size will emit an error or not return.
These select the first or last element of a collection, or else the first element matching a condition.
Note, however, that not all collections have a well-defined meaning of what “first” and “last” means.
For instance, a hash set might store elements according to their hash keys, which might change from run to run.
In that case, the “first” element of a hash set could also be different for different runs of a program.
A collection is ordered if it always yields its elements in the same order.
Most collections are ordered, but some (such as hash sets) are not—dropping the ordering provides a little bit of extra efficiency.
Ordering is often essential to give reproducible tests and help in debugging.
That’s why Scala collections provide ordered alternatives for all collection types.
Subcollection retrieval operations takeWhile, tail, init, slice, take, drop, filter, dropWhile, filterNot, and withFilter.
These all return some subcollection identified by an index range or a predicate.
Subdivision operations splitAt, span, partition, and groupBy, which split the elements of this collection into several subcollections.
Element tests exists, forall, and count, which test collection elements with a given predicate.
Folds foldLeft, foldRight, /:, :\, reduceLeft, reduceRight, which apply a binary operation to successive elements.
Specific folds sum, product, min, and max, which work on collections of specific types (numeric or comparable)
String operations mkString, addString, and stringPrefix, which provide alternative ways of converting a collection to a string.
View operations consisting of two overloaded variants of the view method.
All operations on the resulting filter will only apply to those elements of xs for which the condition p is true.
Adds a string to StringBuilder b that shows all elements of xs between separators sep enclosed in strings start and end.
Converts the collection to a string that shows all elements of xs between separators sep enclosed in strings start and end.
The next trait from the top in Figure 24.1 is Iterable.
All methods in this trait are defined in terms of an an abstract method, iterator, which.
The foreach method from trait Traversable is implemented in Iterable in terms of iterator.
Quite a few subclasses of Iterable override this standard implementation of foreach in Iterable, because they can provide a more efficient implementation.
Remember that foreach is the basis of the implementation of all operations in Traversable, so its performance matters.
Two more methods exist in Iterable that return iterators: grouped and sliding.
These iterators, however, do not return single elements but whole subsequences of elements of the original collection.
The maximal size of these subsequences is given as an argument to these methods.
The grouped method chunks its elements into increments, whereas sliding yields a sliding window over the elements.
The difference between the two should become clear by looking at the following interpreter interaction:
Trait Iterable also adds some other methods to Traversable that can be implemented efficiently only if an iterator is available.
You might wonder why the extra trait Traversable is above Iterable.
Can we not do everything with an iterator? So what’s the point of having.
Let’s say you want a class hierarchy for binary trees that have integer elements at the leaves.
To do this, have Tree inherit from Traversable[Int] and define a foreach method like this:
To see this, consider that for a balanced tree with N leaves you will have N - 1 interior nodes of class Branch.
To do this, have Tree inherit from Iterable[Int] and define an iterator method like this:
At first glance, this looks no harder than the foreach solution.
However, there’s an efficiency problem that has to do with the implementation of the iterator concatenation method, ++
Overall, that makes log(N) indirections to get at a leaf of a balanced tree with N leaves.
So the cost of visiting all elements of a tree went up from about 2N for the foreach traversal method to N log(N) for the traversal with iterator.
If the tree has a million elements that means about two million steps for foreach and about twenty million steps for iterator.
In the inheritance hierarchy below Iterable you find three traits: Seq, Set, and Map.
A common aspect of these three traits is that they all implement the PartialFunction trait1 with its apply and isDefinedAt methods.
For instance, Set('a', 'b', 'c')('b') == true whereas Set()('a') == false.
In the following three sections, we will explain each of the three kinds of collections in more detail.
The operations on sequences, summarized in Figure 24.3, fall into the following categories:
Indexing and length operations apply, isDefinedAt, length, indices, and lengthCompare.
For a Seq, the apply operation means indexing; hence a sequence of type Seq[T] is a partial function that takes an Int argument (an index) and yields a sequence element of type T.
The elements of a sequence are indexed from zero up to the length of the sequence minus one.
The length method on sequences is an alias of the size method of general collections.
The lengthCompare method allows you to compare the lengths of two sequences even if one of the sequences has infinite length.
Index search operations indexOf, lastIndexOf, indexOfSlice, lastIndexOfSlice, indexWhere, lastIndexWhere, segmentLength, and prefixLength, which return the index of an element equal to a given value or matching some predicate.
Addition operations +:, :+, and padTo, which return new sequences obtained by adding elements at the front or the end of a sequence.
Update operations updated and patch, which return a new sequence obtained by replacing some elements of the original sequence.
Sorting operations sorted, sortWith, and sortBy, which sort sequence elements according to various criteria.
Reversal operations reverse, reverseIterator, and reverseMap, which yield or process sequence elements in reverse order, from last to first.
Comparison operations startsWith, endsWith, contains, corresponds, and containsSlice, which relate two sequences or search an element in a sequence.
Multiset operations intersect, diff, union, and distinct, which perform set-like operations on the elements of two sequences or remove duplicates.
If a sequence is mutable, it offers in addition a side-effecting update method, which lets sequence elements be updated.
Recall from Chapter 3 that syntax like seq(idx) = elem is just a shorthand for seq.update(idx, elem)
The update method changes a sequence element in place, and is only available for mutable sequences.
The updated method is available for all sequences and always returns a new sequence instead of modifying the original.
Comparison between two elements proceeds by mapping the function f over both and comparing the results.
These do not add any new operations, but each offers different performance characteristics.
A linear sequence has efficient head and tail operations, whereas an indexed sequence has efficient apply, length, and (if mutable) update operations.
List is a frequently used linear sequence, as is Stream.
The Vector class provides an interesting compromise between indexed and linear access.
It has both effectively constant time indexing overhead and constant time linear access overhead.
Because if this, vectors are a good foundation for mixed access patterns where both indexed and linear accesses are used.
Buffers allow not only updates of existing elements but also element insertions, element removals, and efficient additions of new elements at the end of the buffer.
The principal new methods supported by a buffer are += and ++=, for element addition at the end, +=: and ++=: for addition at the front, insert and insertAll for element insertions, as well as remove and -= for element removal.
Two Buffer implementations that are commonly used are ListBuffer and ArrayBuffer.
As the name implies, a ListBuffer is backed by a List and supports efficient conversion of its elements to a List, whereas an ArrayBuffer is backed by an array, and can be quickly converted into one.
You saw a glimpse of the implementation of ListBuffer in Section 22.2
The contains method indicates whether a set contains a given element.
The apply method for a set is the same as contains, so set(elem) is the same as set contains elem.
That means sets can also be used as test functions that return true for the elements they contain.
Additions + and ++, which add one or more elements to a set, yielding a new set as a result.
Removals - and --, which remove one or more elements from a set, yielding a new set.
These set operations exist in two forms: alphabetic and symbolic.
Mutable sets have methods that add, remove, or update elements, which are summarized in Table 24.6:
Just like an immutable set, a mutable set offers the + and ++ operations for element additions and the - and -- operations for element removals.
But these are less often used for mutable sets since they involve copying the set.
As a more efficient alternative, mutable sets offer the update methods += and -=
The operation s += elem adds elem to the set s as a side effect, and returns the mutated set as a result.
Likewise, s -= elem removes elem from the set, and returns the mutated set as a result.
Besides += and -= there are also the bulk operations ++= and --=, which add or remove all elements of a traversable or an iterator.
The choice of the method names += and -= means that very similar code can work with either mutable or immutable sets.
Consider first the following interpreter dialogue that uses an immutable set s:
In this example, we used += and -= on a var of type immutable.Set.
So this invokes the addition method + on the set s and then assigns the result back to the s variable.
However, even though the statements look the same as before, they do something different.
The s += 4 statement now invokes the += method on the mutable set value s, changing the set in place.
Likewise, the s -= 2 statement now invokes the -= method on the same set.
You often can replace a mutable collection stored in a val by an immutable collection stored in a var, and vice versa.
This works at least as long as there are no alias references to the collection through which you can observe whether it was updated in place or a new collection was created.
Mutable sets also provide add and remove as variants of += and -=
The difference is that add and remove return a boolean result indicating whether the operation had an effect on the set.
The current default implementation of a mutable set uses a hash table to store the set’s elements.
The default implementation of an immutable set uses a representation that adapts to the number of elements of the set.
An empty set is represented by just a singleton object.
Sets of sizes up to four are represented by a single object that stores all elements as fields.
Beyond that size, immutable sets are implemented as hash tries.2
A consequence of these representation choices is that for sets of small sizes, up to about four, immutable sets are more compact and more efficient.
So if you expect the size of a set to be small, try to make it immutable.
A SortedSet is a set where, no matter what order elements were added to the set, the elements are traversed in sorted order.
The default representation of a SortedSet is an ordered binary tree maintaining the invariant that all elements in the left subtree of a node are smaller than all elements in the right subtree.
That way, a simple in-order traversal can return all tree elements in increasing order.
To create an empty tree set, you could first specify the desired ordering.
For example, here is an ordering that puts strings in reverse order:
Then, to create an empty tree set with that ordering, use:
Or you can leave out the ordering argument but give an element type or the empty set.
In that case, the default ordering on the element type will be used:
If you create new sets from a tree set (for instance by concatenation or filtering), they will keep the same ordering as the original set.
For instance, the range method returns all elements from a starting element up to, but excluding, an end element.
Or, the from method returns all elements greater than or equal to a starting element in the set’s ordering.
The result of calls to both methods is again a sorted set.
Bit sets are sets of non-negative integer elements that are implemented in one or more words of packed bits.
The internal representation of a bit set uses an array of Longs.
It follows that the size of a bit set depends on the largest integer that’s stored in it.
Bitsets are hence more compact than other sets if they contain many small elements.
Another advantage of bit sets is that operations such as membership test with contains, or element addition and removal with += and -=, are all extremely efficient.
Maps are Iterables of pairs of keys and values (also named mappings or associations)
The fundamental operations on maps, summarized in Table 24.7, are similar to those on sets.
Mutable maps additionally support the operations shown in Table 24.8
These operations turn maps into partial functions from keys to values.
The operation “m get key” tests whether the map contains an association for the given key.
If so, it returns the associated value in a Some.
If no key is defined in the map, get returns None.
Maps also define an apply method that returns the value associated with a given key directly, without wrapping it in an Option.
If the key is not defined in the map, an exception is raised.
Additions and updates +, ++, and updated, which let you add new bindings to a map or change existing bindings.
Removals - and --, which remove bindings from a map.
Subcollection producers keys, keySet, keysIterator, valuesIterator, and values, which return a map’s keys and values separately in various forms.
Transformations filterKeys and mapValues, which produce a new map by filtering and transforming bindings of an existing map.
Otherwise, updates ms with the mapping k -> d and returns d.
The addition and removal operations for maps mirror those for sets.
As for sets, mutable maps also support the non-destructive addition operations +, -, and updated, but they are used less frequently because they involve a copying of the mutable map.
Instead, a mutable map m is usually updated “in place,” using the two variants m(key) = value or m += (key -> value)
There is also the variant m put (key, value), which returns an Option value that contains the value previously associated with key, or None if the key did not exist in the map before.
The getOrElseUpdate is useful for accessing maps that act as caches.
Say you have an expensive computation triggered by invoking a function f:
Assume further that f has no side-effects, so invoking it again with the same argument will always yield the same result.
In that case you could save time by storing previously computed bindings of argument and results of f in a map, and only computing the result of f if a result of an argument was not found there.
You could say the map is a cache for the computations of the function f.
You can now create a more efficient caching version of the f function:
Note that the second argument to getOrElseUpdate is “by-name,” so the computation of f("abc") above is only performed if getOrElseUpdate requires the value of its second argument, which is precisely if its first argument is not found in the cache map.
In Section 1.1, we mentioned that if you needed a thread-safe map, you could mix the SynchronizedMap trait into whatever particular map implementation you desired.
For example, you could mix SynchronizedMap into HashMap, as shown in Listing 24.1
The rest of the example is the definition of singleton object MapMaker, which declares one method, makeMap.
The makeMap method declares its result type to be a mutable map of string keys to string values.
The first statement inside the body of makeMap constructs a new mutable HashMap that mixes in the SynchronizedMap trait:
Given this code, the Scala compiler will generate a synthetic subclass of HashMap that mixes in SynchronizedMap, and create (and return) an instance of it.
This synthetic class will also override a method named default, because of this code:
If you define a new map class and override the default method, however, your.
Thus, the synthetic HashMap subclass generated by the compiler from the code in Listing 24.1 will return the somewhat curt response string, "Why do you want to know?", when queried with a non-existent key.
Because the mutable map returned by the makeMap method mixes in the SynchronizedMap trait, it can be used by multiple threads at once.
Here’s an example of the map being used, by one thread, in the interpreter:
You can create synchronized sets similarly to the way you create synchronized maps.
For example, you could create a synchronized HashSet by mixing in the SynchronizedSet trait, like this:
Alternatively, you may prefer to use unsynchronized collections with Scala actors.
Scala provides many concrete immutable collection classes for you to choose from.
They differ in the traits they implement (maps, sets, sequences), whether they can be infinite, and the speed of various operations.
We’ll start by reviewing the most common immutable collection types.
They provide constant-time access to their first element as well as the rest of the list, and they have a constant-time cons operation for adding a new element to the front of the list.
A stream is like a list except that its elements are computed lazily.
Whereas lists are constructed with the :: operator, streams are constructed with the similar-looking #::
The tail is not printed here, though, because it hasn’t been computed yet! Streams are required to compute lazily, and the toString method of a stream is careful not to force any extra evaluation.
It computes a stream that contains a Fibonacci sequence starting with the given two numbers.
A Fibonacci sequence is one where each element is the sum of the previous two elements in the series:
The first element of the sequence is clearly a, and the rest of the sequence is the Fibonacci sequence starting with b followed by a + b.
The tricky part is computing this sequence without causing an infinite recursion.
If the function used :: instead of #::, then every call to the function would result in another call, thus causing an infinite recursion.
Since it uses #::, though, the right-hand side is not evaluated until it is requested.
Here are the first few elements of the Fibonacci sequence starting with two ones:
Lists are very efficient when the algorithm processing them is careful to only process their heads.
Accessing, adding, and removing the head of a list takes.
Vectors are a new collection type in Scala 2.8 that give efficient access to elements beyond the head.
Access to any elements of a vector take only “effectively constant time,” as defined below.
It’s a larger constant than for access to the head of a list or for reading an element of an array, but it’s a constant nonetheless.
As a result, algorithms using vectors do not have to be careful about accessing just the head of the sequence.
They can access and modify elements at arbitrary locations, and thus they can be much more convenient to write.
Vectors are built and modified just like any other sequence:
Vectors with up to 32 elements can be represented in a single node.
So for all vectors of reasonable size, an element selection involves up to five primitive array selections.
This is what we meant when we wrote that element access is “effectively constant time.”
Vectors are immutable, so you cannot change an element of a vector in place.
However, with the updated method you can create a new vector that differs from a given vector only in a single element:
As the last line above shows, a call to updated has no effect on the original vector vec.
Like selection, functional vector updates are also “effectively constant time.” Updating an element in the middle of a vector can be done by copying the node that contains the element, and every node that points to it, starting from the root of the tree.
This means that a functional update creates between one and five nodes that each contain up to 32 elements or subtrees.
This is certainly more expensive than an in-place update in a mutable array, but still a lot cheaper than copying the whole vector.
Because vectors strike a good balance between fast random selections and fast random functional updates, they are currently the default implementation of immutable indexed sequences:
If you need a last-in-first-out sequence, you can use a Stack.
You push an element onto a stack with push, pop an element with pop, and peek at the top of the stack without removing it with top.
Immutable stacks are used rarely in Scala programs because their functionality is subsumed by lists: A push on an immutable stack is the same as a :: on a list, and a pop on a stack is the same a tail on a list.
A queue is just like a stack except that it is first-in-first-out rather than last-infirst-out.
You can append an element to an immutable queue with enqueue:
To append multiple elements to a queue, call enqueue with a collection as its argument:
To remove an element from the head of the queue, use dequeue:
Note that dequeue returns a pair consisting of the element removed and the rest of the queue.
A range is an ordered sequence of integers that are equally spaced apart.
If you want to create a range that is exclusive of its upper limit, use the convenience method until instead of to:
Ranges are represented in constant space, because they can be defined by just three numbers: their start, their end, and the stepping value.
Because of this representation, most operations on ranges are extremely fast.
Hash tries4 are a standard way to implement immutable sets and maps efficiently.
For instance, to find a given key in a map, you use the lowest five bits of the hash code of the key to select the first subtree, the next five bits the next subtree, and so on.
Selection stops once all elements stored in a node have hash codes that differ from each other in the bits that are selected so far.
Thus, not all the bits of the hash code are necessarily used.
Hash tries strike a nice balance between reasonably fast lookups and reasonably efficient functional insertions (+) and deletions (-)
That’s why they underlie Scala’s default implementations of immutable maps and sets.
In fact, Scala has a further optimization for immutable sets and maps that contain less than five elements.
Sets and maps with one to four elements are stored as single objects that just contain the elements (or key/value pairs in the case of a map) as fields.
The empty immutable set and empty immutable map is in each case a singleton object—there’s no need to duplicate storage for those because an empty immutable set or map will always stay empty.
Red-black trees are a form of balanced binary trees where some nodes are designated “red” and others “black.” Like any balanced binary tree, operations on them reliably complete in time logarithmic to the size of the tree.
Scala provides implementations of sets and maps that use a red-black tree internally.
Red-black trees are also the standard implementation of SortedSet in Scala, because they provide an efficient iterator that returns all elements of the set in sorted order.
A bit set represents a collection of small integers as the bits of a larger integer.
Thus, bit sets are very compact so long as the largest integer in the set is less than a few hundred or so.
Adding an item to the set takes time proportional to the number of Longs in the bit set’s array, which is typically a small number.
Here are some simple examples of the use of a bit set:
A list map represents a map as a linked list of key-value pairs.
In general, operations on a list map might have to iterate through the entire list.
Thus, operations on a list map take time linear in the size of the map.
In fact there is little usage for list maps in Scala because standard immutable maps are almost always faster.
The only possible difference is if the map is for some reason constructed in such a way that the first elements in the list are selected much more often than the other elements.
Now that you’ve seen the most commonly used immutable collection classes that Scala provides in its standard library, take a look at the mutable collection classes.
Most operations on an array buffer have the same speed as an array, because the operations simply access and modify the underlying array.
Additionally, array buffers can have data efficiently added to the end.
Appending an item to an array buffer takes amortized constant time.
Thus, array buffers are useful for efficiently building up a large collection whenever the new items are always added to the end.
A list buffer is like an array buffer except that it uses a linked list internally instead of an array.
If you plan to convert the buffer to a list once it is built up, use a list buffer instead of an array buffer.
Just like an array buffer is useful for building arrays, and a list buffer is useful for building lists, a string builder is useful for building strings.
String builders are so commonly used that they are already imported into the default namespace.
The “buf.type” that appears in the interpreter responses in this and several other examples in this section is a singleton type.
As will be explained in Section 29.6, buf.type means the variable holds exactly the object referred to by buf.
Linked lists are mutable sequences that consist of nodes that are linked with next pointers.
In most languages null would be picked as the empty linked list.
That does not work for Scala collections, because even empty sequences must support all sequence methods.
Empty linked lists are encoded instead in a special way: Their next field points back to the node itself.
Like their immutable cousins, linked lists are best operated on sequentially.
In addition, linked lists make it easy to insert an element or linked list into another linked list.
DoubleLinkedLists are like the single linked lists described in the previous subsection, except besides next, they have another mutable field, prev, that points to the element preceding the current node.
The main benefit of that additional link is that it makes element removal very fast.
A MutableList consists of a single linked list together with a pointer that refers to the terminal empty node of that list.
This makes list append a constant time operation because it avoids having to traverse the list in search for its terminal node.
You use a mutable queue similarly to the way you use an immutable one, but instead of enqueue, you use the += and ++= operators to append.
Also, on a mutable queue, the dequeue method will just remove the head element from the queue and return it.
Array sequences are mutable sequences of fixed size that store their elements internally in an Array[AnyRef]
You would typically use an ArraySeq if you want an array for its performance characteristics, but you also want to create generic instances of the sequence where you do not know the type of the elements and do not have a ClassManifest to provide it at run-time.
You will find out about these issues with arrays shortly, in Section 24.11
It works exactly the same as the immutable version except that modifications happen in place.
ArrayStack is an alternative implementation of a mutable stack, which is backed by an Array that gets resized as needed.
It provides fast indexing and is generally slightly more efficient for most operations than a normal mutable stack.
A hash table stores its elements in an underlying array, placing each item at a position in the array determined by the hash code of that item.
Adding an element to a hash table takes only constant time, so long as there isn’t already another element in the array that has the same hash code.
Hash tables are thus very fast so long as the objects placed in them have a good distribution of hash codes.
As a result, the default mutable map and set types in Scala are based on hash tables.
Hash sets and maps are used just like any other set or map.
Iteration over a hash table is not guaranteed to occur in any particular order.
Iteration simply proceeds through the underlying array in whichever order it happens to be.
To get a guaranteed iteration order, use a linked hash map or set instead of a regular one.
A linked hash map or set is just like a regular hash map or set except that it also includes a linked list of the elements in the order they were added.
Iteration over such a collection is always in the same order that the elements were initially added.
A weak hash map is a special kind of hash map in which the garbage collector does not follow links from the map to the keys stored in it.
This means that a key and its associated value will disappear from the map if there is no other reference to that key.
Weak hash maps are useful for tasks such as caching, where you want to re-use an expensive function’s result if the function is called again on the same key.
If keys and function results are stored in a regular hash map, the map could grow without bounds, and no key would ever become garbage.
As soon as a key object becomes unreachable, it’s entry is removed from the weak hash map.
A concurrent map can be accessed by several threads at once.
In addition to the usual Map operations, it provides the following atomic operations:
What it is What it does m putIfAbsent(k, v) Adds key/value binding k -> m unless k is already.
A mutable bit set is just like an immutable one, except that it can be modified in place.
Mutable bit sets are slightly more efficient at updating than immutable ones, because they don’t have to copy around Longs that haven’t changed.
One the one hand, Scala arrays correspond one-to-one to Java arrays.
That is, a Scala array Array[Int] is represented as a Java int[], an Array[Double] is represented as a Java double[] and an Array[String] is represented as a Java String[]
But at the same time, Scala arrays offer much more their Java analogues.
That is, you can have an Array[T], where T is a type parameter or abstract type.
Second, Scala arrays are compatible with Scala sequences—you can pass an Array[T] where a Seq[T] is required.
Given that Scala arrays are represented just like Java arrays, how can these additional features be supported in Scala? In fact, the answer to this question differs between Scala 2.8 and earlier versions.
Previously, the Scala compiler somewhat “magically” wrapped and unwrapped arrays to and from Seq objects, when required, in a process called boxing and unboxing.
The details of this were quite complicated, in particular when you created a new array of generic type Array[T]
There were some puzzling corner cases and the performance of array operations was not all that predictable.
Instead the Scala 2.8 array implementation makes systematic use of implicit conversions.
In Scala 2.8 an array does not pretend to be a sequence.
It can’t really be that because the data type representation of a native array is not a subtype of Seq.
This interaction demonstrates that arrays are compatible with sequences, because there’s an implicit conversion from Array to WrappedArray.
To go the other way, from a WrappedArray to an Array, you can use the toArray method defined in Traversable.
The last interpreter line above shows that wrapping then unwrapping with toArray gives you back the same array you started with.
There is yet another implicit conversion that gets applied to arrays.
This conversion simply “adds” all sequence methods to arrays but does not turn the array itself into a sequence.
Typically, this ArrayOps object is short-lived; it will usually be inaccessible after the call to the sequence method and its storage can be recycled.
The difference between the two implicit conversions on arrays is demonstrated here:
You see that calling reverse on seq, which is a WrappedArray, will give again a WrappedArray.
That’s logical, because wrapped arrays are Seqs, and calling reverse on any Seq will give again a Seq.
On the other hand, calling reverse on the ops value of class ArrayOps will result in an Array, not a Seq.
The ArrayOps example above was quite artificial, intended only to show the difference to WrappedArray.
The ArrayOps object gets inserted automatically by the implicit conversion.
So the line above is equivalent to the following line, where intArrayOps was the conversion that was implicitly inserted previously:
This raises the question how the compiler picked intArrayOps over the other implicit conversion to WrappedArray in the line above.
After all, both conversions map an array to a type that supports a reverse method, which is what the input specified.
The answer to that question is that the two implicit conversions are prioritized.
The ArrayOps conversion has a higher priority than the WrappedArray conversion.
Implicits in subclasses and subobjects take precedence over implicits in base classes.
So if both conversions are applicable, the one in Predef is chosen.
A very similar scheme, which was described in Section 21.7, works for strings.
So now you know how arrays can be compatible with sequences and how they can support all sequence operations.
What about genericity? In Java you cannot write a T[] where T is a type parameter.
How then is Scala’s Array[T] represented? In fact a generic array like Array[T] could be at run-time any of Java’s eight primitive array types byte[], short[], char[], int[], long[], float[], double[], boolean[], or it could be an array of objects.
At run-time, when an element of an array of type Array[T] is accessed or updated there is a sequence of type tests that determine the actual array type, followed by the correct array operation on the Java array.
You can expect accesses to generic arrays to be three to four times slower than accesses to primitive or object arrays.
This means that if you need maximal performance, you should prefer concrete over generic arrays.
Representing the generic array type is not enough, however, There must also be a way to create generic arrays.
This is an even harder problem, which requires a little bit of help from you.
To illustrate the problem, consider the following attempt to write a generic method that creates an array:
The evenElems method returns a new array that consists of all elements of the argument vector xs that are at even positions in the vector.
The first line of the body of evenElems creates the result array, which has the same element type as the argument.
So depending on the actual type parameter for T, this could be an Array[Int], or an Array[Boolean], or an array of some of the other primitive types in Java, or an array of some reference type.
But these types all have different runtime representations, so how is the Scala runtime going to pick the correct one? In fact, it can’t do that based on the information it is given, because the actual type that corresponds to the type parameter T is erased at runtime.
That’s why you will get the following error message if you attempt to compile the code above:
What’s required here is that you help the compiler by providing a runtime hint of what the actual type parameter of evenElems is.
A class manifest is a type descriptor object that describes what the top-level class of a type is.
The Scala compiler will generate code to construct and pass class manifests automatically if you instruct it to do so.
Using an alternative and shorter syntax, you can also demand that the type comes with a class manifest by using a context bound.
This means following the type with a colon and the class name ClassManifest, like this:
The two revised versions of evenElems mean exactly the same.
What happens in either case is that when the Array[T] is constructed, the compiler will look for a class manifest for the type parameter T, that is, it will look for an implicit value of type ClassManifest[T]
If such a value is found, the manifest is used to construct the right kind of array.
Otherwise, you’ll see an error message like the one shown previously.
Here is an interpreter interaction that uses the evenElems method:
In both cases, the Scala compiler automatically constructed a class manifest for the element type (first Int, then String) and passed it to the implicit parameter of the evenElems method.
The compiler can do that for all concrete types, but not if the argument is itself another type parameter without its class manifest.
What happened here is that the evenElems demands a class manifest for the type parameter U, but none was found.
The solution in this case is, of course, to demand another implicit class manifest for U.
This example also shows that the context bound in the definition of U is just a shorthand for an implicit parameter named here evidence$1 of type ClassManifest[U]
Whenever you create an array of a type parameter T, you also need to provide an implicit class manifest for T.
The easiest way to do this is to declare the type parameter with a ClassManifest context bound, as in [T: ClassManifest]
Like arrays, strings are not directly sequences, but they can be converted to them, and they also support all sequence operations.
Here are some examples of operations you can invoke on strings:
These operations are supported by two implicit conversions, which were explained in Section 21.7
This conversion was applied in the last line of the previous example in which a string was converted into a Seq.
The other, high-priority conversion maps a string to a StringOps object, which adds all methods on immutable sequences to strings.
This conversion was implicitly inserted in the method calls of reverse, map, drop, and slice in the previous example.
As the previous explanations have shown, different collection types have different performance characteristics.
That’s often the primary reason for picking one collection type over another.
The entries in these two tables are explained as follows:
Some invocations of the operation might take longer, but if many operations are performed on average only constant time per operation is taken.
Log The operation takes time proportional to the logarithm of the collection size.
Table 24.10 treats sequence types—both immutable and mutable—with the following operations:
Table 24.11 treats mutable and immutable sets and maps with the following operations:
The collection libraries have a uniform approach to equality and hashing.
The idea is, first, to divide collections into sets, maps, and sequences.
On the other hand, within the same category, collections are equal if and.
It does not matter for the equality check whether a collection is mutable or immutable.
For a mutable collection, equality simply depends on the current elements at the time the equality test is performed.
This means that a mutable collection might be equal to different collections at different times, depending what elements are added or removed.
This is a potential trap when using a mutable collection as a key in a hash map.
In this example, the selection in the last line will most likely fail because the hash code of the array xs has changed in the second-to-last line.
Therefore, the hash-code-based lookup will look at a different place than the one in which xs was stored.
Collections have quite a few methods that construct new collections.
We call such methods transformers because they take at least one collection as their receiver object and produce another collection in their result.
Transformers can be implemented in two principal ways: strict and nonstrict (or lazy)
A strict transformer constructs a new collection with all of its elements.
A non-strict, or lazy, transformer constructs only a proxy for the result collection, and its elements are constructed on demand.
As an example of a non-strict transformer, consider the following implementation of a lazy map operation:
Note that lazyMap constructs a new Iterable without stepping through all elements of the given collection coll.
The given function f is instead applied to the elements of the new collection’s iterator as they are demanded.
Scala collections are by default strict in all their transformers, except for Stream, which implements all its transformer methods lazily.
However, there is a systematic way to turn every collection into a lazy one and vice versa, which is based on collection views.
A view is a special kind of collection that represents some base collection, but implements all of its transformers lazily.
To go from a collection to its view, you can use the view method on the collection.
If xs is some collection, then xs.view is the same collection, but with all transformers implemented lazily.
To get back from a view to a strict collection, you can use the force method.
As an example, say you have a vector of Ints over which you want to map two functions in succession:
In many situations, constructing the intermediate result from the first call to map is a bit wasteful.
In the pseudo example, it would be faster to do a.
If you have the two functions available in the same place you can do this by hand.
But quite often, successive transformations of a data structure are done in different program modules.
A more general way to avoid the intermediate results is by turning the vector first into a view, applying all transformations to the view, and finally forcing the view to a vector:
We’ll do this sequence of operations again, one by one:
The application v.view gives you a SeqView, i.e., a lazily evaluated Seq.
The first, Int, shows the type of the view’s elements.
The second, Vector[Int], shows you the type constructor you get back when forcing the view.
It does not apply that map until the view is forced, however.
The “M” after SeqView is an indication that the view encapsulates a map operation.
For instance “S” indicates a delayed slice operation, and “R” indicates a reverse.
We’ll now apply the second map to the last result.
Both stored functions get applied as part of the execution of the force operation and a new vector is constructed.
One detail to note is that the static type of the final result is a Seq, not a Vector.
Tracing the types back we see that as soon as the first delayed map was applied, the result had static type SeqViewM[Int, Seq[_]]
That is, the “knowledge” that the view was applied to the specific sequence type Vector got lost.
There are two reasons why you might want to consider using views.
You have seen that by switching a collection to a view the construction of intermediate results can be avoided.
As another example, consider the problem of finding the first palindrome in a list of words.
A palindrome is a word that reads backwards the same as forwards.
Now, assume you have a very long sequence words and you want to find a palindrome in the first million words of that sequence.
Can you re-use the definition of findPalindrome? Of course, you could write:
This nicely separates the two aspects of taking the first million words of a sequence and finding a palindrome in it.
But the downside is that it always constructs an intermediary sequence consisting of one million words, even if the first word of that sequence is already a palindrome.
So potentially, 999,999 words are copied into the intermediary result without being inspected at all afterwards.
Many programmers would give up here and write their own specialized version of finding palindromes in some given prefix of an argument sequence.
An exception to this is arrays: applying delayed operations on arrays will again give results with static type Array.
This has the same nice separation of concerns, but instead of a sequence of a million elements it will only construct a single lightweight view object.
This way, you do not need to choose between performance and modularity.
The second use case applies to views over mutable sequences.
Many transformer functions on such views provide a window into the original sequence that can then be used to update selectively some elements of that sequence.
To see this in an example, suppose you have an array arr:
You can create a subwindow into that array by creating a slice of a view of the array:
The view does not copy these elements, it just provides a reference to them.
Now, assume you have a method that modifies some elements of a sequence.
For instance, the following negate method would negate all elements of the sequence of integers it’s given:
Assume now you want to negate elements at positions three through five of the array arr.
Can you use negate for this? Using a view, this is simple:
What happened here is that negate changed all elements of subarr, which were a slice of the elements of arr.
Again, you see that views help in keeping things modular.
The code above nicely separated the question of what index range to apply a method to from the question what method to apply.
After having seen all these nifty uses of views you might wonder why have strict collections at all? One reason is that performance comparisons do.
For smaller collection sizes the added overhead of forming and applying closures in views is often greater than the gain from avoiding the intermediary data structures.
A possibly more important reason is that evaluation in views can be very confusing if the delayed operations have side effects.
Here’s an example that bit a few users of versions of Scala before 2.8
In these versions the Range type was lazy, so it behaved in effect like a view.
People were trying to create a number of actors7 like this:
They were surprised that none of the actors were executing afterwards, even though the actor method should create and start an actor from the code that’s enclosed in the braces following it.
To explain why nothing happened, remember that the for expression above is equivalent to an application of the map method:
That is, no element was computed, and, consequently, no actor was created! Actors would have been created by forcing the range of the whole expression, but it’s far from obvious that this is what was required to make the actors do their work.
To avoid surprises like this, the Scala 2.8 collections library has more regular rules.
The only way to go from a strict to a lazy collection is via the view method.
So the actors definition above would behave as expected in Scala 2.8 in that it would create and start ten actors.
To get back the surprising previous behavior, you’d have to add an explicit view method call:
In summary, views are a powerful tool to reconcile concerns of efficiency with concerns of modularity.
But in order not to be entangled in aspects of delayed evaluation, you should restrict views to two scenarios.
Either you apply views in purely functional code where collection transformations do.
Or you apply them over mutable collections where all modifications are done explicitly.
What’s best avoided is a mixture of views and operations that create new collections while also having side effects.
An iterator is not a collection, but rather a way to access the elements of a collection one by one.
The two basic operations on an iterator it are next and hasNext.
A call to it.next() will return the next element of the iterator and advance the state of the iterator.
Calling next again on the same iterator will then yield the element one beyond the one returned previously.
You can find out whether there are more elements to return using Iterator’s hasNext method.
The most straightforward way to “step through” all the elements returned by an iterator is to use a while loop:
Iterators in Scala also provide analogues of most of the methods that you find in the Traversable, Iterable, and Seq traits.
For instance, they provide a foreach method that executes a given procedure on each element returned by an iterator.
As always, for expressions can be used as an alternate syntax for expressions involving foreach, map, filter, and flatMap, so yet another way to print all elements returned by an iterator would be:
The other operations that Iterator has in common with Traversable have the same property of leaving the iterator at its end when done.
For instance, iterators provide a map method, which returns a new iterator:
As you can see, after the call to map, the it iterator has advanced to its end.
Another example is the dropWhile method, which can be used to find.
For instance, to find the first word in the iterator shown previously that has at least two characters, you could write:
Note again that it has changed by the call to dropWhile: it now points to the second word “number” in the list.
In fact, it and the result res4 returned by dropWhile will return exactly the same sequence of elements.
There is only one standard operation, duplicate, which allows you to re-use the same iterator:
The call to duplicate gives you two iterators, which each return exactly the same elements as the iterator it.
The two iterators work independently; advancing one does not affect the other.
By contrast the original iterator, it, is advanced to its end by duplicate and is thus rendered unusable.
In summary, iterators behave like collections if you never access an iterator again after invoking a method on it.
The Scala collection libraries make this explicit with an abstraction called TraversableOnce, which is a common supertrait of Traversable and Iterator.
As the name implies, TraversableOnce objects can be traversed using foreach, but the state of that object after the traversal is not specified.
If the TraversableOnce object is in fact an Iterator, it will be at its end after the traversal, but if it is a Traversable, it will still exist as before.
A common use case of TraversableOnce is as an argument type for methods that can take either an iterator or traversable as argument.
An example is the appending method ++ in trait Traversable.
It takes a TraversableOnce parameter, so you can append elements coming from either an iterator or a traversable collection.
Note: it will be at its end after this operation!
Note: The iterator advances to just after the element, or, if none is found, to the end.
Note: The iterator advances past the position of this element.
Note: The iterator advances past the position of this element.
Note: it will advance to the position after the n’th element, or to its end, if it contains less than n elements.
Needed so that iterators can be used in for expressions.
Note: At least one of it and jt will be at its end after this operation.
Adds a string to StringBuilder b that shows all elements returned by it between separators sep enclosed in strings start and end.
Converts the collection to a string that shows all elements returned by it between separators sep enclosed in strings start and end.
Sometimes you want an iterator that can “look ahead” so that you can inspect the next element to be returned without advancing past that element.
Consider, for instance, the task to skip leading empty strings from an iterator that returns a sequence of strings.
You might be tempted to write something like the following method:
But looking at this code more closely, it’s clear that this is wrong: the code will indeed skip leading empty strings, but it will also advance it past the first non-empty string!
The solution to this problem is to use a buffered iterator, an instance of trait BufferedIterator.
BufferedIterator is a subtrait of Iterator, which provides one extra method, head.
Calling head on a buffered iterator will return its first element, but will not advance the iterator.
Using a buffered iterator, skipping empty words can be written like this:
Every iterator can be converted to a buffered iterator by calling its buffered method.
Note that calling head on the buffered iterator, bit, did not advance it.
Therefore, the subsequent call, bit.next(), returned again the same value as bit.head.
You can take any collection name and follow it by a list of elements in parentheses.
The result will be a new collection with the given elements.
HashSet(dog, cat, bird) // A hash set of the same animals.
So this is a call to the apply method of the companion object of the List class.
That method takes an arbitrary number of arguments and constructs a list from them.
Every collection class in the Scala library has a companion object with such an apply method.
It does not matter whether the collection class represents a concrete implementation, like List, Stream, or Vector, or whether it is an trait such as Seq, Set, or Traversable.
In the latter case, calling apply will produce some default implementation of the trait.
Besides apply, every collection companion object also defines a member empty, which returns an empty collection.
So instead of List() you could write List.empty, instead of Map(), Map.empty, and so on.
Descendants of Seq traits also provide other factory operations in their companion objects.
What it is What it does S.empty The empty sequence.
S(x, y, z) A sequence consisting of elements x, y, and z.
S.fill(n)(e) A sequence of length n where each element is computed by expression e.
S.tabulate(n)(f) A sequence of length n where the element at each index i is computed by f(i)
S.range(start, end, step) The sequence of integers starting with start and progressing by step increments up to, and excluding, the end value.
For instance, both libraries know iterators, iterables, sets, maps, and sequences.
In particular, the Scala libraries put much more emphasis on immutable collections, and provide many more operations that transform a collection into a new one.
Sometimes you might need to convert from one collection framework to the other.
For instance, you might want to access to an existing Java collection, as if it were a Scala collection.
Or you might want to pass one of Scala’s collections to a Java method that expects the Java counterpart.
It is quite easy to do this, because Scala offers implicit conversions between all the major collection types in the JavaConversions object.
In particular, you will find bidirectional conversions between the following types:
You have now automatic conversions between Scala collections and their corresponding Java collections.
Internally, these conversion work by setting up a “wrapper” object that forwards all operations to the underlying collection object.
So collections are never copied when converting between Java and Scala.
An interesting property is that if you do a round-trip conversion from, say, a Java type to its corresponding Scala type, and back to the same Java type, you end up with the identical collection object you started with.
Some other common Scala collections exist that can also be converted to Java types, but for which no corresponding conversion exists in the other direction.
If you have existing applications written in Scala 2.7, porting them to use the new collections should be almost automatic.
There are only a couple of possible issues to take care of.
Generally, the old functionality of Scala 2.7 collections has been left in place.
Some features have been deprecated, which means they will removed in some future release.
You will get a deprecation warning when you compile code that makes use of these features in Scala 2.8
In a few places deprecation was unfeasible, because the operation in question was retained in 2.8, but changed in meaning or performance characteristics.
These cases will be flagged with migration warnings when compiled under 2.8
To get full deprecation and migration warnings with suggestions how to change your code, pass the -deprecation and -Xmigration flags to scalac.8 You can also pass the same options to the scala interpreter to get the warnings in an interactive session.
Note that -Xmigration is an extended option, so it starts with an X.
This package tried to mimic some of the Java collection library design in Scala, but in doing so broke many symmetries.
Most people who wanted Java collections bypassed jcl and used java.util directly.
Projections have been generalized and cleaned up and are now available as views.
It seems that projections were used rarely, so not much code should be affected by this change.
So, if your code uses either jcl or projections there might be some minor rewriting to do.
You’ve now seen how to use Scala’s collection in great detail.
Scala’s collections take the approach of giving you powerful building blocks rather than a number of ad hoc utility methods.
Putting together two or three such building blocks allows you to express an enormous number of useful computations.
This style of library is especially effective due to Scala having a light syntax for function literals, and due to it providing many collection types that are persistent and immutable.
This chapter has shown collections from the point of view of a programmer using the collection library.
The next chapter will show you how the collections are built and how you can add your own collection types.
This chapter describes the architecture of the Scala collections framework in detail.
Compared to what you learned in Chapter 24 you will find out more about the internal workings of the framework.
You will also learn how this architecture helps you define your own collections in a few lines of code, while reusing the overwhelming part of collection functionality from the framework.
Chapter 24 enumerated a large number of collection operations, which exist uniformly on many different collection implementations.
Implementing every collection operation anew for every collection type would lead to an enormous amount of code, most of which would be copied from somewhere else.
Such code duplication could lead to inconsistencies over time, when an operation is added or modified in one part of the collection library but not in others.
The principal design objective of the new collections framework was to avoid any duplication, defining every operation in as few places as possible.1 The design approach was to implement most operations in collection “templates” that can be flexibly inherited from individual base classes and implementations.
This chapter explains these templates and other classes and traits that constitute the “building blocks” of the framework, as well as the construction principles they support.
Ideally, everything should be defined in one place only, but there are a few exceptions where things needed to be redefined.
Almost all collection operations are implemented in terms of traversals and builders.
Traversals are handled by Traversable’s foreach method, and building new collections is handled by instances of class Builder.
Listing 25.1 presents a slightly abbreviated outline of this class.
You can add an element x to a builder b with b += x.
There’s also syntax to add more than one element at once, for instance b += (x, y), and b ++= xs work as for buffers (in fact, buffers are an enriched version of builders)
The state of the builder is undefined after taking its result, but it can be reset into a new empty state using clear()
Builders are generic in both the element type, Elem, and in the type, To, of collections they return.
Often, a builder can refer to some other builder for assembling the elements of a collection, but then would like to transform the result of the other builder, for example to give it a different type.
This task is simplified by method mapResult in class Builder.
Array buffers are builders for themselves, so taking the result() of an array buffer will return the same buffer.
If you want to use this buffer to produce a builder that builds arrays, you can use mapResult like this:
The result value, bldr, is a builder that uses the array buffer, buf, to collect elements.
When a result is demanded from bldr, the result of buf is computed, which yields the array buffer buf itself.
This array buffer is then mapped with _.toArray to an array.
So the end result is that bldr is a builder for arrays.
The main design objectives of the collection library redesign were to have, at the same time, natural types and maximal sharing of implementation code.
In particular, Scala’s collections follow the “same-result-type” principle: wherever possible, a transformation method on a collection will yield a collection of the same type.
For instance, the filter operation should yield, on every collection type, an instance of the same collection type.
Applying filter on a List should give a List; applying it on a Map should give a Map, and so on.
In the rest of this section, you will find out how this is achieved.
The fast track The material in this section is a bit more dense than usual and might require some time to absorb.
The Scala collection library avoids code duplication and achieves the “same-result-type” principle by using generic builders and traversals over collections in so-called implementation traits.
These traits are named with a Like suffix; for instance, IndexedSeqLike is the implementation trait for IndexedSeq, and similarly, TraversableLike is the implementation trait for Traversable.
Collection classes such as Traversable or IndexedSeq inherit all their concrete method implementations from these traits.
Implementation traits have two type parameters instead of one for normal collections.
They parameterize not only over the collection’s element type, but also over the collection’s representation type, i.e., the type of the underlying collection, such as Seq[I] or List[T]
The type parameter, Elem, stands for the element type of the traversable whereas the type parameter Repr stands for its representation.
In particular Repr might be instantiated to a type that is itself not a subtype of Traversable.
That way, classes outside the collections hierarchy such as String and Array can still make use of all operations defined in a collection implementation trait.
Taking filter as an example, this operation is defined once for all collection classes in the trait TraversableLike.
An outline of the relevant code is shown in Listing 25.2
The trait declares two abstract methods, newBuilder and foreach, which are implemented in concrete collection classes.
The filter operation is implemented in the same way for all collections using these methods.
It first constructs a new builder for the representation type Repr, using newBuilder.
It then traverses all elements of the current collection, using foreach.
If an element x satisfies the given predicate p (i.e., p(x) is true), it is added with the builder.
Finally, the elements collected in the builder are returned as an instance of the Repr collection type by calling the builder’s result method.
A bit more complicated is the map operation on collections.
For instance, if f is a function from String to Int, and xs is a List[String], then xs map f should give a List[Int]
Likewise, if ys is an Array[String], then ys map f should give a Array[Int]
The problem is how to achieve that without duplicating the definition of the map method in lists and arrays.
The newBuilder/foreach framework shown in Listing 25.2 is not sufficient for this because it only allows creation of new instances of the same collection.
What’s more, even the result type constructor of a function like map might depend in non-trivial ways on the other argument types.
However, if you map the function (_.toFloat) over the same bit set, the result is a general Set[Float]
Of course, it can’t be a bit set because bit sets contain Ints, not Floats.
Note that map’s result type depends on the type of function that’s passed to it.
If the result type of that function argument is again an Int, the result of map is a BitSet, but if the result type of the function argument is something else, the result of map is just a Set.
You’ll find out soon how this typeflexibility is achieved in Scala.
Here are two more interactions with the interpreter that both map a function over a map:
The first function swaps two arguments of a key/value pair.
The result of mapping this function is again a map, but now going in the other direction.
In fact, the first expression yields the inverse of the original map, provided.
The second function, however, maps the key/value pair to an integer, namely its value component.
In that case, we cannot form a Map from the results, but we still can form an Iterable, a supertrait of Map.
You might ask, why not restrict map so that it can always return the same kind of collection? For instance, on bit sets map could accept only Int-toInt functions and on maps it could only accept pair-to-pair functions.
Not only are such restrictions undesirable from an object-oriented modeling point of view, they are illegal because they would violate the Liskov substitution principle: A Map is an Iterable.
So every operation that’s legal on an Iterable must also be legal on a Map.
Scala solves this problem instead with overloading: not the simple form of overloading inherited by Java (that would not be flexible enough), but the more systematic form of overloading that’s provided by implicit parameters.
It’s quite similar to the implementation of filter shown in Listing 25.2
The principal difference is that where filter used the newBuilder method, which is abstract in class TraversableLike, map uses a builder factory that’s passed as an additional implicit parameter of type CanBuildFrom.
Listing 25.4 shows the definition of the trait CanBuildFrom, which represents builder factories.
It has three type parameters: Elem indicates the element type of the collection to be built, To indicates the type of collection to build, and From indicates the type for which this builder factory applies.
By defining the right implicit definitions of builder factories, you can tailor the right typing behavior as needed.
This means that when operating on a BitSet you can construct another BitSet provided the type of the collection to build is Int.
If this is not the case, you can always fall back to a different implicit builder factory, this time implemented in mutable.Set’s companion object.
The type of this more general builder factory, where A is a generic type parameter, is:
This means that when operating on an arbitrary Set (expressed by the existential type Set[_]) you can build a Set again, no matter what the element type A is.
Given these two implicit instances of CanBuildFrom, you can then rely on Scala’s rules for implicit resolution to pick the one that’s appropriate and maximally specific.
So implicit resolution provides the correct static types for tricky collection operations such as map.
But what about the dynamic types? Specifically, say you have a list value that has Iterable as its static type, and you map some function over that value:
The static type of ys above is Iterable, as expected.
But its dynamic type is (and should be) still List! This behavior is achieved by one more indirection.
The apply method in CanBuildFrom is passed the source collection as argument.
Most builder factories for generic traversables (in fact all except builder factories for leaf classes) forward the call to a method genericBuilder of a collection.
The genericBuilder method in turn calls the builder that belongs to the collection in which it is defined.
So Scala uses static implicit resolution to resolve constraints on the types of.
What needs to be done if you want to integrate a new collection class, so that it can profit from all predefined operations at the right types? In this section you’ll be walked through two examples that do this.
Say you want to create a new sequence type for RNA strands, which are sequences of bases A (adenine), T (thymine), G (guanine), and U (uracil)
The definitions for bases are easily set up as shown in Listing 25.5
Every base is defined as a case object that inherits from a common abstract class Base.
You can see in the examples two different ways to use collections to implement these functions.
The toInt function is implemented as a Map from Base values to integers.
This makes use of the fact that both maps and arrays are functions because they inherit from the Function1 trait.
The next task is to define a class for strands of RNA.
However, RNA strands can get quite long, so it makes sense to invest some work in a compact representation.
Because there are only four bases, a base can be identified with two bits, and you can therefore store sixteen bases as two-bit values in an integer.
The idea, then, is to construct a specialized subclass of Seq[Base], which uses this packed representation.
If clients cannot see what the representation details of RNA sequences are, it becomes possible to change these representation details at any point in the future without affecting client code.
In other words, this design achieves a good decoupling of the interface of RNA sequences and its implementation.
However, if constructing an RNA sequence with new is impossible, there must be some other way to create new RNA sequences, else the whole class would be rather useless.
In fact there are two alternatives for RNA sequence creation, both provided by the RNA1 companion object.
The first way is method fromSeq, which converts a given sequence of bases (i.e., a value of type Seq[Base]) into an instance of class RNA1
The fromSeq method does this by packing all the bases contained in its argument sequence into an array, then calling RNA1’s private constructor with that array and the length of the original sequence as arguments.
This makes use of the fact that a private constructor of a class is visible in the class’s companion object.
It takes a variable number of Base arguments and simply forwards them as a sequence to fromSeq.
The first two results are as expected, but the last result of taking the first three elements of rna1 might not be.
In fact, you see a IndexedSeq[Base] as static result type and a Vector as the dynamic type of the result value.
You might have expected to see an RNA1 value instead.
Class IndexedSeq, on the other hand, has a take method that returns an IndexedSeq, and that’s implemented in terms of IndexedSeq’s default implementation, Vector.
So that’s what you were seeing on the last line of the previous interaction.
Now that you understand why things are the way they are, the next question should be what needs to be done to change them? One way to do this would be to override the take method in class RNA1, maybe like this:
But what about drop, or filter, or init? In fact there are over fifty methods on sequences that return again a sequence.
For consistency, all of these would have to be overridden.
Fortunately, there is a much easier way to achieve the same effect.
The RNA class needs to inherit not only from IndexedSeq, but also from its implementation trait IndexedSeqLike.
The new implementation differs from the previous one in only two aspects.
The IndexedSeqLike trait implements all concrete methods of IndexedSeq in an extensible way.
To be able to do this, IndexedSeqLike bases itself on the newBuilder abstraction, which creates a builder of the right kind.
Subclasses of trait IndexedSeqLike have to override newBuilder to return collections of their own kind.
To construct this builder, it first creates an ArrayBuffer, which itself is a Builder[Base, ArrayBuffer]
It then transforms the ArrayBuffer builder by calling its mapResult method to an RNA2 builder.
The mapResult method expects a transformation function from ArrayBuffer to RNA2 as its parameter.
If you had left out the newBuilder definition, you would have gotten an error message like the following:
The error message is quite long and complicated, which reflects the intricate way the collection libraries are put together.
It’s best to ignore the information about where the methods come from, because in this case it detracts more than it helps.
In other words, the RNA2 class is invalid without a definition of newBuilder with the first result type.
With the refined implementation of the RNA class in Listing 25.7, methods like take, drop, or filter work now as expected:
However, there is another class of methods in collections that are not dealt with yet.
These methods do not always return the collection type exactly.
They might return the same kind of collection, but with a different element type.
If s is a Seq[Int], and f is a function from Int to String, then s.map(f) would return a Seq[String]
So the element type changes between the receiver and the result, but the kind of collection stays the same.
There are a number of other methods that behave like map.
For some of them you would expect this (e.g., flatMap, collect), but for others you might not.
How should these methods be adapted to RNA strands? Ideally we’d expect that mapping bases to bases over an RNA strand would yield again an RNA strand:
Likewise, appending two RNA strands with ++ should yield again another RNA strand:
On the other hand, mapping bases to some other type over an RNA strand cannot yield another RNA strand because the new elements have the wrong type.
In the same vein appending elements that are not of type Base to an RNA strand can yield a general sequence, but it cannot yield another RNA strand.
In fact, if you ran the first two examples above with instances of this class you would obtain:
So the result of map and ++ is never an RNA strand, even if the element type of the generated collection is a Base.
To see how to do better, it pays to have a close look at the signature of the map method (or of ++, which has a similar signature)
Here A is the type of elements of the collection, and Repr is the type of the collection itself, that is, the second type parameter that gets passed to implementation classes such as TraversableLike and IndexedSeqLike.
The map method takes two more type parameters, B and That.
The B parameter stands for the result type of the mapping function, which is also the element type of the new collection.
The That appears as the result type of map, so it represents the type of the new collection that gets created.
How is the That type determined? In fact it is linked to the other types by an implicit parameter cbf, of type CanBuildFrom[Repr, B, That]
These CanBuildFrom implicits are defined by the individual collection classes.
In essence, an implicit value of type CanBuildFrom[From, Elem, To] says: “Here is a way, given a collection of type From, to build with elements of type Elem a collection of type To.”
Now the behavior of map and ++ on RNA2 sequences becomes clearer.
There is no CanBuildFrom instance that creates RNA2 sequences, so the next best available CanBuildFrom was found in the companion object of the inherited trait IndexedSeq.
That implicit creates IndexedSeqs, and that’s what you saw when applying map to rna2
To address this shortcoming, you need to define an implicit instance of CanBuildFrom in the companion object of the RNA class.
Hence, this instance states that, given an RNA strand and a new element type Base, you can.
First, the newBuilder implementation has moved from the RNA class to its companion object.
The newBuilder method in class RNA simply forwards to this definition.
Second, there is now an implicit CanBuildFrom value in object RNA.
To create such an object you need to define two apply methods in the CanBuildFrom trait.
Both create a new builder for an RNA collection, but they differ in their argument list.
The apply() method simply creates a new builder of the right type.
By contrast, the apply(from) method takes the original collection as argument.
This can be useful to adapt the dynamic type of builder’s return type to be the same as the dynamic type of the receiver.
In the case of RNA this does not come into play because RNA is a final class, so any receiver of static type RNA.
That’s why apply(from) also simply calls newBuilder, ignoring its argument.
The RNA class in Listing 25.8 implements all collection methods at their natural types.
In essence, you need to know where to put the newBuilder factories and the canBuildFrom implicits.
On the plus side, with relatively little code you get a large number of methods automatically defined.
Also, if you don’t intend to do bulk operations like take, drop, map, or ++ on your collection you can choose to not go the extra length and stop at the implementation shown in Listing 25.6
The discussion so far centered on the minimal amount of definitions needed to define new sequences with methods that obey certain types.
But in practice you might also want to add new functionality to your sequences or to override existing methods for better efficiency.
An example of this is the overridden foreach method in class RNA.
Furthermore, many other collection methods are implemented in terms of foreach.
So it makes sense to invest some effort optimizing the method’s implementation.
The standard implementation of foreach in IndexedSeq will simply select every i’th element of the collection using apply, where i ranges from 0 to the collection’s length minus one.
So this standard implementation selects an array element and unpacks a base from it once for every element in an RNA strand.
The overriding foreach in class RNA is smarter than that.
For every selected array element it immediately applies the given function to all bases contained in it.
So the effort for array selection and bit unpacking is much reduced.
As a second example you’ll learn how to integrate a new kind of map into the collection framework.
The idea is to implement a mutable map with String as the type of keys by a “Patricia trie”.2 The term Patricia is in fact an abbreviation for “Practical Algorithm to Retrieve Information Coded in Alphanumeric.” The idea is to store a set or a map as a tree where subsequent character in a search key determines uniquely a descendant tree.
For instance a Patricia trie storing the three strings "abc", "abd", "al", "all", "xy" would.
To find the node corresponding to the string "abc" in this trie, simply follow the subtree labeled "a", proceed from there to the subtree labeled "b", to finally reach its subtree labeled "c"
If the Patricia trie is used as a map, the value that’s associated with a key is stored in the nodes that can be reached by the key.
If it is a set, you simply store a marker saying that the node is present in the set.
Another nice feature is that they support selecting a subcollection by giving a prefix.
For instance, in the tree in Figure 25.1 you can obtain the sub-collection of all keys that start with an "a" simply by following the "a" link from the root of the tree.
Based on these ideas we will now walk you through the implementation of a map that’s implemented as a Patricia trie.
We call the map a PrefixMap, which means that it provides a method withPrefix that selects a submap of all keys starting with a given prefix.
We’ll first define a prefix map with the keys shown in Figure 25.1:
Then calling withPrefix on m will yield another prefix map:
You have seen this pattern already for sequences in the RNA strand example; then as now inheriting an implementation class such as MapLike serves to get the right result type for transformations such as filter.
A prefix map node has two mutable fields: suffixes and value.
The value field contains an optional value that’s associated with the node.
The suffixes field contains a map from characters to PrefixMap values.
You might ask why did we pick an immutable map as the implementation type for suffixes? Would not a mutable map have been more standard, since PrefixMap as a whole is also mutable? The answer is that immutable maps that contain only a few elements are very efficient in both space and execution time.
For instance, maps that contain fewer than 5 elements are represented as a single object.
So if small collections are common, it’s better to pick immutable over mutable.
In the case of Patricia tries, we’d expect that most nodes except the ones at the very top of the tree would contain only a few successors.
So storing these successors in an immutable map is likely to be more efficient.
Now have a look at the first method that needs to be implemented for a map: get.
The algorithm is as follows: To get the value associated with the empty string in a prefix map, simply select the optional value stored in the root of the tree.
Otherwise, if the key string is not empty, try to select the submap corresponding to the first character of the string.
If that yields a map, follow up by looking up the remainder of the key string after its first character in that map.
If the selection fails, the key is not stored in the map, so return with None.
The combined selection over an option value is elegantly expressed using flatMap.
When applied to an optional value, ov, and a closure, f, which in turn returns an optional value, ov flatMap f will succeed if both ov and f return a defined value.
The next two methods to implement for a mutable map are += and -=
In the implementation of Listing 25.10, these are defined in terms of two other methods: update and remove.
The remove method is very similar to get, except that before returning any associated value, the field containing that value is set to None.
The update method first calls withPrefix to navigate to the tree node that needs.
The withPrefix method navigates through the tree, creating sub-maps as necessary if some prefix of characters is not yet contained as a path in the tree.
The last abstract method to implement for a mutable map is iterator.
This method needs to produce an iterator that yields all key/value pairs stored in the map.
For any given prefix map this iterator is composed of the following parts: First, if the map contains a defined value, Some(x), in the value field at its root, then ("", x) is the first element returned from the iterator.
Furthermore, the iterator needs to traverse the iterators of all submaps stored in the suffixes field, but it needs to add a character in front of every key string returned by those iterators.
More precisely, if m is the submap reached from the root through a character chr, and (s, v) is an element returned from m.iterator, then the root’s iterator will return (chr +: s, v) instead.
This logic is implemented quite concisely as a concatenation of two for expressions in the implementation of the iterator method in Listing 25.10
This makes use of the fact that Option values define an iterator method that returns either no element, if the option value is None, or exactly one element x, if the option value is Some(x)
Note that there is no newBuilder method defined in PrefixMap.
There is no need to, because maps and sets come with default builders, which are instances of class MapBuilder.
For a mutable map the default builder starts with an empty map and then adds successive elements using the map’s += method.
The default builders for immutable maps and sets use the non-destructive element addition method +, instead of method +=
However, in all these cases, to build the right kind of set or map, you need to start with an empty set or map of this kind.
This is provided by the empty method, which is the last method defined in PrefixMap.
In Listing 25.10, this method simply returns a fresh PrefixMap.
We’ll now turn to the companion object PrefixMap, which is shown in Listing 25.11
In fact it is not strictly necessary to define this companion object, as class PrefixMap can stand well on its own.
The main purpose of object PrefixMap is to define some convenience factory methods.
It also defines a CanBuildFrom implicit to make typing work out better.
The same methods are present for all other collections in Scala’s collection framework so it makes sense to define them here, too.
The other member in object PrefixMap is an implicit CanBuildFrom instance.
It has the same purpose as the CanBuildFrom definition in the last section: to make methods like map return the best possible type.
For instance, consider mapping a function over the key/value pairs of a PrefixMap.
As long as that function produces pairs of strings and some second type, the result collection will again be a PrefixMap.
The given function argument takes the key/value bindings of the prefix map res0 and produces pairs of strings.
The result of the map is a PrefixMap, this time with value type String instead of Int.
Without the canBuildFrom implicit in PrefixMap the result would just have been a general mutable map, not a prefix map.
To summarize, if you want to fully integrate a new collection class into the framework you need to pay attention to the following points:
Inherit from the right implementation trait to implement most collection operations.
If you want map and similar operations to return instances of your collection type, provide an implicit CanBuildFrom in your class’s companion object.
You have now seen how Scala’s collections are built and how you can build new kinds of collections.
Because of Scala’s rich support for abstraction, each new collection type can have a large number of methods without having to reimplement them all over again.
By now you have probably grown accustomed to the concise way data can be decomposed and analyzed using pattern matching.
This chapter shows you how to generalize this concept further.
For instance, Some(x) is a valid pattern because Some is a case class.
Sometimes you might wish that you could write patterns like this without creating an associated case class.
In fact, you might wish to be able to create your own kinds of patterns.
This chapter explains what extractors are and how you can use them to define patterns that are decoupled from an object’s representation.
To illustrate the problem extractors solve, imagine that you need to analyze strings that represent email addresses.
Given a string, you want to decide whether it is an email address or not, and, if it is, you want to access the user and domain parts of the address.
The traditional way to do this uses three helper functions:
With these functions, you could parse a given string s as follows:
What’s more, things would become more complicated if you combined several such tests.
For instance you might want to find two successive strings in a list that are both email addresses with the same user.
You can try this yourself with the access functions defined previously to see what would be involved.
You saw already in Chapter 15 that pattern matching is ideal for attacking problems like this.
Let’s assume for the moment that you could match a string with a pattern:
The pattern would match if the string contained an embedded at sign (@)
In that case it would bind variable user to the part of the string before the @ and variable domain to the part after it.
Postulating a pattern like this, the previous expression could be written more clearly like this:
The more complicated problem of finding two successive email addresses with the same user part would translate to the following pattern:
This is much more legible than anything that could be written with access functions.
However, the problem is that strings are not case classes; they do not have a representation that conforms to EMail(user, domain)
This is where Scala’s extractors come in: they let you define new patterns for preexisting types, where the pattern need not follow the internal representation of the type.
An extractor in Scala is an object that has a method called unapply as one of its members.
The purpose of that unapply method is to match a value and.
Often, the extractor object also defines a dual method apply for building values, but this is not required.
As an example, Listing 26.1 shows an extractor object for email addresses:
The apply method has the same meaning as always: it turns EMail into an object that can be applied to arguments in parentheses in the same way a method is applied.
So you can write EMail("John", "epfl.ch") to construct the string "John@epfl.ch"
To make this more explicit, you could also let EMail inherit from Scala’s function type, like this:
As a result of this declaration, you could, for example, pass EMail to a method expecting a Function2[String, String, String]
The unapply method is what turns EMail into an extractor.
In a sense, it reverses the construction process of apply.
Where apply takes two strings and forms an email address string out of them, unapply takes an email address and returns potentially two strings: the user and the domain of the address.
But unapply must also handle the case where the given string is not an email address.
That’s why unapply returns an Option-type over pairs of strings.
Its result is either Some(user, domain) if the string str is an email.
Now, whenever pattern matching encounters a pattern referring to an extractor object, it invokes the extractor’s unapply method on the selector expression.
As you saw previously, this call to EMail.unapply will return either None or Some(u, d), for some values u for the user part of the address and d for the domain part.
In the None case, the pattern does not match, and the system tries another pattern or fails with a MatchError exception.
In the Some(u, d) case, the pattern matches and its variables are bound to the elements of the returned value.
In the previous match, user would be bound to u and domain would be bound to d.
In the EMail pattern matching example, the type String of the selector expression, selectorString, conformed to unapply’s argument type (which in the example was also String)
It would also be possible to use the EMail extractor to match selector expressions for more general types.
For instance, to find out whether an arbitrary value x was an email address string, you could write:
Given this code, the pattern matcher will first check whether the given value x conforms to String, the parameter type of EMail’s unapply method.
If it does conform, the value is cast to String and pattern matching proceeds as before.
As demonstrated here, where Some is applied to the tuple, (user, domain), you can leave off one pair of parentheses when passing a tuple to a function that takes a single argument.
In object EMail, the apply method is called an injection, because it takes some arguments and yields an element of a given set (in our case: the set of strings that are email addresses)
The unapply method is called an extraction, because it takes an element of the same set and extracts some of its parts (in our case: the user and domain substrings)
Injections and extractions are often grouped together in one object, because then you can use the object’s name for both a constructor and a pattern, which simulates the convention for pattern matching with case classes.
However, it is also possible to define an extraction in an object without a corresponding injection.
The object itself is called an extractor, regardless of whether or not it has an apply method.
If an injection method is included, it should be the dual to the extraction method.
Going in the other direction means running first the unapply and then the apply, as shown in the following code:
In that code, if the match on obj succeeds, you’d expect to get back that same object from the apply.
These two conditions for the duality of apply and unapply are good design principles.
They are not enforced by Scala, but it’s recommended to keep to them when designing your extractors.
The unapply method of the previous example returned a pair of element values in the success case.
This is easily generalized to patterns of more than two variables.
To bind N variables, an unapply would return an N-element tuple, wrapped in a Some.
The case where a pattern binds just one variable is treated differently, however.
For example, the extractor object shown in Listing 26.2 defines apply and unapply for strings that consist of the same substring appearing twice in a row:
It’s also possible that an extractor pattern does not bind any variables.
In that case the corresponding unapply method returns a boolean—true for success and false for failure.
For instance, the extractor object shown in Listing 26.3 characterizes strings consisting of all uppercase characters:
This time, the extractor only defines an unapply, but not an apply.
It would make no sense to define an apply, as there’s nothing to construct.
The following userTwiceUpper function applies all previously defined extractors together in its pattern matching code:
The first pattern of this function matches strings that are email addresses whose user part consists of two occurrences of the same string in uppercase letters.
Note that UpperCase in function userTwiceUpper takes an empty parameter list.
This cannot be omitted as otherwise the match would test for equality with the object UpperCase! Note also that, even though UpperCase() itself does not bind any variables, it is still possible to associate a variable with the whole pattern matched by it.
For instance, in the first userTwiceUpper invocation above, x was bound to "DI", because that was the value against which the UpperCase() pattern was matched.
The previous extraction methods for email addresses all returned a fixed number of element values.
For example, you might want to match on a string representing a domain name, so that every part of the domain is kept in a different sub-pattern.
This would let you express patterns such as the following:
In this example things were arranged so that domains are expanded in reverse order—from the top-level domain down to the sub-domains.
This feature is more useful if the top-level domain comes first, because then you can use sequence wildcards to match sub-domains of arbitrary depth.
The question remains how an extractor can support vararg matching as shown in the previous example, where patterns can have a varying number of sub-patterns.
The unapply methods encountered so far are not sufficient, because they each return a fixed number of sub-elements in the success case.
To handle this case, Scala lets you define a different extraction method specifically for vararg matching.
To see how it is written, have a look at the Domain extractor, shown in Listing 26.4:
The Domain object defines an unapplySeq method that first splits the string into parts separated by periods.
This is done using Java’s split method on strings, which takes a regular expression as its argument.
The result of unapplySeq is then that array with all elements reversed and wrapped in a Some.
The result type of an unapplySeq must conform to Option[Seq[T]], where the element type T is arbitrary.
As you saw in Section 17.1, Seq is an important class in Scala’s collection hierarchy.
It’s a common superclass of several classes describing different kinds of sequences: Lists, Arrays, WrappedString, and several others.
For symmetry, Domain also has an apply method that builds a domain string from a variable argument parameter of domain parts starting with the top-level domain.
You can use the Domain extractor to get more detailed information out of email strings.
For instance, to search for an email address named "tom" in some “.com” domain, you could write the following function:
It’s also possible to return some fixed elements from an unapplySeq together with the variable part.
This is expressed by returning all elements in a tuple, where the variable part comes last, as usual.
As an example, Listing 26.5 shows a new extractor for emails where the domain part is already expanded into a sequence:
The unapplySeq method in ExpandedEMail returns an optional value of a pair (a Tuple2)
The first element of the pair is the user part.
You saw in Section 15.2 that you can access the elements of a list or an array using sequence patterns such as:
In fact, these sequence patterns are all implemented using extractors in the standard Scala library.
The List object contains an apply method that takes a variable number of arguments.
It also contains an unapplySeq method that returns all elements of the list as a sequence.
Even though they are very useful, case classes have one shortcoming: they expose the concrete representation of data.
This means that the name of the class in a constructor pattern corresponds to the concrete representation type of the selector object.
In open systems of large size, representation independence is very important because it allows you to change an implementation type used in a set of components without affecting clients of these components.
If your component had defined and exported a set of case classes, you’d be stuck with them because client code could already contain pattern matches against these case classes.
Renaming some case classes or changing the class hierarchy would affect client code.
Extractors do not share this problem, because they represent a layer of indirection between a data representation and the way it is viewed by clients.
You could still change a concrete representation of a type, as long as you update all your extractors with it.
Representation independence is an important advantage of extractors over case classes.
On the other hand, case classes also have some advantages of their own over extractors.
First, they are much easier to set up and to define, and they require less code.
Second, they usually lead to more efficient pattern matches than extractors, because the Scala compiler can optimize patterns over case classes much better than patterns over extractors.
This is because the mechanisms of case classes are fixed, whereas an unapply or unapplySeq method in an extractor could do almost anything.
Third, if your case classes inherit from a sealed base class, the Scala compiler will check.
So which of the two methods should you prefer for your pattern matches? It depends.
If you write code for a closed application, case classes are usually preferable because of their advantages in conciseness, speed and static checking.
If you decide to change your class hierarchy later, the application needs to be refactored, but this is usually not a problem.
On the other hand, if you need to expose a type to unknown clients, extractors might be preferable because they maintain representation independence.
You could always start with case classes and then, if the need arises, change to extractors.
Because patterns over extractors and patterns over case classes look exactly the same in Scala, pattern matches in your clients will continue to work.
Of course, there are also situations where it’s clear from the start that the structure of your patterns does not match the representation type of your data.
The email addresses discussed in this chapter were one such example.
One particularly useful application area of extractors are regular expressions.
Like Java, Scala provides regular expressions through a library, but extractors make it much nicer to interact with them.
Scala inherits its regular expression syntax from Java, which in turn inherits most of the features of Perl.
Here are just some examples that should be enough as refreshers:
The number contains three groups, i.e., the minus sign, the part before the decimal point, and the fractional part including the decimal point.
A new regular expression value is created by passing a string to the Regex constructor.
Note that, compared to the regular expression for decimal numbers given previously, every backslash appears twice in the string above.
This is because in Java and Scala a single backslash is an escape character in a string literal, not a regular character that shows up in the string.
If a regular expression contains many backslashes this might be a bit painful to write and to read.
As you saw in Section 5.2, a raw string is a sequence of characters between triple quotes.
The difference between a raw and a normal string is that all characters in a raw string appear exactly as they are typed.
This includes backslashes, which are not treated as escape characters.
As you can see from the interpreter’s output, the generated result value for Decimal is exactly the same as before.
Another, even shorter way to write a regular expression in Scala is this:
In other words, simply append a .r to a string to obtain a regular expression.
This is possible because there is a method named r in class StringOps, which converts a string to a regular expression.
You can search for occurrences of a regular expression in a string using several different operators:
Finds first occurrence of regular expression regex in string str, returning the result in an Option type.
Finds all occurrences of regular expression regex in string str, returning the results in an Iterator.
Finds an occurrence of regular expression regex at the start of string str, returning the result in an Option type.
For instance, you could define the input sequence below and then search decimal numbers in it:
What’s more, every regular expression in Scala defines an extractor.
The extractor is used to identify substrings that are matched by the groups of the regular expression.
For instance, you could decompose a decimal number string as follows:
What happens here is that the Decimal regular expression value defines an unapplySeq method.
That method matches every string that corresponds to the regular expression syntax for decimal numbers.
If a group is missing, the element value is set to null, as can be seen in the following example:
It’s also possible to mix extractors with regular expression searches in a for expression.
For instance, the following expression decomposes all decimal numbers it finds in the input string:
In this chapter you saw how to generalize pattern matching with extractors.
Extractors let you define your own kinds of patterns, which need not correspond to the type of the expressions you select on.
This gives you more flexibility in the kinds of patterns you can use for matching.
In effect it’s like having different possible views on the same data.
It also gives you a layer between a type’s representation and the way clients view it.
This lets you do pattern matching while maintaining representation independence, a property which is very useful in large software systems.
Extractors are one more element in your tool box that let you define flexible library abstractions.
They are used heavily in Scala’s libraries, for instance, to enable convenient regular expression matching.
Like comments, they can be sprinkled throughout a program and attached to any variable, method, expression, or other program element.
Unlike comments, they have structure, thus making them easier to machine process.
It shows their general syntax and how to use several standard annotations.
This chapter does not show how to write new annotation processing tools, because it is beyond the scope of this book.
Chapter 31 shows one technique, but not the only one.
Instead, this chapter focuses on how to use annotations, because it is more common to use annotations than to define new annotation processors.
There are many things you can do with a program other than compiling and running it.
Pretty printing code so that it matches your preferred style.
Checking code for common errors such as opening a file but, on some control paths, never closing it.
Experimental type checking, for example to manage side effects or ensure ownership properties.
Such tools are called meta-programming tools, because they are programs that take other programs as input.
Annotations support these tools by letting the programmer sprinkle directives to the tool throughout their source code.
Such directives let the tools be more effective than if they could have no user input.
For example, annotations can improve the previously listed tools as follows:
A documentation generator could be instructed to document certain methods as deprecated.
A pretty printer could be instructed to skip over parts of the program that have been carefully hand formatted.
A checker for non-closed files could be instructed to ignore a particular file that has been manually verified to be closed.
A side-effects checker could be instructed to verify that a specified method has no side effects.
In all of these cases, it would in theory be possible for the programming language to provide ways to insert the extra information.
In fact, most of these are directly supported in some language or another.
However, there are too many such tools for one language to directly support them all.
Further, all of this information is completely ignored by the compiler, which after all just wants to make the code run.
Scala’s philosophy in cases like this is to include the minimum, orthogonal support in the core language such that a wide variety of metaprogramming tools can be written.
In this case, that minimum support is a system of annotations.
The compiler understands just one feature, annotations, but it doesn’t attach any meaning to individual annotations.
Each meta-programming tool can then define and use its own specific annotations.
The annotation is the @deprecated part, and it applies to the entirety of the bigMistake method (not shown—it’s too embarrassing)
Maybe bigMistake will be removed entirely from a future version of the code.
In the previous example, a method is annotated as @deprecated.
Annotations are allowed on any kind of declaration or definition, including vals, vars, defs, classes, objects, traits, and types.
The annotation applies to the entirety of the declaration or definition that follows it:
To do so, place a colon (:) after the expression and then write the annotation.
Syntactically, it looks like the annotation is being used as a type:
So far the annotations shown have been simply an at sign followed by an annotation class.
Such simple annotations are common and useful, but annotations have a richer general form:
For annotations that do have arguments, place the arguments in parentheses, for example, @serial(1234)
The precise form of the arguments you may give to an annotation depends on the particular annotation class.
Most annotation processors only let you supply immediate constants such as 123 or "hello"
The compiler itself supports arbitrary expressions, however, so long as they type check.
Some annotation classes can make use of this, for example, to let you refer to other variables that are in scope:
This means that named and default annotation arguments are supported naturally, because Scala already has named and default arguments for method and constructor calls.1 One slightly tricky bit concerns annotations that conceptually take other annotations as arguments, which are required by some frameworks.
You cannot write an annotation directly as an argument to an annotation, because annotations are not valid expressions.
They are for features that are used widely enough to merit putting in the language specification, but that are not fundamental enough to merit their own syntax.
Sometimes you write a class or method that you later wish you had not.
Once it is available, though, code written by other people might call the method.
Thus, you cannot simply delete the method, because this would cause other people’s code to stop compiling.
Deprecation lets you gracefully remove a method or class that turns out to be a mistake.
You mark the method or class as deprecated, and then anyone who calls that method or class will get a deprecation warning.
They had better heed this warning and update their code! The idea is that after a suitable amount of time has passed, you feel safe in assuming that all reasonable clients will have stopped accessing the deprecated class or method and thus that you can safely remove it.
You mark a method as deprecated simply by writing @deprecated before it.
Such an annotation will cause the Scala compiler to emit deprecation warnings whenever Scala code accesses the method.
If you supply a string as an argument to @deprecated, that string will be emitted along with the error message.
Use this message to explain to developers what they should use instead of the deprecated method.
Concurrent programming does not mix well with shared mutable state.
For this reason, the focus of Scala’s concurrency support is message passing and a minimum of shared mutable state.
Nonetheless, sometimes programmers want to use mutable state in their concurrent programs.
It informs the compiler that the variable in question will be used by multiple threads.
Such variables are implemented so that reads and writes to the variable are slower, but accesses from multiple threads behave more predictably.
On the Java platform, however, you get the same behavior as if you wrote the field in Java code and marked it with the Java volatile modifier.
A serialization framework helps you convert objects into a stream of bytes and vice versa.
This is useful if you want to save objects to disk or send them over the network.
Instead, you should use a framework from your underlying platform.
What Scala does is provide three annotations that are useful for a variety of frameworks.
Also, the Scala compiler for the Java platform interprets these annotations in the Java way (see Chapter 31)
The first annotation indicates whether a class is serializable at all.
A handle to a socket or GUI window, for example, cannot be serialized.
You should add a @serializable annotation to any class you would like to be serializable.
The second annotation helps deal with serializable classes changing as time goes by.
The framework should store this number in the generated byte stream.
When you later reload that byte stream and try to convert it to an object, the framework can check that the current version of the class has the same version number as the version.
The framework will then automatically refuse to load old instances of the class.
Finally, Scala provides a @transient annotation for fields that should not be serialized at all.
If you mark a field as @transient, then the framework should not save the field even when the surrounding object is serialized.
When the object is loaded, the field will be restored to the default value for the type of the field annotated as @transient.
Scala code normally does not need explicit get and set methods for fields, because Scala blends the syntax for field access and method invocation.
Some platform-specific frameworks do expect get and set methods, however.
If you add this annotation to a field, the compiler will automatically generate get and set methods for you.
If you annotate a field named crazy, the get method will be named getCrazy and the set method will be named setCrazy.
The generated get and set methods are only available after a compilation pass completes.
Thus, you cannot call these get and set methods from code you compile at the same time as the annotated fields.
This should not be a problem in practice, because in Scala code you can access the fields directly.
This feature is intended to support frameworks that expect regular get and set methods, and typically you do not compile the framework and the code that uses it at the same time.
You would typically add the @tailrec annotation to a method that needs to be tail recursive, for instance because you expect that it would recurse very deeply otherwise.
If the optimization cannot be performed, you will then get a warning together with an explanation of the reasons.
The @unchecked annotation is interpreted by the compiler during pattern matches.
It tells the compiler not to worry if the match expression seems to leave out some cases.
The @native annotation informs the compiler that a method’s implementation is supplied by the runtime rather than in Scala code.
The compiler will toggle the appropriate flags in the output, and it will be up to the developer to supply the implementation using a mechanism such as the Java Native Interface (JNI)
When using the @native annotation, a method body must be supplied, but it will not be emitted into the output.
For example, here is how to declare that method beginCountdown will be supplied by the runtime:
First of all it covered the syntax of annotations, because using annotations is far more common than defining new ones.
It covers annotations only available when targeting Java, additional meanings of standard annotations when targeting Java, how to interoperate with Java-based annotations, and how to use Java-based mechanisms to define and process annotations in Scala.
After discussing semistructured data in general, it shows the essential functionality in Scala for manipulating XML: how to make nodes with XML literals, how to save and load XML to files, and how to take apart XML nodes using query methods and pattern matching.
This chapter is just a brief introduction to what is possible with XML, but it shows enough to get you started.
It is more structured than plain strings, because it organizes the contents of the data into a tree.
Plain XML is less structured than the objects of a programming language, though, as it admits free-form text between tags and it lacks a type system.1
Semi-structured data is very helpful any time you need to serialize program data for saving in a file or shipping across a network.
Instead of converting structured data all the way down to bytes, you convert it to and from semi-structured data.
You then use pre-existing library routines to convert between semi-structured data and binary data, saving your time for more important problems.
There are many forms of semi-structured data, but XML is the most widely used on the Internet.
There are XML tools on most operating systems, and most programming languages have XML libraries available.
There are type systems for XML, such as XML Schemas, but they are beyond the scope of this book.
If you write software that communicates over the Internet, then sooner or later you will need to interact with some service that speaks XML.
For all of these reasons, Scala includes special support for processing XML.
This chapter shows you Scala’s support for constructing XML, processing it with regular methods, and processing it with Scala’s pattern matching.
In addition to these nuts and bolts, the chapter shows along the way several common idioms for using XML in Scala.
Tags, written like <pod>, consist of a less-than sign, an alphanumeric label, and a greater than sign.
An end tag looks just like a start tag except that it has a slash just before the tag’s label, like this: </pod>
Start and end tags must match each other, just like parentheses.
Any start tag must eventually be followed by an end tag with the same label.
Further, the contents of any two matching tags must itself be valid XML.
You cannot have two pairs of matching tags overlap each other:
Since tags are required to match in this way, XML is structured as nested elements.
Each pair of matching start and end tags forms an element, and elements may be nested within each other.
The full story is more complicated, but this is enough to be effective with XML.
Two other things you should know are, first, there is a shorthand notation for a start tag followed immediately by its matching end tag.
Simply write one tag with a slash put after the tag’s label.
Using an empty element, the previous example could just as well be written as follows:
An attribute is a name-value pair written with an equals sign in the middle.
The attribute name itself is plain, unstructured text, and the value is surrounded by either double quotes ("") or single quotes ('')
Scala lets you type in XML as a literal anywhere that an expression is valid.
Simply type a start tag and then continue writing XML content.
The compiler will go into an XML-input mode and will read content as XML until it sees the end tag matching the start tag you began with:
Class Node is the abstract superclass of all XML node classes.
For example, the “stuff” part of <a>stuff</a> is of class Text.
Many methods in the XML library process NodeSeqs in places you might expect them to process individual Nodes.
You can still use such methods with individual nodes, however, since Node extends from NodeSeq.
This may sound weird, but it works out well for XML.
You can think of an individual Node as a one-element NodeSeq.
A braces escape can include arbitrary Scala content, including further XML literals.
Thus, as the nesting level increases, your code can switch back and forth between XML and ordinary Scala code.
If the code inside the curly braces evaluates to either an XML node or a sequence of XML nodes, those nodes are inserted directly as is.
An expression inside a brace escape does not have to evaluate to an XML node.
In such a case, the result is converted to a string and inserted as a text node:
To contrast, if you create XML with low-level string operations, you will run into traps such as the following:
This behavior can allow some nasty surprises for the original programmer, because it allows the user to affect the resulting XML tree outside of the space provided for the user inside the <a> element.
You can prevent this entire class of problems by always constructing XML using XML literals, not string appends.
You have now seen enough of Scala’s XML support to write the first part of a serializer: conversion from internal data structures to XML.
All you need for this are XML literals and their brace escapes.
As an example, suppose you are implementing a database to keep track of your extensive collection of vintage Coca-Cola thermometers.
You might make the following internal class to hold entries in the catalog:
This is a straightforward, data-heavy class that holds various pieces of information such as when the thermometer was made, when you got it, and how much you paid for it.
To convert instances of this class to XML, simply add a toXML method that uses XML literals and brace escapes, like this:
Note The “new CCTherm” expression in the previous example works even though CCTherm is an abstract class, because this syntax actually instantiates an anonymous subclass of CCTherm.
Among the many methods available for the XML classes, there are three in particular that you should be aware of.
They allow you to take apart XML without thinking too much about the precise way XML is represented in Scala.
These methods are based on the XPath language for processing XML.
As is common in Scala, you can write them directly in Scala code instead of needing to invoke an external tool.
By calling the text method on any XML node you retrieve all of the text within that node, minus any element tags:
If you want to find a sub-element by tag name, simply call \ with the name of the tag:
The reason is that // starts a comment in Scala! Thus, some other symbol has to be used, and using the other kind of slashes works well.
Simply put an at sign (@) before the attribute name:
For example, you can parse back a CCTherm instance by using the following code:
This code searches through an input XML node, named node, to find each of the six pieces of data needed to specify a CCTherm.
The data that is text is extracted with .text and left as is.
There is one last part needed to write a data serializer: conversion between XML and streams of bytes.
This last part is the easiest, because there are library routines that will do it all for you.
You simply have to call the right routine on the right data.
To convert XML to a string, all you need is toString.
The presence of a workable toString is why you can experiment with XML in the Scala shell.
However, it is better to use a library routine and convert all the way to bytes.
That way, the resulting XML can include a directive that specifies which character encoding was used.
If you encode the string to bytes yourself, then the onus is on you to keep track of the character encoding.
To convert from XML to a file of bytes, you can use the XML.save command.
You must specify a file name and a node to be saved:
After running the above command, the resulting file therm1.xml looks like the following:
Loading is simpler than saving, because the file includes everything the loader needs to know.
There are many variations on these loading and saving methods, including methods for reading and writing to various kinds of readers, writers, input and output streams.
These are good when you know exactly what kind of XML structure you are taking apart.
Sometimes, though, there are a few possible structures the XML could have.
Maybe there are multiple kinds of records within the data, for example because you have extended your thermometer collection to include clocks and sandwich plates.
Maybe you simply want to skip over any white space between tags.
Whatever the reason, you can use the pattern matcher to sift through the possibilities.
The first case looks for an <a> element whose contents consist of a single sub-node.
It binds those contents to a variable named contents and then evaluates the code to the right of the associated right arrow (=>)
Thus it will fail to match in cases like the following:
If you want the function to match in cases like these, you can match against a sequence of nodes instead of a single one.
The pattern for “any sequence” of XML nodes is written ‘_*’
Here is the updated function that matches a sequence of sub-elements instead of a single sub-element:
As a final tip, be aware that XML patterns work very nicely with for expressions as a way to iterate through some parts of an XML tree while ignoring other parts.
For example, suppose you wish to skip over the white space between records in the following XML structure:
Visually, it looks like there are two nodes inside the <catalog> element.
There is white space before, after, and between the two elements! If you do not consider this white space, you might incorrectly process the thermometer records as follows:
This chapter has only scratched the surface of what you can do with XML.
There are many other extensions, libraries, and tools you could learn about, some customized for Scala, some made for Java but usable in Scala, and some language-neutral.
What you should walk away from this chapter with is how to use semi-structured data for interchange, and how to access semistructured data via Scala’s XML support.
In Chapter 1, we claimed that one way Scala is a scalable language is that you can use the same techniques to construct small as well as large programs.
Up to now in this book we’ve focused primarily on programming in the small: designing and implementing the smaller program pieces out of which you can construct a larger program.1 The other side of the story is programming in the large: organizing and assembling the smaller pieces into larger programs, applications, or systems.
In short, packages and access modifiers enable you to organize a large program using packages as modules, where a module is a “smaller program piece” with a well defined interface and a hidden implementation.
While the division of programs into packages is already quite helpful, it is limited because it provides no way to abstract.
You cannot reconfigure a package two different ways within the same program, and you cannot inherit between packages.
A package always includes one precise list of contents, and that list is fixed until you change the code.
In this chapter, we’ll discuss how you can use Scala’s object-oriented features to make a program more modular.
We’ll first show how a simple singleton object can be used as a module, and then we’ll show how you can use traits and classes as abstractions over modules.
These abstractions can be reconfigured into multiple modules, even multiple times within the same program.
Finally, we’ll show a pragmatic technique for using traits to divide a module across multiple files.
As a program grows in size, it becomes increasingly important to organize it in a modular way.
First, being able to compile different modules that make up the system separately helps different teams work independently.
In addition, being able to unplug one implementation of a module and plug in another is useful, because it allows different configurations of a system to be used in different contexts, such as unit testing on a developer’s desktop, integration testing, staging, and deployment.
For example, you may have an application that uses a database and a message service.
As you write code, you may want to run unit tests on your desktop that use mock versions of both the database and message service, which simulate these services sufficiently for testing without needing to talk across the network to a shared resource.
During integration testing, you may want to use a mock message service but a live developer database.
During staging and certainly during deployment, your organization will likely want to use live versions of both the database and message service.
Any technique that aims to facilitate this kind of modularity needs to provide a few essentials.
First, there should be a module construct that provides a good separation of interface and implementation.
Second, there should be a way to replace one module with another that has the same interface without changing or recompiling the modules that depend on the replaced one.
Lastly, there should be a way to wire modules together.
This wiring task can by thought of as configuring the system.
One approach to solving this problem is dependency injection, a technique supported on the Java platform by frameworks such as Spring and Guice, which are popular in the enterprise Java community.2 Spring, for example, essentially allows you to represent the interface of a module as a Java interface and implementations of the module as Java classes.
You can specify dependencies between modules and “wire” an application together via external XML configuration files.
Although you can use Spring with Scala and thereby use Spring’s approach to achieving system-level modularity of your Scala programs, with Scala you have some alternatives enabled by the language itself.
In the remainder of this chapter, we’ll show how to use objects as modules to achieve the desired “in the large” modularity without using an external framework.
Fowler, “Inversion of control containers and the dependency injection pattern.” [Fow04]
Imagine you are building an enterprise web application that will allow users to manage recipes.
You want to partition the software into layers, including a domain layer and an application layer.
In the domain layer, you’ll define domain objects, which will capture business concepts and rules and encapsulate state that will be persisted to an external relational database.
In the application layer, you’ll provide an API organized in terms of the services the application offers to clients (including the user interface layer)
The application layer will implement these services by coordinating tasks and delegating the work to the objects of the domain layer.3
Imagine also that you want to be able to plug in real or mock versions of certain objects in each of these layers, so that you can more easily write unit tests for your application.
To achieve this goal, you can treat the objects you want to mock as modules.
In Scala, there is no need for objects to be “small” things, no need to use some other kind of construct for “big” things like modules.
One of the ways Scala is a scalable language is that the same constructs are used for structures both small and large.
For example, since one of the “things” you want to mock in the domain layer is the object that represents the relational database, you’ll make that one of the modules.
In the application layer, you’ll treat a “database browser” object as a module.
The database will hold all of the recipes that a person has collected.
The browser will help search and browse that database, for example, to find every recipe that includes an ingredient you have on hand.
The first thing to do is to model foods and recipes.
To keep things simple, a food will simply have a name, as shown in Listing 29.1
A recipe will simply have a name, a list of ingredients, and some instructions, as shown in Listing 29.2
The naming of these layers follows that of Evans, Domain-Driven Design.
Scala uses objects for modules, so you can start modularizing your program by making two singleton objects to serve as the mock implementations of the database and browser modules during testing.
These entity classes are simplified to keep the example uncluttered with too much real-world detail.
To make things a little more interesting, suppose the database sorts foods into categories.
To implement this, you can add a FoodCategory class and a list of all categories in the database, as shown in Listing 29.5
Notice in this last example that the private keyword, so useful for implementing classes, is also useful for implementing modules.
Items marked private are part of the implementation of a module, and thus are particularly easy to change without affecting other modules.
At this point, many more facilities could be added, but you get the idea.
Programs can be divided into singleton objects, which you can think of as modules.
This is no big news, but it becomes very useful when you consider abstraction.
Although the examples shown so far did manage to partition your application into separate database and browser modules, the design is not yet very “modular.” The problem is that there is essentially a “hard link” from the browser module to the database modules:
Because the SimpleBrowser module mentions the SimpleDatabase module by name, you won’t be able to plug in a different implementation of the database module without modifying and recompiling the browser module.
In addition, although there’s no hard link from the SimpleDatabase module.
When making these modules more pluggable, however, it is important to avoid duplicating code, because much code can likely be shared by different implementations of the same module.
For example, suppose you want the same code base to support multiple recipe databases, and you want to be able to create a separate browser for each of these databases.
You would like to reuse the browser code for each of the instances, because the only thing different about the browsers is which database they refer to.
Except for the database implementation, the rest of the code can be reused character for character.
How can the program be arranged to minimize repetitive code? How can the code be made reconfigurable, so that you can configure it using either database implementation?
The answer is a familiar one: if a module is an object, then a template for a module is a class.
Just like a class describes the common parts of all its instances, a class can describe the parts of a module that are common to all of its possible configurations.
The browser definition therefore becomes a class, instead of an object, and the database to use is specified as an abstract member of the class, as shown in Listing 29.6
The database also becomes a class, including as much as possible that is common between all databases, and declaring the missing.
This is good, because each of these architectural layers should depend only on layers below them.
In this case, all database modules must define methods for allFoods, allRecipes, and allCategories, but since they can use an arbitrary definition, the methods must be left abstract in the Database class.
The foodNamed method, by contrast, can be defined in the abstract Database class, as shown in Listing 29.7:
The SimpleDatabase object must be updated to inherit from the abstract Database class, as shown in Listing 29.8:
Then, a specific browser module is made by instantiating the Browser class and specifying which database to use, as shown in Listing 29.9
You can use these more pluggable modules the same as before:
Now, however, you can create a second mock database, and use the same browser class with it, as shown in Listing 29.10:
Often a module is too large to fit comfortably into a single file.
When that happens, you can use traits to split a module into separate files.
For example, suppose you wanted to move categorization code out of the main Database file and into its own.
You could create a trait for the code as shown in Listing 29.11
Now class Database can mix in the FoodCategories trait instead of defining FoodCategory and allCategories itself, as shown in Listing 29.12:
Continuing in this way, you might try and divide SimpleDatabase into two traits, one for foods and one for recipes.
This would allow you to define SimpleDatabase, for example, as shown in Listing 29.13:
The SimpleFoods trait could look as shown in Listing 29.14:
So far so good, but unfortunately, a problem arises if you try to define a SimpleRecipes trait like this:
The problem here is that Pear is located in a different trait from the one that uses it, so it is out of scope.
The compiler has no idea that SimpleRecipes is only ever mixed together with SimpleFoods.
There is a way you can tell this to the compiler, however.
Technically, a self type is an assumed type for this whenever this is mentioned within the class.
Pragmatically, a self type specifies the requirements on any concrete class the trait is mixed into.
If you have a trait that is only ever used when mixed in with another trait or traits, then you can specify that those other traits should be assumed.
In the present case, it is enough to specify a self type of SimpleFoods, as shown in Listing 29.15:
Implicitly, the reference to Pear is thought of as this.Pear.
Abstract subclasses and traits do not have to follow this restriction, but since they cannot be instantiated with new, there is no risk that the this.Pear reference will fail.
One final feature of Scala modules is worth emphasizing: they can be linked together at runtime, and you can decide which modules will link to which depending on runtime computations.
For example, Listing 29.16 shows a small program that chooses a database at runtime and then prints out all the apple recipes in it:
Now, if you use the simple database, you will find a recipe for fruit salad.
If you use the student database, you will find no recipes at all using apples:
Configuring with Scala code You may wonder if you are not backsliding to the hard links problem of the original examples in this chapter, because the GotApples object shown in Listing 29.16 contains hard links to both StudentDatabase and SimpleDatabase.
The difference here is that the hard links are localized in one file that can be replaced.
Every modular application needs some way to specify the actual module implementations to use in a particular situation.
This act of “configuring” the application will by definition involve the naming of concrete module implementations.
For example, in a Spring application, you configure by naming implementations in an external XML file.
One advantage to using Scala source over XML for configuration is that the process of running your configuration file through the Scala compiler should uncover any misspellings in it prior to its actual use.
Despite using the same code, the different browser and database modules created in the previous section really are separate modules.
This means that each module has its own contents, including any nested classes.
FoodCategory in SimpleDatabase, for example, is a different class from FoodCategory in StudentDatabase!
If instead you prefer all FoodCategorys to be the same, you can accomplish this by moving the definition of FoodCategory outside of any class or trait.
The choice is yours, but as it is written, each Database gets its own, unique FoodCategory class.
The two FoodCategory classes shown in the previous example really are different, so the compiler is correct to complain.
Sometimes, though, you may encounter a case where two types are the same but the compiler can’t verify it.
You will see the compiler complaining that two types are not the same, even though you as the programmer know they perfectly well are.
In such cases you can often fix the problem using singleton types.
For example, in the GotApples program, the type checker does not know that db and browser.database are the same.
This will cause type errors if you try to pass categories between the two objects:
To avoid this error, you need to inform the type checker that they are the same object.
You can do this by changing the definition of browser.database as shown in Listing 29.17:
This definition is the same as before except that database has the funnylooking type db.type.
The “.type” on the end means that this is a singleton type.
A singleton type is extremely specific and holds only one object, in this case, whichever object is referred to by db.
Usually such types are too specific to be useful, which is why the compiler is reluctant to insert them automatically.
In this case, though, the singleton type allows the compiler to know that db and browser.database are the same object, enough information to eliminate the type error.
This chapter has shown how to use Scala’s objects as modules.
In addition to simple static modules, this approach gives you a variety of ways to create abstract, reconfigurable modules.
There are actually even more abstraction techniques than shown, because anything that works on a class, also works on a class used to implement a module.
As always, how much of this power you use should be a matter of taste.
Modules are part of programming in the large, and thus are hard to experiment with.
You need a large program before it really makes a difference.
Nonetheless, after reading this chapter you know which Scala features to think about when you want to program in a modular style.
Think about these techniques when you write your own large programs, and recognize these coding patterns when you see them in other people’s code.
It is also more tricky than it looks at first glance.
This chapter looks at object equality in detail and gives some recommendations to consider when you design your own equality tests.
As mentioned in Section 11.2, the definition of equality is different in Scala and Java.
Java has two equality comparisons: the == operator, which is the natural equality for value types and object identity for reference types, and the equals method, which is (user-defined) canonical equality for reference types.
This convention is problematic, because the more natural symbol, ==, does not always correspond to the natural notion of equality.
When programming in Java, a common pitfall for beginners is to compare objects with == when they should have been compared with equals.
For instance, comparing two strings x and y using “x == y” might well yield false in Java, even if x and y have exactly the same characters in the same order.
Scala also has an equality method signifying object identity, but it is not used much.
That kind of equality, written “x eq y”, is true if x and y reference the same object.
The == equality is reserved in Scala for the “natural” equality of each type.
For value types, == is value comparison, just like in Java.
For reference types, == is the same as equals in Scala.
You can redefine the behavior of == for new types by overriding the equals method, which is always inherited from class Any.
The inherited equals, which takes effect unless overridden, is object identity, as is the case in Java.
It is not possible to override == directly, as it is defined as a final method in class Any.
That is, Scala treats == as if it were defined as follows in class Any:
How should the equals method be defined? It turns out that writing a correct equality method is surprisingly difficult in object-oriented languages.
This is problematic, because equality is at the basis of many other things.
For one, a faulty equality method for a type C might mean that you cannot reliably put an object of type C in a collection.
Nevertheless, with commonly occurring faulty implementations of the equals method, you could still see behavior like the following:
Here are four common pitfalls2 that can cause inconsistent behavior when overriding equals:
These four pitfalls are discussed in the remainder of this section.
Consider adding an equality method to the following class of simple points:
A seemingly obvious, but wrong way would be to define it like this:
What’s wrong with this method? At first glance, it seems to work OK:
However, trouble starts once you start putting points into a collection:
What went wrong? In fact, the version of equals given previously does not override the standard method equals, because its type is different.
Here is the type of the equals method as it is defined in the root class Any:3
Because the equals method in Point takes a Point instead of an Any as an argument, it does not override equals in Any.
Now, overloading in Scala and in Java is resolved by the static type of the argument, not the run-time type.
So as long as the static type of the argument is Point, the equals method in Point is called.
However, once the static argument is of type Any, the equals method in Any is called instead.
This method has not been overridden, so it is still implemented by comparing object identity.
That’s also why the contains method in HashSet returned false.
Since that method operates on generic sets, it calls the generic equals method in Object instead of the overloaded variant in Point.
It takes a value of type Any as parameter and it yields a Boolean result.
The compiler simply makes it appear to have type Any.
It first tests whether the other object is also of type Point.
If it is, it compares the coordinates of the two points and returns the result.
A related pitfall is to define == with a wrong signature.
Normally, if you try to redefine == with the correct signature, which takes an argument of type Any, the compiler will give you an error because you try to override a final method of type Any.
However, newcomers to Scala sometimes make two errors at once: They try to override == and they give it the wrong signature.
In that case, the user-defined == method is treated as an overloaded variant of the same-named method class Any, and the program compiles.
However, the behavior of the program would be just as dubious as if you had defined equals with the wrong signature.
However, if you repeat the HashSet.contains test, you will probably still get false.
Eventually, you’ll get one which is not contained in the set.
What goes wrong here is that Point redefined equals without also redefining hashCode.
Note that the collection in the example above is a HashSet.
This means elements of the collection are put in “hash buckets” determined by their hash code.
The contains test first determines a hash bucket to look in and then compares the given elements with all elements in that bucket.
Now, the last version of class Point did redefine equals, but it did not at the same time.
So hashCode is still what it was in its version in class AnyRef: some transformation of the address of the allocated object.
Different hash codes mean with high probability different hash buckets in the set.
The contains test will look for a matching element in the bucket which corresponds to p2’s hash code.
In most cases, point p1 will be in another bucket, so it will never be found.
The problem was that the last implementation of Point violated the contract on hashCode as defined for class Any:4
If two objects are equal according to the equals method, then calling the hashCode method on each of the two objects must produce the same integer result.
In fact, it’s well known in Java that hashCode and equals should always be redefined together.
Furthermore, hashCode may only depend on fields that equals depends on.
For the Point class, the following would be a suitable definition of hashCode:
This is just one of many possible implementations of hashCode.
We’ll provide more guidance on writing hashCode later in this chapter.
Adding hashCode fixes the problems of equality when defining classes like Point.
However, there are still other trouble spots to watch out for.
The only difference is that the fields x and y are now vars instead of vals.
The equals and hashCode methods are now defined in terms of these mutable fields, so their results change when the fields change.
This can have strange effects once you put points in collections:
Now, if you change a field in point p, does the collection still contain the point? We’ll try it:
Where did p go? More strangeness results if you check whether the iterator of the set contains p:
So here’s a set that does not contain p, yet p is among the elements of the set! What happened, of course, is that after the change to the x field, the point.
That is, its original hash bucket no longer corresponded to the new value of its hash code.
In a manner of speaking, the point p “dropped out of sight” in the set coll even though it still belonged to its elements.
The lesson to be drawn from this example is that when equals and hashCode depend on mutable state, it causes problems for potential users.
If they put such objects into collections, they have to be careful never to modify the depended-on state, and this is tricky.
If you need a comparison that takes the current state of an object into account, you should usually name it something else, not equals.
Considering the last definition of Point, it would have been preferable to omit a redefinition of hashCode and to name the comparison method equalContents, or some other name different from equals.
Point would then have inherited the default implementation of equals and hashCode.
So p would have stayed locatable in coll even after the modification to its x field.
Pitfall #4: Failing to define equals as an equivalence relation.
The contract of the equals method in scala.Any specifies that equals must implement an equivalence relation on non-null objects:5
It is reflexive: for any non-null value x , the expression x.equals(x) should return true.
It is symmetric: for any non-null values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.
It is transitive: for any non-null values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.
It is consistent: for any non-null values x and y, multiple invocations of x.equals(y) should consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.
The definition of equals developed so far for class Point satisfies the contract for equals.
Say there is a subclass ColoredPoint of Point that adds a field color of type Color.
Assume Color is defined as an enumeration, as presented in Section 20.9:
ColoredPoint overrides equals to take the new color field into account:
Note that in this case, class ColoredPoint need not override hashCode.
Because the new definition of equals on ColoredPoint is stricter than the overridden definition in Point (meaning it equates fewer pairs of objects), the contract for hashCode stays valid.
If two colored points are equal, they must have the same coordinates, so their hash codes are guaranteed to be equal as well.
Taking the class ColoredPoint by itself, its definition of equals looks OK.
However, the contract for equals is broken once points and colored points are mixed.
The comparison “p equals cp” invokes p’s equals method, which is defined in class Point.
This method only takes into account the coordinates of the two points.
On the other hand, the comparison “cp equals p” invokes cp’s equals method, which is defined in class ColoredPoint.
This method returns false, because p is not a ColoredPoint.
The loss in symmetry can have unexpected consequences for collections.
So even though p and cp are equal, one contains test succeeds whereas the other one fails.
How can you change the definition of equals so that it becomes symmetric? Essentially there are two ways.
You can either make the relation more general or more strict.
Making it more general means that a pair of two objects, x and y, is taken to be equal if either comparing x with y or comparing y with x yields true.
The new definition of equals in ColoredPoint has one more case than the old one: If the other object is a Point but not a ColoredPoint, the method forwards to the equals method of Point.
Now, both “cp equals p” and “p equals cp” result in true.
Define a point and two colored points of different colors, all at the same position:
Taken individually, redp is equal to p and p is equal to bluep:
Making the equals relation more general seems to lead to a dead end.
One way to make equals stricter is to always treat objects of different classes as different.
That could be achieved by modifying the equals methods in classes Point and ColoredPoint.
In class Point, you could add an extra comparison that checks whether the run-time class of the other Point is exactly the same as this Point’s class, as follows:
You can then revert class ColoredPoint’s implementation back to the version that previously had violated the symmetry requirement:6
Here, an instance of class Point is considered to be equal to some other instance of the same class only if the objects have the same coordinates and they have the same run-time class, meaning .getClass on either object returns the same value.
The new definitions satisfy symmetry and transitivity because now every comparison between objects of different classes yields false.
So a colored point can never be equal to a point.
This convention looks reasonable, but one could argue that the new definition is too strict.
For p it is Point, whereas for pAnon it is an anonymous subclass of Point.
It does not seem reasonable to treat it as being different from p.
Is there a sane way to redefine equality on several levels of the class hierarchy while keeping its contract? In fact, there is such a way, but it requires one more method to redefine together with equals and hashCode.
The idea is that as soon as a class redefines equals (and hashCode), it should also explicitly state that objects of this class are never equal to objects of some superclass that implement a different equality.
Given the new implementation of equals in Point, this version of ColoredPoint no longer violates the symmetry requirement.
This is achieved by adding a method canEqual to every class that redefines equals.
The method should return true if the other object is an instance of the class in which canEqual is (re)defined, false otherwise.
It is called from equals to make sure that the objects are comparable both ways.
Listing 30.1 shows a new (and final) implementation of class Point along these lines:
The equals method in this version of class Point contains the additional requirement that the other object can equal this one, as determined by the canEqual method.
The implementation of canEqual in Point states that all instances of Point can be equal.
It can be shown that the new definition of Point and ColoredPoint keeps the contract of equals.
Indeed, for any point p and colored point cp, “p equals cp” will return false because “cp canEqual p” will return false.
The reverse comparison, “cp equals p”, will also return false, because p is not a ColoredPoint, so the first pattern match in the body of equals in ColoredPoint will fail.
These examples demonstrate that if a superclass equals implementation defines and calls canEqual, then programmers who implement subclasses can.
Because ColoredPoint overrides canEqual, for example, a colored point may never be equal to a plain-old point.
But because the anonymous subclass referenced from pAnon does not override canEqual, its instance can be equal to a Point instance.
One potential criticism of the canEqual approach is that it violates the Liskov Substitution Principle (LSP)
For example, the technique of implementing equals by comparing run-time classes, which led to the inability to define a subclass whose instances can equal instances of the superclass, has been described as a violation of the LSP.7 The reasoning is that the LSP states you should be able to use (substitute) a subclass instance where a superclass instance is required.
In the previous example, however, “coll contains cp” returned false even though cp’s x and y values matched those of the point in the collection.
Thus it may seem like a violation of the LSP, because you can’t use a ColoredPoint here where a Point is expected.
We believe this is the wrong interpretation, though, because the LSP doesn’t require that a subclass behaves identically to its superclass, just that it behaves in a way that fulfills the contract of its superclass.
The problem with writing an equals method that compares run-time classes is not that it violates the LSP, but that it doesn’t give you a way to create a subclass whose instances can equal superclass instances.
For example, had we used the run-time class technique in the previous example, “coll contains pAnon” would have returned false, and that’s not what we wanted.
Thus, in the previous example we were able to pass two different Point subclass instances to the collection’s contains method, and we got back two different answers, both correct.
The equals methods in the previous examples all started with a pattern match that tested whether the type of the operand conformed to the type of the class containing the equals method.
When classes are parameterized, this scheme needs to be adapted a little bit.
The class hierarchy shown in Listing 30.3 defines an abstract class Tree for a binary tree, with two alternative implementations: an EmptyTree object and a Branch class representing non-empty trees.
A non-empty tree is made up of some element elem and a left and right child tree.
The type of its element is given by a type parameter T.
We’ll now add equals and hashCode methods to these classes.
For class Tree itself there’s nothing to do, because we assume that these methods are implemented separately for each implementation of the abstract class.
For object EmptyTree, there’s still nothing to do because the default implementations of equals and hashCode that EmptyTree inherits from AnyRef work just fine.
After all, an EmptyTree is only equal to itself, so equality should be reference equality, which is what’s inherited from AnyRef.
But adding equals and hashCode to Branch requires some work.
A Branch value should only be equal to other Branch values, and only if the two values have equal elem, left and right fields.
Compiling this example, however, gives an indication that “unchecked” warnings occurred.
Compiling again with the -unchecked option reveals the following problem:
As the warning says, there is a pattern match against a Branch[T] type, yet the system can only check that the other reference is (some kind of) Branch; it cannot check that the element type of the tree is T.
You encountered in Chapter 19 the reason for this: element types of parameterized types are eliminated by the compiler’s erasure phase; they are not available to be inspected at run-time.
So what can you do? Fortunately, it turns out that you need not necessarily check that two Branches have the same element types when comparing them.
It’s quite possible that two Branches with different element types are equal, as long as their fields are the same.
A simple example of this would be the Branch that consists of a single Nil element and two empty subtrees.
It’s plausible to consider any two such Branches to be equal, no matter what static types they have:
The positive result of the comparison above was obtained with the implementation of equals on Branch shown previously.
This demonstrates that the element type of the Branch was not checked—if it had been checked, the result would have been false.
Note that one can disagree which of the two possible outcomes of the comparison would be more natural.
In the end, this depends on the mental model of how classes are represented.
In an alternative model where a type parameter forms part of an object’s value, it’s equally natural to consider them different.
There’s only a tiny change needed to formulate an equals method that does not produce an unchecked warning: instead of an element type T, use a lower case letter, such as t:
Recall from Section 15.2 that a type parameter in a pattern starting with a lower-case letter represents an unknown type.
The type parameter t represents the unknown element type of the Branch.
It can also be replaced by an underscore, as in the following case, which is equivalent to the previous one:
The only thing that remains is to define for class Branch the other two methods, hashCode and canEqual, which go with equals.
As shown previously, the principle is to take hashCode values of all fields, and to combine them using additions and multiplications by some prime number.
The implementation of the canEqual method used a typed pattern match.
It would also be possible to formulate it with isInstanceOf:
After all, Branch[_] is technically a type parameter of a method, not a type pattern, so how is it possible to leave some parts of it undefined? The answer to that question is found in the next chapter: Branch[_] is a shorthand for a so-called existential type, which is roughly speaking a type with some unknown parts in it.
So even though technically the underscore stands for two different things in a pattern match and in a type parameter of a method call, in essence the meaning is the same: it lets you label something that is unknown.
The final version of Branch is shown in Listing 30.4
In this section, we’ll provide step-by-step recipes for creating equals and hashCode methods that should suffice for most situations.
As an illustration, we’ll use the methods of class Rational, shown in Listing 30.5
If you’re going to override equals in a non-final class, you should create a canEqual method.
The only exception to this requirement is for final classes that redefine the equals method inherited from AnyRef.
For them the subclass anomalies described in Section 30.2 cannot arise; consequently they need not define canEqual.
The type of the object passed to canEqual should be Any:
The canEqual method should yield true if the argument object is an instance of the current class (i.e., the class in which canEqual is defined), false otherwise:
In the equals method, make sure you declare the type of the object passed as an Any:
Write the body of the equals method as a single match expression.
The selector of the match should be the object passed to equals:
The first case should declare a typed pattern for the type of the class on which you’re defining the equals method:
In the body of this case, write an expression that logical-ands together the individual expressions that must be true for the objects to be equal.
If the equals method you are overriding is not that of AnyRef, you will most likely want to include an invocation of the superclass’s equals method:
If you are defining equals for a class that first introduced canEqual, you should invoke canEqual on the argument to the equality method, passing this as the argument:
Overriding redefinitions of equals should also include the canEqual invocation, unless they contain a call to super.equals.
In the latter case, the canEqual test will already be done by the superclass call.
Lastly, for each field relevant to equality, verify that the field in this object is equal to the corresponding field in the passed object:
For the second case, use a wildcard pattern that yields false:
If you adhere to the preceding recipe, equality is guaranteed to be an equivalence relation, as is required by the equals contract.
For hashCode, you can usually achieve satisfactory results if you use the following recipe, which is similar to a recipe recommended for Java classes in Effective Java.8 Include in the calculation each field in your object that is used to determine equality in the equals method (the “relevant” fields)
For each relevant field, no matter its type, you can calculate a hash code by invoking hashCode on it.
To calculate a hash code for the entire object, add.
For example, to implement the hash code for an object that has five relevant fields named a, b, c, d, and e, you would write:
If you wish, you can leave off the hashCode invocation on fields of type Int, Short, Byte, and Char.
The hash code for an Int is the value of the Int, as are the hash codes of Shorts, Bytes, and Chars when automatically widened to Int.
Given numer or denom are Ints, therefore, we implemented Rational’s hashCode method like this:
One thing to keep in mind as you write hashCode methods using this approach is that your hash code will only be as good as the hash codes you build it out of, namely the hash codes you obtain by calling hashCode on the relevant fields of your object.
Sometimes you may need to do something extra besides just calling hashCode on the field to get a useful hash code for that field.
For example, if one of your fields is a collection, you probably want a hash code for that field that is based on all the elements contained in the collection.
If the field is a List, Set, Map, or tuple, you can simply call hashCode on the field, because equals and hashCode are overridden in those classes to take into account the contained elements.
However the same is not true for Arrays, which do not take elements into account when calculating a hash code.
Lastly, if you find that a particular hash code calculation is harming the performance of your program, you can consider caching the hash code.
If the object is immutable, you can calculate the hash code when the object is created and store it in a field.
You can do this by simply overriding hashCode with a val instead of a def, like this:
This approach trades off memory for computation time, because each instance of the immutable class will have one more field to hold the cached hash code value.
In retrospect, defining a correct implementation of equals has been surprisingly subtle.
You must be careful about the type signature; you must override hashCode; you should avoid dependencies on mutable state; and you should implement and use a canEqual method if your class is non-final.
Given how difficult it is to implement a correct equality method, you might prefer to define your classes of comparable objects as case classes.
That way, the Scala compiler will add equals and hashCode methods with the right properties automatically.
Scala code is often used in tandem with large Java programs and frameworks.
Since Scala is highly compatible with Java, most of the time you can combine the languages without worrying very much.
For example, standard frameworks such as Swing, Servlets, and JUnit are known to work just fine with Scala.
Nonetheless, from time to time you will run into some issue with combining Java and Scala.
This chapter describes two aspects of combining Java and Scala.
First, it discusses how Scala is translated to Java, which is especially important if you call Scala code from Java.
Second, it discusses the use of Java annotations in Scala, an important feature if you want to use Scala with an existing Java framework.
Most of the time you can think of Scala at the source code level.
However, you will have a richer understanding of how the system works if you know something about its translation.
Further, if you call Scala code from Java, you will need to know what Scala code looks like from a Java point of view.
Scala is implemented as a translation to standard Java bytecodes.
As much as possible, Scala features map directly onto the equivalent Java features.
Scala classes, methods, strings, exceptions, for example, are all compiled to the same in Java bytecode as their Java counterparts.
To make this happen required an occasional hard choice in the design of Scala.
For example, it might have been nice to resolve overloaded methods at run time, using run-time types, rather than at compile time.
Such a design would break with Java’s, however, making it much trickier to mesh Java and Scala.
In this case, Scala stays with Java’s overloading resolution, and thus Scala methods and method calls can map directly to Java methods and method calls.
Similarly, while both Scala and Java have generic types, the details of the two systems clash.
For language features like these, Scala code cannot be mapped directly to a Java construct, so it must be encoded using some combination of the structures Java does have.
For these features that are mapped indirectly, the encoding is not fixed.
There is an ongoing effort to make the translations as simple as possible, so by the time you read this, some details may be different than at the time of writing.
You can find out what translation your current Scala compiler uses by examining the “.class” files with tools like javap.
A value type like Int can be translated in two different ways to Java.
Whenever possible, the compiler translates a Scala Int to a Java int to get better performance.
Sometimes this is not possible, though, because the compiler is not sure whether it is translating an Int or some other data type.
For example, a particular List[Any] might hold only Ints, but the compiler has no way to be sure.
In cases like this, where the compiler is unsure whether an object is a value type or not, the compiler uses objects and relies on wrapper classes.
Java has no exact equivalent to a singleton object, but it does have static methods.
The Scala translation of singleton objects uses a combination of.
The implementation of value types was discussed in detail in Section 11.2
For every Scala singleton object, the compiler will create a Java class for the object with a dollar sign added to the end.
For a singleton object named App, the compiler produces a Java class named App$
This class has all the methods and fields of the Scala singleton object.
The Java class also has a single static field named MODULE$ to hold the one instance of the class that is created at run time.
As a full example, suppose you compile the following singleton object:
Scala will generate a Java App$ class with the following fields and methods:
An important special case is if you have a “standalone” singleton object, one which does not come with a class of the same name.
For example, you might have a singleton object named App, and not have any class named App.
In that case, the compiler will create a Java class named App that has a static forwarder method for each method of the Scala singleton object:
To contrast, if you did have a class named App, Scala would create a corresponding Java App class to hold the members of the App class you defined.
In that case it would not add any forwarding methods for the same-named singleton object, and Java code would have to access the singleton via the MODULE$ field.
Compiling any trait creates a Java interface of the same name.
This interface is usable as a Java type, and it lets you call methods on Scala objects through variables of that type.
If you make a Scala trait that includes only abstract methods, then that trait will be translated directly to a Java interface, with no other code to worry about.
Essentially this means that you can write a Java interface in Scala syntax if you like.
Several annotations cause the compiler to emit extra information when targeting the Java platform.
When the compiler sees such an annotation, it first processes it according to the general Scala rules, and then it does something extra for Java.
Deprecation For any method or class marked @deprecated, the compiler will add Java’s own deprecation annotation to the emitted code.
Because of this, Java compilers can issue deprecation warnings when Java code accesses deprecated Scala methods.
Volatile fields Likewise, any field marked @volatile in Scala is given the Java volatile modifier in the emitted code.
Thus, volatile fields in Scala behave exactly according to Java’s semantics, and accesses to volatile fields.
Serialization Scala’s three standard serialization annotations are all translated to Java equivalents.
A @serializable class has Java’s Serializable interface added to it.
Any variable marked @transient is given the Java transient modifier.
That is, Scala has no equivalent to Java’s throws declarations on methods.
All Scala methods are translated to Java methods that declare no thrown exceptions.2
The reason this feature is omitted from Scala is that the Java experience with it has not been purely positive.
Because annotating methods with throws clauses is a heavy burden, too many developers write code that swallows and drops exceptions, just to get the code to compile without adding all those throws clauses.
They may intend to improve the exception handling later, but experience shows that all too often time-pressed programmers will never come back and add proper exception handling.
The twisted result is that this well-intentioned feature often ends up making code less reliable.
A large amount of production Java code swallows and hides runtime exceptions, and the reason it does so is to satisfy the compiler.
Sometimes when interfacing to Java, however, you may need to write Scala code that has Java-friendly annotations describing which exceptions your methods may throw.
Thus, if you wish to write an RMI remote interface as a Scala trait with abstract methods, you would need to list RemoteException in the throws clauses for those methods.
To accomplish this, all you have to do is mark your methods with @throws annotations.
For example, the Scala class shown in Listing 31.1 has a method marked as throwing IOException.
The reason it all works is that the Java bytecode verifier does not check the declarations, anyway! The Java compiler checks, but not the verifier.
Note that the read method indicates with a Java throws clause that it may throw an IOException.
Existing annotations from Java frameworks can be used directly in Scala code.
Any Java framework will see the annotations you write just as if you were writing in Java.
JUnit is a framework for writing automated tests and for running those tests.
The latest version, JUnit 4, uses annotations to indicate which parts of your code are tests.
The idea is that you write a lot of tests for your code, and then you run those tests whenever you change the source code.
That way, if your changes add a new bug, one of the tests will fail and you will find out immediately.
You simply write a method in a top-level class that exercises your code, and you use an annotation to mark the method as a test.
This test adds multiple items to a set and makes sure that each is added only once.
The assertEquals method, which comes as part of the JUnit API, checks that its two arguments are equal.
In this case, the test verifies that repeatedly adding the same numbers does not increase the size of a set.
The test can be run using any JUnit test runner.
Here it is being run with the command-line test runner:
To make an annotation that is visible to Java reflection, you must use Java notation and compile it with javac.
For this use case, writing the annotation in Scala does not seem helpful, so the standard compiler does not support it.
The reasoning is that the Scala support would inevitably fall short of the.
After compiling the above with javac, you can use the annotation as follows:
To see when these annotations are present, you can use the Java reflection APIs.
Here, the reflective methods getClass and getMethods are used to inspect all the fields of the input object’s class.
Java 1.5, many reflection objects have a getAnnotation method for searching for annotations of a specific type.
In this case, the code looks for an annotation of our new Ignore type.
Since this is a Java API, success is indicated by whether the result is null or is an actual annotation object.
As an aside, notice that the methods are in class Tests$ instead of class Tests when viewed with Java reflection.
As described at the beginning of the chapter, the implementation of a Scala singleton object is placed in a Java class with a dollar sign added to the end of its name.
In this case, the implementation of Tests is in the Java class Tests$
Be aware that when you use Java annotations you have to work within their limitations.
For example, you can only use constants, not expressions, in the arguments to annotations.
This is necessary so that Scala code can access any legal Java class.
For some cases, though, the Scala types you have seen so far are not enough.
Existential types are a fully supported part of the language, but in practice they are mainly used when accessing Java types from Scala.
This section gives a brief overview of how existential types work, but mostly this is only.
The general form of an existential type is as follows:
The type part is an arbitrary Scala type, and the declarations part is a list of abstract vals and types.
The interpretation is that the declared variables and types exist but are unknown, just like abstract members of a class.
The type is then allowed to refer to the declared variables and types even though it is unknown what they refer to.
This is an Iterator of T’s for some type T.
The type T is unknown, and could be anything, but it is known to be fixed for this particular Iterator.
This is an Iterator of T, for some type T that is a subtype of Component.
In this case T is still unknown, but now it is sure to be a subtype of Component.
You can also insert upper and lower bounds when using this placeholder syntax.
Simply add them to the underscore instead of in the forSome clause.
How do you actually use them? Well, in simple cases, you use an existential type just as if the forSome were not there.
Scala will check that the program is sound even though the types and values in the forSome clause are unknown.
If you access this in Scala code you will see that it has an existential type:
If you want to find out how many elements are in this collection, you can simply ignore the existential part and call the size method as normal:
In more complicated cases, existential types can be more awkward, because there is no way to name the existential type.
For example, suppose you wanted to create a mutable Scala set and initialize it with the elements of contents:
There is no way to name the type of elements in the Java collection, so you cannot write down a satisfactory type for set.
To work around this kind of problem, here are two tricks you should consider:
When passing an existential type into a method, move type parameters from the forSome clause to type parameters of the method.
Inside the body of the method, you can use the type parameters to refer to the types that were in the forSome clause.
Instead of returning an existential type from a method, return an object that has abstract members for each of the types in the forSome clause.
Using these two tricks together, the previous code can be written as follows:
You can see why Scala code normally does not use existential types.
To do anything sophisticated with them, you tend to convert them to use abstract members.
So you may as well use abstract members to begin with.
For compatibility’s sake, Scala provides access to Java’s concurrency primitives.
The wait, notify, and notifyAll methods can be called in Scala, and they have the same meaning as in Java.
Scala doesn’t technically have a synchronized keyword, but it includes a predefined synchronized method that can be called as follows:
Usually when you compile Scala code that depends on Java code, you first build the Java code to class files.
You then build the Scala code, putting the Java code’s class files on the classpath.
This approach doesn’t work, however, if the Java code has references back into the Scala code.
In such a case, no matter which order you compile the code, one side or the other will have unsatisfied external references.
All it takes is a mostly Java project where you replace one Java file with a Scala file.
To support such builds, Scala allows compiling against Java source code as well as Java class files.
All you have to is put the Java source files on the command line as if they were Scala files.
The Scala compiler won’t compile those Java files, but it will scan them to see what they contain.
To use this facility, you first compile the Scala code using Java source files, and then compile the Java code using Scala class files.
Most of the time, you can ignore how Scala is implemented and simply write and run your code.
Sometimes it is nice to “look under the hood,” however, so this chapter has gone into three aspects of Scala’s implementation on the Java platform: what the translation looks like, how Scala and Java annotations work together, and how Scala’s existential types let you access Java wildcard types.
It also covered using Java’s concurrency primitives from Scala and compiling combined Scala and Java projects.
These topics are important whenever you use Scala and Java together.
Sometimes it helps in designing a program to specify that things happen independently, in parallel, concurrently.
Java includes support for concurrency, and although this support is sufficient, it turns out to be quite difficult to get right in practice as programs get larger and more complex.
Actors provide a concurrency model that is easier to work with and can, therefore, help you avoid many of the difficulties of using Java’s native concurrency model.
This chapter will show you the basics of how to use Scala’s actors library and provide an extended example that transforms the single-threaded circuit simulation code of Chapter 18 into a multi-threaded version.
The Java platform comes with a built-in threading model based on shared data and locks.
Each object is associated with a logical monitor, which can be used to control multi-threaded access to data.
To use this model, you decide what data will be shared by multiple threads and mark as “synchronized” sections of the code that access, or control access to, the shared data.
The Java runtime employs a locking mechanism to ensure that only one thread at a time enters synchronized sections guarded by the same lock, thereby enabling you to orchestrate multi-threaded access to the shared data.
At each method call, you must reason about what locks it will try to hold, and convince yourself that it will not deadlock while trying to obtain them.
Compounding the problem, the locks you reason about are not fixed at compile time, because the program is free to create new locks at run time as it progresses.
Making things worse, testing is not reliable with multi-threaded code.
Since threads are non-deterministic, you might successfully test a program one thousand times, yet still the program could go wrong the first time it runs on a customer’s machine.
With shared data and locks, you must get the program correct through reason alone.
It can be just as problematic to synchronize everything as it is to synchronize nothing.
The problem is that new lock operations remove possibilities for race conditions, but simultaneously add possibilities for deadlocks.
A correct lock-using program must have neither race conditions nor deadlocks, so you cannot play it safe by overdoing it in either direction.
Using the concurrency utilities makes multi-threaded programming far less error prone than rolling your own abstractions with Java’s low-level synchronization primitives.
Nevertheless, the concurrent utilities are also based on the shared data and locks model, and as a result do not solve the fundamental difficulties of using that model.
Scala’s actors library does address the fundamental problem by providing an alternative, share-nothing, message-passing model that programmers tend to find much easier to reason about.
Actors are a good first tool of choice when designing concurrent software, because they can help you avoid the deadlocks and race conditions that are easy to fall into when using the shared data and locks model.
An actor is a thread-like entity that has a mailbox for receiving messages.
You start an actor by invoking its start method, similar to the way you start a Java thread:
Notice that the “I’m acting!” output is interleaved with the Scala shell’s output.
This interleaving is due to the SillyActor actor running independently from the thread running the shell.
You could run two actors at the same time, like this:
The val definition above creates an actor that executes the actions defined in the block following the actor method.
There is no need to call a separate start method.
How do they work together, though? How do they communicate without using shared memory and locks? Actors communicate by sending each other messages.
You send a message by using the ! method, like this:
Nothing happens in this case, because SillyActor is too busy acting to process its messages, and so the "hi there" message sits in its mailbox unread.
Listing 32.2 shows a new, more sociable, actor that waits for a message in its mailbox and prints out whatever it receives.
It receives a message by calling receive, passing in a partial function.1
When an actor sends a message, it does not block, and when an actor receives a message, it is not interrupted.
The sent message waits in the receiving actor’s mailbox until the actor calls receive.
As discussed in Section 15.7, a partial function (an instance of trait PartialFunction) is not a full function—i.e., it might not be defined over all input values.
In addition to an apply method that takes one argument, a partial function offers an isDefinedAt method, which also takes one argument.
The isDefinedAt method will return true if the partial function can “handle” the passed value.
If you pass a value to apply for which isDefinedAt would return false, however, apply will throw an exception.
As described in Section 15.7, a partial function literal is expressed as a series of match alternatives or “cases.” It looks like a match expression without the match keyword.
An actor will only process messages matching one of the cases in the partial function passed to receive.
For each message in the mailbox, receive will first invoke isDefinedAt on the passed partial function to determine whether it has a case that will match and handle the message.
The receive method will choose the first message in the mailbox for which isDefinedAt returns true, and pass that message to the partial function’s apply method.
For example, echoActor’s apply method will print "received message: " followed by the message object’s toString result.
If the mailbox contains no message for which isDefinedAt returns true, the actor on which receive was invoked will block until a matching message arrives.
For example, here is an actor that handles only messages of type Int:
If you send a String or Double, for example, the intActor will silently ignore the message:
But if you pass an Int, you’ll get a response printed out:
The actor subsystem manages one or more native threads for its own use.
So long as you work with an explicit actor that you define, you do not need to think much about how they map to threads.
The other direction is also supported: every native thread is also usable as an actor.
Instead, you should use Actor.self if you want to view the current thread as an actor.
This facility is especially useful for debugging actors from the interactive shell.
The receive method returns the value computed by the partial function passed to it.
In this case, the partial function returns the message itself, and so the received message ends up being printed out by the interpreter shell.
If you use this technique, it is better to use a variant of receive called receiveWithin.
If you use receive in the interpreter shell, then the receive will block the shell until a message arrives.
In the case of self.receive, this could mean waiting forever! Instead, use receiveWithin with some timeout value:
As described so far, in fact, every actor must be given its own thread, so that all the act methods get their turn.
Unfortunately, despite their light-sounding name, threads are not all that cheap in Java.
Threads consume enough memory that typical Java virtual machines, which can host millions of objects, can have only thousands of threads.
Worse, switching threads often takes hundreds if not thousands of processor cycles.
If you want your program be as efficient as possible, then it is important to be sparing with thread creation and switching.
To help you conserve threads, Scala provides an alternative to the usual receive method called react.
Unlike receive, however, react does not return after it finds and processes a message.
Because the react method does not need to return, the implementation does not need to preserve the call stack of the current thread.
Instead, the library can reuse the current thread for the next actor that wakes up.
This approach is so effective that if every actor in a program uses react instead of receive, only a single thread is necessary in principle to host all of the program’s actors (to be sure, if your computer has several processor cores, the actors subsystem will use enough threads to utilize all cores when it can)
In practice, programs will need at least a few receive’s, but you should try to use react whenever possible so as to conserve threads.
Because react does not return, the message handler you pass it must now both process that message and arrange to do all of the actor’s remaining work.
A common way to do this is to have a top-level work method—such as act itself—that the message handler calls when it finishes.
The actor shown in Listing 32.3 waits for strings that are host names, and if there is one, returns an IP address for that host name.
Behind the scenes, react will throw an exception after its done.
Writing an actor to use react instead of receive is challenging, but pays off in performance.
Because react does not return, the calling actor’s call stack can be discarded, freeing up the thread’s resources for a different actor.
At the extreme, if all of the actors of a program use react, then they can be implemented on a single thread.
This coding pattern is so common with event-based actors, there is special support in the library for it.
The Actor.loop function executes a block of code repeatedly, even if the code calls react.
NameResolver’s act method can be rewritten to use loop as shown in Listing 32.4
The one difference in behavior between this act method and that of Listing 32.3 is.
Instead, this actor will loop and react to messages forever.
At this point you have seen everything you need to write your own actors.
Simply using these methods takes you only so far, however.
The point of them is that they support an actors style of concurrent programming.
To the extent you can write in this style, your code will be easier to debug and will have fewer deadlocks and race conditions.
This section provides some guidelines for programming in an actors style.
A well written actor does not block while processing a message.
The problem is that while the actor blocks, some other actor might make a request on it that it could handle.
If the actor is blocked on the first request, it will not even notice the second request.
In the worst case, a deadlock can even result, with multiple actors blocked as they each wait for some other blocked actor to respond.
Instead of blocking, the actor should arrange for some message to arrive designating that action is ready to be taken.
Often this rearrangement will require the help of other actors.
How react works A return type of Nothing indicates a function will never return normally, but instead will always complete abruptly with an exception.
The actual implementation of react is not as simple as the following description, and subject to change, but conceptually you can think of react as working like this:
When you call start on an actor, the start method will in some way arrange things such that some thread will eventually call act on that actor.
If that act method invokes react, the react method will look in the actor’s mailbox for a message the passed partial function can handle.
It does this the same way as receive, by passing candidate messages to the partial function’s isDefinedAt method.
If it finds a message that can be handled, react will schedule the handling of that message for later execution and throw an exception.
If it doesn’t find one, it will place the actor in “cold storage,” to be resurrected if and when it gets more messages in its mailbox, and throw an exception.
In either case, react will complete abruptly with this exception, and so will act.
The thread that invoked act will catch the exception, forget about the actor, and move on to other duties.
This is why if you want react to handle more than the first message, you’ll need to call act again from inside your partial function, or use some other means to get react invoked again.
This helper actor does indeed block, but since it will never receive a message, it is OK in this case.
The emoteLater method, shown in Listing 32.5, demonstrates the use of this idiom.
It creates a new actor that will do the sleep so that the main actor does not block.
Because this actor does not block in sleep—its helper actor does—it can continue to do other work while waiting for its next time to emote.
Unlike the earlier silly actor, this one will continue to print out messages while it waits for its next input:
The key way the actors model addresses the difficulties of the shared data and locks model is by providing a safe space—the actor’s act method—where you can think sequentially.
Put another way, actors allow you to write a multi-threaded program as a bunch of independent single-threaded programs that communicate with each other via asynchronous messaging.
This simplification works, however, only so long as messages are the only way you let your actors communicate.3
For example, a GoodActor could include a reference to itself in a message to a BadActor, to identify itself as the source of that message.
If BadActor invokes some arbitrary method on GoodActor instead of sending it a message with ‘!’, however, problems may ensue.
The invoked method might read private instance data in GoodActor, which may have been written by a different thread.
As a result, you would need to ensure that both the BadActor thread’s reading of the instance data and the GoodActor thread’s writing of it are synchronized on the same lock.
The GoodActor’s private instance data has become shared data that must be guarded by a lock.
As soon as you go around the message passing scheme between actors, therefore, you drop back down into the shared data and locks model, with all the difficulties you were trying to avoid in the first place by using the actors model.
On the other hand, this does not mean that you should never go around message passing.
Although shared data and locks is very difficult to get right, it is not impossible.
One difference between Scala’s approach to actors and that of Erlang, in fact, is that Scala gives you the option to combine the actors and shared data and locks models in the same program.
As an example, imagine you wanted multiple actors to share a common mutable map.
Since the map is mutable, the pure actors approach would be to create an actor that “owns” the mutable map and define a set of messages that allows other actors to access it.
You could define a message for putting a key-value pair into the shared map, getting a value given a key, and so on, for all the operations you need to do on the map.
In addition, you’d need to define messages for sending asynchronous responses to actors that made queries of the map.
Another option, however, is to pass a thread-safe map, such as ConcurrentHashMap from the Java Concurrency Utilities, in a message to multiple actors, and let those actors use that map directly.
Another benefit is that a message send ensures the message object is safely published to other threads, as described in Goetz, et.
Although it would be far easier and safer to implement a shared map via actors than to implement something like ConcurrentHashMap yourself, since ConcurrentHashMap already exists, you may judge it easier and as low risk to use that than to implement your own shared map with an actor.
This would also mean that your responses from the shared map could be synchronous, whereas with actors they would need to be asynchronous.
If you’re considering shared data and locks When considering whether to combine the actors model with the shared data and locks model, it is helpful to recall the words of Harry Callahan, played by Clint Eastwood in the 1971 movie Dirty Harry:
But being as this is a .44 Magnum, the most powerful handgun in the world, and would blow your head clean off, you’ve got to ask yourself one question: Do I feel lucky? Well, do ya, punk?
Because Scala’s actors model provides what amounts to a single-threaded environment inside each actor’s act method, you need not worry about whether the objects you use in the implementation of this method are thread-safe.
You can use unsynchronized, mutable objects to your hearts content in an act method, for example, because each act method is effectively confined to one thread.4 This is why the actors model is called a share-nothing modelthe data is confined to one thread rather than being shared by many.
There is one exception to the share-nothing rule, however: the data inside objects used to send messages between actors is “shared” by multiple actors.
As a result, you do have to worry about whether message objects are threadsafe.
When using react, different messages could potentially be handled by different threads, but if so they will be handled sequentially and with sufficient synchronization to allow you to program under the simplifying assumption that each act method is confined to a single thread.
The best way to ensure that message objects are thread-safe is to only use immutable objects for messages.
Instances of any class that has only val fields, which themselves refer only to immutable objects, are immutable.
An easy way to define such message classes, of course, is as case classes.
So long as you don’t explicitly add var fields to a case class and ensure the val fields are all immutable types, your case class will by definition be immutable.
It will also be convenient for pattern matching in the partial functions passed to react or receive.
You can also use as messages instances of regular (non-case) immutable classes that you define.
Or you can use instances of the many immutable classes provided in the Scala API, such as tuples, strings, lists, immutable sets and maps, and so on.
Now, if an actor sends a mutable, unsynchronized object as a message, and never reads or writes that object thereafter, it would work, but it’s just asking for trouble.
A future maintainer may not realize the object is shared and write to it, thereby creating a hard to find concurrency bug.
In general, it is best to arrange your data such that every unsynchronized, mutable object is “owned,” and therefore accessed by, only one actor.
You can arrange for objects to be transferred from one actor to another if you like, but you need to make sure that at any given time, it is clear which actor owns the object and is allowed to access it.
In other words, when you design an actors-based system, you need to decide which parts of mutable memory are assigned to which actor.
All other actors that access a mutable data structure must send messages to the data structure’s owner and wait for a message to come back with a reply.
If you do find you have a mutable object you want to continue using as well as send in a message to another actor, you should make and send a copy of it instead.
While you’re at it, you may want to make it immutable.
For example, because arrays are mutable and unsynchronized, any array you use should be accessed by one actor at a time.
If you want to continue using an array as well as send it to another actor, you should send a copy.
For example, if the array itself holds only immutable objects, you can make a copy with arr.clone.
But you should also consider using arr.toList, and send the resulting immutable list instead.
Immutable objects are convenient in many cases, but they really shine for parallel systems, because they are the easiest, lowest risk way to design thread-safe objects.
When you design a program that might involve parallelism in the future, whether using actors or not, you should try especially hard to make data structures immutable.
When you return a value from a method, the caller is in a good position to remember what it was doing before it called the method.
It can take the response value and then continue whatever it was doing.
When one actor makes a request of another, the response might not come for a long time.
The calling actor should not block, but should continue to do any other work it can while it waits for the response.
A difficulty, then, is interpreting the response when it finally does come back.
Can the actor remember what it was doing when it made the request?
One way to simplify the logic of an actors program is to include redundant information in the messages.
If the request is an immutable object, you can even cheaply include a reference to the request in the return value! For example, the IP-lookup actor would be better if it returned the host name in addition to the IP address found for it.
It would make this actor slightly longer, but it should simplify the logic of any actor making requests on it:
Another way to increase redundancy in the messages is to make a case class for each kind of message.
While such a wrapper is not strictly necessary in many cases, it makes an actors program much easier to understand.
Imagine a programmer looking at a send of a string, for example:
It can be difficult to figure out which actors in the code might respond.
It is much easier if the code looks like this:
Now, the programmer can search for LookupIP in the source code, probably finding very few possible responders.
Listing 32.6 shows an updated nameresolving actor that uses case classes instead of tuples for its messages.
Each participant in the simulation could run as its own actor, thus allowing you to speed up a simulation by using more processors.
This section will walk you through the process, using code based on a parallel circuit simulator developed by Philipp Haller.
Most of the design from Chapter 18 works fine for both sequential and parallel discrete event simulation.
There are events, and they happen at designated times, processing an event can cause new events to be scheduled, and so forth.
Likewise, a circuit simulation can be implemented as a discrete event simulation by making gates and wires participants in the simulation, and changes in the wires the events of the simulation.
The one thing that would be nice to change would be to run the events in parallel.
How can the design be rearranged to make this happen?
The key idea is to make each simulated object an actor.
Each event can then be processed by the actor where most of that event’s state lies.
For circuit simulation, the update of a gate’s output can be processed by the actor corresponding to that gate.
With this arrangement, events will naturally be handled in parallel.
In code, it is likely that there will be some common behavior between different simulated objects.
It makes sense, then, to define a trait Simulant that can be mixed into any class to make it a simulated object.
Wires, gates, and other simulated objects can mix in this trait.
So far so good, but there are a few design issues to work out, several of which do not have a single, obviously best answer.
For this chapter, we present a reasonable choice for each design issue that keeps the code concise.
There are other solutions possible, though, and trying them out would make for good practice for anyone wanting experience programming with actors.
That decision raises a new question, though: how do simulants know when it’s safe to move forward? A straightforward approach is to have a “clock” actor that keeps track of the current time and tells the simulation participants when it is time to move forward.
To keep the clock from moving forward before all simulants are ready, the clock can ping actors at carefully chosen times to make sure they have received and processed all messages for the current time tick.
There will be Ping messages that the clock sends the simulants, and Pong messages that the simulants send back when they are ready for the clock to move forward.
Note that these messages could be defined as having no fields.
However, the time and from fields add a little bit of redundancy to the system.
The time field holds the time of a ping, and it can be used to connect a Pong with its associated Ping.
The sender of a Ping is always the clock, so it does not have a from field.
All of this information is unnecessary if the program is behaving perfectly, but it can simplify the logic in some places, and it can greatly help in debugging if the program has any errors.
One question that arises is how a simulant knows it has finished with the current time tick.
Simulants should not respond to a Ping until they have finished all the work for that tick, but how do they know? Maybe another actor has made a request to it that has not yet arrived.
Maybe a message one actor has sent another has not been processed yet.
It simplifies the answer to this question to add two constraints.
First, assume that simulants never send each other messages directly, but instead only schedule events on each other.
Second, they never post events for the current time tick, but only for times at least one tick into the future.
These two constraints are significant, but they appear tolerable for a typical simulation.
After all, there is normally some non-zero propagation delay whenever two components of a system interact with each other.
Further, at worst, time ticks can be made to correspond to shorter time intervals, and information that will be needed in the future can be sent ahead of time.
Simulants could be allowed to send messages directly to each other.
However, if they do so, then there would need to be a more sophisticated mechanism for deciding when it is safe for an actor to send back a Pong.
Ping until any other simulants it has made requests to are finished processing those requests.
To ensure this property, you would need the simulants to pass each other some extra information.
For now, assume that simulants don’t communicate with each other except via the simulation’s agenda.
Given that decision, there may as well be a single agenda of work items, and that agenda may as well be held by the clock actor.
That way, the clock can wait to send out pings until it has sent out requests for all work items at the current time.
Actors then know that whenever they receive a Ping, they have already received from the clock all work items that need to happen at the current time tick.
It is thus safe when an actor receives a Ping to immediately send back a Pong, because no more work will be arriving during the current time tick.
The final design issue to work out is how a simulation is set up to begin with.
A natural approach is to create the simulation with the clock stopped, add all the simulants, connect them all together, and then start the clock.
The subtlety is that you need to be absolutely sure that everything is connected before you start the clock running! Otherwise, some parts of the simulation will start running before they are fully formed.
How do you know when the simulation is fully assembled and ready to start? There are again multiple ways to approach this problem.
The simple way adopted in this chapter is to avoid sending messages to actors while setting the simulation up.
That way, once the last method call returns, you know that the simulation is entirely constructed.
The resulting coding pattern is that you use regular method calls to set the simulation up, and you use actor message sends while the simulation is running.
Given the preceding decisions, the rest of the design is straightforward.
A WorkItem can be defined much like in Chapter 18, in that it holds a time and an action.
For the parallel simulation, however, the action itself has a different encoding.
For parallel simulation, it is more natural to use a target actor and a message to be sent to that actor:
Likewise, the afterDelay method for scheduling a new work item becomes an AfterDelay message that can be sent to the clock.
Just as with the WorkItem class, the zero-argument action function is replaced by a message and a target actor:
Finally, it will prove useful to have messages requesting the simulation to start and stop:
There is a Clock class holding a current time and an agenda, and a clock only advances the clock after it has pinged all of its simulants to be sure they are ready.
There is a Simulant trait for simulation participants, and these communicate with their fellow simulants by sending work items to the clock to add to its agenda.
The next section will take a look now at how to implement these core classes.
There are two things that need implementing for the core framework: the Clock class and the Simulant trait.
Once the simulation is fully initialized, the clock will be sent the Start message and running will become true.
This way, the simulation stays frozen until all of its pieces have been connected together as desired.
It also means that, since all of the simulants are also frozen, it is safe to use regular method calls to set things up instead of needing to use actor message sends.
A clock may as well go ahead and start running as an actor once it is created.
This is safe, because it will not actually do anything until it receives a Start message:
A clock also keeps track of the current time (currentTime), the list of participants managed by this clock (allSimulants), and the list of participants that are still working on the current time tick (busySimulants)
A list is used to hold allSimulants, because it is only iterated through, but a set is used for busySimulants because items will be removed from it in an unpredictable order.
Once the simulator starts running, it will only advance to a new time when busySimulants is empty, and whenever it advances the clock, it will set busySimulants to allSimulants.
To set up a simulation, there is going to be a need for a method to add new simulants to a clock.
Its main loop alternates between two responsibilities: advancing the clock, and responding to messages.
Once the clock advances, it can only advance again when at least one message has been received, so it is safe to define the main loop as an alternation between these two activities:
The advancement of time has a few parts beyond simply incrementing the currentTime.
First, if the agenda is empty, and the simulation is not just starting, then the simulation should exit.
Second, assuming the agenda is non-empty, all work items for time currentTime should now take place.
Third, all simulants should be put on the busySimulants list and sent Pings.
The clock will not advance again until all Pings have been responded to:
Processing the current events is simply a matter of processing all events at the top of the agenda whose time is currentTime:
First, the items that need to occur at the current time are selected using takeWhile and saved into the val todoNow.
Second, those items are dropped from the agenda by using drop.
Finally, the items to do now are looped through and sent the target message.
The assert is included just to guarantee that the scheduler’s logic is sound.
Given this ground work, handling the messages that a clock can receive is straightforward.
An AfterDelay message causes a new item to be added to the work queue.
A Pong causes a simulant to be removed from the list of.
Start causes the simulation to begin, and Stop causes the clock to stop:
The insert method, not shown, is exactly like that of Listing 18.8
It inserts its argument into the agenda while being careful to keep the agenda sorted.
Boiled down to its essence, a Simulant is any actor that understands and cooperates with the simulation messages Stop and Ping.
Its act method can therefore be as simple as this:
If it receives a Ping, it responds with a Pong.
If the Ping is for time 1, then simStarting is called before the Pong is sent back, allowing subclasses to define behavior that should happen when the simulation starts running.
Any other message must be interpreted by subclasses, so it defers to an abstract handleSimMessage method.
There are two abstract members of a simulant: handleSimMessage and clock.
A simulant must know its clock so that it can reply to Ping messages and schedule new work items.
Putting it all together, the Simulant trait is as shown in Listing 32.7
Note that a simulant goes ahead and starts running the moment it is created.
This is safe and convenient, because it will not actually do anything until its clock sends it a message, and that should not happen until the simulation starts and the clock receives a Start message.
Like its sequential cousin in Chapter 18, it takes surprisingly little code.
Now that the simulation framework is complete, it’s time to work on the implementation of circuits.
A circuit has a number of wires and gates, which will be simulants, and a clock for managing the simulation.
A wire holds a boolean signal—either high (true) or low (false)
Gates are connected to a number of wires, some of which are inputs and others outputs.
Gates compute a signal for their output wires based on the state of their input wires.
Since the wire, gates, etc., of a circuit are only used for that particular circuit, their classes can be defined as members of a Circuit class, just as with the currency objects of Section 20.10
The overall Circuit class will therefore have a number of members:
Now look at each of these members, one group at a time.
Once the simulation starts running, wires and gates can only communicate via message sends, so they will need a message type for each kind of information they want to send each other.
Gates need to tell their output wires to change state, and wires need to inform the gates they are inputs to whenever their state changes:
It is unclear what the precise delays should be, so those delays are worth putting into vals.
This way, they can be easily adjusted in the future:
At this point it is time to look at the Wire and Gate classes.
A wire is a simulant that has a current signal state (high or low) and a list of gates that are observing that state.
It mixes in the Simulant trait, so it also needs to specify a clock to use:
The class also needs a handleSimMessage method to specify how it should respond to simulation messages.
The only message a wire should receive is SetSignal, the message for changing a wire’s signal.
The response should be that if the signal is different from the current signal, the current state changes, and the new signal is propagated:
The above code shows how changes in a wire’s signal are propagated to any gates watching it.
It’s also important to pass the initial state of a wire to any observing gates.
This only needs to be done once, when the simulation starts up.
After that, gates can simply store the result of the most recent SignalChanged they have received.
Sending out the initial signal when the simulation starts is as simple as providing a simStarting() method:
There are now just a few more odds and ends about wires.
Wires need a method for connecting new gates, and they could use a nice toString method:
Now consider gates, the other major class of objects in a circuit.
There are three fundamental gates that would be nice to define: And, Or, and Not.
All of these share a lot of behavior, so it is worth defining an abstract Gate class to hold the commonality.
A difficulty in defining this Gate class is that some gates have two input wires (And, Or) while others have just one (Not)
However, it simplifies the code to think of all gates as having two inputs, where Not gates simply ignore their second input.
The ignored second input can be set to some dummy wire that never changes state from false:
Given this trick, the gate class will come together straightforwardly.
It mixes in the Simulant trait, and its one constructor accepts two input wires and one output wire:
Thus, there should be an abstract method for computing an output based on inputs:
Thus, the delay of the gate should be an abstract val:
The delay could be a def, but making it a val encodes the fact that a particular gate’s delay should never change.
Because Gate mixes in Simulant, it is required to specify which clock it is using.
As with Wire, Gate should specify the clock of the enclosing Circuit.
For convenience, the Gate can go ahead and add itself to the clock when it is constructed:
Similarly, it makes sense to go ahead and connect the gate to the two input wires, using regular method calls:
The only local state of a gate is the most recent signal on each of its input wires.
This state needs to be stored, because wires only send a signal when the state changes.
If one input wire changes, only that one wire’s state will be sent to the gate, but the new output will need to be computed from both wires’ states:
There is only one message they need to handle, and that’s the SignalChanged message indicating that one of the input wires has changed.
When a SignalChanged arrives, two things need to be done.
First, the local notion of the wire states need to be updated according to the change.
Second, the new output needs to be computed and then sent out to the output wire with a SetSignal message:
Given this abstract Gate class, it is now easy to define specific kinds of gates.
As with the sequential simulation in Chapter 18, the gates can be created as side effects of calling some utility methods.
All the methods need to do is create a Gate and fill in the appropriate delay and output computation.
Everything else is common to all gates and is handled in the Gate class:
In the case of Not gates, a dummy wire will be specified as the second input.
This is an implementation detail from the point of view of a caller creating a Not gate, so the inverter method only takes one input wire instead of two:
At this point the library can simulate circuits, but, as described in Chapter 18, it is useful to add a wire-probing utility so that you can watch the circuit evolve.
Without such a utility, the simulation would have no way to know which wires are worth logging and which are more like implementation details.
Define a probe method that takes a Wire as an argument and then prints out a line of text whenever that wire’s signal changes.
The method can be implemented by simply making a new simulant that connects itself to a specified wire.
This simulant can respond to SignalChanged messages by printing out the new signal:
Callers should create an instance of Circuit, create a bunch of wires and gates, call probe on a few wires of interest, and then start the simulation running.
The one piece missing is how the simulation is started, and that can be as simple as sending the clock a Start message:
For instance Listing 32.8 shows again the half adder and full adder components that were already introduced then.
Their implementation stays the same, but as a small variation they are now packaged in a trait, named Adders, whereas in Chapter 18 they were contained in an abstract class.
Because the trait is marked as extending Circuit, it can directly access members of Circuit such as Wire and orGate.
This circuit variable holds a circuit that has all of the methods of Circuit and all of the methods of Adders.
Note that with this coding pattern, based on a trait instead of a class, you set the stage to provide multiple component sets.
Users mix in whichever component sets they plan to use, like this:
It includes a simulation framework, a circuit simulation class, and a small library of standard adder components.
This example creates a circuit that includes the Adders trait.
It immediately imports all of the circuit’s members, thus allowing easy accesses to methods like probe and fullAdder.
Three will be used as inputs (ain, bin, and cin), and two will be used as outputs (sout, cout)
The three input wires are given arbitrary initial signals of true, false, and true.
The probe method gets applied to all five externally visible wires, so any changes in their state can be observed as the simulation runs.
Finally the wires are plugged into a full adder, and the simulation is started.
It lets you simplify your code, and it lets you take advantage of multiple processors.
It is therefore unfortunate that the most widely used concurrency primitives, threads, locks, and monitors, are such a minefield of deadlocks and race conditions.
The actors style provides a way out of the minefield, letting you write concurrent programs without having such a great risk of deadlocks and race.
This chapter has introduced several fundamental constructs for working with actors in Scala, including how to create actors, how to send and receive messages, and how to conserve threads with react, among other nuts and bolts.
It then showed you how to use these constructs as part of a general actors style.
Occasionally, you may need to process a small, special-purpose language.
For example, you may need to read configuration files for your software, and you want to make them easier to modify by hand than XML.
Whatever the reason, you are going to need a parser.
You need a way to convert the input language into some data structure your software can process.
One choice is to roll your own parser (and lexical analyzer)
If you are an expert, it is still time consuming.
Some of the better known are Yacc and Bison for parsers written in C and ANTLR for parsers written in Java.
You’ll probably also need a scanner generator such as Lex, Flex, or JFlex to go with it.
This might be the best solution, except for a couple of inconveniences.
You need to learn new tools, including their—sometimes obscure—error messages.
You also need to figure out how to connect the output of these tools to your program.
This might limit the choice of your programming language, and complicate your tool chain.
Instead of using the standalone domain specific language of a parser generator, you will use an internal domain specific language, or internal DSL for short.
This chapter introduces only one language feature that was not explained before: this aliasing, in Section 33.6
The chapter does, however, heavily use several other features that were explained in previous chapters.
Among others, parameterized types, abstract types, functions as objects, operator overloading, by-name parameters, and implicit conversions all play important roles.
The chapter shows how these language elements can be combined in the design of a very high-level library.
The concepts explained in this chapter tend to be a bit more advanced than previous chapters.
If you have a good grounding in compiler construction, you’ll profit from it reading this chapter, because it will help you put things better in perspective.
However, the only prerequisite for understanding this chapter is that you know about regular and context-free grammars.
If you don’t, the material in this chapter can also safely be skipped.
Say you want to construct a parser for arithmetic expressions consisting of floating-point numbers, parentheses, and the binary operators +, -, *, and /
The first step is always to write down a grammar for the language to be parsed.
This context-free grammar defines formally a language of arithmetic expressions.
Every expression (represented by expr) is a term, which can be followed by a sequence of + or - operators and further terms.
A term is a factor, possibly followed by a sequence of * or / operators and further factors.
A factor is either a numeric literal or an expression in parentheses.
Note that the grammar already encodes the relative precedence of operators.
Now that you have defined the grammar, what’s next? If you use Scala’s combinator parsers, you are basically done! You only need to perform some systematic text replacements and wrap the parser in a class, as shown in Listing 33.1:
The parsers for arithmetic expressions are contained in a class that inherits from the trait JavaTokenParsers.
This trait provides the basic machinery for writing a parser and also provides some primitive parsers that recognize some word classes: identifiers, string literals and numbers.
The three definitions in class Arith represent the productions for arithmetic expressions.
As you can see, they follow very closely the productions of the context-free grammar.
In fact, you could generate this part automatically from the context-free grammar, by performing a number of simple text replacements:
Every production becomes a method, so you need to prefix it with def.
The result type of each method is Parser[Any], so you need to change the ::= symbol to “: Parser[Any] =”
You’ll find out later in this chapter what the type Parser[Any] signifies, and also how to make it more precise.
In the grammar, sequential composition was implicit, but in the program it is expressed by an explicit operator: ~
So you need to insert a ~ between every two consecutive symbols of a production.
That way, the parser code keeps closely to the visual appearance of the grammar—it just replaces spaces by ~ characters.
The resulting class Arith defines three parsers, expr, term and factor, which can be used to parse arithmetic expressions and their parts.
You can exercise your parser with the following small program:
The ParseExpr object defines a main method that parses the first commandline argument passed to it.
It prints the original input argument, and then prints its parsed version.
This expression applies the parser, expr, to the given input.
It expects that all of the input matches, i.e., that there are no characters trailing a parsed expression.
There’s also a method parse, which allows you to parse an input prefix, leaving some remainder unread.
You can run the arithmetic parser with the following command:
The output tells you that the parser successfully analyzed the input string up to position [1.12]
That means the first line and the twelfth column—in other words, the whole input string—was parsed.
It is not very useful, and you will find out later how to get more specific parser results.
You can also try to introduce some input string that is not a legal expression.
For instance, you could write one closing parenthesis too many:
Here, the expr parser parsed everything until the final closing parenthesis, which does not form part of the arithmetic expression.
The parseAll method then issued an error message, which said that it expected a - operator at the point of the closing parenthesis.
You’ll find out later in this chapter why it produced this particular error message, and how you can improve it.
This parser, which was inherited from Arith’s supertrait, JavaTokenParsers, recognizes a floating point number in the format of Java.
But what do you do if you need to parse numbers in a format that’s a bit different from Java’s? In this situation, you can use a regular expression parser.
The idea is that you can use any regular expression as a parser.
The regular expression parses all strings that it can match.
For instance, the regular expression parser shown in Listing 33.2 describes Java’s identifiers:
The MyParsers object of Listing 33.2 inherits from trait RegexParsers, whereas Arith inherited from JavaTokenParsers.
The top-level trait is Parsers, which defines a very general parsing framework for all sorts of input.
One level below is trait RegexParsers, which requires that the input is a sequence of characters and provides for regular expression parsing.
Even more specialized is trait JavaTokenParsers, which implements parsers for basic classes of words (or tokens) as they are defined in Java.
JSON, the JavaScript Object Notation, is a popular data interchange format.
In this section, we’ll show you how to write a parser for it.
A JSON value is an object, array, string, number, or one of the three reserved words null, true, or false.
A JSON object is a (possibly empty) sequence of members separated by commas and enclosed in braces.
Each member is a string/value pair where the string and the value are separated by a colon.
Finally, a JSON array is a sequence of values separated by commas and enclosed in square brackets.
As an example, Listing 33.3 contains an address-book formatted as a JSON object.
Parsing such data is straightforward when using Scala’s parser combinators.
This parser follows the same structure as the arithmetic expression parser.
It is again a straightforward mapping of the productions of the JSON grammar.
For instance, in the example in Listing 33.4, repsep(member, ",") parses a comma-separated sequence of member terms.
Otherwise, the productions in the parser correspond exactly to the productions in the grammar, as was the case for the arithmetic expression parsers.
To try out the JSON parsers, we’ll change the framework a bit, so that the parser operates on a file instead of on the command line:
The main method in this program first creates a FileReader object.
It then parses the characters returned by that reader according to the value production of the JSON grammar.
It seems to be a sequence composed of bits and pieces of the input glued together with lists and ~ combinations.
It is less readable for humans than the input, but it is also too disorganized to be easily analyzable by a computer.
To figure out what to do, you need to know first what the individual parsers in the combinator frameworks return as a result (provided they succeed in parsing the input)
A sequential composition P~Q returns the results of both P and of Q.
These results are returned in an instance of a case class that is also written ~
An alternative composition P | Q returns the result of either P or Q, whichever one succeeds.
A repetition rep(P) or repsep(P, separator) returns a list of the results of all runs of P.
An option opt(P) returns an instance of Scala’s Option type.
With these rules you can now deduce why the parser output appeared as it did in the previous examples.
It would be much better to map a JSON object into an internal Scala representation that represents the meaning of the JSON value.
A JSON object is represented as a Scala map of type Map[String, Any]
Every member is represented as a key/value binding in the map.
A JSON array is represented as a Scala list of type List[Any]
A JSON numeric literal is represented as a Scala Double.
The values true, false, and null are represented as the Scala values with the same names.
As an example, here is a parser that parses a floating point number and converts it to a Scala value of type Double:
And here is a parser that parses the string "true" and returns Scala’s boolean true value:
Here’s a new version of a parser for JSON objects that returns a Scala Map:
Here’s a definition of that class—it’s an inner class of trait Parsers:
Listing 33.5 shows a full JSON parser that returns meaningful results.
This is all you need to know in order to get started writing your own parsers.
As an aide to memory, Table 33.1 lists the parser combinators that were discussed so far.
Note that the body of the value parser in Listing 33.5 is enclosed in parentheses.
This is a little trick to disable semicolon inference in parser expressions.
You saw in Section 4.2 that Scala assumes there’s a semicolon between any two lines that can be separate statements syntactically, unless the first line ends in an infix operator, or the two lines are enclosed in parentheses or square brackets.
Now, you could have written the | operator at the end of the each alternative instead of at the beginning of the following one, like this:
In that case, no parentheses around the body of the value parser would have been required.
However, some people prefer to see the | operator at the beginning of the second alternative rather than at the end of the first.
Normally, this would lead to an unwanted semicolon between the two lines, like this:
The semicolon changes the structure of the code, causing it to fail compilation.
Putting the whole expression in parentheses avoids the semicolon and makes the code compile correctly.
That’s important for a parser because it lets you concentrate on the grammar at hand, instead of the combinators themselves.
You notice that the code becomes much longer, and that it’s hard to “see” the grammar among all those operators and parentheses.
On the other hand, somebody new to combinator parsing could probably figure out better what the code is supposed to do.
The previous sections have shown that Scala’s combinator parsers provide a convenient means for constructing your own parsers.
Since they are nothing more than a Scala library, they fit seamlessly into your Scala programs.
So it’s very easy to combine a parser with some code that processes the results it delivers, or to rig a parser so that it takes its input from some specific source (say, a file, a string, or a character array)
How is this achieved? In the rest of this chapter you’ll take a look “under the hood” of the combinator parser library.
You’ll see what a parser is, and how the primitive parsers and parser combinators encountered in previous sections are implemented.
You can safely skip these parts if all you want to do is write some simple combinator parsers.
On the other hand, reading the rest of this chapter should give you a deeper understanding of combinator.
Choosing between symbolic and alphabetic names As guidelines for choosing between symbolic and alphabetic names we recommend the following:
Use symbolic names in cases where they already have a universally established meaning.
For instance, nobody would recommend writing add instead of + for numeric addition.
Otherwise, give preference to alphabetic names if you want your code to be understandable to casual readers.
You can still choose symbolic names for domain-specific libraries, if this gives clear advantages in legibility and you do not expect anyway that a casual reader without a firm grounding in the domain would be able to understand the code immediately.
In the case of parser combinators we are looking at a highly domainspecific language, which casual readers may have trouble understanding even with alphabetic names.
Furthermore, symbolic names give clear advantages in legibility for the expert.
So we believe their use is warranted in this application.
This trait defines the Parser type as well as all fundamental combinators.
Except where stated explicitly otherwise, the definitions explained in the following two subsections all reside in this trait.
That is, they are assumed to be contained in a trait definition that starts as follows:
A Parser is in essence just a function from some input type to a parse result.
As a first approximation, the type could be written as follows:
Sometimes, a parser reads a stream of tokens instead of a raw sequence of characters.
A separate lexical analyzer is then used to convert a stream of raw characters into a stream of tokens.
It is similar to a Stream, but also keeps track of the positions of all the elements it reads.
It is an abstract type member of the Parsers trait:
This means that subclasses and subtraits of Parsers need to instantiate class Elem to the type of input elements that are being parsed.
But it would also be possible to set Elem to some other type, such as the type of tokens returned from a separate lexer.
A parser might either succeed or fail on some given input.
Consequently class ParseResult has two subclasses for representing success and failure:
The Success case carries the result returned from the parser in its result parameter.
The type of parser results is arbitrary; that’s why ParseResult, Success, and Parser are all parameterized with a type parameter T.
The type parameter represents the kinds of results returned by a given parser.
Success also takes a second parameter, in, which refers to the input immediately following the part that the parser consumed.
This field is needed for chaining parsers, so that one parser can operate after another.
Note that this is a purely functional approach to parsing.
A parser analyzes some part of the input stream, and then returns the remaining part in its result.
This class takes as a parameter a message that describes why the parser failed.
Like Success, Failure also takes the remaining input stream as a second parameter.
This is needed not for chaining (the parser won’t continue after a failure), but to position the error message at the correct place in the input stream.
Note that parse results are defined to be covariant in the type parameter T.
That is, a parser returning Strings as result, say, is compatible with a parser returning AnyRefs.
The previous characterization of parsers as functions from inputs to parse results was a bit oversimplified.
So Parser is in reality a class that inherits from the function type Input => ParseResult[T] and additionally defines these methods:
Since parsers are (i.e., inherit from) functions, they need to define an apply method.
The apply method still needs to be implemented in the individual parsers that inherit from the abstract Parser class.
These parsers will be discussed after the following section on this aliasing.
The body of the Parser class starts with a curious expression:
A clause such as “id =>” immediately after the opening brace of a class template defines the identifier id as an alias for this in the class.
For instance, you could access an object-private member m of the class using either id.m or this.m; the two are completely equivalent.
The first expression would not compile if id were just defined as a val with this as its right hand side, because in that case the Scala compiler would treat id as a normal identifier.
You saw syntax like this in Section 29.4, where it was used to give a self type to a trait.
Aliasing can also be a good abbreviation when you need to access the this of an outer class.
Inside Inner the this value of the Outer class is referred to twice, using different expressions.
The first expression shows the Java way of doing things: You can prefix the reserved word this with the name of an outer class and a period; such an expression then refers to the this of the outer class.
The second expression shows the alternative that Scala gives you.
By introducing an alias named outer for this in class Outer, you can refer to this alias directly also in inner classes.
The Scala way is more concise, and can also improve clarity, if you choose the name of the alias well.
Trait Parsers defines a generic parser elem that can be used to parse any single token:
This parser takes two parameters: a kind string describing what kind of token should be parsed and a predicate p on Elems, which indicates whether an element fits the class of tokens to be parsed.
When applying the parser elem(kind, p) to some input in, the first element of the input stream is tested with predicate p.
Its result is the element itself, and its remaining input is the input stream starting just after the element that was parsed.
On the other hand, if p returns false, the parser fails with an error message that indicates what kind of token was expected.
To parse more interesting phrases, you can string parsers together with the sequential composition operator ~
As you have seen before, P~Q is a parser that applies first the P parser to a given input string.
Then, if P succeeds, the Q parser is applied to the input that’s left after P has done its job.
The ~ combinator is implemented as a method in class Parser.
Now, if p~q is run on some input in, first p is run on in and the result is analyzed in a pattern match.
If p succeeds, q is run on the remaining input in1
If q also succeeds, the parser as a whole succeeds.
Its result is a ~ object containing both the result of p (i.e., x) and the result of q (i.e., y)
On the other hand, if either p or q fails the result of p~q is the Failure object returned by p or q.
Generally, Scala always interprets a binary type operation such as A op B, as the parameterized type op[A, B]
This is analogous to the situation for patterns, where a binary pattern P op Q is also interpreted as an application, i.e., op(P, Q)
A more elegant technique, though, is to define them in terms of ~ as follows:
An alternative composition P | Q applies either P or Q to a given input.
If P succeeds, the whole parser succeeds with the result of P.
Otherwise, if P fails, then Q is tried on the same input as P.
The result of Q is then the result of the whole parser.
Here is a definition of | as a method of class Parser:
Note that if P and Q both fail, then the failure message is determined by Q.
This means that the actual parser argument will be evaluated only when q is needed, which should only be the case after p has run.
This makes it possible to write recursive parsers like the following one which parses a number enclosed by arbitrarily many parentheses:
There are also two parsers that do not consume any input: success and failure.
Both are implemented as methods in trait Parsers, the outer trait that also contains class Parser:
Also defined in trait Parsers are the option and repetition combinators opt, rep, and repsep.
They are all implemented in terms of sequential composition, alternative, and result conversion:
The parsers you saw so far made use of string literals and regular expressions to parse single words.
The support for these comes from RegexParsers, a subtrait of Parsers:
This trait is more specialized than trait Parsers in that it only works for inputs that are sequences of characters:
It defines two methods, literal and regex, with the following signatures:
Note that both methods have an implicit modifier, so they are automatically applied whenever a String or Regex is given but a Parser is expected.
That’s why you can write string literals and regular expressions directly in a grammar, without having to wrap them with one of these methods.
The RegexParsers trait also takes care of handling white space between symbols.
To do this, it calls a method named handleWhiteSpace before running a literal or regex parser.
The handleWhiteSpace method skips the longest input sequence that conforms to the whiteSpace regular expression, which is defined by default as follows:
If you prefer a different treatment of white space, you can override the whiteSpace val.
For instance, if you want white space not to be skipped at all, you can override whiteSpace with the empty regular expression:
The task of syntax analysis is often split into two phases.
The lexer phase recognizes individual words in the input and classifies them into some token classes.
This is followed by a syntactical analysis phase that analyzes sequences of tokens.
Syntactical analysis is also sometimes just called parsing, even though this is slightly imprecise, as lexical analysis can also be regarded as a parsing problem.
The Parsers trait as described in the previous section can be used for either phase, because its input elements are of the abstract type Elem.
For lexical analysis, Elem would be instantiated to Char, meaning the individual characters that make up a word are being parsed.
The syntactical analyzer would in turn instantiate Elem to the type of token returned by the lexer.
Scala’s parsing combinators provide several utility classes for lexical and syntactic analysis.
These are contained in two sub-packages, one for each kind of analysis:
If you want to split your parser into a separate lexer and syntactical analyzer, you should consult the Scaladoc documentation for these packages.
But for simple parsers, the regular expression based approach shown previously in this chapter is usually sufficient.
There’s one final topic that was not covered yet: how does the parser issue an error message? Error reporting for parsers is somewhat of a black art.
One problem is that when a parser rejects some input, it generally has encountered many different failures.
Each alternative parse must have failed, and recursively so at each choice point.
Which of the usually numerous failures should be emitted as error message to the user?
Scala’s parsing library implements a simple heuristic: among all failures, the one that occurred at the latest position in the input is chosen.
In other words, the parser picks the longest prefix that is still valid and issues an error message that describes why parsing the prefix could not be continued further.
If there are several failure points at that latest position, the one that was visited last is chosen.
For instance, consider running the JSON parser on a faulty address book which starts with the line:
The part that “false” was expected comes from the fact that "false" is the last alternative of the production for value in the JSON grammar.
Users who know the JSON grammar in detail can reconstruct the error message, but for non-experts this error message is probably surprising and can also be quite misleading.
A better error message can be engineered by adding a “catch-all” failure point as last alternative of a value production:
This addition does not change the set of inputs that are accepted as valid documents.
What it does is improve the error messages, because now it will be the explicitly added failure that comes as last alternative and therefore gets reported:
The implementation of the “latest possible” scheme of error reporting uses a field named lastFailure in trait Parsers to mark the failure that occurred at the latest position in the input:
It is updated in the constructor of the Failure class:
The field is read by the phrase method, which emits the final error message if the parser failed.
If p succeeds with a completely consumed input, the success result of p is returned.
If p succeeds but the input is not read completely, a failure with message “end of input expected” is returned.
If p fails, the failure or error stored in lastFailure is returned.
Note that the treatment of lastFailure is non-functional; it is updated as a side effect by the constructor of Failure and by the phrase method itself.
A functional version of the same scheme would be possible, but it would require threading the lastFailure value through every parser result, no matter whether this result is a Success or a Failure.
The parser combinators employ backtracking to choose between different parsers in an alternative.
In an expression P | Q, if P fails, then Q is run on.
This happens even if P has parsed some tokens before failing.
In this case the same tokens will be parsed again by Q.
Backtracking imposes only a few restrictions on how to formulate a grammar so that it can be parsed.
Then the second alternative would be tried on the same term and this would succeed.
In the end the term ended up being parsed twice.
It is often possible to modify the grammar so that backtracking can be avoided.
For instance, in the case of arithmetic expressions, either one of the following productions would work:
For instance, the grammars for arithmetic expressions and JSON terms earlier in this chapter are both LL(1), so the backtracking capabilities of the parser combinator framework are never exercised for inputs from these languages.
There are ways to avoid stack overflows even in the presence of left-recursion, but this requires a more refined parsing combinator framework, which to date has not been implemented.
Using this operator, the productions in the arithmetic expression parser could alternatively be written as follows:
One advantage of an LL(1) parser is that it can use a simpler input technique.
Input can be read sequentially, and input elements can be discarded once they are read.
That’s another reason why LL(1) parsers are usually more efficient than backtracking parsers.
You have now seen all the essential elements of Scala’s combinator parsing framework.
With the framework you can construct parsers for a large class of contextfree grammars.
The framework lets you get started quickly, but it is also customizable to new kinds of grammars and input methods.
Being a Scala library, it integrates seamlessly with the rest of the language.
So it’s easy to integrate a combinator parser in a larger Scala program.
One downside of combinator parsers is that they are not very efficient, at least not when compared with parsers generated from special purpose tools such as Yacc or Bison.
First, the backtracking method used by combinator parsing is itself not very efficient.
Depending on the grammar and the parse input, it might yield an exponential slow-down due to repeated backtracking.
The second problem affecting the performance of combinator parsers is that they mix parser construction and input analysis in the same set of operations.
In effect, a parser is generated anew for each input that’s parsed.
This problem can be overcome, but it requires a different implementation of the parser combinator framework.
In an optimizing framework, a parser would no longer be represented as a function from inputs to parse results.
Instead, it would be represented as a tree, where every construction step was represented as a case class.
For instance, sequential composition could be represented by a case class Seq, alternative by Alt, and so on.
The “outermost” parser method, phrase, could then take this symbolic representation of a parser and convert it to highly efficient parsing tables, using standard parser generator algorithms.
What’s nice about all this is that from a user perspective nothing changes compared to plain combinator parsers.
They need not be aware that these methods generate a symbolic representation of a parser instead of a parser function.
Since the phrase combinator converts these representations into real parsers, everything works as before.
The advantage of this scheme with respect to performance is two-fold.
First, you can now factor out parser construction from input analysis.
Second, the parser generation can use efficient parsing algorithms such as LALR(1).3 These algorithms usually lead to much faster parsers than parsers that operate with backtracking.
At present, such an optimizing parser generator has not yet been written for Scala.
If someone contributes such a generator, it will be easy to integrate into the standard Scala library.
Even postulating that such a generator will exist at some point in the future, however, there are reasons for keeping the current parser combinator framework around.
It is much easier to understand and to adapt than a parser generator, and the difference in speed would often not matter in practice, unless you want to parse very large inputs.
In this chapter you’ll learn how to develop in Scala applications that use a graphical user interface (GUI)
The applications we’ll develop are based on a Scala library that provides access to Java’s Swing framework of GUI classes.
Conceptually, the Scala library resembles the underlying Swing classes, but hides much of their complexity.
You’ll find out that developing GUI applications using the framework is actually quite easy.
Even with Scala’s simplifications, a framework like Swing is quite rich, with many different classes and many methods in each class.
To find your way in such a rich library, it helps to use an IDE such as Scala’s Eclipse plugin.
The advantage is that the IDE can show you interactively with its command completion which classes are available in a package and which methods are available for objects you reference.
This speeds up your learning considerably when you first explore an unknown library space.
As a first Swing application, we’ll start with a window containing a single button.
To program with Swing, you need to import various classes from Scala’s Swing API package:
Listing 34.1 shows the code of your first Swing application in Scala.
If you compile and run that file, you should see a window as shown on the left of Figure 34.1
The window can be resized to a larger size as shown on the right of Figure 34.1
If you analyze the code in Listing 34.1 line by line, you’ll notice the following elements:
The main method then proceeds to call the top method, which you supply:
This method contains the code that defines your top-level GUI component.
This is usually some kind of Frame—i.e., a window that can contain arbitrary data.
A MainFrame is like a normal Swing Frame except that closing it will also close the whole GUI application.
Two of the most important are the frame’s title, which will be written in the title bar, and its contents, which will be displayed in the window itself.
In Scala’s Swing API, such attributes are modeled as properties.
You know from Section 18.2 that properties are encoded in Scala as pairs of getter and setter methods.
For instance, the title property of a Frame object is modeled as a getter method:
It is this setter method that gets invoked by the above assignment to title.
The effect of the assignment is that the chosen title is shown in the header of the window.
If you leave it out, the window will have an empty title.
The top frame is the root component of the Swing application.
It is a Container, which means that further components can be defined in it.
Every Swing container has a contents property, which allows you to get and set the components it contains.
The getter contents of this property has type Seq[Component], indicating that a component can in general have several objects as its contents.
Frames, however, always have just a single component as their contents.
This component is set and potentially changed using the setter contents_=
For example, in Listing 34.1 a single Button constitutes the contents of the top frame.
The button also gets a title, in this case “Click me.”
As next step, we’ll add some text as a second content element to the top frame of the application.
The left part of Figure 34.2 shows what the application should look like.
You saw in the last section that a frame contains exactly one child component.
Hence, to make a frame with both a button and a label, you need to.
A Panel is a container that displays all the components it contains according to some fixed layout rules.
There are a number of different possible layouts that are implemented by various subclasses of class Panel, ranging from simple to quite intricate.
In fact, one of the hardest parts of a complex GUI application can be getting the layouts right—it’s not easy to come up with something that displays reasonably well on all sorts of devices and for all window sizes.
In this class, the two subcomponents of the top frame are named button and label.
The label is a displayed text field that can’t be edited:
The code in Listing 34.2 picks a simple vertical layout where components are stacked on top of each other in a BoxPanel:
The contents property of the BoxPanel is an (initially empty) buffer, to which the button and label elements are added with the += operator:
We also add a border around the two objects by assigning to the border property of the panel:
As is the case with other GUI components, borders are represented as objects.
EmptyBorder is a factory method in object Swing that takes four parameters indicating the width of the borders on the top, right, bottom, and left sides of the objects to be drawn.
Simple as it is, the example has already shown the basic way to structure a GUI application.
It is built from components, which are instances of scala.swing classes such as Frame, Panel, Label or Button.
Components have properties, which can be customized by the application.
Panel components can contain several other components in their contents property, so that in the end a GUI application consists of a tree of components.
On the other hand, the application still misses an essential property.
If you run the code in Listing 34.2 and click on the displayed button, nothing happens.
In fact, the application is completely static; it does not react in any way to user events except for the close button of the top frame, which terminates the application.
So as a next step, we’ll refine the application so that it displays together with the button a label that indicates how often the button was clicked.
The right part of Figure 34.2 contains a snapshot of what the application should look like after a few button clicks.
To achieve this behavior, you need to connect a user-input event (the button was clicked) with an action (the displayed label is updated)
A subscriber subscribes with a publisher to be notified of any published events.
Publishers are also called “event sources,” and subscribers are also called “event listeners”
For instance a Button is an event source, which publishes an event, ButtonClicked, indicating that the button was clicked.
In Scala, subscribing to an event source source is done by the call listenTo(source)
There’s also a way to unsubscribe from an event source using deafTo(source)
In the current example application, the first thing to do is to get the top frame to listen to its button, so that it gets notified of any events that the button issues.
To do that you need to add the following call to the body of the top frame:
Being notified of events is only half the story; the other half is handling them.
It is here that the Scala Swing framework is most different from (and radically simpler than) the Java Swing API’s.
In Java, signaling an event means calling a “notify” method in an object that has to implement some Listener interfaces.
Usually, this involves a fair amount of indirection and boilerplate code, which makes event-handling applications hard to write and read.
By contrast, in Scala, an event is a real object that gets sent to subscribing components much like messages are sent to actors.
For instance, pressing a button will create an event which is an instance of the following case class:
The parameter of the case class refers to the button that was clicked.
To have your component react to incoming events you need to add a handler to a property called reactions.
The first line above defines a variable, nClicks, which holds the number of times a button was clicked.
The remaining lines add the code between braces as a handler to the reactions property of the top frame.
Handlers are functions defined by pattern matching on events, much like an actor’s receive blocks are defined by pattern matching on messages.
The handler above matches events of the form ButtonClicked(b), i.e., any event which is an instance of class ButtonClicked.
The pattern variable b refers to the actual button that was clicked.
The action that corresponds to this event in the code above increments nClicks and updates the text of the label.
Generally, a handler is a PartialFunction that matches on events and performs some actions.
It is also possible to match on more than one kind of event in a single handler by using multiple cases.
It’s also possible to remove handlers from the reaction property, using the -= operator.
As another example, we’ll write a GUI program that converts between temperature degrees in Celsius and Fahrenheit.
The user interface of the program is shown in Figure 34.3
It consists of two text fields (shown in white) with a label following each.
One text field shows temperatures in degrees Celsius, the other in degrees Fahrenheit.
Each of the two fields can be edited by the user of the application.
Once the user has changed the temperature in either field, the temperature in the other field should automatically update.
Listing 34.4 shows the complete code that implements this application.
The imports at the top of the code use a short-hand:
This is in fact equivalent to the imports used before:
The reason you can use the shorthand is that packages nest in Scala.
Because package scala.swing is contained in package scala, and everything in that package imported automatically, you can write just swing to refer to the package.
Because you have imported everything in scala.swing in the first import, you can refer to the event package with just event thereafter.
The two components celsius and fahrenheit in TempConverter are objects of class TextField.
A TextField in Swing is a component that lets you edit a single line of text.
It has a default width, which is given in the columns property measured in characters (set to 5 for both fields)
The contents of TempConverter are assembled into a panel, which includes the two text fields and two labels that explain what the fields are.
The panel is of class FlowPanel, which means it displays all its elements.
The reactions of TempConverter are defined by a handler that contains two cases.
Each case matches an EditDone event for one of the two text fields.
Such an event gets issued when a text field has been edited by the user.
Note the form of the patterns, which include back ticks around the element names:
As was explained in Section 15.2, the back ticks around celsius ensure that the pattern matches only if the source of the event was the celsius object.
If you had omitted the back ticks and just written case EditDone(celsius), the pattern would have matched every event of class EditDone.
The changed field would then be stored in the pattern variable celsius.
Alternatively, you could have defined the two TextField objects starting with upper case characters, i.e., Celsius and Fahrenheit.
In that case you could have matched them directly without back ticks, as in case EditDone(Celsius)
The two actions of the EditDone events convert one quantity to another.
Each starts by reading out the contents of the modified field and converting it to an Int.
It then applies the formula for converting one temperature degree to the other, and stores the result back as a string in the other text field.
This chapter has given you a first taste of GUI programming, using Scala’s wrappers for the Swing framework.
It has shown how to assemble GUI components, how to customize their properties, and how to handle events.
For space reasons, we could discuss only a small number of simple components.
You can find out about them by consulting the Scala documentation of the package scala.swing.
The next section will develop an example of a more complicated Swing application.
There are also many tutorials on the original Java Swing framework, on which the Scala wrapper is based.1 The Scala wrappers resemble the underlying Swing classes, but try to simplify concepts where possible and make them more uniform.
The simplification makes extensive use of the properties of the Scala language.
Its “everything is an object” philosophy makes it possible to inherit the main method of a GUI application.
The method can thus be hidden from user applications, including the boilerplate code for setting things up that comes with it.
Finally, and most importantly, Scala’s first-class functions and pattern matching make it possible to formulate event handling as the reactions component property, which greatly simplifies life for the application developer.
In the previous chapters you saw many different constructs of the Scala programming language.
In this chapter you’ll see how these constructs play together in the implementation of a sizable application.
The task is to write a spreadsheet application, which will be named SCells.
First, everybody knows spreadsheets, so it is easy to understand what the application should do.
Second, spreadsheets are programs that exercise a large range of different computing tasks.
There’s the visual aspect, where a spreadsheet is seen as a rich GUI application.
There’s the symbolic aspect, having to do with formulas and how to parse and interpret them.
There’s the calculational aspect, dealing with how to update possibly large tables incrementally.
There’s the reactive aspect, where spreadsheets are seen as programs that react in intricate ways to events.
Finally, there’s the component aspect where the application is constructed as a set of reusable components.
All these aspects will be treated in depth in this chapter.
We’ll start by writing the basic visual framework of the application.
Figure 35.1 shows the first iteration of the user interface.
You can see that a spreadsheet is a scrollable table.
You express this in Swing by defining a spreadsheet as a ScrollPane containing a Table.
It imports from package scala.swing essential elements of Scala’s Swing wrapper.
Spreadsheet itself is a class that takes height and width (in numbers of cells) as parameters.
The class extends ScrollPane, which gives it the scroll-bars at the bottom and right in Figure 35.1
The four lines in its body set some of its attributes: rowHeight for the height of a table row in points, autoResizeMode to turn auto-sizing the table off, showGrid to show a grid of lines between cells, and gridColor to set the color of the grid to a dark gray.
The rowHeader component, which contains the row-number headers at the left of the spreadsheet in Figure 35.1, is a ListView that displays in its.
The two lines in its body fix the width of a cell to be 30 points and the height to be the same as the table’s rowHeight.
The whole spreadsheet is assembled by setting two fields in ScrollPane.
The field viewportView is set to the table, and the field rowHeaderView is set to the rowHeader list.
The difference between the two views is that a view port of a scroll pane is the area that scrolls with the two bars, whereas the row header on the left stays fixed when you move the horizontal scroll bar.
By some quirk, Swing already supplies by default a column header at the top of the table, so there’s no need to define one explicitly.
To try out the rudimentary spreadsheet shown in Listing 35.1, you just need to define a main program that creates the Spreadsheet component.
If you play a bit with the spreadsheet written so far, you’ll quickly notice that the output that’s displayed in a cell is always exactly what you entered in the cell.
In a real spreadsheet, you would enter a formula and you’d see its value.
So what is entered into a cell is different from what is displayed.
As a first step to a real spreadsheet application, you should concentrate on disentangling data entry and display.
The basic mechanism for display is contained in the rendererComponent method of class Table.
If you want to change that, you need to override rendererComponent to do something different.
Listing 35.3 shows a new version of Spreadsheet with a rendererComponent method.
The rendererComponent method overrides a default method in class Table.
The isSelected and hasFocus parameters are Booleans that indicate whether the cell has been selected and whether it has focus, meaning that keyboard events will go into the cell.
The remaining two parameters, row and column, give the cell’s coordinates.
The new rendererComponent method checks whether the cell has input focus.
If hasFocus is true, the cell is used for editing.
In this case you want to display an editable TextField that contains the data the user has entered so far.
This data is returned by the helper method userData, which displays the contents of the table at a given row and column.
The contents are retrieved by the call this(row, column).1 The userData method also takes care to display a null element as the empty string instead of “null.”
Although “this(row, column)” may look similar to a constructor invocation, it is in this case an invocation of the apply method on the current Table instance.
But what should be displayed if the cell does not have focus? In a real spreadsheet this would be the value of a cell.
The first table, named table contains what the user entered.
A second “shadow” table contains the internal representation of cells and what should be displayed.
In the spreadsheet example, this table is a two-dimensional array called cells.
If a cell at a given row and column does not have editing focus, the rendererComponent method will display the element cells(row)(column)
The element cannot be edited, so it should be displayed in a Label instead of in an editable TextField.
You could do this directly in the Spreadsheet class, but it’s generally preferable to separate the view of a GUI component from its internal model.
That’s why in the example above the cells array is defined in a separate class named Model.
The model is integrated into the Spreadsheet by defining a value cellModel of type Model.
The import clause that follows this val definition makes the members of cellModel available inside Spreadsheet without having to prefix them.
Listing 35.4 shows a first simplified version of a Model class.
The class defines an inner class, Cell, and a two-dimensional array, cells, of Cell elements.
If you compile the modified Spreadsheet class with the Model class and run the Main application you should see a window as in Figure 35.2
The objective of this section was to arrive at a design where the displayed value of a cell is different from the string that was entered into it.
This objective has clearly been met, albeit in a very crude way.
In the new spreadsheet you can enter anything you want into a cell, but it will always display just its coordinates once it loses focus.
In reality, a spreadsheet cell holds two things: An actual value and a formula to compute this value.
A formula that computes a value always starts with an equals sign and is followed by an arithmetic expression.
The SCells spreadsheet has a particularly simple and uniform convention for arithmetic expressions: every.
The function name is an identifier such as add for binary addition, or sum for summation of an arbitrary number of operands.
A function argument can be a number, a reference to a cell, a reference to a range of cells such as C1:D16, or another function application.
You’ll see later that SCells has an open architecture that makes it easy to install your own functions via mixin composition.
The first step to handling formulas is writing down the types that represent them.
As you might expect, the different kinds of formulas are represented by case classes.
Listing 35.5 shows the contents of a file named Formulas.scala, where these case classes are defined:
The root of the class hierarchy shown in Listing 35.5 is a trait Formula.
Each case class overrides the toString method so that it displays its kind of formula in the standard way shown above.
For convenience there’s also an Empty object that represents the contents of an empty cell.
The Empty object is an instance of the Textual class with an empty string argument.
In the previous section you saw the different kinds of formulas and how they display as strings.
In this section you’ll see how to reverse the process: to transform a user input string into a Formula tree.
The rest of this section explains one by one the different elements of a class FormulaParsers, which contains the parsers that do the transformation.
Specifically, formula parsers are an instance of the RegexParsers class explained in that chapter:
The first two elements of object FormulaParsers are auxiliary parsers for identifiers and decimal numbers:
As you can see from the first regular expression above, an identifier starts with a letter or underscore.
This is followed by an arbitrary number of “word” characters represented by the regular expression code \w, which recognizes letters, digits or underscores.
The second regular expression describes decimal numbers, which consist of an optional minus sign, one or more digits that are represented by regular expression code \d, and an optional decimal part consisting of a period followed by zero or more digits.
It first calls a regular expression parser that determines the form of a coordinate: a single letter followed by one or more digits.
The string returned from that parser is then converted to a cell coordinate by separating the letter from the numerical part and converting the two parts to indices for the cell’s column and row:
Note that the cell parser is a bit restrictive in that it allows only column coordinates consisting of a single letter.
Hence the number of spreadsheet columns is in effect restricted to be at most 26, because further columns cannot be parsed.
It’s a good idea to generalize the parser so that it accepts cells with several leading letters.
Such a range is composed of two cell coordinates with a colon between them:
The number parser recognizes a decimal number, which is converted to a Double and wrapped in an instance of the Number class:
Such an application is composed of an identifier followed by a list of argument expressions in parentheses:
The expr parser recognizes a formula expression—either a top-level formula following an ‘=’, or an argument to a function.
Such a formula expression is defined to be a cell, a range of cells, a number, or an application:
This definition of the expr parser contains a slight oversimplification because ranges of cells should only appear as function arguments; they should not be allowed as top-level formulas.
You could change the formula grammar so that the two uses of expressions are separated, and ranges are excluded syntactically from top-level formulas.
In the spreadsheet presented here such an error is instead detected once an expression is evaluated.
The textual parser recognizes an arbitrary input string, as long as it does not start with an equals sign (recall that strings that start with ‘=’ are considered to be formulas):
The formula parser recognizes all kinds of legal inputs into a cell.
A formula is either a number, or a textual entry, or a formula starting with an equals sign:
The final method parse uses this grammar in a method that converts an input string into a Formula tree:
The parse method parses all of the input with the formula parser.
If it fails, a Textual object with an error message is returned instead.
The only thing that remains is to integrate the parser into the spreadsheet.
To do this, you can enrich the Cell class in class Model by a formula field:
In the new version of the Cell class, the toString method is defined to display the cell’s formula.
That way you can check whether formulas have been correctly parsed.
The last step in this section is to integrate the parser into the spreadsheet.
Parsing a formula happens as a reaction to the user’s input into a cell.
A completed cell input is modeled in the Swing library by a TableUpdated event.
It contains the table that was changed, as well as a set of coordinates of affected cells given by rows and column.
So in general a TableUpdated event can refer to several affected cells, but they would be on a consecutive range of rows and share the same column.
Once a table is changed, the affected cells need to be re-parsed.
To react to a TableUpdated event, you add a case to the reactions value of the table component, as is shown in Listing 35.6
Now, whenever the table is edited the formulas of all affected cells will be updated by parsing the corresponding user data.
When compiling the classes discussed so far and launching the scells.Main application you should see a spreadsheet application like the one shown in Figure 35.3
After editing is done, a cell displays the formula it contains.
Range[Int] is also the type of a Scala expression such as “1 to N”
Of course, in the end a spreadsheet should evaluate formulas, not just display them.
In this section, we’ll add the necessary components to achieve this.
What’s needed is a method, evaluate, which takes a formula and returns the value of that formula in the current spreadsheet, represented as a Double.
The method needs to access the cells field in class Model to find out about the current values of cells that are referenced in a formula.
On the other hand, the Model class needs to call evaluate.
Hence, there’s a mutual dependency between the Model and the Evaluator.
A good way to express such mutual dependencies between classes was shown in Chapter 29: you use inheritance in one direction and self types in the other.
In the spreadsheet example, class Model inherits from Evaluator and thus gains access to its evaluation method.
To go the other way, class Evaluator defines its self type to be Model, like this:
That way, the this value inside class Evaluator is assumed to be Model and the cells array is accessible by writing either cells or this.cells.
As you can see from this definition, operations are modeled as functions from lists of values to values.
The Op type introduces a convenient alias for the type of an operation.
The computation in evaluate is wrapped in a try-catch to guard against input errors.
There are actually quite a few things that can go wrong when evaluating a cell formula: coordinates might be out of range; function names might be undefined; functions might have the wrong number of arguments; arithmetic operations might be illegal or overflow.
The reaction to any of these errors is the same: a “not-a-number” value is returned.
The returned value, Double.NaN, is the IEEE representation for a computation that does not have a representable floating-point value.
This might happen because of an overflow or a division by zero, for example.
The advantage of this scheme is that it’s simple to understand and doesn’t require much code to implement.
Its disadvantage is that all kinds of errors are lumped together, so a spreadsheet user does not get any detailed feedback on what went wrong.
If you wish you can experiment with more refined ways of representing errors in the SCells application.
The evaluation of arguments is different from the evaluation of top-level formulas.
To handle arguments that might evaluate to lists, there’s another evaluation function, called evalList.
This function takes a formula and returns a list of values.
If the formula argument passed to evalList is a Range, the returned value is a list consisting of the values of all cells referenced by the range.
For every other formula the result is a list consisting of the single result value of that formula.
The cells referenced by a formula are computed by a third function, references.
The references method is actually more general than needed right now in that it computes the list of cells referenced by any sort of formula, not just a Range formula.
It will turn out later that the added functionality is needed to compute the sets of cells that need updating.
The body of the method is a straightforward pattern match on kinds of formulas.
For a coordinate Coord(row, column), it returns a single-element list containing the cell at that coordinate.
For the other two types of formulas, Textual and Number, it returns an empty list.
The class Evaluator itself defines no operations that can be performed on cells: its operations table is initially empty.
The idea is to define such operations in other traits, which are then mixed into the Model class.
Listing 35.8 shows an example trait that implements common arithmetic operations:
The only thing it does is populate the operations table during its initialization.
Of the seven operations that are defined by the Arithmetic trait, five are binary operations and two take an arbitrary number of arguments.
For instance, the addition operation add is defined by the expression:
That is, it expects an argument list consisting of two elements x and y and returns the sum of x and y.
If the argument list contains a number of elements different from two, a MatchError is thrown.
This corresponds to the general “let it crash” philosophy of SCell’s evaluation model, where incorrect input is expected to lead to a runtime exception that then gets caught by the trycatch inside the evaluation method.
The last two operations, sum and prod, take a list of arguments of arbitrary length and insert a binary operation between successive elements.
So they are instances of the “fold left” schema that’s expressed in class List by the /: operation.
For instance, to sum a list of numbers List(x, y, z), the operation computes 0 + x + y + z.
The first operand, 0, is the result if the list is empty.
You can integrate this operation library into the spreadsheet application by mixing the Arithmetic trait into the Model class, like this:
Another change in the Model class concerns the way cells display themselves.
In the new version, the displayed value of a cell depends on its formula.
If the formula is a Textual field, the contents of the field are displayed literally.
In all other cases, the formula is evaluated and the result value of that evaluation is displayed.
If you compile the changed traits and classes and relaunch the Main program you get something that starts to resemble a real spreadsheet.
You can enter formulas into cells and get them to evaluate themselves.
You’ll have to click on C5 manually to see a change in its value.
What’s still missing is a way to have cells recompute their values automatically after a change.
If a cell’s value has changed, all cells that depend on that value should have their results recomputed and redisplayed.
The simplest way to achieve this would be to recompute the value of every cell in the spreadsheet after each change.
However such an approach does not scale well as the spreadsheet grows in size.
A better approach is to recompute the values of only those cells that refer to a changed cell in their formula.
The idea is to use an event-based publish/subscribe framework for change propagation: once a cell gets assigned a formula, it will subscribe to be notified of all value changes in cells to which the formula refers.
A value change in one of these cells will trigger a re-evaluation of the subscriber cell.
If such a re-evaluation causes a change in the value of the cell, it will in turn notify all cells that depend on it.
The process continues until all cell values have stabilized, i.e., there are no more changes in the values of any cell.3
The publish/subscribe framework is implemented in class Model using the standard event mechanism of Scala’s Swing framework.
Compared to the previous version of Model, this version adds a new import of swing._, which makes Swing’s event abstractions directly available.
The main modifications of class Model concern the nested class Cell.
Class Cell now inherits from Publisher, so that it can publish events.
The event-handling logic is completely contained in the setters of two properties: value and formula.
This assumes that there are no cyclic dependencies between cells.
We discuss dropping this assumption at the end of this chapter.
To the outside, it looks like value and formula are two variables in class Cell.
The value_= setter assigns a new value w to the private field v.
If the new value is different from the old one, it also publishes a ValueChanged event with the cell itself as argument.
Note that the test whether the value has changed is a bit tricky because it involves the value NaN.
The Java spec says that NaN is different from every other value, including itself! Therefore, a test whether two values are the same has to treat NaN specially: two values v, w are the same if they are equal with respect to ==, or they are both the value NaN, i.e., v.isNaN and w.isNaN both yield true.
If a cell is assigned a new formula, it first unsubscribes with deafTo from all cells referenced by the previous formula value.
It then stores the new formula in the private variable f and subscribes with listenTo to all cells referenced by it.
The last piece of code in the revised class Cell specifies how to react to a ValueChanged event:
The final piece missing is the re-display of modified cells.
So far, all value propagation concerned the internal Cell values only; the visible table was not affected.
One way to change this would be to add a redraw command to the value_= setter.
However, this would undermine the strict separation between model and view that you have seen so far.
A more modular solution is to notify the table of all ValueChanged events and let it do the redrawing itself.
Listing 35.9 shows the final spreadsheet component, which implements this scheme.
Class Spreadsheet of Listing 35.9 has only two new revisions.
First, the table component now subscribes with listenTo to all cells in the model.
The spreadsheet developed in this chapter is fully functional, even though at some points it adopts the simplest solution to implement rather than the most convenient one for the user.
That way, it could be written in just under 200 lines of code.
Nevertheless, the architecture of the spreadsheet makes modifications and extensions easy.
In case you would like to experiment with the code a bit further, here are some suggestions of what you could change or add:
You could make the spreadsheet resizable, so that the number of rows and columns can be changed interactively.
You could add new kinds of formulas, for instance binary operations, or other functions.
As alternatives, you could either disallow such a situation, or just compute one iteration each time one of the cells is touched.
You could enhance error handling, giving more detailed messages describing what went wrong.
You could add a formula entry field at the top of the spreadsheet, so that long formulas could be entered more conveniently.
At the beginning of this book we stressed the scalability aspect of Scala.
We claimed that the combination of Scala’s object-oriented and functional constructs makes it suitable for programs ranging from small scripts to very large systems.
The spreadsheet presented here is clearly still a small system, even though it would probably take up much more than 200 lines in most other languages.
Nevertheless, you can see many of the details that make Scala scalable at play in this application.
The spreadsheet uses Scala’s classes and traits with their mixin composition to combine its components in flexible ways.
The need for static state is completely eliminated—the only top-level components that are not classes.
The application also uses higher-order functions and pattern matching extensively, both for accessing formulas and for event handling.
So it is a good showcase of how functional and object-oriented programming can be combined smoothly.
One important reason why the spreadsheet application is so concise is that it can base itself on powerful libraries.
The parser combinator library provides in effect an internal domain-specific language for writing parsers.
Without it, parsing formulas would have been much more difficult.
The event handling in Scala’s Swing libraries is a good example of the power of control abstractions.
If you know Java’s Swing libraries, you probably appreciate the conciseness of Scala’s reactions concept, particularly when compared to the tedium of writing notify methods and implementing listener interfaces in the classical publish/subscribe design pattern.
So the spreadsheet demonstrates the benefits of extensibility, where high-level libraries can be made to look just like language extensions.
If you’re on some flavor of Unix, you can run a Scala script as a shell script by prepending a “pound bang” directive at the top of the file.
For example, type the following into a file named helloarg:
The initial #!/bin/sh must be the very first line in the file.
You can run the Scala script as a shell script by simply saying:
If you’re on Windows, you can achieve the same effect by naming the file helloarg.bat and placing this at the top of your script:
It usually comes with a way to decompose the type through pattern matching.
The concept is found in specification languages and functional programming languages.
Algebraic data types can be emulated in Scala with case classes.
It has the form “case pattern => expression.” Another name for alternative is case.
Annotations are computer processable, so you can use them to effectively add an extension to Scala.
The curly braces contains the body of the anonymous subclass, which may be empty.
However, if the name following new refers to a trait or class that contains abstract members, these must be made concrete inside the curly braces that define the body of the anonymous subclass.
The parameter is the variable that refers to the argument.
In addition, applications can take (command line) arguments that show up in the Array[String] passed to main methods of singleton objects.
When the block evaluates, all of its expressions and declarations are processed in order, and then the block returns the value of the last expression as its own value.
Blocks are commonly used as the bodies of functions, for expressions, while loops, and any other place where you want to group a number of statements together.
More formally, a block is an encapsulation construct for which you can only see side effects and a result value.
The curly braces in which you define a class or object do not, therefore, form a block, because fields and methods (which are defined inside those curly braces) are visible from the outside.
For instance, in the function literal expression (x: Int) => (x, y), both variables x and y are used, but only x is bound, because it is defined in the expression as an Int and the sole argument to the function described by the expression.
The argument corresponding to a by-name parameter is evaluated not before the method is invoked, but each time the parameter is referenced by name inside the method.
The argument corresponding to a by-value parameter is evaluated before the method is invoked.
A class that takes type parameters is called a type constructor.
A type can be said to have a class as well, as in: the class of type Array[String] is Array.
Companion objects and classes have access to each other’s private members.
In addition, any implicit conversions defined in the companion object will be in scope anywhere the class is used.
The class or trait then subtypes contravariantly within the opposite direction as—the type annotated parameter.
The class or trait then subtypes covariantly with—in the same direction as—the type annotated parameter.
For example, List is covariant in its type parameter, so List[String] is a subtype of List[Any]
For instance def f(x: Int)(y: Int) is a curried function with two parameter lists.
A curried function is applied by passing several arguments lists, as in: f(3)(4)
However, it is also possible to write a partial application of a curried function, such as f(3)
You can define classes, traits, singleton objects, fields, methods, local functions, local variables, etc.
Because definitions always involve some kind of implementation, abstract members are declared not defined.
If a class Parent is mentioned in a class Child’s optional extends clause, then Parent is the direct superclass of Child.
If a trait is mentioned in Child’s extends clause, the trait’s direct superclass is the Child’s direct superclass.
If Child has no extends clause, then AnyRef is the direct superclass of Child.
If a class’s direct superclass takes type parameters, for example class Child extends Parent[String], the direct superclass of Child is still Parent, not Parent[String]
On the other hand, Parent[String] would be the direct supertype of Child.
See supertype for more discussion of the distinction between class and type.
You can also say that an expression evaluates to a result or results in a value.
The value to the right of the if is the filter expression.
For instance, in the function literal expression (x: Int) => (x, y), both variables x and y are used, but only y is a free variable, because it is not defined inside the expression.
A function has a parameter list, a body, and a result type.
Functions that are members of a class, trait, or singleton object are called methods.
Functions with the result type of Unit are called procedures.
At run time, function literals are instantiated into objects called function values.
For example, (x: Int, y: Int) => x + y.
A function value is “invoked” when its apply method is called.
A function value that captures free variables is a closure.
The style is characterized by passing function values into looping methods, immutable data, methods with no side effects.
The value to the right of the <- is the generator expression.
For example, because scala.List takes a type parameter, scala.List is a generic class.
The style is characterized by iteration with loops, mutating data in place, and methods with side effects.
It is the dominant paradigm of languages such as C, C++, C# and Java, and contrasts with the functional style.
It can mean a property that always holds true when a data structure is well-formed.
For example, it is an invariant of a sorted binary tree that each node is ordered before its right subnode, if it has a right subnode.
Invariant is also sometimes used as a synonym for nonvariant: “class Array is invariant in its type parameter.”
A literal is a shorthand way to describe an object, where the shorthand exactly mirrors the structure of the created object.
To contrast, a def defined as a member of a class, trait, or singleton object is called a method.
Although similar to local variables, parameters to functions are not referred to as local variables, but simply as parameters or “variables” without the “local.”
A member may be accessed with the name of its owner, a dot, and its simple name.
For example, top-level fields and methods defined in a class are members of that class.
A trait defined inside a class is a member of its enclosing class.
A type defined with the type keyword in a class is a member of that class.
A class is a member of the package in which is it defined.
By contrast, a local variable or local function is not a member of its surrounding block.
Sending a message does not interrupt what the receiver is doing.
The receiver can wait until it has finished its current activity and its invariants have been reestablished.
Meta-programming software is required in order to do anything with an annotation.
In other words, in “trait Hat,” Hat is just a trait, but in “new Cat extends AnyRef with Hat,” Hat can be called a mixin.
When used as a verb, “mix in” is two words.
For example, you can mix traits into classes or other traits.
Mixin composition differs from traditional multiple inheritance in that the type of the super reference is not known at the point the trait is defined, but rather is determined anew each time the trait is mixed into a class or other trait.
For example, the private modifier indicates that a class, trait, field, or method being defined is private.
The class or trait then does not subtype when that parameter changes.
For example, because class Array is nonvariant in its type parameter, Array[String] is neither a subtype nor a supertype of Array[Any]
Methods may be invoked in operator notation, such as b + 2, and when in that notation, + is an operator.
The distinction between parameters and arguments is that arguments refer to the actual objects passed when a function is invoked.
Parameters are the variables that refer to those passed arguments.
This supports the uniform access principle, which enables the def to be changed into a val without requiring a change to client code.
The swiss.cow part is a path that forms a reference to an object.
The meaning of the type is sensitive to the path you use to access it.
The types swiss.cow.Food and fish.Food, for example, are different types.
A case with a pattern guard will only be selected if the pattern matches and the pattern guard yields true.
Fields are initialized only for value parameters not passed to the superclass constructor, except for any that are not used in the body of the class and can therefore by optimized away.
If the only place the function calls itself is the last expression of the function, then the function is tail recursive.
Reference type variables hold references to objects, because reference types (instances of AnyRef) are implemented as Java objects that reside on the JVM’s heap.
Value type variables, by contrast, may sometimes hold a reference (to a boxed wrapper type) and sometimes not (when the object is being represented as a primitive value)
The term “refers” is more abstract than “holds a reference.” If a variable of type scala.Int is currently represented as a primitive Java int value, then that variable still refers to the Int object, but no reference is involved.
Reference equality can be determined, for reference types only, by calling eq in AnyRef.
In Java programs, reference equality can be determined using == on Java reference types.
Instances of reference types always reside on the JVM’s heap at run time.
For a particular input, an invocation of a referentially transparent function can be replaced by its result without changing the program semantics.
Even if that variable is assigned to null, it conceptually refers to the Null object.
At runtime, an object may be implemented by a Java object or a value of a primitive type, but Scala allows programmers to.
The result of every expression in Scala is an object.
You can call this value the result of the function.
You can also say the function results in the value.
The result of every function in Scala is an object.
Runtime encompasses both the virtual machine, as defined by the Java Virtual Machine Specification, and the runtime libraries of the Java API and the standard Scala API.
The phrase at run time (with a space between run and time) means when the program is running, and contrasts with compile time.
To contrast, a static type is the type of an expression at compile time.
Most runtime types are simply bare classes with no type parameters.
A script must end in an expression, not a definition.
It is more structured than a flat binary file or text file, but it does not have the full structure of a programming language’s data structures.
You can later deserialize the byte stream, even on different computer, and obtain an object that is the same as the original serialized object.
A singleton object that shares its name with a class, and is defined in the same source file as that class, is that class’s companion object.
A singleton object that doesn’t have a companion class is a standalone object.
For classes and traits that take no type parameters, the subtype relationship mirrors the subclass relationship.
For example, if class Cat is a subclass of abstract class Animal, and neither takes type parameters, type Cat is a subtype of type Animal.
Likewise, if trait Apple is a subtrait of trait Fruit, and neither takes type parameters, type Apple is a subtype of type Fruit.
For classes and traits that take type parameters, however, variance comes into play.
For example, because abstract class List is declared to be covariant in its lone type parameter (i.e., List is declared List[+A]), List[Cat] is a subtype of List[Animal], and List[Apple] a subtype of List[Fruit]
These subtype relationships exist even though the class of each of these types is List.
By contrast, because Set is not declared to be covariant in its type parameter (i.e., Set is declared Set[A] with no plus sign), Set[Cat] is not a subtype of Set[Animal]
A subtype should correctly implement the contracts of its supertypes, so that the Liskov Substitution Principle applies, but the compiler only verifies this property at the level of type checking.
It defines the type signature, behavior and initial state of the class, trait, or object.
When a trait is being mixed into a class or trait, it is called a mixin.
A trait may be parameterized with one or more types.
For example, Set is a trait that takes a single type parameter, whereas Set[Int] is a type.
Also, Set is said to be “the trait of” type Set[Int]
A type restricts the possible values to which a variable can refer, or an expression can produce, at run time.
A variable or expression’s type can also be referred to as a static type if necessary to differentiate it from an object’s runtime type.
Type is distinct from class because a class that takes type parameters can construct many types.
For example, List is a class, but not a type.
List[Int] and List[String] are also types (called ground types because they have no free type parameters)
A type can have a “class” or “trait.” For example, the class of type List[Int] is List.
Type constraints are not checked by the standard Scala compiler, but must instead be checked by an extra tool or by a compiler plugin.
The type signature of a class, trait, or singleton object comprises its name, the type signatures of all of its members and constructors, and its declared inheritance and mixin relations.
Scala supports this principle by not allowing parentheses to be placed at call sites of parameterless functions.
As a result, a parameterless function definition can be changed to a val, or vice versa, without affecting client code.
Reference types (instances of AnyRef) are implemented as objects that reside on the JVM’s heap.
When an instance of a reference type becomes unreachable, it indeed becomes unreferenced, and is available for garbage collection.
Value type instances can be boxed (converted from a primitive value to a wrapper object) and unboxed (converted from a wrapper object to a primitive value) throughout the lifetime of the variables that refer to them.
If a value type instance currently represented as a wrapper object on the JVM’s heap becomes unreachable, it indeed becomes unreferenced, and is available for garbage collection.
But if a value type currently represented as a primitive value becomes unreachable, then it does not become unreferenced, because it does not exist as an object on the JVM’s heap at that point in time.
The runtime may reclaim memory occupied by unreachable objects, but if an Int, for example, is implemented at run time by a primitive Java int that occupies some memory in the stack frame of an executing method, then the memory for that object is “reclaimed” when the stack frame is popped as the method completes.
Memory for reference types, such as Strings, may be reclaimed by the JVM’s garbage collector after they become unreachable.
The term value essentially means the image of an object in memory (on the JVM’s heap or stack)
This term has meaning at the level of Scala source code.
Over the lifetime of a value type instance, the runtime may transform it back and forth between primitive and wrapper types (i.e., to box and unbox it)
Both vals and vars must be initialized when defined, but only vars can be later reassigned to refer to a different object.
Such variance annotations indicate how subtyping works for a generic class or trait.
For example, the generic class List is covariant in its type parameter, and thus List[String] is a subtype of List[Any]
By default, i.e., absent a + or - annotation, type parameters are nonvariant.
The yield keyword designates the result of a for expression.
He works on programming languages and systems, more specifically on the topic of how to combine object-oriented and functional programming.
Since 2001 he has concentrated on designing, implementing, and refining Scala.
Previously, he has influenced the development of Java as a co-designer of Java generics and as the original author of the current javac reference compiler.
He worked on Scala for two years as a post-doc at EPFL.
In addition to Scala, he has worked on a wide variety of programming languages, ranging from the dynamic language Smalltalk to the scientific language X10 to the logic language that powers LogicBlox.
He and his wife currently live in Atlanta with two cats, a chihuahua, and a turtle.
His popular columns in JavaWorld magazine covered Java internals, object-oriented design, and Jini.
Active in the Jini Community since its inception, Bill led the Jini Community’s ServiceUI project, whose ServiceUI API became the de facto standard way to associate user interfaces to Jini services.
Bill is also the lead developer and designer of ScalaTest, an open source testing tool for Scala and Java developers.
The coauthor of this book, Martin Odersky, founded Scala Solutions to provide the Scala community with a source of quality Scala training, consulting, and development tools.
If you or your colleagues need training or other services then check out the Scala Solutions website.
Scala Solutions and its partners provide regular Scala training courses that are available locally in many countries.
For commercial organizations, Scala Solutions provides a certified source of stable Scala versions, migration utilities and the consulting services they need to take advantage of all the new Scala features as new versions are released or assist you maintaining the stability of deployed applications.
Scala Solutions has unrivalled expertise in the field of professional Scala development and they, like you, enjoy programming in Scala.
Escalate Software provides professional training and consulting services for teams using the Scala programming language.
Co-founded by Bill Venners (coauthor of this book) and Dick Wall, Escalate Software offers custom corporate training in addition to regular openenrollment training courses from novice to expert content.
In addition, Escalate Software can help your business get started and succeed with Scala through its “kickstart” program, which helps you get skills and infrastructure in place for your build, development, and deployment.
For Escalate Software, providing Scala training and consulting services is a lot more than just a job, it is a calling.
In addition to helping you achieve your goals quickly, Escalate Software also aims to enrich, expand, and help sustain the use of Scala and the growth of the Scala community, maintaining strong ties and cooperation with the rest of the community.
For information on Escalate Software’s next public Scala workshops, visit:
Dive deeper into Scala’s actors model with this new book from Artima Press:
Actors in Scala is the authoritative guide to programming with the actors framework of Scala’s standard library, co-written by the creator and lead maintainer, Philipp Haller.
The book provides a comprehensive introduction to the actor model of concurrency and shows how Scala’s actors enable you to build efficient, scalable, and robust concurrent software for the JVM.
Hiring software professionals is difficult, but few books exist on this specific topic.
Agile Hiring presents a fresh approach that is tested by fire: developed by the author in over twenty years of experience hiring software professionals at both small companies and large.
Drawing on principles from the “agile” software movement, this book offers a different way to think about hiring.
This book provides principles and techniques that will help you hire the best software professionals.
First Steps in Scala Learn to use the Scala interpreter Define some variables Define some functions Write some Scala scripts Loop with while; decide with if Iterate with foreach and for Conclusion.
Next Steps in Scala Parameterize arrays with types Use lists Use tuples Use sets and maps Learn to recognize the functional style Read lines from a file Conclusion.
Composition and Inheritance A two-dimensional layout library Abstract classes Defining parameterless methods Extending classes Overriding methods and fields Defining parametric fields Invoking superclass constructors Using override modifiers Polymorphism and dynamic binding Declaring final members Using composition and inheritance Implementing above, beside, and toString Defining a factory object Heighten and widen Putting it all together Conclusion.
Traits How traits work Thin versus rich interfaces Example: Rectangular objects The Ordered trait Traits as stackable modifications Why not multiple inheritance? To trait, or not to trait? Conclusion.
Extractors An example: extracting email addresses Extractors Patterns with zero or one variables Variable argument extractors Extractors and sequence patterns Extractors versus case classes Regular expressions Conclusion.
Object Equality Equality in Scala Writing an equality method Defining equality for parameterized types Recipes for equals and hashCode Conclusion.
Actors and Concurrency Trouble in paradise Actors and message passing Treating native threads as actors Better performance through thread reuse Good actors style A longer example: Parallel discrete event simulation Conclusion.
