This books speaks directly to developers faced with the real and hard.
Venkat introduces (Java) developers to programming Scala in an easyto-follow, pragmatic style.
This book covers Scala from basics to concurrency, one of the most critical and most difficult topics in programming today.
Venkat gets to the meat without any fluff, and I highly.
With his conversational style, this book allows developers to quickly learn the Scala.
Venkat provides a great guide to get you started with this exciting new.
A pleasure to read! A great introduction to Scala for the experienced.
Java developer! This book teaches the “Scala way” of programming.
Concurrency is the next giant challenge we must face as developers, and traditional imperative languages make it too hard.
This book guides Java developers through the important capabilities and nuances of Scala, showing why so much interest is bubbling around this new language.
This is one of the books that I will go back.
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Pragmatic Programmers, LLC was aware of a trademark claim, the designations have.
Every precaution was taken in the preparation of this book.
Our Pragmatic courses, workshops, and other products can help you and your team.
No part of this publication may be reproduced, stored in a retrieval system, or transmitted, in any form, or by any means, electronic, mechanical, photocopying, recording, or.
Introduction There are so many languages that you could use to program the JVM.
In this book I hope to convince you to take the time to learn Scala.
The language and its libraries let you focus on your.
We live in a world where hardware is getting cheaper and more powerful.
Users now have devices with multiple processors, each with multiple cores.
Although Java has served us well so far, it was not designed.
In this introduction, we’ll take a quick tour of the benefits of functional.
When creating a multithreaded application in Scala, you’ll lean toward a functional.
You can retire the synchronized keyword from your vocabularies and enjoy the productivity gains of Scala.
The benefits of Scala, however, are not limited to multithreaded applications.
You can also use it to build powerful, concise, single-threaded.
Scala’s support for functional programming helps you to write concise.
Second, unlike Erlang, Scala runs on the JVM and interoperates.
These two features of Scala make it a prime candidate for use in different layers of enterprise applications.
An object is said to be immutable if you can’t change its contents once you create it.
This eliminates the concerns of managing contention when multiple threads access the.
Java’s String is a great example of an immutable object.
Scala is by far the only prominent strongly typed language that provides.
If you are an experienced Java programmer and are battling with Java.
You can quite easily wrap your Java code into Scala’s actors to.
If you value static typing and like to benefit from the support offered by.
If you are looking for a higher level of abstraction and highly expressive.
The operators and constructs of Scala can be quite intimidating2 to a beginner.
The syntax is not going to be easy for the faint of heart certainly.
You can build full applications entirely in Scala or intermix it to the extent you desire with.
Apache Camel uses Scala for its DSL to create routing rules.
It takes full advantage of Scala features such as conciseness, expressiveness, pattern matching, and concurrency.
Scala, short for Scalable Language, is a hybrid functional programming.
It was created by Martin Odersky3 and was first released in.
It supports both an imperative style and a functional style.
It is highly scalable, and it takes less code to create highperforming applications.
Here is a quick example that highlights many of these features:
The result of this call is then sent back to the actor.
Back in the main thread, we call the (not yet implemented) function.
So, once the previous code is fully implemented, we can.
Let’s now take a look at the function getYearEndClosing( ):
In this short and sweet function, we send a request to http://ichart.
We are left with implementing the getTopStock( ) method, which is the.
Let’s see how we can do that in a functional style:
We wrote the getTopStock( ) method without a single explicit assignment.
We took the number of symbols as a parameter to this method.
Our goal is to find the symbol with the highest.
Using the receiveWithin( ) method, we receive the symbol and price values.
If it is, we use the new symbol and its price as the high for comparison with the next price we will.
Otherwise, we use the previously determined (previousHigh) symbol and high price.
Again, focus on the big picture, and do not worry about.
That was about twenty-five lines of code to concurrently access the Web.
As a result, you should not be concerned with any synchronization and data contention.
If you put all the previous code together and execute, you will get the.
Assume the network delay is d seconds and you are interested in analyzing n symbols.
If you wrote the code to run sequentially, that would.
Since we executed the requests for data concurrently, the previous code takes only about d seconds.
Imagine how you would have implemented the previous example in.
The previous code is distinctive from how you’d implement it in Java in.
We took advantage of a number of powerful Scala features: actors, closures, collections, pattern matching, and tuples, to mention a few.
Since we handled only immutable state, we did not have to spend.
These benefits have removed a huge burden from your shoulders.
Scala provides you with the freedom to choose and mix two styles of.
Scala lets you use the style you’re most comfortable with within the.
You can also use Java classes in Scala and Scala classes in.
Scala is a statically typed language, but, unlike Java, it has sensible.
You don’t work for the compiler; instead, you let the compiler work for.
For example, when we define var i = 1, Scala immediately figures.
Now, if we try to assign a String to that.
Later in this book you will see how type inference works beyond such.
By losing the semicolon, the parentheses, and the dot, your code.
One of the most interesting aspects of Scala is scalability.
Java applications to take full advantage of multithreading on multicore.
The real beauty of Scala is in what it does not have.
C#, and C++, the Scala language has a very small kernel of rules built.
The rest, including operators, are part of the Scala library.
I’ve mentioned that Scala can be used as a functional programming.
Let’s start by contrasting it with the imperative style of Java programming.
We created the mutable variable highTemperature and continually modified it in the loop.
Functional programming is a declarative style in which you say what.
You are seeing an interplay of Scala conciseness and functional programming style in the previous code.
We created the function findMax( ) that accepts, as a parameter, an.
The = symbol between the parentheses and the curly brace told Scala to infer the.
Within the function, we asked the foldLeft( ) method of the collection.
As you know, the max( ) method of the java.lang.Math class takes two.
Those two parameters are being sent implicitly in the previous code.
The first implicit parameter to max( ) is the previous high value, and.
The third person, who is 32, discards the note and creates a new one.
The note we get from the last person will contain the age.
Did the previous code feel like taking a shot of Red Bull? Scala code.
But once you do, you will be able to take advantage.
Let’s take a look at another example of functional style.
Rather than loop through each element to realize that, we simply say we.
We are telling Scala that the variables values and doubleValues can’t be changed once created.
The underscore (_) represents the argument passed to this function.
The function itself is passed as an argument to the map function.
So, although we obtained a list with double the values of elements in.
This immutable approach is a key concept that makes functional programming a desirable style for concurrent programming.
My objective in writing this book is to get you up to speed on Scala.
There is a lot you need to learn to do that, but there is a lot more you.
Lex Spoon, and Bill Venners that does a great job of introducing the.
I have written this book for a busy Java developer, so my objective is.
You will see that the concepts are introduced fairly quickly but with lots of examples.
In each chapter, you’ll learn essential facts that will get you closer to.
I will walk you through installing Scala and getting your first Scala code.
Scala, being a pure object-oriented language, handles classes quite differently than Java.
For instance, it has no static keyword, yet you can.
Function values and closures are central concepts in functional programming and one of the most common features in Scala.
You will learn about the powerful event-based concurrency model and.
Once you figure out how to use concurrency, you’ll want to put it to.
You want to make sure the code you type does what you want.
Finally, in Appendix A, on page 211, you’ll find references to articles.
These assumptions will allow you to quickly get into the essence of Scala and.
Developers who are familiar with other languages can use this book as.
Programmers who are somewhat familiar with Scala can use this book.
I had the privilege of getting help from some really smart minds when.
These highly passionate people with very busy schedules volunteered their time to critique this book, tell me where I fell.
Any errors you find in this book are entirely mine.
Special thanks to Scott Leberknight; he is one of the most thorough.
What can an author of a book on a programming language ask for that’s.
The book you’re reading is well-polished, copyedited, refined, and refactored.
There is one person who braved to read and edit the words as.
Thomas, for taking on this book project and supporting it to completion.
Thank you for providing such an agile environment and the high.
I also thank the readers of this book in the beta.
You guys are a source of inspiration, and I learn.
I concurrently thank Martin Odersky and the Scala community for their.
You will find the current release on the top.1 For.
The examples in this book were tested against version 2.7.4 of Scala.
If you are a bleeding-edge type, a stable version will not satisfy you.
You will need the latest drop of the evolving language implementation.
Scroll down the download page to the “Release Candidate” section, and.
Alternately, if you need the absolutely latest and are willing to.
No matter which version you choose, you’ll also need the JDK 1.4 or.
Explorer and selected “Extract Here.” Move the extracted directory to.
You’ll need to set up the path to the Scala bin.
To do this, go to the Control Panel, and open the “System”
Close any open commandline windows because changes to the environment variables won’t take.
You have a couple of options if you want to install Scala on your Unixlike system.
On Mac OS X, you can use MacPorts to install it using the.
There is one more step: setting up the path to the Scala bin directory.
For Windows versions other than Vista, follow the appropriate steps to change environment variables.
Depending on the shell you use, edit the appropriate profile files.
Close any open terminal windows because changes to the environment variables won’t take.
The quickest way to try Scala is to use the command-line shell scala.
On the command line (in a terminal window or command prompt), type.
You should see an introductory message followed by a prompt:
At the prompt, type val number = 6, and hit Return.
Now try entering number = 7, and Scala will respond with this error:
Technically, we can source our profile file, but opening a new window is less trouble.
Scala tells us that we can’t reassign the constant number.
In the console, however, we can redefine constants and variables.
Redefining constants and variables within the same scope is possible.
You can use the up arrow to bring back commands you typed previously.
It even can bring back commands from a previous invocation of.
While typing a line of command, you can press Ctrl+A to go.
The shell tries to execute what you type as soon as you hit the Return.
If you type something incomplete and press Return, for example.
When you are done with the shell, simply type :quit or exit to exit the.
In addition to using the shell, we can send short statements or.
We used () instead of [ ] to index the args variable—this is a Scala idiom.
If you have Scala code in a file, you can load that into the shell using.
Although the shell and the -e option are convenient ways to experiment.
Alternately, you can tell it to treat the file as a script file or as an object.
We can execute the script with the command scala HelloWorld.scala like.
We can follow the filename with any arguments we want to send to the.
The ability to write Scala code into a file and run it as a script is quite.
You can use this to write code related to system maintenance or administrative tasks, for example, and run them from the.
The scala tool compiles your script into bytecode in memory and executes it.
It rolls the code into the traditional main( ) method of a Main.
So, when you run the script, you’re running the main( ) method.
If you want to view the bytecode generated, use the.
As you begin to use Scala for writing scripts, you will find it easier to.
On Unix-like systems, you can do that by setting a shell preamble.
Make sure the file Script.scala has executable permission by typing.
You can configure Windows to invoke Scala when you run a .scala file.
To do that, within Windows Explorer, simply double-click a Scala script.
Browse to the location where Scala is installed, and select.
Now you can run the program by simply double-clicking it.
As Java developers, you most likely use an IDE to develop applications.
Scala plug-ins for those IDEs (covered in Appendix A, on page 211)
These IDEs allow you to enjoy with Scala the same facilities you’re.
You can use syntax highlighting, code completion, debugging, proper indentation, and so on, to.
To install the Scala plug-in for Eclipse, follow the instructions at http://
Here’s how to write a class and compile it using the scalac compiler.
In the following example, we define an object named Sample.
As an example, on my Vista machine, I set it to C:\programs\scala\
In this chapter, we installed Scala and took it for a short drive.
Scala favors pure object orientation, but it maps types to Java types.
Scala has very high code density—you type less to achieve more.
Scala makes quite a few things in the previous code optional.
You can define a variable using either a val or a var.
The variables defined using val are immutable and can’t be changed after initialization.
Those defined using var, however, are mutable and can be changed any number of times.
The immutability applies to the variable and not the instance to which the variable refers.
For example, if we write val buffer = new StringBuffer(), we can’t change what buffer refers to.
However, we can modify the instance of StringBuffer using methods like append( )
On the other hand, if we define an instance of String using val str = "hello", we can’t modify the instance as well because String itself is immutable.
You can make an instance of a class immutable by defining all of its fields using val and providing only the methods that let you read, and not modify, the state of the instance.
In Scala, you should prefer using val over var as much as possible since that promotes immutability and functional style.
Scala is smart enough to infer that i is an integer.
To run the previous Scala script, type scala Greetings.scala, or run it.
The range that was generated in the previous code included both the.
We’ll discuss more about this charming feature in the sidebar.
In the previous example, it appears that we’ve reassigned i as we iterated through the loop.
However, i is not a var; it is a val.
We can also perform the loop in a more functional style using foreach( ):
Scala allows you to drop both the dot and the parentheses if a method takes either zero or one parameter.
If a method takes more than one parameter, you must use the parentheses, but the dot is still optional.
You can take advantage of this lightweight syntax to create code that reads naturally.
For example, assume we have a turn( ) method defined on a class Car:
We can call the previous method in a lightweight syntax as follows:
Enjoy the optional dot and parentheses to reduce code clutter.
The previous example is concise, and there are no assignments.
So, within the parentheses, we’re providing a body of code that takes one argument, named in this example.
The => separates the parameter list on the left from the implementation on the right.
Java presents a split view of the world—there are objects, and then.
Java doesn’t let you call a method on a primitive like this: 2.toString()
In the following code, we create an instance of Scala’s Int and send it.
In the previous code,2 Scala quietly treated Scala.Int as the primitive.
The result is no performance loss at runtime for type conversions.
Classes like RichInt, RichDouble, RichBoolean, and so on, are called rich.
There is a simpler way to do this in Scala.
A tuple is an immutable object sequence created as comma-separated.
For example, the following represents a tuple with three objects:
We can assign the elements of a tuple into multiple vars or vals in parallel, as shown in this example:
What if you try to assign the result of the method to fewer variables or to.
Instead of assigning the values, you can also access individual elements.
For example, if we execute val info = getPersonInfo(1), then we.
If you need to create a string that runs multiple lines, it is really simple.
Simply place the multiple lines of strings within three double.
Here, we create a string that runs three lines long:
And so, my fellow Americans: ask not what your country can do.
And so, my fellow Americans: ask not what your country can do.
In fact, Scala took the string too literally; we wouldn’t want.
And so, my fellow Americans: ask not what your country can do.
If the pipe symbol appears anywhere else other than the leading.
And so, my fellow Americans: ask not what your country can do.
You will find raw strings very useful when creating regular expressions.
Scala has some defaults that make the code concise and easier to read.
If a script is sufficient for your needs, you can put the executable.
Classes and methods are public by default, so you don’t explicitly.
In addition, by default Scala imports two packages, the scala.Predef.
The inclusion of java.lang allows you to use common Java types in.
You can also use Scala types easily since everything in package scala is.
They become so convenient that you will begin to believe that.
The object Predef also provides aliases to things like scala.collection.
Technically, Scala has no operators, but when I say “operator overloading,” I mean overloading symbols like +, +-, and so on.
In the first statement, we created a class named Complex and defined.
Within the + method, we created a new instance of the Complex class.
The real part and the imaginary part of the result is the sum of the real.
We discussed Scala’s simple and elegant support for operator overloading.
However, the fact that Scala does not have operators is probably.
Since Scala does not have operators, it can’t define precedence.
The first character of methods is used to determine their priority.7 If.
In the following code, we have defined both an add method and a multiply method.
As you start to appreciate Scala’s design elegance and conciseness, you.
The result of the assignment operation (a = b) in Scala is a Unit.
When we attempt to execute the previous code, we’ll get this compilation error:
As much as Scala provides operator overloading, this behavior is at the.
For primitive types, == means value-based comparison, whereas for objects it’s.
So, if a and b are int, then a == b results in.
However, if they’re references to objects, the result is true only if both references are pointing.
Scala’s handling of == is different from Java; however, it is consistent.
This is ensured by implementing ==( ) as a final.
So, if you want to provide your own implementation of equality for your.
If you want to perform the identity-based comparison on references, you can use the eq( )
Scala’s handling of == is consistent for all types and avoids the common.
You can place a semicolon at the end of a statement, particularly if you want to place multiple statements on the same line.
Scala infers a semicolon if your statement does not end with an infix.
It also infers a semicolon at the end of a statement if the next statement.
However, since we did not place a semicolon when we defined list2, Scala assumes we are creating an anonymous inner class that derives from ArrayList[Int]
So, if your intent is to start a new code block after creating.
Should you continue to use semicolons in Scala? In Java you had no choice.
Java defaults to package internal visibility if you don’t specify any.
By default, Scala treats classes, fields, and methods as public if you.
If you want to make a member private or protected, simply.
In the previous code, we have defined the methods start( ) and stop( ) as.
On the other hand, we’ve defined turnTable( ) explicitly as private.
Leave out any access modifier for public fields and methods.
In Scala, protected makes the decorated members visible to the class.
When we compile the previous code, we will get the following errors:
In the previous code, checkEngine( ) of Vehicle is decorated as a protected.
Scala allows us to access that method from within an instance.
However, Scala does not allow us to access that method on an instance.
This behavior is different from how Java treats protected access.
On one hand, Scala is more restrictive than Java in how it treats the.
On the other hand, it gives you a far greater flexibility and also fine-grained control over setting access visibility.
Let’s look at an example of the fine-grained access control:
When we compile the previous code, we will get the following error:
First observe how Scala allows you to define nested packages.
C++ and C# namespaces, Scala allows you to nest a package within.
If you decide to place multiple small classes belonging to a.
In the previous code, we gave visibility for the private field workDetails.
However, we gave visibility for the private field friends to any class within the.
The default visibility of private is class level—from an instance method.
However, Scala also allows you to decorate private and protected with this.
For instance, in the previous example, since secret is decorated private[this], it is accessible only on the.
Similarly, a field annotated with protected[this] is accessible from within an instance method of a derived class but only on the.
In Java you use return to return results from methods.
When Scala sees a return, it bails out of that method.
At the least, it affects Scala’s ability to infer the return type.
In the previous code, we had to explicitly provide the return type for the.
In this chapter, you took a quick drive through Scala from the perspective of Java programmers.
Java and how, at the same time, it sets itself apart.
Classes in Scala In this chapter, you’ll create classes in Scala.
Scala code tends to be more concise than Java code.
Also, even though Scala is a pure object-oriented language, it still has to.
Scala handles these concepts in a fairly interesting way using companion objects.
Actor class that you will use quite frequently when doing concurrent.
Let’s start with a Java example for creating a class that follows the bean.
In the previous code, the class Car has two properties, called year and.
In the Java version, we explicitly defined the field and method for the.
Here is how we would use the previous Scala class:
Scala rolls the primary constructor into the class definition and provides a concise way to define fields and corresponding methods.
We declared number as a val, so Scala defined number as a private final.
Since we declared creditLimit as a var, Scala defined a private field named.
If we don’t declare a parameter as a val or var, then Scala creates a private field and a private getter and setter for it.
Any expression or executable statement you put into the class definition is actually executed as part of the primary constructor.
The default generated getters and setters do not follow the JavaBean conventions.
Later in this section we’ll see how to control that.
In addition to the parameters we have provided in the primary constructor, we can define other fields, methods, and zero or more auxiliary.
In the following code, the this( ) method is our auxiliary.
Our primary constructor2 takes the two parameters firstName and lastName.
From within the auxiliary constructor, we’re calling the primary constructor to initialize the name-related fields.
So, Scala creates a special method position( ) for the getter and position_=( ) for the setter.
In the previous definition of position, you could have set the initial value.
For this you use the Scala syntax for annotation, which is similar.
Extending from a base class in Scala is similar to extending in Java.
Scala insists that you use the keyword override when you override a.
The override annotation was introduced in Java 5 but is still.
In Scala, auxiliary constructors have to call either the primary constructor or another auxiliary constructor.
When we extend the class Vehicle, we pass the parameters to the base.
The parameters we send should match one of the constructors.
Since the properties id and year in Car are derived.
We use singletons to represent objects that act as a central.
You create them using the keyword object instead of class.
Assume we have a class Marker that represents color markers for primary colors.
The MarkerFactory is a singleton that allows us to reuse.
If the argument is not a primary color, it returns a null.
Once you define a singleton, its name represents the single instance of.
The MarkerFactory we just saw is an example of a stand-alone object.
Scala also allows you to create a singleton that is connected to a class.
Such a singleton will share the same name as a class name and is.
In the previous example, we want to regulate the creation of.
Here is some example code that uses the modified class:
The constructor of Marker is marked private; however, the companion.
Marker outside the class or the companion object, we’ll get an error.
Each class may have an optional companion object that you write in the.
We can call it on the Marker companion object like we’d.
The companion object also provides another benefit, the ability to create.
The special apply( ) method, for which Scala provides syntax sugar, does.
You were introduced to Scala’s support of the OO paradigm in this.
You’re now ready to enjoy Scala’s conciseness and pure object.
In the next chapter, we will discuss one of the key features.
Sensible Typing Static typing, or compile-time type checking, helps you define and verify.
You don’t have to specify a type in most cases, and.
Here we defined a variable year explicitly as type Int.
In this chapter, you’ll learn about Scala’s sensible static typing and type.
Scala will provide type inference and type safety for the Java Generics.
As an aside, note that the underscore in the import statement is equivalent to the asterisks in Java.
So when we type java.util._, we are importing all classes in the java.util package.
Scala is vigilant about the type of the object you instantiate.
Scala differs from Java when it comes to handling Generics:
We created a reference, list1, that points to an instance of ArrayList[Int]
Then we created another reference, list2, that points to an instance of.
So, how can you create a new ArrayList without specifying the type? One.
You saw how Scala deals with an assignment when one collection holds objects of type Nothing, while the other.
Scala, by default, insists the collection types on either side.
Parameterized Type, on page 71 how you can alter this default behavior.
Equivalent Java code will compile with no errors but result in a runtime ClassCastException.
Here is an example using a collection of objects of type Any—Any is the.
You saw how Java Generics enjoy enhanced type safety in Scala.
You don’t have to specify the type in order to benefit from Scala type.
You can just rely on the type inference where it makes sense.
Scala insists that a nonparameterized collection be a collection of Nothing and restricts assignment between types.
Scala’s Any type is a superclass of all types in Scala, graphically illustrated in the following diagram.
Any allows you to hold a common reference to objects of any type in.
AnyRef directly maps to the Java Object, so you can pretty much use.
In other words, while AnyRef directly maps to Object, Any.
You can see why you’d need Any, but what is the purpose of Nothing?
Scala’s type inference works hard to determine the type of expressions.
If the type inferred is too broad, it will not help type.
At the same time, how do you infer the type of an expression or function if one branch returns, say, an Int and another branch.
However, an exception may occur at any place, so not.
Since it is a subtype of all types, it is substitutable for anything.
Nothing is abstract, so you would not have a real instance of it anywhere at.
Scala infers the return type of an expression that throws an exception.
When you perform pattern matching, for example, the result of the match may be.
Second, there is no way to force the caller of your function to check for.
Here, commentOnPractice( ) may return a comment (String) or may not.
By making the type explicit as Option[String], Scala forces us to check.
In addition to inferring the types of variables, Scala also tries to infer.
We’ve defined method1( ) like we normally define methods, by providing.
If the method definition or body is small and can be condensed into a.
This can be useful for simple getters and setters that perform minimal.
You can also override the default type inference of Scala by providing.
We can choose any type that the result of the method execution is.
If it is not—for example, if we declare the return type of.
In general, it is better to use the = and let Scala infer the type of methods.
You have one less thing to worry about, and you can let the wellbuilt type inference do the job for you.
If your method takes parameters, you need to specify the parameter.
You can write a method that takes a variable number of arguments.
However, only the trailing parameter can take variable number of arguments.
Scala treats the varargs parameter (values in the previous example) as.
Although we can send discrete arguments, we can’t, however, send an.
If we want to use the values in an array as variable arguments, we can.
You have seen a lot of Scala idioms, but there is one final thing I want.
You saw how Scala prevents you from making assignments that may.
Here is Java code that can get us into trouble:
However, it is easy to bypass this in Java like this:
The ability to send a collection of subclass instances to a collection of.
By default Scala does not allow either one of them.
Although the default behavior of Scala is good in general, there are.
We’ve defined two classes—a Dog that extends a class Pet.
If we send the dogs to the previous method, we will get a compilation.
Scala will complain when we call workWithPets( )—we can’t send an array.
We have to tell Scala that it is OK to let this happen.
We’ve defined the method playWithPets( ) with a special syntax.
If we try to send an array of Objects or an array of objects of some type.
We’ve constrained the destination array’s parameterized type (D) to be a.
In the previous two examples, we controlled the parameters of methods.
Here, +T tells Scala to allow covariance; in other words, during type.
However, this is possible for the functional list List implemented.
Similarly, you can ask Scala to support contravariance on your types.
In this chapter, we discussed the static typing in Scala and its type.
With the understanding of typing, type inference, and how to write methods, you’re all.
Function Values and Closures As the name implies, functions are first-class citizens in functional programming.
Closures are special forms of function values that close over or bound to variables defined in another scope or.
In this chapter, you’ll learn how to use function values and.
How would we find the sum of values in a given range 1 to number in.
What if in addition we now need to count the number of even numbers.
In Scala, we’ll pass an anonymous function to the function that iterates.
So, we can pass different logic to achieve different tasks.
Such functions that can take other functions as parameters are called.
They reduce code duplication, increase reusability, and make your code concise as well.
In Scala, you can create functions within functions, assign them to.
Let’s rewrite our previous example in Scala using function values.
Suppose we want to perform different operations (such as summing numbers or counting the number of even numbers) on a range of values.
We’ll start by first extracting the common code, which is that code for.
The given function is expected to receive an Int, representing an element in the range, and return an Int as a partial result of.
The second argument is actually an anonymous just-in-time function, that is, a function with no name but only an implementation.
Scala was able to infer that the type of the parameter (i) is an Int from.
Instead of finding the sum, if we’d like to count the even numbers in.
If we’d like to count the odd numbers, we can call the method as follows:
Scala allows you to accept any number of parameters as function values, and they can be any parameter, not just the trailing parameter.
It was quite easy to make the code DRY2 using function values.
You can define and use function values with multiple parameters.
It allows us to cascade or accumulate results from operations on each.
The inject( ) method takes three parameters: an array of Int, an initial Int.
In the method we set a variable carryOver to the initial value.
This method accepts a function value as a parameter, which it invokes.
When we’re done calling the operation for each element in the array, we.
Let’s look at a couple of examples of using the previous inject( ) method.
Here’s how we would total the elements in the array:
The first argument to the method inject( ) is an array whose elements.
The second argument is an initial value 0 for the sum.
The third argument is the function that carries out the operation of.
Here’s the output of executing the previous two calls to the inject( )
If you’d like to navigate over elements in a collection and perform operations, you don’t have to really roll out your own inject( ) method—I.
Here is an example of using it to get the sum and max of elements in.
As an observant reader, you probably noticed the function value was.
That looks a lot better than sending those functions as arguments within parentheses.
Currying in Scala transforms a function that takes more than one.
Let’s examine what goes on when you define a method with multiple.
Take a look at the following interactive Scala shell session:
We first defined the function foo( ) we discussed previously.
The creation of partially applied functions when you curry is Scala’s.
From a practical point of view, they help you to pass.
The multiple parameter lists are the only difference between the previous version and the earlier version of the inject( ) method.
So, we don’t have to send the function values as comma-separated.
You saw how function values help create more reusable code and eliminate code duplication.
You can, however, create references to function values and therefore reuse them as.
Assume we have a class Equipment that expects us to provide a calculation routine for its simulation.
When we create instances of Equipment, we can pass in a function value.
In the previous code, we want to use the same calculation code for both.
It would be good to create that once and reuse it.
We stored the function value into a reference named calculator.
In the earlier example, Scala inferred the input as Int.
However, since we’re defining this function value as stand-alone, we had to tell Scala the type of the parameter.
We then passed the name of the reference as an argument to the constructor in the two instances we created.
In the previous example, we created a reference calculator to a function.
This may feel more natural to you since you’re used to defining.
We created our calculation as a function and passed in the name of the.
Scala comfortably treated that as a reference to a function.
You don’t have to compromise on good design principles and code quality when programming in Scala.
On the contrary, it promotes good practices, and you should strive to make use of that when coding in Scala.
Scala provides the notation _, the underscore, to represent parameters.
You can use this if you plan to use that parameter.
In the previous code, we’re using the /: method to compute the sum of.
You may argue that code is terse and you lost readability—the names.
Where it makes sense, you can take this conciseness further.
We want to use that function to determine the maximum among elements of an array.
Let’s start with how we’d simply use that with the.
We are sending the pair of values (large and elem) to the max2( ) method.
The _ represents not only a single parameter; it can represent the entire.
So, we can modify the call to max2( ) as follows:
As you can see, you can adjust the conciseness dial of Scala to the.
While you enjoy the benefit of conciseness, however, you need to make sure your code does not become.
As a Java programmer, you’re familiar with the synchronized block.
That monitor is automatically released when you leave the synchronized block.
Unfortunately, while Java provided that mechanism for synchronized, it did not.
You may try to achieve that using anonymous inner classes, but.
Fortunately, you can implement those constructs in Scala quite easily.
Assume we have a class named Resource that needs to start some transaction automatically and end the transaction deterministically as soon.
We can rely on the constructor to correctly start the transaction.
We can use function values to implement this pattern in Scala.
This forces us to use the object in a certain way, thus guaranteeing automatic and deterministic behavior.
In the companion object, we have a method named use( ) that accepts a.
Resource, and within the safeguard of the try and finally blocks, we send.
That’s all it took to provide a deterministic call to necessary operations.
Now let’s take a look at how we can use the Resource class.
We invoke the use( ) method of the Resource companion object and provide it with a code block.
When we’re done, at the time we leave the code block, the.
The resource-intensive object is considered to be on loan to you, and you’re expected to return it promptly.
Here is an example of how to use this pattern:
Now we can use the function writeToFile( ) to write some content to a file:
When we run the code, the contents of the file output.txt are as follows:
As a user of the method writeToFile( ), we don’t have to worry about closing the file.
The file is on loan to us to use within the code block.
When you invoke a function, you’re said to be applying the function.
If you send only a few arguments, then you get back.
In the previous code, the log( ) method takes two parameters: date and.
We want to invoke the method multiple times, with the same.
In the next code sample, we first bind a value to the date parameter.
We use the _ to leave the second parameter unbound.
We can now invoke this new method with only the unbound.
When you create a partially applied function, Scala internally creates a.
In the examples you’ve seen so far in this chapter, the variables and.
In the previous code, we have defined a code block and assigned it to the.
Here’s how we can use the code block in calls to.
When we pass the closure to the method loopThrough( ), the value is.
The binding did not get a copy of the variable’s current value; it’s actually bound to the variable itself.
Furthermore, when the closure sets result, we see it in the main code.
Here’s the output from the three calls to loopThrough( ):
In this chapter, you explored the concepts related to function values.
You can probably see the benefit of using these code blocks where you want to.
You have learned in this chapter a valuable tool that you will.
Traits and Type Conversions Traits are like interfaces with a partial implementation.
Single implementation inheritance forces you to model everything into a.
In this chapter, you’ll learn Scala’s support for abstraction and object.
This allows you to attach methods to an object without modifying the.
A trait is a behavior that can be mixed into or assimilated into a class.
Assume we’ve modeled a class Human and want to make it friendly.
One disadvantage of the previous code is the friendly quality does not.
Dogs are great friends—they listen to us quietly when we have a lot.
But, how can we make a Dog a friend? We can’t inherit a.
The vals and vars you define and initialize in a.
The actual definition or the implementation of name will be.
The class Human and its derived classes Man and Woman simply use.
You will also use the keyword with to mix in your first.
In addition to mixing in the trait, we have overridden its.
You can call the methods of a trait on the instances of classes that mix.
You can also treat a reference to such classes as a reference of the.
Traits look similar to classes but have some significant differences.
First, they require the mixed-in class to implement the uninitialized.
Traits do not suffer from the method collision problem that generally.
In the previous example, we mixed the trait Friend into the Dog class.
You can also mix in traits selectively at an instance level.
Cat does not mix in the Friend trait, so we can’t treat an instance of Cat.
Any attempts to do so, as you can see here, will result in.
Scala, however, does offer help for cat lovers, and we can exclusively.
Scala gives you the flexibility to treat all the instances of a class as a.
An applicant for an apartment may need to be checked for credit.
Furthermore, if we decide to run additional checks, the class.
Next we’ll introduce an abstract class Check that runs a general check.
For different types of checks like credit, criminal record, and employment, we create traits like these:
We’ve extended these traits from the class Check since we intend to.
We are interested in enhancing or decorating the implementation of the.
So, we have one abstract class and three traits in the example so far.
On the other hand, we could run checks for employment like this:
If you’d rather run a different combination of checks, simply mix in.
The rightmost trait picked up the call to check( )
Traits are a powerful tool in Scala that allow you to mix in crosscutting concerns, and you can use them to create highly extensible code.
In the previous example, the method check( ) of the Check class was.
Any class extending from this class is required to implement the writeMessage( ) method.
If we extend a trait from this abstract class and call.
By using the keyword override, we are telling Scala that.
At the same time, we are saying that the actual final “terminal”
So, here is an example of traits that extend the previous.
We could have mixed in one or more traits in the previous definition of.
Instead, let’s mix in the traits at the time of creating.
Assume we’re creating an application that involves several date and.
The previous looks more like data input rather than code—one of the.
In the second statement, we are calling the method on.
If we try to compile the previous code, Scala will complain that days( )
Implicit type conversion can help you extend the language to create.
Let’s start with some crufty code to first understand the concept and.
We need to define the variables ago and from_now and ask Scala to.
The DateHelper class provides the days( ) method we want.2 Now, all.
Simply mark the method as implicit, and Scala will automatically pick it.
Now that the code works, it’s time to clean it up a bit.
By tucking away the converter into a separate singleton object, we get better.
When we import DateHelper, Scala will automatically find the converter.
This is because Scala applies conversions in the current scope.
Here’s an example of using the implicit conversion we wrote in the DateHelper:
Scala has a number of implicit conversions already defined in the Predef.
Scala applies at most one implicit conversion at a time.
In this chapter, you learned about two interesting scala features, traits.
These two concepts can help you create extensible code with dynamic behavior beyond what’s provided by one single.
In the next chapter, you’ll take a look at Scala’s support for collections of objects.
Using Collections In this chapter, you’ll learn how to create instances of common Scala.
You can still use the collections from the JDK such as ArrayList, Vector, and simple arrays, but.
You can choose between these versions by selecting a class in one of.
In the previous example, we started with a Set of three colors.
Set and Map are traits in the Scala package scala.collection that are refined by corresponding mutable versions.
In the previous example, we created an instance of Set without using a.
This magic is possible because of a special apply( )
Scala automatically calls an apply( ) method on the companion object of.
The apply( ) method is available on Map and List as.
Suppose we’re writing an RSS feed reader and we want to frequently.
If we want to update only select feeds from feeds1, say the ones that are.
Set3 is a class that represents an implementation of a set with three elements.
If we need to merge two Sets of feeds to create a new Set, we can use the.
If we need to compare notes and find what common feeds we have with.
Here’s the effect of the intersect operation on the two previous feeds:
If we want to prefix each feed with the string “http://,” we can use the.
If we’d like to access the elements of a Set using an index, we can.
Finally, when we’re ready to iterate over the feeds and refresh them one.
If we want to get a Map of feeds for folks whose name starts with “D,”
On the other hand, if we want to filter on the values, in addition to or.
If we want to get a feed for a person, simply use the get( ) method.
Option[T], and the result may be either a Some[T] or a None, where T is.
Alternately, we can use the apply( ) method to get the values for a keyremember, this is the method Scala calls when we use parentheses on a.
Unlike get( ), if there’s no value for a given.
If we’d like to add a feed, use the update( ) method.
Instead, it returns a new Map with the added element:
Instead of calling update( ) explicitly, you can take advantage of another.
If you use the parentheses on a class or instance on the left.
We can use the implicit call on immutable collections, like this: val.
Unlike Set and Map, which have mutable and immutable implementations, List comes only in the immutable flavor.
Everything except the first element can be accessed using the tail method.
Accessing the last element of the list requires traversing the list and so.
So, most operations on the list are structured around operations on the head and tail.
Read a :: list as “prefix a to the list.”
This method is an operation on the list, even though the list follows the.
When we invoke feeds(1), we’re using List’s apply( ) method.
Suppose we want to append a list, say listA, to another, say list.
So, the code would be list ::: listA and would read “prefix list to listA.” Since.
Again, the method :::( ) is called on the list that follows the operator.
To append an element to our list, we can use the same :::( ) method.
First we place the element we’d like to append into a list and prefix the.
Notice that to append an element or a list to another list, we actually.
So, the same result is achieved but with better performance.
To select only feeds that satisfy some condition, use the filter( ) method.
If we want to check whether all feeds meet a certain condition, we can.
If, on the other hand, we want to know whether any feed.
Suppose we need to know the number of characters we need to display.
We can use the map( ) method to work on each element.
If we’re interested in the total number of characters of all feeds put.
Notice that although the previous method is performing the summation, it did not deal with any mutable state.
The foldLeft( ) method will invoke the given function value (code block) for.
We can reach out to Scala conventions here and make the code even.
The convention of : may surprise you at first, but as you get used to it.
For example, if we want to prefix a value to a list, we can write.
Although it reads “value is prefixed to the list,” the target.
If a method name ends with a colon (:), then the target of the call is.
It can be quite frustrating for someone new to Scala, but.
The last call in the previous example is equivalent to this code as well:
In addition to operators that end with :, there are a set of operators that.
The unary + maps over to a call to unary_+( ), the.
Here’s an example of defining unary operators on a Sample class:
As you get comfortable with Scala, you’ll develop a Scala eye—soon.
The previous code prints “ho ho ho.” It’s a short form of the general.
The for expression takes as a parameter one or more generators, with.
That was a boatload of details, but don’t worry, because we’ll take a.
The previous code returns a collection of values where each value is a.
We could’ve also performed the previous logic using the map( ) method.
Behind the scenes, Scala translates the for expression into an expression that uses a combination of methods like map( ) and filter( ) depending on the complexity of the expression.
Now suppose we want to double only even numbers in the range.
If you find the semicolons in the previous code too noisy, you can drop.
Here is an example of iterating over a collection of Person and printing.
The previous code is also an example of the Scala syntax sugar where.
If you provide more than one generator in the for expression, each generator forms an inner loop, with the rightmost generator controlling the.
In this chapter, you learned how to use the three major collections.
You also saw the power of the for( ) expression and.
Pattern matching is the second most widely used feature of Scala, after.
You’ll usually pass messages between actors as a String literal, a number, or a tuple.
If your message is a literal, you don’t have to do much to.
Simply type the literal you’d like to match, and you’re done.
Suppose we need to determine activities for different days of the week.
Assume we get the day as a String and we respond with our activity for.
Here is an example of how we can pattern match the days:
The case expression is not limited to use within the match statement.
Here, the block of code containing the case expression(s) is simply a.
In the previous example, we did not handle all possible values of day.
In the previous code, we’ve defined an enumeration for the days of the.
In our activity( ) method, we matched SUNDAY and SATURDAY and.
If we run the code, we’ll get this match of SATURDAY followed by MONDAY.
This matches any tuple with two values in it, plus the literal “done.”
If the argument we send is not a tuple with two elements or does not.
You can match Lists the same way you matched tuples.
In the first and second case, we expected two and three specific items.
You will often want to handle a sequence of values that are not all of the.
You may want to handle a sequence of, say, Ints differently.
You can see how to specify types for single values and elements of a.
You already saw how to define placeholder vals for what you’re matching (like a and b when matching tuples)
Scala expects the pattern variables to start with a lowercase letter and.
You can refer to the offending fields in the case expression with explicit.
In a realistic application, you will soon outgrow matching simple literals, lists, tuples, and objects.
Two options are available for you in Scala: case classes.
Let’s take a look at each of these in turn.
It is convenient to store this information in objects, but how would.
We’ve defined Trade as abstract since we don’t expect instances of it.
Now we can use these in case statements, as shown here:
The stock symbol and quantity we receive are matched and stored in the pattern variables stock.
This will be a problem at runtime if a Hedge is.
However, Scala does not know how many case classes inherit.
After all, we may have extended other case classes in other.
Scala can, however, help if we tell Scala that we have no more.
Now, if we compile the TradeProcessor class, the Scala compiler will yell.
In the following code, we forgot to place parentheses next to Apple in.
When we forgot the parentheses, instead of sending an instance of the.
So, we end up sending in a function instead of an instance of the.
If the acceptStuff( ) method received an instance of a case.
You can take pattern matching to the next level of matching arbitrary.
The process( ) method performs pattern matching using the yet-to-bedefined extractor Symbol.
If it returns true, the expression associated with the case is executed.
The extractor has one method named unapply( ) that accepts the value.
The unapply( ) may strike you as an odd name for a method.
These two methods, apply( ) and unapply( ), perform the opposite actions.
Now that we are able to ask for a stock quote, the next task given to.
Assume that the message for this arrives in the format “SYMBOL:PRICE.” We need to pattern match this format and take action.
We’ve added a new case with a yet-to-be-written extractor ReceiveStockPrice.
This extractor will be different from the Symbol extractor we wrote.
To handle this possibility, the return type of this method should be.
It should reject the request for invalid symbol ERR, even though the.
One is to check whether the symbol is valid within ReceiveStockPrice.
We first apply the ReceiveStockPrice extractor, which returns a pair of.
Now if we rerun the sample calls on this modified service, we’ll get the.
You can pretty much take control of the matching in the.
Although this absolute power is very useful, if you can tailor your pattern into a regular expression, you don’t have to go to those lengths.
When you create a regular expression, you’re working with an instance of the Regex class in that package.
We create a String and call the r( ) method on it.
To find a first match of the regular expression, simply call the findFirstIn( )
In the previous example, this will find the word Scala from the.
If instead of finding only the first occurrence we’d like to find all occurrences of the matching word, we can use the findAllIn( ) method, as.
In the previous code, we’ve concatenated the resulting list of elements.
If we’d like to replace matching text, we can use replaceFirstIn( ) to replace.
For a detailed discussion on regular expressions, refer to Jeffrey E.
The output from executing all three of the previous regular expression.
If you’re already familiar with regular expressions, using them in Scala.
You create a regular expression, and you get an extractor for free.
Scala rolls each match you place within parentheses into a pattern variable.
So, for example, "(S|s)cala".r will hold an unapply( ) method.
Suppose we want to pattern match “GOOG” stocks and get the price.
We created a regular expression to match a string that starts with the.
It will return the value that matches the pattern within the parentheses—price:
In the previous example, our regular expression matches a string that.
The part before the : and the part after it are.
We can match for specific stocks like GOOG and IBM, or we.
As you can see, Scala takes a no-sweat approach to using regular.
In this chapter, you saw one of the most powerful features of Scala.
If you want a bit more control on the matching, you can.
If you want to match arbitrary patterns, Scala extractors are your friend.
Concurrent Programming Scala makes it easy to implement multithreaded applications.
In the functional style of programming, you lean toward immutable.
You can’t modify the state of an immutable object once you.
You create an instance and invoke mutators or modifiers to.
Goetz’s Java Concurrency in Practice [Goe06], have been written on how to conquer.
In the following Java class, the Counter class has a field named count.
That field can be accessed and modified using a getter and setter.
In order to protect against multiple threads accessing the count, we.
Suppose an instance of the Counter is used by multiple threads and.
Even though both the methods of the Counter are synchronized, between the call to getCount( ) and.
Furthermore, we have to check to make sure this is being.
This may seem a bit strange if you’re not used to functional programming.
However, as you get comfortable with the style, you’ll realize you’re not facing the threading-related issues you currently fight.
They are simple and easy to work with since they don’t have a.
For example, in the Flyweight pattern,3 immutable objects are used to share.
Even in pure Java code, Joshua Bloch in Effective Java [Blo01] recommends that we “minimize mutability” and advocates making classes.
It accepts a function value/closure as a parameter and starts running as soon as you create it.
The receive( ) method accepts a closure as well, and typically you’d use pattern matching to process the.
This code computes the sum of factors for a given candidate number.
Let’s exercise the previous code with a few sample numbers,5 as shown.
On my machine, a MacBook Pro with a dual-core processor running.
So, we can split the range of numbers from 1 to candidate into multiple.
So, use caution, and check for overflows in your Scala code.
There is no synchronize or wait in the previous code.
For each partition, we delegated the computation of the partial sum of factors to a.
Finally, we receive the messages from the delegated actors, one.
There wasn’t much of a time difference between the two approaches.
This time the sequential computation took nearly two minutes more.
Next let’s look at how messages get from one actor to another.
The missed calls may be friends inviting our actor to parties as well as.
An actor is not blocked when it sends a message.
From the output you see that the send did not block and the receive.
Sending and receiving messages asynchronously is a good practiceyou can make the most use of concurrency.
A failed actor may lead to failure of other actors and in.
So if you need to use this method, you may want.
The !?( ) method will return the result if the actor sends it a message.
You may wonder what happened to the message that we did not.
We can retrieve that message using a special case class:8 ![a](val ch : Channel[a], val msg : a)
Now that you have a basic understanding of how actors interact, let’s.
In the previous example we used the actor( ) method of the Actor singleton object.
That’s right—Scala’s Actor is simply a trait, and you can mix.
We create a class AnsweringService that mixes in the trait Actor; remember, if you don’t extend any class, you use the keyword extends to mix.
We send a couple of tuple messages to the actor to begin with.
The messages we have sent so far are now processed.
You can stop the actor by calling the exit( ) method.
However, this method simply throws an exception in an attempt to terminate the current.
A variation of this method takes a reason for exiting as a parameter;
The “ping” message we sent before sending the “quit” message was processed.
In the previous example, we controlled when the actor was started.
Here is a method (isPrime( )) that tells us whether a given number is.
For illustrative purposes, I have some added print statements in.
If we call the previous method, we will be blocked until we receive a.
Let’s delegate the responsibility of calling this method to an.
Upon receiving this message, it finds out whether the given number is.
The previous example processes each number as it is received; you can.
So, the execution is sequential even though we delegated it to an actor.
Fear not, we can quite easily make this example concurrent so it can.
If we run the code again with the previous change, you’ll notice that.
You can write concurrent code effortlessly and in a thread-safe manner.
One other observation from the previous output—there is no guarantee.
Actors will process messages as they are received and respond as soon as they’re ready.
The receive( ) method accepts a function value/closure and returns a.
The accumulator receives and totals the numbers sent to it.
If nothing is received within the given timeout period, the receiveWithin( )
In the previous code, we took the receipt of the.
You should prefer using the receiveWithin( ) method to the receive( ) method to avoid the liveness problem.
Oh, one last thing about receive( ) and receiveWithin( )—they’re quite diligent, and they don’t waste any time on messages they don’t care about.
This is because these methods treat the function value as partially.
Of course, if you want to complain about it, you can.
At the end of the previous code, we placed a call to receiveWithin( )
You saw how to avoid the problem of contention by passing immutable.
In each actor, when you called receive( ), you actually asked Report erratum.
You will hold on to that thread until you’re done.
The reason Scala has to hold on to those threads is that there is state.
Unlike its cousin receive( ), the react( ) method does not return any.
In fact, it never returns from the call you make to it.
This may be a bit confusing, but it gets easier if you look at this a bit differently.
If you want to continue processing more messages after you process.
Here, receiveMessage( ) uses the receiveWithin( ) method to process the.
In this case we’re in an active loop and will get.
On the other hand, reactMessage( ) uses the react( )
We’ve created four actors, two that use react( ) and two that use receiveWithin( )
Finally, we send a series of messages to these four actors at.
The actors that use the receiveWithin( ) method have thread affinity; they.
On the other hand, the actors using react( ) are freely swapping their.
However, the second message this actor received was handled by.
In other words, the actors using react( ) don’t have any thread affinity;
If we forget, no more messages will be processed by this.
However, writing that call is not elegant, and we could easily.
It gets only more complicated if we have multiple case.
Similar to receiveWithin( ), reactWithin( ) will time out if any message is not.
The output is not quite what we’d like to see.
So, we decided to add to the local variable sum from.
So, the value of sum in each call to accumulate( ) starts with a zero.
We turned the sum, which was a local variable, into a function parameter.
One final point to remember about react( ) and reactWithin( ) is that since.
So, don’t bother writing anything after a call to either of these.
There are two things that stand in your way to fully use react( ) and.
If you have multiple case statements, and typically you would, you’d.
Instead of calling methods recursively within reactWithin( ), place the.
It would be nice if Scala gave an unreachable error for this.
When the message arrives, an arbitrary thread will pick up the execution of an appropriate case statement.
Since the loopWhile( ) is taking care of the looping, you can.
So, this gives the best of both worlds, dealing with state as provided by receiveWithin( ) and utilizing threads from a pool as reactWithin( )
Let’s take a look at an example of using reactWithin( ) within a loopWhile( ):
In the previous code, we’re not making any recursive calls—that’s taken.
Also, when we want to quit processing messages, simply set the flag, and it takes care of quitting from the loop.
You saw how each actor runs in its own thread when you use receive.
If we do not send any command-line arguments, the code in the two actors and the code in the.
On the other hand, if we run the previous code as scala InMainThread.
Whenever an actor is started, Scala lets the singleton Scheduler run it.
By setting the Scheduler’s impl, you can control the actors’ scheduling.
The previous approach is far-reaching; it allowed us to control the.
By default, this method returns the singleton Scheduler for an.
In the previous code, we’ve created three actors, two by extending the.
Actor trait and one using the more convenient actor( ) method.
We control the thread of MyActor2 by overriding the protected method scheduler( )
When we run the previous code, the actors created using the.
You should prefer the methods ending withWithin over the other methods.
Calling receive( ) or react( ) can lead to a failure.
So, when should you use receiveWithin( ), and when should you use.
Your actor will be blocked until you receive the message and.
On the other hand, if you are implementing a service that receives.
The latter approach is OK if you have one or two case statements in your.
I hope you’ve ended this chapter as impressed with Scala’s facility.
You can build your entire application in Scala or build parts of the.
Intermixing with Java In this chapter, you’ll learn how to use Java classes in Scala and use.
We’ll discuss how Scala idioms manifest on the Java side.
At the end of this chapter, you’ll be equipped with what you need to.
Before we talk about mixing Java and Scala, let’s look at using Scala.
Here’s a script that uses both of the previous classes:
We did not have to compile any of the previous code.
Since that file also contains Dog, that class got resolved as well.
Instead, if we had the Dog class in its own separate file Dog.scala or we.
In the previous example, both the files Person.scala and usePerson.scala.
If the class is in a compiled form in a different directory, use the classpath option instead or in addition to the sourcepath option.
Suppose we want to use the previous Person class in the following Scala.
If the Person class has already been compiled, we can simply compile.
On the other hand, if the Person class is not already compiled, we can.
Specify the sourcepath so the compiler can find the files it needs to compile alongside.
Of course, you can use both the sourcepath and the classpath options—this will allow you to pick up Scala.
You can run the compiled bytecode either using the scala tool or using.
On the other hand, if you want to run it using java tool, simply specify.
You can see here that both of the previous approaches will yield the.
You’ll have to import the class’s package if it’s not part of java.lang.
We can use these classes in our Scala code just like we use any Scala.
Here’s an example of creating an instance of Investment in Scala:
If the bytecode compiled from the previous Java files is located in a.
Once we compile, we can run our code like this:
Alternately, we can also run it using the java tool:
You have to use caution with the yield( ) method of the Investment class.
You can place the offending variables/methods in a backtick to get around the problem.
Scala classes that follow standard Java constructs are pretty straightforward, and you can use them readily on the Java side.
Here’s a sample Java class that uses this Scala class:
We’ll have to compile the Scala code using scalac and the Java code.
In the previous example, we have placed the generated bytecode in the.
That was pretty simple to use the Scala class in Java.
However, not all Scala classes will be that kind to you.
The simulate( ) method in the Equipment class shown here is not usable.
So, when designing your API, if your class will primarily be used from.
Java, provide normal methods in addition to higher-order methods for.
The previous trait has one abstract method that should be implemented.
However, if a trait has method implementations, then Java classes can’t.
If you intend for your Java classes to implement a trait, then make it.
Any common implementation in this case should go into an abstract base class instead of.
However, if you intend for Java classes to use a trait only, then.
Single, shown next, will result in a class named Single$
In addition, it also creates a regular class with methods that.
We can use the previous singleton object in Java as we’d use a Java.
Scala creates two classes, one for the class (Buddy in the following example) that represents the Scala class and the other for the companion.
To access the companion class, use the name of the class directly.
You can extend a Java class from a Scala class, and vice versa.
Java, you’ll run into trouble when you try to throw an exception.
In the previous code, Ostrich’s fly( ) method was able to throw the exception without any problem.
Once we add the throws clause, Java will complain “fly() in Penguin cannot override fly() in Bird; overridden method does not throw NoFlyException.”
Even though Scala is flexible and does not insist that you specify what.
Java, you’ll have to ask the Scala compiler to emit those details in the.
Even though Scala supports annotations, it does not provide any syntax to create an annotation.
So, for us to implement the Penguin in Java, we have to modify Bird like.
Now when we compile the previous class, the Scala compiler will place.
Your Penguin Java class will compile with no errors after this change.
You saw how easy it is to intermix Java and Scala.
Unit Testing with Scala Your code always does what you type—unit testing helps you to assert.
Learning to write unit tests in Scala will benefit you in a number of.
It is a nice way to introduce Scala on your current projects.
It is very hard to unit test code that is.
In order to test it, you’d end up making the.
This will lead to a better design by making the code.
You have three optionsyou can use JUnit, TestNG, or ScalaTest.
Using JUnit to run tests written in Scala is really simple.
That is pure Java syntax without the semicolon at the.
On the other hand, the next addition of “Sugar” illustrates some.
You can enjoy such lightweight syntax when writing your unit tests in.
Finally, we assert that the ArrayList instance has two elements in.
We can compile this code using scalac and run this code like we’d typically run any JUnit test.
Here’s the result of the command to execute the test:
See how simple it is to write a JUnit test in Scala? You benefit further.
JUnit and TestNG are both good starting points for unit testing Scala.
However, as you get more familiar with Scala, you’ll want to take.
When you’re ready for that, you may want to graduate to using ScalaTest.
ScalaTest is a testing framework written in Scala by Bill Venners.
It provides concise syntax for assertions and functional style for.
ScalaTest does not ship with Scala, so first you need to download it from.
Let’s start with a canary test,1 which is a very simple test to make sure.
We extended CanaryTest from the class Suite that’s part of ScalaTest.
Set the classpath accordingly based on the system you are on.
If the test had failed, we would’ve gotten a long.
If you want to execute more than one test suite, you can use the Runner class provided in ScalaTest.2 It allows you to selectively include and.
ScalaTest also provides a SuperSuite that you can extend and use to nest other suites.
However, Runner requires no coding and provides autodiscovery of suites.
We can compile and run it using the following commands:
The -p option specifies the directories where Runner will look for test.
Since we did not specify any particular test suite, it will pick up.
If you are a command-line type (like your humble author), you can use.
Suite Starting - DiscoverySuite: The execute method of a nested suite is.
Suite Starting - ListTest: The execute method of a nested suite is about.
Suite Completed - ListTest: The execute method of a nested suite returned.
Suite Completed - DiscoverySuite: The execute method of a nested suite.
Alternately, you can also use an -f option to redirect to a file.
ScalaTest provides a simple assert( ) method.4 It checks whether the.
A variation of assert( ) checks whether the parameter evaluates to None.
When we run the previous test, we get an error message that includes.
The test indicated a failure, but the message is not very helpful.
When we run the previous test, we will get an error message that.
However, the message lacks context, and it would be nice to have some more details on.
When we run the previous test, we get more meaningful information:
The expect( ) method is fairly concise, is readable, and provides the right.
Exception tests are useful to ensure that the unit of code under test is.
I call this the land-mine method, because it blows up if we step on it.
The previous exception test does its job, but it’s verbose.
ScalaTest is evolving to use a newer style for intercept.
Currently the new style does not take an error message argument.
The intercept( ) method takes the expected exception class as a parameter, an optional error message, and a closure containing the expression.
If the expected exception or its subclass is thrown by the expression, the intercept( ) method.
If you have common code you’d like to share between tests, there are.
You can mix in ScalaTest’s BeforeAndAfter trait into your test suite—this.
Let’s look at an example of using beforeEach( ) and.
That is imperative style—we risk having some fields in our.
One of the tenets of unit testing is that the tests must be isolated from each other.
Alternately, you can completely avoid the fields, and the associated.
The method withList( ) accepts a closure as a parameter—that stuff within the.
Within the withList( ) method, we create an instance of ArrayList and assign.
Within each of the test methods, we call withList( ) and present it with a.
We can create more of these initialization methods like withList( ) and use.
So, we can pick and choose between different initialization and cleanup pairs.
ScalaTest provides a FunSuite that allows you to write your tests in a.
Instead of the traditional test methods, we invoked FunSuite’s test( ) method and provided descriptive messages.
OK, you have now fallen in love with ScalaTest but quickly realize that.
You wonder whether you can take advantage of the concise syntax and.
JUnit3Suite for JUnit (or TestNGSuite for TestNG) allows you to do just.
You simply extend your test suite from JUnit3Suite and write your.
You can run your tests now using either ScalaTest or JUnit.
Here is some sample Scala code to run the previous test using JUnit:
We can compile and run the previous code using ScalaTest or JUnit.
The following example shows you how to compile and run it using both.
Suite Starting - UsingJUnit3Suite: The execute method of a nested suite.
Suite Completed - UsingJUnit3Suite: The execute method of a nested.
In the previous example, you saw how to run the test we wrote with.
When writing unit tests, you’ll often rely on using mock objects to.
You’re now equipped with very important tools and practices in this.
Exception Handling Java’s checked exceptions force you to catch exceptions you don’t care.
Scala supports the Java semantics for exception handling, but it does.
So, if we want to call the Thread’s sleep( ), for.
You can leave out the empty parentheses when you instantiate.
So, Scala did not insist that we write an unnecessary try-catch block.
Of course, you certainly should handle exceptions you can do something about—that’s what catch is for.
The syntax of catch is quite different in Scala; you use pattern matching for handling the exceptions.
The output from the previous code (with a partial stack trace) is shown.
The taxFor( ) method throws three different exceptions depending on the.
The catch block has case statements for handling two of these.
Scala also supports the finally block—just as in Java, it’s executed irrespective of whether the code in the try block threw an exception.
In the previous example, we saw how to catch specific exceptions.
Just as catching checked exceptions is optional in Scala, so too is.
When attempting to handle exceptions, Java watches over the order in.
So, Scala does not warn you if a former statement handles.
The first case matches Exception and all of its subclasses.
In this chapter, you saw how Scala provides a concise and elegant way.
Scala also does not require you to catch exceptions that you don’t care to handle.
Using Scala In this chapter, we’ll bring together a lot of things you’ve learned so far.
We will progressively build an application that will allow us to find the net worth of our investments in the.
You’ll see the benefit of Scala’s conciseness and expressiveness, you’ll learn the power of pattern matching along with function.
We’ll build an application that takes a list of stock ticker symbols along.
We will first develop the application as a console application.
As a first step, we want to know the ticker symbols and units of stock.
The following code helps us read this information into memory:
A sample execution of the previous code is shown here:
In the previous code, we invoked the readLine( ) method of the Scala.
That is, Predef’s printf( ) routes the call to Console’s printf( )
Now that we’ve figured how to get user input in Scala, it’s time to see.
The previous simple code writes the symbol “AAPL” to the file named.
In the previous code, we read the file that contains this code and printed.
As you know, reading a file is not such a simple task.
The Source class is an Iterator over the input stream.
The Source companion object has several convenience methods to read from a file, an.
Very soon we will need to read information off the Web.
So, while discussing Source, let’s take a look at its fromURL( ) method.
In the previous code we called fromURL( ) to obtain a Source instance that.
We want to extract the version number from the content we received.
Although the previous example may quench your thirst to read and.
One approach is to store the ticker symbols and units as plain.
Reading the file is easy, but then parsing through the contents of.
As much as we all hate XML for its verbosity, it does come in.
We created a val named xmlFragment and directly assigned it to some.
Scala parsed the XML content and happily created an instance of scala.xml.Elem for us, as shown in the following output:
The Scala package scala.xml provides classes to help us read XML documents, parse them, create them, and store them.
You probably have played with XPath, which provides a very powerful way to query into an XML document.
Scala provides an XPathlike query ability with one minor difference.
So, let’s see how we can parse this XML fragment on.
We called the \( ) method on the XML element and asked it to look for.
The \( ) method looks only for elements that are direct descendants of.
In the previous example, we use the text( ) method to get the text node.
We can also use pattern matching to get the text value and other contents.
If we want to navigate the structure of an XML document, the.
We saw the power of pattern matching in Chapter 9, Pattern Matching.
We took the first units element and asked Scala to extract the text value.
Furthermore, we want to get the units for all symbols, not just the first.
We can ask Scala to grab all contents (elements and text) using.
The bad news is it reads everything including the text nodes.
Remember, the first parameter you provide for the for( ) method.
Once we get an XML document in memory, we know how to parse it.
As an example, let’s load an XML file that contains symbols and units, increase the.
Here is a sample file stocks.xml that we will load:
The load( ) method of the XML singleton object in the scala.xml package.
You can see from the output shown next that the load( ) returned to.
You already know how to parse the content of this document and store.
In the previous code, as we processed each symbol element, we accumulated the symbol and the corresponding units into a new Map.
The last step is to increase the units value, create an XML representation of the data, and store it into a file.
You know that Scala does not require you to stuff XML elements into a.
But, you may wonder, how do you generate dynamic content into.
When done, we’ll save the content into a file using the save( )
We first created an XML document with symbols as the root element.
The last step is to save the generated document, and we use the save( )
The save( ) method simply saved the XML document without any bells.
If you’d like to add an XML version, add doctypes, and.
The final step to complete our net asset application is to get the stock.
We have the list of ticker symbols and the units in.
The parameters s, a, b, and c represent the ticker symbol, start month.
When you visit the previous URL, you’ll get a comma-separated value.
To get the latest closing price, we have to skip the first header line and.
We multiply the closing price we fetched by the number of units we have, and.
Let’s capture the code that populates a map with the ticker symbols.
As a experienced programmer, you know already how to do that using.
Now we’re all set to fetch the data and compute the results.
In the previous code, we first get the map of ticker symbols and units.
Once we receive the latest closing price, we multiply it with the units.
The sequential implementation of the net asset application looked up.
Let’s refactor the previous code so we can make the requests for the.
Review the previous code to make sure you understand what’s going.
We have put to use the concepts you have learned so far in this.
As you can see from the previous output, the net asset value is the.
Each day you run it, the result will be different.
You’re eager to show off your net asset application to friends, but you.
Scala comes with the scala.swing library that makes it easy to write.
It expects you to implement a top( ) method in which you’d return an instance of the all-toofamiliar Frame.
Go ahead, compile the previous code using scalac SampleGUI.scala, and.
The MainFrame class is part of the Scala swing library and takes.
We then set a title property and created an instance of a Label and a.
The last order of business is to handle the events, in this example, the.
We register the button as a source of an event.
Within the handler, we match the events we’re interested in using the appropriate case.
In this example, that would be the click event on the.
Now let’s focus our attention on putting a GUI on top of the net asset.
When we create multiple actors to query for the prices, remember to.
That’s because the UI components in Swing are not thread safe.
When we finish this example, the GUI will look like the following:
The table displays the ticker symbols, units, price, and total value for.
The Update button will start the action to get the data from.
Part of the code we will write will deal with the GUI components.
Since the price and value is not known initially, this method.
The fetchPrice( ) method accepts a UI updating actor as a parameter, and.
We’ve created a singleton object named NetAssetAPPGUI that extends the.
Let’s now take a look at creating an instance of MainFrame:
We set the desired title value and created the four components we need:
The first argument is the initial data for the table that we obtain from.
Remember, we can’t place multiple components on the main window.
So, we will place these components within a BoxPanel and in turn place.
The BoxPanel boxes up or stacks up the components given to it (especially since the orientation is vertical)
At the bottom we place a FlowPanel that holds the.
The only thing left is to handle the events and.
In the previous code we subscribed to events on the button and added.
In the handler we first disable the Update button and then.
We provide to it a uiUpdater, which is an actor we.
So, we better create that one quickly so we can start updating the UI.
The value uiUpdater refers to an anonymous instance of an Actor.
In the act( ) method, we receive the messages sent.
That last missing piece is the updateTable( ) method, which will.
The previous method simply loops through the table, locates the symbol.
Now as you run the application, you will notice the stock prices and.
The code we’ve created so far follows a happy path.
If you have a network connection and if the service responded on time, everything goes.
For your benefit, I’ve listed the entire code for the UI here again—you.
In this chapter, you saw firsthand the conciseness and expressiveness.
You enjoyed the benefits of pattern matching, XML processing, and functional style.
You also saw the benefit and ease of the concurrency API.
You’re all set to take these benefits to your real-word.
In this blog, Neal Ford discusses canary tests and the advantage of starting out.
In this blog, Martin Fowler discusses the term command query separation.
In this article, Martin Fowler discusses the practice of continuous integration.
Ola Bini makes a case for mixing different languages to build large-scale applications with multiple layers including the domain layer, the dynamic layer, and.
Ivan Tarasov discusses some Scala puzzlers, including a problem with parameterless case classes.
This is the Scala wiki page describing the Loan pattern—a pattern to dispose.
This is a testing framework written in Scala to test Scala and Java code.
This page presents details of IDE plug-ins available for working with Scala.
This is the official website for the Scala programming language.
This is the online version of the Scala Language API.
The Pragmatic Bookshelf Available in paperback and DRM-free PDF, our titles are here to help you stay on top of.
The following are in print as of June 2009; be sure to check our website at.
As development gets more and more difficult, the Pragmatic Programmers.
Read our weblogs, join our online discussions, participate in our mailing list, interact.
Check out the latest pragmatic developments, new titles and other offerings.
Buy the Book If you liked this eBook, perhaps you’d like to have a paper copy of the book.
